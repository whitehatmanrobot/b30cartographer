ightMask;
        lDstDelta     = psoDst->lDelta - cjMiddle - 2;
                                // Delta from the end of the destination
                                //  to the start on the next scan, accounting
                                //  for 'left' and 'right' bytes

        lSrcDelta     = soTmp.lDelta - cBpp * (8 * (cjMiddle + 2));
                                // Compute source delta for special cases
                                //  like when cjMiddle gets bumped up to '0',
                                //  and to correct aligned cases

        do {
            // This is the loop that breaks the source rectangle into
            // manageable batches.

            cyThis  = cyTmpScans;
            cyToGo -= cyThis;
            if (cyToGo < 0)
                cyThis += cyToGo;

            rclTmp.bottom = cyThis;

            ppdev->pfnGetBits(ppdev, &soTmp, &rclTmp, &ptlSrc);

            ptlSrc.y += cyThis;         // Get ready for next batch loop

            _asm {
                mov     eax,ulForeColor     ;eax = foreground colour
                                            ;ebx = temporary storage
                                            ;ecx = count of middle dst bytes
                                            ;dl  = destination byte accumulator
                                            ;dh  = temporary storage
                mov     esi,soTmp.pvScan0   ;esi = source pointer
                mov     edi,pjDst           ;edi = destination pointer

                ; Figure out the appropriate compute routine:

                mov     ebx,cBpp
                mov     pfnCompute,offset Compute_Destination_Byte_From_8bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_16bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_32bpp

            Do_Left_Byte:
                call    pfnCompute
                and     dl,jLeftMask
                mov     dh,jNotLeftMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi
                mov     ecx,cjMiddle
                dec     ecx
                jl      short Do_Right_Byte

            Do_Middle_Bytes:
                call    pfnCompute
                mov     [edi],dl
                inc     edi
                dec     ecx
                jge     short Do_Middle_Bytes

            Do_Right_Byte:
                call    pfnCompute
                and     dl,jRightMask
                mov     dh,jNotRightMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi

                add     edi,lDstDelta
                add     esi,lSrcDelta
                dec     cyThis
                jnz     short Do_Left_Byte

                mov     pjDst,edi               ;save for next batch

                jmp     All_Done

            Compute_Destination_Byte_From_8bpp:
                mov     bl,[esi]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 0

                mov     bl,[esi+1]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 1

                mov     bl,[esi+2]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 2

                mov     bl,[esi+3]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 3

                mov     bl,[esi+4]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 4

                mov     bl,[esi+5]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 5

                mov     bl,[esi+6]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 6

                mov     bl,[esi+7]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 7

                add     esi,8                   ;advance the source
                ret

            Compute_Destination_Byte_From_16bpp:
                mov     bx,[esi]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 0

                mov     bx,[esi+2]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 1

                mov     bx,[esi+4]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 2

                mov     bx,[esi+6]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 3

                mov     bx,[esi+8]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 4

                mov     bx,[esi+10]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 5

                mov     bx,[esi+12]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 6

                mov     bx,[esi+14]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 7

                add     esi,16                  ;advance the source
                ret

            Compute_Destination_Byte_From_32bpp:
                mov     ebx,[esi]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 0

                mov     ebx,[esi+4]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 1

                mov     ebx,[esi+8]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 2

                mov     ebx,[esi+12]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 3

                mov     ebx,[esi+16]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 4

                mov     ebx,[esi+20]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 5

                mov     ebx,[esi+24]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 6

                mov     ebx,[esi+28]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 7

                add     esi,32                  ;advance the source
                ret

            All_Done:
            }
        } while (cyToGo > 0);

        prcl++;
    } while (--c != 0);
}

#endif // i386

/******************************Public*Routine******************************\
* BOOL bPuntBlt
*
* Has GDI do any drawing operations that we don't specifically handle
* in the driver.
*
\**************************************************************************/

BOOL bPuntBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*    ppdev;

    if (psoDst->iType != STYPE_BITMAP)
        ppdev = (PDEV*) psoDst->dhpdev;
    else
        ppdev = (PDEV*) psoSrc->dhpdev;

    #if DBG
    {
        //////////////////////////////////////////////////////////////////////
        // Diagnostics
        //
        // Since calling the engine to do any drawing can be rather painful,
        // particularly when the source is an off-screen DFB (since GDI will
        // have to allocate a DIB and call us to make a temporary copy before
        // it can even start drawing), we'll try to avoid it as much as
        // possible.
        //
        // Here we simply spew out information describing the blt whenever
        // this routine gets called (checked builds only, of course):

        ULONG ulClip;

        ulClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

        DISPDBG((4, ">> Punt << Dst format: %li Dst type: %li Clip: %li Rop: %lx",
            psoDst->iBitmapFormat, psoDst->iType, ulClip, rop4));

        if (psoSrc != NULL)
        {
            DISPDBG((4, "        << Src format: %li Src type: %li",
                psoSrc->iBitmapFormat, psoSrc->iType));

            if (psoSrc->iBitmapFormat == BMF_1BPP)
            {
                DISPDBG((4, "        << Foreground: %lx  Background: %lx",
                    pxlo->pulXlate[1], pxlo->pulXlate[0]));
            }
        }

        if ((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL) && (psoSrc != NULL))
        {
            if (((psoSrc->dhsurf == NULL) &&
                 (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)) ||
                ((psoDst->dhsurf == NULL) &&
                 (psoDst->iBitmapFormat != ppdev->iBitmapFormat)))
            {
                // Don't bother printing the 'xlate' message when the source
                // is a different bitmap format from the destination -- in
                // those cases we know there always has to be a translate.
            }
            else
            {
                DISPDBG((4, "        << With xlate"));
            }
        }

        // If the rop4 requires a pattern, and it's a non-solid brush...

        if (((((rop4 >> 4) ^ (rop4)) & 0x0f0f) != 0) &&
            (pbo->iSolidColor == -1))
        {
            if (pbo->pvRbrush == NULL)
                DISPDBG((4, "        << With brush -- Not created"));
            else
                DISPDBG((4, "        << With brush -- Created Ok"));
        }
    }
    #endif

    if (DIRECT_ACCESS(ppdev))
    {
        //////////////////////////////////////////////////////////////////////
        // Banked Framebuffer bPuntBlt
        //
        // This section of code handles a PuntBlt when GDI can directly draw
        // on the framebuffer, but the drawing has to be done in banks:

        BANK     bnk;
        BOOL     b;
        HSURF    hsurfTmp;
        SURFOBJ* psoTmp;
        SIZEL    sizl;
        POINTL   ptlSrc;
        RECTL    rclTmp;
        RECTL    rclDst;

        if (ppdev->bAutoBanking)
        {
            DSURF*  pdsurfDst;
            DSURF*  pdsurfSrc;
            OH*     pohSrc;
            OH*     pohDst;

            if (psoDst->dhsurf != NULL)
            {
                pdsurfDst       = (DSURF*) psoDst->dhsurf;
                psoDst          = ppdev->psoPunt;
                psoDst->pvScan0 = pdsurfDst->poh->pvScan0;
                psoDst->lDelta  = ppdev->lDelta;

                if (psoSrc != NULL)
                {
                    pdsurfSrc = (DSURF*) psoSrc->dhsurf;
                    if ((pdsurfSrc != NULL) &&
                        (pdsurfSrc != pdsurfDst))
                    {
                        // If we're doing a BitBlt between different off-screen
                        // surfaces, we have to be sure to give GDI different
                        // surfaces, otherwise it may get confused when it has
                        // to do screen-to-screen blts with a translate...

                        pohSrc = pdsurfSrc->poh;
                        pohDst = pdsurfDst->poh;

                        psoSrc          = ppdev->psoPunt2;
                        psoSrc->pvScan0 = pohSrc->pvScan0;
                        psoSrc->lDelta  = ppdev->lDelta;

                        // Undo the source pointer adjustment we did earlier:

                        ptlSrc.x = pptlSrc->x + (pohDst->x - pohSrc->x);
                        ptlSrc.y = pptlSrc->y + (pohDst->y - pohSrc->y);
                        pptlSrc  = &ptlSrc;
                    }
                }
            }
            else
            {
                ppdev           = (PDEV*)  psoSrc->dhpdev;
                pdsurfSrc       = (DSURF*) psoSrc->dhsurf;
                psoSrc          = ppdev->psoPunt;
                psoSrc->pvScan0 = pdsurfSrc->poh->pvScan0;
                psoSrc->lDelta  = ppdev->lDelta;
            }

            ppdev->pfnBankSelectMode(ppdev, BANK_ON);
            return(EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst, pptlSrc,
                             pptlMsk, pbo, pptlBrush, rop4));
        }

        // We copy the original destination rectangle, and use that in every
        // GDI call-back instead of the original because sometimes GDI is
        // sneaky and points 'prclDst' to '&pco->rclBounds'.  Because we
        // modify 'rclBounds', that would affect 'prclDst', which we don't
        // want to happen:

        rclDst = *prclDst;

        if ((psoSrc == NULL) || (psoSrc->iType == STYPE_BITMAP))
        {
            ASSERTDD(psoDst->iType != STYPE_BITMAP,
                     "Dest should be the screen when given a DIB source");

            // Do a memory-to-screen blt:

            vBankStart(ppdev, &rclDst, pco, &bnk);

            b = TRUE;
            do {
                b &= EngBitBlt(bnk.pso, psoSrc, psoMsk, bnk.pco, pxlo,
                               &rclDst, pptlSrc, pptlMsk, pbo, pptlBrush,
                               rop4);
            } while (bBankEnum(&bnk));
        }
        else
        {
            b = FALSE;  // Assume failure

            // The screen is the source (it may be the destination too...)

            ptlSrc.x = pptlSrc->x + ppdev->xOffset;
            ptlSrc.y = pptlSrc->y + ppdev->yOffset;

            if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
            {
                // We have to intersect the destination rectangle with
                // the clip bounds if there is one (consider the case
                // where the app asked to blt a really, really big
                // rectangle from the screen -- prclDst would be really,
                // really big but pco->rclBounds would be the actual
                // area of interest):

                rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
                rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
                rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
                rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);

                // Correspondingly, we have to offset the source point:

                ptlSrc.x += (rclDst.left - prclDst->left);
                ptlSrc.y += (rclDst.top - prclDst->top);
            }

            // We're now either going to do a screen-to-screen or screen-to-DIB
            // blt.  In either case, we're going to create a temporary copy of
            // the source.  (Why do we do this when GDI could do it for us?
            // GDI would create a temporary copy of the DIB for every bank
            // call-back!)

            sizl.cx = rclDst.right  - rclDst.left;
            sizl.cy = rclDst.bottom - rclDst.top;

            // Don't forget to convert from relative to absolute coordinates
            // on the source!  (vBankStart takes care of that for the
            // destination.)

            rclTmp.right  = sizl.cx;
            rclTmp.bottom = sizl.cy;
            rclTmp.left   = 0;
            rclTmp.top    = 0;

            // GDI does guarantee us that the blt extents have already been
            // clipped to the surface boundaries (we don't have to worry
            // here about trying to read where there isn't video memory).
            // Let's just assert to make sure:

            ASSERTDD((ptlSrc.x >= 0) &&
                     (ptlSrc.y >= 0) &&
                     (ptlSrc.x + sizl.cx <= ppdev->cxMemory) &&
                     (ptlSrc.y + sizl.cy <= ppdev->cyMemory),
                     "Source rectangle out of bounds!");

            hsurfTmp = (HSURF) EngCreateBitmap(sizl,
                                               0,    // Let GDI choose ulWidth
                                               ppdev->iBitmapFormat,
                                               0,    // Don't need any options
                                               NULL);// Let GDI allocate

            if (hsurfTmp != 0)
            {
                psoTmp = EngLockSurface(hsurfTmp);

                if (psoTmp != NULL)
                {
                    ppdev->pfnGetBits(ppdev, psoTmp, &rclTmp, &ptlSrc);

                    if (psoDst->iType == STYPE_BITMAP)
                    {
                        // It was a Screen-to-DIB blt; now it's a DIB-to-DIB
                        // blt.  Note that the source point is (0, 0) in our
                        // temporary surface:

                        b = EngBitBlt(psoDst, psoTmp, psoMsk, pco, pxlo,
                                      &rclDst, (POINTL*) &rclTmp, pptlMsk,
                                      pbo, pptlBrush, rop4);
                    }
                    else
                    {
                        // It was a Screen-to-Screen blt; now it's a DIB-to-
                        // screen blt.  Note that the source point is (0, 0)
                        // in our temporary surface:

                        vBankStart(ppdev, &rclDst, pco, &bnk);

                        b = TRUE;
                        do {
                            b &= EngBitBlt(bnk.pso, psoTmp, psoMsk, bnk.pco,
                                           pxlo, &rclDst, (POINTL*) &rclTmp,
                                           pptlMsk, pbo, pptlBrush, rop4);

                        } while (bBankEnum(&bnk));
                    }

                    EngUnlockSurface(psoTmp);
                }

                EngDeleteSurface(hsurfTmp);
            }
        }

        return(b);
    }

#if !defined(_X86_)

    else
    {
        //////////////////////////////////////////////////////////////////////
        // Really Slow bPuntBlt
        //
        // Here we handle a PuntBlt when GDI can't draw directly on the
        // framebuffer (as on the Alpha, which can't do it because of its
        // 32 bit bus).  If you thought the banked version was slow, just
        // look at this one.  Guaranteed, there will be at least one bitmap
        // allocation and extra copy involved; there could be two if it's a
        // screen-to-screen operation.

        POINTL  ptlSrc;
        RECTL   rclDst;
        SIZEL   sizl;
        BOOL    bSrcIsScreen;
        HSURF   hsurfSrc;
        RECTL   rclTmp;
        BOOL    b;
        LONG    lDelta;
        BYTE*   pjBits;
        BYTE*   pjScan0;
        HSURF   hsurfDst;
        RECTL   rclScreen;

        b = FALSE;          // For error cases, assume we'll fail

        rclDst = *prclDst;
        if (pptlSrc != NULL)
            ptlSrc = *pptlSrc;

        if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
        {
            // We have to intersect the destination rectangle with
            // the clip bounds if there is one (consider the case
            // where the app asked to blt a really, really big
            // rectangle from the screen -- prclDst would be really,
            // really big but pco->rclBounds would be the actual
            // area of interest):

            rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
            rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
            rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
            rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);

            ptlSrc.x += (rclDst.left - prclDst->left);
            ptlSrc.y += (rclDst.top  - prclDst->top);
        }

        sizl.cx = rclDst.right  - rclDst.left;
        sizl.cy = rclDst.bottom - rclDst.top;

        // We only need to make a copy from the screen if the source is
        // the screen, and the source is involved in the rop.  Note that
        // we have to check the rop before dereferencing 'psoSrc'
        // (because 'psoSrc' may be NULL if the source isn't involved):

        bSrcIsScreen = (((((rop4 >> 2) ^ (rop4)) & 0x3333) != 0) &&
                        (psoSrc->iType != STYPE_BITMAP));

        if (bSrcIsScreen)
        {
            // We need to create a copy of the source rectangle:

            hsurfSrc = (HSURF) EngCreateBitmap(sizl, 0, ppdev->iBitmapFormat,
                                               0, NULL);
            if (hsurfSrc == 0)
                goto Error_0;

            psoSrc = EngLockSurface(hsurfSrc);
            if (psoSrc == NULL)
                goto Error_1;

            rclTmp.left   = 0;
            rclTmp.top    = 0;
            rclTmp.right  = sizl.cx;
            rclTmp.bottom = sizl.cy;

            // ppdev->pfnGetBits takes absolute coordinates for the source point:

            ptlSrc.x += ppdev->xOffset;
            ptlSrc.y += ppdev->yOffset;

            ppdev->pfnGetBits(ppdev, psoSrc, &rclTmp, &ptlSrc);

            // The source will now come from (0, 0) of our temporary source
            // surface:

            ptlSrc.x = 0;
            ptlSrc.y = 0;
        }

        if (psoDst->iType == STYPE_BITMAP)
        {
            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);
        }
        else
        {
            // We need to create a temporary work buffer.  We have to do
            // some fudging with the offsets so that the upper-left corner
            // of the (relative coordinates) clip object bounds passed to
            // GDI will be transformed to the upper-left corner of our
            // temporary bitmap.

            // The alignment doesn't have to be as tight as this at 16bpp
            // and 32bpp, but it won't hurt:

            lDelta = ppdev->cBpp * (((rclDst.right + 3) & ~3L) -
                             ((rclDst.left) & ~3L));

            // We're actually only allocating a bitmap that is 'sizl.cx' x
            // 'sizl.cy' in size:

            pjBits = EngAllocMem(0, lDelta * sizl.cy, ALLOC_TAG);
            if (pjBits == NULL)
                goto Error_2;

            // We now adjust the surface's 'pvScan0' so that when GDI thinks
            // it's writing to pixel (rclDst.top, rclDst.left), it will
            // actually be writing to the upper-left pixel of our temporary
            // bitmap:

            pjScan0 = pjBits - (rclDst.top * lDelta)
                             - (ppdev->cBpp * (rclDst.left & ~3L));

            ASSERTDD((((ULONG_PTR) pjScan0) & 3) == 0,
                    "pvScan0 must be dword aligned!");

            // The checked build of GDI sometimes checks on blts that
            // prclDst->right <= pso->sizl.cx, so we lie to it about
            // the size of our bitmap:

            sizl.cx = rclDst.right;
            sizl.cy = rclDst.bottom;

            hsurfDst = (HSURF) EngCreateBitmap(
                        sizl,                   // Bitmap covers rectangle
                        lDelta,                 // Use this delta
                        ppdev->iBitmapFormat,   // Same colour depth
                        BMF_TOPDOWN,            // Must have a positive delta
                        pjScan0);               // Where (0, 0) would be

            if ((hsurfDst == 0) ||
                (!EngAssociateSurface(hsurfDst, ppdev->hdevEng, 0)))
                goto Error_3;

            psoDst = EngLockSurface(hsurfDst);
            if (psoDst == NULL)
                goto Error_4;

            // Make sure that the rectangle we Get/Put from/to the screen
            // is in absolute coordinates:

            rclScreen.left   = rclDst.left   + ppdev->xOffset;
            rclScreen.right  = rclDst.right  + ppdev->xOffset;
            rclScreen.top    = rclDst.top    + ppdev->yOffset;
            rclScreen.bottom = rclDst.bottom + ppdev->yOffset;

            // It would be nice to get a copy of the destination rectangle
            // only when the ROP involves the destination (or when the source
            // is an RLE), but we can't do that.  If the brush is truly NULL,
            // GDI will immediately return TRUE from EngBitBlt, without
            // modifying the temporary bitmap -- and we would proceed to
            // copy the uninitialized temporary bitmap back to the screen.

            ppdev->pfnGetBits(ppdev, psoDst, &rclDst, (POINTL*) &rclScreen);

            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);

            ppdev->pfnPutBits(ppdev, psoDst, &rclScreen, (POINTL*) &rclDst);

            EngUnlockSurface(psoDst);

        Error_4:

            EngDeleteSurface(hsurfDst);

        Error_3:

            EngFreeMem(pjBits);
        }

        Error_2:

        if (bSrcIsScreen)
        {
            EngUnlockSurface(psoSrc);

        Error_1:

            EngDeleteSurface(hsurfSrc);
        }

        Error_0:

        return(b);
    }

#endif

}

/******************************Public*Routine******************************\
* BOOL DrvBitBlt
*
* Implements the workhorse routine of a display driver.
*
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*           ppdev;
    DSURF*          pdsurfDst;
    DSURF*          pdsurfSrc;
    POINTL          ptlSrc;
    BYTE            jClip;
    OH*             poh;
    BOOL            bMore;
    CLIPENUM        ce;
    LONG            c;
    RECTL           rcl;
    BYTE            rop3;
    FNFILL*         pfnFill;
    RBRUSH_COLOR    rbc;        // Realized brush or solid colour
    FNXFER*         pfnXfer;
    ULONG           iSrcBitmapFormat;
    ULONG           iDir;
    BOOL            bRet;
    XLATECOLORS     xlc;
    XLATEOBJ        xlo;

    bRet = TRUE;                // Assume success

    pdsurfDst = (DSURF*) psoDst->dhsurf;    // May be NULL

    if (psoSrc == NULL)
    {
        ///////////////////////////////////////////////////////////////////
        // Fills
        ///////////////////////////////////////////////////////////////////

        // Fills are this function's "raison d'etre", so we handle them
        // as quickly as possible:

        ASSERTDD(pdsurfDst != NULL,
                 "Expect only device destinations when no source");

        if (pdsurfDst->dt == DT_SCREEN)
        {
            ppdev = (PDEV*) psoDst->dhpdev;

            poh = pdsurfDst->poh;
            ppdev->xOffset  = poh->x;
            ppdev->yOffset  = poh->y;
            ppdev->xyOffset = poh->xy;

            // Make sure it doesn't involve a mask (i.e., it's really a
            // Rop3):

            rop3 = (BYTE) rop4;

            if ((BYTE) (rop4 >> 8) == rop3)
            {
                // Since 'psoSrc' is NULL, the rop3 had better not indicate
                // that we need a source.

                ASSERTDD((((rop4 >> 2) ^ (rop4)) & 0x33) == 0,
                         "Need source but GDI gave us a NULL 'psoSrc'");

            // Fill_It:

                pfnFill = ppdev->pfnFillSolid;   // Default to solid fill

                if ((((rop3 >> 4) ^ (rop3)) & 0xf) != 0)
                {
                    // The rop says that a pattern is truly required
                    // (blackness, for instance, doesn't need one):

                    rbc.iSolidColor = pbo->iSolidColor;
                    if (rbc.iSolidColor == -1)
                    {
                        if (ppdev->cBpp > 2)
                        {
                            // [HWBUG]
                            goto Punt_It;
                        }

                        // Try and realize the pattern brush; by doing
                        // this call-back, GDI will eventually call us
                        // again through DrvRealizeBrush:

                        rbc.prb = pbo->pvRbrush;
                        if (rbc.prb == NULL)
                        {
                            rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                            if (rbc.prb == NULL)
                            {
                                // If we couldn't realize the brush, punt
                                // the call (it may have been a non 8x8
                                // brush or something, which we can't be
                                // bothered to handle, so let GDI do the
                                // drawing):

                                goto Punt_It;
                            }
                        }
                        pfnFill = ppdev->pfnFillPat;
                    }
                }

                // Note that these 2 'if's are more efficient than
                // a switch statement:

                if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                {
                    pfnFill(ppdev, 1, prclDst, rop4, rbc, pptlBrush);
                    goto All_Done;
                }
                else if (pco->iDComplexity == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                        pfnFill(ppdev, 1, &rcl, rop4, rbc, pptlBrush);
                    goto All_Done;
                }
                else
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    do {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                        c = cIntersect(prclDst, ce.arcl, ce.c);

                        if (c != 0)
                            pfnFill(ppdev, c, ce.arcl, rop4, rbc, pptlBrush);

                    } while (bMore);
                    goto All_Done;
                }
            }
        }
    }

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if ((psoSrc != NULL) && (psoSrc->dhsurf != NULL))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        if (pdsurfSrc->dt == DT_DIB)
        {
            // Here we consider putting a DIB DFB back into off-screen
            // memory.  If there's a translate, it's probably not worth
            // moving since we won't be able to use the hardware to do
            // the blt (a similar argument could be made for weird rops
            // and stuff that we'll only end up having GDI simulate, but
            // those should happen infrequently enough that I don't care).

            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                ppdev = (PDEV*) psoSrc->dhpdev;

                // See 'DrvCopyBits' for some more comments on how this
                // moving-it-back-into-off-screen-memory thing works:

                if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                {
                    if (--pdsurfSrc->cBlt == 0)
                    {
                        if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))
                            goto Continue_It;
                    }
                }
                else
                {
                    // Some space was freed up in off-screen memory,
                    // so reset the counter for this DFB:

                    pdsurfSrc->iUniq = ppdev->iHeapUniq;
                    pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                }
            }

            psoSrc = pdsurfSrc->pso;

            // Handle the case where the source is a DIB DFB and the
            // destination is a regular bitmap:

            if (psoDst->dhsurf == NULL)
                goto EngBitBlt_It;

        }
    }

Continue_It:

    if (pdsurfDst != NULL)
    {
        if (pdsurfDst->dt == DT_DIB)
        {
            psoDst = pdsurfDst->pso;

            // If the destination is a DIB, we can only handle this
            // call if the source is not a DIB:

            if ((psoSrc == NULL) || (psoSrc->dhsurf == NULL))
                goto EngBitBlt_It;
        }
    }

    // At this point, we know that either the source or the destination is
    // not a DIB.  Check for a DFB to screen, DFB to DFB, or screen to DFB
    // case:

    if ((psoSrc != NULL) &&
        (psoDst->dhsurf != NULL) &&
        (psoSrc->dhsurf != NULL))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        pdsurfDst = (DSURF*) psoDst->dhsurf;

        ASSERTDD(pdsurfSrc->dt == DT_SCREEN, "Expected screen source");
        ASSERTDD(pdsurfDst->dt == DT_SCREEN, "Expected screen destination");

        ptlSrc.x = pptlSrc->x - (pdsurfDst->poh->x - pdsurfSrc->poh->x);
        ptlSrc.y = pptlSrc->y - (pdsurfDst->poh->y - pdsurfSrc->poh->y);

        pptlSrc  = &ptlSrc;
    }

    if (psoDst->dhsurf != NULL)
    {
        pdsurfDst = (DSURF*) psoDst->dhsurf;
        ppdev     = (PDEV*)  psoDst->dhpdev;

        ppdev->xOffset  = pdsurfDst->poh->x;
        ppdev->yOffset  = pdsurfDst->poh->y;
        ppdev->xyOffset = pdsurfDst->poh->xy;
    }
    else
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        ppdev     = (PDEV*)  psoSrc->dhpdev;

        ppdev->xOffset  = pdsurfSrc->poh->x;
        ppdev->yOffset  = pdsurfSrc->poh->y;
        ppdev->xyOffset = pdsurfSrc->poh->xy;
    }

    if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
    {
        // Since we've already handled the cases where the ROP4 is really
        // a ROP3 and no source is required, we can assert...

        ASSERTDD((psoSrc != NULL) && (pptlSrc != NULL),
                 "Expected no-source case to already have been handled");

        ///////////////////////////////////////////////////////////////////
        // Bitmap transfers
        ///////////////////////////////////////////////////////////////////

        // Since the foreground and background ROPs are the same, we
        // don't have to worry about no stinking masks (it's a simple
        // Rop3).

        rop3 = (BYTE) rop4;     // Make it into a Rop3 (we keep the rop4
                                //  around in case we decide to punt)

        if (psoDst->dhsurf != NULL)
        {
            // The destination is the screen:

            if ((rop3 >> 4) == (rop3 & 0xf))
            {
                // The ROP3 doesn't require a pattern:

                if (psoSrc->dhsurf == NULL)
                {
                    //////////////////////////////////////////////////
                    // DIB-to-screen blt

                    iSrcBitmapFormat = psoSrc->iBitmapFormat;
                    if (iSrcBitmapFormat == BMF_1BPP)
                    {
                        pfnXfer = ppdev->pfnXfer1bpp;
                        goto Xfer_It;
                    }
                    else if ((iSrcBitmapFormat == ppdev->iBitmapFormat) &&
                             ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
                    {
                        if ((rop3 & 0xf) != 0xc)
                        {
                            pfnXfer = ppdev->pfnXferNative;
                        }
                        else
                        {
                            // Plain SRCCOPY blts will be somewhat faster
                            // if we go through the memory aperture:

                            pfnXfer = vXferNativeSrccopy;
                        }
                        goto Xfer_It;
                    }
                    else if ((iSrcBitmapFormat == BMF_4BPP) &&
                             (ppdev->iBitmapFormat == BMF_8BPP))
                    {
                        // !!!
                        // pfnXfer = ppdev->pfnXfer4bpp;
                        // goto Xfer_It;
                    }
                }
                else // psoSrc->dhsurf != NULL
                {
                    if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
                    {
                        //////////////////////////////////////////////////
                        // Screen-to-screen blt with no translate

                        if (jClip == DC_TRIVIAL)
                        {
                            (ppdev->pfnCopyBlt)(ppdev, 1, prclDst, rop4,
                                                pptlSrc, prclDst);
                            goto All_Done;
                        }
                        else if (jClip == DC_RECT)
                        {
                            if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                            {
                                (ppdev->pfnCopyBlt)(ppdev, 1, &rcl, rop4,
                                                    pptlSrc, prclDst);
                            }
                            goto All_Done;
                        }
                        else
                        {
                            // Don't forget that we'll have to draw the
                            // rectangles in the correct direction:

                            if (pptlSrc->y >= prclDst->top)
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTDOWN;
                                else
                                    iDir = CD_LEFTDOWN;
                            }
                            else
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTUP;
                                else
                                    iDir = CD_LEFTUP;
                            }

                            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                               iDir, 0);

                            do {
                                bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                                      (ULONG*) &ce);

                                c = cIntersect(prclDst, ce.arcl, ce.c);

                                if (c != 0)
                                {
                                    (ppdev->pfnCopyBlt)(ppdev, c, ce.arcl,
                                            rop4, pptlSrc, prclDst);
                                }

                            } while (bMore);
                            goto All_Done;
                        }
                    }
                }
            }
            else if (psoSrc->iBitmapFormat == BMF_1BPP)
            {
                if ( 0 &&   // !!!
                    (rop4 == 0xE2E2) &&
                    (pbo->iSolidColor != 0xffffffff) &&
                    //pxlo must be non NULL since the rop is E2E2
                    (pxlo->pulXlate[0] == 0) &&
                    (pxlo->pulXlate[1] == (ULONG)((1 << (ppdev->cBpp * 8)) - 1)))
                {
                    //
                    // A BitBlt with the rop E2E2 (DSPDxax), a monochrome
                    // source, a foreground color of white, and a background
                    // color of black is equivalent to a monochrome expansion
                    // with transparency.  All ones in the source expand to
                    // the brush color, and all zeros in the source expand to
                    // the destination color.
                    //

                    xlo.pulXlate   = (ULONG*) &xlc;
                    xlc.iForeColor = pbo->iSolidColor;
                    xlc.iBackColor = 0;
                    pxlo = &xlo;
                    rop4 = 0xccaa;

                    pfnXfer = ppdev->pfnXfer1bpp;
                    goto Xfer_It;
                }
            }
        }
        else
        {
            #if defined(_X86_)
            {
                // We special case screen to monochrome blts because they
                // happen fairly often.  We only handle SRCCOPY rops and
                // monochrome destinations (to handle a true 1bpp DIB
                // destination, we would have to do near-colour searches
                // on every colour; as it is, the foreground colour gets
                // mapped to '1', and everything else gets mapped to '0'):

                if ((psoDst->iBitmapFormat == BMF_1BPP) &&
                    (rop3 == 0xcc) &&
                    (pxlo->flXlate & XO_TO_MONO) &&
                    (ppdev->iBitmapFormat != BMF_24BPP))
                {
                    pfnXfer = vXferScreenTo1bpp;
                    psoSrc  = psoDst;               // A misnomer, I admit
                    goto Xfer_It;
                }
            }
            #endif // i386
        }
    }

#if 0
    // [WORK] - Implement transparent brushes and then uncomment this block
    //          and the Fill_It label above.

    else if ((psoMsk == NULL) &&
             (rop4 & 0xff00) == (0xaa00) &&
             ((((rop4 >> 2) ^ (rop4)) & 0x33) == 0))
    {
        // The only time GDI will ask us to do a true rop4 using the brush
        // mask is when the brush is 1bpp, and the background rop is AA
        // (meaning it's a NOP):

        rop3 = (BYTE) rop4;

        goto Fill_It;
    }
#endif

    // Just fall through to Punt_It...

Punt_It:

    bRet = bPuntBlt(psoDst,
                    psoSrc,
                    psoMsk,
                    pco,
                    pxlo,
                    prclDst,
                    pptlSrc,
                    pptlMsk,
                    pbo,
                    pptlBrush,
                    rop4);
    goto All_Done;

//////////////////////////////////////////////////////////////////////
// Common bitmap transfer

Xfer_It:
    if (jClip == DC_TRIVIAL)
    {
        pfnXfer(ppdev, 1, prclDst, rop4, psoSrc, pptlSrc, prclDst, pxlo);
        goto All_Done;
    }
    else if (jClip == DC_RECT)
    {
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            pfnXfer(ppdev, 1, &rcl, rop4, psoSrc, pptlSrc, prclDst, pxlo);
        goto All_Done;
    }
    else
    {
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                           CD_ANY, 0);

        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                  (ULONG*) &ce);

            c = cIntersect(prclDst, ce.arcl, ce.c);

            if (c != 0)
            {
                pfnXfer(ppdev, c, ce.arcl, rop4, psoSrc,
                        pptlSrc, prclDst, pxlo);
            }

        } while (bMore);
        goto All_Done;
    }

////////////////////////////////////////////////////////////////////////
// Common DIB blt

EngBitBlt_It:

    // Our driver doesn't handle any blt's between two DIBs.  Normally
    // a driver doesn't have to worry about this, but we do because
    // we have DFBs that may get moved from off-screen memory to a DIB,
    // where we have GDI do all the drawing.  GDI does DIB drawing at
    // a reasonable speed (unless one of the surfaces is a device-
    // managed surface...)
    //
    // If either the source or destination surface in an EngBitBlt
    // call-back is a device-managed surface (meaning it's not a DIB
    // that GDI can draw with), GDI will automatically allocate memory
    // and call the driver's DrvCopyBits routine to create a DIB copy
    // that it can use.  So this means that this could handle all 'punts',
    // and we could conceivably get rid of bPuntBlt.  But this would have
    // a bad performance impact because of the extra memory allocations
    // and bitmap copies -- you really don't want to do this unless you
    // have to (or your surface was created such that GDI can draw
    // directly onto it) -- I've been burned by this because it's not
    // obvious that the performance impact is so bad.
    //
    // That being said, we only call EngBitBlt when all the surfaces
    // are DIBs:

    bRet = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst,
                     pptlSrc, pptlMsk, pbo, pptlBrush, rop4);

All_Done:
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL DrvCopyBits
*
* Do fast bitmap copies.
*
* Note that GDI will (usually) automatically adjust the blt extents to
* adjust for any rectangular clipping, so we'll rarely see DC_RECT
* clipping in this routine (and as such, we don't bother special casing
* it).
*
* I'm not sure if the performance benefit from this routine is actually
* worth the increase in code size, since SRCCOPY BitBlts are hardly the
* most common drawing operation we'll get.  But what the heck.
*
* It's faster to do straight SRCCOPY bitblt's through the memory
* aperture than to use the data transfer register; as such, this
* routine is the logical place to put this special case.
*
\**************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    PDEV*   ppdev;
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    RECTL   rcl;
    POINTL  ptl;
    OH*     pohSrc;
    OH*     pohDst;

    // DrvCopyBits is a fast-path for SRCCOPY blts.  But it can still be
    // pretty complicated: there can be translates, clipping, RLEs,
    // bitmaps that aren't the same format as the screen, plus
    // screen-to-screen, DIB-to-screen or screen-to-DIB operations,
    // not to mention DFBs (device format bitmaps).
    //
    // Rather than making this routine almost as big as DrvBitBlt, I'll
    // handle here only the speed-critical cases, and punt the rest to
    // our DrvBitBlt routine.
    //
    // We'll try to handle anything that doesn't involve clipping:

    if (((pco  == NULL) || (pco->iDComplexity == DC_TRIVIAL)) &&
        ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        if (psoDst->dhsurf != NULL)
        {
            // We know the destination is either a DFB or the screen:

            ppdev     = (PDEV*)  psoDst->dhpdev;
            pdsurfDst = (DSURF*) psoDst->dhsurf;

            // See if the source is a plain DIB:

            if (psoSrc->dhsurf != NULL)
            {
                pdsurfSrc = (DSURF*) psoSrc->dhsurf;

                // Make sure the destination is really the screen or an
                // off-screen DFB (i.e., not a DFB that we've converted
                // to a DIB):

                if (pdsurfDst->dt == DT_SCREEN)
                {
                    ASSERTDD(psoSrc->dhsurf != NULL, "Can't be a DIB");

                    if (pdsurfSrc->dt == DT_SCREEN)
                    {

                    Screen_To_Screen:

                        //////////////////////////////////////////////////////
                        // Screen-to-screen

                        ASSERTDD((psoSrc->dhsurf != NULL) &&
                                 (pdsurfSrc->dt == DT_SCREEN)    &&
                                 (psoDst->dhsurf != NULL) &&
                                 (pdsurfDst->dt == DT_SCREEN),
                                 "Should be a screen-to-screen case");

                        // pfnCopyBlt takes relative coordinates (relative
                        // to the destination surface, that is), so we have
                        // to change the start point to be relative to the
                        // destination surface too:

                        pohSrc = pdsurfSrc->poh;
                        pohDst = pdsurfDst->poh;

                        ptl.x = pptlSrc->x - (pohDst->x - pohSrc->x);
                        ptl.y = pptlSrc->y - (pohDst->y - pohSrc->y);

                        ppdev->xOffset  = pohDst->x;
                        ppdev->yOffset  = pohDst->y;
                        ppdev->xyOffset = pohDst->xy;

                        (ppdev->pfnCopyBlt)(ppdev, 1, prclDst, 0xcccc, &ptl,
                            prclDst);
                        return(TRUE);
                    }
                    else // (pdsurfSrc->dt != DT_SCREEN)
                    {
                        // Ah ha, the source is a DFB that's really a DIB.

                        ASSERTDD(psoDst->dhsurf != NULL,
                                "Destination can't be a DIB here");

                        /////////////////////////////////////////////////////
                        // Put It Back Into Off-screen?
                        //
                        // We take this opportunity to decide if we want to
                        // put the DIB back into off-screen memory.  This is
                        // a pretty good place to do it because we have to
                        // copy the bits to some portion of the screen,
                        // anyway.  So we would incur only an extra screen-to-
                        // screen blt at this time, much of which will be
                        // over-lapped with the CPU.
                        //
                        // The simple approach we have taken is to move a DIB
                        // back into off-screen memory only if there's already
                        // room -- we won't throw stuff out to make space
                        // (because it's tough to know what ones to throw out,
                        // and it's easy to get into thrashing scenarios).
                        //
                        // Because it takes some time to see if there's room
                        // in off-screen memory, we only check one in
                        // HEAP_COUNT_DOWN times if there's room.  To bias
                        // in favour of bitmaps that are often blt, the
                        // counters are reset every time any space is freed
                        // up in off-screen memory.  We also don't bother
                        // checking if no space has been freed since the
                        // last time we checked for this DIB.

                        if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                        {
                            if (--pdsurfSrc->cBlt == 0)
                            {
                                if (bMoveDibToOffscreenDfbIfRoom(ppdev,
                                                                 pdsurfSrc))
                                    goto Screen_To_Screen;
                            }
                        }
                        else
                        {
                            // Some space was freed up in off-screen memory,
                            // so reset the counter for this DFB:

                            pdsurfSrc->iUniq = ppdev->iHeapUniq;
                            pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                        }

                        // Since the destination is definitely the screen,
                        // we don't have to worry about creating a DIB to
                        // DIB copy case (for which we would have to call
                        // EngCopyBits):

                        psoSrc = pdsurfSrc->pso;

                        goto DIB_To_Screen;
                    }
                }
                else // (pdsurfDst->dt != DT_SCREEN)
                {
                    // Because the source is not a DIB, we don't have to
                    // worry about creating a DIB to DIB case here (although
                    // we'll have to check later to see if the source is
                    // really a DIB that's masquerading as a DFB...)

                    ASSERTDD(psoSrc->dhsurf != NULL,
                             "Source can't be a DIB here");

                    psoDst = pdsurfDst->pso;

                    goto Screen_To_DIB;
                }
            }
            else if (psoSrc->iBitmapFormat == ppdev->iBitmapFormat)
            {
                // Make sure the destination is really the screen:

                if (pdsurfDst->dt == DT_SCREEN)
                {

                DIB_To_Screen:

                    //////////////////////////////////////////////////////
                    // DIB-to-screen

                    ASSERTDD((psoDst->dhsurf != NULL) &&
                             (pdsurfDst->dt == DT_SCREEN)    &&
                             (psoSrc->dhsurf == NULL) &&
                             (psoSrc->iBitmapFormat == ppdev->iBitmapFormat),
                             "Should be a DIB-to-screen case");

                    // ppdev->pfnPutBits takes absolute screen coordinates, so
                    // we have to muck with the destination rectangle:

                    pohDst = pdsurfDst->poh;

                    rcl.left   = prclDst->left   + pohDst->x;
                    rcl.right  = prclDst->right  + pohDst->x;
                    rcl.top    = prclDst->top    + pohDst->y;
                    rcl.bottom = prclDst->bottom + pohDst->y;

                    // We use the memory aperture to do the transfer,
                    // because that is supposed to be faster for SRCCOPY
                    // blts than using the data-transfer register:

                    ppdev->pfnPutBits(ppdev, psoSrc, &rcl, pptlSrc);
                    return(TRUE);
                }
            }
        }
        else // (psoDst->dhsurf == NULL)
        {

        Screen_To_DIB:

            pdsurfSrc = (DSURF*) psoSrc->dhsurf;
            ppdev     = (PDEV*)  psoSrc->dhpdev;

            if (psoDst->iBitmapFormat == ppdev->iBitmapFormat)
            {
                if (pdsurfSrc->dt == DT_SCREEN)
                {
                    //////////////////////////////////////////////////////
                    // Screen-to-DIB

                    ASSERTDD((psoSrc->dhsurf != NULL) &&
                             (pdsurfSrc->dt == DT_SCREEN)    &&
                             (psoDst->dhsurf == NULL) &&
                             (psoDst->iBitmapFormat == ppdev->iBitmapFormat),
                             "Should be a screen-to-DIB case");

                    // ppdev->pfnGetBits takes absolute screen coordinates, so we have
                    // to muck with the source point:

                    pohSrc = pdsurfSrc->poh;

                    ptl.x = pptlSrc->x + pohSrc->x;
                    ptl.y = pptlSrc->y + pohSrc->y;

                    ppdev->pfnGetBits(ppdev, psoDst, prclDst, &ptl);
                    return(TRUE);
                }
                else
                {
                    // The source is a DFB that's really a DIB.  Since we
                    // know that the destination is a DIB, we've got a DIB
                    // to DIB operation, and should call EngCopyBits:

                    psoSrc = pdsurfSrc->pso;
                    goto EngCopyBits_It;
                }
            }
        }
    }

    // We can't call DrvBitBlt if we've accidentally converted both
    // surfaces to DIBs, because it isn't equipped to handle it:

    ASSERTDD((psoSrc->dhsurf != NULL) ||
             (psoDst->dhsurf != NULL),
             "Accidentally converted both surfaces to DIBs");

    /////////////////////////////////////////////////////////////////
    // A DrvCopyBits is after all just a simplified DrvBitBlt:

    return(DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc, NULL,
                     NULL, NULL, 0x0000CCCC));

EngCopyBits_It:

    ASSERTDD((psoDst->dhsurf == NULL) &&
             (psoSrc->dhsurf == NULL),
             "Both surfaces should be DIBs to call EngCopyBits");

    return(EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft products
* is prohibited without the expressed written consent of Microsoft Corp.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-7 and 9-15 of the Windows standard (required)
* 16-color palette, where vertices 0-7 are the vertices of the inner color
* cube, and 0 plus 9-15 are the vertices of the full color cube. Vertex 8 is
* 75% gray; this could be used in the dither, but that would break apps that
* depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Note that as a result of the compatibility requirement, the dither
* produced by this algorithm is the exact same dither as that produced
* by the default Windows 3.1 16 color and 256 color VGA drivers.
*
* Copyright (c) 1992-1994 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDword[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.
BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* vComputeSubspaces
*
* Calculates the subspace data associated with rgb, stores the data at
* pvVertexData, in the form of an array of VERTEX_DATA structures,
* suitable for vDitherColor. Returns a pointer to the byte after the
* last VERTEX_DATA structure.
*
* Ignores the high byte of rgb.
*
\**************************************************************************/

VERTEX_DATA* vComputeSubspaces(
ULONG           rgb,
VERTEX_DATA*    pvVertexData)
{
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulSymmetry;
    ULONG   ulRed, ulGre, ulBlu, ulTemp;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;

    // Split the color into red, green, and blue components
    ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
    ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
    ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

    // Sort the RGB so that the point is transformed into subspace 0, and
    // keep track of the swaps in ulSymmetry so we can unravel it again
    // later.  We want r >= g >= b (subspace 0).
    ulSymmetry = 0;
    if (ulBlueTemp > ulRedTemp) {
        SWAPTHEM(ulBlueTemp,ulRedTemp);
        ulSymmetry = SWAP_RB;
    }

    if (ulBlueTemp > ulGreenTemp) {
        SWAPTHEM(ulBlueTemp,ulGreenTemp);
        ulSymmetry |= SWAP_GB;
    }

    if (ulGreenTemp > ulRedTemp) {
        SWAPTHEM(ulGreenTemp,ulRedTemp);
        ulSymmetry |= SWAP_RG;
    }

    ulSymmetry <<= 4;   // for lookup purposes

    // Scale the values from 0-255 to 0-64. Note that the scaling is not
    // symmetric at the ends; this is done to match Windows 3.1 dithering
    ulRed = (ulRedTemp + 1) >> 2;
    ulGre = (ulGreenTemp + 1) >> 2;
    ulBlu = (ulBlueTemp + 1) >> 2;

    // Compute the subsubspace within subspace 0 in which the point lies,
    // then calculate the # of pixels to dither in the colors that are the
    // four vertexes of the tetrahedron bounding the color we're emulating.
    // Only vertices with more than zero pixels are stored, and the
    // vertices are stored in order of increasing intensity, saving us the
    // need to sort them later
    if ((ulRedTemp + ulGreenTemp) > 256) {
        // Subsubspace 2 or 3
        if ((ulRedTemp + ulBlueTemp) > 256) {
            // Subsubspace 3
            // Calculate the number of pixels per vertex, still in
            // subsubspace 3, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 3 is:
            // 7, 9, 0x0B, 0x0F
            if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            ulVertex2Temp = ulGre - ulBlu;
            ulVertex3Temp = (ulRed - 64) + ulBlu;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
            }
        } else {
            // Subsubspace 2
            // Calculate the number of pixels per vertex, still in
            // subsubspace 2, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 2 is:
            // 3, 7, 9, 0x0B
            ulVertex1Temp = ulBlu << 1;
            ulVertex2Temp = ulRed - ulGre;
            ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
            if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex1Temp != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
        }
    } else {
        // Subsubspace 0 or 1
        if (ulRedTemp > 128) {
            // Subsubspace 1
            // Calculate the number of pixels per vertex, still in
            // subsubspace 1, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 1 is:
            // 1, 3, 7, 9
            if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex2Temp = ulBlu << 1;
            ulVertex3Temp = (ulRed - 32) << 1;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
        } else {
            // Subsubspace 0
            // Calculate the number of pixels per vertex, still in
            // subsubspace 0, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 0 is:
            // 0, 1, 3, 7
            if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
            }
            if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex3Temp = ulBlu << 1;
            if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex1Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
        }
    }

    return(pvVertexData);
}

/******************************Public*Routine******************************\
* vDitherColor
*
* Dithers the ulNumVertices vertices described by vVertexData into pulDest.
*
\**************************************************************************/

VOID vDitherColor(
ULONG*          pulDest,
VERTEX_DATA*    vVertexData,
VERTEX_DATA*    pvVertexDataEnd,
ULONG           ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulDitherOrder;
    BYTE    jColor;
    BYTE   *pjDither = (BYTE *)pulDest;

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleToDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDitherOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) ajConvert[pvVertexData->ulVertex];
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        pjDither[*(pulDitherOrder+2)] = jColor;
                    case 2:
                        pjDither[*(pulDitherOrder+1)] = jColor;
                    case 1:
                        pjDither[*(pulDitherOrder+0)] = jColor;
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        pjDither[*pulDitherOrder] = jColor;
                        pjDither[*(pulDitherOrder+1)] = jColor;
                        pjDither[*(pulDitherOrder+2)] = jColor;
                        pjDither[*(pulDitherOrder+3)] = jColor;
                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);

    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) ajConvert[vVertexData[1].ulVertex];
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleToDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) ajConvert[vVertexData[0].ulVertex];
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder;
        }

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                pjDither[*(pulDitherOrder+2)] = jColor;
            case 2:
                pjDither[*(pulDitherOrder+1)] = jColor;
            case 1:
                pjDither[*(pulDitherOrder+0)] = jColor;
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {
                pjDither[*pulDitherOrder] = jColor;
                pjDither[*(pulDitherOrder+1)] = jColor;
                pjDither[*(pulDitherOrder+2)] = jColor;
                pjDither[*(pulDitherOrder+3)] = jColor;
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;
    }
}

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA
* colours.
*
\**************************************************************************/

ULONG DrvDitherColor(
DHPDEV  dhpdev,
ULONG   iMode,
ULONG   rgb,
ULONG*  pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;

    // Figure out if we need a full color dither or only a monochrome dither.

    // Note: we'll get colour dithers only at 8bpp, because that's the
    //       only colour depth at which we set GCAPS_COLOR_DITHER.

    if (iMode != DM_MONOCHROME)
    {
        // Full color dither

        // Calculate what color subspaces are involved in the dither
        pvVertexData = vComputeSubspaces(rgb, vVertexData);

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = (ULONG)(pvVertexData - vVertexData); // # of vertices with more than
                                                //  zero pixels in the dither

        vDitherColor(pul, vVertexData, pvVertexData, ulTemp);
    }
    else
    {
        // Note: we can get monochrome dithers at any colour depth because
        //       we always set GCAPS_MONO_DITHER.

        // For monochrome we will only use the Intensity (grey level)

        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convenience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\videosim\videosim.h ===
/*++

Copyright (c) 1992-1994  Microsoft Corporation

Module Name:

    videosim.h

Abstract:

    definitions for the simulation driver.

Environment:

    Kernel mode

Revision History:

--*/

//
// Define device extension structure. This is device dependant/private
// information.
//

typedef struct _HW_DEVICE_EXTENSION {
    PVOID VideoRamBase;
    ULONG VideoRamLength;
    ULONG CurrentModeNumber;
    PVOID SectionPointer;
    PMDL  Mdl;
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


#define ONE_MEG 0x100000

extern VIDEO_MODE_INFORMATION SimModes[];
extern ULONG SimNumModes;

extern ULONG bLoaded;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\videosim\videosim.c ===
/*++

Copyright (c) 1992-1998  Microsoft Corporation

Module Name:

    videosim.c

Abstract:

    Minport to simulate a frame buffer miniport driver.
    video driver.

Environment:

    Kernel mode

Revision History:

--*/

#define _NTDRIVER_

#ifndef FAR
#define FAR
#endif

#include "dderror.h"
#include "ntosp.h"
#include "stdarg.h"
#include "stdio.h"
#include "zwapi.h"

#include "ntddvdeo.h"
#include "video.h"
#include "videosim.h"

//
// Function Prototypes
//
// Functions that start with 'Sim' are entry points for the OS port driver.
//

ULONG
DriverEntry(
    PVOID Context1,
    PVOID Context2
    );

VP_STATUS
SimFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
SimInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
SimStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );


#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,SimFindAdapter)
#pragma alloc_text(PAGE,SimInitialize)
#pragma alloc_text(PAGE,SimStartIO)
#endif


ULONG
DriverEntry (
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    Context1 - First context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

    Context2 - Second context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

--*/

{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG status;
    ULONG initializationStatus;

    //
    // Zero out structure.
    //

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    //
    // Specify sizes of structure and extension.
    //

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitData.HwFindAdapter = SimFindAdapter;
    hwInitData.HwInitialize = SimInitialize;
    hwInitData.HwInterrupt = NULL;
    hwInitData.HwStartIO = SimStartIO;

    //
    // Determine the size we require for the device extension.
    //

    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //
    // Always start with parameters for device0 in this case.
    //

//    hwInitData.StartingDeviceNumber = 0;

    //
    // Once all the relevant information has been stored, call the video
    // port driver to do the initialization.
    // For this device we will repeat this call three times, for ISA, EISA
    // and MCA.
    // We will return the minimum of all return values.
    //

    hwInitData.AdapterInterfaceType = PCIBus;

    return (VideoPortInitialize(Context1,
                                Context2,
                                &hwInitData,
                                NULL));

} // end DriverEntry()

VP_STATUS
SimFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

/*++

Routine Description:

    This routine is called to determine if the adapter for this driver
    is present in the system.
    If it is present, the function fills out some information describing
    the adapter.

Arguments:

    HwDeviceExtension - Supplies the miniport driver's adapter storage. This
        storage is initialized to zero before this call.

    HwContext - Supplies the context value which was passed to
        VideoPortInitialize().

    ArgumentString - Suuplies a NULL terminated ASCII string. This string
        originates from the user.

    ConfigInfo - Returns the configuration information structure which is
        filled by the miniport driver. This structure is initialized with
        any knwon configuration information (such as SystemIoBusNumber) by
        the port driver. Where possible, drivers should have one set of
        defaults which do not require any supplied configuration information.

    Again - Indicates if the miniport driver wants the port driver to call
        its VIDEO_HW_FIND_ADAPTER function again with a new device extension
        and the same config info. This is used by the miniport drivers which
        can search for several adapters on a bus.

Return Value:

    This routine must return:

    NO_ERROR - Indicates a host adapter was found and the
        configuration information was successfully determined.

    ERROR_INVALID_PARAMETER - Indicates an adapter was found but there was an
        error obtaining the configuration information. If possible an error
        should be logged.

    ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
        supplied configuration information.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    NTSTATUS Status;
    HANDLE SectionHandle;
    ACCESS_MASK SectionAccess;
    ULONGLONG SectionSize = 0x100000;

    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Only create a device once.
    //

    if (bLoaded++)
    {
        return ERROR_DEV_NOT_EXIST;
    }

#if 0
    //
    // Create the frame buffer
    //

    SectionAccess = SECTION_ALL_ACCESS;

    Status = ZwCreateSection(&SectionHandle,
                             SectionAccess,
                             (POBJECT_ATTRIBUTES) NULL,
                             (PLARGE_INTEGER) &SectionSize,
                             PAGE_READWRITE,
                             SEC_COMMIT,
                             NULL);

    if (!NT_SUCCESS(Status))
    {
         return ERROR_DEV_NOT_EXIST;
    }

    //
    // Now reference the section handle.
    //

    Status = ObReferenceObjectByHandle(SectionHandle,
                                       SECTION_ALL_ACCESS,
                                       NULL,
                                       KernelMode,
                                       &(hwDeviceExtension->SectionPointer),
                                       (POBJECT_HANDLE_INFORMATION) NULL );


    ZwClose(SectionHandle);

    if (!NT_SUCCESS(Status))
    {
         return ERROR_DEV_NOT_EXIST;
    }
#endif

    //
    // Clear out the Emulator entries and the state size since this driver
    // does not support them.
    //

    ConfigInfo->NumEmulatorAccessEntries = 0;
    ConfigInfo->EmulatorAccessEntries = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    ConfigInfo->HardwareStateSize = 0;

    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength = 0x00000000;

    //
    // Initialize the current mode number.
    //

    hwDeviceExtension->CurrentModeNumber = 0;

    //
    // Indicate we do not wish to be called over
    //

    *Again = 0;

    //
    // Indicate a successful completion status.
    //

    return NO_ERROR;

} // end SimFindAdapter()


BOOLEAN
SimInitialize(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:


    Always returns TRUE since this routine can never fail.

--*/

{
    ULONG i;

    //
    // Walk through the list of modes and mark the indexes properly
    //

    for (i = 0; i < SimNumModes; i++) {

        SimModes[i].ModeIndex = i;

    }

    return TRUE;

} // end SimInitialize()


BOOLEAN
SimStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    acceptss a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    RequestPacket - Pointer to the video request packet. This structure
    contains all the parameters passed to the VideoIoControl function.

Return Value:


--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;
    PVIDEO_MODE_INFORMATION modeInformation;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    PVIDEO_SHARE_MEMORY pShareMemory;
    PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
    ULONG ulTemp;
    NTSTATUS ntStatus;
    ULONG ViewSize;
    PVOID ViewBase;
    LARGE_INTEGER ViewOffset;
    HANDLE sectionHandle;

    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //

    switch (RequestPacket->IoControlCode) {


    case IOCTL_VIDEO_MAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "SimStartIO - MapVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength <
                                     sizeof(VIDEO_MEMORY_INFORMATION)) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

            RequestPacket->StatusBlock->Information = 0;
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        if (hwDeviceExtension->VideoRamBase == 0)
        {
            //
            // Allocate this once, and hang on to forever after, reusing it
            // through successive launches of NetMeeting.
            //
            hwDeviceExtension->VideoRamBase = ExAllocatePoolWithTag(
                NonPagedPool, ONE_MEG, 'ddmN');
        }

        if (hwDeviceExtension->VideoRamBase == 0)
        {
             status = ERROR_INVALID_PARAMETER;
             break;
        }

        RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MEMORY_INFORMATION);

        memoryInformation = RequestPacket->OutputBuffer;

#if 0
        status = ERROR_INVALID_PARAMETER;

        ViewSize = 0x100000;
        ViewBase = NULL;
        ViewOffset.QuadPart = 0;

        if (NT_SUCCESS(ObOpenObjectByPointer(hwDeviceExtension->SectionPointer,
                                             0L,
                                             (PACCESS_STATE) NULL,
                                             SECTION_ALL_ACCESS,
                                             (POBJECT_TYPE) NULL,
                                             KernelMode,
                                             &sectionHandle)))
        {
            if (NT_SUCCESS(ZwMapViewOfSection(sectionHandle,
                                              NtCurrentProcess(),
                                              &ViewBase,
                                              0,
                                              ViewSize,
                                              &ViewOffset,
                                              &ViewSize,
                                              ViewUnmap,
                                              0,
                                              PAGE_READWRITE)))
            {
            }

            ZwClose(sectionHandle);
        }
#endif

        memoryInformation->VideoRamBase =
        memoryInformation->FrameBufferBase = hwDeviceExtension->VideoRamBase;

        memoryInformation->VideoRamLength =
        memoryInformation->FrameBufferLength = ONE_MEG;

        VideoDebugPrint((1, "VideoSim: RamBase = %08lx, RamLength = %08lx\n",
                         hwDeviceExtension->VideoRamBase,
                         hwDeviceExtension->VideoRamLength));

        status = NO_ERROR;

        break;


    case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

        VideoDebugPrint((1, "SimStartIO - UnMapVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
        }

        //
        // We have a problem if the MDL is still around when this memory is
        // freed.  On the next MAP call, we'll allocate a new block of
        // memory.  But when SHARE is called, to get a user mode pointer
        // referring to it, that will use the old MDL, referring to the OLD
        // VideoRamBase block.
        //
        // ASSERT(!hwDeviceExtension->Mdl);

        if (hwDeviceExtension->VideoRamBase)
        {
            ExFreePool(hwDeviceExtension->VideoRamBase);
            hwDeviceExtension->VideoRamBase = 0;
        }

        status = NO_ERROR;

        break;


    case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:

        VideoDebugPrint((1, "SimStartIO - ShareVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength <
                                   sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
        {

            VideoDebugPrint((1,
              "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        pShareMemory = RequestPacket->InputBuffer;

        RequestPacket->StatusBlock->Information =
                                    sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

        //
        // Beware: the input buffer and the output buffer are the same
        // buffer, and therefore data should not be copied from one to the
        // other
        //

        status = ERROR_INVALID_PARAMETER;

        if (hwDeviceExtension->Mdl == NULL)
        {
            hwDeviceExtension->Mdl = MmCreateMdl(0,
                                                 hwDeviceExtension->VideoRamBase,
                                                 ONE_MEG);

            if (hwDeviceExtension->Mdl)
            {
                MmBuildMdlForNonPagedPool(hwDeviceExtension->Mdl);
            }
        }

        if (hwDeviceExtension->Mdl)
        {
            pShareMemoryInformation = RequestPacket->OutputBuffer;

            pShareMemoryInformation->VirtualAddress =
                MmMapLockedPagesSpecifyCache(hwDeviceExtension->Mdl,
                                             UserMode,
                                             MmCached,
                                             NULL,
                                             FALSE,
                                             NormalPagePriority);

            pShareMemoryInformation->SharedViewOffset = 0;
            pShareMemoryInformation->SharedViewSize = ONE_MEG;

            status = NO_ERROR;
        }

        break;


    case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:

        VideoDebugPrint((2, "SimStartIO - UnshareVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY))
        {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;

        }

        pShareMemory = RequestPacket->InputBuffer;

        MmUnmapLockedPages(pShareMemory->RequestedVirtualAddress,
                           hwDeviceExtension->Mdl);

        status = NO_ERROR;

        break;


    case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        VideoDebugPrint((2, "SimStartIO - QueryCurrentModes\n"));

        modeInformation = RequestPacket->OutputBuffer;

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MODE_INFORMATION)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            *((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer) =
                SimModes[hwDeviceExtension->CurrentModeNumber];

            status = NO_ERROR;
        }

        break;

    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

    {
        UCHAR i;

        VideoDebugPrint((2, "SimStartIO - QueryAvailableModes\n"));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
                 SimNumModes * sizeof(VIDEO_MODE_INFORMATION)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            modeInformation = RequestPacket->OutputBuffer;

            for (i = 0; i < SimNumModes; i++) {

                *modeInformation = SimModes[i];
                modeInformation++;

            }

            status = NO_ERROR;
        }

        break;
    }


    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((2, "SimStartIO - QueryNumAvailableModes\n"));

        if (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information =
                                                sizeof(VIDEO_NUM_MODES)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->NumModes =
                SimNumModes;
            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->ModeInformationLength =
                sizeof(VIDEO_MODE_INFORMATION);

            status = NO_ERROR;
        }

        break;


    case IOCTL_VIDEO_SET_CURRENT_MODE:

        VideoDebugPrint((2, "SimStartIO - SetCurrentMode\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MODE)) {

            status = ERROR_INSUFFICIENT_BUFFER;
        }

        hwDeviceExtension->CurrentModeNumber =  ((PVIDEO_MODE)
                (RequestPacket->InputBuffer))->RequestedMode;

        status = NO_ERROR;

        break;


    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        VideoDebugPrint((2, "SimStartIO - SetColorRegs\n"));

        status = NO_ERROR;

        break;


    case IOCTL_VIDEO_RESET_DEVICE:

        VideoDebugPrint((2, "SimStartIO - RESET_DEVICE\n"));

        status = NO_ERROR;

        break;

    //
    // if we get here, an invalid IoControlCode was specified.
    //

    default:

        VideoDebugPrint((1, "Fell through Sim startIO routine - invalid command\n"));

        status = ERROR_INVALID_FUNCTION;

        break;

    }

    RequestPacket->StatusBlock->Status = status;

    return TRUE;

} // end SimStartIO()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992-1996 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

#if DBG

LONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    LONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )
{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
    }

    va_end(ap);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\brush.c ===
/******************************Module*Header*******************************\
* Module Name: Brush.c
*
* Handles all brush/pattern initialization and realization.
*
* Copyright (c) 1992-1996 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vRealizeDitherPattern
*
* Generates an 8x8 dither pattern, in our internal realization format, for
* the color ulRGBToDither.  Note that the high byte of ulRGBToDither does
* not need to be set to zero, because vComputeSubspaces ignores it.
\**************************************************************************/

VOID vRealizeDitherPattern(
RBRUSH*     prb,
ULONG       ulRGBToDither,
ULONG       cTile)
{
    ULONG           ulNumVertices;
    VERTEX_DATA     vVertexData[4];
    VERTEX_DATA*    pvVertexData;
    LONG            i;

    // Calculate what color subspaces are involved in the dither:

    pvVertexData = vComputeSubspaces(ulRGBToDither, vVertexData);

    // Now that we have found the bounding vertices and the number of
    // pixels to dither for each vertex, we can create the dither pattern

    ulNumVertices = (ULONG)(pvVertexData - vVertexData);
                      // # of vertices with more than zero pixels in the dither

    // Do the actual dithering:

    vDitherColor(&prb->aulPattern[0], vVertexData, pvVertexData, ulNumVertices);

    if (cTile)
    {
        BYTE*   pjDst = (BYTE*)&prb->aulPattern[0];

        // Probably another version of vDitherColor is
        // in order.

        i = 56;    // start with last row of 8x8
            RtlCopyMemory(&pjDst[i<<1], &pjDst[i], 8);
            RtlCopyMemory(&pjDst[(i<<1)+8], &pjDst[i], 8);
        i -= 8;
            RtlCopyMemory(&pjDst[i<<1], &pjDst[i], 8);
            RtlCopyMemory(&pjDst[(i<<1)+8], &pjDst[i], 8);
        i -= 8;
            RtlCopyMemory(&pjDst[i<<1], &pjDst[i], 8);
            RtlCopyMemory(&pjDst[(i<<1)+8], &pjDst[i], 8);
        i -= 8;
            RtlCopyMemory(&pjDst[i<<1], &pjDst[i], 8);
            RtlCopyMemory(&pjDst[(i<<1)+8], &pjDst[i], 8);
        i -= 8;
            RtlCopyMemory(&pjDst[i<<1], &pjDst[i], 8);
            RtlCopyMemory(&pjDst[(i<<1)+8], &pjDst[i], 8);
        i -= 8;
            RtlCopyMemory(&pjDst[i<<1], &pjDst[i], 8);
            RtlCopyMemory(&pjDst[(i<<1)+8], &pjDst[i], 8);
        i -= 8;
            RtlCopyMemory(&pjDst[i<<1], &pjDst[i], 8);
            RtlCopyMemory(&pjDst[(i<<1)+8], &pjDst[i], 8);
        i -= 8;
            // bytes 0-7 are already in place
            RtlCopyMemory(&pjDst[(i<<1)+8], &pjDst[i], 8);

        RtlCopyMemory(&pjDst[128], pjDst, 128);
    }

    // Initialize the fields we need:

    prb->ptlBrushOrg.x = LONG_MIN;
    prb->fl            = 0;
    prb->pbe           = NULL;
}

/******************************Public*Routine******************************\
* BOOL DrvRealizeBrush
*
* This function allows us to convert GDI brushes into an internal form
* we can use.  It may be called directly by GDI at SelectObject time, or
* it may be called by GDI as a result of us calling BRUSHOBJ_pvGetRbrush
* to create a realized brush in a function like DrvBitBlt.
*
* Note that we have no way of determining what the current Rop or brush
* alignment are at this point.
*
* Warning: psoPattern will be null if the RB_DITHERCOLOR flag is set in
*          iHatch.
*
\**************************************************************************/

BOOL DrvRealizeBrush(
BRUSHOBJ*   pbo,
SURFOBJ*    psoDst,
SURFOBJ*    psoPattern,
SURFOBJ*    psoMask,
XLATEOBJ*   pxlo,
ULONG       iHatch)
{
    PDEV*   ppdev;
    ULONG   iPatternFormat;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    lSrcDelta;
    LONG    cj;
    LONG    dp;
    LONG    i;
    LONG    j;
    RBRUSH* prb;
    ULONG*  pulXlate;
    ULONG   cTile = 0;
    ULONG   ulSize;

    ppdev = (PDEV*) psoDst->dhpdev;

    // We only handle brushes if we have an off-screen brush cache
    // available.  If there isn't one, we can simply fail the realization,
    // and eventually GDI will do the drawing for us (although a lot
    // slower than we could have done it):

    if (!(ppdev->flStatus & STAT_BRUSH_CACHE))
    {
        DISPDBG((2,"There is no brush cache"));
        goto ReturnFalse;
    }

    if ((ppdev->ulChipID != W32P) && (ppdev->ulChipID != ET6000))
    {
        // Patterns are duplicated horizontally and vertically (4 tiles)

        cTile = 1;
    }

    // We have a fast path for dithers when we set GCAPS_DITHERONREALIZE:

    ulSize = sizeof(RBRUSH) + (TOTAL_BRUSH_SIZE * ppdev->cBpp);
    if (cTile)
    {
        ulSize *= 4;
    }

    if (iHatch & RB_DITHERCOLOR)
    {
        // Implementing DITHERONREALIZE increased our score on a certain
        // unmentionable benchmark by 0.4 million 'megapixels'.  Too bad
        // this didn't work in the first version of NT.

        prb = BRUSHOBJ_pvAllocRbrush(pbo, ulSize);
        if (prb == NULL)
        {
            goto ReturnFalse;
        }

        vRealizeDitherPattern(prb, iHatch, cTile);
        goto ReturnTrue;
    }

    // We only accelerate 8x8 patterns.  Since Win3.1 and Chicago don't
    // support patterns of any other size, it's a safe bet that 99.9%
    // of the patterns we'll ever get will be 8x8:

    if ((psoPattern->sizlBitmap.cx != 8) ||
        (psoPattern->sizlBitmap.cy != 8))
    {
        goto ReturnFalse;
    }

    // At  8bpp, we handle patterns at 1bpp, 4bpp and 8bpp with/without an xlate.
    // At 16bpp, we handle patterns at 1bpp and 16bpp without an xlate.
    // At 32bpp, we handle patterns at 1bpp and 32bpp without an xlate.

    iPatternFormat = psoPattern->iBitmapFormat;

    if ((iPatternFormat == ppdev->iBitmapFormat)                            ||
        (iPatternFormat == BMF_1BPP)                                        ||
        (iPatternFormat == BMF_4BPP) && (ppdev->iBitmapFormat == BMF_8BPP))
    {
        cj = (8 * ppdev->cBpp);    // Every pattern is 8 pels wide

        prb = BRUSHOBJ_pvAllocRbrush(pbo, ulSize);
        if (prb == NULL)
        {
            goto ReturnFalse;
        }

        // Initialize the fields we need:

        prb->ptlBrushOrg.x = LONG_MIN;
        prb->fl            = 0;
        prb->pbe           = NULL;

        lSrcDelta = psoPattern->lDelta;
        pjSrc     = (BYTE*) psoPattern->pvScan0;
        pjDst     = (BYTE*) &prb->aulPattern[0];

        if (ppdev->iBitmapFormat == iPatternFormat)
        {
            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                DISPDBG((2, "Realizing un-translated brush"));

                // The pattern is the same color depth as the screen, and
                // there's no translation to be done:

                for (i = 8; i != 0; i--)
                {
                    RtlCopyMemory(pjDst, pjSrc, cj);
                    if (cTile)
                    {
                        RtlCopyMemory(pjDst + cj, pjDst, cj);
                        pjDst += cj;
                    }
                    pjSrc += lSrcDelta;
                    pjDst += cj;
                }
            }
            else if (ppdev->iBitmapFormat == BMF_8BPP)
            {
                DISPDBG((2, "Realizing 8bpp translated brush"));

                // The screen is 8bpp, and there's translation to be done:

                pulXlate = pxlo->pulXlate;

                for (i = 8; i != 0; i--)
                {
                    for (j = 8; j != 0; j--)
                    {
                        *pjDst++ = (BYTE) pulXlate[*pjSrc++];
                    }
                    if (cTile)
                    {
                        RtlCopyMemory(pjDst, pjDst - 8, 8);
                        pjDst += 8;
                    }

                    pjSrc += lSrcDelta - 8;
                }
            }
            else
            {
                // I don't feel like writing code to handle translations
                // when our screen is 16bpp or higher (although I probably
                // should; we could allocate a temporary buffer and use
                // GDI to convert, like is done in the VGA driver).

                DISPDBG((2, "Not realizing translated brush for 16bpp or higher"));
                goto ReturnFalse;
            }
        }
        else if (iPatternFormat == BMF_1BPP)
        {
            DISPDBG((2, "Realizing 1bpp brush"));

            pulXlate = pxlo->pulXlate;

            if (ppdev->iBitmapFormat == BMF_8BPP)
            {
                for (i = 8; i != 0; i--)
                {
                    *pjDst++ = (BYTE) pulXlate[(*pjSrc >> 7) & 1];
                    *pjDst++ = (BYTE) pulXlate[(*pjSrc >> 6) & 1];
                    *pjDst++ = (BYTE) pulXlate[(*pjSrc >> 5) & 1];
                    *pjDst++ = (BYTE) pulXlate[(*pjSrc >> 4) & 1];
                    *pjDst++ = (BYTE) pulXlate[(*pjSrc >> 3) & 1];
                    *pjDst++ = (BYTE) pulXlate[(*pjSrc >> 2) & 1];
                    *pjDst++ = (BYTE) pulXlate[(*pjSrc >> 1) & 1];
                    *pjDst++ = (BYTE) pulXlate[(*pjSrc >> 0) & 1];

                    if (cTile)
                    {
                        RtlCopyMemory(pjDst, pjDst - cj, cj);
                        pjDst += cj;
                    }

                    pjSrc += lSrcDelta;
                }
            }
            else if (ppdev->iBitmapFormat == BMF_16BPP)
            {
                dp = ppdev->cBpp;    // Every pattern is 8 pels wide

                for (i = 8; i != 0; i--)
                {
                    *((WORD *)pjDst) = (WORD) (pulXlate[(*pjSrc >> 7) & 1]);    pjDst += dp;
                    *((WORD *)pjDst) = (WORD) (pulXlate[(*pjSrc >> 6) & 1]);    pjDst += dp;
                    *((WORD *)pjDst) = (WORD) (pulXlate[(*pjSrc >> 5) & 1]);    pjDst += dp;
                    *((WORD *)pjDst) = (WORD) (pulXlate[(*pjSrc >> 4) & 1]);    pjDst += dp;
                    *((WORD *)pjDst) = (WORD) (pulXlate[(*pjSrc >> 3) & 1]);    pjDst += dp;
                    *((WORD *)pjDst) = (WORD) (pulXlate[(*pjSrc >> 2) & 1]);    pjDst += dp;
                    *((WORD *)pjDst) = (WORD) (pulXlate[(*pjSrc >> 1) & 1]);    pjDst += dp;
                    *((WORD *)pjDst) = (WORD) (pulXlate[(*pjSrc >> 0) & 1]);    pjDst += dp;

                    if (cTile)
                    {
                        RtlCopyMemory(pjDst, pjDst - cj, cj);
                        pjDst += cj;
                    }

                    pjSrc += lSrcDelta;
                }
            }
            else if (ppdev->iBitmapFormat == BMF_24BPP)
            {
                dp = ppdev->cBpp;    // Every pattern is 8 pels wide

                for (i = 8; i != 0; i--)
                {
                    *((ULONG *)pjDst) = pulXlate[(*pjSrc >> 7) & 1];    pjDst += dp;
                    *((ULONG *)pjDst) = pulXlate[(*pjSrc >> 6) & 1];    pjDst += dp;
                    *((ULONG *)pjDst) = pulXlate[(*pjSrc >> 5) & 1];    pjDst += dp;
                    *((ULONG *)pjDst) = pulXlate[(*pjSrc >> 4) & 1];    pjDst += dp;
                    *((ULONG *)pjDst) = pulXlate[(*pjSrc >> 3) & 1];    pjDst += dp;
                    *((ULONG *)pjDst) = pulXlate[(*pjSrc >> 2) & 1];    pjDst += dp;
                    *((ULONG *)pjDst) = pulXlate[(*pjSrc >> 1) & 1];    pjDst += dp;
                    *((ULONG *)pjDst) = pulXlate[(*pjSrc >> 0) & 1];    pjDst += dp;

                    if (cTile)
                    {
                        RtlCopyMemory(pjDst, pjDst - cj, cj);
                        pjDst += cj;
                    }

                    pjSrc += lSrcDelta;
                }
            }
        }
        else
        {
            DISPDBG((2, "Realizing 4bpp brush"));

            // The screen is 8bpp and the pattern is 4bpp:

            ASSERTDD((ppdev->iBitmapFormat == BMF_8BPP) &&
                     (iPatternFormat == BMF_4BPP),
                     "Messed up brush logic");

            pulXlate = pxlo->pulXlate;

            for (i = 8; i != 0; i--)
            {
                // Inner loop is repeated only 4 times because each loop
                // handles 2 pixels:

                for (j = 4; j != 0; j--)
                {
                    *pjDst++ = (BYTE) pulXlate[*pjSrc >> 4];
                    *pjDst++ = (BYTE) pulXlate[*pjSrc & 15];
                    pjSrc++;
                }

                if (cTile)
                {
                    RtlCopyMemory(pjDst, pjDst - 8, 8);
                    pjDst += 8;
                }

                pjSrc += lSrcDelta - 4;
            }
        }

        if (cTile)
        {
            pjDst     = (BYTE*) &prb->aulPattern[0];
            RtlCopyMemory(pjDst + (cj*8*2), pjDst, cj*8*2);
        }

ReturnTrue:

        ppdev->pfnFastPatRealize(ppdev, prb, NULL, FALSE);

        if (psoPattern != NULL)
        {
            DISPDBG((2, "Succeeded realization -- Type: %li Format: %li cx: %li cy: %li",
                        psoPattern->iType, psoPattern->iBitmapFormat,
                        psoPattern->sizlBitmap.cx, psoPattern->sizlBitmap.cy));
        }
        else
        {
            DISPDBG((2, "Succeeded realization -- it was a DITHER_ON_REALIZE"));
        }
        return(TRUE);
    }

ReturnFalse:

    if (psoPattern != NULL)
    {
        DISPDBG((2, "Failed realization -- Type: %li Format: %li cx: %li cy: %li",
                    psoPattern->iType, psoPattern->iBitmapFormat,
                    psoPattern->sizlBitmap.cx, psoPattern->sizlBitmap.cy));
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bEnableBrushCache
*
* Allocates off-screen memory for storing the brush cache.
\**************************************************************************/

BOOL bEnableBrushCache(
PDEV*   ppdev)
{
    OH*         poh;            // Points to off-screen chunk of memory
    BRUSHENTRY* pbe;            // Pointer to the brush-cache entry
    LONG        i;

    pbe = &ppdev->abe[0];       // Points to where we'll put the first brush
                                //   cache entry
    {
        LONG x;
        LONG y;
        ULONG cTileFactor = 1;

        // Reserve the offscreen space that is required for the ACL to do
        // solid fills.  If this fails, our solid fill code will not work.
        // We need two DWORD storage locations if we're going to do any
        // monochrome expansion stuff (font painting...).

        // Note: these must be dword aligned for the w32p

        // Not that *I* ever made this mistake, but don't
        // place any early outs (returns) before you allocate the solid
        // color work area.  Not having a solid color work area is a
        // fatal error for this driver.

        DISPDBG((2,"Allocating solid brush work area"));
        poh = pohAllocate(ppdev, NULL, 8, 1, FLOH_MAKE_PERMANENT);

        ASSERTDD((poh != NULL),
                 "We couldn't allocate offscreen space for the solid colors");

		if (!poh)
			return FALSE;

        ppdev->ulSolidColorOffset = (poh->y * ppdev->lDelta) + ppdev->cBpp * poh->x;
        DISPDBG((2,"Allocating brush cache"));

        if ((ppdev->ulChipID != W32P) && (ppdev->ulChipID != ET6000))
        {
            cTileFactor = 4;
        }

        //
        // Fix this mess up.
        //

        poh = pohAllocate(ppdev,
                          NULL,
                          cTileFactor * 2 * 64,
                          FAST_BRUSH_COUNT,
                          FLOH_MAKE_PERMANENT);

        if (poh == NULL)
        {
            DISPDBG((1,"Failed to allocate brush cache"));
            goto ReturnTrue;    // See note about why we can return TRUE...
        }

        ppdev->cBrushCache = FAST_BRUSH_COUNT;

        // Hardware brushes require that the bits start on a 64 (height*width)
        // pixel boundary.  The heap manager doesn't guarantee us any such
        // alignment, so we allocate a bit of extra room so that we can
        // do the alignment ourselves:

        x = poh->x;
        y = poh->y;

        for (i = FAST_BRUSH_COUNT; i != 0; i--)
        {
            ULONG ulOffset;
            ULONG ulCeil;
            ULONG ulDiff;

            // Note:  I learned the HARD way that you can't just align x
            //        to your pattern size, because the lDelta of your screen
            //        is not guaranteed to be a multiple of your pattern size.
            //        Since y is changing in this loop, the recalc must
            //        be done inside this loop.  I really need to set these
            //        up with a hardcoded linear buffer or else make the
            //        heap linear.

            ulOffset = (y * ppdev->lDelta) + (x * ppdev->cBpp);
            ulCeil = (ulOffset + ((ppdev->cBpp*64)-1)) & ~((ppdev->cBpp*64)-1);
            ulDiff = (ulCeil - ulOffset)/ppdev->cBpp;

            // If we hadn't allocated 'ppdev' with LMEM_ZEROINIT,
            // we would have to initialize pbe->prbVerify too...

            pbe->x = x + ulDiff;
            pbe->y = y;

            DISPDBG((2, "BrushCache[%d] pos(%d,%d) pbe(%d,%d) delta(%d) o(%d) c(%d) d(%d)",
                i,
                x,
                y,
                pbe->x,
                pbe->y,
                ppdev->lDelta,
                ulOffset,
                ulCeil,
                ulDiff
            ));

            //x += FAST_BRUSH_ALLOCATION * FAST_BRUSH_ALLOCATION;   // size of a brush (x*y)
            y++;
            //

            pbe++;
        }
    }

    // Note that we don't have to remember 'poh' for when we have
    // to disable brushes -- the off-screen heap frees any
    // off-screen heap allocations automatically.

    // We successfully allocated the brush cache, so let's turn
    // on the switch showing that we can use it:

    ppdev->flStatus |= STAT_BRUSH_CACHE;

ReturnTrue:

    // If we couldn't allocate a brush cache, it's not a catastrophic
    // failure; patterns will still work, although they'll be a bit
    // slower since they'll go through GDI.  As a result we don't
    // actually have to fail this call:

    DISPDBG((5, "Passed bEnableBrushCache"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableBrushCache
*
* Cleans up anything done in bEnableBrushCache.
\**************************************************************************/

VOID vDisableBrushCache(PDEV* ppdev)
{
    // We ain't gotta do nothin'
}

/******************************Public*Routine******************************\
* VOID vAssertModeBrushCache
*
* Resets the brush cache when we exit out of full-screen.
\**************************************************************************/

VOID vAssertModeBrushCache(
PDEV*   ppdev,
BOOL    bEnable)
{
    BRUSHENTRY* pbe;
    LONG        i;

    if (bEnable)
    {
        // Invalidate the brush cache:

        pbe = &ppdev->abe[0];

        for (i = ppdev->cBrushCache; i != 0; i--)
        {
            pbe->prbVerify = NULL;
            pbe++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\ddraw.c ===
/******************************Module*Header*******************************\
* Module Name: ddraw.c
*
* Implements all the DirectDraw components for the driver.
*
* Copyright (c) 1995-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// NT is kind enough to pre-calculate the 2-d surface offset as a 'hint' so
// that we don't have to do the following, which would be 6 DIVs per blt:
//
//    y += (offset / pitch)
//    x += (offset % pitch) / bytes_per_pixel

#define convertToGlobalCord(x, y, surf) \
{                                       \
    y += surf->yHint;                   \
    x += surf->xHint;                   \
}

/////////////////////////////////////////////////////////////////
// DirectDraw stuff

#define VBLANK_IS_ACTIVE(pjPorts)\
    ((CP_IN_BYTE(pjPorts, STATUS_1) & 0x08) ? TRUE : FALSE)   // !!! 0x3da

#define DISPLAY_IS_ACTIVE(pjPorts)\
    ((CP_IN_BYTE(pjPorts, STATUS_1) & 0x01) ? TRUE : FALSE)


#define ENTER(s)    DISPDBG((10, "Entering "#s));
#define EXIT(s)     DISPDBG((10, "Exiting "#s" line(%d)", __LINE__));

/******************************Public*Routine******************************\
* VOID vGetDisplayDuration
*
* Get the length, in EngQueryPerformanceCounter() ticks, of a refresh cycle.
*
* If we could trust the miniport to return back and accurate value for
* the refresh rate, we could use that.  Unfortunately, our miniport doesn't
* ensure that it's an accurate value.
*
\**************************************************************************/

#define NUM_VBLANKS_TO_MEASURE      1
#define NUM_MEASUREMENTS_TO_TAKE    10
#define NUM_MEASUREMENTS_TO_DISCARD 3

#if (NUM_MEASUREMENTS_TO_TAKE - NUM_MEASUREMENTS_TO_DISCARD) < 2
    #error ***************************************
    #error *** You discarded too many measurements
    #error ***************************************
#endif

VOID vGetDisplayDuration(PDEV* ppdev)
{
    BYTE*       pjBase;
    BYTE*       pjPorts;
    LONG        i;
    LONG        j;
    LONGLONG    li;
    LONGLONG    liMin;
    LONGLONG    aliMeasurement[NUM_MEASUREMENTS_TO_TAKE + 1];

    pjBase = ppdev->pjBase;
    pjPorts = ppdev->pjPorts;

    memset(&ppdev->flipRecord, 0, sizeof(ppdev->flipRecord));

    // Warm up EngQUeryPerformanceCounter to make sure it's in the working
    // set:

    EngQueryPerformanceCounter(&li);

    // Unfortunately, since NT is a proper multitasking system, we can't
    // just disable interrupts to take an accurate reading.  We also can't
    // do anything so goofy as dynamically change our thread's priority to
    // real-time.
    //
    // So we just do a bunch of short measurements and take the minimum.
    //
    // It would be 'okay' if we got a result that's longer than the actual
    // VBlank cycle time -- nothing bad would happen except that the app
    // would run a little slower.  We don't want to get a result that's
    // shorter than the actual VBlank cycle time -- that could cause us
    // to start drawing over a frame before the Flip has occured.

    while (VBLANK_IS_ACTIVE(pjPorts))
        ;
    while (!(VBLANK_IS_ACTIVE(pjPorts)))
        ;

    for (i = 0; i < NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        // We're at the start of the VBlank active cycle!

        EngQueryPerformanceCounter(&aliMeasurement[i]);

        // Okay, so life in a multi-tasking environment isn't all that
        // simple.  What if we had taken a context switch just before
        // the above EngQueryPerformanceCounter call, and now were half
        // way through the VBlank inactive cycle?  Then we would measure
        // only half a VBlank cycle, which is obviously bad.  The worst
        // thing we can do is get a time shorter than the actual VBlank
        // cycle time.
        //
        // So we solve this by making sure we're in the VBlank active
        // time before and after we query the time.  If it's not, we'll
        // sync up to the next VBlank (it's okay to measure this period --
        // it will be guaranteed to be longer than the VBlank cycle and
        // will likely be thrown out when we select the minimum sample).
        // There's a chance that we'll take a context switch and return
        // just before the end of the active VBlank time -- meaning that
        // the actual measured time would be less than the true amount --
        // but since the VBlank is active less than 1% of the time, this
        // means that we would have a maximum of 1% error approximately
        // 1% of the times we take a context switch.  An acceptable risk.
        //
        // This next line will cause us wait if we're no longer in the
        // VBlank active cycle as we should be at this point:

        while (!(VBLANK_IS_ACTIVE(pjPorts)))
            ;

        for (j = 0; j < NUM_VBLANKS_TO_MEASURE; j++)
        {
            while (VBLANK_IS_ACTIVE(pjPorts))
                ;
            while (!(VBLANK_IS_ACTIVE(pjPorts)))
                ;
        }
    }

    EngQueryPerformanceCounter(&aliMeasurement[NUM_MEASUREMENTS_TO_TAKE]);

    // Use the minimum:

    liMin = aliMeasurement[1+NUM_MEASUREMENTS_TO_DISCARD] -
            aliMeasurement[0+NUM_MEASUREMENTS_TO_DISCARD];

    DISPDBG((1, "Refresh count: %li - %li", 1, (ULONG) liMin));

    for (i = 2+NUM_MEASUREMENTS_TO_DISCARD; i <= NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        li = aliMeasurement[i] - aliMeasurement[i - 1];

        DISPDBG((1, "               %li - %li", i - NUM_MEASUREMENTS_TO_DISCARD, (ULONG) li));

        if (li < liMin)
            liMin = li;
    }

    // Round the result:

    ppdev->flipRecord.liFlipDuration
        = (DWORD) (liMin + (NUM_VBLANKS_TO_MEASURE / 2)) / NUM_VBLANKS_TO_MEASURE;

    DISPDBG((1, "Frequency %li.%03li Hz",
        (ULONG) (EngQueryPerformanceFrequency(&li),
            li / ppdev->flipRecord.liFlipDuration),
        (ULONG) (EngQueryPerformanceFrequency(&li),
            ((li * 1000) / ppdev->flipRecord.liFlipDuration) % 1000)));

    ppdev->flipRecord.liFlipTime = aliMeasurement[NUM_MEASUREMENTS_TO_TAKE];
    ppdev->flipRecord.bFlipFlag  = FALSE;
    ppdev->flipRecord.fpFlipFrom = 0;
}

/******************************Public*Routine******************************\
* HRESULT vUpdateFlipStatus
*
* Checks and sees if the most recent flip has occurred.
*
\**************************************************************************/

HRESULT vUpdateFlipStatus(
PDEV*   ppdev,
FLATPTR fpVidMem)
{
    BYTE*       pjBase;
    BYTE*       pjPorts;
    LONGLONG    liTime;

    ENTER(vUpdateFlipStatus);

    pjBase = ppdev->pjBase;
    pjPorts = ppdev->pjPorts;

    if ((ppdev->flipRecord.bFlipFlag) &&
        ((fpVidMem == 0) || (fpVidMem == ppdev->flipRecord.fpFlipFrom)))
    {
        if (VBLANK_IS_ACTIVE(pjPorts))
        {
            if (ppdev->flipRecord.bWasEverInDisplay)
            {
                ppdev->flipRecord.bHaveEverCrossedVBlank = TRUE;
            }
        }
        else if (DISPLAY_IS_ACTIVE(pjPorts))
        {
            if( ppdev->flipRecord.bHaveEverCrossedVBlank )
            {
                ppdev->flipRecord.bFlipFlag = FALSE;

                EXIT(vUpdateFlipStatus);
                return(DD_OK);
            }
            ppdev->flipRecord.bWasEverInDisplay = TRUE;
        }

        EngQueryPerformanceCounter(&liTime);

        if (liTime - ppdev->flipRecord.liFlipTime
                                <= ppdev->flipRecord.liFlipDuration)
        {
            EXIT(vUpdateFlipStatus);
            return(DDERR_WASSTILLDRAWING);
        }

        ppdev->flipRecord.bFlipFlag = FALSE;
    }

    EXIT(vUpdateFlipStatus);

    return(DD_OK);
}

/******************************Public*Routine******************************\
* DWORD DdBlt
*
\**************************************************************************/

DWORD DdBlt(
PDD_BLTDATA lpBlt)
{
    PDD_SURFACE_GLOBAL      srcSurf;
    PDD_SURFACE_LOCAL       destSurfx;
    PDD_SURFACE_GLOBAL      destSurf;
    PDEV*                   ppdev;
    BYTE*                   pjBase;
    HRESULT                 ddrval;
    FLATPTR                 destOffset;
    DWORD                   destPitch;
    DWORD                   destX;
    DWORD                   destY;
    DWORD                   direction;
    DWORD                   dwFlags;
    DWORD                   height;
    BYTE                    rop;
    FLATPTR                 sourceOffset;
    DWORD                   srcPitch;
    DWORD                   srcX;
    DWORD                   srcY;
    DWORD                   width;
    LONG                    lDelta;
    LONG                    cBpp;

    ULONG                   ulBltAdjust = 0;

    ENTER(DdBlt);

    ppdev     = (PDEV*) lpBlt->lpDD->dhpdev;
    pjBase    = ppdev->pjBase;

    lDelta    = ppdev->lDelta;
    cBpp      = ppdev->cBpp;

    destSurfx = lpBlt->lpDDDestSurface;
    destSurf  = destSurfx->lpGbl;

    // Is a flip in progress?

    ddrval = vUpdateFlipStatus(ppdev, destSurf->fpVidMem);
    if (ddrval != DD_OK)
    {
        lpBlt->ddRVal = ddrval;
        EXIT(DdBlt);
        return(DDHAL_DRIVER_HANDLED);
    }

    dwFlags = lpBlt->dwFlags;

    if (dwFlags & DDBLT_ASYNC)
    {
        // If async, then only work if we won't have to wait on the
        // accelerator to start the command.

        // !!! is this next line correct?

        if (IS_BUSY(ppdev, pjBase))
        {
            lpBlt->ddRVal = DDERR_WASSTILLDRAWING;
            EXIT(DdBlt);
            return(DDHAL_DRIVER_HANDLED);
        }
    }

    // Copy src/dest rects:

    destX      = lpBlt->rDest.left;
    destY      = lpBlt->rDest.top;
    width      = lpBlt->rDest.right - lpBlt->rDest.left;
    height     = lpBlt->rDest.bottom - lpBlt->rDest.top;
    destPitch  = destSurf->lPitch;
    destOffset = destSurf->fpVidMem;

    if (dwFlags & DDBLT_COLORFILL)
    {
        lpBlt->ddRVal = DD_OK;

        convertToGlobalCord(destX, destY, destSurf);

        // Solid fill here

        {
            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            CP_FG_ROP(ppdev, pjBase, R3_PATCOPY);
            CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta - 1));
            CP_PAT_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset);
            CP_XCNT(ppdev, pjBase, (width * cBpp - 1));
            CP_YCNT(ppdev, pjBase, (height - 1));
            WAIT_FOR_IDLE_ACL(ppdev, pjBase);
            *(PULONG)(ppdev->pjScreen + ppdev->ulSolidColorOffset) =
                COLOR_REPLICATE(ppdev, lpBlt->bltFX.dwFillColor);

            if (cBpp == 3)
            {
                CP_PEL_DEPTH(ppdev, pjBase, HW_PEL_DEPTH_24BPP);
                CP_PAT_WRAP(ppdev, pjBase, SOLID_COLOR_PATTERN_WRAP_24BPP);
                CP_PAT_Y_OFFSET(ppdev, pjBase, (SOLID_COLOR_PATTERN_OFFSET_24BPP - 1));
                CP_DST_ADDR(ppdev, pjBase, ((destY * lDelta) + (cBpp * destX)));
                WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
                CP_PEL_DEPTH(ppdev, pjBase, HW_PEL_DEPTH_8BPP);
            }
            else
            {
                CP_PAT_WRAP(ppdev, pjBase, SOLID_COLOR_PATTERN_WRAP);
                CP_PAT_Y_OFFSET(ppdev, pjBase, (SOLID_COLOR_PATTERN_OFFSET - 1));
                CP_DST_ADDR(ppdev, pjBase, ((destY * lDelta) + (cBpp * destX)));
            }
        }

        EXIT(DdBlt);
        return(DDHAL_DRIVER_HANDLED);
    }

    // We specified with Our ddCaps.dwCaps that we handle a limited number
    // of commands, and by this point in our routine we've handled everything
    // except DDBLT_ROP.  DirectDraw and GDI shouldn't pass us anything
    // else; we'll assert on debug builds to prove this:

    ASSERTDD((dwFlags & DDBLT_ROP) && (lpBlt->lpDDSrcSurface),
        "Expected dwFlags commands of only DDBLT_ASYNC and DDBLT_COLORFILL");

    // Get offset, width, and height for source:

    srcSurf      = lpBlt->lpDDSrcSurface->lpGbl;
    srcX         = lpBlt->rSrc.left;
    srcY         = lpBlt->rSrc.top;
    srcPitch     = srcSurf->lPitch;
    sourceOffset = srcSurf->fpVidMem;

    // Assume we can do the blt top-to-bottom, left-to-right:

    if ((destSurf == srcSurf) && (srcX + width  > destX) &&
        (srcY + height > destY) && (destX + width > srcX) &&
        (destY + height > srcY) &&
        (((srcY == destY) && (destX > srcX) )
             || ((srcY != destY) && (destY > srcY))))
    {
        // Okay, we have to do the blt bottom-to-top, right-to-left:

        ulBltAdjust = 1;

        srcX = lpBlt->rSrc.right;
        srcY = lpBlt->rSrc.bottom - 1;
        destX = lpBlt->rDest.right;
        destY = lpBlt->rDest.bottom - 1;
    }

    // NT only ever gives us SRCCOPY rops, so don't even both checking
    // for anything else.

    convertToGlobalCord(srcX, srcY, srcSurf);
    convertToGlobalCord(destX, destY, destSurf);

    // Bitmap Blt

    {
        WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

        if (ulBltAdjust) {
            CP_XY_DIR(ppdev, pjBase, (BOTTOM_TO_TOP | RIGHT_TO_LEFT));
        }

        if (dwFlags & DDBLT_KEYSRCOVERRIDE)
        {
            // Color keyed Transparency

            CP_FG_ROP(ppdev, pjBase, R3_SRCCOPY);
            CP_SRC_WRAP(ppdev, pjBase, NO_PATTERN_WRAP);
            CP_SRC_Y_OFFSET(ppdev, pjBase, (lDelta - 1));
            CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta - 1));
            if (ulBltAdjust) {
                CP_PAT_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset + cBpp - 1);
            } else {
                CP_PAT_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset);
            }
            CP_ROUTING_CTRL(ppdev, pjBase, 0x13);   // Generate CompareMap
            CP_XCNT(ppdev, pjBase, ((cBpp * width) - 1));
            CP_YCNT(ppdev, pjBase, (height - 1));
            CP_SRC_ADDR(ppdev, pjBase, ((srcY * lDelta) + (cBpp * srcX) - ulBltAdjust));
            WAIT_FOR_IDLE_ACL(ppdev, pjBase);
            *(PULONG)(ppdev->pjScreen + ppdev->ulSolidColorOffset) =
                COLOR_REPLICATE(ppdev, lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue);

            if (cBpp == 3)
            {
                CP_PEL_DEPTH(ppdev, pjBase, HW_PEL_DEPTH_24BPP);
                CP_PAT_WRAP(ppdev, pjBase, SOLID_COLOR_PATTERN_WRAP_24BPP);
                CP_PAT_Y_OFFSET(ppdev, pjBase, (SOLID_COLOR_PATTERN_OFFSET_24BPP - 1));
                CP_DST_ADDR(ppdev, pjBase, ((destY * lDelta) + (cBpp * destX) - ulBltAdjust));
            }
            else if (cBpp == 2)
            {
                CP_PEL_DEPTH(ppdev, pjBase, HW_PEL_DEPTH_16BPP);
                CP_PAT_WRAP(ppdev, pjBase, SOLID_COLOR_PATTERN_WRAP);
                CP_PAT_Y_OFFSET(ppdev, pjBase, (SOLID_COLOR_PATTERN_OFFSET - 1));
                CP_DST_ADDR(ppdev, pjBase, ((destY * lDelta) + (cBpp * destX) - ulBltAdjust));
            }
            else
            {
                CP_PAT_WRAP(ppdev, pjBase, SOLID_COLOR_PATTERN_WRAP);
                CP_PAT_Y_OFFSET(ppdev, pjBase, (SOLID_COLOR_PATTERN_OFFSET - 1));
                CP_DST_ADDR(ppdev, pjBase, ((destY * lDelta) + (cBpp * destX) - ulBltAdjust));
            }

            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            CP_PEL_DEPTH(ppdev, pjBase, HW_PEL_DEPTH_8BPP);
            CP_ROUTING_CTRL(ppdev, pjBase, 0x33);
        }
        else
        {
            // Opaque

            CP_FG_ROP(ppdev, pjBase, R3_SRCCOPY);
            CP_SRC_WRAP(ppdev, pjBase, NO_PATTERN_WRAP);
            CP_SRC_Y_OFFSET(ppdev, pjBase, (lDelta - 1));
            CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta - 1));
            CP_XCNT(ppdev, pjBase, ((cBpp * width) - 1));
            CP_YCNT(ppdev, pjBase, (height - 1));
            CP_SRC_ADDR(ppdev, pjBase, ((srcY * lDelta) + (cBpp * srcX) - ulBltAdjust));

            CP_DST_ADDR(ppdev, pjBase, ((destY * lDelta) + (cBpp * destX) - ulBltAdjust));
        }

        if (ulBltAdjust) {
            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            CP_XY_DIR(ppdev, pjBase, 0);
        }
    }


    lpBlt->ddRVal = DD_OK;

    EXIT(DdBlt);

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdFlip
*
\**************************************************************************/

DWORD DdFlip(
PDD_FLIPDATA lpFlip)
{
    PDEV*       ppdev;
    BYTE*       pjBase;
    BYTE*       pjPorts;
    HRESULT     ddrval;
    ULONG       ulMemoryOffset;
    ULONG       ulLowOffset;
    ULONG       ulMiddleOffset;
    ULONG       ulHighOffset;

    ENTER(DdFLip);

    ppdev    = (PDEV*) lpFlip->lpDD->dhpdev;
    pjBase   = ppdev->pjBase;
    pjPorts  = ppdev->pjPorts;

    // Is the current flip still in progress?
    //
    // Don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem.

    ddrval = vUpdateFlipStatus(ppdev, 0);
    if ((ddrval != DD_OK) || (IS_BUSY(ppdev, pjBase)))
    {
        lpFlip->ddRVal = DDERR_WASSTILLDRAWING;
        EXIT(DdFLip);
        return(DDHAL_DRIVER_HANDLED);
    }

    // Do the flip:

    ulMemoryOffset = (ULONG)(lpFlip->lpSurfTarg->lpGbl->fpVidMem) >> 2;

    ulLowOffset    = 0x0d | ((ulMemoryOffset & 0x0000ff) << 8);
    ulMiddleOffset = 0x0c | ((ulMemoryOffset & 0x00ff00));
    ulHighOffset   = 0x33 | ((ulMemoryOffset & 0x0f0000) >> 8);

    // Make sure that the border/blanking period isn't active; wait if
    // it is.  We could return DDERR_WASSTILLDRAWING in this case, but
    // that will increase the odds that we can't flip the next time:

    while (!(DISPLAY_IS_ACTIVE(pjPorts)))
        ;

    CP_OUT_WORD(pjPorts, CRTC_INDEX, ulLowOffset);
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ulMiddleOffset);
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ulHighOffset);

    // Remember where and when we were when we did the flip:

    EngQueryPerformanceCounter(&ppdev->flipRecord.liFlipTime);

    ppdev->flipRecord.bFlipFlag              = TRUE;
    ppdev->flipRecord.bHaveEverCrossedVBlank = FALSE;
    ppdev->flipRecord.bWasEverInDisplay      = FALSE;

    ppdev->flipRecord.fpFlipFrom = lpFlip->lpSurfCurr->lpGbl->fpVidMem;

    lpFlip->ddRVal = DD_OK;

    EXIT(DdFLip);
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdLock
*
\**************************************************************************/

DWORD DdLock(
PDD_LOCKDATA lpLock)
{
    PDEV*   ppdev;
    BYTE*   pjBase;
    HRESULT ddrval;

    ENTER(DdLock);

    ppdev  = (PDEV*) lpLock->lpDD->dhpdev;
    pjBase = ppdev->pjBase;

    // Check to see if any pending physical flip has occurred.
    // Don't allow a lock if a blt is in progress:

    ddrval = vUpdateFlipStatus(ppdev, lpLock->lpDDSurface->lpGbl->fpVidMem);
    if (ddrval != DD_OK)
    {
        lpLock->ddRVal = DDERR_WASSTILLDRAWING;
        EXIT(DdLock);
        return(DDHAL_DRIVER_HANDLED);
    }

    if ((ppdev->dwLinearCnt == 0) && (IS_BUSY(ppdev, pjBase)))
    {
        lpLock->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    // Reference count it, just for the heck of it:

    ppdev->dwLinearCnt++;

    EXIT(DdLock);
    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdUnlock
*
\**************************************************************************/

DWORD DdUnlock(
PDD_UNLOCKDATA lpUnlock)
{
    PDEV*   ppdev;

    ENTER(DdUnlock);

    ppdev = (PDEV*) lpUnlock->lpDD->dhpdev;

    ppdev->dwLinearCnt--;

    EXIT(DdUnlock);
    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetBltStatus
*
* Doesn't currently really care what surface is specified, just checks
* and goes.
*
\**************************************************************************/

DWORD DdGetBltStatus(
PDD_GETBLTSTATUSDATA lpGetBltStatus)
{
    PDEV*   ppdev;
    BYTE*   pjBase;
    HRESULT ddRVal;

    ENTER(DdGetBltStatus);

    ppdev  = (PDEV*) lpGetBltStatus->lpDD->dhpdev;
    pjBase = ppdev->pjBase;

    ddRVal = DD_OK;
    if (lpGetBltStatus->dwFlags == DDGBS_CANBLT)
    {
        // DDGBS_CANBLT case: can we add a blt?

        ddRVal = vUpdateFlipStatus(ppdev,
                        lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem);

        if (ddRVal == DD_OK)
        {
            // There was no flip going on, so is there room in the FIFO
            // to add a blt?

            // !!! is this next line correct?

            if (IS_BUSY(ppdev, pjBase))
            {
                ddRVal = DDERR_WASSTILLDRAWING;
            }
        }
    }
    else
    {
        // DDGBS_ISBLTDONE case: is a blt in progress?

        if (IS_BUSY(ppdev, pjBase))
        {
            ddRVal = DDERR_WASSTILLDRAWING;
        }
    }

    lpGetBltStatus->ddRVal = ddRVal;

    EXIT(DdGetBltStatus);
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdMapMemory
*
* This is a new DDI call specific to Windows NT that is used to map
* or unmap all the application modifiable portions of the frame buffer
* into the specified process's address space.
*
\**************************************************************************/

DWORD DdMapMemory(
PDD_MAPMEMORYDATA lpMapMemory)
{
    PDEV*                           ppdev;
    VIDEO_SHARE_MEMORY              ShareMemory;
    VIDEO_SHARE_MEMORY_INFORMATION  ShareMemoryInformation;
    DWORD                           ReturnedDataLength;

    ENTER(DdMapMemory);

    ppdev = (PDEV*) lpMapMemory->lpDD->dhpdev;

    if (lpMapMemory->bMap)
    {
        ShareMemory.ProcessHandle = lpMapMemory->hProcess;

        // 'RequestedVirtualAddress' isn't actually used for the SHARE IOCTL:

        ShareMemory.RequestedVirtualAddress = 0;

        // We map in starting at the top of the frame buffer:

        ShareMemory.ViewOffset = 0;

        // We map down to the end of the frame buffer.
        //
        // Note: There is a 64k granularity on the mapping (meaning that
        //       we have to round up to 64k).
        //
        // Note: If there is any portion of the frame buffer that must
        //       not be modified by an application, that portion of memory
        //       MUST NOT be mapped in by this call.  This would include
        //       any data that, if modified by a malicious application,
        //       would cause the driver to crash.  This could include, for
        //       example, any DSP code that is kept in off-screen memory.

        ShareMemory.ViewSize
            = ROUND_UP_TO_64K(ppdev->cyMemory * ppdev->lDelta);

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               &ShareMemoryInformation,
                               sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
                               &ReturnedDataLength))
        {
            DISPDBG((0, "Failed IOCTL_VIDEO_SHARE_MEMORY"));

            lpMapMemory->ddRVal = DDERR_GENERIC;
            EXIT(DdMapMemory);
            return(DDHAL_DRIVER_HANDLED);
        }

        lpMapMemory->fpProcess = (ULONG_PTR) ShareMemoryInformation.VirtualAddress;
    }
    else
    {
        ShareMemory.ProcessHandle           = lpMapMemory->hProcess;
        ShareMemory.ViewOffset              = 0;
        ShareMemory.ViewSize                = 0;
        ShareMemory.RequestedVirtualAddress = (VOID*) lpMapMemory->fpProcess;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {
            RIP("Failed IOCTL_VIDEO_UNSHARE_MEMORY");
        }
    }

    lpMapMemory->ddRVal = DD_OK;
    EXIT(DdMapMemory);
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetFlipStatus
*
* If the display has gone through one refresh cycle since the flip
* occurred, we return DD_OK.  If it has not gone through one refresh
* cycle we return DDERR_WASSTILLDRAWING to indicate that this surface
* is still busy "drawing" the flipped page.   We also return
* DDERR_WASSTILLDRAWING if the bltter is busy and the caller wanted
* to know if they could flip yet.
*
\**************************************************************************/

DWORD DdGetFlipStatus(
PDD_GETFLIPSTATUSDATA lpGetFlipStatus)
{
    PDEV*   ppdev;
    BYTE*   pjBase;

    ENTER(DdGetFlipStatus);

    ppdev  = (PDEV*) lpGetFlipStatus->lpDD->dhpdev;
    pjBase = ppdev->pjBase;

    // We don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem:

    lpGetFlipStatus->ddRVal = vUpdateFlipStatus(ppdev, 0);

    // Check if the bltter is busy if someone wants to know if they can
    // flip:

    if (lpGetFlipStatus->dwFlags == DDGFS_CANFLIP)
    {
        if ((lpGetFlipStatus->ddRVal == DD_OK) && (IS_BUSY(ppdev, pjBase)))
        {
            lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
        }
    }

    EXIT(DdGetFlipStatus);
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdWaitForVerticalBlank
*
\**************************************************************************/

DWORD DdWaitForVerticalBlank(
PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
    PDEV*   ppdev;
    BYTE*   pjBase;
    BYTE*   pjPorts;

    ENTER(DdWaitForVerticalBlank);

    ppdev   = (PDEV*) lpWaitForVerticalBlank->lpDD->dhpdev;
    pjBase  = ppdev->pjBase;
    pjPorts = ppdev->pjPorts;

    lpWaitForVerticalBlank->ddRVal = DD_OK;

    switch (lpWaitForVerticalBlank->dwFlags)
    {
    case DDWAITVB_I_TESTVB:

        // If TESTVB, it's just a request for the current vertical blank
        // status:

        if (VBLANK_IS_ACTIVE(pjPorts))
            lpWaitForVerticalBlank->bIsInVB = TRUE;
        else
            lpWaitForVerticalBlank->bIsInVB = FALSE;

        EXIT(DdWaitForVerticalBlank);
        return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKBEGIN:

        // If BLOCKBEGIN is requested, we wait until the vertical blank
        // is over, and then wait for the display period to end:

        while (VBLANK_IS_ACTIVE(pjPorts))
            ;
        while (!(VBLANK_IS_ACTIVE(pjPorts)))
            ;

        EXIT(DdWaitForVerticalBlank);
        return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKEND:

        // If BLOCKEND is requested, we wait for the vblank interval to end:

        while (!(VBLANK_IS_ACTIVE(pjPorts)))
            ;
        while (VBLANK_IS_ACTIVE(pjPorts))
            ;

        EXIT(DdWaitForVerticalBlank);
        return(DDHAL_DRIVER_HANDLED);
    }

    EXIT(DdWaitForVerticalBlank);
    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* BOOL DrvGetDirectDrawInfo
*
* Will be called before DrvEnableDirectDraw is called.
*
\**************************************************************************/

BOOL DrvGetDirectDrawInfo(
DHPDEV          dhpdev,
DD_HALINFO*     pHalInfo,
DWORD*          pdwNumHeaps,
VIDEOMEMORY*    pvmList,            // Will be NULL on first call
DWORD*          pdwNumFourCC,
DWORD*          pdwFourCC)          // Will be NULL on first call
{
    BOOL        bCanFlip;
    PDEV*       ppdev;
    LONGLONG    li;
    OH*         poh;

    ENTER(DrvGetDirectDrawInfo);

    ppdev = (PDEV*) dhpdev;

    // We may not support DirectDraw on this card:

    if (!(ppdev->flStatus & STAT_DIRECTDRAW))
    {
        EXIT(DrvGetDirectDrawInfo);
        return(FALSE);
    }

    pHalInfo->dwSize = sizeof(*pHalInfo);

    // Current primary surface attributes.  Since HalInfo is zero-initialized
    // by GDI, we only have to fill in the fields which should be non-zero:

    pHalInfo->vmiData.pvPrimary       = ppdev->pjScreen;
    pHalInfo->vmiData.dwDisplayWidth  = ppdev->cxScreen;
    pHalInfo->vmiData.dwDisplayHeight = ppdev->cyScreen;
    pHalInfo->vmiData.lDisplayPitch   = ppdev->lDelta;

    pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof(DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB;

    // !!! What about 15 vs. 16 Bpp below?

    pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->cBpp * 8;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
    }

    // These masks will be zero at 8bpp:

    pHalInfo->vmiData.ddpfDisplay.dwRBitMask = ppdev->flRed;
    pHalInfo->vmiData.ddpfDisplay.dwGBitMask = ppdev->flGreen;
    pHalInfo->vmiData.ddpfDisplay.dwBBitMask = ppdev->flBlue;

    if (ppdev->iBitmapFormat == BMF_32BPP)
    {
        pHalInfo->vmiData.ddpfDisplay.dwRGBAlphaBitMask
            = ~(ppdev->flRed | ppdev->flGreen | ppdev->flBlue);
    }
    else
    {
        pHalInfo->vmiData.ddpfDisplay.dwRGBAlphaBitMask = 0;
    }

    // Set up the pointer to the first available video memory after
    // the primary surface:

    bCanFlip     = FALSE;
    *pdwNumHeaps = 0;

    // Free up as much off-screen memory as possible:

    bMoveAllDfbsFromOffscreenToDibs(ppdev);

    // Now simply reserve the biggest chunk for use by DirectDraw:

    poh = ppdev->pohDirectDraw;
    if (poh == NULL)
    {
        poh = pohAllocate(ppdev,
                          NULL,
                          ppdev->heap.cxMax,
                          ppdev->heap.cyMax,
                          FLOH_MAKE_PERMANENT);

        ppdev->pohDirectDraw = poh;
    }

    if (poh != NULL)
    {
        *pdwNumHeaps = 1;

        // Fill in the list of off-screen rectangles if we've been asked
        // to do so:

        if (pvmList != NULL)
        {
            DISPDBG((1, "DirectDraw gets %li x %li surface at (%li, %li)",
                    poh->cx, poh->cy, poh->x, poh->y));

            pvmList->dwFlags        = VIDMEM_ISRECTANGULAR;
            pvmList->fpStart        = (poh->y * ppdev->lDelta)
                                    + (poh->x * ppdev->cBpp);
            pvmList->dwWidth        = poh->cx * ppdev->cBpp;
            pvmList->dwHeight       = poh->cy;
            pvmList->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
            if ((DWORD) ppdev->cyScreen <= pvmList->dwHeight)
            {
                bCanFlip = TRUE;
            }
        }
    }

    // Capabilities supported:

    pHalInfo->ddCaps.dwFXCaps = 0;
    pHalInfo->ddCaps.dwCaps   = DDCAPS_BLT
                              | DDCAPS_BLTCOLORFILL
                              | DDCAPS_COLORKEY;

    pHalInfo->ddCaps.dwCKeyCaps     = DDCKEYCAPS_SRCBLT;
    pHalInfo->ddCaps.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN
                                    | DDSCAPS_PRIMARYSURFACE;
    if (bCanFlip)
    {
        pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_FLIP;
    }

    // Required alignments of the scan lines for each kind of memory:

    pHalInfo->vmiData.dwOffscreenAlign = 8 * ppdev->cBpp;

    // FourCCs supported:

    *pdwNumFourCC = 0;

    EXIT(DrvGetDirectDrawInfo);
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL DrvEnableDirectDraw
*
\**************************************************************************/

BOOL DrvEnableDirectDraw(
DHPDEV                  dhpdev,
DD_CALLBACKS*           pCallBacks,
DD_SURFACECALLBACKS*    pSurfaceCallBacks,
DD_PALETTECALLBACKS*    pPaletteCallBacks)
{
    PDEV* ppdev;

    ENTER(DrvEnableDirectDraw);

    ppdev = (PDEV*) dhpdev;

    pCallBacks->WaitForVerticalBlank = DdWaitForVerticalBlank;
    pCallBacks->MapMemory            = DdMapMemory;
    pCallBacks->dwFlags              = DDHAL_CB32_WAITFORVERTICALBLANK
                                     | DDHAL_CB32_MAPMEMORY;

    pSurfaceCallBacks->Blt           = DdBlt;
    pSurfaceCallBacks->Flip          = DdFlip;
    pSurfaceCallBacks->Lock          = DdLock;
    pSurfaceCallBacks->Unlock        = DdUnlock;
    pSurfaceCallBacks->GetBltStatus  = DdGetBltStatus;
    pSurfaceCallBacks->GetFlipStatus = DdGetFlipStatus;
    pSurfaceCallBacks->dwFlags       = DDHAL_SURFCB32_BLT
                                     | DDHAL_SURFCB32_FLIP
                                     | DDHAL_SURFCB32_LOCK
                                     | DDHAL_SURFCB32_UNLOCK
                                     | DDHAL_SURFCB32_GETBLTSTATUS
                                     | DDHAL_SURFCB32_GETFLIPSTATUS;

    // Note that we don't call 'vGetDisplayDuration' here, for a couple of
    // reasons:
    //
    //  o Because the system is already running, it would be disconcerting
    //    to pause the graphics for a good portion of a second just to read
    //    the refresh rate;
    //  o More importantly, we may not be in graphics mode right now.
    //
    // For both reasons, we always measure the refresh rate when we switch
    // to a new mode.

    EXIT(DrvEnableDirectDraw);
    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDirectDraw
*
\**************************************************************************/

VOID DrvDisableDirectDraw(
DHPDEV      dhpdev)
{
    PDEV*   ppdev;

    ENTER(DrvDisableDirectDraw);

    ppdev = (PDEV*) dhpdev;

    // DirectDraw is done with the display, so we can go back to using
    // all of off-screen memory ourselves:

    pohFree(ppdev, ppdev->pohDirectDraw);
    ppdev->pohDirectDraw = NULL;

    EXIT(DrvDisableDirectDraw);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeDirectDraw
*
\**************************************************************************/

VOID vAssertModeDirectDraw(
PDEV*   ppdev,
BOOL    bEnabled)
{
}

/******************************Public*Routine******************************\
* BOOL bEnableDirectDraw
*
* This function is called when the mode is first initialized, right after
* the miniport does the mode-set.
*
\**************************************************************************/

BOOL bEnableDirectDraw(
PDEV*   ppdev)
{
    ENTER(bEnableDirectDraw);

    // We're not going to bother to support accelerated DirectDraw on
    // the pre-ET6000 chips, because they don't have linear frame
    // buffers.

    if (ppdev->ulChipID == ET6000)
    {
        // Accurately measure the refresh rate for later:

        vGetDisplayDuration(ppdev);

        // DirectDraw is all set to be used on this card:

        ppdev->flStatus |= STAT_DIRECTDRAW;
    }

    EXIT(bEnableDirectDraw);
    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableDirectDraw
*
\**************************************************************************/

VOID vDisableDirectDraw(
PDEV*   ppdev)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1996 Microsoft Corporation
\***************************************************************************/


#if DBG

VOID
DebugPrint(
    LONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#define ASSERTDD(x, y) if (!(x)) RIP (y)

#else

//
// The statement "0;" should always be optimized out.  Defining these
// this way will allow us to use statements such as
// portdata = DISPDBG((0,msg)), inp(x) even on free builds.
// This is a great way to use DISPDBGs in the "read" or "input" macros.
//

#define DISPDBG(arg)    0
#define RIP(x)          0
#define ASSERTDD(x, y)  0

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\enable.c ===
/******************************Module*Header*******************************\
* Module Name: enable.c
*
* This module contains the functions that enable and disable the
* driver, the pdev, and the surface.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

BOOL bGetChipIDandRev(HANDLE hDriver, PPDEV ppdev);


BYTE*        gpjBase;
BYTE*        gpjPorts;
BYTE*        gpjMmu0;

/******************************Public*Structure****************************\
* GDIINFO ggdiDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

GDIINFO ggdiDefault = {
    GDI_DRIVER_VERSION,     // ulVersion
    DT_RASDISPLAY,          // ulTechnology
    0,                      // ulHorzSize (filled in later)
    0,                      // ulVertSize (filled in later)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    0,                      // cPlanes (filled in later)
    20,                     // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)

    0,                      // ulLogPixelsX (filled in later)
    0,                      // ulLogPixelsY (filled in later)

    TC_RA_ABLE /* | TC_SCROLLBLT */,
                            // flTextCaps --
                            //   Setting TC_SCROLLBLT tells console to scroll
                            //   by repainting the entire window.  Otherwise,
                            //   scrolls are done by calling the driver to
                            //   do screen to screen copies.

    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)

    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)

    1,                      // xStyleStep
    1,                      // yStyleSte;
    3,                      // denStyleStep -- Styles have a one-to-one aspect
                            //   ratio, and every 'dot' is 3 pixels long

    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize

    256,                    // ulNumPalReg

    // These fields are for halftone initialization.  The actual values are
    // a bit magic, but seem to work well on our display.

    {                       // ciDevice
       { 6700, 3300, 0 },   //      Red
       { 2100, 7100, 0 },   //      Green
       { 1400,  800, 0 },   //      Blue
       { 1750, 3950, 0 },   //      Cyan
       { 4050, 2050, 0 },   //      Magenta
       { 4400, 5200, 0 },   //      Yellow
       { 3127, 3290, 0 },   //      AlignmentWhite
       20000,               //      RedGamma
       20000,               //      GreenGamma
       20000,               //      BlueGamma
       0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh
    0,                       // ulBltAlignment
    0,                       // ulPanningHorzRes
    0,                       // ulPanningVertRes
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault = {

    (GCAPS_OPAQUERECT
     | GCAPS_DITHERONREALIZE
     | GCAPS_PALMANAGED
     | GCAPS_MONO_DITHER
     | GCAPS_COLOR_DITHER
     | GCAPS_DIRECTDRAW
     | GCAPS_ASYNCMOVE
     ),
                // NOTE: Only enable ASYNCMOVE if your code
                //   and hardware can handle DrvMovePointer
                //   calls at any time, even while another
                //   thread is in the middle of a drawing
                //   call such as DrvBitBlt.

                                                // flGraphicsFlags
    SYSTM_LOGFONT,                              // lfDefaultFont
    HELVE_LOGFONT,                              // lfAnsiVarFont
    COURI_LOGFONT,                              // lfAnsiFixFont
    0,                                          // cFonts
    BMF_8BPP,                                   // iDitherFormat
    8,                                          // cxDither
    8,                                          // cyDither
    0                                           // hpalDefault (filled in later)
};

/******************************Public*Structure****************************\
* DFVFN gadrvfn[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
* Why haven't we implemented DrvSaveScreenBits?  To save code.
*
* When the driver doesn't hook DrvSaveScreenBits, USER simulates on-
* the-fly by creating a temporary device-format-bitmap, and explicitly
* calling DrvCopyBits to save/restore the bits.  Since we already hook
* DrvCreateDeviceBitmap, we'll end up using off-screen memory to store
* the bits anyway (which would have been the main reason for implementing
* DrvSaveScreenBits).  So we may as well save some working set.
\**************************************************************************/

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
#if !DRIVER_PUNT_ALL
    {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },
    {   INDEX_DrvPaint,                 (PFN) DrvPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush       },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap },
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo  },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw   },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw  },
#endif
};

ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);


/******************************Public*Routine******************************\
* BOOL DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.

    DISPDBG((100, "DrvEnableDriver"));

    // Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = gcdrvfn;

    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after DrvEnableDriver, when GDI
* wants to get some information about us.
*
* (This function mostly returns back information; DrvEnableSurface is used
* for initializing the hardware and driver components.)
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PDEV*   ppdev;

    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:

    DISPDBG((100, "DrvEnablePDEV"));

    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        DISPDBG((0, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
    }

    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:

    ppdev = (PDEV*) EngAllocMem(0, sizeof(PDEV), ALLOC_TAG);
    if (ppdev == NULL)
    {
        DISPDBG((0, "DrvEnablePDEV - Failed EngAllocMem"));
        goto ReturnFailure0;
    }

    memset(ppdev, 0, sizeof(PDEV));

    ppdev->hDriver = hDriver;

    if (!bGetChipIDandRev(hDriver, ppdev))
    {
        //
        // This puppy wasn't recognized as a W32
        //

        goto ReturnFailure1;
    }

    // Get the current screen mode information.  Set up device caps and
    // devinfo:

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
    {
        goto ReturnFailure1;
    }

    // Initialize palette information.

    if (!bInitializePalette(ppdev, pdi))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
    }

    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((0, "Failed DrvEnablePDEV"));
    return(0);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
* Note that this function will be called when previewing modes in the
* Display Applet, but not at system shutdown.  If you need to reset the
* hardware at shutdown, you can do it in the miniport by providing a
* 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
*
* Note: In an error, we may call this before DrvEnablePDEV is done.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV  dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    vUninitializePalette(ppdev);
    EngFreeMem(ppdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}


/******************************Public*Routine******************************\
* HSURF DrvEnableSurface
*
* Creates the drawing surface, initializes the hardware, and initializes
* driver components.  This function is called after DrvEnablePDEV, and
* performs the final device initialization.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurf;
    SIZEL   sizl;
    DSURF*  pdsurf;
    VOID*   pvTmpBuffer;

    ppdev = (PDEV*) dhpdev;

    /////////////////////////////////////////////////////////////////////
    // First, enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...

    if (!bEnableHardware(ppdev))
        goto ReturnFailure;

    if (!bEnableBanking(ppdev))
        goto ReturnFailure;

    if (!bEnableOffscreenHeap(ppdev))
        goto ReturnFailure;

    if (!bEnablePointer(ppdev))
        goto ReturnFailure;

    if (!bEnableText(ppdev))
        goto ReturnFailure;

    if (!bEnableBrushCache(ppdev))
        goto ReturnFailure;

    if (!bEnablePalette(ppdev))
        goto ReturnFailure;

    if (!bEnableDirectDraw(ppdev))
        goto ReturnFailure;

    /////////////////////////////////////////////////////////////////////
    // Now create our private surface structure.
    //
    // Whenever we get a call to draw directly to the screen, we'll get
    // passed a pointer to a SURFOBJ whose 'dhpdev' field will point
    // to our PDEV structure, and whose 'dhsurf' field will point to the
    // following DSURF structure.
    //
    // Every device bitmap we create in DrvCreateDeviceBitmap will also
    // have its own unique DSURF structure allocated (but will share the
    // same PDEV).  To make our code more polymorphic for handling drawing
    // to either the screen or an off-screen bitmap, we have the same
    // structure for both.

    pdsurf = EngAllocMem(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG);
    if (pdsurf == NULL)
    {
        DISPDBG((0, "DrvEnableSurface - Failed pdsurf EngAllocMem"));
        goto ReturnFailure;
    }

    ppdev->pdsurfScreen = pdsurf;        // Remember it for clean-up

    pdsurf->poh     = ppdev->pohScreen;  // The screen is a surface, too
    pdsurf->dt      = DT_SCREEN;         // Not to be confused with a DIB
    pdsurf->sizl.cx = ppdev->cxScreen;
    pdsurf->sizl.cy = ppdev->cyScreen;
    pdsurf->ppdev   = ppdev;
    pdsurf->cBlt    = 0;
    pdsurf->iUniq   = 0;

    /////////////////////////////////////////////////////////////////////
    // Next, have GDI create the actual SURFOBJ.
    //
    // Our drawing surface is going to be 'device-managed', meaning that
    // GDI cannot draw on the framebuffer bits directly, and as such we
    // create the surface via EngCreateDeviceSurface.  By doing this, we ensure
    // that GDI will only ever access the bitmaps bits via the Drv calls
    // that we've HOOKed.
    //
    // If we could map the entire framebuffer linearly into main memory
    // (i.e., we didn't have to go through a 64k aperture), it would be
    // beneficial to create the surface via EngCreateBitmap, giving GDI a
    // pointer to the framebuffer bits.  When we pass a call on to GDI
    // where it can't directly read/write to the surface bits because the
    // surface is device managed, it has to create a temporary bitmap and
    // call our DrvCopyBits routine to get/set a copy of the affected bits.
    // For example, the OpenGL component prefers to be able to write on the
    // framebuffer bits directly.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    if (ppdev->bAutoBanking)
    {
        HSURF       hsurfFrameBuf;

        // Engine-managed surface:

        hsurfFrameBuf = (HSURF) EngCreateBitmap(sizl,
                                                ppdev->lDelta,
                                                ppdev->iBitmapFormat,
                                                BMF_TOPDOWN,
                                                ppdev->pjScreen);
        if (hsurfFrameBuf == 0)
        {
            DISPDBG((0, "DrvEnableSurface - Failed EngCreateBitmap"));
            goto ReturnFailure;
        }

        if (!EngAssociateSurface(hsurfFrameBuf, ppdev->hdevEng, 0))
        {
            DISPDBG((0, "DrvEnableSurface - Failed EngAssociateSurface 1"));
            goto ReturnFailure;
        }


        ppdev->psoFrameBuffer = EngLockSurface(hsurfFrameBuf);
        if (ppdev->psoFrameBuffer == NULL)
        {
            DISPDBG((0, "DrvEnableSurface - Couldn't lock our surface"));
            goto ReturnFailure;
        }
    }

    hsurf = EngCreateDeviceSurface((DHSURF) pdsurf, sizl, ppdev->iBitmapFormat);
    if (hsurf == 0)
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngCreateDeviceSurface"));
        goto ReturnFailure;
    }

    ppdev->hsurfScreen = hsurf;             // Remember it for clean-up
    ppdev->bEnabled = TRUE;                 // We'll soon be in graphics mode

    /////////////////////////////////////////////////////////////////////
    // Now associate the surface and the PDEV.
    //
    // We have to associate the surface we just created with our physical
    // device so that GDI can get information related to the PDEV when
    // it's drawing to the surface (such as, for example, the length of
    // styles on the device when simulating styled lines).
    //

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks))
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngAssociateSurface 2"));
        goto ReturnFailure;
    }

    // Create our generic temporary buffer, which may be used by any
    // component.

    pvTmpBuffer = EngAllocMem(0, TMP_BUFFER_SIZE, ALLOC_TAG);

    if (pvTmpBuffer == NULL)
    {
        DISPDBG((0, "DrvEnableSurface - Failed VirtualAlloc"));
        goto ReturnFailure;
    }

    ppdev->pvTmpBuffer = pvTmpBuffer;

    DISPDBG((5, "Passed DrvEnableSurface"));

    return(hsurf);

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((0, "Failed DrvEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
* Note that this function will be called when previewing modes in the
* Display Applet, but not at system shutdown.  If you need to reset the
* hardware at shutdown, you can do it in the miniport by providing a
* 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
*
* Note: In an error case, we may call this before DrvEnableSurface is
*       completely done.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.

    if (ppdev->bAutoBanking)
    {
        EngUnlockSurface(ppdev->psoFrameBuffer);
    }

    vDisableDirectDraw(ppdev);
    vDisablePalette(ppdev);
    vDisableBrushCache(ppdev);
    vDisableText(ppdev);
    vDisablePointer(ppdev);
    vDisableOffscreenHeap(ppdev);
    vDisableBanking(ppdev);
    vDisableHardware(ppdev);

    EngDeleteSurface(ppdev->hsurfScreen);

    if (ppdev->pvTmpBuffer)
    {
        EngFreeMem(ppdev->pvTmpBuffer);
    }

    if (ppdev->pdsurfScreen)
    {
        EngFreeMem(ppdev->pdsurfScreen);
    }
}

/******************************Public*Routine******************************\
* VOID DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL DrvAssertMode(
DHPDEV  dhpdev,
BOOL    bEnable)
{
    PDEV* ppdev;

    ppdev = (PDEV*) dhpdev;

    if (!bEnable)
    {
        //////////////////////////////////////////////////////////////
        // Disable - Switch to full-screen mode

        vAssertModeDirectDraw(ppdev, FALSE);

        vAssertModePalette(ppdev, FALSE);

        vAssertModeBrushCache(ppdev, FALSE);

        vAssertModeText(ppdev, FALSE);

        vAssertModePointer(ppdev, FALSE);

        if (bAssertModeOffscreenHeap(ppdev, FALSE))
        {
            vAssertModeBanking(ppdev, FALSE);

            if (bAssertModeHardware(ppdev, FALSE))
            {
                ppdev->bEnabled = FALSE;

                return(TRUE);
            }

            //////////////////////////////////////////////////////////
            // We failed to switch to full-screen.  So undo everything:

            vAssertModeBanking(ppdev, TRUE);

            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
        }                                           //   return code with TRUE

        vAssertModePointer(ppdev, TRUE);

        vAssertModeText(ppdev, TRUE);

        vAssertModeBrushCache(ppdev, TRUE);

        vAssertModePalette(ppdev, TRUE);
    }
    else
    {
        //////////////////////////////////////////////////////////////
        // Enable - Switch back to graphics mode

        // We have to enable every subcomponent in the reverse order
        // in which it was disabled:

        if (bAssertModeHardware(ppdev, TRUE))
        {
            vAssertModeBanking(ppdev, TRUE);

            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
                                                    //   return code with TRUE
            vAssertModePointer(ppdev, TRUE);

            vAssertModeText(ppdev, TRUE);

            vAssertModeBrushCache(ppdev, TRUE);

            vAssertModePalette(ppdev, TRUE);

            ppdev->bEnabled = TRUE;

            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* ULONG DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)
{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    if (!bGetChipIDandRev(hDriver, NULL))
    {
        //
        // This puppy wasn't recognized as a W32
        //

        return(0);
    }


    cModes = getAvailableModes(hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize);
    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return(0);
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG_PTR)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);


        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return(cbOutputSize);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeHardware
*
* Sets the appropriate hardware state for graphics mode or full-screen.
*
\**************************************************************************/

BOOL bAssertModeHardware(
PDEV* ppdev,
BOOL  bEnable)
{
    DWORD                   ReturnedDataLength;
    ULONG                   ulReturn;
    VIDEO_MODE_INFORMATION  VideoModeInfo;
    LONG                    cjEndOfFrameBuffer;
    LONG                    cjPointerOffset;
    LONG                    lDelta;
    ULONG                   ulMode;

    if (bEnable)
    {
        // Call the miniport via an IOCTL to set the graphics mode.

        ulMode = ppdev->ulMode;

        if (ppdev->bAutoBanking)
        {
            ulMode |= VIDEO_MODE_MAP_MEM_LINEAR;
        }

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_CURRENT_MODE,
                               &ulMode,  // input buffer
                               sizeof(DWORD),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed VIDEO_SET_CURRENT_MODE"));
            goto ReturnFalse;
        }

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_QUERY_CURRENT_MODE,
                               NULL,
                               0,
                               &VideoModeInfo,
                               sizeof(VideoModeInfo),
                               &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - failed VIDEO_QUERY_CURRENT_MODE"));
            goto ReturnFalse;
        }

        #if DEBUG_HEAP
            VideoModeInfo.VideoMemoryBitmapWidth  = VideoModeInfo.VisScreenWidth;
            VideoModeInfo.VideoMemoryBitmapHeight = VideoModeInfo.VisScreenHeight;
        #endif

        // The following variables are determined only after the initial
        // modeset:

        ppdev->lDelta   = VideoModeInfo.ScreenStride;
        ppdev->flCaps   = VideoModeInfo.AttributeFlags;

        ppdev->cxMemory = VideoModeInfo.VideoMemoryBitmapWidth;
        ppdev->cyMemory = VideoModeInfo.VideoMemoryBitmapHeight;

        DISPDBG((1,"ppdev->cxMemory = %d",ppdev->cxMemory));
        DISPDBG((1,"ppdev->cyMemory = %d",ppdev->cyMemory));

#if DRIVER_PUNT_ALL
        //
        // Force SW cursor if PUNT_ALL
        //

        ppdev->flCaps |= CAPS_SW_POINTER;
#endif

        if (ppdev->ulChipID != ET6000)
        {
            if ((ppdev->cBpp > 1) ||
                (ppdev->cxScreen > 1024))
            {
                ppdev->flCaps |= CAPS_SW_POINTER;
            }
        }

        if (ppdev->cxScreen < 512)
        {
            // The 320x240 and 320x200 modes can't use HW pointers

            ppdev->flCaps |= CAPS_SW_POINTER;
        }

        // If we're using the hardware pointer, reserve the last 1k of
        // the frame buffer to store the pointer shape:

        if (!(ppdev->flCaps & (CAPS_SW_POINTER)))
        {
            // Byte offset from start of frame buffer to end:

            cjEndOfFrameBuffer = ppdev->cyMemory * ppdev->lDelta;

            // We'll reserve the end of off-screen memory for the hardware
            // pointer shape.

            cjPointerOffset = (cjEndOfFrameBuffer - SPRITE_BUFFER_SIZE);

            //  If we are using the ET6000 then we are going to round up to the
            //  next 1K boundary.  This is necessary because of the requirements
            //  of the ET6000 sprite.

            if (ppdev->ulChipID == ET6000)
            {
                cjPointerOffset += 1023;
                cjPointerOffset &= 0xFFFFFC00;
            }

            // Figure out the coordinate where the pointer shape starts:

            lDelta = ppdev->lDelta;

            ppdev->cjPointerOffset = cjPointerOffset;
            ppdev->yPointerShape   = (cjPointerOffset / lDelta);
            ppdev->xPointerShape   = (cjPointerOffset % lDelta)
                                   / ppdev->cBpp;

            if (ppdev->yPointerShape >= ppdev->cyScreen)
            {
                // There's enough room for the pointer shape at the
                // bottom of off-screen memory; reserve its room by
                // lying about how much off-screen memory there is:

                ppdev->cyMemory = ppdev->yPointerShape;
            }
            else
            {
                // There's not enough room for the pointer shape in
                // off-screen memory; we'll have to simulate:

                ppdev->flCaps |= CAPS_SW_POINTER;
            }
        }

        {
            BYTE*       pjBase = ppdev->pjBase;
            LONG        lDeltaScreen;

            // Set the default state of the MMU Control Register so the ACL
            // can start.  This must be done on pre W32p chips.

            if (ppdev->ulChipID != ET6000)
            {
                // Set a known state for all the MMU apertures, linear address,
                // non-accelerated.
                // Set MMU Aperture 2 so it will route its data to the ACL

                CP_MMU_CTRL(ppdev, pjBase, 0x70 | MMU_APERTURE_2_ACL_BIT);

                if (ppdev->ulChipID != W32P)
                {
                    CP_STATE(ppdev, pjBase, 0x09);
                    CP_X_POS_W32(ppdev, pjBase, 0);
                    CP_Y_POS_W32(ppdev, pjBase, 0);
                }
                else
                {
                    CP_X_POS_W32P(ppdev, pjBase, 0);
                    CP_Y_POS_W32P(ppdev, pjBase, 0);
                }
            }

            // Set default values to the following registers.
            // These values should not change.  If they are changed, it is the
            // responsiblity of the of the code that changed them to set them
            // back to the values they are set to here.

            CP_SRC_WRAP(ppdev, pjBase, NO_PATTERN_WRAP);
            if (ppdev->ulChipID == ET6000)
            {
                CP_ACL_CONFIG(ppdev, pjBase, 0x06);
                CP_ROUTING_CTRL(ppdev, pjBase, 0x33);
            }
            else
            {
                // Enable using wait-states to sync with the ACL QUEUE.
                CP_SYNC_ENABLE(ppdev, pjBase, 0x01);
                CP_ROUTING_CTRL(ppdev, pjBase, 0);
            }

            // Set the W32's source and destination offset registers.

            lDeltaScreen  = ppdev->cxMemory;

            CP_SRC_Y_OFFSET(ppdev, pjBase, (lDeltaScreen - 1));
            CP_DST_Y_OFFSET(ppdev, pjBase, (lDeltaScreen - 1));

            // Set the default blit direction.

            CP_XY_DIR(ppdev, pjBase, 0);

            // The W32p overloads the Virtual Bus size register for use as the
            // ACL pixel depth register.

            // Set a default value for the ACL pixel depth to 1 byte.
            // This should be benign on the W32 and W32i.

            CP_BUS_SIZE(ppdev, pjBase, 0);

            // If this is a W32p then we must set ASEN in the OperationStateReg
            // the ACL can start.

            if ((ppdev->ulChipID == W32P) || (ppdev->ulChipID == ET6000))
            {
                CP_STATE(ppdev, pjBase, 0x10);
            }

            //
            // The following MUST be done for all pre-W32p chips.  It must
            // also be done for W32p rev A chips because the register still
            // exists (though undocumented).  The operation is harmless on
            // later chips, so just do it.
            //

            CP_RELOAD_CTRL(ppdev, pjBase, 0);

            //
            // An outside source has told us that certain ET6000 cards will
            // not correctly be reset during reboot if the ACL Transfer
            // Disable Register is not cleared.  The BIOS will normally clear
            // this register during boot, but if the card gets hot, the
            // register isn't always cleared.  We will clear it here just
            // to be sure.
            //

            if (ppdev->ulChipID == ET6000)
            {
                CP_XFER_DISABLE(ppdev, pjBase, 0);
            }
        }

        // Do some paramater checking on the values that the miniport
        // returned to us:

        ASSERTDD(ppdev->cxMemory >= ppdev->cxScreen, "Invalid cxMemory");
        ASSERTDD(ppdev->cyMemory >= ppdev->cyScreen, "Invalid cyMemory");
    }
    else
    {
        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there:

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_RESET_DEVICE,
                               NULL,
                               0,
                               NULL,
                               0,
                               &ulReturn))
        {
            DISPDBG((0, "bAssertModeHardware - Failed reset IOCTL"));
            goto ReturnFalse;
        }
    }

    DISPDBG((5, "Passed bAssertModeHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bAssertModeHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bEnableHardware
*
* Puts the hardware in the requested mode and initializes it.
*
* Note: Should be called before any access is done to the hardware from
*       the display driver.
*
\**************************************************************************/

BOOL bEnableHardware(
PDEV*   ppdev)
{
    VIDEO_MEMORY                VideoMemory;
    VIDEO_MEMORY_INFORMATION    VideoMemoryInfo;
    DWORD                       ReturnedDataLength;
    DWORD                       uRet;
    VIDEO_PUBLIC_ACCESS_RANGES  VideoAccessRange[3];
    ULONG                       ulMode;

    ulMode = ppdev->ulMode | VIDEO_MODE_MAP_MEM_LINEAR;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_CURRENT_MODE,
                           &ulMode,  // input buffer
                           sizeof(DWORD),
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
        ulMode &= ~VIDEO_MODE_MAP_MEM_LINEAR;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_CURRENT_MODE,
                               &ulMode,  // input buffer
                               sizeof(DWORD),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {

            DISPDBG((0, "bEnableHardware - Failed VIDEO_SET_CURRENT_MODE"));
            goto ReturnFalse;
        }
    }

    ppdev->bAutoBanking = (ulMode & VIDEO_MODE_MAP_MEM_LINEAR) ?
                           TRUE : FALSE;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                           NULL,
                           0,
                           (PVOID) &VideoAccessRange,
                           sizeof (VideoAccessRange),
                           &ReturnedDataLength) != NO_ERROR)
    {
        DISPDBG((0, "bEnableHardware - Error mapping access ranges."));
        goto ReturnFalse;
    }

    ppdev->pjMmu0  = gpjMmu0 = VideoAccessRange[0].VirtualAddress;
    ppdev->pjMmu1  = ppdev->pjMmu0 + 1 * 0x2000;
    ppdev->pjMmu2  = ppdev->pjMmu0 + 2 * 0x2000;

    ppdev->pjBase  = gpjBase  = VideoAccessRange[1].VirtualAddress;
    ppdev->pjPorts = gpjPorts = VideoAccessRange[2].VirtualAddress;


    // Get the linear memory address range.

    VideoMemory.RequestedVirtualAddress = NULL;

    uRet =  EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                               &VideoMemory,      // input buffer
                               sizeof(VIDEO_MEMORY),
                               &VideoMemoryInfo,  // output buffer
                               sizeof(VideoMemoryInfo),
                               &ReturnedDataLength);
    if (uRet != NO_ERROR)
    {
        DISPDBG((0, "bEnableHardware - Error mapping video buffer"));
        goto ReturnFalse;
    }

    DISPDBG((1, "FrameBufferBase(ie. pjScreen) %lx", VideoMemoryInfo.FrameBufferBase));
    DISPDBG((1, "FrameBufferLength %lx", VideoMemoryInfo.FrameBufferLength));

    // Record the Frame Buffer Linear Address.

    ppdev->pjScreen = (BYTE*) VideoMemoryInfo.FrameBufferBase;
    ppdev->cjBank   =         VideoMemoryInfo.FrameBufferLength;
    //ppdev->bAutoBanking =     (VideoMemoryInfo.VideoRamLength ==
    //                           VideoMemoryInfo.FrameBufferLength)?
    //                           TRUE:FALSE;

    //
    //  We've done the mapping for IO ports and memory space, so let's get
    //  the pointer to the PCI config space.  This is gotten from the CTRC
    //  registers 21,22, & 23 on the ET6000.
    //

    if (ppdev->ulChipID == ET6000)
    {
        char    a, b, c;

        OUTP(CRTC_INDEX, 0x23);
        a = INP(CRTC_DATA);
        OUTP(CRTC_INDEX, 0x22);
        b = INP(CRTC_DATA);
        OUTP(CRTC_INDEX, 0x21);
        c = INP(CRTC_DATA);

        ppdev->PCIConfigSpaceAddr =
            ((long) a << 24) | ((long) b << 16) | ((long) c << 8);
    }

    // Now we can set the mode and unlock the accelerator.

    if (!bAssertModeHardware(ppdev, TRUE))
        goto ReturnFalse;

    // Can do memory-mapped IO:

    if (ppdev->ulChipID == ET6000)
    {
        ppdev->pfnXfer1bpp          = vET6000SlowXfer1bpp;
    }
    else
    {
        ppdev->pfnXfer1bpp          = vSlowXfer1bpp;
    }

    ppdev->pfnFillPat           = vPatternFillScr;
    ppdev->pfnCopyBlt           = vScrToScr;
    ppdev->pfnFastPatRealize    = vFastPatRealize;

    /////////////////////////////////////////////////////////////
    // Fill in pfns specific to color depth

    if (ppdev->cBpp == 3)
    {
        ppdev->pfnFillSolid     = vSolidFillScr24;
    }
    else
    {
        ppdev->pfnFillSolid     = vSolidFillScr;
    }

    /////////////////////////////////////////////////////////////
    // Fill in pfns specific to linear vs banked frame buffer

    if (ppdev->bAutoBanking)
    {
        ppdev->pfnGetBits       = vGetBitsLinear;
        ppdev->pfnPutBits       = vPutBitsLinear;
    }
    else
    {
        ppdev->pfnGetBits       = vGetBits;
        ppdev->pfnPutBits       = vPutBits;
    }

    /////////////////////////////////////////////////////////////
    // Fill in pfns specific to chip type

    if (ppdev->ulChipID == W32P)
    {
        ppdev->pfnXferNative = vXferBlt8p;
    }
    else if (ppdev->ulChipID == ET6000)
    {
        ppdev->pfnXferNative = vXferET6000;
    }
    else
    {
        ppdev->pfnXferNative = vXferBlt8i;
    }


    #if DBG
    {
        DISPDBG((1, "cjBank: %lx, cxMemory: %li, cyMemory: %li, lDelta: %li, Flags: %lx",
                ppdev->cjBank, ppdev->cxMemory, ppdev->cyMemory,
                ppdev->lDelta, ppdev->flCaps));

        if (ppdev->flCaps & CAPS_SW_POINTER)
        {
            DISPDBG((0, "Using software pointer"));
        }
        else
        {
            DISPDBG((0, "Using hardware pointer"));
        }

        DISPDBG((0, "%d bpp mode", ppdev->cBpp * 8));

        if(ppdev->bAutoBanking)
        {
            DISPDBG((0, "Linear Mode"));
        }
        else
        {
            DISPDBG((0, "Banked Mode"));
        }
    }
    #endif

    DISPDBG((5, "Passed bEnableHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableHardware
*
* Undoes anything done in bEnableHardware.
*
* Note: In an error case, we may call this before bEnableHardware is
*       completely done.
*
\**************************************************************************/

VOID vDisableHardware(
PDEV*   ppdev)
{
    DWORD        ReturnedDataLength;
    VIDEO_MEMORY VideoMemory[2];

    VideoMemory[0].RequestedVirtualAddress = ppdev->pjScreen;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                           VideoMemory,
                           sizeof(VIDEO_MEMORY),
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
        DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_UNMAP_VIDEO"));
    }

    VideoMemory[0].RequestedVirtualAddress = ppdev->w32MmuInfo.pvMemoryBufferVirtualAddr;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES,
                           VideoMemory,
                           sizeof(VideoMemory),
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
        DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_FREE_PUBLIC_ACCESS 1"));
    }

    VideoMemory[0].RequestedVirtualAddress = ppdev->w32MmuInfo.pvPortsVirtualAddr;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES,
                           VideoMemory,
                           sizeof(VideoMemory),
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
        DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_FREE_PUBLIC_ACCESS 2"));
    }
}

/******************************Public*Routine******************************\
* BOOL bInitializeModeFields
*
* Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
* devinfo based on the requested mode.
*
\**************************************************************************/

BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)
{
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    BOOL                    bSelectDefault;
    VIDEO_MODE_INFORMATION  VideoModeInformation;
    ULONG                   cbModeSize;

    // Call the miniport to get mode information

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);
    if (cModes == 0)
        goto ReturnFalse;

    // Now see if the requested mode has a match in that table.

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth        == 0) &&
        (pdm->dmPelsHeight       == 0) &&
        (pdm->dmBitsPerPel       == 0) &&
        (pdm->dmDisplayFrequency == 0))
    {
        DISPDBG((1, "Default mode requested"));
        bSelectDefault = TRUE;
    }
    else
    {
        DISPDBG((1, "Requested mode..."));
        DISPDBG((1, "   Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((1, "   Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((1, "   Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((1, "   Frequency     -- %li", pdm->dmDisplayFrequency));

        bSelectDefault = FALSE;
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            DISPDBG((2, "   Checking against miniport mode:"));
            DISPDBG((2, "      Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "      Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "      Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                      pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "      Frequency     -- %li", pVideoTemp->Frequency));

            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((1, "...Found a mode match!"));
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);

    }

    // If no mode has been found, return an error

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((1, "...Couldn't find a mode match!"));
        EngFreeMem(pVideoBuffer);
        goto ReturnFalse;
    }

    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.

    VideoModeInformation = *pVideoModeSelected;
    EngFreeMem(pVideoBuffer);

    #if DEBUG_HEAP
        VideoModeInformation.VisScreenWidth  = 640;
        VideoModeInformation.VisScreenHeight = 480;
    #endif

    // Set up screen information from the mini-port:

    ppdev->ulMode           = VideoModeInformation.ModeIndex;
    ppdev->cxScreen         = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen         = VideoModeInformation.VisScreenHeight;

    DISPDBG((1, "ScreenStride: %lx", VideoModeInformation.ScreenStride));

    ppdev->flHooks          = (HOOK_BITBLT
                               | HOOK_TEXTOUT
                               | HOOK_COPYBITS
                               | HOOK_STROKEPATH
#if !DRIVER_PUNT_ALL
                               | HOOK_PAINT
                               | HOOK_STRETCHBLT
#endif
                               );

    // Fill in the GDIINFO data structure with the default 8bpp values:

    *pgdi = ggdiDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;

    pgdi->cBitsPixel        = VideoModeInformation.BitsPerPlane;
    pgdi->cPlanes           = VideoModeInformation.NumberOfPlanes;
    pgdi->ulVRefresh        = VideoModeInformation.Frequency;

    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    // Fill in the devinfo structure with the default 8bpp values:

    *pdi = gdevinfoDefault;

    if (VideoModeInformation.BitsPerPlane == 8)
    {
        ppdev->w32PatternWrap  = PATTERN_WRAP_8x8;
        ppdev->cPelSize        = 0;
        ppdev->cBpp            = 1;
        ppdev->iBitmapFormat   = BMF_8BPP;
        ppdev->ulWhite         = 0xff;
    }
    else if ((VideoModeInformation.BitsPerPlane == 16) ||
             (VideoModeInformation.BitsPerPlane == 15))
    {
        ppdev->w32PatternWrap  = PATTERN_WRAP_16x8;
        ppdev->cPelSize        = 1;
        ppdev->cBpp            = 2;
        ppdev->iBitmapFormat   = BMF_16BPP;
        ppdev->ulWhite         = 0xffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_16BPP;

        pdi->iDitherFormat     = BMF_16BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }
    else
    {
        ASSERTDD(VideoModeInformation.BitsPerPlane == 24,
                 "This driver supports only 8, 16 and 24bpp");

        ppdev->w32PatternWrap  = PATTERN_WRAP_32x8;
        ppdev->cPelSize        = 2;
        ppdev->cBpp            = 3;
        ppdev->iBitmapFormat   = BMF_24BPP;
        ppdev->ulWhite         = 0xffffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_24BPP;

        pdi->iDitherFormat     = BMF_24BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }

    DISPDBG((5, "Passed bInitializeModeFields"));
    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializeModeFields"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* DWORD getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,
DWORD*                   cbModeSize)
{
    ULONG                   ulTemp;
    VIDEO_NUM_MODES         modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
                           NULL,
                           0,
                           &modes,
                           sizeof(VIDEO_NUM_MODES),
                           &ulTemp))
    {
        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(0, modes.NumModes *
                                        modes.ModeInformationLength,
                                    ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes - Failed EngAllocMem"));
        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_AVAIL_MODES,
                           NULL,
                           0,
                           *modeInformation,
                           modes.NumModes * modes.ModeInformationLength,
                           &ulTemp))
    {

        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_AVAIL_MODES"));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8, 15, 16 or 24 bits per pel.
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
            ((pVideoTemp->BitsPerPlane != 8)
             && (pVideoTemp->BitsPerPlane != 15)
             && (pVideoTemp->BitsPerPlane != 16)
             && (pVideoTemp->BitsPerPlane != 24)    // !!! will this work
             ))
        {
            DISPDBG((2, "Rejecting miniport mode:"));
            DISPDBG((2, "   Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "   Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "   Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                   pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "   Frequency     -- %li", pVideoTemp->Frequency));

            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return(modes.NumModes);
}


/******************************Public*Routine******************************\
* BOOL bGetChipIDandRev
*
* Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
* devinfo based on the requested mode.
*
* If bRetInfo is TRUE then pChipIDandRev is filled in.
*
* Returns TRUE if chip is one of the W32 family, FALSE otherwise
*
\**************************************************************************/

BOOL bGetChipIDandRev(HANDLE hDriver, PPDEV ppdev)
{

    BYTE                            jChipID;
    BOOL                            bRet = TRUE;
    VIDEO_COPROCESSOR_INFORMATION   VideoCoprocessorInfo;
    DWORD                           ReturnedDataLength;

    //
    // Get information about the video card.
    //

    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_GET_VIDEO_CARD_INFO,
                           NULL,
                           0,
                           &VideoCoprocessorInfo,
                           sizeof(VIDEO_COPROCESSOR_INFORMATION),
                           &ReturnedDataLength))
    {
        RIP("bGetChipIDandRev - Couldn't get video card info");
        bRet = FALSE;
        goto ReturnStatus;
    }

    if (VideoCoprocessorInfo.ulChipID < W32)
    {
        bRet = FALSE;
        goto ReturnStatus;
    }

    if (ppdev)
    {
        ppdev->ulChipID =   VideoCoprocessorInfo.ulChipID;
        ppdev->ulRevLevel = VideoCoprocessorInfo.ulRevLevel;
    }

    DISPDBG((1, "ulChipID = %d", VideoCoprocessorInfo.ulChipID));
    DISPDBG((1, "ulRevLevel = %d", VideoCoprocessorInfo.ulRevLevel));

ReturnStatus:
    return (bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\hw.h ===
/******************************Module*Header*******************************\
* Module Name: hw.h
*
* All the hardware specific driver file stuff.  Parts are mirrored in
* 'hw.inc'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#define CP_TRACK     DISPDBG((100,"CP access - File(%s)  line(%d)", __FILE__, __LINE__))

typedef struct _PDEV PDEV;      // Handy forward declaration


//////////////////////////////////////////////////////////////////////
// private IOCTL info - if you touch this, do the same to the miniport

#define IOCTL_VIDEO_GET_VIDEO_CARD_INFO \
        CTL_CODE (FILE_DEVICE_VIDEO, 2048, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _VIDEO_COPROCESSOR_INFORMATION {
    ULONG ulChipID;         // ET3000, ET4000, W32, W32I, or W32P
    ULONG ulRevLevel;       // REV_A, REV_B, REV_C, REV_D, REV_UNDEF
    ULONG ulVideoMemory;    // in bytes
} VIDEO_COPROCESSOR_INFORMATION, *PVIDEO_COPROCESSOR_INFORMATION;

//////////////////////////////////////////////////////////////////////
// The following are reflected in hw.inc.  Don't change these
// without changing that file.

typedef enum _CHIP_TYPE {
    ET3000 = 1,
    ET4000,
    W32,
    W32I,
    W32P,
    ET6000
} CHIP_TYPE;

typedef enum _REV_TYPE {
    REV_UNDEF = 1,
    REV_A,
    REV_B,
    REV_C,
    REV_D,
} REV_TYPE;

//////////////////////////////////////////////////////////////////////
// Ports

#define SEG_SELECT_LO                   0x03CD
#define SEG_SELECT_HI                   0x03CB
#define CRTC_INDEX                      0x03D4
#define CRTC_DATA                       0x03D5

#define CRTCB_SPRITE_INDEX              0x217A
#define CRTCB_SPRITE_DATA               0x217B



//////////////////////////////////////////////////////////////////////
// Memory Map

// When we are banked

#define BANKED_MMU_BUFFER_MEMORY_ADDR          0xB8000
#define BANKED_MMU_BUFFER_MEMORY_LEN           (0xBE000 - 0xB8000)
#define BANKED_MMU_MEMORY_MAPPED_REGS_ADDR     0xBFF00
#define BANKED_MMU_MEMORY_MAPPED_REGS_LEN      (0xC0000 - 0xBFF00)
#define BANKED_MMU_EXTERNAL_MAPPED_REGS_ADDR   0xBE000
#define BANKED_MMU_EXTERNAL_MAPPED_REGS_LEN    (0xBF000 - 0xBE000)

#define BANKED_APERTURE_0_OFFSET   0x0000
#define BANKED_APERTURE_1_OFFSET   0x2000
#define BANKED_APERTURE_2_OFFSET   0x4000

// When we are linear

#define MMU_BUFFER_MEMORY_ADDR          0x200000
#define MMU_BUFFER_MEMORY_LEN           0x17FFFF
#define MMU_MEMORY_MAPPED_REGS_ADDR     0x3FFF00
#define MMU_MEMORY_MAPPED_REGS_LEN      0x000100
#define MMU_EXTERNAL_MAPPED_REGS_ADDR   0x3FE000
#define MMU_EXTERNAL_MAPPED_REGS_LEN    0x001000

#define APERTURE_0_OFFSET   0x000000
#define APERTURE_1_OFFSET   0x080000
#define APERTURE_2_OFFSET   0x100000

// Always

#define VGA_MEMORY_ADDR                 0xA0000

#define MMU_APERTURE_2_ACL_BIT          0x04

#define MMU_PORT_IO_ADDR                0
#define MMU_PORT_IO_LEN                 0x10000


//////////////////////////////////////////////////////////////////////
// Alpha and PowerPC considerations
//
// Both the Alpha and the PowerPC do not guarantee that I/O to
// separate addresses will be executed in order.  The Alpha and
// PowerPC differ, however, in that the PowerPC guarantees that
// output to the same address will be executed in order, while the
// Alpha may cache and 'collapse' consecutive output to become only
// one output.
//
// Consequently, we use the following synchronization macros.  They
// are relatively expensive in terms of performance, so we try to avoid
// them whereever possible.
//
// CP_EIEIO() 'Ensure In-order Execution of I/O'
//    - Used to flush any pending I/O in situations where we wish to
//      avoid out-of-order execution of I/O to separate addresses.
//
// CP_MEMORY_BARRIER()
//    - Used to flush any pending I/O in situations where we wish to
//      avoid out-of-order execution or 'collapsing' of I/O to
//      the same address.  On the PowerPC, this will be defined as
//      a null operation.

#if defined(PPC)

    // On PowerPC, CP_MEMORY_BARRIER doesn't do anything.

    #define CP_EIEIO()          MEMORY_BARRIER()
    #define CP_MEMORY_BARRIER()

#else

    // On Alpha, CP_EIEIO() is the same thing as a CP_MEMORY_BARRIER().
    // On other systems, both CP_EIEIO() and CP_MEMORY_BARRIER() don't
    // do anything.

    #define CP_EIEIO()          MEMORY_BARRIER()
    #define CP_MEMORY_BARRIER() MEMORY_BARRIER()

#endif

//////////////////////////////////////////////////////////////////
// Port access macros

#define CP_OUT_DWORD(pjBase, cjOffset, ul)\
{\
    CP_TRACK;\
    WRITE_PORT_ULONG((BYTE*) pjBase + (cjOffset), (DWORD) (ul));\
    CP_EIEIO();\
}

#define CP_OUT_WORD(pjBase, cjOffset, w)\
{\
    CP_TRACK;\
    WRITE_PORT_USHORT((BYTE*) pjBase + (cjOffset), (WORD) (w));\
    CP_EIEIO();\
}

#define CP_OUT_BYTE(pjBase, cjOffset, j)\
{\
    CP_TRACK;\
    WRITE_PORT_UCHAR((BYTE*) pjBase + (cjOffset), (BYTE) (j));\
    CP_EIEIO();\
}

#define CP_IN_DWORD(pjBase, cjOffset)\
(\
    CP_TRACK,\
    READ_PORT_ULONG((BYTE*) pjBase + (cjOffset))\
)

#define CP_IN_WORD(pjBase, cjOffset)\
(\
    CP_TRACK,\
    READ_PORT_USHORT((BYTE*) pjBase + (cjOffset))\
)

#define CP_IN_BYTE(pjBase, cjOffset)\
(\
    CP_TRACK,\
    READ_PORT_UCHAR((BYTE*) pjBase + (cjOffset))\
)

//////////////////////////////////////////////////////////////////
// Memory mapped register access macros

#define CP_WRITE_DWORD(pjBase, cjOffset, ul)\
    CP_TRACK,\
    WRITE_REGISTER_ULONG((BYTE*) pjBase + (cjOffset), (DWORD) (ul))

#define CP_WRITE_WORD(pjBase, cjOffset, w)\
    CP_TRACK,\
    WRITE_REGISTER_USHORT((BYTE*) pjBase + (cjOffset), (WORD) (w))

#define CP_WRITE_BYTE(pjBase, cjOffset, j)\
    CP_TRACK,\
    WRITE_REGISTER_UCHAR((BYTE*) pjBase + (cjOffset), (BYTE) (j))

#define CP_READ_DWORD(pjBase, cjOffset)\
(\
    CP_TRACK,\
    READ_REGISTER_ULONG((BYTE*) pjBase + (cjOffset))\
)

#define CP_READ_WORD(pjBase, cjOffset)\
(\
    CP_TRACK,\
    READ_REGISTER_USHORT((BYTE*) pjBase + (cjOffset))\
)

#define CP_READ_BYTE(pjBase, cjOffset)\
(\
    CP_TRACK,\
    READ_REGISTER_UCHAR((BYTE*) pjBase + (cjOffset))\
)

//////////////////////////////////////////////////////////
// W32 ACL register access macros

//////////////////////////////////////////////////////////
// Reads

#define CP_ACL_STAT(ppdev, pjBase)\
    CP_READ_BYTE(pjBase, OFFSET_jAclStatus)

//////////////////////////////////////////////////////////
// Writes

#define CP_WRITE_MMU_DWORD(ppdev, mmu, offset, x)\
{\
    CP_WRITE_DWORD((ppdev->pjMmu##mmu), offset, (x));\
    CP_EIEIO();\
}

#define CP_WRITE_MMU_WORD(ppdev, mmu, offset, x)\
{\
    CP_WRITE_WORD((ppdev->pjMmu##mmu), offset, (x));\
    CP_EIEIO();\
}

#define CP_WRITE_MMU_BYTE(ppdev, mmu, offset, x)\
{\
    CP_WRITE_BYTE((ppdev->pjMmu##mmu), offset, (x));\
    CP_EIEIO();\
}

#define CP_MMU_BP0(ppdev, pjBase, x)\
{\
    CP_WRITE_DWORD(pjBase, OFFSET_ulMmuBasePtr0, (x));\
    CP_EIEIO();\
}

#define CP_MMU_BP1(ppdev, pjBase, x)\
{\
    CP_WRITE_DWORD(pjBase, OFFSET_ulMmuBasePtr1, (x));\
    CP_EIEIO();\
}

#define CP_MMU_BP2(ppdev, pjBase, x)\
{\
    CP_WRITE_DWORD(pjBase, OFFSET_ulMmuBasePtr2, (x));\
    CP_EIEIO();\
}

#define CP_MMU_CTRL(ppdev, pjBase, x)\
{\
    CP_WRITE_BYTE(pjBase, OFFSET_jMmuCtrl, (x));\
    CP_EIEIO();\
}

#define CP_STATE(ppdev, pjBase, x)\
{\
    CP_WRITE_BYTE(pjBase, OFFSET_jOperationState, (x));\
    CP_EIEIO();\
}

#define CP_SYNC_ENABLE(ppdev, pjBase, x)\
{\
    CP_WRITE_BYTE(pjBase, OFFSET_jSyncEnable, (x));\
    CP_EIEIO();\
}

#define CP_PAT_ADDR(ppdev, pjBase, x)\
{\
    CP_WRITE_DWORD(pjBase, OFFSET_ulPatAddr, (x));\
    CP_EIEIO();\
}

#define CP_SRC_ADDR(ppdev, pjBase, x)\
{\
    CP_WRITE_DWORD(pjBase, OFFSET_ulSrcAddr, (x));\
    CP_EIEIO();\
}

#define CP_DST_ADDR(ppdev, pjBase, x)\
{\
    CP_WRITE_DWORD(pjBase, OFFSET_ulDstAddr, (x));\
    CP_EIEIO();\
}

#define CP_MIX_ADDR(ppdev, pjBase, x)\
{\
    CP_WRITE_DWORD(pjBase, OFFSET_ulMixAddr, (x));\
    CP_EIEIO();\
}

#define CP_PAT_Y_OFFSET(ppdev, pjBase, x)\
{\
    CP_WRITE_WORD(pjBase, OFFSET_wPatYOffset, (x));\
    CP_EIEIO();\
}

#define CP_SRC_Y_OFFSET(ppdev, pjBase, x)\
{\
    CP_WRITE_WORD(pjBase, OFFSET_wSrcYOffset, (x));\
    CP_EIEIO();\
}

#define CP_DST_Y_OFFSET(ppdev, pjBase, x)\
{\
    CP_WRITE_WORD(pjBase, OFFSET_wDstYOffset, (x));\
    CP_EIEIO();\
}

#define CP_MIX_Y_OFFSET(ppdev, pjBase, x)\
{\
    CP_WRITE_WORD(pjBase, OFFSET_wMixYOffset, (x));\
    CP_EIEIO();\
}

#define CP_PEL_DEPTH(ppdev, pjBase, x)\
{\
    CP_WRITE_BYTE(pjBase, OFFSET_jPixelDepthW32P, (x));\
    CP_EIEIO();\
}

#define CP_BUS_SIZE(ppdev, pjBase, x)\
{\
    CP_WRITE_BYTE(pjBase, OFFSET_jBusSizeW32, (x));\
    CP_EIEIO();\
}

#define CP_XY_DIR(ppdev, pjBase, x)\
{\
    CP_WRITE_BYTE(pjBase, OFFSET_jXYDir, (x));\
    CP_EIEIO();\
}

#define CP_PAT_WRAP(ppdev, pjBase, x)\
{\
    CP_WRITE_BYTE(pjBase, OFFSET_jPatWrap, (x));\
    CP_EIEIO();\
}

#define CP_XFER_DISABLE(ppdev, pjBase, x)\
{\
    CP_WRITE_BYTE(pjBase, OFFSET_jXferDisable, (x));\
    CP_EIEIO();\
}

#define CP_SRC_WRAP(ppdev, pjBase, x)\
{\
    CP_WRITE_BYTE(pjBase, OFFSET_jSrcWrap, (x));\
    CP_EIEIO();\
}

#define CP_XCNT(ppdev, pjBase, x)\
{\
    CP_WRITE_WORD(pjBase, OFFSET_wXCnt, (x));\
    CP_EIEIO();\
}

#define CP_YCNT(ppdev, pjBase, x)\
{\
    CP_WRITE_WORD(pjBase, OFFSET_wYCnt, (x));\
    CP_EIEIO();\
}

#define CP_ROUTING_CTRL(ppdev, pjBase, x)\
{\
    CP_WRITE_BYTE(pjBase, OFFSET_jRoutCtrl, (x));\
    CP_EIEIO();\
}

#define CP_RELOAD_CTRL(ppdev, pjBase, x)\
{\
    CP_WRITE_BYTE(pjBase, OFFSET_jReloadCtrlW32, (x));\
    CP_EIEIO();\
}

#define CP_BK_ROP(ppdev, pjBase, x)\
{\
    CP_WRITE_BYTE(pjBase, OFFSET_jBkRop, (x));\
    CP_EIEIO();\
}

#define CP_FG_ROP(ppdev, pjBase, x)\
{\
    CP_WRITE_BYTE(pjBase, OFFSET_jFgRop, (x));\
    CP_EIEIO();\
}

#define CP_ERR_TERM(ppdev, pjBase, x)\
{\
    CP_WRITE_WORD(pjBase, OFFSET_wErrTerm, (x));\
    CP_EIEIO();\
}

#define CP_DELTA_MINOR(ppdev, pjBase, x)\
{\
    CP_WRITE_WORD(pjBase, OFFSET_wDeltaMinor, (x));\
    CP_EIEIO();\
}

#define CP_DELTA_MAJOR(ppdev, pjBase, x)\
{\
    CP_WRITE_WORD(pjBase, OFFSET_wDeltaMajor, (x));\
    CP_EIEIO();\
}

#define CP_X_POS_W32P(ppdev, pjBase, x)\
{\
    CP_WRITE_WORD(pjBase, OFFSET_wXPosW32P, (x));\
    CP_EIEIO();\
}

#define CP_Y_POS_W32P(ppdev, pjBase, x)\
{\
    CP_WRITE_WORD(pjBase, OFFSET_wYPosW32P, (x));\
    CP_EIEIO();\
}

#define CP_X_POS_W32(ppdev, pjBase, x)\
{\
    CP_WRITE_WORD(pjBase, OFFSET_wXPosW32, (x));\
    CP_EIEIO();\
}

#define CP_Y_POS_W32(ppdev, pjBase, x)\
{\
    CP_WRITE_WORD(pjBase, OFFSET_wYPosW32, (x));\
    CP_EIEIO();\
}

#define CP_ACL_CONFIG(ppdev, pjBase, x)\
{\
    CP_WRITE_WORD(pjBase, OFFSET_jConfig, (x));\
    CP_EIEIO();\
}

#define CP_ACL_POWER(ppdev, pjBase, x)\
{\
    CP_WRITE_WORD(pjBase, OFFSET_jPowerCtrl, (x));\
    CP_EIEIO();\
}

#define CP_ACL_STEP(ppdev, pjBase, x)\
{\
    CP_WRITE_WORD(pjBase, OFFSET_jSteppingCtrl, (x));\
    CP_EIEIO();\
}

//////////////////////////////////////////////////////////
// W32 video coprocessor control register offsets

#define OFFSET_ulMmuBasePtr0       0x00
#define OFFSET_ulMmuBasePtr1       0x04
#define OFFSET_ulMmuBasePtr2       0x08
#define OFFSET_jMmuCtrl            0x13
#define OFFSET_jSuspendTerminate   0x30
#define OFFSET_jOperationState     0x31
#define OFFSET_jSyncEnable         0x32
#define OFFSET_jConfig             0x32    // ET6000
#define OFFSET_jIntrMask           0x34
#define OFFSET_jIntrStatus         0x35
#define OFFSET_jAclStatus          0x36
#define OFFSET_jPowerCtrl          0x37    // ET6000
#define OFFSET_wXPosW32P           0x38    // W32p+ only
#define OFFSET_wYPosW32P           0x3A    // W32p+ only
#define OFFSET_ulPatAddr           0x80
#define OFFSET_ulSrcAddr           0x84
#define OFFSET_wPatYOffset         0x88
#define OFFSET_wSrcYOffset         0x8A
#define OFFSET_wDstYOffset         0x8C
#define OFFSET_jBusSizeW32         0x8E    // W32 and W32i only
#define OFFSET_jPixelDepthW32P     0x8E    // W32p+ only
#define OFFSET_jXYDir              0x8F
#define OFFSET_jPatWrap            0x90
#define OFFSET_jXferDisable        0x91    // ET6000
#define OFFSET_jSrcWrap            0x92
#define OFFSET_jSecondaryEdge      0x93    // ET6000
#define OFFSET_wXPosW32            0x94    // W32 and W32i only
#define OFFSET_wYPosW32            0x96    // W32 and W32i only
#define OFFSET_wXCnt               0x98
#define OFFSET_wYCnt               0x9A
#define OFFSET_jRoutCtrl           0x9C
#define OFFSET_jMixCtrl            0x9C    // ET6000
#define OFFSET_jReloadCtrlW32      0x9D    // W32 and W32i only
#define OFFSET_jSteppingCtrl       0x9D    // ET6000
#define OFFSET_jBkRop              0x9E
#define OFFSET_jFgRop              0x9F
#define OFFSET_ulDstAddr           0xA0
#define OFFSET_ulMixAddr           0xA4
#define OFFSET_wMixYOffset         0xA8
#define OFFSET_wErrTerm            0xAA
#define OFFSET_wDeltaMinor         0xAC
#define OFFSET_wDeltaMajor         0xAE
#define OFFSET_wSecErrTerm         0xB2    //  ET6000
#define OFFSET_wSecDeltaMinor      0xB4    //  ET6000
#define OFFSET_wSecDeltaMajor      0xB6    //  ET6000

typedef struct {
    ULONG   ulVgaMemAddr;
    ULONG   ulPhysMemAddr;
    ULONG   ulPhysMemLen;
    ULONG   ulPhysRegsAddr;
    ULONG   ulPhysRegsLen;
    ULONG   ulPhysPortsAddr;
    ULONG   ulPhysPortsLen;
    ULONG   ulPhysExtrnMapRegAddr;
    ULONG   ulPhysExtrnMapRegLen;

    PVOID   pvMemoryBufferVirtualAddr;
    PVOID   pvMemoryMappedRegisterVirtualAddr;
    PVOID   pvPortsVirtualAddr;
    PVOID   pvExternalRegistersVirtualAddr;
} W32MMUINFO, *PW32MMUINFO;

//////////////////////////////////////////////////////////
// Virtual bus size

#define VIRTUAL_BUS_8_BIT   0x00
#define VIRTUAL_BUS_16_BIT  0x01
#define VIRTUAL_BUS_32_BIT  0x02

#define HW_PEL_DEPTH_8BPP   0x00
#define HW_PEL_DEPTH_16BPP  0x10
#define HW_PEL_DEPTH_24BPP  0x20
#define HW_PEL_DEPTH_32BPP  0x30

//////////////////////////////////////////////////////////
// Routing control

#define CPU_SOURCE_DATA     0x01
#define CPU_MIX_DATA        0x02
#define CPU_X_COUNT         0x04
#define CPU_Y_COUNT         0x05

//////////////////////////////////////////////////////////
// X/Y direction

#define BOTTOM_TO_TOP   0x02
#define RIGHT_TO_LEFT   0x01

#define TBLR    0x00
#define TBRL    0x01
#define BTLR    0x02
#define BTRL    0x03

//////////////////////////////////////////////////////////
// Pattern/Source wrap

#define NO_PATTERN_WRAP                     0x77
    
#define SOLID_COLOR_PATTERN_WRAP            0x02
#define SOLID_COLOR_PATTERN_OFFSET          0x04
#define SOLID_COLOR_PATTERN_WRAP_24BPP      0x0A
#define SOLID_COLOR_PATTERN_OFFSET_24BPP    0x03
    
#define PATTERN_WRAP_8x8                    0x33
#define PATTERN_WRAP_16x8                   0x34
#define PATTERN_WRAP_32x8                   0x35
    
#define PATTERN_WIDTH                       0x08
#define PATTERN_HEIGHT                      0x08
#define PATTERN_SIZE                        (PATTERN_WIDTH*PATTERN_HEIGHT)
#define PATTERN_OFFSET                      PATTERN_WIDTH

//////////////////////////////////////////////////////////
// W32 H/W pointer (sprite) data.

typedef struct {
    POINTL  ptlHot,
            ptlLast;
    SIZEL   szlPointer;
    FLONG   fl;
} W32SPRITEDATA, *PW32SPRITEDATA;

#define POINTER_DISABLED    0X01

//////////////////////////////////////////////////////////
// Some handy clipping control structures.

typedef struct {
    ULONG   c;
    RECTL   arcl[8];
} ENUMRECTS8, *PENUMRECTS8;

////////////////////////////////////////////////////////////////////////////
// The following will spin until there is room in the ACL command queue for
// another blt command.

#define WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase)  \
{                                                \
    while (CP_ACL_STAT(ppdev, pjBase) & 0x01);   \
}

////////////////////////////////////////////////////////////////////////////
// The following will spin until the ACL has processed all queued commands.

#define WAIT_FOR_IDLE_ACL(ppdev, pjBase)         \
{                                                \
    while (CP_ACL_STAT(ppdev, pjBase) & 0x02);   \
}

////////////////////////////////////////////////////////////////////////////
// The following will return TRUE if the FIFO is full.

#define FIFO_BUSY(ppdev, pjBase)        \
    (CP_ACL_STAT(ppdev, pjBase) & 0x01) \

////////////////////////////////////////////////////////////////////////////
// The following will return TRUE if the ACL is busy at the moment.

#define IS_BUSY(ppdev, pjBase)          \
    (CP_ACL_STAT(ppdev, pjBase) & 0x02) \

////////////////////////////////////////////////////////////////////////////
// The following will spin until the ACL starts processing a command.

#define WAIT_FOR_BUSY_ACL(ppdev, pjBase)            \
{                                                   \
    while (!(CP_ACL_STAT(ppdev, pjBase) & 0x02));   \
}

////////////////////////////////////////////////////////////////////////////
// The following will spin until the vertical retrace occurs.

#define WAIT_FOR_VERTICAL_RETRACE                   \
{                                                   \
    while ( (INP(0x3DA) & 0x08));                   \
    while (!(INP(0x3DA) & 0x08));                   \
}                                                   \

////////////////////////////////////////////////////////////////////////////
// The following synchronize framebuffer access with the accelerator

#define START_DIRECT_ACCESS(ppdev, pjBase)\
{\
    WAIT_FOR_IDLE_ACL(ppdev, pjBase);\
}

#define END_DIRECT_ACCESS(ppdev, pjBase)\
{\
    CP_EIEIO();\
}

//////////////////////////////////////////////////////////
//  Made a change to check for >= W32P so that the ET6000 could be handled
//  correctly by this macro.  It is more efficient than checking for both
//  chip types.  Keep in mind that this macro may have to be modified to
//  properly handle future chips.

#define SET_DEST_ADDR(ppdev, addr)                              \
{                                                               \
    BYTE* pjBase = ppdev->pjBase;                               \
                                                                \
    if (ppdev->ulChipID >= W32P)                                \
    {                                                           \
        CP_DST_ADDR(ppdev, pjBase, (addr)+ppdev->xyOffset);     \
    }                                                           \
    else                                                        \
    {                                                           \
        CP_MMU_BP2(ppdev, pjBase, ((addr)+ppdev->xyOffset));    \
    }                                                           \
}

#define SET_DEST_ADDR_ABS(ppdev, addr)                          \
{                                                               \
    BYTE* pjBase = ppdev->pjBase;                               \
                                                                \
    if (ppdev->ulChipID >= W32P)                                \
    {                                                           \
        CP_DST_ADDR(ppdev, pjBase, (addr));                     \
    }                                                           \
    else                                                        \
    {                                                           \
        CP_MMU_BP2(ppdev, pjBase, (addr));                      \
    }                                                           \
}

#define START_ACL(ppdev)                    \
{                                           \
    if (ppdev->ulChipID < W32P)             \
    {                                       \
        CP_WRITE_MMU_BYTE(ppdev, 2, 0, 0);  \
    }                                       \
}

#define SET_FG_COLOR(ppdev,color)                                               \
{                                                                               \
    BYTE* pjBase = ppdev->pjBase;                                               \
    LONG     cBpp = ppdev->cBpp;                                                \
                                                                                \
    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);                                    \
    CP_PAT_WRAP(ppdev, pjBase, SOLID_COLOR_PATTERN_WRAP);                       \
    CP_PAT_Y_OFFSET(ppdev, pjBase, (SOLID_COLOR_PATTERN_OFFSET - 1));           \
    CP_PAT_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset);                      \
                                                                                \
    {                                                                           \
        ULONG ulSolidColor;                                                     \
                                                                                \
        WAIT_FOR_IDLE_ACL(ppdev, pjBase);                                       \
        CP_MMU_BP0(ppdev, pjBase, ppdev->ulSolidColorOffset);                   \
                                                                                \
        ulSolidColor = color;                                                   \
                                                                                \
        if (cBpp == 1)                                                          \
        {                                                                       \
            ulSolidColor |= ulSolidColor << 8;                                  \
        }                                                                       \
        if (cBpp <= 2)                                                          \
        {                                                                       \
            ulSolidColor |= ulSolidColor << 16;                                 \
        }                                                                       \
                                                                                \
        CP_WRITE_MMU_DWORD(ppdev, 0, 0, ulSolidColor);                          \
    }                                                                           \
}

//////////////////////////////////////////////////////////
// CRTCB/Sprite defines port definitions.

#define CRTCB_SPRITE_HORZ_POSITION_LOW      0xE0
#define CRTCB_SPRITE_HORZ_POSITION_HIGH     0xE1
#define CRTCB_WIDTH_LOW_SPRITE_HORZ_PRESET  0xE2
#define CRTCB_WIDTH_HIGH                    0xE3
#define CRTCB_SPRITE_VERT_POSITION_LOW      0xE4
#define CRTCB_SPRITE_VERT_POSITION_HIGH     0xE5
#define CRTCB_HEIGHT_LOW_SPRITE_VERT_PRESET 0xE6
#define CRTCB_HEIGHT_HIGH                   0xE7
#define CRTCB_SPRITE_START_ADDR_LOW         0xE8
#define CRTCB_SPRITE_START_ADDR_MEDIUM      0xE9
#define CRTCB_SPRITE_START_ADDR_HIGH        0xEA
#define CRTCB_SPRITE_ROW_OFFSET_LOW         0xEB
#define CRTCB_SPRITE_ROW_OFFSET_HIGH        0xEC
#define CRTCB_PIXEL_PANNING                 0xED
#define CRTCB_COLOR_DEPTH                   0xEE
#define CRTCB_SPRITE_CONTROL                0xEF

//  ET6000 specific sprite equates.  These are offsets into the
//  PCI configuration space.
//
#define ET6K_SPRITE_HORZ_PRESET             0x82
#define ET6K_SPRITE_VERT_PRESET             0x83
#define ET6K_SPRITE_HORZ_POS_LOW            0x84
#define ET6K_SPRITE_HORZ_POS_HIGH           0x85
#define ET6K_SPRITE_VERT_POS_LOW            0x86
#define ET6K_SPRITE_VERT_POS_HIGH           0x87
#define ET6K_SPRITE_ADDR_LOW                0x0F
#define ET6K_SPRITE_ADDR_HIGH               0x0E
#define ET6K_SPRITE_ENABLE_PORT             0x46
#define ET6K_SPRITE_ENABLE_BIT              0x01

//////////////////////////////////////////////////////////
// The following enable is documented as part of the IMA port.
// It's true, the facts are stranger than fiction.

#define CRTCB_SPRITE_ENABLE_PORT            0xF7
#define CRTCB_SPRITE_ENABLE_BIT             0x80

//////////////////////////////////////////////////////////
// Some handy macros for sprite manipulation

#define SPRITE_BUFFER_SIZE  0x4400

//////////////////////////////////////////////////////////
// There are bugs in the W32 that require enabling or
// disabling the cursor during vertical retrace.

#define ENABLE_SPRITE(ppdev)                            \
{                                                       \
    BYTE    byte;                                       \
    ppdev->W32SpriteData.fl &= ~POINTER_DISABLED;       \
    if (ppdev->ulChipID != ET6000)                      \
    {                                                   \
        if (ppdev->ulChipID == W32)                         \
        {                                                   \
            WAIT_FOR_VERTICAL_RETRACE;                      \
        }                                                   \
        OUTP(CRTCB_SPRITE_INDEX, CRTCB_SPRITE_ENABLE_PORT); \
        byte = INP(CRTCB_SPRITE_DATA);                      \
        byte |= CRTCB_SPRITE_ENABLE_BIT;                    \
        OUTP(CRTCB_SPRITE_DATA, byte);                      \
    }\
    else                                                    \
    {                                                       \
        byte = INP(ppdev->PCIConfigSpaceAddr + ET6K_SPRITE_ENABLE_PORT);\
        byte |= ET6K_SPRITE_ENABLE_BIT;                     \
        OUTP(ppdev->PCIConfigSpaceAddr + ET6K_SPRITE_ENABLE_PORT, byte);\
    }                                                       \
}

#define DISABLE_SPRITE(ppdev)                           \
{                                                       \
    BYTE    byte;                                       \
    ppdev->W32SpriteData.fl |= POINTER_DISABLED;        \
    if (ppdev->ulChipID != ET6000)                      \
    {                                                   \
        if (ppdev->ulChipID == W32)                         \
        {                                                   \
            WAIT_FOR_VERTICAL_RETRACE;                      \
        }                                                   \
        OUTP(CRTCB_SPRITE_INDEX, CRTCB_SPRITE_ENABLE_PORT); \
        byte = INP(CRTCB_SPRITE_DATA);                      \
        byte &= ~CRTCB_SPRITE_ENABLE_BIT;                   \
        OUTP(CRTCB_SPRITE_DATA, byte);                      \
    }\
    else                                                    \
    {                                                       \
        byte = INP(ppdev->PCIConfigSpaceAddr + ET6K_SPRITE_ENABLE_PORT);\
        byte &= ~ET6K_SPRITE_ENABLE_BIT;                    \
        OUTP(ppdev->PCIConfigSpaceAddr + ET6K_SPRITE_ENABLE_PORT, byte);\
    }                                                       \
}

#define SET_HORZ_POSITION(val)                                  \
{                                                               \
    OUTP(CRTCB_SPRITE_INDEX, CRTCB_SPRITE_HORZ_POSITION_LOW);   \
    OUTP(CRTCB_SPRITE_DATA, LOBYTE(val));                       \
    OUTP(CRTCB_SPRITE_INDEX, CRTCB_SPRITE_HORZ_POSITION_HIGH);  \
    OUTP(CRTCB_SPRITE_DATA, HIBYTE(val));                       \
}

#define SET_VERT_POSITION(val)                                  \
{                                                               \
    OUTP(CRTCB_SPRITE_INDEX, CRTCB_SPRITE_VERT_POSITION_LOW);   \
    OUTP(CRTCB_SPRITE_DATA, LOBYTE(val));                       \
    OUTP(CRTCB_SPRITE_INDEX, CRTCB_SPRITE_VERT_POSITION_HIGH);  \
    OUTP(CRTCB_SPRITE_DATA, HIBYTE(val));                       \
}

#define SET_HORZ_PRESET(val)                                      \
{                                                                 \
    OUTP(CRTCB_SPRITE_INDEX, CRTCB_WIDTH_LOW_SPRITE_HORZ_PRESET); \
    OUTP(CRTCB_SPRITE_DATA, LOBYTE(val));                         \
    OUTP(CRTCB_SPRITE_INDEX, CRTCB_WIDTH_HIGH);                   \
    OUTP(CRTCB_SPRITE_DATA, 0);                                   \
}

#define SET_VERT_PRESET(val)                                       \
{                                                                  \
    OUTP(CRTCB_SPRITE_INDEX, CRTCB_HEIGHT_LOW_SPRITE_VERT_PRESET); \
    OUTP(CRTCB_SPRITE_DATA, LOBYTE(val));                          \
    OUTP(CRTCB_SPRITE_INDEX, CRTCB_HEIGHT_HIGH);                   \
    OUTP(CRTCB_SPRITE_DATA, 0);                                    \
}

#define SET_SPRITE_START_ADDR(val)                              \
{                                                               \
    ULONG ulAddr;                                               \
    ulAddr = val >> 2;                                          \
    OUTP(CRTCB_SPRITE_INDEX, CRTCB_SPRITE_START_ADDR_LOW);      \
    OUTP(CRTCB_SPRITE_DATA, LOWORD(LOBYTE(ulAddr)));            \
    OUTP(CRTCB_SPRITE_INDEX, CRTCB_SPRITE_START_ADDR_MEDIUM);   \
    OUTP(CRTCB_SPRITE_DATA, LOWORD(HIBYTE(ulAddr)));            \
    OUTP(CRTCB_SPRITE_INDEX, CRTCB_SPRITE_START_ADDR_HIGH);     \
    OUTP(CRTCB_SPRITE_DATA, LOBYTE(HIWORD(ulAddr)));            \
}

#define SET_SPRITE_ROW_OFFSET                                   \
{                                                               \
    OUTP(CRTCB_SPRITE_INDEX, CRTCB_SPRITE_ROW_OFFSET_LOW);      \
    OUTP(CRTCB_SPRITE_DATA, 2);                                 \
    OUTP(CRTCB_SPRITE_INDEX, CRTCB_SPRITE_ROW_OFFSET_HIGH);     \
    OUTP(CRTCB_SPRITE_DATA, 0);                                 \
}

#define ET6K_SPRITE_HORZ_POSITION(ppdev, x)                     \
{                                                               \
    OUTP(ppdev->PCIConfigSpaceAddr + ET6K_SPRITE_HORZ_POS_LOW, (x & 0x00FF));\
    OUTP(ppdev->PCIConfigSpaceAddr + ET6K_SPRITE_HORZ_POS_HIGH, (x >> 8));\
}
#define ET6K_SPRITE_VERT_POSITION(ppdev, y)                     \
{                                                               \
    OUTP(ppdev->PCIConfigSpaceAddr + ET6K_SPRITE_VERT_POS_LOW, (y & 0x00FF));\
    OUTP(ppdev->PCIConfigSpaceAddr + ET6K_SPRITE_VERT_POS_HIGH, (y >> 8));\
}
#define ET6K_HORZ_PRESET(ppdev, x);                             \
{                                                               \
    OUTP(ppdev->PCIConfigSpaceAddr + ET6K_SPRITE_HORZ_PRESET, (x));\
}
#define ET6K_VERT_PRESET(ppdev, y)                              \
{                                                               \
    OUTP(ppdev->PCIConfigSpaceAddr + ET6K_SPRITE_VERT_PRESET, (y));\
}

//
//  The ET6000 sprite start address is specified in DWORDS.  We have a buffer
//  of 256 dwords at the end of video memory which contains the sprite data.
//  Since this aligns us to a 1K boundary, we can be sure that by simply
//  discarding the lower 10 bits of the address that we won't be losing
//  anything.
//
#define ET6K_SPRITE_START_ADDR(ppdev, addr)                     \
{                                                               \
    OUTP(CRTC_INDEX, ET6K_SPRITE_ADDR_HIGH);                    \
    OUTP(CRTC_DATA, ((addr >> 18) & 0x0FF));                    \
    OUTP(CRTC_INDEX, ET6K_SPRITE_ADDR_LOW);                     \
    OUTP(CRTC_DATA, ((addr >> 10) & 0x0FF));                    \
}
#define ET6K_SPRITE_COLOR(ppdev, color)                         \
{                                                               \
    OUTP(ppdev->PCIConfigSpaceAddr + 0x67, 9);                  \
    OUTP(ppdev->PCIConfigSpaceAddr + 0x69, color & 0x00FF);     \
    OUTP(ppdev->PCIConfigSpaceAddr + 0x69, color >> 8);         \
}

////////////////////////////////////////////////////////////////////////
// Chip equates

#define STATUS_1    0x03DA
#define VSY_NOT     0x0008

#define ENABLE_KEY(ppdev)                           \
{                                                   \
    CP_OUT_BYTE(ppdev->pjPorts,(0x03D8),(0x00));    \
    CP_OUT_BYTE(ppdev->pjPorts,(0x03BF),(0x01));    \
}

#define DISABLE_KEY(ppdev)                          \
{                                                   \
    CP_OUT_BYTE(ppdev->pjPorts,(0x03BF),(0x03));    \
    CP_OUT_BYTE(ppdev->pjPorts,(0x03D8),(0xa0));    \
}

#define OUTPW(p, v)          CP_OUT_WORD(ppdev->pjPorts,(p),(v))
#define OUTP(p, v)           CP_OUT_BYTE(ppdev->pjPorts,(p),(v))
#define INPW(p)              CP_IN_WORD(ppdev->pjPorts,(p))
#define INP(p)               CP_IN_BYTE(ppdev->pjPorts,(p))

//////////////////////////////////////////////////////////
// Rop definitions for the hardware

#define R3_SRCCOPY          0xCC    /* dest = source                   */
#define R3_SRCPAINT         0xEE    /* dest = source OR dest           */
#define R3_SRCAND           0x88    /* dest = source AND dest          */
#define R3_SRCINVERT        0x66    /* dest = source XOR dest          */
#define R3_SRCERASE         0x44    /* dest = source AND (NOT dest )   */
#define R3_NOTSRCCOPY       0x33    /* dest = (NOT source)             */
#define R3_NOTSRCERASE      0x11    /* dest = (NOT src) AND (NOT dest) */
#define R3_MERGECOPY        0xC0    /* dest = (source AND pattern)     */
#define R3_MERGEPAINT       0xBB    /* dest = (NOT source) OR dest     */
#define R3_PATCOPY          0xF0    /* dest = pattern                  */
#define R3_PATPAINT         0xFB    /* dest = DPSnoo                   */
#define R3_PATINVERT        0x5A    /* dest = pattern XOR dest         */
#define R3_DSTINVERT        0x55    /* dest = (NOT dest)               */
#define R3_BLACKNESS        0x00    /* dest = BLACK                    */
#define R3_WHITENESS        0xFF    /* dest = WHITE                    */

#define R4_SRCCOPY          0xCCCC  /* dest = source                   */
#define R4_SRCPAINT         0xEEEE  /* dest = source OR dest           */
#define R4_SRCAND           0x8888  /* dest = source AND dest          */
#define R4_SRCINVERT        0x6666  /* dest = source XOR dest          */
#define R4_SRCERASE         0x4444  /* dest = source AND (NOT dest )   */
#define R4_NOTSRCCOPY       0x3333  /* dest = (NOT source)             */
#define R4_NOTSRCERASE      0x1111  /* dest = (NOT src) AND (NOT dest) */
#define R4_MERGECOPY        0xC0C0  /* dest = (source AND pattern)     */
#define R4_MERGEPAINT       0xBBBB  /* dest = (NOT source) OR dest     */
#define R4_PATCOPY          0xF0F0  /* dest = pattern                  */
#define R4_PATPAINT         0xFBFB  /* dest = DPSnoo                   */
#define R4_PATINVERT        0x5A5A  /* dest = pattern XOR dest         */
#define R4_DSTINVERT        0x5555  /* dest = (NOT dest)               */
#define R4_BLACKNESS        0x0000  /* dest = BLACK                    */
#define R4_WHITENESS        0xFFFF  /* dest = WHITE                    */

#define R3_NOP              0xAA    /* dest = dest                     */
#define R4_XPAR_EXPAND      0xCCAA  /* dest = source (where src is 1)  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\driver.h ===
/******************************Module*Header*******************************\
* Module Name: driver.h
*
* Contains prototypes for the display driver.
*
* Copyright (c) 1992-1996 Microsoft Corporation
\**************************************************************************/

//////////////////////////////////////////////////////////////////////
// Warning:  The following define is for private use only.  It should
//           only be used in such a fashion that when defined as 0,
//           all code specific to punting is optimized out completely.
//
//           ### Not sure if this should go in or not.

#define DRIVER_PUNT_ALL         0
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Put all the conditional-compile constants here.  There had better
// not be many!

// Set this bit when GDI's HOOK_SYNCHRONIZEACCESS works so that we don't
// have to worry about synchronizing device-bitmap access.  Note that
// this wasn't an option in the first release of NT:

#define SYNCHRONIZEACCESS_WORKS 1

#define DIRECT_ACCESS(ppdev)    1

// When running on an x86, we can make banked call-backs to GDI where
// GDI can write directly on the frame buffer.  The Alpha has a weird
// bus scheme, and can't do that:

#if !defined(_ALPHA_)
    #define GDI_BANKING         1
#else
    #define GDI_BANKING         1   // was 0
#endif

// Both fast and slow patterns are enabled by default:

#define FASTFILL_PATTERNS       1
#define SLOWFILL_PATTERNS       1

// Useful for visualizing the 2-d heap:

#define DEBUG_HEAP              0

//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#define DLL_NAME                L"w32"      // Name of the DLL in UNICODE

#define STANDARD_DEBUG_PREFIX   "W32: "     // All debug output is prefixed
                                            //   by this string
#define ALLOC_TAG               '23WD'        // Four byte tag (characters in
                                              // reverse order) used for memory
                                              // allocations

#define CLIP_LIMIT          50  // We'll be taking 800 bytes of stack space

#define DRIVER_EXTRA_SIZE   0   // Size of the DriverExtra information in the
                                //   DEVMODE structure

#define TMP_BUFFER_SIZE     8192  // Size in bytes of 'pvTmpBuffer'.  Has to
                                  //   be at least enough to store an entire
                                  //   scan line (i.e., 6400 for 1600x1200x32).

#if defined(ALPHA)
    #define XFER_BUFFERS    16  // Defines the maximum number of write buffers
                                //   possible on any Alpha.  Must be a power
#else                           //   of two.
    #define XFER_BUFFERS    1   // On non-alpha systems, we don't have to
                                //   worry about the chip caching our bus
#endif                          //   writes.

#define XFER_MASK           (XFER_BUFFERS - 1)

typedef struct _CLIPENUM {
    LONG    c;
    RECTL   arcl[CLIP_LIMIT];   // Space for enumerating complex clipping

} CLIPENUM;                         /* ce, pce */

typedef struct _PDEV PDEV;      // Handy forward declaration

VOID vSetClipping(PDEV*, RECTL*);
VOID vResetClipping(PDEV*);

//////////////////////////////////////////////////////////////////////
// Text stuff

typedef struct _XLATECOLORS {       // Specifies foreground and background
ULONG   iBackColor;                 //   colours for faking a 1bpp XLATEOBJ
ULONG   iForeColor;
} XLATECOLORS;                          /* xlc, pxlc */

BOOL bEnableText(PDEV*);
VOID vDisableText(PDEV*);
VOID vAssertModeText(PDEV*, BOOL);

VOID vFastText(GLYPHPOS*, ULONG, BYTE*, ULONG, ULONG, RECTL*, RECTL*,
               FLONG, RECTL*, RECTL*);
VOID vClearMemDword(ULONG*, ULONG);

//////////////////////////////////////////////////////////////////////
// Dither stuff

// Describes a single colour tetrahedron vertex for dithering:

typedef struct _VERTEX_DATA {
    ULONG ulCount;              // Number of pixels in this vertex
    ULONG ulVertex;             // Vertex number
} VERTEX_DATA;                      /* vd, pv */

VERTEX_DATA*    vComputeSubspaces(ULONG, VERTEX_DATA*);
VOID            vDitherColor(ULONG*, VERTEX_DATA*, VERTEX_DATA*, ULONG);

//////////////////////////////////////////////////////////////////////
// Brush stuff

// 'Slow' brushes are used when we don't have hardware pattern capability,
// and we have to handle patterns using screen-to-screen blts:


#define SLOW_BRUSH_CACHE_DIM    3   // Controls the number of brushes cached
                                    //   in off-screen memory, when we don't
                                    //   have the W32 hardware pattern support.
                                    //   We allocate 3 x 3 brushes, so we can
                                    //   cache a total of 9 brushes:
#define SLOW_BRUSH_COUNT        (SLOW_BRUSH_CACHE_DIM * SLOW_BRUSH_CACHE_DIM)
#define SLOW_BRUSH_DIMENSION    64  // After alignment is taken care of,
                                    //   every off-screen brush cache entry
                                    //   will be 64 pels in both dimensions
#define SLOW_BRUSH_ALLOCATION   (SLOW_BRUSH_DIMENSION + 8)
                                    // Actually allocate 72x72 pels for each
                                    //   pattern, using the 8 extra for brush
                                    //   alignment

// 'Fast' brushes are used when we have hardware pattern capability:

#define FAST_BRUSH_COUNT        16  // Total number of non-hardware brushes
                                    //   cached off-screen
#define FAST_BRUSH_DIMENSION    8   // Every off-screen brush cache entry
                                    //   is 8 pels in both dimensions
#define FAST_BRUSH_ALLOCATION   8   // We have to align ourselves, so this is
                                    //   the dimension of each brush allocation

// Common to both implementations:

#define RBRUSH_2COLOR           1   // For RBRUSH flags

#define TOTAL_BRUSH_COUNT       max(FAST_BRUSH_COUNT, SLOW_BRUSH_COUNT)
                                    // This is the maximum number of brushes
                                    //   we can possibly have cached off-screen
#define TOTAL_BRUSH_SIZE        64  // We'll only ever handle 8x8 patterns,
                                    //   and this is the number of pels

typedef struct _BRUSHENTRY BRUSHENTRY;

// NOTE: Changes to the RBRUSH or BRUSHENTRY structures must be reflected
//       in strucs.inc!

typedef struct _RBRUSH {
    FLONG       fl;             // Type flags
    BOOL        bTransparent;   // TRUE if brush was realized for a transparent
                                //   blt (meaning colours are white and black),
                                //   FALSE if not (meaning it's already been
                                //   colour-expanded to the correct colours).
                                //   Value is undefined if the brush isn't
                                //   2 colour.
    ULONG       ulForeColor;    // Foreground colour if 1bpp
    ULONG       ulBackColor;    // Background colour if 1bpp
    POINTL      ptlBrushOrg;    // Brush origin of cached pattern.  Initial
                                //   value should be -1
    BRUSHENTRY* pbe;            // Points to brush-entry that keeps track
                                //   of the cached off-screen brush bits
    ULONG       aulPattern[1];  // Open-ended array for keeping copy of the
      // Don't put anything     //   actual pattern bits in case the brush
      //   after here, or       //   origin changes, or someone else steals
      //   you'll be sorry!     //   our brush entry (declared as a ULONG
                                //   for proper dword alignment)

} RBRUSH;                           /* rb, prb */

typedef struct _BRUSHENTRY {
    RBRUSH*     prbVerify;      // We never dereference this pointer to
                                //   find a brush realization; it is only
                                //   ever used in a compare to verify
                                //   that for a given realized brush, our
                                //   off-screen brush entry is still valid.
    LONG        x;              // x-position of cached pattern
    LONG        y;              // y-position of cached pattern

} BRUSHENTRY;                       /* be, pbe */

typedef union _RBRUSH_COLOR {
    RBRUSH*     prb;
    ULONG       iSolidColor;
} RBRUSH_COLOR;                     /* rbc, prbc */

BOOL bEnableBrushCache(PDEV*);
VOID vDisableBrushCache(PDEV*);
VOID vAssertModeBrushCache(PDEV*, BOOL);

//////////////////////////////////////////////////////////////////////
// Stretch stuff

typedef struct _STR_BLT {
    PDEV*   ppdev;
    PBYTE   pjSrcScan;
    LONG    lDeltaSrc;
    LONG    XSrcStart;
    PBYTE   pjDstScan;
    LONG    lDeltaDst;
    LONG    XDstStart;
    LONG    XDstEnd;
    LONG    YDstStart;
    LONG    YDstCount;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
} STR_BLT;

typedef VOID (*PFN_DIRSTRETCH)(STR_BLT*);

VOID vDirectStretch8Narrow(STR_BLT*);
VOID vDirectStretch8(STR_BLT*);
VOID vDirectStretch16(STR_BLT*);
VOID vDirectStretch32(STR_BLT*);

/////////////////////////////////////////////////////////////////////////
// Heap stuff

typedef enum {
    OH_FREE = 0,        // The off-screen allocation is available for use
    OH_DISCARDABLE,     // The allocation is occupied by a discardable bitmap
                        //   that may be moved out of off-screen memory
    OH_PERMANENT,       // The allocation is occupied by a permanent bitmap
                        //   that cannot be moved out of off-screen memory
} OHSTATE;

typedef struct _DSURF DSURF;
typedef struct _OH OH;
typedef struct _OH
{
    OHSTATE  ohState;       // State of off-screen allocation
    LONG     x;             // x-coordinate of left edge of allocation
    LONG     y;             // y-coordinate of top edge of allocation
    LONG     xy;            // y-coordinate of top edge of allocation
    LONG     cx;            // Width in pixels of allocation
    LONG     cy;            // Height in pixels of allocation
    LONG     cxReserved;    // Dimensions of original reserved rectangle;
    LONG     cyReserved;    //   zero if rectangle is not 'reserved'
    OH*      pohNext;       // When OH_FREE or OH_RESERVE, points to the next
                            //   free node, in ascending cxcy value.  This is
                            //   kept as a circular doubly-linked list with a
                            //   sentinel at the end.
                            // When OH_DISCARDABLE, points to the next most
                            //   recently created allocation.  This is kept as
                            //   a circular doubly-linked list.
    OH*      pohPrev;       // Opposite of 'pohNext'
    ULONG    cxcy;          // Width and height in a dword for searching
    OH*      pohLeft;       // Adjacent allocation when in-use or available
    OH*      pohUp;
    OH*      pohRight;
    OH*      pohDown;
    DSURF*   pdsurf;        // Points to our DSURF structure
    VOID*    pvScan0;       // Points to start of first scan-line
};                              /* oh, poh */

// This is the smallest structure used for memory allocations:

typedef struct _OHALLOC OHALLOC;
typedef struct _OHALLOC
{
    OHALLOC* pohaNext;
    OH       aoh[1];
} OHALLOC;                      /* oha, poha */

typedef struct _HEAP
{
    LONG     cxMax;         // Largest possible free space by area
    LONG     cyMax;
    OH       ohFree;        // Head of the free list, containing those
                            //   rectangles in off-screen memory that are
                            //   available for use.  pohNext points to
                            //   hte smallest available rectangle, and pohPrev
                            //   points to the largest available rectangle,
                            //   sorted by cxcy.
    OH       ohDiscardable; // Head of the discardable list that contains all
                            //   bitmaps located in offscreen memory that
                            //   are eligible to be tossed out of the heap.
                            //   It is kept in order of creation: pohNext
                            //   points to the most recently created; pohPrev
                            //   points to the least recently created.
    OH       ohPermanent;   // List of permanently allocated rectangles
    OH*      pohFreeList;   // List of OH node data structures available
    OHALLOC* pohaChain;     // Chain of allocations
} HEAP;                         /* heap, pheap */

typedef enum {
    DT_SCREEN,              // Surface is kept in screen memory
    DT_DIB                  // Surface is kept as a DIB
} DSURFTYPE;                    /* dt, pdt */

typedef struct _DSURF
{
    DSURFTYPE dt;           // DSURF status (whether off-screen or in a DIB)
    SIZEL     sizl;         // Size of the original bitmap (could be smaller
                            //   than poh->sizl)
    PDEV*     ppdev;        // Need this for deleting the bitmap
    union {
        OH*         poh;    // If DT_SCREEN, points to off-screen heap node
        SURFOBJ*    pso;    // If DT_DIB, points to locked GDI surface
    };

    // The following are used for DT_DIB only...

    ULONG     cBlt;         // Counts down the number of blts necessary at
                            //   the current uniqueness before we'll consider
                            //   putting the DIB back into off-screen memory
    ULONG     iUniq;        // Tells us whether there have been any heap
                            //   'free's since the last time we looked at
                            //   this DIB

} DSURF;                          /* dsurf, pdsurf */

// GDI expects dword alignment for any bitmaps on which it is expected
// to draw.  Since we occasionally ask GDI to draw directly on our off-
// screen bitmaps, this means that any off-screen bitmaps must be dword
// aligned in the frame buffer.  We enforce this merely by ensuring that
// all off-screen bitmaps are four-pel aligned (we may waste a couple of
// pixels at the higher colour depths):

#define HEAP_X_ALIGNMENT    4

// Number of blts necessary before we'll consider putting a DIB DFB back
// into off-screen memory:

#define HEAP_COUNT_DOWN     6

// Flags for 'pohAllocate':

typedef enum {
    FLOH_ONLY_IF_ROOM       = 0x0001,   // Don't kick stuff out of off-
                                        //   screen memory to make room
    FLOH_MAKE_PERMANENT     = 0x0002,   // Allocate a permanent entry
    FLOH_RESERVE            = 0x0004,   // Allocate an off-screen entry,
                                        //   but let it be used by discardable
                                        //   bitmaps until it's needed
} FLOH;

// Publicly callable heap APIs:

OH*  pohAllocate(PDEV*, POINTL*, LONG, LONG, FLOH);
BOOL bOhCommit(PDEV*, OH*, BOOL);
OH*  pohFree(PDEV*, OH*);

OH*  pohMoveOffscreenDfbToDib(PDEV*, OH*);
BOOL bMoveDibToOffscreenDfbIfRoom(PDEV*, DSURF*);
BOOL bMoveAllDfbsFromOffscreenToDibs(PDEV* ppdev);

BOOL bEnableOffscreenHeap(PDEV*);
VOID vDisableOffscreenHeap(PDEV*);
BOOL bAssertModeOffscreenHeap(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Bank manager stuff

#define BANK_DATA_SIZE  80      // Number of bytes to allocate for the
                                //   miniport down-loaded bank code working
                                //   space

typedef struct _BANK
{
    // Private data:

    RECTL    rclDraw;           // Rectangle describing the remaining undrawn
                                //   portion of the drawing operation
    RECTL    rclSaveBounds;     // Saved from original CLIPOBJ for restoration
    BYTE     iSaveDComplexity;  // Saved from original CLIPOBJ for restoration
    BYTE     fjSaveOptions;     // Saved from original CLIPOBJ for restoration
    LONG     iBank;             // Current bank
    PDEV*    ppdev;             // Saved copy

    // Public data:

    SURFOBJ* pso;               // Surface wrapped around the bank.  Has to be
                                //   passed as the surface in any banked call-
                                //   back.
    CLIPOBJ* pco;               // Clip object that is the intersection of the
                                //   original clip object with the bounds of the
                                //   current bank.  Has to be passed as the clip
                                //   object in any banked call-back.

} BANK;                         /* bnk, pbnk */

typedef enum {
    BANK_OFF = 0,       // We've finished using the memory aperture
    BANK_ON,            // We're about to use the memory aperture
    BANK_DISABLE,       // We're about to enter full-screen; shut down banking
    BANK_ENABLE,        // We've exited full-screen; re-enable banking

} BANK_MODE;                    /* bankm, pbankm */

typedef VOID (FNBANKMAP)(PDEV*, LONG);
typedef VOID (FNBANKSELECTMODE)(PDEV*, BANK_MODE);
typedef VOID (FNBANKINITIALIZE)(PDEV*, BOOL);
typedef BOOL (FNBANKCOMPUTE)(PDEV*, RECTL*, RECTL*, LONG*, LONG*);

VOID vBankStart(PDEV*, RECTL*, CLIPOBJ*, BANK*);
BOOL bBankEnum(BANK*);

FNBANKCOMPUTE bBankComputeNonPower2;
FNBANKCOMPUTE bBankComputePower2;

BOOL bEnableBanking(PDEV*);
VOID vDisableBanking(PDEV*);
VOID vAssertModeBanking(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Pointer stuff

#define POINTER_DATA_SIZE       40      // Number of bytes to allocate for the
                                        //   miniport down-loaded pointer code
                                        //   working space
#define HW_INVISIBLE_OFFSET     2       // Offset from 'ppdev->yPointerBuffer'
                                        //   to the invisible pointer
#define HW_POINTER_DIMENSION    64      // Maximum dimension of default
                                        //   (built-in) hardware pointer
#define HW_POINTER_HIDE         63      // Hardware pointer start pixel
                                        //   position used to hide the pointer

typedef VOID (FNSHOWPOINTER)(VOID*, BOOL);
typedef VOID (FNMOVEPOINTER)(VOID*, LONG, LONG);
typedef BOOL (FNSETPOINTERSHAPE)(VOID*, LONG, LONG, LONG, LONG, LONG, LONG,
                                 BYTE*);
typedef VOID (FNENABLEPOINTER)(VOID*, BOOL);

BOOL bEnablePointer(PDEV*);
VOID vDisablePointer(PDEV*);
VOID vAssertModePointer(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Palette stuff

BOOL bEnablePalette(PDEV*);
VOID vDisablePalette(PDEV*);
VOID vAssertModePalette(PDEV*, BOOL);

BOOL bInitializePalette(PDEV*, DEVINFO*);
VOID vUninitializePalette(PDEV*);

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

/////////////////////////////////////////////////////////////////////////
// DirectDraw stuff

// There's a 64K granularity that applies to the mapping of the frame
// buffer into the application's address space:

#define ROUND_UP_TO_64K(x)  (((ULONG)(x) + 0x10000 - 1) & ~(0x10000 - 1))

typedef struct _FLIPRECORD
{
    FLATPTR         fpFlipFrom;             // Surface we last flipped from
    LONGLONG        liFlipTime;             // Time at which last flip
                                            //   occured
    LONGLONG        liFlipDuration;         // Precise amount of time it
                                            //   takes from vblank to vblank
    BOOL            bHaveEverCrossedVBlank; // True if we noticed that we
                                            //   switched from inactive to
                                            //   vblank
    BOOL            bWasEverInDisplay;      // True if we ever noticed that
                                            //   we were inactive
    BOOL            bFlipFlag;              // True if we think a flip is
                                            //   still pending
} FLIPRECORD;

BOOL bEnableDirectDraw(PDEV*);
VOID vDisableDirectDraw(PDEV*);
VOID vAssertModeDirectDraw(PDEV*, BOOL);

//////////////////////////////////////////////////////////////////////
// Low-level blt function prototypes

typedef VOID (FNFILL)(PDEV*, LONG, RECTL*, ROP4, RBRUSH_COLOR, POINTL*);
typedef VOID (FNXFER)(PDEV*, LONG, RECTL*, ROP4, SURFOBJ*, POINTL*,
                      RECTL*, XLATEOBJ*);
typedef VOID (FNCOPY)(PDEV*, LONG, RECTL*, ROP4, POINTL*, RECTL*);
typedef VOID (FNFASTPATREALIZE)(PDEV*, RBRUSH*, POINTL*, BOOL);
typedef VOID (FNBITS)(PDEV*, SURFOBJ*, RECTL*, POINTL*);
typedef VOID (FNLOWXFER)(PDEV*, BYTE*, LONG, LONG, LONG);

FNFILL              vPatternFillScr;
FNFILL              vSolidFillScr;
FNFILL              vSolidFillScr24;
FNXFER              vSlowXfer1bpp;
FNCOPY              vScrToScr;
FNFASTPATREALIZE    vFastPatRealize;
FNXFER              vXferNativeSrccopy;
FNXFER              vXferBlt8i;
FNXFER              vXferBlt16i;
FNXFER              vXferBlt24i;
FNXFER              vXferBlt8p;
FNXFER              vXferBlt16p;
FNXFER              vXferBlt24p;
FNXFER              vXferScreenTo1bpp;
FNBITS              vPutBits;
FNBITS              vGetBits;
FNBITS              vPutBitsLinear;
FNBITS              vGetBitsLinear;

FNXFER              vET6000SlowXfer1bpp;
FNXFER              vXferET6000;

FNLOWXFER           vXfer_BYTES;
FNLOWXFER           vXfer_DWORDS;
FNLOWXFER           vXferI_1_Byte;
FNLOWXFER           vXferI_2_Bytes;
FNLOWXFER           vXferI_3_Bytes;
FNLOWXFER           vXferP_1_Byte;
FNLOWXFER           vXferP_2_Bytes;
FNLOWXFER           vXferP_3_Bytes;

VOID vPutBits(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vGetBits(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vGetBitsLinear(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vIoSlowPatRealize(PDEV*, RBRUSH*, BOOL);

////////////////////////////////////////////////////////////////////////
// Capabilities flags
//
// These are private flags passed to us from the W32 miniport.  They
// come from the high word of the 'AttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to us via an 'VIDEO_QUERY_AVAIL_MODES' or 'VIDEO_QUERY_CURRENT_MODE'
// IOCTL.
//
// NOTE: These definitions must match those in the W32 miniport's 'W32.h'!

typedef enum {
    CAPS_HW_PATTERNS        = 0x00010000,   // 8x8 hardware pattern support
    CAPS_MM_TRANSFER        = 0x00020000,   // Memory-mapped image transfers
    CAPS_MM_IO              = 0x00040000,   // Memory-mapped I/O
    CAPS_MM_32BIT_TRANSFER  = 0x00080000,   // Can do 32bit bus size transfers
    CAPS_16_ENTRY_FIFO      = 0x00100000,   // At least 16 entries in FIFO
    CAPS_SW_POINTER         = 0x00200000,   // No hardware pointer; use software
                                            //   simulation
    CAPS_BT485_POINTER      = 0x00400000,   // Use Brooktree 485 pointer
    CAPS_MASKBLT_CAPABLE    = 0x00800000,   // Hardware can handle masked blts
    CAPS_NEW_BANK_CONTROL   = 0x01000000,   // Set if 801/805/928 style banking
    CAPS_NEWER_BANK_CONTROL = 0x02000000,   // Set if 864/964 style banking
    CAPS_RE_REALIZE_PATTERN = 0x04000000,   // Set if we have to work around the
                                            //   864/964 hardware pattern bug
    CAPS_SLOW_MONO_EXPANDS  = 0x08000000,   // Set if we have to slow down
                                            //   monochrome expansions
    CAPS_MM_GLYPH_EXPAND    = 0x10000000,   // Use memory-mapped I/O glyph-
                                            //   expand method of drawing text
                                            //   (always implied for non-x86)
    CAPS_SCALE_POINTER      = 0x20000000,   // Set if the W32 hardware pointer
                                            //   x position has to be scaled by
                                            //   two
    CAPS_TI025_POINTER      = 0x40000000,   // Use TI TVP3025 pointer
} CAPS;

#define CAPS_DAC_POINTER    (CAPS_BT485_POINTER | CAPS_TI025_POINTER)


////////////////////////////////////////////////////////////////////////
// Miniport stuff

typedef struct {
    ULONG   ulPhysicalAddress;
    ULONG   ulLength;
    ULONG   ulInIoSpace;
    PVOID   pvVirtualAddress;
} W32_ADDRESS_MAPPING_INFORMATION, *PW32_ADDRESS_MAPPING_INFORMATION;


////////////////////////////////////////////////////////////////////////
// Status flags

typedef enum {
    STAT_GLYPH_CACHE        = 0x0001,   // Glyph cache successfully allocated
    STAT_BRUSH_CACHE        = 0x0002,   // Brush cache successfully allocated
    STAT_DIRECTDRAW         = 0x0004,   // DirectDraw is enabled
} STATUS;

////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
    LONG        xOffset;
    LONG        yOffset;
    LONG        xyOffset;
    BYTE*       pjBase;                 // Video coprocessor base
    BYTE*       pjScreen;               // Points to base screen address
    LONG        iBoard;                 // Logical multi-board identifier
                                        //   (zero by default)
    ULONG       iBitmapFormat;          // BMF_8BPP or BMF_16BPP or BMF_24BPP
                                        //   (our current colour depth)
    ULONG       ulChipID;
    ULONG       ulRevLevel;

    // Precomputed values for the three aperatures in linear memory.

    BYTE*       pjMmu0;
    BYTE*       pjMmu1;
    BYTE*       pjMmu2;

    // -------------------------------------------------------------------
    // NOTE: Changes up to here in the PDEV structure must be reflected in
    // i386\strucs.inc (assuming you're on an x86, of course)!

    CAPS        flCaps;                 // Capabilities flags
    STATUS      flStatus;               // Status flags
    BOOL        bEnabled;               // In graphics mode (not full-screen)

    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfScreen;            // Engine's handle to screen surface
    DSURF*      pdsurfScreen;           // Our private DSURF for the screen

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    LONG        cxMemory;               // Width of Video RAM
    LONG        cyMemory;               // Height of Video RAM
    ULONG       ulMode;                 // Mode the mini-port driver is in.
    LONG        lDelta;                 // Distance from one scan to the next.

    FLONG       flHooks;                // What we're hooking from GDI
    LONG        cPelSize;               // 0 if 8bpp, 1 if 16bpp, 2 if 32bpp
    LONG        cBpp;                   // 1 if 8bpp, 2 if 16bpp, 3 if 32bpp
    ULONG       ulWhite;                // 0xff if 8bpp, 0xffff if 16bpp,
                                        //   0xffffffff if 32bpp
    UCHAR*      pucCsrBase;             // Mapped IO port base for this PDEV
    VOID*       pvTmpBuffer;            // General purpose temporary buffer,
                                        //   TMP_BUFFER_SIZE bytes in size
                                        //   (Remember to synchronize if you
                                        //   use this for device bitmaps or
                                        //   async pointers)
    UCHAR*      apjMmXfer[XFER_BUFFERS];// Pre-computed array of unique
    USHORT*     apwMmXfer[XFER_BUFFERS];//   addresses for doing memory-mapped
    ULONG*      apdMmXfer[XFER_BUFFERS];//   transfers without memory barriers

    ////////// Low-level blt function pointers:

    FNFILL*     pfnFillSolid;
    FNFILL*     pfnFillPat;
    FNXFER*     pfnXfer1bpp;
    FNXFER*     pfnXferNative;
    FNCOPY*     pfnCopyBlt;
    FNFASTPATREALIZE* pfnFastPatRealize;
    FNBITS*     pfnGetBits;
    FNBITS*     pfnPutBits;

    ////////// Palette stuff:

    PALETTEENTRY* pPal;                 // The palette if palette managed
    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    FLONG       flRed;                  // Red mask for 16/32bpp bitfields
    FLONG       flGreen;                // Green mask for 16/32bpp bitfields
    FLONG       flBlue;                 // Blue mask for 16/32bpp bitfields

    ////////// Heap stuff:

    HEAP        heap;                   // All our off-screen heap data
    ULONG       iHeapUniq;              // Incremented every time room is freed
                                        //   in the off-screen heap
    SURFOBJ*    psoPunt;                // Wrapper surface for having GDI draw
                                        //   on off-screen bitmaps
    SURFOBJ*    psoPunt2;               // Another one for off-screen to off-
                                        //   screen blts
    OH*         pohScreen;              // Allocation structure for the screen

    ////////// Banking stuff:

    BOOL        bAutoBanking;           // True if the system is set up to have
                                        // the memory manager do the banking
    LONG        cjBank;                 // Size of a bank, in bytes
    LONG        cPower2ScansPerBank;    // Used by 'bBankComputePower2'
    LONG        cPower2BankSizeInBytes; // Used by 'bBankComputePower2'
    CLIPOBJ*    pcoBank;                // Clip object for banked call backs
    SURFOBJ*    psoBank;                // Surface object for banked call backs
    SURFOBJ*    psoFrameBuffer;         // Surface object for non-banked call backs
    VOID*       pvBankData;             // Points to aulBankData[0]
    ULONG       aulBankData[BANK_DATA_SIZE / 4];
                                        // Private work area for downloaded
                                        //   miniport banking code

    FNBANKMAP*          pfnBankMap;
    FNBANKSELECTMODE*   pfnBankSelectMode;
    FNBANKCOMPUTE*      pfnBankCompute;

    ////////// Pointer stuff:

    LONG        xPointerHot;            // xHot of current hardware pointer
    LONG        yPointerHot;            // yHot of current hardware pointer

    LONG        cjPointerOffset;        // Byte offset from start of frame
                                        //   buffer to off-screen memory where
                                        //   we stored the pointer shape
    LONG        xPointerShape;          // x-coordinate
    LONG        yPointerShape;          // y-coordinate
    LONG        iPointerBank;           // Bank containing pointer shape
    VOID*       pvPointerShape;         // Points to pointer shape when bank
                                        //   is mapped in
    LONG        dyPointer;              // Start y-pixel position for the
                                        //   current pointer
    LONG        cPointerShift;          // Horizontal scaling factor for
                                        //   hardware pointer position

    ULONG       ulHwGraphicsCursorModeRegister_45;
                                        // Default value for index 45
    VOID*       pvPointerData;          // Points to ajPointerData[0]
    BYTE        ajPointerData[POINTER_DATA_SIZE];
                                        // Private work area for downloaded
                                        //   miniport pointer code

    FNSHOWPOINTER*      pfnShowPointer;
    FNMOVEPOINTER*      pfnMovePointer;
    FNSETPOINTERSHAPE*  pfnSetPointerShape;
    FNENABLEPOINTER*    pfnEnablePointer;

    ////////// Brush stuff:

    BOOL        bRealizeTransparent;    // Hint to DrvRealizeBrush for whether
                                        //   the brush should be realized as
                                        //   transparent or not
    LONG        iBrushCache;            // Index for next brush to be allocated
    LONG        cBrushCache;            // Total number of brushes cached
    BRUSHENTRY  abe[TOTAL_BRUSH_COUNT]; // Keeps track of brush cache

// W32 specific stuff

    BYTE*           pjPorts;            // Video port base
    ULONG           w32PatternWrap;     // Value for the Pattern Wrap register
                                        //   8x8 pixels (varies with pel depth)

    W32MMUINFO      w32MmuInfo;
    ULONG           ulSolidColorOffset;
    W32SPRITEDATA   W32SpriteData;

    // Rendering extensions colour information.

    UCHAR       rDepth;                 // Number of red bits
    UCHAR       gDepth;                 // Number of green bits
    UCHAR       bDepth;                 // Number of blue bits
    UCHAR       aDepth;                 // Number of alpha bits
    UCHAR       rBitShift;              // Left bit-shift for red component
    UCHAR       gBitShift;              // Left bit-shift for green component
    UCHAR       bBitShift;              // Left bit-shift for blue component
    UCHAR       aBitShift;              // Left bit-shift for alpha component

#if 0
    ////////// DCI stuff:

    BOOL        bSupportDCI;            // True if miniport supports DCI

    ////////// 3D DDI Rendering Extension stuff:

    VOID*       pvOut;                  // Points to current output buffer
    VOID*       pvOutMax;               // Points to end of current output buffer
    VOID*       pvInMax;                // Points to end of current input buffer
    OH*         pohFrontBuffer;         // Allocation structure for the screen
    OH*         pohBackBuffer;          // Allocation structure for optional
                                        //   off-screen back buffer
    LONG        cDoubleBufferRef;       // Reference count for current number
                                        //   of RC's that have active double-
                                        //   buffers
    POINTL      ptlDoubleBuffer[2];     // (x, y) positions of front and back
                                        //   buffers in video memory
                                        //   0 -- RX_BACK_LEFT
                                        //   1 -- RX_FRONT_LEFT
                                        // Note: Make sure that the index
                                        //   is in the range [0, 1]!
#endif

    //  Extensions added for the ET6000

    LONG        lBltBufferPitch;        //  Pitch of our blt buffer.
    OH*         pohBltBuffer;           //  Pointer to offscreen memory used for
                                        //  double buffering blts and stretches.
    ULONG       PCIConfigSpaceAddr;     //  The Offset into IO space for PCI Cfg data

    /////////// DirectDraw stuff:

    FLIPRECORD  flipRecord;             // Used to track VBlank status
    DWORD       dwLinearCnt;            // Reference count of active
                                        //   DirectDraw Locks
    OH*         pohDirectDraw;          // Off-screen heap allocation for use
                                        //   by DirectDraw
} PDEV, *PPDEV;




/////////////////////////////////////////////////////////////////////////
// Miscellaneous prototypes:

BOOL bIntersect(RECTL*, RECTL*, RECTL*);
LONG cIntersect(RECTL*, RECTL*, LONG);
BOOL bFastFill(PDEV*, LONG, POINTFIX*, ULONG, ULONG, ULONG, RBRUSH*);
DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION*, DWORD*);

BOOL bInitializeModeFields(PDEV*, GDIINFO*, DEVINFO*, DEVMODEW*);

BOOL bEnableHardware(PDEV*);
VOID vDisableHardware(PDEV*);
BOOL bAssertModeHardware(PDEV*, BOOL);

extern BYTE aMixToRop3[];

/////////////////////////////////////////////////////////////////////////
// The x86 C compiler insists on making a divide and modulus operation
// into two DIVs, when it can in fact be done in one.  So we use this
// macro.
//
// Note: QUOTIENT_REMAINDER implicitly takes unsigned arguments.

#if defined(i386)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#endif

/////////////////////////////////////////////////////////////////////////
// OVERLAP - Returns TRUE if the same-size lower-right exclusive
//           rectangles defined by 'pptl' and 'prcl' overlap:

#define OVERLAP(prcl, pptl)                                             \
    (((prcl)->right  > (pptl)->x)                                   &&  \
     ((prcl)->bottom > (pptl)->y)                                   &&  \
     ((prcl)->left   < ((pptl)->x + (prcl)->right - (prcl)->left))  &&  \
     ((prcl)->top    < ((pptl)->y + (prcl)->bottom - (prcl)->top)))

/////////////////////////////////////////////////////////////////////////
// SWAP - Swaps the value of two variables, using a temporary variable

#define SWAP32(a, b)            \
{                               \
    register ULONG tmp;         \
    tmp = (ULONG)(a);           \
    (ULONG)(a) = (ULONG)(b);    \
    (ULONG)(b) = tmp;           \
}

#define SWAP(a, b, tmp) { (tmp) = (a); (a) = (b); (b) = (tmp); }

//////////////////////////////////////////////////////////

_inline ULONG COLOR_REPLICATE(PDEV* ppdev, ULONG x)
{
    ULONG ulResult = x;
    if (ppdev->cBpp == 1)
    {
        ulResult |= (ulResult << 8);
    }
    if (ppdev->cBpp <= 2)
    {
        ulResult |= (ulResult << 16);
    }
    return(ulResult);
}

/////////////////////////////////////////////////////////////////////////
// DUMPVAR - Dumps a variable name and value to the debugger.
//           usage -> DUMPVAR(ppdev->cjPointerOffset,"%xh");

#define DUMPVAR(x,format_str)   DISPDBG((0,#x" = "format_str,x));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\lines.h ===
/******************************Module*Header*******************************\
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* NOTE: This file mirrors LINES.INC.  Changes here must be reflected in
* the .inc file!
*
* Copyright (c) 1992-1994 Microsoft Corporation
\**************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration

//
// These constants are used for the W32p line drawing algorithm
//

// method 1
#define NO_X_FLIP   0
#define NO_Y_FLIP   0
#define X_FLIP      1
#define Y_FLIP      1
#define X_MAJOR     1
#define Y_MAJOR     0

// method 2
#define LINE_DRAW           0x80
#define LINE_USE_ERROR_TERM 0x20
#define LINE_X_NEG          0x01
#define LINE_Y_NEG          0x12
#define LINE_X_MAJOR        0x04


// We have to be careful that we don't overflow any registers when using
// the hardware to draw lines (as opposed to going through the strips
// routines, which will never overflow).  We accomplish this by simply
// checking the bounds of the path; if it is so large that any of the
// hardware terms may overflow, we punt the entire path to the strips
// code (should be pretty rare).

#define MAX_INTEGER_BOUND  (1535)   // W32's line length term is limited to
#define MIN_INTEGER_BOUND  (-512)   //   a maximum value of 2047

// We have special strip routines when all strips have at most this many
// pixels:

#define MAX_SHORT_STROKE_LENGTH 15

// # of strip drawers in every group:

#define NUM_STRIP_DRAW_DIRECTIONS 4

// # of strip drawers for doing either solid lines or styled lines:

#define NUM_STRIP_DRAW_STYLES 8

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00008000L     // 1... .... .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_STYLED               0x00000400L     // .... .1.. .... ....
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000400L
#define FL_STYLE_SHIFT          10

#define FL_LAST_PEL_INCLUSIVE   0x00002000L     // ..1. .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

////////////////////////////////////////////////////////////////////////////
// NOTE: The following structures must exactly match those declared in
//       lines.inc!

typedef struct _STRIP {
    LONG   cStrips;               // # of strips in array
    LONG   flFlips;               // Indicates if line goes up or down
    POINTL ptlStart;             // first point
    LONG   alStrips[STRIP_MAX];   // Array of strips
} STRIP;

typedef struct _LINESTATE {
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    STYLEPOS*       psp;            // Pointer to current style entry

    STYLEPOS        spRemaining;    // To go in current style
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           ulStyleMask;    // Are we working on a gap in the style?
                                    // 0xff if yes, 0x0 if not
    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;                        /* ls */

// Strip drawer prototype:

typedef VOID (*PFNSTRIP)(PDEV*, STRIP*, LINESTATE*);
extern PFNSTRIP gapfnStripP[];

// Strip drawers:

VOID vssSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vssSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vssSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vssSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vStripStyledHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vStripStyledVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vrlSolidHorizontalP(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidVerticalP(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidDiagonalHorizontalP(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidDiagonalVerticalP(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vStripStyledHorizontalP(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vStripStyledVerticalP(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);


// External calls:

BOOL bLines(PDEV*, POINTFIX*, POINTFIX*, RUN* prun, ULONG,
            LINESTATE*, RECTL*, PFNSTRIP apfn[], FLONG);



//
// axis must be a constant
//

#define SETUP_DRAW_LINE(pjBase,dx,dy,axis,cBpp)             \
{                                                           \
    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);                \
                                                            \
    if (axis == 1)                                          \
    {                                                       \
        /* X major */                                       \
        CP_XCNT(ppdev, pjBase, ((dx - 1) * cBpp));          \
        CP_YCNT(ppdev, pjBase, 0xfff);                      \
        CP_DELTA_MINOR(ppdev, pjBase, dy);                  \
        CP_DELTA_MAJOR(ppdev, pjBase, dx);                  \
    }                                                       \
    else /*if (axis == 0)*/                                 \
    {                                                       \
        /* Y major */                                       \
        CP_XCNT(ppdev, pjBase, 0xfff);                      \
        CP_YCNT(ppdev, pjBase, (dy - 1));                   \
        CP_DELTA_MINOR(ppdev, pjBase, dx);                  \
        CP_DELTA_MAJOR(ppdev, pjBase, dy);                  \
    }                                                       \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\lines.c ===
/*************************************************************************\
* Module Name: Lines.c
*
* Contains the code for drawing short fractional endpoint lines and
* longer lines with strips.  There is also a separate x86 Asm version
* of this code.
*
* Copyright (c) 1990-1994 Microsoft Corporation
* Copyright (c) 1992      Digital Equipment Corporation
\**************************************************************************/

#include "precomp.h"

///////////////////////////////////////////////////////////////////////

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// UUInt32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit ULONGs to produce a 64-bit DWORDLONG result.
//
// UInt64By32To32 is our own macro to divide a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// UInt64Mod32To32 is our own macro to modulus a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// 64 bit divides are usually very expensive.  Since it's very rare
// that we'll get lines where the upper 32 bits of the 64 bit result
// are used, we can almost always use 32-bit ULONG divides.  We still
// must correctly handle the larger cases:

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define UInt64Mod32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) % (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) % (ULONG)(b)))

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_V
    FL_V_ROUND_DOWN,                   // FL_FLIP_V | FL_FLIP_D
    FL_V_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE
    0xbaadf00d,                        // FL_FLIP_SLOPE_ONE | FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE | FL_FLIP_V
    0xbaadf00d                         // FL_FLIP_SLOPE_ONE | FL_FLIP_V | FL_FLIP_D
};

BOOL bIntegerLine(PDEV*, ULONG, ULONG, ULONG, ULONG);
BOOL bHardwareLine(PDEV*, POINTFIX*, POINTFIX*);

/******************************Public*Routine******************************\
* BOOL bLines(ppdev, pptfxFirst, pptfxBuf, cptfx, pls,
*                   prclClip, apfn[], flStart)
*
* Computes the DDA for the line and gets ready to draw it.  Puts the
* pixel data into an array of strips, and calls a strip routine to
* do the actual drawing.
*
* Doing NT Lines Right
* --------------------
*
* In NT, all lines are given to the device driver in fractional
* coordinates, in a 28.4 fixed point format.  The lower 4 bits are
* fractional for sub-pixel positioning.
*
* Note that you CANNOT! just round the coordinates to integers
* and pass the results to your favorite integer Bresenham routine!!
* (Unless, of course, you have such a high resolution device that
* nobody will notice -- not likely for a display device.)  The
* fractions give a more accurate rendering of the line -- this is
* important for things like our Bezier curves, which would have 'kinks'
* if the points in its polyline approximation were rounded to integers.
*
* Unfortunately, for fractional lines there is more setup work to do
* a DDA than for integer lines.  However, the main loop is exactly
* the same (and can be done entirely with 32 bit math).
*
* If You've Got Hardware That Does Bresenham
* ------------------------------------------
*
* A lot of hardware limits DDA error terms to 'n' bits.  With fractional
* coordinates, 4 bits are given to the fractional part, letting
* you draw in hardware only those lines that lie entirely in a 2^(n-4)
* by 2^(n-4) pixel space.
*
* And you still have to correctly draw those lines with coordinates
* outside that space!  Remember that the screen is only a viewport
* onto a 28.4 by 28.4 space -- if any part of the line is visible
* you MUST render it precisely, regardless of where the end points lie.
* So even if you do it in software, somewhere you'll have to have a
* 32 bit DDA routine.
*
* Our Implementation
* ------------------
*
* We employ a run length slice algorithm: our DDA calculates the
* number of pixels that are in each row (or 'strip') of pixels.
*
* We've separated the running of the DDA and the drawing of pixels:
* we run the DDA for several iterations and store the results in
* a 'strip' buffer (which are the lengths of consecutive pixel rows of
* the line), then we crank up a 'strip drawer' that will draw all the
* strips in the buffer.
*
* We also employ a 'half-flip' to reduce the number of strip
* iterations we need to do in the DDA and strip drawing loops: when a
* (normalized) line's slope is more than 1/2, we do a final flip
* about the line y = (1/2)x.  So now, instead of each strip being
* consecutive horizontal or vertical pixel rows, each strip is composed
* of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
* (128, 128) would generate only one strip.
*
* We also always draw only left-to-right.
*
* Styled lines may have arbitrary style patterns.  We specially
* optimize the default patterns (and call them 'masked' styles).
*
* The DDA Derivation
* ------------------
*
* Here is how I like to think of the DDA calculation.
*
* We employ Knuth's "diamond rule": rendering a one-pixel-wide line
* can be thought of as dragging a one-pixel-wide by one-pixel-high
* diamond along the true line.  Pixel centers lie on the integer
* coordinates, and so we light any pixel whose center gets covered
* by the "drag" region (John D. Hobby, Journal of the Association
* for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
*
* We must define which pixel gets lit when the true line falls
* exactly half-way between two pixels.  In this case, we follow
* the rule: when two pels are equidistant, the upper or left pel
* is illuminated, unless the slope is exactly one, in which case
* the upper or right pel is illuminated.  (So we make the edges
* of the diamond exclusive, except for the top and left vertices,
* which are inclusive, unless we have slope one.)
*
* This metric decides what pixels should be on any line BEFORE it is
* flipped around for our calculation.  Having a consistent metric
* this way will let our lines blend nicely with our curves.  The
* metric also dictates that we will never have one pixel turned on
* directly above another that's turned on.  We will also never have
* a gap; i.e., there will be exactly one pixel turned on for each
* column between the start and end points.  All that remains to be
* done is to decide how many pixels should be turned on for each row.
*
* So lines we draw will consist of varying numbers of pixels on
* successive rows, for example:
*
*       ******
*             *****
*                  ******
*                        *****
*
* We'll call each set of pixels on a row a "strip".
*
* (Please remember that our coordinate space has the origin as the
* upper left pixel on the screen; postive y is down and positive x
* is right.)
*
* Device coordinates are specified as fixed point 28.4 numbers,
* where the first 28 bits are the integer coordinate, and the last
* 4 bits are the fraction.  So coordinates may be thought of as
* having the form (x, y) = (M/F, N/F) where F is the constant scaling
* factor F = 2^4 = 16, and M and N are 32 bit integers.
*
* Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
* left-to-right and whose slope is in the first octant, and let
* dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
*
* Since the slope of the line is less than 1, the edges of the
* drag region are created by the top and bottom vertices of the
* diamond.  At any given pixel row y of the line, we light those
* pixels whose centers are between the left and right edges.
*
* Let mL(n) denote the line representing the left edge of the drag
* region.  On pixel row j, the column of the first pixel to be
* lit is
*
*       iL(j) = ceiling( mL(j * F) / F)
*
* Since the line's slope is less than one:
*
*       iL(j) = ceiling( mL([j + 1/2] F) / F )
*
* Recall the formula for our line:
*
*       n(m) = (dN / dM) (m - M0) + N0
*
*       m(n) = (dM / dN) (n - N0) + M0
*
* Since the line's slope is less than one, the line representing
* the left edge of the drag region is the original line offset
* by 1/2 pixel in the y direction:
*
*       mL(n) = (dM / dN) (n - F/2 - N0) + M0
*
* From this we can figure out the column of the first pixel that
* will be lit on row j, being careful of rounding (if the left
* edge lands exactly on an integer point, the pixel at that
* point is not lit because of our rounding convention):
*
*       iL(j) = floor( mL(j F) / F ) + 1
*
*             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
*
*             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
*
*                      F dM j - [ dM (N0 + F/2) - dN M0 ]
*             = floor( ---------------------------------- ) + 1
*                                   F dN
*
*                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
*             = floor( ------------------------------------ ) + 1       (1)
*                                     dN
*
*             = floor( (dM j + alpha) / dN ) + 1
*
* where
*
*       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
*
* We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
* pixels in row j.  Because we are always calculating iL(j) for
* integer quantities of j, we note that the only fractional term
* is constant, and so we can 'throw away' the fractional bits of
* alpha:
*
*       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
*
* so
*
*       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
*
* for integers j.
*
* Note if iR(j) is the line's rightmost pixel on row j, that
* iR(j) = iL(j + 1) - 1.
*
* Similarly, rewriting equation (1) as a function of column i,
* we can determine, given column i, on which pixel row j is the line
* lit:
*
*                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
*       j(i) = ceiling( ------------------------------------ ) - 1
*                                       dM
*
* Floors are easier to compute, so we can rewrite this:
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
*       j(i) = floor( ----------------------------------------------- ) - 1
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
*            = floor( ---------------------------------------------------- )
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
*            = floor( ---------------------------------------- )
*                                       dM
*
* We can once again wave our hands and throw away the fractional bits
* of the remainder term:
*
*       j(i) = floor( (dN i + gamma) / dM )                             (4)
*
* where
*
*       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
*
* We now note that
*
*       beta = -gamma - 1 = ~gamma                                      (6)
*
* To draw the pixels of the line, we could evaluate (3) on every scan
* line to determine where the strip starts.  Of course, we don't want
* to do that because that would involve a multiply and divide for every
* scan.  So we do everything incrementally.
*
* We would like to easily compute c , the number of pixels on scan j:
*                                  j
*
*    c  = iL(j + 1) - iL(j)
*     j
*
*       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
*
* This may be rewritten as
*
*    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
*     j          j+1    j+1                j    j
*
* where i , i    are integers and r  < dN, r    < dN.
*        j   j+1                   j        j+1
*
* Rewriting (7) again:
*
*    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
*     j          j    j                          j    j
*
*
*       = floor((r  + dM) / dN) - floor(r  / dN)
*                 j                      j
*
* This may be rewritten as
*
*    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
*     j                j                      j
*
* where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
*
* r  is the remainder (or "error") term in the DDA loop: r  / dN
*  j                                                      j
* is the exact fraction of a pixel at which the strip ends.  To go
* on to the next scan and compute c    we need to know r   .
*                                  j+1                  j+1
*
* So in the main loop of the DDA:
*
*    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
*     j                j                  j+1     j
*
* and we know r  < dN, r    < dN, and dR < dN.
*              j        j+1
*
* We have derived the DDA only for lines in the first octant; to
* handle other octants we do the common trick of flipping the line
* to the first octant by first making the line left-to-right by
* exchanging the end-points, then flipping about the lines y = 0 and
* y = x, as necessary.  We must record the transformation so we can
* undo them later.
*
* We must also be careful of how the flips affect our rounding.  If
* to get the line to the first octant we flipped about x = 0, we now
* have to be careful to round a y value of 1/2 up instead of down as
* we would for a line originally in the first octant (recall that
* "In the case where two pels are equidistant, the upper or left
* pel is illuminated...").
*
* To account for this rounding when running the DDA, we shift the line
* (or not) in the y direction by the smallest amount possible.  That
* takes care of rounding for the DDA, but we still have to be careful
* about the rounding when determining the first and last pixels to be
* lit in the line.
*
* Determining The First And Last Pixels In The Line
* -------------------------------------------------
*
* Fractional coordinates also make it harder to determine which pixels
* will be the first and last ones in the line.  We've already taken
* the fractional coordinates into account in calculating the DDA, but
* the DDA cannot tell us which are the end pixels because it is quite
* happy to calculate pixels on the line from minus infinity to positive
* infinity.
*
* The diamond rule determines the start and end pixels.  (Recall that
* the sides are exclusive except for the left and top vertices.)
* This convention can be thought of in another way: there are diamonds
* around the pixels, and wherever the true line crosses a diamond,
* that pel is illuminated.
*
* Consider a line where we've done the flips to the first octant, and the
* floor of the start coordinates is the origin:
*
*        +-----------------------> +x
*        |
*        | 0                     1
*        |     0123456789abcdef
*        |
*        |   0 00000000?1111111
*        |   1 00000000 1111111
*        |   2 0000000   111111
*        |   3 000000     11111
*        |   4 00000    ** 1111
*        |   5 0000       ****1
*        |   6 000           1***
*        |   7 00             1  ****
*        |   8 ?                     ***
*        |   9 22             3         ****
*        |   a 222           33             ***
*        |   b 2222         333                ****
*        |   c 22222       3333                    **
*        |   d 222222     33333
*        |   e 2222222   333333
*        |   f 22222222 3333333
*        |
*        | 2                     3
*        v
*        +y
*
* If the start of the line lands on the diamond around pixel 0 (shown by
* the '0' region here), pixel 0 is the first pel in the line.  The same
* is true for the other pels.
*
* A little more work has to be done if the line starts in the
* 'nether-land' between the diamonds (as illustrated by the '*' line):
* the first pel lit is the first diamond crossed by the line (pixel 1 in
* our example).  This calculation is determined by the DDA or slope of
* the line.
*
* If the line starts exactly half way between two adjacent pixels
* (denoted here by the '?' spots), the first pixel is determined by our
* round-down convention (and is dependent on the flips done to
* normalize the line).
*
* Last Pel Exclusive
* ------------------
*
* To eliminate repeatedly lit pels between continuous connected lines,
* we employ a last-pel exclusive convention: if the line ends exactly on
* the diamond around a pel, that pel is not lit.  (This eliminates the
* checks we had in the old code to see if we were re-lighting pels.)
*
* The Half Flip
* -------------
*
* To make our run length algorithm more efficient, we employ a "half
* flip".  If after normalizing to the first octant, the slope is more
* than 1/2, we subtract the y coordinate from the x coordinate.  This
* has the effect of reflecting the coordinates through the line of slope
* 1/2.  Note that the diagonal gets mapped into the x-axis after a half
* flip.
*
* How Many Bits Do We Need, Anyway?
* ---------------------------------
*
* Note that if the line is visible on your screen, you must light up
* exactly the correct pixels, no matter where in the 28.4 x 28.4 device
* space the end points of the line lie (meaning you must handle 32 bit
* DDAs, you can certainly have optimized cases for lesser DDAs).
*
* We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
* calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
* are in the first octant, so dM >= dN.  Then we know that gamma can
* be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
* valid lines will have dM and dN values at most 31 bits (unsigned)
* of significance.  So gamma requires 33 bits of significance (we store
* this as a 64 bit number for convenience).
*
* When running through the DDA loop, r  + dR can have a value in the
*                                     j
* range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
*             j
*
* Testing Lines
* -------------
*
* To be NT compliant, a display driver must exactly adhere to GIQ,
* which means that for any given line, the driver must light exactly
* the same pels as does GDI.  This can be tested using the Guiman tool
* provided elsewhere in the DDK, and 'ZTest', which draws random lines
* on the screen and to a bitmap, and compares the results.
*
* If You've Got Line Hardware
* ---------------------------
*
* If your hardware already adheres to GIQ, you're all set.  Otherwise
* you'll want to look at the S3 sample code and read the following:
*
* 1) You'll want to special case integer-only lines, since they require
*    less processing time and are more common (CAD programs will probably
*    only ever give integer lines).  GDI does not provide a flag saying
*    that all lines in a path are integer lines; consequently, you will
*    have to explicitly check every line.
*
* 2) You are required to correctly draw any line in the 28.4 device
*    space that intersects the viewport.  If you have less than 32 bits
*    of significance in the hardware for the Bresenham terms, extremely
*    long lines would overflow the hardware.  For such (rare) cases, you
*    can fall back to strip-drawing code (or if your display is a frame
*    buffer, fall back to the engine).
*
* 3) If you can explicitly set the Bresenham terms in your hardware, you
*    can draw non-integer lines using the hardware.  If your hardware has
*    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
*    pels long (4 bits are required for the fractional part, and one bit is
*    used as a sign bit).  Note that integer lines don't require the 4
*    fractional bits, so if you special case them as in 1), you can do
*    integer lines that are up to 2^(n - 1) pels long.  See the
*    'bHardwareLine' routine for an example.
*
\**************************************************************************/

BOOL bLines(
PDEV*	   ppdev,
POINTFIX*  pptfxFirst,  // Start of first line
POINTFIX*  pptfxBuf,    // Pointer to buffer of all remaining lines
RUN*       prun,        // Pointer to runs if doing complex clipping
ULONG      cptfx,       // Number of points in pptfxBuf or number of runs
                        // in prun
LINESTATE* pls,         // Colour and style info
RECTL*     prclClip,    // Pointer to clip rectangle if doing simple clipping
PFNSTRIP   apfn[],      // Array of strip functions
FLONG      flStart)     // Flags for each line, which is a combination of:
                        //      FL_SIMPLE_CLIP
                        //      FL_COMPLEX_CLIP
                        //      FL_STYLED
                        //      FL_LAST_PEL_INCLUSIVE
                        //        - Should be set only for all integer lines,
                        //          and can't be used with FL_COMPLEX_CLIP
{
    ULONG     M0;
    ULONG     dM;
    ULONG     N0;
    ULONG     dN;
    ULONG     dN_Original;
    FLONG     fl;
    LONG      x;
    LONG      y;

    LONGLONG  llBeta;
    LONGLONG  llGamma;
    LONGLONG  dl;
    LONGLONG  ll;

    ULONG     ulDelta;

    ULONG     x0;
    ULONG     y0;
    ULONG     x1;
    ULONG     cStylePels;    // Major length of line in pixels for styling
    ULONG     xStart;
    POINTL    ptlStart;
    STRIP     strip;
    PFNSTRIP  pfn;
    LONG      cPels;
    LONG*     plStrip;
    LONG*     plStripEnd;
    LONG      cStripsInNextRun;

    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx; // Last point in path record
    STYLEPOS  spThis;                         // Style pos for this line
    BOOL      bW32p = (ppdev->ulChipID == W32P);

    do {

/***********************************************************************\
* Start the DDA calculations.                                           *
\***********************************************************************/

        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;


    	// Check for non-clipped, non-styled integer endpoint lines

        if (bW32p)
        {

            if ((fl & (FL_CLIP | FL_STYLED)) == 0)
            {
                // Special-case integer end-point lines:

    	        if (((M0 | dM | N0 | dN) & (F - 1)) == 0)
                {
                    if (bIntegerLine(ppdev, M0, N0, dM, dN))
                    {
                        goto Next_Line;
                    }
                }
            }
        }

        if ((LONG) M0 > (LONG) dM)
        {
        // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

    // Compute the delta dx.  The DDI says we can never have a valid delta
    // with a magnitued more than 2^31 - 1, but GDI never actually checks
    // its transforms.  So we have to check for this case to avoid overflow:

        dM -= M0;
        if ((LONG) dM < 0)
        {
            goto Next_Line;
        }

        if ((LONG) dN < (LONG) N0)
        {
        // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

        dN -= N0;

        if ((LONG) dN < 0)
        {
            goto Next_Line;
        }

    // We now have a line running left-to-right, top-to-bottom from (M0, N0)
    // to (M0 + dM, N0 + dN):

        if (dN >= dM)
        {
            if (dN == dM)
            {
            // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
            // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        x = LFLOOR((LONG) M0);
        y = LFLOOR((LONG) N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

        llGamma = UInt32x32To64(dM, N0 + F/2) - UInt32x32To64(M0, dN);
        if (fl & FL_V_ROUND_DOWN)   // Adjust so y = 1/2 rounds down
        {
            llGamma--;
        }

        llGamma >>= FLOG2;
        llBeta = ~llGamma;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.                  *
\***********************************************************************/

    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'.
    //
    // For lines that go left-to-right, we have the following grid:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 xxxxxxxx?.......
    //   |   1 xxxxxxx.........
    //   |   2 xxxxxx..........
    //   |   3 xxxxx...........
    //   |   4 xxxx............
    //   |   5 xxx.............
    //   |   6 xx..............
    //   |   7 x...............
    //   |   8 x...............
    //   |   9 x.....**........
    //   |   a xx......****....
    //   |   b xxx.........****
    //   |   c xxxx............****
    //   |   d xxxxx...........    ****
    //   |   e xxxxxx..........        ****
    //   |   f xxxxxxx.........
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one must be handled similarly to the right-to-
    // left case.

        {

        // Calculate x0, x1

            ULONG N1 = FXFRAC(N0 + dN);
	    ULONG M1 = FXFRAC(M0 + dM);

	    x1 = LFLOOR(M0 + dM);

            if (fl & FL_LAST_PEL_INCLUSIVE)
            {
            // It sure is easy to compute the first pel when lines have only
            // integer coordinates and are last-pel inclusive:

                x0 = 0;
                y0 = 0;

            // Last-pel inclusive lines that are exactly one pixel long
            // have a 'delta-x' and 'delta-y' equal to zero.  The problem is
            // that our clip code assumes that 'delta-x' is always non-zero
            // (since it never happens with last-pel exclusive lines).  As
            // an inelegant solution, we simply modify 'delta-x' in this
            // case -- because the line is exactly one pixel long, changing
            // the slope will obviously have no effect on rasterization.

                if (x1 == 0)
                {
                    dM      = 1;
                    llGamma = 0;
                    llBeta  = ~llGamma;
                }
            }
            else
            {
                if (fl & FL_FLIP_H)
                {
                // ---------------------------------------------------------------
                // Line runs right-to-left:  <----

                // Compute x1:

                    if (N1 == 0)
                    {
                        if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                        {
                            x1++;
                        }
                    }
                    else if (abs((LONG) (N1 - F/2)) + M1 > F)
                    {
                        x1++;
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((N1 > 0) && (M1 == N1 + 8))
                            x1++;

                    // Don't you love special cases?  Is this a rhetorical question?

                        if ((N0 > 0) && (M0 == N0 + 8))
                        {
                            x0      = 2;
                            ulDelta = dN;
                            goto right_to_left_compute_y0;
                        }
                    }

                // Compute x0:

                    x0      = 1;
                    ulDelta = 0;
                    if (N0 == 0)
                    {
                        if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                        {
                            x0      = 2;
                            ulDelta = dN;
                        }
                    }
                    else if (abs((LONG) (N0 - F/2)) + M0 > F)
                    {
                        x0      = 2;
                        ulDelta = dN;
                    }


                // Compute y0:

                right_to_left_compute_y0:

                    y0 = 0;
                    ll = llGamma + (LONGLONG) ulDelta;

                    if (ll >= (LONGLONG) (2 * dM - dN))
                        y0 = 2;
                    else if (ll >= (LONGLONG) (dM - dN))
                        y0 = 1;
                }
                else
                {
                // ---------------------------------------------------------------
                // Line runs left-to-right:  ---->

                // Compute x1:

                    if (!(fl & FL_LAST_PEL_INCLUSIVE))
                        x1--;

                    if (M1 > 0)
                    {
                        if (N1 == 0)
                        {
                            if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                                x1++;
                        }
                        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
                        {
                            x1++;
                        }
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((M1 > 0) && (N1 == M1 + 8))
                            x1--;

                        if ((M0 > 0) && (N0 == M0 + 8))
                        {
                            x0 = 0;
                            goto left_to_right_compute_y0;
                        }
                    }

                // Compute x0:

                    x0 = 0;
                    if (M0 > 0)
                    {
                        if (N0 == 0)
                        {
                            if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                                x0 = 1;
                        }
                        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
                        {
                            x0 = 1;
                        }
                    }

                // Compute y0:

                left_to_right_compute_y0:

                    y0 = 0;
                    if (llGamma >= (LONGLONG) (dM - (dN & (-(LONG) x0))))
                    {
                        y0 = 1;
                    }
                }
            }
        }

        cStylePels = x1 - x0 + 1;
        if ((LONG) cStylePels <= 0)
            goto Next_Line;

        xStart = x0;

/***********************************************************************\
* Complex clipping.                                                     *
\***********************************************************************/

        if (fl & FL_COMPLEX_CLIP)
        {
            dN_Original = dN;

        Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
            // Line runs right-to-left <-----

                x0 = xStart + cStylePels - prun->iStop - 1;
                x1 = xStart + cStylePels - prun->iStart - 1;
            }
            else
            {
            // Line runs left-to-right ----->

                x0 = xStart + prun->iStart;
                x1 = xStart + prun->iStop;
            }

            prun++;

        // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

        // No overflow since large integer math is used.  Both values
        // will be positive:

            dl = UInt32x32To64(x0, dN) + llGamma;

        // y0 = dl / dM:

            y0 = UInt64Div32To32(dl, dM);

            ASSERTDD((LONG) y0 >= 0, "y0 weird: Goofed up end pel calc?");
        }

/***********************************************************************\
* Simple rectangular clipping.                                          *
\***********************************************************************/

        if (fl & FL_SIMPLE_CLIP)
        {
            ULONG y1;
            LONG  xRight;
            LONG  xLeft;
            LONG  yBottom;
            LONG  yTop;

        // Note that y0 and y1 are actually the lower and upper bounds,
        // respectively, of the y coordinates of the line (the line may
        // have actually shrunk due to first/last pel clipping).
        //
        // Also note that x0, y0 are not necessarily zero.

            RECTL* prcl = &prclClip[(fl & FL_RECTLCLIP_MASK) >>
                                    FL_RECTLCLIP_SHIFT];

        // Normalize to the same point we've normalized for the DDA
        // calculations:

            xRight  = prcl->right  - x;
            xLeft   = prcl->left   - x;
            yBottom = prcl->bottom - y;
            yTop    = prcl->top    - y;

            if (yBottom <= (LONG) y0 ||
                xRight  <= (LONG) x0 ||
                xLeft   >  (LONG) x1)
            {
            Totally_Clipped:

                if (fl & FL_STYLED)
                {
                    pls->spNext += cStylePels;
                    if (pls->spNext >= pls->spTotal2)
                        pls->spNext %= pls->spTotal2;
                }

                goto Next_Line;
            }

            if ((LONG) x1 >= xRight)
                x1 = xRight - 1;

        // We have to know the correct y1, which we haven't bothered to
        // calculate up until now.  This multiply and divide is quite
        // expensive; we could replace it with code similar to that which
        // we used for computing y0.
        //
        // The reason why we need the actual value, and not an upper
        // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
        // careful when calculating x(y) that y0 <= y <= y1, otherwise
        // we can overflow on the divide (which, needless to say, is very
        // bad).

            dl = UInt32x32To64(x1, dN) + llGamma;

        // y1 = dl / dM:

            y1 = UInt64Div32To32(dl, dM);

            if (yTop > (LONG) y1)
                goto Totally_Clipped;

            if (yBottom <= (LONG) y1)
            {
                y1 = yBottom;
                dl = UInt32x32To64(y1, dM) + llBeta;

            // x1 = dl / dN:

                x1 = UInt64Div32To32(dl, dN);
            }

        // At this point, we've taken care of calculating the intercepts
        // with the right and bottom edges.  Now we work on the left and
        // top edges:

            if (xLeft > (LONG) x0)
            {
                x0 = xLeft;
                dl = UInt32x32To64(x0, dN) + llGamma;

            // y0 = dl / dM;

                y0 = UInt64Div32To32(dl, dM);

                if (yBottom <= (LONG) y0)
                    goto Totally_Clipped;
            }

            if (yTop > (LONG) y0)
            {
                y0 = yTop;
                dl = UInt32x32To64(y0, dM) + llBeta;

            // x0 = dl / dN + 1;

                x0 = UInt64Div32To32(dl, dN) + 1;

                if (xRight <= (LONG) x0)
                    goto Totally_Clipped;
            }

            ASSERTDD(x0 <= x1, "Improper rectangle clip");
        }

/***********************************************************************\
* Done clipping.  Unflip if necessary.                                 *
\***********************************************************************/

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }


        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        cPels = x1 - x0 + 1;

/***********************************************************************\
* Style calculations.                                                   *
\***********************************************************************/

        if (fl & FL_STYLED)
        {
            STYLEPOS sp;

            spThis       = pls->spNext;
            pls->spNext += cStylePels;

            {
                if (pls->spNext >= pls->spTotal2)
                    pls->spNext %= pls->spTotal2;

                if (fl & FL_FLIP_H)
                    sp = pls->spNext - x0 + xStart;
                else
                    sp = spThis + x0 - xStart;

                ASSERTDD(fl & FL_STYLED, "Oops");

            // Normalize our target style position:

                if ((sp < 0) || (sp >= pls->spTotal2))
                {
                    sp %= pls->spTotal2;

                // The modulus of a negative number is not well-defined
                // in C -- if it's negative we'll adjust it so that it's
                // back in the range [0, spTotal2):

                    if (sp < 0)
                        sp += pls->spTotal2;
                }

            // Since we always draw the line left-to-right, but styling is
            // always done in the direction of the original line, we have
            // to figure out where we are in the style array for the left
            // edge of this line.

                if (fl & FL_FLIP_H)
                {
                // Line originally ran right-to-left:

                    sp = -sp;
                    if (sp < 0)
                        sp += pls->spTotal2;

                    pls->ulStyleMask = ~pls->ulStartMask;
                    pls->pspStart    = &pls->aspRtoL[0];
                    pls->pspEnd      = &pls->aspRtoL[pls->cStyle - 1];
                }
                else
                {
                // Line originally ran left-to-right:

                    pls->ulStyleMask = pls->ulStartMask;
                    pls->pspStart    = &pls->aspLtoR[0];
                    pls->pspEnd      = &pls->aspLtoR[pls->cStyle - 1];
                }

                if (sp >= pls->spTotal)
                {
                    sp -= pls->spTotal;
                    if (pls->cStyle & 1)
                        pls->ulStyleMask = ~pls->ulStyleMask;
                }

                pls->psp = pls->pspStart;
                while (sp >= *pls->psp)
                    sp -= *pls->psp++;

                ASSERTDD(pls->psp <= pls->pspEnd,
                        "Flew off into NeverNeverLand");

                pls->spRemaining = *pls->psp - sp;
                if ((pls->psp - pls->pspStart) & 1)
                    pls->ulStyleMask = ~pls->ulStyleMask;
            }
        }

        plStrip    = &strip.alStrips[0];
        plStripEnd = &strip.alStrips[STRIP_MAX];    // Is exclusive
        cStripsInNextRun   = 0x7fffffff;

	strip.ptlStart = ptlStart;

        if (2 * dN > dM &&
            !(fl & FL_STYLED))
        {
        // Do a half flip!  Remember that we may doing this on the
        // same line multiple times for complex clipping (meaning the
        // affected variables should be reset for every clip run):

            fl |= FL_FLIP_HALF;

            llBeta  = llGamma - (LONGLONG) ((LONG) dM);
            dN = dM - dN;
            y0 = x0 - y0;       // Note this may overflow, but that's okay
        }

    // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips = fl;
        pfn           = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

    // Now calculate the DDA variables needed to figure out how many pixels
    // go in the very first strip:

        {
            register LONG  i;
            register ULONG dI;
            register ULONG dR;
                     ULONG r;

            if (dN == 0)
                i = 0x7fffffff;
            else
            {
                dl = UInt32x32To64(y0 + 1, dM) + llBeta;

                ASSERTDD(dl >= 0, "Oops!");

            // i = (dl / dN) - x0 + 1;
            // r = (dl % dN);

                i = UInt64Div32To32(dl, dN);
                r = UInt64Mod32To32(dl, dN);
                i = i - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN

                ASSERTDD(dI > 0, "Weird dI");
            }

            ASSERTDD(i > 0 && i <= 0x7fffffff, "Weird initial strip length");
            ASSERTDD(cPels > 0, "Zero pel line");

/***********************************************************************\
* Run the DDA!                                                          *
\***********************************************************************/

            while(TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
                    (*pfn)(ppdev, &strip, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
            (*pfn)(ppdev, &strip, pls);


        }

    Next_Line:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }

    } while (pptfxBuf < pptfxBufEnd);

    return(TRUE);

}

//////////////////////////////////////////////////////////////////////////
// General defines for bHardwareLine

#define HW_FLIP_D           0x0001L     // Diagonal flip
#define HW_FLIP_V           0x0002L     // Vertical flip
#define HW_FLIP_H           0x0004L     // Horizontal flip
#define HW_FLIP_SLOPE_ONE   0x0008L     // Normalized line has exactly slope one
#define HW_FLIP_MASK        (HW_FLIP_D | HW_FLIP_V | HW_FLIP_H)

#define HW_X_ROUND_DOWN     0x0100L     // x = 1/2 rounds down in value
#define HW_Y_ROUND_DOWN     0x0200L     // y = 1/2 rounds down in value

LONG gaiDir[] = { 0, 1, 7, 6, 3, 2, 4, 5 };

FLONG gaflHardwareRound[] = {
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        |
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    //           |        | FLIP_V |
    HW_Y_ROUND_DOWN,                    //           |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    //           | FLIP_H |        |
    HW_X_ROUND_DOWN,                    //           | FLIP_H |        | FLIP_D
    0,                                  //           | FLIP_H | FLIP_V |
    0,                                  //           | FLIP_H | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE |        |        |
    0xffffffff,                         // SLOPE_ONE |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE |        | FLIP_V |
    0xffffffff,                         // SLOPE_ONE |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H |        |
    0xffffffff,                         // SLOPE_ONE | FLIP_H |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H | FLIP_V |
    0xffffffff                          // SLOPE_ONE | FLIP_H | FLIP_V | FLIP_D
};

#if 0
//////////////////////////////////////////////////////////////////////////
// S3 specific defines

#define DEFAULT_DRAW_CMD (DRAW_LINE | DRAW | DIR_TYPE_XY | MULTIPLE_PIXELS | \
                          WRITE | LAST_PIXEL_OFF)

LONG gaiDrawCmd[] = {
    DEFAULT_DRAW_CMD | PLUS_X | PLUS_Y |       0,   // Octant 0
    DEFAULT_DRAW_CMD | PLUS_X | PLUS_Y | MAJOR_Y,   // Octant 1
    DEFAULT_DRAW_CMD | PLUS_X |      0 |       0,   // Octant 7
    DEFAULT_DRAW_CMD | PLUS_X |      0 | MAJOR_Y,   // Octant 6
    DEFAULT_DRAW_CMD | 0      | PLUS_Y |       0,   // Octant 3
    DEFAULT_DRAW_CMD | 0      | PLUS_Y | MAJOR_Y,   // Octant 2
    DEFAULT_DRAW_CMD | 0      |      0 |       0,   // Octant 4
    DEFAULT_DRAW_CMD | 0      |      0 | MAJOR_Y,   // Octant 5
};

#endif

// The S3's hardware can have 13 bits of significance for the error and
// step terms:

#define NUM_DDA_BITS 13

/******************************Public*Routine******************************\
* BOOL bHardwareLine(ppdev, pptfxStart, pptfxEnd)
*
* This routine is useful for folks who have line drawing hardware where
* they can explicitly set the Bresenham terms -- they can use this routine
* to draw fractional coordinate GIQ lines with the hardware.
*
* Fractional coordinate lines require an extra 4 bits of precision in the
* Bresenham terms.  For example, if your hardware has 13 bits of precision
* for the terms, you can only draw GIQ lines up to 255 pels long using this
* routine.
*
* Input:
*   pptfxStart  - Points to GIQ coordinate of start of line
*   pptfxEnd    - Points to GIQ coordinate of end of line
*   NUM_DDA_BITS- The number of bits of precision your hardware can support.
*
* Output:
*   returns     - TRUE if the line was drawn.
*                 FALSE if the line is too long, and the strips code must be
*                 used.
*
* DDALINE:
*   iDir        - Direction of the line, as an octant numbered as follows:
*
*                    \ 5 | 6 /
*                     \  |  /
*                    4 \ | / 7
*                       \ /
*                   -----+-----
*                       /|\
*                    3 / | \ 0
*                     /  |  \
*                    / 2 | 1 \
*
*   ptlStart    - Start pixel of line.
*   cPels       - # of pels in line.  *NOTE* You must check if this is <= 0!
*   dMajor      - Major axis delta.
*   dMinor      - Minor axis delta.
*   lErrorTerm  - Error term.
*
* What you do with the last 3 terms may be a little tricky.  They are
* actually the terms for the formula of the normalized line
*
*                     dMinor * x + (lErrorTerm + dMajor)
*       y(x) = floor( ---------------------------------- )
*                                  dMajor
*
* where y(x) is the y coordinate of the pixel to be lit as a function of
* the x-coordinate.
*
* Every time the line advances one in the major direction 'x', dMinor
* gets added to the current error term.  If the resulting value is >= 0,
* we know we have to move one pixel in the minor direction 'y', and
* dMajor must be subtracted from the current error term.
*
* If you're trying to figure out what this means for your hardware, you can
* think of the DDALINE terms as having been computed equivalently as
* follows:
*
*     dMinor     = 2 * (minor axis delta)
*     dMajor     = 2 * (major axis delta)
*     lErrorTerm = - (major axis delta) - fixup
*
* That is, if your documentation tells you that for integer lines, a
* register is supposed to be initialized with the value
* '2 * (minor axis delta)', you'll actually use dMinor.
*
* Example: Setting up the 8514
*
*     AXSTPSIGN is supposed to be the axial step constant register, defined
*     as 2 * (minor axis delta).  You set:
*
*           AXSTPSIGN = dMinor
*
*     DGSTPSIGN is supposed to be the diagonal step constant register,
*     defined as 2 * (minor axis delta) - 2 * (major axis delta).  You set:
*
*           DGSTPSIGN = dMinor - dMajor
*
*     ERR_TERM is supposed to be the adjusted error term, defined as
*     2 * (minor axis delta) - (major axis delta) - fixup.  You set:
*
*           ERR_TERM = lErrorTerm + dMinor
*
* Implementation:
*
*     You'll want to special case integer lines before calling this routine
*     (since they're very common, take less time to the computation of line
*     terms, and can handle longer lines than this routine because 4 bits
*     aren't being given to the fraction).
*
*     If a GIQ line is too long to be handled by this routine, you can just
*     use the slower strip routines for that line.  Note that you cannot
*     just fail the call -- you must be able to accurately draw any line
*     in the 28.4 device space when it intersects the viewport.
*
* Testing:
*
*     Use Guiman, or some other test that draws random fractional coordinate
*     lines and compares them to what GDI itself draws to a bitmap.
*
\**************************************************************************/

BOOL bHardwareLine(
PDEV*     ppdev,
POINTFIX* pptfxStart,       // Start of line
POINTFIX* pptfxEnd)         // End of line
{
    FLONG fl;    // Various flags
    ULONG M0;    // Normalized fractional unit x start coordinate (0 <= M0 < F)
    ULONG N0;    // Normalized fractional unit y start coordinate (0 <= N0 < F)
    ULONG M1;    // Normalized fractional unit x end coordinate (0 <= M1 < F)
    ULONG N1;    // Normalized fractional unit x end coordinate (0 <= N1 < F)
    ULONG dM;    // Normalized fractional unit x-delta (0 <= dM)
    ULONG dN;    // Normalized fractional unit y-delta (0 <= dN <= dM)
    LONG  x;     // Normalized x coordinate of origin
    LONG  y;     // Normalized y coordinate of origin
    LONG  x0;    // Normalized x offset from origin to start pixel (inclusive)
    LONG  y0;    // Normalized y offset from origin to start pixel (inclusive)
    LONG  x1;    // Normalized x offset from origin to end pixel (inclusive)
    LONG  lGamma;// Bresenham error term at origin
    LONG  cPels; // Number of pixels in line

/***********************************************************************\
* Normalize line to the first octant.
\***********************************************************************/

    fl = 0;

    M0 = pptfxStart->x;
    dM = pptfxEnd->x;

    if ((LONG) dM < (LONG) M0)
    {
    // Line runs from right to left, so flip across x = 0:

        M0 = -(LONG) M0;
        dM = -(LONG) dM;
        fl |= HW_FLIP_H;
    }

// Compute the delta.  The DDI says we can never have a valid delta
// with a magnitude more than 2^31 - 1, but the engine never actually
// checks its transforms.  To ensure that we'll never puke on our shoes,
// we check for that case and simply refuse to draw the line:

    dM -= M0;
    if ((LONG) dM < 0)
        return(FALSE);

    N0 = pptfxStart->y;
    dN = pptfxEnd->y;

    if ((LONG) dN < (LONG) N0)
    {
    // Line runs from bottom to top, so flip across y = 0:

        N0 = -(LONG) N0;
        dN = -(LONG) dN;
        fl |= HW_FLIP_V;
    }

// Compute another delta:

    dN -= N0;
    if ((LONG) dN < 0)
        return(FALSE);

    if (dN >= dM)
    {
        if (dN == dM)
        {
        // Have to special case slopes of one:

            fl |= HW_FLIP_SLOPE_ONE;
        }
        else
        {
        // Since line has slope greater than 1, flip across x = y:

            register ULONG ulTmp;
            ulTmp = dM; dM = dN; dN = ulTmp;
            ulTmp = M0; M0 = N0; N0 = ulTmp;
            fl |= HW_FLIP_D;
        }
    }

// Figure out if we can do the line in hardware, given that we have a
// limited number of bits of precision for the Bresenham terms.
//
// Remember that one bit has to be kept as a sign bit:

    if ((LONG) dM >= (1L << (NUM_DDA_BITS - 1)))
        return(FALSE);

    fl |= gaflHardwareRound[fl];

/***********************************************************************\
* Calculate the error term at pixel 0.
\***********************************************************************/

    x = LFLOOR((LONG) M0);
    y = LFLOOR((LONG) N0);

    M0 = FXFRAC(M0);
    N0 = FXFRAC(N0);

// NOTE NOTE NOTE: If this routine were to handle any line in the 28.4
// space, it will overflow its math (the following part requires 36 bits
// of precision)!  But we get here for lines that the hardware can handle
// (see the expression (dM >= (1L << (NUM_DDA_BITS - 1))) above?), so if
// cBits is less than 28, we're safe.
//
// If you're going to use this routine to handle all lines in the 28.4
// device space, you will HAVE to make sure the math doesn't overflow,
// otherwise you won't be NT compliant!  (See 'bHardwareLine' for an example
// how to do that.  You don't have to worry about this if you simply
// default to the strips code for long lines, because those routines
// already do the math correctly.)

// Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ].  Note
// that M0 and N0 have at most 4 bits of significance (and if the
// arguments are properly ordered, on a 486 each multiply would be no
// more than 13 cycles):

    lGamma = (N0 + F/2) * dM - M0 * dN;

    if (fl & HW_Y_ROUND_DOWN)
        lGamma--;

    lGamma >>= FLOG2;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.
\***********************************************************************/

// The toughest part of GIQ is determining the start and end pels.
//
// Our approach here is to calculate x0 and x1 (the inclusive start
// and end columns of the line respectively, relative to our normalized
// origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
// start point is easily calculated by plugging x0 into our line equation
// (which takes care of whether y = 1/2 rounds up or down in value)
// getting y0, and then undoing the normalizing flips to get back
// into device space.
//
// We look at the fractional parts of the coordinates of the start and
// end points, and call them (M0, N0) and (M1, N1) respectively, where
// 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
// to determine x0:
//
//   +-----------------------> +x
//   |
//   | 0                     1
//   |     0123456789abcdef
//   |
//   |   0 ........?xxxxxxx
//   |   1 ..........xxxxxx
//   |   2 ...........xxxxx
//   |   3 ............xxxx
//   |   4 .............xxx
//   |   5 ..............xx
//   |   6 ...............x
//   |   7 ................
//   |   8 ................
//   |   9 ......**........
//   |   a ........****...x
//   |   b ............****
//   |   c .............xxx****
//   |   d ............xxxx    ****
//   |   e ...........xxxxx        ****
//   |   f ..........xxxxxx
//   |
//   | 2                     3
//   v
//
//   +y
//
// This grid accounts for the appropriate rounding of GIQ and last-pel
// exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
// on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
// depending on what flips have been done to normalize the line.
//
// For the end point, if (M1, N1) lands on an 'x', x1 =
// floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
// floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
// depending on what flips have been done to normalize the line.
//
// Lines of exactly slope one require a special case for both the start
// and end.  For example, if the line ends such that (M1, N1) is (9, 1),
// the line has gone exactly through (8, 0) -- which may be considered
// to be part of 'x' because of rounding!  So slopes of exactly slope
// one going through (8, 0) must also be considered as belonging in 'x'
// when an x value of 1/2 is supposed to round up in value.

// Calculate x0, x1:

    N1 = FXFRAC(N0 + dN);
    M1 = FXFRAC(M0 + dM);

    x1 = LFLOOR(M0 + dM);

// Line runs left-to-right:

// Compute x1:

    x1--;
    if (M1 > 0)
    {
        if (N1 == 0)
        {
            if (LROUND(M1, fl & HW_X_ROUND_DOWN))
                x1++;
        }
        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
        {
            x1++;
        }
    }

    if ((fl & (HW_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
           == (HW_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
    {
    // Have to special-case diagonal lines going through our
    // the point exactly equidistant between two horizontal
    // pixels, if we're supposed to round x=1/2 down:

        if ((M1 > 0) && (N1 == M1 + 8))
            x1--;

        if ((M0 > 0) && (N0 == M0 + 8))
        {
            x0 = 0;
            goto left_to_right_compute_y0;
        }
    }

// Compute x0:

    x0 = 0;
    if (M0 > 0)
    {
        if (N0 == 0)
        {
            if (LROUND(M0, fl & HW_X_ROUND_DOWN))
                x0 = 1;
        }
        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
        {
            x0 = 1;
        }
    }

left_to_right_compute_y0:

/***********************************************************************\
* Calculate the start pixel.
\***********************************************************************/

// We now compute y0 and adjust the error term.  We know x0, and we know
// the current formula for the pixels to be lit on the line:
//
//                     dN * x + lGamma
//       y(x) = floor( --------------- )
//                           dM
//
// The remainder of this expression is the new error term at (x0, y0).
// Since x0 is going to be either 0 or 1, we don't actually have to do a
// multiply or divide to compute y0.  Finally, we subtract dM from the
// new error term so that it is in the range [-dM, 0).

    y0      = 0;
    lGamma += (dN & (-x0));
    lGamma -= dM;
    if (lGamma >= 0)
    {
        y0      = 1;
        lGamma -= dM;
    }

// Undo our flips to get the start coordinate:

    x += x0;
    y += y0;

    if (fl & HW_FLIP_D)
    {
        register LONG lTmp;
        lTmp = x; x = y; y = lTmp;
    }

    if (fl & HW_FLIP_V)
    {
        y = -y;
    }

    if (fl & HW_FLIP_H)
    {
        x = -x;
    }

/***********************************************************************\
* Return the Bresenham terms:
\***********************************************************************/

    // iDir       = gaiDir[fl & HW_FLIP_MASK];
    // ptlStart.x = x;
    // ptlStart.y = y;
    // cPels      = x1 - x0 + 1;  // NOTE: You'll have to check if cPels <= 0!
    // dMajor     = dM;
    // dMinor     = dN;
    // lErrorTerm = lGamma;

/***********************************************************************\
* Draw the line.  S3 specific code follows:
\***********************************************************************/

    cPels = x1 - x0 + 1;
#if 0
    if (cPels > 0)
    {
        IO_FIFO_WAIT(ppdev, 7);

        IO_CUR_X(ppdev, x);
        IO_CUR_Y(ppdev, y);
        IO_MAJ_AXIS_PCNT(ppdev, cPels);
        IO_AXSTP(ppdev, dN);
        IO_DIASTP(ppdev, dN - dM);
        IO_ERR_TERM(ppdev, dN + lGamma);
        IO_CMD(ppdev, gaiDrawCmd[fl & HW_FLIP_MASK]);
    }
#endif
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\intline.c ===
/*************************************************************************\
* Module Name: intline.c
*
* Copyright (c) 1993-1994 Microsoft Corporation
* Copyright (c) 1992      Digital Equipment Corporation
\**************************************************************************/

#include "precomp.h"


/******************************************************************************
 * bIntegerLine
 *
 * This routine attempts to draw a line segment between two points. It
 * will only draw if both end points are whole integers: it does not support
 * fractional endpoints.
 *
 * Returns:
 *   TRUE     if the line segment is drawn
 *   FALSE    otherwise
 *****************************************************************************/

BOOL
bIntegerLine (
PDEV*   ppdev,
ULONG	x1,
ULONG	y1,
ULONG	x2,
ULONG	y2
)
{
    BYTE*   pjBase = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    xyOffset = ppdev->xyOffset;
    ULONG   ulDst;
    LONG	dx;
    LONG    dy;
    LONG    fudge;
    BYTE    jLineDrawCmd = (LINE_DRAW | LINE_USE_ERROR_TERM);
    LONG	ErrorTerm;

    //
    // This code assumes that CP_PEL_DEPTH()
    // has been set to ((cBpp - 1) << 4)
    //
    // This is done in stroke.c before this routine is called.
    //
    // Unfortunately, I can't verify it with an ASSERT because values
    // in the queue cannot be read back.
    //

    x1 >>= 4;
    y1 >>= 4;
    x2 >>= 4;
    y2 >>= 4;

    dx = x2 - x1;
    dy = y2 - y1;

    if ((dx == 0) && (dy == 0))
    {
        goto ReturnTrue;
    }

    ulDst = (y1 * lDelta) + (cBpp * x1);
    ulDst += xyOffset;

    //
    // If dx and dy have different signs and the line is Y Major then
    // we'll have to adjust the Error Term by 1.
    //

    fudge = ((dx ^ dy) < 0)? 1:0;

    if (dx < 0)
    {
        ulDst += (cBpp-1);
        CP_PAT_ADDR(ppdev, pjBase, (ppdev->ulSolidColorOffset + cBpp -1));
        jLineDrawCmd |= LINE_X_NEG;
        dx = -dx;
    }

    if (dy < 0)
    {
        fudge = -fudge;
        jLineDrawCmd |= LINE_Y_NEG;
        dy = -dy;
    }

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta - 1));

    if (dx > dy)
    {
        // x major

        jLineDrawCmd |= LINE_X_MAJOR;
        ErrorTerm = dx;

        CP_XCNT(ppdev, pjBase, ((dx - 1) * cBpp));
        CP_YCNT(ppdev, pjBase, 0xfff);
        CP_DELTA_MINOR(ppdev, pjBase, dy);
        CP_DELTA_MAJOR(ppdev, pjBase, dx);
    }
    else
    {
        // y major

        ErrorTerm = dy - fudge;

        CP_XCNT(ppdev, pjBase, 0xfff);
        CP_YCNT(ppdev, pjBase, (dy - 1));
        CP_DELTA_MINOR(ppdev, pjBase, dx);
        CP_DELTA_MAJOR(ppdev, pjBase, dy);
    }

    CP_XY_DIR(ppdev, pjBase, jLineDrawCmd);
    CP_ERR_TERM(ppdev, pjBase, ErrorTerm);
    CP_DST_ADDR(ppdev, pjBase, ulDst);

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_XY_DIR(ppdev, pjBase, 0);
    CP_PAT_ADDR(ppdev, pjBase, (ppdev->ulSolidColorOffset));

ReturnTrue:
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\paint.c ===
/******************************Module*Header*******************************\
* Module Name: paint.c
*
* Copyright (c) 1992-1994 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaMix[] =
{
    0xFF,  // R2_WHITE        - Allow rop = gaMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE        - Allow rop = gaMix[mix & 0xFF]
};

/******************************Public*Routine******************************\
* BOOL DrvPaint
*
\**************************************************************************/

BOOL DrvPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    ROP4 rop4;

    rop4 = ((MIX) gaMix[mix >> 8] << 8) | gaMix[mix & 0xf];

    // Since our DrvFillPath routine handles almost all fills, DrvPaint
    // won't get called all that much (mainly via PaintRgn, FillRgn, or
    // complex clipped polygons).  As such, we save some code and simply
    // punt to DrvBitBlt:

    return(DrvBitBlt(pso, NULL, NULL, pco, NULL, &pco->rclBounds, NULL,
                     NULL, pbo, pptlBrush, rop4));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\heap.c ===
/******************************Module*Header*******************************\
* Module Name: heap.c
*
* This module contains the routines for a 2-d heap.  It is used primarily
* for allocating space for device-format-bitmaps in off-screen memory.
*
* Off-screen bitmaps are a big deal on NT because:
*
*    1) It reduces the working set.  Any bitmap stored in off-screen
*       memory is a bitmap that isn't taking up space in main memory.
*
*    2) There is a speed win by using the accelerator hardware for
*       drawing, in place of NT's GDI code.  NT's GDI is written entirely
*       in 'C++' and perhaps isn't as fast as it could be.
*
*    3) It leads naturally to nifty tricks that can take advantage of
*       the hardware, such as MaskBlt support and cheap double buffering
*       for OpenGL.
*
* The heap algorithm employed herein attempts to solve an unsolvable
* problem: the problem of keeping arbitrary sized bitmaps as packed as
* possible in a 2-d space, when the bitmaps can come and go at random.
*
* This problem is due entirely to the nature of the hardware for which this
* driver is written: the hardware treats everything as 2-d quantities.  If
* the hardware bitmap pitch could be changed so that the bitmaps could be
* packed linearly in memory, the problem would be infinitely easier (it is
* much easier to track the memory, and the accelerator can be used to re-pack
* the heap to avoid segmentation).
*
* If your hardware can treat bitmaps as one dimensional quantities (as can
* the XGA and ATI), by all means please implement a new off-screen heap.
*
* When the heap gets full, old allocations will automatically be punted
* from off-screen and copied to DIBs, which we'll let GDI draw on.
*
* Note that this heap manages reverse-L shape off-screen memory
* configurations (where the scan pitch is longer than the visible screen,
* such as happens at 800x600 when the scan length must be a multiple of
* 1024).
*
* NOTE: All heap operations must be done under some sort of synchronization,
*       whether it's controlled by GDI or explicitly by the driver.  All
*       the routines in this module assume that they have exclusive access
*       to the heap data structures; multiple threads partying in here at
*       the same time would be a Bad Thing.  (By default, GDI does NOT
*       synchronize drawing on device-created bitmaps.)
*
* Copyright (c) 1993-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define OH_ALLOC_SIZE   4000        // Do all memory allocations in 4k chunks
#define OH_QUANTUM      4           // The minimum dimension of an allocation
#define CXCY_SENTINEL   0x7fffffff  // The sentinel at the end of the available
                                    //  list has this very large 'cxcy' value

// This macro results in the available list being maintained with a
// cx-major, cy-minor sort:

#define CXCY(cx, cy) (((cx) << 16) | (cy))

/******************************Public*Routine******************************\
* OH* pohNewNode
*
* Allocates a basic memory unit in which we'll pack our data structures.
*
* Since we'll have a lot of OH nodes, most of which we will be
* occasionally traversing, we do our own memory allocation scheme to
* keep them densely packed in memory.
*
* It would be the worst possible thing for the working set to simply
* call EngAllocMem(sizeof(OH)) every time we needed a new node.  There
* would be no locality; OH nodes would get scattered throughout memory,
* and as we traversed the available list for one of our allocations,
* it would be far more likely that we would hit a hard page fault.
\**************************************************************************/

OH* pohNewNode(
PDEV*   ppdev)
{
    LONG     i;
    LONG     cOhs;
    OHALLOC* poha;
    OH*      poh;

    if (ppdev->heap.pohFreeList == NULL)
    {
        // We zero-init to initialize all the OH flags, and to help in
        // debugging (we can afford to do this since we'll be doing this
        // very infrequently):

        poha = EngAllocMem(FL_ZERO_MEMORY, OH_ALLOC_SIZE, ALLOC_TAG);
        if (poha == NULL)
            return(NULL);

        // Insert this OHALLOC at the begining of the OHALLOC chain:

        poha->pohaNext  = ppdev->heap.pohaChain;
        ppdev->heap.pohaChain = poha;

        // This has a '+ 1' because OHALLOC includes an extra OH in its
        // structure declaration:

        cOhs = (OH_ALLOC_SIZE - sizeof(OHALLOC)) / sizeof(OH) + 1;

        // The big OHALLOC allocation is simply a container for a bunch of
        // OH data structures in an array.  The new OH data structures are
        // linked together and added to the OH free list:

        poh = &poha->aoh[0];
        for (i = cOhs - 1; i != 0; i--)
        {
            poh->pohNext = poh + 1;
            poh          = poh + 1;
        }

        poh->pohNext      = NULL;
        ppdev->heap.pohFreeList = &poha->aoh[0];
    }

    poh = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh->pohNext;

    return(poh);
}

/******************************Public*Routine******************************\
* VOID vOhFreeNode
*
* Frees our basic data structure allocation unit by adding it to a free
* list.
*
\**************************************************************************/

VOID vOhFreeNode(
PDEV*   ppdev,
OH*     poh)
{
    if (poh == NULL)
        return;

    poh->pohNext            = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh;
    poh->ohState            = -1;
}

/******************************Public*Routine******************************\
* VOID vCalculateMaximumNonPermanent
*
* Traverses the list of in-use and available rectangles to find the one
* with the maximal area.
*
\**************************************************************************/

VOID vCalculateMaximumNonPermanent(
PDEV*   ppdev)
{
    OH*     poh;
    OH*     pohSentinel;
    LONG    lArea;
    LONG    lMaxArea;
    LONG    cxMax;
    LONG    cyMax;
    LONG    i;

    lMaxArea = 0;
    cxMax    = 0;
    cyMax    = 0;

    // First time through, loop through the list of free available
    // rectangles:

    pohSentinel = &ppdev->heap.ohFree;

    for (i = 2; i != 0; i--)
    {
        for (poh = pohSentinel->pohNext; poh != pohSentinel; poh = poh->pohNext)
        {
            ASSERTDD(poh->ohState != OH_PERMANENT,
                     "Permanent node in free or discardable list");

            // We don't have worry about this multiply overflowing
            // because we are dealing in physical screen coordinates,
            // which will probably never be more than 15 bits:

            lArea = poh->cx * poh->cy;
            if (lArea > lMaxArea)
            {
                cxMax    = poh->cx;
                cyMax    = poh->cy;
                lMaxArea = lArea;
            }
        }

        // Second time through, loop through the list of discardable
        // rectangles:

        pohSentinel = &ppdev->heap.ohDiscardable;
    }

    // All that we are interested in is the dimensions of the rectangle
    // that has the largest possible available area (and remember that
    // there might not be any possible available area):

    ppdev->heap.cxMax = cxMax;
    ppdev->heap.cyMax = cyMax;
}

/******************************Public*Routine******************************\
* OH* pohFree
*
* Frees an off-screen heap allocation.  The free space will be combined
* with any adjacent free spaces to avoid segmentation of the 2-d heap.
*
* Note: A key idea here is that the data structure for the upper-left-
*       most node must be kept at the same physical CPU memory so that
*       adjacency links are kept correctly (when two free spaces are
*       merged, the lower or right node can be freed).
*
\**************************************************************************/

OH* pohFree(
PDEV*   ppdev,
OH*     poh)
{
    ULONG   cxcy;
    OH*     pohBeside;
    OH*     pohNext;
    OH*     pohPrev;
    OHSTATE oldState;

    if (poh == NULL)
        return(NULL);

    DISPDBG((2, "Freeing %li x %li at (%li, %li)",
            poh->cx, poh->cy, poh->x, poh->y));

    #if DEBUG_HEAP
    {
        RECTL           rclBitmap;
        RBRUSH_COLOR    rbc;
        LONG            xOffset;
        LONG            yOffset;
        LONG            xyOffset;

        rclBitmap.left   = poh->x;
        rclBitmap.top    = poh->y;
        rclBitmap.right  = poh->x + poh->cx;
        rclBitmap.bottom = poh->y + poh->cy;

        xOffset  = ppdev->xOffset;
        yOffset  = ppdev->yOffset;
        xyOffset = ppdev->xyOffset;

        ppdev->xOffset  = 0;
        ppdev->yOffset  = 0;
        ppdev->xyOffset = 0;

        ppdev->pfnFillSolid(ppdev, 1, &rclBitmap, 0x0, rbc, NULL);

        ppdev->xOffset  = xOffset;
        ppdev->yOffset  = yOffset;
        ppdev->xyOffset = xyOffset;
    }
    #endif

    oldState = poh->ohState;
    if (oldState != OH_DISCARDABLE)
    {
        // We can remove the 'reserved' status unless we are merely
        // deleting a discardable rectangle that was temporarily
        // placed in a reserve rectangle:

        poh->cxReserved = 0;
        poh->cyReserved = 0;
    }

    // Update the uniqueness to show that space has been freed, so that
    // we may decide to see if some DIBs can be moved back into off-screen
    // memory:

    ppdev->iHeapUniq++;

MergeLoop:

    // Try merging with the right sibling:

    pohBeside = poh->pohRight;
    if ((poh->cxReserved    != poh->cx)         &&
        (pohBeside->ohState == OH_FREE)         &&
        (pohBeside->cy      == poh->cy)         &&
        (pohBeside->pohUp   == poh->pohUp)      &&
        (pohBeside->pohDown == poh->pohDown)    &&
        (pohBeside->pohRight->pohLeft != pohBeside))
    {
        // Add the right rectangle to ours:

        poh->cx      += pohBeside->cx;
        poh->pohRight = pohBeside->pohRight;

        // Remove 'pohBeside' from the free list and free it:

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Try merging with the lower sibling:

    pohBeside = poh->pohDown;
    if ((poh->cyReserved     != poh->cy)        &&
        (pohBeside->ohState  == OH_FREE)        &&
        (pohBeside->cx       == poh->cx)        &&
        (pohBeside->pohLeft  == poh->pohLeft)   &&
        (pohBeside->pohRight == poh->pohRight)  &&
        (pohBeside->pohDown->pohUp != pohBeside))
    {
        poh->cy     += pohBeside->cy;
        poh->pohDown = pohBeside->pohDown;

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Don't do any more merge this rectangle into anything to the
    // top or to the left if it's reserved:

    if (!poh->cxReserved)
    {
        // Try merging with the left sibling:

        pohBeside = poh->pohLeft;
        if ((pohBeside->cxReserved != pohBeside->cx) &&
            (pohBeside->ohState    == OH_FREE)       &&
            (pohBeside->cy         == poh->cy)       &&
            (pohBeside->pohUp      == poh->pohUp)    &&
            (pohBeside->pohDown    == poh->pohDown)  &&
            (pohBeside->pohRight   == poh)           &&
            (poh->pohRight->pohLeft != poh))
        {
            // We add our rectangle to the one to the left:

            pohBeside->cx      += poh->cx;
            pohBeside->pohRight = poh->pohRight;

            // Remove 'poh' from whatever list it was in (if we were
            // asked to free a 'permanent' node, it will have been in
            // the permanent list) and free it:

            poh->pohNext->pohPrev = poh->pohPrev;
            poh->pohPrev->pohNext = poh->pohNext;

            vOhFreeNode(ppdev, poh);

            poh = pohBeside;
            goto MergeLoop;
        }

        // Try merging with the upper sibling:

        pohBeside = poh->pohUp;
        if ((pohBeside->cyReserved != pohBeside->cy) &&
            (pohBeside->ohState    == OH_FREE)       &&
            (pohBeside->cx         == poh->cx)       &&
            (pohBeside->pohLeft    == poh->pohLeft)  &&
            (pohBeside->pohRight   == poh->pohRight) &&
            (pohBeside->pohDown    == poh)           &&
            (poh->pohDown->pohUp != poh))
        {
            pohBeside->cy      += poh->cy;
            pohBeside->pohDown  = poh->pohDown;

            poh->pohNext->pohPrev = poh->pohPrev;
            poh->pohPrev->pohNext = poh->pohNext;

            vOhFreeNode(ppdev, poh);

            poh = pohBeside;
            goto MergeLoop;
        }
    }

    // Remove this node from whatever list it's in:

    poh->pohNext->pohPrev = poh->pohPrev;
    poh->pohPrev->pohNext = poh->pohNext;

    cxcy = CXCY(poh->cx, poh->cy);

    // Insert the node, in order, into the free list:

    pohNext = ppdev->heap.ohFree.pohNext;
    while (pohNext->cxcy < cxcy)
    {
        pohNext = pohNext->pohNext;
    }
    pohPrev = pohNext->pohPrev;

    pohPrev->pohNext = poh;
    pohNext->pohPrev = poh;
    poh->pohPrev     = pohPrev;
    poh->pohNext     = pohNext;
    poh->cxcy        = cxcy;
    poh->ohState     = OH_FREE;

    if (oldState == OH_PERMANENT)
    {
        // Removing the permanent entry means that we may be able to
        // enlarge the maximum possible rectangle we can allow:

        vCalculateMaximumNonPermanent(ppdev);
    }

    // Return the node pointer for the new and improved available rectangle:

    return(poh);
}

/******************************Public*Routine******************************\
* BOOL bDiscardEverythingInRectangle
*
* Throws out of the heap any discardable bitmaps that intersect with the
* specified rectangle.
*
\**************************************************************************/

BOOL bDiscardEverythingInRectangle(
PDEV*   ppdev,
LONG    x,
LONG    y,
LONG    cx,
LONG    cy)
{
    BOOL bRet;
    OH*  poh;
    OH*  pohNext;

    bRet = TRUE;        // Assume success

    poh = ppdev->heap.ohDiscardable.pohNext;
    while (poh != &ppdev->heap.ohDiscardable)
    {
        ASSERTDD(poh->ohState == OH_DISCARDABLE,
                 "Non-discardable node in discardable list");

        pohNext = poh->pohNext;

        if ((poh->x < x + cx) &&
            (poh->y < y + cy) &&
            (poh->x + poh->cx > x) &&
            (poh->y + poh->cy > y))
        {
            // The two rectangles intersect.  Give the boot to the
            // discardable bitmap:

            if (!pohMoveOffscreenDfbToDib(ppdev, poh))
                bRet = FALSE;
        }

        poh = pohNext;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bFreeRightAndBottomSpace
*
* Given a free off-screen rectangle, allocates the upper-left part of
* the rectangle to hold the allocation request, and puts the two rectangles
* comprising the unused right and bottom portions on the free list.
*
\**************************************************************************/

BOOL bFreeRightAndBottomSpace(
PDEV*   ppdev,
OH*     pohThis,
LONG    cxThis,
LONG    cyThis,
BOOL    bQuantum)           // Set if inifitely small allocations should be
                            //   allowed
{
    ULONG cxcy;             // Temporary versions
    OH*   pohNext;
    OH*   pohPrev;
    LONG  cxRem;
    LONG  cyRem;
    OH*   pohBelow;
    LONG  cxBelow;
    LONG  cyBelow;
    OH*   pohBeside;
    LONG  cxBeside;
    LONG  cyBeside;
    LONG  cQuantum;

    // We're going to use the upper-left corner of our given rectangle,
    // and divide the unused remainder into two rectangles which will
    // go on the free list.

    // Compute the width of the unused rectangle to the right, and the
    // height of the unused rectangle below:

    cyRem = pohThis->cy - cyThis;
    cxRem = pohThis->cx - cxThis;

    // Given finite area, we wish to find the two rectangles that are
    // most square -- i.e., the arrangement that gives two rectangles
    // with the least perimiter:

    cyBelow  = cyRem;
    cxBeside = cxRem;

    if (cxRem <= cyRem)
    {
        cxBelow  = cxThis + cxRem;
        cyBeside = cyThis;
    }
    else
    {
        cxBelow  = cxThis;
        cyBeside = cyThis + cyRem;
    }

    // If 'bQuantum' is set, we only make new available rectangles of
    // the unused right and bottom portions if they're greater in
    // dimension than OH_QUANTUM (it hardly makes sense to do the
    // book-work to keep around a 2-pixel wide available space, for
    // example):

    cQuantum = (bQuantum) ? 1 : OH_QUANTUM;

    pohBeside = NULL;
    if (cxBeside >= cQuantum)
    {
        pohBeside = pohNewNode(ppdev);
        if (pohBeside == NULL)
            return(FALSE);
    }

    pohBelow = NULL;
    if (cyBelow >= cQuantum)
    {
        pohBelow = pohNewNode(ppdev);
        if (pohBelow == NULL)
        {
            vOhFreeNode(ppdev, pohBeside);
            return(FALSE);
        }

        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBelow, cyBelow);
        pohNext = ppdev->heap.ohFree.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext   = pohBelow;
        pohNext->pohPrev   = pohBelow;
        pohBelow->pohPrev  = pohPrev;
        pohBelow->pohNext  = pohNext;

        // Now update the adjacency information:

        pohBelow->pohLeft  = pohThis->pohLeft;
        pohBelow->pohUp    = pohThis;
        pohBelow->pohRight = pohThis->pohRight;
        pohBelow->pohDown  = pohThis->pohDown;

        // Update the rest of the new node information:

        pohBelow->cxReserved = 0;
        pohBelow->cyReserved = 0;
        pohBelow->cxcy       = cxcy;
        pohBelow->ohState    = OH_FREE;
        pohBelow->x          = pohThis->x;
        pohBelow->y          = pohThis->y + cyThis;
        pohBelow->xy         = ((ppdev->cBpp * pohBelow->x) +
                                (pohBelow->y * ppdev->lDelta));
        pohBelow->cx         = cxBelow;
        pohBelow->cy         = cyBelow;

        // Modify the current node to reflect the changes we've made:

        pohThis->cy = cyThis;
    }

    if (cxBeside >= cQuantum)
    {
        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBeside, cyBeside);
        pohNext = ppdev->heap.ohFree.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext    = pohBeside;
        pohNext->pohPrev    = pohBeside;
        pohBeside->pohPrev  = pohPrev;
        pohBeside->pohNext  = pohNext;

        // Now update the adjacency information:

        pohBeside->pohUp    = pohThis->pohUp;
        pohBeside->pohLeft  = pohThis;
        pohBeside->pohDown  = pohThis->pohDown;
        pohBeside->pohRight = pohThis->pohRight;

        // Update the rest of the new node information:

        pohBeside->cxReserved = 0;
        pohBeside->cyReserved = 0;
        pohBeside->cxcy       = cxcy;
        pohBeside->ohState    = OH_FREE;
        pohBeside->x          = pohThis->x + cxThis;
        pohBeside->y          = pohThis->y;
        pohBeside->xy         = ((ppdev->cBpp * pohBeside->x) +
                                 (pohBeside->y * ppdev->lDelta));
        pohBeside->cx         = cxBeside;
        pohBeside->cy         = cyBeside;

        // Modify the current node to reflect the changes we've made:

        pohThis->cx = cxThis;
    }

    if (pohBelow != NULL)
    {
        pohThis->pohDown = pohBelow;
        if ((pohBeside != NULL) && (cyBeside == pohThis->cy))
            pohBeside->pohDown = pohBelow;
    }
    if (pohBeside != NULL)
    {
        pohThis->pohRight = pohBeside;
        if ((pohBelow != NULL) && (cxBelow == pohThis->cx))
            pohBelow->pohRight  = pohBeside;
    }

    pohThis->cxcy = CXCY(pohThis->cx, pohThis->cy);

    return(TRUE);
}

/******************************Public*Routine******************************\
* OH* pohMakeRoomAtLocation
*
* Attempts to allocate a rectangle at a specific position.
*
\**************************************************************************/

OH* pohMakeRoomAtLocation(
PDEV*   ppdev,
POINTL* pptl,               // Requested position for the rectangle
LONG    cxThis,             // Width of rectangle to be allocated
LONG    cyThis,             // Height of rectangle to be allocated
FLONG   floh)               // Allocation flags
{
    OH*     poh;
    OH*     pohTop;
    OH*     pohLeft;
    LONG    cxLeft;
    LONG    cyTop;
    OH*     pohRight;

    if (!(floh & FLOH_ONLY_IF_ROOM))
    {
        // First off, discard any bitmaps that overlap the requested
        // rectangle, assuming we're allowed to:

        if (!bDiscardEverythingInRectangle(ppdev, pptl->x, pptl->y, cxThis, cyThis))
            return(NULL);
    }

    // Now see if there is a free rectangle that entirely contains the
    // requested rectangle.

    for (poh = ppdev->heap.ohFree.pohNext;
         poh != &ppdev->heap.ohFree;
         poh = poh->pohNext)
    {
        ASSERTDD(poh->ohState == OH_FREE, "Non-free node in free list");

        // See if the current free rectangle completely contains the
        // requested rectangle:

        if ((poh->x <= pptl->x) &&
            (poh->y <= pptl->y) &&
            (poh->x + poh->cx >= pptl->x + cxThis) &&
            (poh->y + poh->cy >= pptl->y + cyThis))
        {
            // We can't reserve this rectangle, or make it permanent, if it's
            // already been reserved:

            if ((!poh->cxReserved) ||
                ((floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT)) == 0))
            {
                // The 'poh' rectangle entirely contains the requested
                // rectangle.  We may have a situation like this, where
                // the smaller rectangle is the requested rectangle, and
                // the larger rectangle is the available rectangle:
                //
                //     +-------------------+
                //     |                   |
                //     |    +---------+    |
                //     |    |Requested|    |
                //     |    |         |    |
                //     |    +---------+    |
                //     |                   |
                //     +-------------------+
                //
                // We want to make the space to the left and to the top of
                // the requested rectangle available to the heap.  Our
                // free-space routine only knows how to free space to the
                // right and bottom of an allocation, though.  So we will
                // temporarily allocate temporary rectangles to subdivide
                // our rectangle like the following:
                //
                //     +-------------------+
                //     |Top                |
                //     +----+--------------+
                //     |Left|Free          |
                //     |    |              |
                //     |    |              |
                //     |    |              |
                //     +----+--------------+
                //
                // Then, in the resulting 'Free' space, we will allocate the
                // upper-left corner for our requested rectangle, after which
                // we will go back and free the 'Top' and 'Left' temporary
                // rectangles.

                pohTop  = NULL;
                pohLeft = NULL;
                cxLeft  = pptl->x - poh->x;
                cyTop   = pptl->y - poh->y;

                if (cyTop > 0)
                {
                    if (!bFreeRightAndBottomSpace(ppdev, poh, poh->cx, cyTop,
                                                  TRUE))
                    {
                        return(NULL);
                    }

                    pohTop = poh;
                    poh    = pohTop->pohDown;
                }

                if (cxLeft > 0)
                {
                    if (!bFreeRightAndBottomSpace(ppdev, poh, cxLeft, poh->cy,
                                                  TRUE))
                    {
                        pohFree(ppdev, pohTop);
                        return(NULL);
                    }

                    pohLeft = poh;
                    poh     = pohLeft->pohRight;
                }

                ASSERTDD((poh->x == pptl->x) &&
                         (poh->y == pptl->y) &&
                         (poh->x + poh->cx >= poh->x + cxThis) &&
                         (poh->y + poh->cy >= poh->y + cyThis),
                        "poh must properly fit requested rectangle");

                // Finally, we can subdivide to get our requested rectangle:

                if (!bFreeRightAndBottomSpace(ppdev, poh, cxThis, cyThis, FALSE))
                    poh = NULL;         // Fail this call

                // Free our temporary rectangles, if there are any:

                pohFree(ppdev, pohTop);
                pohFree(ppdev, pohLeft);

                return(poh);
            }
        }
    }

    // There was no free rectangle that completely contains the requested
    // rectangle:

    return(NULL);
}

/******************************Public*Routine******************************\
* OH* pohMakeRoomAnywhere
*
* Allocates space for an off-screen rectangle.  It will attempt to find
* the smallest available free rectangle, and will allocate the block out
* of its upper-left corner.  The remaining two rectangles will be placed
* on the available free space list.
*
* If the rectangle would have been large enough to fit into off-screen
* memory, but there is not enough available free space, we will boot
* bitmaps out of off-screen and into DIBs until there is enough room.
*
\**************************************************************************/

OH* pohMakeRoomAnywhere(
PDEV*   ppdev,
LONG    cxThis,             // Width of rectangle to be allocated
LONG    cyThis,             // Height of rectangle to be allocated
FLONG   floh)               // May have FLOH_ONLY_IF_ROOM set
{
    ULONG cxcyThis;         // Width and height search key
    OH*   pohThis;          // Points to found available rectangle we'll use

    ASSERTDD((cxThis > 0) && (cyThis > 0), "Illegal allocation size");

    // Increase the width to get the proper alignment (thus ensuring that all
    // allocations will be properly aligned):

    cxThis = (cxThis + (HEAP_X_ALIGNMENT - 1)) & ~(HEAP_X_ALIGNMENT - 1);

    // We can't succeed if the requested rectangle is larger than the
    // largest possible available rectangle:

    if ((cxThis > ppdev->heap.cxMax) || (cyThis > ppdev->heap.cyMax))
        return(NULL);

    // Find the first available rectangle the same size or larger than
    // the requested one:

    cxcyThis = CXCY(cxThis, cyThis);
    pohThis  = ppdev->heap.ohFree.pohNext;
    while (pohThis->cxcy < cxcyThis)
    {
        ASSERTDD(pohThis->ohState == OH_FREE, "Non-free node in free list");

        pohThis = pohThis->pohNext;
    }

    while (pohThis->cy < cyThis)
    {
        ASSERTDD(pohThis->ohState == OH_FREE, "Non-free node in free list");

        pohThis = pohThis->pohNext;
    }

    ASSERTDD(pohThis->ohState == OH_FREE, "Non-free node in free list");

    if (pohThis->cxcy == CXCY_SENTINEL)
    {
        // There was no space large enough...

        if (floh & FLOH_ONLY_IF_ROOM)
            return(NULL);

        DISPDBG((2, "> Making room for %li x %li allocation...", cxThis, cyThis));

        // We couldn't find an available rectangle that was big enough
        // to fit our request.  So throw things out of the heap until we
        // have room, oldest allocations first:

        do {
            pohThis = ppdev->heap.ohDiscardable.pohPrev;  // Least-recently created

            ASSERTDD(pohThis != &ppdev->heap.ohDiscardable,
                     "Ran out of discardable entries -- Max not set correctly");
            ASSERTDD(pohThis->ohState == OH_DISCARDABLE,
                     "Non-discardable node in discardable list");

            // We can safely exit here if we have to:

            pohThis = pohMoveOffscreenDfbToDib(ppdev, pohThis);
            if (pohThis == NULL)
                return(NULL);

        } while ((pohThis->cx < cxThis) || (pohThis->cy < cyThis));
    }

    if ((pohThis->cxReserved) && (floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT)))
    {
        // We can't reserve this rectangle, or make it permanent, if it's
        // already been reserved.  So throw absolutely everything out and
        // search the free list.
        //
        // NOTE: This is extremely painful!  A better approach would be to
        //       keep separate 'cxMax' and 'cyMax' variables kept for free
        //       rectangles that are not reserved (cxMax and cyMax
        //       currently include reserved free rectangles).

        if (!bDiscardEverythingInRectangle(ppdev, 0, 0,
                                           ppdev->cxMemory, ppdev->cyMemory))
        {
            return(NULL);
        }

        pohThis = &ppdev->heap.ohFree;
        do {
            pohThis = pohThis->pohNext;

            if (pohThis == &ppdev->heap.ohFree)
                return(NULL);

        } while ((pohThis->cxReserved)  ||
                 (pohThis->cx < cxThis) ||
                 (pohThis->cy < cyThis));
    }

    if (!bFreeRightAndBottomSpace(ppdev, pohThis, cxThis, cyThis, FALSE))
        return(NULL);

    return(pohThis);
}

/******************************Public*Routine******************************\
* OH* pohAllocate
*
* Allocates a rectangle in off-screen memory.
*
* Types:
*
*   FLOH_RESERVE
*
*     Reserves an off-screen rectangle.  The space may still be used by
*     discardable bitmaps until the rectangle is committed via 'bOhCommit'.
*
*   FLOH_MAKE_PERMANENT
*
*     Allocates an off-screen rectangle that can never be booted
*     of the heap.   It's the caller's responsibility to manage
*     the rectangle, which includes what to do with the memory in
*     DrvAssertMode when the display is changed to full-screen
*     mode.
*
*   Default
*
*     Allocates a 'discardable' off-screen rectangle for a DFB that may
*     be  kicked out of off-screen if the space is needed.
*
* Options:
*
*   FLOH_ONLY_IF_ROOM
*
*     Allocates an off-screen rectangle only if there is free space
*     available -- i.e., no discardable rectangles will be moved out of
*     off-screen to make room.
*
*   Default
*
*     May move discardable rectangles out of off-screen to make room.
*
* Arguments:
*
*   pptl
*
*     If NULL, the rectangle will be allocated anywhere in un-used offscreen
*     memory.
*
*     If non-NULL, is a requested position for the rectangle.
*
*     NOTE: The heap will quickly fragment if arbitrary positions are
*           requested.  This position option works best if there is only
*           one specific rectangle ever requested, or if the allocations
*           are always wider than they are high.
*
\**************************************************************************/

OH* pohAllocate(
PDEV*   ppdev,
POINTL* pptl,           // Optional requested position of rectangle
LONG    cxThis,         // Width of rectangle to be allocated
LONG    cyThis,         // Height of rectangle to be allocated
FLOH    floh)           // Allocation flags
{
    OH*     pohThis;    // Points to found available rectangle we'll use
    OH*     pohRoot;    // Point to root of list where we'll insert node
    ULONG   cxcy;
    OH*     pohNext;
    OH*     pohPrev;

    ASSERTDD((floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT))
             != (FLOH_RESERVE | FLOH_MAKE_PERMANENT),
             "Illegal flags -- can't set both FLOH_RESERVE and FLOH_MAKE_PERMANENT");

    if (pptl == NULL)
    {
        pohThis = pohMakeRoomAnywhere(ppdev, cxThis, cyThis, floh);
        if (pohThis == NULL)
            DISPDBG((2, "Can't allocate %li x %li with flags %li",
                        cxThis, cyThis, floh));
    }
    else
    {
        pohThis = pohMakeRoomAtLocation(ppdev, pptl, cxThis, cyThis, floh);
        if (pohThis == NULL)
            DISPDBG((2, "Can't allocate %li x %li at %li, %li with flags %li",
                        cxThis, cyThis, pptl->x, pptl->y, floh));
    }

    if (pohThis == NULL)
        return(NULL);

    // Calculate the effective start address for this bitmap in off-
    // screen memory:

    pohThis->pvScan0 = ppdev->pjScreen + (pohThis->y * ppdev->lDelta)
                                       + (pohThis->x * ppdev->cBpp);

    // The caller is responsible for setting this field:

    pohThis->pdsurf = NULL;

    // Our 'reserve' logic expects the node to have 'free' status:

    ASSERTDD(pohThis->ohState == OH_FREE, "Node not free after making room");
    ASSERTDD(((floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT)) == 0) ||
             (pohThis->cxReserved == 0),
             "Can't reserve a rectangle that's already reserved");

    if (floh & FLOH_RESERVE)
    {
        // A non-zero value for 'cxReserved' means it's reserved:

        pohThis->cxReserved = pohThis->cx;
        pohThis->cyReserved = pohThis->cy;

        // Remove this node from its place in the free list:

        pohThis->pohPrev->pohNext = pohThis->pohNext;
        pohThis->pohNext->pohPrev = pohThis->pohPrev;

        // Now insert the node, in order, back into the free list:

        cxcy = pohThis->cxcy;

        pohNext = ppdev->heap.ohFree.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext = pohThis;
        pohNext->pohPrev = pohThis;
        pohThis->pohPrev = pohPrev;
        pohThis->pohNext = pohNext;
    }
    else
    {
        // Remove this node from the free list:

        pohThis->pohPrev->pohNext = pohThis->pohNext;
        pohThis->pohNext->pohPrev = pohThis->pohPrev;

        if (floh & FLOH_MAKE_PERMANENT)
        {
            // Change status of node and insert into permanent list:

            pohThis->ohState = OH_PERMANENT;
            pohRoot = &ppdev->heap.ohPermanent;

            // Calculate the new maximum size rectangle available
            // for allocation:

            vCalculateMaximumNonPermanent(ppdev);
        }
        else
        {
            // Change status of node and insert into discardable list:

            pohThis->ohState = OH_DISCARDABLE;
            pohRoot = &ppdev->heap.ohDiscardable;
        }

        // Now insert the node at the head of the appropriate list:

        pohThis->pohNext = pohRoot->pohNext;
        pohThis->pohPrev = pohRoot;

        pohRoot->pohNext->pohPrev = pohThis;
        pohRoot->pohNext          = pohThis;
    }

    DISPDBG((2, "   Allocated (%li x %li) at (%li, %li) with flags %li",
                cxThis, cyThis, pohThis->x, pohThis->y, floh));

    return(pohThis);
}

/******************************Public*Routine******************************\
* BOOL bOhCommit
*
* If 'bCommit' is TRUE, converts a 'reserved' allocation to 'permanent,'
* moving from off-screen memory any discardable allocations that may have
* been using the space.
*
* If 'bCommit' is FALSE, converts a 'permanent' allocation to 'reserved,'
* allowing the space to be used by discardable allocations.
*
\**************************************************************************/

BOOL bOhCommit(
PDEV*   ppdev,
OH*     poh,
BOOL    bCommit)
{
    BOOL    bRet;
    LONG    cx;
    LONG    cy;
    ULONG   cxcy;
    OH*     pohRoot;
    OH*     pohNext;
    OH*     pohPrev;

    bRet = FALSE;       // Assume failure

    if (poh == NULL)
        return(bRet);

    if ((bCommit) && (poh->cxReserved))
    {
        if (bDiscardEverythingInRectangle(ppdev, poh->x, poh->y,
                                          poh->cxReserved, poh->cyReserved))
        {
            DISPDBG((2, "Commited %li x %li at (%li, %li)",
                        poh->cx, poh->cy, poh->x, poh->y));

            poh->ohState = OH_PERMANENT;

            // Remove this node from the free list:

            poh->pohPrev->pohNext = poh->pohNext;
            poh->pohNext->pohPrev = poh->pohPrev;

            // Now insert the node at the head of the permanent list:

            pohRoot = &ppdev->heap.ohPermanent;

            poh->pohNext = pohRoot->pohNext;
            poh->pohPrev = pohRoot;

            pohRoot->pohNext->pohPrev = poh;
            pohRoot->pohNext          = poh;

            bRet = TRUE;
        }
    }
    else if ((!bCommit) && (poh->ohState == OH_PERMANENT))
    {
        DISPDBG((2, "Decommited %li x %li at (%li, %li)",
                    poh->cx, poh->cy, poh->x, poh->y));

        poh->ohState    = OH_FREE;
        poh->cxReserved = poh->cx;
        poh->cyReserved = poh->cy;

        // Remove this node from the permanent list:

        poh->pohPrev->pohNext = poh->pohNext;
        poh->pohNext->pohPrev = poh->pohPrev;

        // Now insert the node, in order, into the free list:

        cxcy = poh->cxcy;

        pohNext = ppdev->heap.ohFree.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext    = poh;
        pohNext->pohPrev    = poh;
        poh->pohPrev        = pohPrev;
        poh->pohNext        = pohNext;

        bRet = TRUE;
    }

    // Recalculate the biggest rectangle available for allocation:

    vCalculateMaximumNonPermanent(ppdev);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bMoveDibToOffscreenDfbIfRoom
*
* Converts the DIB DFB to an off-screen DFB, if there's room for it in
* off-screen memory.
*
* Returns: FALSE if there wasn't room, TRUE if successfully moved.
*
\**************************************************************************/

BOOL bMoveDibToOffscreenDfbIfRoom(
PDEV*   ppdev,
DSURF*  pdsurf)
{
    OH*         poh;
    SURFOBJ*    pso;
    RECTL       rclDst;
    POINTL      ptlSrc;
    HSURF       hsurf;

    ASSERTDD(pdsurf->dt == DT_DIB,
             "Can't move a bitmap off-screen when it's already off-screen");

    // If we're in full-screen mode, we can't move anything to off-screen
    // memory:

    if (!ppdev->bEnabled)
        return(FALSE);

    poh = pohAllocate(ppdev, NULL, pdsurf->sizl.cx, pdsurf->sizl.cy,
                      FLOH_ONLY_IF_ROOM);
    if (poh == NULL)
    {
        // There wasn't any free room.

        return(FALSE);
    }

    // 'pdsurf->sizl' is the actual bitmap dimension, not 'poh->cx' or
    // 'poh->cy'.

    rclDst.left   = poh->x;
    rclDst.top    = poh->y;
    rclDst.right  = rclDst.left + pdsurf->sizl.cx;
    rclDst.bottom = rclDst.top  + pdsurf->sizl.cy;

    ptlSrc.x      = 0;
    ptlSrc.y      = 0;

    ppdev->pfnPutBits(ppdev, pdsurf->pso, &rclDst, &ptlSrc);

    // Update the data structures to reflect the new off-screen node:

    pso           = pdsurf->pso;
    pdsurf->dt    = DT_SCREEN;
    pdsurf->poh   = poh;
    poh->pdsurf   = pdsurf;

    // Now free the DIB.  Get the hsurf from the SURFOBJ before we unlock
    // it (it's not legal to dereference psoDib when it's unlocked):

    hsurf = pso->hsurf;
    EngUnlockSurface(pso);
    EngDeleteSurface(hsurf);

    return(TRUE);
}

/******************************Public*Routine******************************\
* OH* pohMoveOffscreenDfbToDib
*
* Converts the DFB from being off-screen to being a DIB.
*
* Note: The caller does NOT have to call 'pohFree' on 'poh' after making
*       this call.
*
* Returns: NULL if the function failed (due to a memory allocation).
*          Otherwise, it returns a pointer to the coalesced off-screen heap
*          node that has been made available for subsequent allocations
*          (useful when trying to free enough memory to make a new
*          allocation).
\**************************************************************************/

OH* pohMoveOffscreenDfbToDib(
PDEV*   ppdev,
OH*     poh)
{
    DSURF*   pdsurf;
    HBITMAP  hbmDib;
    SURFOBJ* pso;
    RECTL    rclDst;
    POINTL   ptlSrc;

    DISPDBG((2, "Throwing out %li x %li at (%li, %li)!",
                 poh->cx, poh->cy, poh->x, poh->y));

    pdsurf = poh->pdsurf;

    ASSERTDD((poh->x != 0) || (poh->y != 0),
            "Can't make the visible screen into a DIB");
    ASSERTDD(pdsurf->dt != DT_DIB,
            "Can't make a DIB into even more of a DIB");

    hbmDib = EngCreateBitmap(pdsurf->sizl, 0, ppdev->iBitmapFormat,
                             BMF_TOPDOWN, NULL);
    if (hbmDib)
    {
        if (EngAssociateSurface((HSURF) hbmDib, ppdev->hdevEng, 0))
        {
            pso = EngLockSurface((HSURF) hbmDib);
            if (pso != NULL)
            {
                rclDst.left   = 0;
                rclDst.top    = 0;
                rclDst.right  = pdsurf->sizl.cx;
                rclDst.bottom = pdsurf->sizl.cy;

                ptlSrc.x      = poh->x;
                ptlSrc.y      = poh->y;

                ppdev->pfnGetBits(ppdev, pso, &rclDst, &ptlSrc);

                pdsurf->dt    = DT_DIB;
                pdsurf->pso   = pso;

                // Don't even bother checking to see if this DIB should
                // be put back into off-screen memory until the next
                // heap 'free' occurs:

                pdsurf->iUniq = ppdev->iHeapUniq;
                pdsurf->cBlt  = 0;

                // Remove this node from the off-screen DFB list, and free
                // it.  'pohFree' will never return NULL:

                return(pohFree(ppdev, poh));
            }
        }

        // Fail case:

        EngDeleteSurface((HSURF) hbmDib);
    }

    return(NULL);
}

/******************************Public*Routine******************************\
* BOOL bMoveEverythingFromOffscreenToDibs
*
* This function is used when we're about to enter full-screen mode, which
* would wipe all our off-screen bitmaps.  GDI can ask us to draw on
* device bitmaps even when we're in full-screen mode, and we do NOT have
* the option of stalling the call until we switch out of full-screen.
* We have no choice but to move all the off-screen DFBs to DIBs.
*
* Returns TRUE if all DSURFs have been successfully moved.
*
\**************************************************************************/

BOOL bMoveAllDfbsFromOffscreenToDibs(
PDEV*   ppdev)
{
    // Throw out any discardable bitmaps over the entire surface:

    return(bDiscardEverythingInRectangle(ppdev, 0, 0,
                                         ppdev->cxMemory, ppdev->cyMemory));
}

/******************************Public*Routine******************************\
* HBITMAP DrvCreateDeviceBitmap
*
* Function called by GDI to create a device-format-bitmap (DFB).  We will
* always try to allocate the bitmap in off-screen; if we can't, we simply
* fail the call and GDI will create and manage the bitmap itself.
*
* Note: We do not have to zero the bitmap bits.  GDI will automatically
*       call us via DrvBitBlt to zero the bits (which is a security
*       consideration).
*
\**************************************************************************/

HBITMAP DrvCreateDeviceBitmap(
DHPDEV  dhpdev,
SIZEL   sizl,
ULONG   iFormat)
{
    PDEV*   ppdev;
    OH*     poh;
    DSURF*  pdsurf;
    HBITMAP hbmDevice;
    FLONG   flHooks;

    ppdev = (PDEV*) dhpdev;

    // If we're in full-screen mode, we hardly have any off-screen memory
    // in which to allocate a DFB.  LATER: We could still allocate an
    // OH node and put the bitmap on the DIB DFB list for later promotion.

    if (!ppdev->bEnabled)
        return(0);

    // We only support device bitmaps that are the same colour depth
    // as our display.
    //
    // Actually, those are the only kind GDI will ever call us with,
    // but we may as well check.  Note that this implies you'll never
    // get a crack at 1bpp bitmaps.

    if (iFormat != ppdev->iBitmapFormat)
        return(0);

    // We don't want anything 8x8 or smaller -- they're typically brush
    // patterns which we don't particularly want to stash in off-screen
    // memory:

    if ((sizl.cx <= 8) && (sizl.cy <= 8))
        return(0);

    poh = pohAllocate(ppdev, NULL, sizl.cx, sizl.cy, 0);
    if (poh != NULL)
    {
        pdsurf = EngAllocMem(0, sizeof(DSURF), ALLOC_TAG);
        if (pdsurf != NULL)
        {
            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, sizl, iFormat);
            if (hbmDevice != NULL)
            {
                flHooks = ppdev->flHooks;

                // Setting the SYNCHRONIZEACCESS flag tells GDI that we
                // want all drawing to the bitmaps to be synchronized (GDI
                // is multi-threaded and by default does not synchronize
                // device bitmap drawing -- it would be a Bad Thing for us
                // to have multiple threads using the accelerator at the
                // same time):

                flHooks |= HOOK_SYNCHRONIZEACCESS;

                // It's a device-managed surface; make sure we don't set
                // HOOK_SYNCHRONIZE, otherwise we may confuse GDI:

                flHooks &= ~HOOK_SYNCHRONIZE;

                if (EngAssociateSurface((HSURF) hbmDevice, ppdev->hdevEng,
                                        flHooks))
                {
                    pdsurf->dt    = DT_SCREEN;
                    pdsurf->poh   = poh;
                    pdsurf->sizl  = sizl;
                    pdsurf->ppdev = ppdev;
                    poh->pdsurf   = pdsurf;

                    return(hbmDevice);
                }

                EngDeleteSurface((HSURF) hbmDevice);
            }
            EngFreeMem(pdsurf);
        }
        pohFree(ppdev, poh);
    }

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDeleteDeviceBitmap
*
* Deletes a DFB.
*
\**************************************************************************/

VOID DrvDeleteDeviceBitmap(
DHSURF  dhsurf)
{
    DSURF*   pdsurf;
    PDEV*    ppdev;
    SURFOBJ* psoDib;
    HSURF    hsurfDib;

    pdsurf = (DSURF*) dhsurf;
    ppdev  = pdsurf->ppdev;

    if (pdsurf->dt == DT_SCREEN)
    {
        pohFree(ppdev, pdsurf->poh);
    }
    else
    {
        ASSERTDD(pdsurf->dt == DT_DIB, "Expected DIB type");

        psoDib = pdsurf->pso;

        // Get the hsurf from the SURFOBJ before we unlock it (it's not
        // legal to dereference psoDib when it's unlocked):

        hsurfDib = psoDib->hsurf;
        EngUnlockSurface(psoDib);
        EngDeleteSurface(hsurfDib);
    }

    EngFreeMem(pdsurf);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeOffscreenHeap
*
* This function is called whenever we switch in or out of full-screen
* mode.  We have to convert all the off-screen bitmaps to DIBs when
* we switch to full-screen (because we may be asked to draw on them even
* when in full-screen, and the mode switch would probably nuke the video
* memory contents anyway).
*
\**************************************************************************/

BOOL bAssertModeOffscreenHeap(
PDEV*   ppdev,
BOOL    bEnable)
{
    BOOL b = TRUE;

    if (!bEnable)
    {
        b = bMoveAllDfbsFromOffscreenToDibs(ppdev);
    }

    return(b);
}

/******************************Public*Routine******************************\
* VOID vDisableOffscreenHeap
*
* Frees any resources allocated by the off-screen heap.
*
\**************************************************************************/

VOID vDisableOffscreenHeap(
PDEV*   ppdev)
{
    OHALLOC* poha;
    OHALLOC* pohaNext;
    SURFOBJ* psoPunt;
    HSURF    hsurf;

    psoPunt = ppdev->psoPunt;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }

    psoPunt = ppdev->psoPunt2;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }

    poha = ppdev->heap.pohaChain;
    while (poha != NULL)
    {
        pohaNext = poha->pohaNext;  // Grab the next pointer before it's freed
        EngFreeMem(poha);
        poha = pohaNext;
    }
}

/******************************Public*Routine******************************\
* BOOL bEnableOffscreenHeap
*
* Initializes the off-screen heap using all available video memory,
* accounting for the portion taken by the visible screen.
*
* Input: ppdev->cxScreen
*        ppdev->cyScreen
*        ppdev->cxMemory
*        ppdev->cyMemory
*
\**************************************************************************/

BOOL bEnableOffscreenHeap(
PDEV*   ppdev)
{
    OH*         poh;
    SIZEL       sizl;
    HSURF       hsurf;
    POINTL      ptlScreen;

    DISPDBG((1, "Screen: %li x %li  Memory: %li x %li",
        ppdev->cxScreen, ppdev->cyScreen, ppdev->cxMemory, ppdev->cyMemory));

    ASSERTDD((ppdev->cxScreen <= ppdev->cxMemory) &&
             (ppdev->cyScreen <= ppdev->cyMemory),
             "Memory must not have smaller dimensions than visible screen!");

    ppdev->heap.pohaChain   = NULL;
    ppdev->heap.pohFreeList = NULL;

    // Initialize the available list, which will be a circular
    // doubly-linked list kept in ascending 'cxcy' order, with a
    // 'sentinel' at the end of the list:

    poh = pohNewNode(ppdev);
    if (poh == NULL)
        goto ReturnFalse;

    // The first node describes the entire video memory size:

    poh->pohNext      = &ppdev->heap.ohFree;
    poh->pohPrev      = &ppdev->heap.ohFree;
    poh->ohState      = OH_FREE;
    poh->x            = 0;
    poh->y            = 0;
    poh->xy           = 0;
    poh->cx           = ppdev->cxMemory;
    poh->cy           = ppdev->cyMemory;
    poh->cxcy         = CXCY(ppdev->cxMemory, ppdev->cyMemory);
    poh->pohLeft      = &ppdev->heap.ohFree;
    poh->pohUp        = &ppdev->heap.ohFree;
    poh->pohRight     = &ppdev->heap.ohFree;
    poh->pohDown      = &ppdev->heap.ohFree;
    poh->pvScan0      = ppdev->pjScreen;

    // The second node is our free list sentinel:

    ppdev->heap.ohFree.pohNext         = poh;
    ppdev->heap.ohFree.pohPrev         = poh;
    ppdev->heap.ohFree.cxcy            = CXCY_SENTINEL;
    ppdev->heap.ohFree.cx              = 0x7fffffff;
    ppdev->heap.ohFree.cy              = 0x7fffffff;
    ppdev->heap.ohFree.ohState         = OH_FREE;

    // Initialize the discardable list, which will be a circular
    // doubly-linked list kept in order, with a sentinel at the end.
    // This node is also used for the screen-surface, for its offset:

    ppdev->heap.ohDiscardable.pohNext = &ppdev->heap.ohDiscardable;
    ppdev->heap.ohDiscardable.pohPrev = &ppdev->heap.ohDiscardable;
    ppdev->heap.ohDiscardable.ohState = OH_DISCARDABLE;

    // Initialize the permanent list, which will be a circular
    // doubly-linked list kept in order, with a sentinel at the end.

    ppdev->heap.ohPermanent.pohNext = &ppdev->heap.ohPermanent;
    ppdev->heap.ohPermanent.pohPrev = &ppdev->heap.ohPermanent;
    ppdev->heap.ohPermanent.ohState = OH_PERMANENT;

    // For the moment, make the max really big so that the first
    // allocation we're about to do will succeed:

    ppdev->heap.cxMax = 0x7fffffff;
    ppdev->heap.cyMax = 0x7fffffff;

    ptlScreen.x = 0;
    ptlScreen.y = 0;

    // Finally, reserve the upper-left corner for the screen.  We can
    // actually throw away 'poh' because we'll never need it again
    // (not even for disabling the off-screen heap since everything is
    // freed using OHALLOCs):

    poh = pohAllocate(ppdev, &ptlScreen, ppdev->cxScreen, ppdev->cyScreen,
                      FLOH_MAKE_PERMANENT);

    ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y == 0) &&
             (poh->cx >= ppdev->cxScreen) && (poh->cy >= ppdev->cyScreen),
             "Screen allocation messed up");

    // Remember it so that we can associate the screen SURFOBJ with this
    // poh:

    ppdev->pohScreen = poh;

    //  Here we allocate space for the ET6000 to use as a blt buffer.  This
    //  lets us perform rops on host bitmaps by transferring them a line at
    //  a time into offscreen memory.  We allocate screen_width * 2 lines
    //  so we can double buffer the transfers.
    //

    if (ppdev->ulChipID == ET6000)
    {
        OH* pohTemp;

        ppdev->lBltBufferPitch = ppdev->lDelta;

        // We need to fudge the ppdev->heap.cxMax value so that it doesn't
        // forbid the next allocation.

        ppdev->heap.cxMax = 0x7fffffff;
        ppdev->heap.cyMax = 0x7fffffff;

        pohTemp = pohAllocate(ppdev, NULL, ppdev->cxScreen, 2, FLOH_MAKE_PERMANENT);
        if (pohTemp == NULL)
        {
            DISPDBG((0, "Could not allocate space for ET6000 blt buffer"));
            goto ReturnFalse;
        }

        DISPDBG((1, "ET6000 blt buffer allocated successfully (%p)", pohTemp));
        DISPDBG((1, "    poh->x = %ld", pohTemp->x));
        DISPDBG((1, "    poh->y = %ld", pohTemp->y));
        DISPDBG((1, "    poh->cx = %ld", pohTemp->cx));
        DISPDBG((1, "    poh->cy = %ld", pohTemp->cy));
        ppdev->pohBltBuffer = pohTemp;
    }

    // Allocate a 'punt' SURFOBJ we'll use when the device-bitmap is in
    // off-screen memory, but we want GDI to draw to it directly as an
    // engine-managed surface:

    sizl.cx = ppdev->cxMemory;
    sizl.cy = ppdev->cyMemory;

    // We want to create it with exactly the same hooks and capabilities
    // as our primary surface.  We will override the 'lDelta' and 'pvScan0'
    // fields later:

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    0xbadf00d,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    (VOID*) 0xbadf00d);

    if ((hsurf == 0)                                                  ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks)) ||
        (!(ppdev->psoPunt = EngLockSurface(hsurf))))
    {
        DISPDBG((0, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    // We need another for doing DrvBitBlt and DrvCopyBits when both
    // surfaces are off-screen bitmaps:

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    0xbadf00d,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    (VOID*) 0xbadf00d);

    if ((hsurf == 0)                                                  ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks)) ||
        (!(ppdev->psoPunt2 = EngLockSurface(hsurf))))
    {
        DISPDBG((0, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    DISPDBG((5, "Passed bEnableOffscreenHeap"));

    if (poh != NULL)
        return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableOffscreenHeap"));

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\precomp.h ===
/******************************Module*Header*******************************\
* Module Name: precomp.h
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <winerror.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>

#include "lines.h"
#include "hw.h"
#include "driver.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\pointer.c ===
/******************************Module*Header*******************************\
* Module Name: pointer.c
*
* Contains the pointer management functions.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"


ULONG SetMonoHwPointerShape(
    SURFOBJ    *pso,
    SURFOBJ    *psoMask,
    SURFOBJ    *psoColor,
    XLATEOBJ   *pxlo,
    LONG        xHot,
    LONG        yHot,
    LONG        x,
    LONG        y,
    RECTL      *prcl,
    FLONG       fl);

BYTE jRepMask2[] =
{
    0x00, 0x05, 0x0a, 0x0f, 0x50, 0x55, 0x5a, 0x5f,
    0xa0, 0xa5, 0xaa, 0xaf, 0xf0, 0xf5, 0xfa, 0xff,
};

/*****************************************************************************
 * DrvMovePointer -
 ****************************************************************************/
VOID DrvMovePointer(
    SURFOBJ*    pso,
    LONG        x,
    LONG        y,
    RECTL*      prcl)
{
    PPDEV   ppdev;
    INT xx, yy;

    ppdev = (PPDEV) pso->dhpdev;

    // If x is -1 then take down the cursor.

    if (x == -1)
    {
        DISABLE_SPRITE(ppdev);
        return;
    }

    // Adjust the actual pointer position depending upon
    // the hot spot.

    x -= ppdev->W32SpriteData.ptlHot.x;
    y -= ppdev->W32SpriteData.ptlHot.y;

    if (ppdev->ulChipID == ET6000)
    {
        char    xPreset = 0;
        char    yPreset = 0;

        // We may have disabled the sprite if it went off the screen.
        // So, now have to detect if we did and re-enable it if necessary.

        if (ppdev->W32SpriteData.fl & POINTER_DISABLED)
        {
            ENABLE_SPRITE(ppdev);
        }

        if (x < 0)
        {
            xPreset = (CHAR)~x;
            x = 0;
        }
        if (y < 0)
        {
            yPreset = (CHAR)~y;
            y = 0;
        }

        ET6K_HORZ_PRESET(ppdev, xPreset);
        ET6K_VERT_PRESET(ppdev, yPreset);
        ET6K_SPRITE_HORZ_POSITION(ppdev, x);
        ET6K_SPRITE_VERT_POSITION(ppdev, y);
        return;
    }
    else
    {
        //
        // Adjust pointer x position for color depth
        //

        x *= ppdev->cBpp;

        // Yet another bug.
        // If the cursor is moved entirely off the screen, it could cause
        // the screen to shake.  So, we have to disable the cursor if it
        // is moved entirely off the screen.

        if ((x < - ((LONG) (ppdev->W32SpriteData.szlPointer.cx))) ||
            (x > ((LONG) (ppdev->cxScreen * ppdev->cBpp))) ||
            (y < - ((LONG) (ppdev->W32SpriteData.szlPointer.cy))) ||
            (y > ((LONG) (ppdev->cyScreen))))
        {
            DISABLE_SPRITE(ppdev);
            return;
        }

        // We may have disabled the sprite if it went off the screen.
        // So, now have to detect if we did and re-enable it if necessary.
        // (remembering to keep track of the state).

        if (ppdev->W32SpriteData.fl & POINTER_DISABLED)
        {
            ENABLE_SPRITE(ppdev);
        }

        // The W32 non-rev-B has a problem with a vertical offset of 0x3f.
        // All the other W32's have a problem with the last nibble being
        // 0x0F for both the horizontal and the verical.
        // Never set the bad presets on the chips in question.

        if (x <= 0)
        {
            if ((ppdev->ulChipID == W32) &&
                (ppdev->ulRevLevel != REV_B))
            {
                xx = -x;
                if ((xx & 0x0F) == 0x0F)
                    xx &= ~0x01;

                SET_HORZ_PRESET(xx);
            }
            else
            {
                SET_HORZ_PRESET(-x);
            }
            x = 0;
        }
        else
        {
            SET_HORZ_PRESET(0);
        }

        if (y <= 0)
        {
            if (ppdev->ulChipID == W32)
            {
                yy = -y;

                if (ppdev->ulRevLevel != REV_B)
                {
                    if (yy == 0x3F)
                        yy = 0x3E;
                }
                else
                {
                    if ((yy & 0x0F) == 0x0F)
                        yy &= ~0x01;
                }
                SET_VERT_PRESET(yy);
            }
            else
            {
                SET_VERT_PRESET(-y);
            }

            y = 0;
        }
        else
        {
            SET_VERT_PRESET(0);
        }

        // You guessed it.  Another bug.
        // On the W32 Rev B you can not put the cursor on the bottom line
        // of the display.  And if were in interlaced mode you can't put it
        // on the bottom two lines.

        if ((ppdev->ulChipID == W32) &&
            (ppdev->ulRevLevel == REV_B))
        {
            INT i;

            if (y > (i = ppdev->cyScreen - 2))
            {
                OUTP(0x3D4, 0x35);
                if (INP(0x3D5) & 0x80)
                    y = i;
            }
            else if (y > (i+1))
            {
                y = i+1;
            }
        }

        //////////////////////////////////////////////////////
        // Set the position of the sprite.

        if ((ppdev->ulChipID == W32I) ||
            (ppdev->ulChipID == W32P))
        {
            // You bet, one more bug, and this one is a lulu.
            // First we have to set the vertical position before the horz
            // position.  Why you ask, because, if this is a W32 Rev B or later
            // we may have to toggle a bit in a test register to really set the
            // vertical position, but of course we don't want to set anything
            // else at this point.

            BYTE    status, byte;

            // Wait for horz display interval.

            while ( (INP(0x3DA) & 0x02));
            while (!((status = INP(0x3DA)) & 0x02));

            SET_VERT_POSITION(y);

            // Check if the sprite is being displayed at this very moment.
            // And if it is then skip the test bit stuff.

            if (!(status & 0x04))
            {
                // Looks like we will have to toggle the test bit to
                // really set the vertical position.

                ENABLE_KEY(ppdev);

                OUTP(0x3D4, 0x37);
                byte = INP(0x3D5);
                byte |= 0x40;
                OUTP(0x3D5, byte);
                byte &= ~0x40;
                OUTP(0x3D5, byte);

                DISABLE_KEY(ppdev);
            }

            SET_HORZ_POSITION(x);
        }
        else
        {
            // For consistency sake, we're going to set the vertical first
            // even for non-W32 Rev B chips.

            SET_VERT_POSITION(y);
            SET_HORZ_POSITION(x);
        }

        return;
    }
}


/******************************Public*Routine******************************\
* DrvSetPointerShape
*
* Sets the new pointer shape.
\**************************************************************************/

ULONG DrvSetPointerShape(
    SURFOBJ    *pso,
    SURFOBJ    *psoMask,
    SURFOBJ    *psoColor,
    XLATEOBJ   *pxlo,
    LONG        xHot,
    LONG        yHot,
    LONG        x,
    LONG        y,
    RECTL      *prcl,
    FLONG       fl)
{
    PPDEV   ppdev;
    ULONG   ulRet;

    ppdev = (PPDEV) pso->dhpdev;

    if (ppdev->flCaps & CAPS_SW_POINTER)
    {
        return(SPS_DECLINE);
    }

    // Save the hot spot and dimensions of the cursor in globals.

    ppdev->W32SpriteData.ptlHot.x = xHot;
    ppdev->W32SpriteData.ptlHot.y = yHot;

    ppdev->W32SpriteData.szlPointer.cx = psoMask->sizlBitmap.cx * ppdev->cBpp;
    ppdev->W32SpriteData.szlPointer.cy = psoMask->sizlBitmap.cy / 2;

    if (psoColor != NULL)
    {
        // Disable the mono hardware pointer, and decline the pointer
        // shape

        DISABLE_SPRITE(ppdev);

        ulRet = SPS_DECLINE;

    }
    else
    {
        // Take care of the monochrome pointer.

        ulRet = SetMonoHwPointerShape(pso, psoMask, psoColor, pxlo,
                                      xHot, yHot, x, y, prcl, fl);
        if (ulRet == SPS_DECLINE)
        {
            DISABLE_SPRITE(ppdev);
        }
    }

    return (ulRet);
}

/*****************************************************************************
 * DrvSetMonoHwPointerShape -
 ****************************************************************************/
ULONG SetMonoHwPointerShape(
    SURFOBJ    *pso,
    SURFOBJ    *psoMask,
    SURFOBJ    *psoColor,
    XLATEOBJ   *pxlo,
    LONG        xHot,
    LONG        yHot,
    LONG        x,
    LONG        y,
    RECTL      *prcl,
    FLONG       fl)
{

    INT     i,
            j,
            cxMask,
            cyMask,
            cyAND,
            cxAND,
            cyXOR,
            cxXOR;

    PBYTE   pjAND,
            pjXOR;

    INT     lDelta;

    PPDEV   ppdev;

    INT     ix,
            iy,
            is,
            ip,
            iBit,
            jAndByte,
            jXorByte,
            jSpriteBits,
            jSpriteByte;

    INT     njSpriteBuffer;
    BOOL    bDetectXOR;

    BYTE*   pjBase;

    BYTE    ajAndMask[64][8],
            ajXorMask[64][8];

    BYTE    ajW32Sprite[1024];
    LONG    cBpp;
    INT     ndx = 0;

        ppdev    = (PPDEV) pso->dhpdev;
        pjBase   = ppdev->pjBase;
        cBpp     = ppdev->cBpp;

        // The W32 does not handle an XOR and an AND.
        // So, set a bool if we need to detect this condition.

        bDetectXOR = FALSE;
        if (ppdev->ulChipID == W32)
            bDetectXOR = TRUE;

        // If the mask is NULL this implies the pointer is not
        // visible.

        if (psoMask == NULL)
        {
            DISABLE_SPRITE(ppdev);
            return (SPS_ACCEPT_NOEXCLUDE);
        }

        // Init the AND and XOR masks.

        memset (ajAndMask, 0xFFFFFFFF, 512);
        memset (ajXorMask, 0, 512);

        // Get the bitmap dimensions.

        cxMask = psoMask->sizlBitmap.cx;
        cyMask = psoMask->sizlBitmap.cy;

        cyAND = cyXOR = cyMask / 2;
        cxAND = cxXOR = cxMask / 8;

        // Set up pointers to the AND and XOR masks.

        pjAND  =  psoMask->pvScan0;
        lDelta = psoMask->lDelta;
        pjXOR  = pjAND + (cyAND * lDelta);

        // Copy the AND mask.

        for (i = 0; i < cyAND; i++)
        {
            // Copy over a line of the AND mask.

            for (j = 0; j < cxAND; j++)
            {
                ajAndMask[i][j] = pjAND[j];
            }

            // point to the next line of the AND mask.

            pjAND += lDelta;
        }

        // Copy the XOR mask.

        for (i = 0; i < cyXOR; i++)
        {
            // Copy over a line of the XOR mask.

            for (j = 0; j < cxXOR; j++)
            {
                ajXorMask[i][j] = pjXOR[j];
            }

            // point to the next line of the XOR mask.

            pjXOR += lDelta;
        }

        // Build up the sprite from NT's And and Xor masks.

        // Init the indexes into the sprite buffer (is) and the
        // index for the bit pairs (ip).

        is = 0;
        ip = 0;

        // Outer most loop goes over NT's And and Xor rows.

        for (iy = 0; iy < 64; iy++)
        {
            // loop over the columns.
            for (ix = 0; ix < 8; ix++)
            {
                // pickup a source byte for each mask.
                jAndByte = ajAndMask[iy][ix];
                jXorByte = ajXorMask[iy][ix];

                // loop over the bits in the byte.
                for (iBit = 0x80; iBit != 0; iBit >>= 1)
                {
                    // init the sprite  bitpair.
                    jSpriteBits = 0x0;

                    // Set the sprite bit pairs.
                    if (jAndByte & iBit)
                        jSpriteBits |= 0x02;

                    if (jXorByte & iBit)
                        jSpriteBits |= 0x01;

                    if (bDetectXOR == TRUE)
                    {
                        if ((jAndByte & iBit) && (jXorByte & iBit))
                        {
                            return (SPS_DECLINE);
                        }
                    }

                    if ((ip % 4) == 0)
                    {
                        // If all 4 bit pairs in this byte are filled in
                        // flush the sprite byte to the sprite byte array.
                        // and set the first bit pair.
                        if (ip != 0)
                        {
                            ajW32Sprite[is++] = (BYTE)jSpriteByte;
                        }
                        jSpriteByte = jSpriteBits;
                    }
                    else
                    {
                        // If the sprite byte is not full, shift the bit pair
                        // into position, and or it into the sprite byte.
                        jSpriteBits <<= (ip % 4) * 2;
                        jSpriteByte  |= jSpriteBits;
                    }

                    // bump the bit pair counter.
                    ip++;
                }
            }
        }

        // Flush the last byte.
        ajW32Sprite[is++] = (BYTE)jSpriteByte;

        // Disable the pointer.
        DISABLE_SPRITE(ppdev);

        DISPDBG((1,"setting sprite shape at offset (%xh)", ppdev->cjPointerOffset));

        if (ppdev->ulChipID == ET6000)
        {
            BYTE * pjDst = ppdev->pjScreen + ppdev->cjPointerOffset;
            BYTE * pjSrc = ajW32Sprite;

            for (i = 0; i < 1024; i++)
            {
                *pjDst++ = *pjSrc++;
            }
        }
        else
        {
            ndx = 0;
            CP_MMU_BP0(ppdev, pjBase, ppdev->cjPointerOffset);
            if (cBpp == 1)
            {
                for (i = 0; i < 1024; i++)
                {
                    //*pjSpriteBuffer++ = ajW32Sprite[i];
                    CP_WRITE_MMU_BYTE(ppdev, 0, ndx, ajW32Sprite[i]);
                    ndx++;
                }
            }
            else if (cBpp == 2)
            {
                for (i = 0; i < 64; i++)
                {
                    for (j = 0; j < 8; j++)
                    {
                        //*pjSpriteBuffer++ = jRepMask2[ajW32Sprite[(16*i)+j] & 0xf];
                        //*pjSpriteBuffer++ = jRepMask2[ajW32Sprite[(16*i)+j] >> 4];
                        CP_WRITE_MMU_BYTE(ppdev, 0, ndx, jRepMask2[ajW32Sprite[(16*i)+j] & 0xf]);
                        ndx++;
                        CP_WRITE_MMU_BYTE(ppdev, 0, ndx, jRepMask2[ajW32Sprite[(16*i)+j] >> 4]);
                        ndx++;
                    }
                }
            }
        }

        // Set the position of the cursor.
        DrvMovePointer(pso, x, y, NULL);

        return (SPS_ACCEPT_NOEXCLUDE);
}



/******************************Public*Routine******************************\
* VOID vDisablePointer
*
\**************************************************************************/

VOID vDisablePointer(
    PDEV*   ppdev)
{
    // Nothing to do, really
}

/******************************Public*Routine******************************\
* VOID vAssertModePointer
*
\**************************************************************************/

VOID vAssertModePointer(
PDEV*   ppdev,
BOOL    bEnable)
{
    BYTE*       pjBase;
    ULONG       ulPhysicalAddr;
    INT         i, j,
                nBytesPerBank,
                njSpriteBuffer,
                n8kBanks,
                nRemainingBytes;

    if (ppdev->flCaps & CAPS_SW_POINTER)
    {
        // With a software pointer, we don't have to do anything.
    }
    else
    {
        DISPDBG((1,"vAssertModePointer: cxMemory = %d", ppdev->cxMemory));
        DISPDBG((1,"vAssertModePointer: cyMemory = %d", ppdev->cyMemory));
        DISPDBG((1,"vAssertModePointer: cxScreen = %d", ppdev->cxScreen));
        DISPDBG((1,"vAssertModePointer: cyScreen = %d", ppdev->cyScreen));

        pjBase = ppdev->pjBase;

        // Take care of the init for the Sprite.

        if (ppdev->ulChipID == ET6000)
        {
            BYTE * pjDst = ppdev->pjScreen + ppdev->cjPointerOffset;

            ET6K_SPRITE_HORZ_POSITION(ppdev, ppdev->cxScreen / 2);      //  Center it.
            ET6K_SPRITE_VERT_POSITION(ppdev, ppdev->cyScreen / 2);      //  Center it.
            ET6K_HORZ_PRESET(ppdev, 0);
            ET6K_VERT_PRESET(ppdev, 0);
            ET6K_SPRITE_START_ADDR(ppdev, ppdev->cjPointerOffset);
            ET6K_SPRITE_COLOR(ppdev, 0xFF00);

            for (i = 0; i < 1024; i++)
            {
                *pjDst++ = 0xaa;
            }
        }
        else
        {
            SET_HORZ_POSITION(ppdev->cxScreen * ppdev->cBpp / 2);
            SET_VERT_POSITION(ppdev->cyScreen / 2);
            SET_HORZ_PRESET(0);
            SET_VERT_PRESET(0);

            SET_SPRITE_START_ADDR(ppdev->cjPointerOffset);
            SET_SPRITE_ROW_OFFSET;

            // Set the CRTCB pixel pan register to 0.

            OUTP(CRTCB_SPRITE_INDEX, CRTCB_PIXEL_PANNING);
            OUTP(CRTCB_SPRITE_DATA, 0);

            // Set the pixel depth to 2 bits per pixel.
            // (even though the doc says this is only for the CRTCB mode and not
            // the sprite mode, the doesn't work unless these values are 0.

            OUTP(CRTCB_SPRITE_INDEX, CRTCB_COLOR_DEPTH);
            OUTP(CRTCB_SPRITE_DATA, 0x01);

            // Set the CRTCB/Sprite control to a 64 X 64 Sprite in overlay mode.

            OUTP(CRTCB_SPRITE_INDEX, CRTCB_SPRITE_CONTROL);
            OUTP(CRTCB_SPRITE_DATA, 0x02);

            // Fill the sprite buffer and the next 17 lines with a transparent
            // pattern.  This is to get around one of the sprite bugs.

            njSpriteBuffer = SPRITE_BUFFER_SIZE;

            nBytesPerBank    = 0x2000;
            n8kBanks         = njSpriteBuffer / nBytesPerBank;
            nRemainingBytes  = njSpriteBuffer % nBytesPerBank;

            for (j = 0; j < n8kBanks; j++)
            {
                // First set Aperture 0 to the sprite buffer address.

                CP_MMU_BP0(ppdev, pjBase, (ppdev->cjPointerOffset + (j * nBytesPerBank)));

                // Reset the linear address to the beginning of this 8K segment

                for (i = 0; i < nBytesPerBank; i++)
                {
                    //*pjSpriteBuffer++ = 0xAA;
                    CP_WRITE_MMU_BYTE(ppdev, 0, i, 0xAA);
                }
            }

            // Set Aperture 0 to the sprite buffer address.

            CP_MMU_BP0(ppdev, pjBase, (ppdev->cjPointerOffset + (j * nBytesPerBank)));

            // Reset the linear address to the beginning of this 8K segment

            for (i = 0; i < nRemainingBytes; i++)
            {
                //*pjSpriteBuffer++ = 0xAA;
                CP_WRITE_MMU_BYTE(ppdev, 0, i, 0xAA);
            }

        }
        ENABLE_SPRITE(ppdev);
    }
}

/******************************Public*Routine******************************\
* BOOL bEnablePointer
*
\**************************************************************************/

BOOL bEnablePointer(
PDEV*   ppdev)
{
    if (ppdev->flCaps & CAPS_SW_POINTER)
    {
        // With a software pointer, we don't have to do anything.
    }
    else
    {
        // Enable the W32 hardware pointer.
    }

    // Actually turn on the pointer:

    vAssertModePointer(ppdev, TRUE);

    DISPDBG((5, "Passed bEnablePointer"));

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\str.c ===
/******************************Module*Header*******************************\
* Module Name: stretch.c
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define STRETCH_MAX_EXTENT 32767

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8
*
* Routine Description:
*
*   Stretch blt 8->8
*
* NOTE: This routine doesn't handle cases where the blt stretch starts
*       and ends in the same destination dword!  vDirectStretchNarrow
*       is expected to have been called for that case.
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch8(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    BYTE*   pjDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    BYTE*   pjOldScan;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    BYTE*   pjDst       = pStrBlt->pjDstScan + xDst;
    LONG    yDst        = pStrBlt->YDstStart; // + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)((ULONG_PTR)pjDst & 0x03);
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)((ULONG_PTR)(pjDst + WidthX) & 0x03);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    ULONG   yInt        = 0;
    LONG    lDstStride  = pStrBlt->lDeltaDst - WidthX;

    BYTE*   pjBase      = ppdev->pjBase;
    LONG    cBpp        = 1;
    LONG    lDelta      = ppdev->lDelta;

    ULONG   ulSrcAddr   = yDst * lDelta + xDst * cBpp + ppdev->xyOffset;

    WidthXAln = WidthX - EndAln - ((- (LONG) StartAln) & 0x03);

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    //
    // loop drawing each scan line
    //
    //
    // at least 7 wide (DST) blt
    //

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

    CP_XCNT(ppdev, pjBase, (WidthX * cBpp) - 1);
    CP_YCNT(ppdev, pjBase, 0);  // we'll do one line at a time


    do {
        BYTE    jSrc0,jSrc1,jSrc2,jSrc3;
        ULONG   yTmp;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        switch (StartAln) {
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        }

        pjDstEnd  = pjDst + WidthXAln;

        while (pjDst != pjDstEnd)
        {
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc1 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            jSrc2 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc3 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            ulDst = (jSrc3 << 24) | (jSrc2 << 16) | (jSrc1 << 8) | jSrc0;

            *(PULONG)pjDst = ulDst;
            pjDst += 4;
        }

        switch (EndAln) {
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pjDst = (pjDst + lDstStride);
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pjDst = (pjDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            CP_SRC_ADDR(ppdev, pjBase, ulSrcAddr);

            while (cyDuplicate)
            {
                // Set the blt destination address as the base address of MMU aperture 2
                // Then start the accelerated operation by writing something to this
                // aperture.
                //
                // NOTE: The destination is the ulSrcAddr + lDetla.  Additionally,
                //       ulSrcAddr must be incremented by lDelta for each time through
                //       this loop.  So, instead of maintaining a ulDstAddr, we'll
                //       just piggy back off of ulSrcAddr.

                ulSrcAddr += lDelta;

                SET_DEST_ADDR_ABS(ppdev, ulSrcAddr);
                START_ACL(ppdev);

                if (--cyDuplicate)
                {
                    //
                    // Only wait if we are going to loop again!
                    //

                    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
                }
            }

        }

        ulSrcAddr += lDelta;

    } while (yCount != 0);
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch16
*
* Routine Description:
*
*   Stretch blt 16->16
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch16(
STR_BLT* pStrBlt)
{
    BYTE*   pjOldScan;
    USHORT* pusSrc;
    USHORT* pusDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = (pStrBlt->pjSrcScan) + xSrc * 2;
    USHORT* pusDst      = (USHORT*)(pStrBlt->pjDstScan) + xDst;
    LONG    yDst        = pStrBlt->YDstStart; // + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)(((ULONG_PTR)pusDst & 0x02) >> 1);
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)(((ULONG_PTR)(pusDst + WidthX) & 0x02) >> 1);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - 2 * WidthX;
    ULONG   yInt        = 0;

    BYTE*   pjBase      = ppdev->pjBase;
    LONG    cBpp        = 2;
    LONG    lDelta      = ppdev->lDelta;

    ULONG   ulSrcAddr   = yDst * lDelta + xDst * cBpp + ppdev->xyOffset;

    WidthXAln = WidthX - EndAln - StartAln;

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    // Loop stretching each scan line

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

    CP_XCNT(ppdev, pjBase, (WidthX * cBpp) - 1);
    CP_YCNT(ppdev, pjBase, 0);  // we'll do one line at a time

    do {
        USHORT  usSrc0,usSrc1;
        ULONG   yTmp;

        pusSrc  = (USHORT*) pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        // A single source scan line is being written:

        if (StartAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
            xAccum    = xTmp;
        }

        pusDstEnd  = pusDst + WidthXAln;

        while (pusDst != pusDstEnd)
        {

            usSrc0 = *pusSrc;
            xTmp   = xAccum + xFrac;
            pusSrc = pusSrc + xInt + (xTmp < xAccum);

            usSrc1 = *pusSrc;
            xAccum = xTmp + xFrac;
            pusSrc = pusSrc + xInt + (xAccum < xTmp);

            ulDst = (ULONG)((usSrc1 << 16) | usSrc0);

            *(ULONG*)pusDst = ulDst;
            pusDst+=2;
        }

        if (EndAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pusDst = (USHORT*) ((BYTE*) pusDst + lDstStride);
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pusDst = (USHORT*) ((BYTE*) pusDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            CP_SRC_ADDR(ppdev, pjBase, ulSrcAddr);

            while (cyDuplicate)
            {
                // Set the blt destination address as the base address of MMU aperture 2
                // Then start the accelerated operation by writing something to this
                // aperture.
                //
                // NOTE: The destination is the ulSrcAddr + lDetla.  Additionally,
                //       ulSrcAddr must be incremented by lDelta for each time through
                //       this loop.  So, instead of maintaining a ulDstAddr, we'll
                //       just piggy back off of ulSrcAddr.

                ulSrcAddr += lDelta;

                SET_DEST_ADDR_ABS(ppdev, ulSrcAddr);
                START_ACL(ppdev);

                if (--cyDuplicate)
                {
                    //
                    // Only wait if we are going to loop again!
                    //

                    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
                }
            }
        }

        ulSrcAddr += lDelta;

    } while (yCount != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\palette.c ===
/******************************Module*Header*******************************\
* Module Name: palette.c
*
* Palette support.
*
* Copyright (c) 1992-1994 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

PALETTEENTRY gapalBase[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

/******************************Public*Routine******************************\
* BOOL bInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)
{
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    BYTE            jRed;
    BYTE            jGre;
    BYTE            jBlu;
    HPALETTE        hpal;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Allocate our palette:

        ppal = (PALETTEENTRY*)EngAllocMem(0, sizeof(PALETTEENTRY) * 256, ALLOC_TAG);

        if (ppal == NULL)
        {
            goto ReturnFalse;
        }

        ppdev->pPal = ppal;

        // Generate 256 (8*4*4) RGB combinations to fill the palette

        jRed = 0;
        jGre = 0;
        jBlu = 0;

        ppalTmp = ppal;

        for (ulLoop = 256; ulLoop != 0; ulLoop--)
        {
            ppalTmp->peRed   = jRed;
            ppalTmp->peGreen = jGre;
            ppalTmp->peBlue  = jBlu;
            ppalTmp->peFlags = 0;

            ppalTmp++;

            if (!(jRed += 32))
                if (!(jGre += 32))
                    jBlu += 64;
        }

        // Fill in Windows reserved colours from the WIN 3.0 DDK
        // The Window Manager reserved the first and last 10 colours for
        // painting windows borders and for non-palette managed applications.

        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
            // First 10

            ppal[ulLoop]       = gapalBase[ulLoop];

            // Last 10

            ppal[246 + ulLoop] = gapalBase[ulLoop+10];
        }

        // Create handle for palette.

        hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
    }
    else
    {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_24BPP),
                 "This case handles only 16 or 24bpp");

        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
    }

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if (hpal == 0)
        goto ReturnFalse;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializePalette"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);

    if (ppdev->pPal != (PALETTEENTRY*) NULL)
        EngFreeMem(ppdev->pPal);
}

/******************************Public*Routine******************************\
* BOOL bEnablePalette
*
* Initialize the hardware's 8bpp palette registers.
*
\**************************************************************************/

BOOL bEnablePalette(PDEV* ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    PALETTEENTRY* ppalFrom;
    PALETTEENTRY* ppalTo;
    PALETTEENTRY* ppalEnd;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy Colors in.

        ppalFrom = ppdev->pPal;
        ppalTo   = (PALETTEENTRY*) pScreenClut->LookupTable;
        ppalEnd  = &ppalTo[256];

        for (; ppalTo < ppalEnd; ppalFrom++, ppalTo++)
        {
            ppalTo->peRed   = ppalFrom->peRed   >> 2;
            ppalTo->peGreen = ppalFrom->peGreen >> 2;
            ppalTo->peBlue  = ppalFrom->peBlue  >> 2;
            ppalTo->peFlags = 0;
        }

        // Set palette registers:

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_COLOR_REGISTERS,
                               pScreenClut,
                               MAX_CLUT_SIZE,
                               NULL,
                               0,
                               &ulReturnedDataLength))
        {
            DISPDBG((0, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisablePalette
*
* Undoes anything done in bEnablePalette.
*
\**************************************************************************/

VOID vDisablePalette(
PDEV*   ppdev)
{
    // Nothin' to do
}

/******************************Public*Routine******************************\
* VOID vAssertModePalette
*
* Sets/resets the palette in preparation for full-screen/graphics mode.
*
\**************************************************************************/

VOID vAssertModePalette(
PDEV*   ppdev,
BOOL    bEnable)
{
    // USER immediately calls DrvSetPalette after switching out of
    // full-screen, so we don't have to worry about resetting the
    // palette here.
}

/******************************Public*Routine******************************\
* BOOL DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE          ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT   pScreenClut;
    PALETTEENTRY* ppal;
    PALETTEENTRY* ppalEnd;
    PDEV*         ppdev;

    UNREFERENCED_PARAMETER(fl);

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    ppal = (PPALETTEENTRY) (pScreenClut->LookupTable);

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors, (ULONG*) ppal))
    {
        DISPDBG((0, "DrvSetPalette failed PALOBJ_cGetColors\n"));
        goto ReturnFalse;
    }

    // Set the high reserved byte in each palette entry to 0.

    for (ppalEnd = &ppal[cColors]; ppal < ppalEnd; ppal++)
    {
        ppal->peRed   >>= 2;
        ppal->peGreen >>= 2;
        ppal->peBlue  >>= 2;
        ppal->peFlags = 0;
    }

    // Set palette registers

    ppdev = (PDEV*) dhpdev;

    if (EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_SET_COLOR_REGISTERS,
                            pScreenClut,
                            MAX_CLUT_SIZE,
                            NULL,
                            0,
                            &cColors))
    {
        DISPDBG((0, "DrvSetPalette failed EngDeviceIoControl\n"));
        goto ReturnFalse;
    }

    return(TRUE);

ReturnFalse:

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\stretch.c ===
/******************************Module*Header*******************************\
* Module Name: stretch.c
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define STRETCH_MAX_EXTENT 32767

typedef DWORDLONG ULONGLONG;

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8Narrow
*
* Routine Description:
*
*   Stretch blt 8->8 when the width is 7 or less
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch8Narrow(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    BYTE*   pjDstEnd;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;

    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    BYTE*   pjDst       = pStrBlt->pjDstScan + xDst;
    LONG    yCount      = pStrBlt->YDstCount;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - WidthX;
    ULONG   yInt        = 0;

    yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;

    //
    // Narrow blt
    //

    do {

        ULONG  yTmp = yAccum + yFrac;
        BYTE   jSrc0;
        BYTE*  pjDstEndNarrow = pjDst + WidthX;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        do {
            jSrc0    = *pjSrc;
            xTmp     = xAccum + xFrac;
            pjSrc    = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum   = xTmp;
        } while (pjDst != pjDstEndNarrow);

        pjSrcScan += yInt;

        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }

        yAccum = yTmp;
        pjDst += lDstStride;

    } while (--yCount);

}

/******************************Public*Routine******************************\
*
* Routine Description:
*
*   StretchBlt using integer math. Must be from one surface to another
*   surface of the same format.
*
* Arguments:
*
*   ppdev           -   PDEV for device
*   pvDst           -   Pointer to start of dst bitmap
*   lDeltaDst       -   Bytes from start of dst scan line to start of next
*   DstCx           -   Width of Dst Bitmap in pixels
*   DstCy           -   Height of Dst Bitmap in pixels
*   prclDst         -   Pointer to rectangle of Dst extents
*   pvSrc           -   Pointer to start of Src bitmap
*   lDeltaSrc       -   Bytes from start of Src scan line to start of next
*   SrcCx           -   Width of Src Bitmap in pixels
*   SrcCy           -   Height of Src Bitmap in pixels
*   prclSrc         -   Pointer to rectangle of Src extents
*   prclSClip       -   Clip Dest to this rect
*
* Return Value:
*
*   Status
*
\**************************************************************************/

BOOL bStretchDIB(
PDEV*   ppdev,
VOID*   pvDst,
LONG    lDeltaDst,
RECTL*  prclDst,
VOID*   pvSrc,
LONG    lDeltaSrc,
RECTL*  prclSrc,
RECTL*  prclClip)
{
    STR_BLT StrBlt;
    ULONG   XSrcToDstIntFloor;
    ULONG   XSrcToDstFracFloor;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   YSrcToDstIntFloor;
    ULONG   YSrcToDstFracFloor;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    LONG    SrcIntScan;
    LONG    DstDeltaScanEnd;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
    LONG    LeftClipDistance;
    LONG    TopClipDistance;
    BOOL    bStretch;

    union {
        LARGE_INTEGER   large;
        ULONGLONG       li;
    } liInit;

    PFN_DIRSTRETCH      pfnStr;

    //
    // Calculate exclusive start and end points:
    //

    LONG    WidthDst  = prclDst->right  - prclDst->left;
    LONG    HeightDst = prclDst->bottom - prclDst->top;
    LONG    WidthSrc  = prclSrc->right  - prclSrc->left;
    LONG    HeightSrc = prclSrc->bottom - prclSrc->top;

    LONG    XSrcStart = prclSrc->left;
    LONG    XSrcEnd   = prclSrc->right;
    LONG    XDstStart = prclDst->left;
    LONG    XDstEnd   = prclDst->right;
    LONG    YSrcStart = prclSrc->top;
    LONG    YSrcEnd   = prclSrc->bottom;
    LONG    YDstStart = prclDst->top;
    LONG    YDstEnd   = prclDst->bottom;

    //
    // Validate parameters:
    //

    ASSERTDD(pvDst != (VOID*)NULL, "Bad destination bitmap pointer");
    ASSERTDD(pvSrc != (VOID*)NULL, "Bad source bitmap pointer");
    ASSERTDD(prclDst != (RECTL*)NULL, "Bad destination rectangle");
    ASSERTDD(prclSrc != (RECTL*)NULL, "Bad source rectangle");
    ASSERTDD((WidthDst > 0) && (HeightDst > 0) &&
             (WidthSrc > 0) && (HeightSrc > 0),
             "Can't do mirroring or empty rectangles here");
    ASSERTDD((WidthDst  <= STRETCH_MAX_EXTENT) &&
             (HeightDst <= STRETCH_MAX_EXTENT) &&
             (WidthSrc  <= STRETCH_MAX_EXTENT) &&
             (HeightSrc <= STRETCH_MAX_EXTENT), "Stretch exceeds limits");
    ASSERTDD(prclClip != NULL, "Bad clip rectangle");

    //
    // Calculate X Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*WidthSrc)/WidthDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*WidthSrc -1) / WidthDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liWidthSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = WidthSrc - 1;
        liWidthSrc = liInit.li;

        liQuo = liWidthSrc / (ULONGLONG) WidthDst;

        ulXDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulXDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulXDstToSrcFracCeil + 1;

        ulXDstToSrcIntCeil += (ulTemp < ulXDstToSrcFracCeil);
        ulXDstToSrcFracCeil = ulTemp;
    }

    //
    // Calculate Y Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*HeightSrc)/HeightDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*HeightSrc -1) / HeightDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liHeightSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = HeightSrc - 1;
        liHeightSrc = liInit.li;

        liQuo = liHeightSrc / (ULONGLONG) HeightDst;

        ulYDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulYDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulYDstToSrcFracCeil + 1;

        ulYDstToSrcIntCeil += (ulTemp < ulYDstToSrcFracCeil);
        ulYDstToSrcFracCeil = ulTemp;
    }

    //
    // Now clip Dst in X, and/or calc src clipping effect on dst
    //
    // adjust left and right edges if needed, record
    // distance adjusted for fixing the src
    //

    if (XDstStart < prclClip->left)
    {
        XDstStart = prclClip->left;
    }

    if (XDstEnd > prclClip->right)
    {
        XDstEnd = prclClip->right;
    }

    //
    // Check for totally clipped out destination:
    //

    if (XDstEnd <= XDstStart)
    {
        return(TRUE);
    }

    LeftClipDistance = XDstStart - prclDst->left;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulXDstToSrcFracCeil >> 1) | (ulXDstToSrcIntCeil << 31);
        ulTempInt  = (ulXDstToSrcIntCeil >> 1);

        XSrcStart += ulTempInt;
        ulXFracAccumulator = ulTempFrac;

        if (LeftClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulXDstToSrcFracCeil, LeftClipDistance);

            ulTmp = ulXFracAccumulator;
            ulXFracAccumulator += (ULONG) (ullFraction);
            if (ulXFracAccumulator < ulTmp)
                XSrcStart++;

            XSrcStart += (ulXDstToSrcIntCeil * LeftClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Now clip Dst in Y, and/or calc src clipping effect on dst
    //
    // adjust top and bottom edges if needed, record
    // distance adjusted for fixing the src
    //

    if (YDstStart < prclClip->top)
    {
        YDstStart = prclClip->top;
    }

    if (YDstEnd > prclClip->bottom)
    {
        YDstEnd = prclClip->bottom;
    }

    //
    // Check for totally clipped out destination:
    //

    if (YDstEnd <= YDstStart)
    {
        return(TRUE);
    }

    TopClipDistance = YDstStart - prclDst->top;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulYDstToSrcFracCeil >> 1) | (ulYDstToSrcIntCeil << 31);
        ulTempInt  = ulYDstToSrcIntCeil >> 1;

        YSrcStart += (LONG)ulTempInt;
        ulYFracAccumulator = ulTempFrac;

        if (TopClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulYDstToSrcFracCeil, TopClipDistance);

            ulTmp = ulYFracAccumulator;
            ulYFracAccumulator += (ULONG) (ullFraction);
            if (ulYFracAccumulator < ulTmp)
                YSrcStart++;

            YSrcStart += (ulYDstToSrcIntCeil * TopClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Warm up the hardware if doing an expanding stretch in 'y':
    //

    bStretch = (HeightDst > HeightSrc);
    if (bStretch)
    {
        BYTE*   pjBase  = ppdev->pjBase;
        LONG x;

        //
        // Set up the left and right blt edges, since they never change
        // during the StretchBlt
        //

        WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

        CP_FG_ROP(ppdev, pjBase, R3_SRCCOPY);
        CP_SRC_WRAP(ppdev, pjBase, NO_PATTERN_WRAP);
        CP_SRC_Y_OFFSET(ppdev, pjBase, (lDeltaDst - 1));
        CP_DST_Y_OFFSET(ppdev, pjBase, (lDeltaDst - 1));
    }

    //
    // Fill out blt structure, then call format-specific stretch code
    //

    StrBlt.ppdev     = ppdev;
    StrBlt.XDstEnd   = XDstEnd;
    StrBlt.YDstStart = YDstStart;
    StrBlt.YDstCount = YDstEnd - YDstStart;

    if (StrBlt.YDstCount > 0)
    {
        //
        // Caclulate starting scan line address.  Since the inner loop
        // routines are format dependent, they must add XDstStart/XSrcStart
        // to pjDstScan/pjSrcScan to get the actual starting pixel address.
        //

        StrBlt.pjSrcScan           = (BYTE*) pvSrc + (YSrcStart * lDeltaSrc);
        StrBlt.pjDstScan           = (BYTE*) pvDst + (YDstStart * lDeltaDst);

        StrBlt.lDeltaSrc           = lDeltaSrc;
        StrBlt.XSrcStart           = XSrcStart;
        StrBlt.XDstStart           = XDstStart;
        StrBlt.lDeltaDst           = lDeltaDst;
        StrBlt.ulXDstToSrcIntCeil  = ulXDstToSrcIntCeil;
        StrBlt.ulXDstToSrcFracCeil = ulXDstToSrcFracCeil;
        StrBlt.ulYDstToSrcIntCeil  = ulYDstToSrcIntCeil;
        StrBlt.ulYDstToSrcFracCeil = ulYDstToSrcFracCeil;
        StrBlt.ulXFracAccumulator  = ulXFracAccumulator;
        StrBlt.ulYFracAccumulator  = ulYFracAccumulator;

        if (ppdev->iBitmapFormat == BMF_8BPP)
        {
            if ((XDstEnd - XDstStart) < 7)
                pfnStr = vDirectStretch8Narrow;
            else
                pfnStr = vDirectStretch8;
        }
        else
        {
            ASSERTDD(ppdev->iBitmapFormat == BMF_16BPP,
                     "Only handle stretches at 8 and 16bpp");

            pfnStr = vDirectStretch16;
        }

        (*pfnStr)(&StrBlt);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bBankedStretch
*
\**************************************************************************/

BOOL bBankedStretch(
PDEV*   ppdev,
VOID*   pvDst,
LONG    lDeltaDst,
RECTL*  prclDst,
VOID*   pvSrc,
LONG    lDeltaSrc,
RECTL*  prclSrc,
RECTL*  prclClip)
{
    BANK    bnk;
    BOOL    b;
    RECTL   rclDst;

    b = TRUE;
    if (bIntersect(prclDst, prclClip, &rclDst))
    {
        vBankStart(ppdev, &rclDst, NULL, &bnk);

        do {
            b &= bStretchDIB(ppdev,
                             bnk.pso->pvScan0,
                             lDeltaDst,
                             prclDst,
                             pvSrc,
                             lDeltaSrc,
                             prclSrc,
                             &bnk.pco->rclBounds);

        } while (bBankEnum(&bnk));
    }

    return(b);
}

/******************************Public*Routine******************************\
* BOOL DrvStretchBlt
*
\**************************************************************************/

BOOL DrvStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMsk,
ULONG               iMode)
{
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    PDEV*   ppdev;
    OH*     poh;

    // !!! What about sparse-space Alpha?

    // GDI guarantees us that for a StretchBlt the destination surface
    // will always be a device surface, and not a DIB:

    ppdev = (PDEV*) psoDst->dhpdev;

    // It's quicker for GDI to do a StretchBlt when the source surface
    // is not a device-managed surface, because then it can directly
    // read the source bits without having to allocate a temporary
    // buffer and call DrvCopyBits to get a copy that it can use.
    //
    // So if the source is one of our off-screen DFBs, we'll immediately
    // and permanently convert it to a DIB:

    if (psoSrc->iType == STYPE_DEVBITMAP)
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        if (pdsurfSrc->dt == DT_SCREEN)
        {
            if (!pohMoveOffscreenDfbToDib(ppdev, pdsurfSrc->poh))
                return(FALSE);
        }

        ASSERTDD(pdsurfSrc->dt == DT_DIB, "Can only handle DIB DFBs here");

        psoSrc = pdsurfSrc->pso;
    }

    pdsurfDst = (DSURF*) psoDst->dhsurf;
    if (pdsurfDst->dt == DT_DIB)
    {
        // The destination was a device bitmap that we just converted
        // to a DIB:

        psoDst = pdsurfDst->pso;
        goto Punt_It;
    }

    poh             = pdsurfDst->poh;
    ppdev->xOffset  = poh->x;
    ppdev->yOffset  = poh->y;
    ppdev->xyOffset = (ppdev->cBpp * ppdev->xOffset) +
                      (ppdev->yOffset * ppdev->lDelta);

    {
        RECTL       rclClip;
        RECTL*      prclClip;
        ULONG       cxDst;
        ULONG       cyDst;
        ULONG       cxSrc;
        ULONG       cySrc;
        BOOL        bMore;
        CLIPENUM    ce;
        LONG        c;
        LONG        i;

        if ((psoSrc->iType == STYPE_BITMAP) &&
            (psoMsk == NULL) &&
            ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
            ((psoSrc->iBitmapFormat == ppdev->iBitmapFormat)) &&
            (ppdev->iBitmapFormat != BMF_24BPP))
        {
            cxDst = prclDst->right - prclDst->left;
            cyDst = prclDst->bottom - prclDst->top;
            cxSrc = prclSrc->right - prclSrc->left;
            cySrc = prclSrc->bottom - prclSrc->top;

            // Our 'bStretchDIB' routine requires that the stretch be
            // non-inverting, within a certain size, to have no source
            // clipping, and to have no empty rectangles (the latter is the
            // reason for the '- 1' on the unsigned compare here):

            if (((cxSrc - 1) < STRETCH_MAX_EXTENT)         &&
                ((cySrc - 1) < STRETCH_MAX_EXTENT)         &&
                ((cxDst - 1) < STRETCH_MAX_EXTENT)         &&
                ((cyDst - 1) < STRETCH_MAX_EXTENT)         &&
                (prclSrc->left   >= 0)                     &&
                (prclSrc->top    >= 0)                     &&
                (prclSrc->right  <= psoSrc->sizlBitmap.cx) &&
                (prclSrc->bottom <= psoSrc->sizlBitmap.cy))
            {
                // Our snazzy routine only does COLORONCOLOR.  But for
                // stretching blts, BLACKONWHITE and WHITEONBLACK are also
                // equivalent to COLORONCOLOR:

                if ((iMode == COLORONCOLOR) ||
                    ((iMode < COLORONCOLOR) && (cxSrc <= cxDst) && (cySrc <= cyDst)))
                {

                    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                    {
                        rclClip.left   = LONG_MIN;
                        rclClip.top    = LONG_MIN;
                        rclClip.right  = LONG_MAX;
                        rclClip.bottom = LONG_MAX;
                        prclClip = &rclClip;

                    StretchSingleClipRect:

                        if (bBankedStretch(ppdev,
                                        NULL,
                                        ppdev->lDelta,
                                        prclDst,
                                        psoSrc->pvScan0,
                                        psoSrc->lDelta,
                                        prclSrc,
                                        prclClip))
                        {
                            return(TRUE);
                        }
                    }
                    else if (pco->iDComplexity == DC_RECT)
                    {
                        prclClip = &pco->rclBounds;
                        goto StretchSingleClipRect;
                    }
                    else
                    {
                        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                        do {
                            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                            c = cIntersect(prclDst, ce.arcl, ce.c);

                            if (c != 0)
                            {
                                for (i = 0; i < c; i++)
                                {
                                    if (!bBankedStretch(ppdev,
                                                     NULL,
                                                     ppdev->lDelta,
                                                     prclDst,
                                                     psoSrc->pvScan0,
                                                     psoSrc->lDelta,
                                                     prclSrc,
                                                     &ce.arcl[i]))
                                    {
                                        goto Punt_It;
                                    }
                                }
                            }

                        } while (bMore);

                        return(TRUE);
                    }
                }
            }
        }
    }

Punt_It:

    // GDI is nice enough to handle the cases where 'psoDst' and/or 'psoSrc'
    // are device-managed surfaces, but it ain't gonna be fast...

    return(EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                         prclDst, prclSrc, pptlMsk, iMode));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\misc.c ===
/******************************Module*Header*******************************\
* Module Name: misc.c
*
* Miscellaneous common routines.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'.  If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL bIntersect(
RECTL*  prcl1,
RECTL*  prcl2,
RECTL*  prclResult)
{
    prclResult->left  = max(prcl1->left,  prcl2->left);
    prclResult->right = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
        prclResult->top    = max(prcl1->top,    prcl2->top);
        prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

        if (prclResult->top < prclResult->bottom)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* LONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'.  The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
\**************************************************************************/

LONG cIntersect(
RECTL*  prclClip,
RECTL*  prclIn,         // List of rectangles
LONG    c)              // Can be zero
{
    LONG    cIntersections;
    RECTL*  prclOut;

    cIntersections = 0;
    prclOut        = prclIn;

    for (; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\strips_i.c ===
/******************************Module*Header*******************************\
* Module Name: Strips.c
*
* All the line code in this driver amounts to a big bag of dirt.  Someday,
* I'm going to rewrite it all.  Not today, though (sigh)...
*
* Copyright (c) 1992-1994 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vrlSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using radial lines.
*
* Assumes fgRop, BgRop, and Color are already set correctly.
*
\**************************************************************************/

VOID vrlSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    PBYTE   pjXCount = ((BYTE*) ppdev->pjMmu2);
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    yInc     = 1;
    LONG    i;
    LONG    xyOffset;
    ULONG   ulDst;
    LONG    cLen;

    DISPDBG((1,"vrlSolidHorizontal"));

    ASSERTDD((ppdev->ulChipID != W32P),
             "The strip code won't work on a W32p");

    if (pStrip->flFlips & FL_FLIP_V)
        yInc = -1;

    xyOffset = ppdev->xyOffset;

    WAIT_FOR_IDLE_ACL(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, CPU_X_COUNT);
    CP_YCNT(ppdev, pjBase, 0);

    for (i = 0; i < cStrips; i++)
    {
        ulDst = (y * lDelta) + (cBpp * x);
        ulDst += xyOffset;

        WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
        cLen = ((*pStrips) * cBpp);
        CP_XCNT(ppdev, pjBase, (cLen - 1));
        CP_MMU_BP2(ppdev, pjBase, ulDst);
        *pjXCount = (BYTE)cLen - 1;
        x += *pStrips;
        y += yInc;
        pStrips++;
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, 0);
}

/******************************Public*Routine******************************\
* VOID vrlSolidVertical
*
* Draws left-to-right y-major near-vertical lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    PBYTE   pjYCount = ((BYTE*) ppdev->pjMmu2);
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    i;
    LONG    xyOffset;
    ULONG   ulDst;
    LONG    cLen;

    DISPDBG((1,"vrlSolidVertical"));

    ASSERTDD((ppdev->ulChipID != W32P),
             "The strip code won't work on a W32p");

    xyOffset = ppdev->xyOffset;

    WAIT_FOR_IDLE_ACL(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, CPU_Y_COUNT);
    CP_XCNT(ppdev, pjBase, (cBpp - 1));
    CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta - 1));

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            cLen = (*pStrips);
            CP_YCNT(ppdev, pjBase, (cLen - 1));
            CP_MMU_BP2(ppdev, pjBase, ulDst);
            *pjYCount = (BYTE)cLen - 1;
            y += cLen;
            x++;
            pStrips++;
        }
    }
    else
    {
        CP_XY_DIR(ppdev, pjBase, BOTTOM_TO_TOP);
        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            cLen = (*pStrips);
            CP_YCNT(ppdev, pjBase, (cLen - 1));
            CP_MMU_BP2(ppdev, pjBase, ulDst);
            *pjYCount = (BYTE)(cLen - 1);
            y -= cLen;
            x++;
            pStrips++;
        }

        WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
        CP_XY_DIR(ppdev, pjBase, 0);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, 0);
}

/******************************Public*Routine******************************\
* VOID vrlSolidDiagonalHorizontal
*
* Draws left-to-right x-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidDiagonalHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    PBYTE   pjYCount = ((BYTE*) ppdev->pjMmu2);
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    i;
    LONG    xyOffset;
    ULONG   ulDst;
    LONG    cLen;

    DISPDBG((1,"vrlSolidDiagonalHorizontal"));

    ASSERTDD((ppdev->ulChipID != W32P),
             "The strip code won't work on a W32p");

    xyOffset = ppdev->xyOffset;

    WAIT_FOR_IDLE_ACL(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, CPU_Y_COUNT);
    CP_XCNT(ppdev, pjBase, (cBpp - 1));

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        CP_DST_Y_OFFSET(ppdev, pjBase, ((lDelta + cBpp) - 1));

        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            cLen = (*pStrips);
            CP_YCNT(ppdev, pjBase, (cLen - 1));
            CP_MMU_BP2(ppdev, pjBase, ulDst);
            *pjYCount = (BYTE)(cLen - 1);
            y += (cLen - 1);
            x += cLen;
            pStrips++;
        }
    }
    else
    {
        CP_DST_Y_OFFSET(ppdev, pjBase, ((lDelta - cBpp) - 1));
        CP_XY_DIR(ppdev, pjBase, BOTTOM_TO_TOP);

        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            cLen = (*pStrips);
            CP_YCNT(ppdev, pjBase, (cLen - 1));
            CP_MMU_BP2(ppdev, pjBase, ulDst);
            *pjYCount = (BYTE)(cLen - 1);
            y -= (cLen - 1);
            x += cLen;
            pStrips++;
        }

        WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
        CP_XY_DIR(ppdev, pjBase, 0);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, 0);
}

/******************************Public*Routine******************************\
* VOID vrlSolidDiagonalVertical
*
* Draws left-to-right y-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidDiagonalVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    PBYTE   pjYCount = ((BYTE*) ppdev->pjMmu2);
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    i;
    LONG    xyOffset;
    ULONG   ulDst;
    LONG    cLen;

    DISPDBG((1,"vrlSolidDiagonalVertical"));

    ASSERTDD((ppdev->ulChipID != W32P),
             "The strip code won't work on a W32p");

    xyOffset = ppdev->xyOffset;

    WAIT_FOR_IDLE_ACL(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, CPU_Y_COUNT);
    CP_XCNT(ppdev, pjBase, (cBpp - 1));

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        CP_DST_Y_OFFSET(ppdev, pjBase, ((lDelta + cBpp) - 1));

        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            cLen = (*pStrips);
            CP_YCNT(ppdev, pjBase, (cLen - 1));
            CP_MMU_BP2(ppdev, pjBase, ulDst);
            *pjYCount = (BYTE)(cLen - 1);
            y += cLen;
            x += (cLen - 1);
            pStrips++;
        }
    }
    else
    {
        CP_DST_Y_OFFSET(ppdev, pjBase, ((lDelta - cBpp) - 1));
        CP_XY_DIR(ppdev, pjBase, BOTTOM_TO_TOP);

        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            cLen = (*pStrips);
            CP_YCNT(ppdev, pjBase, (cLen - 1));
            CP_MMU_BP2(ppdev, pjBase, ulDst);
            *pjYCount = (BYTE)(cLen - 1);
            y -= cLen;
            x += (cLen - 1);
            pStrips++;
        }

        WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
        CP_XY_DIR(ppdev, pjBase, 0);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, 0);
}

//{------------------------------------------------------------------------

/******************************Public*Routine******************************\
* VOID vssSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using radial lines.
*
* Assumes fgRop, BgRop, and Color are already set correctly.
*
\**************************************************************************/

VOID vssSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    PBYTE   pjXCount = ((BYTE*) ppdev->pjMmu2);
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    yInc     = 1;
    LONG    i;
    LONG    xyOffset;
    ULONG   ulDst;
    LONG    cLen;

    DISPDBG((1,"vssSolidHorizontal"));

    ASSERTDD((ppdev->ulChipID != W32P),
             "The strip code won't work on a W32p");

    if (pStrip->flFlips & FL_FLIP_V)
        yInc = -1;

    xyOffset = ppdev->xyOffset;

    WAIT_FOR_IDLE_ACL(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, CPU_X_COUNT);
    CP_YCNT(ppdev, pjBase, 0);

    for (i = 0; i < cStrips; i++)
    {
        ulDst = (y * lDelta) + (cBpp * x);
        ulDst += xyOffset;

        WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
        cLen = ((*pStrips) * cBpp);
        CP_MMU_BP2(ppdev, pjBase, ulDst);
        *pjXCount = (BYTE)cLen - 1;
        x += *pStrips;
        y += yInc;
        pStrips++;
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, 0);
}

/******************************Public*Routine******************************\
* VOID vssSolidVertical
*
* Draws left-to-right y-major near-vertical lines using radial lines.
*
\**************************************************************************/

VOID vssSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    PBYTE   pjYCount = ((BYTE*) ppdev->pjMmu2);
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    i;
    LONG    xyOffset;
    ULONG   ulDst;
    LONG    cLen;

    DISPDBG((1,"vssSolidVertical"));

    ASSERTDD((ppdev->ulChipID != W32P),
             "The strip code won't work on a W32p");

    xyOffset = ppdev->xyOffset;

    WAIT_FOR_IDLE_ACL(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, CPU_Y_COUNT);
    CP_XCNT(ppdev, pjBase, (cBpp - 1));
    CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta - 1));

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            cLen = (*pStrips);
            CP_MMU_BP2(ppdev, pjBase, ulDst);
            *pjYCount = (BYTE)cLen - 1;
            y += cLen;
            x++;
            pStrips++;
        }
    }
    else
    {
        CP_XY_DIR(ppdev, pjBase, BOTTOM_TO_TOP);
        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            cLen = (*pStrips);
            CP_MMU_BP2(ppdev, pjBase, ulDst);
            *pjYCount = (BYTE)(cLen - 1);
            y -= cLen;
            x++;
            pStrips++;
        }

        WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
        CP_XY_DIR(ppdev, pjBase, 0);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, 0);
}

/******************************Public*Routine******************************\
* VOID vssSolidDiagonalHorizontal
*
* Draws left-to-right x-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vssSolidDiagonalHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    PBYTE   pjYCount = ((BYTE*) ppdev->pjMmu2);
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    i;
    LONG    xyOffset;
    ULONG   ulDst;
    LONG    cLen;

    DISPDBG((1,"vssSolidDiagonalHorizontal"));

    ASSERTDD((ppdev->ulChipID != W32P),
             "The strip code won't work on a W32p");

    xyOffset = ppdev->xyOffset;

    WAIT_FOR_IDLE_ACL(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, CPU_Y_COUNT);
    CP_XCNT(ppdev, pjBase, (cBpp - 1));

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta + cBpp - 1));

        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            cLen = (*pStrips);
            CP_MMU_BP2(ppdev, pjBase, ulDst);
            *pjYCount = (BYTE)(cLen - 1);
            y += (cLen - 1);
            x += cLen;
            pStrips++;
        }
    }
    else
    {
        CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta - cBpp - 1));
        CP_XY_DIR(ppdev, pjBase, BOTTOM_TO_TOP);

        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            cLen = (*pStrips);
            CP_MMU_BP2(ppdev, pjBase, ulDst);
            *pjYCount = (BYTE)(cLen - 1);
            y -= (cLen - 1);
            x += cLen;
            pStrips++;
        }

        WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
        CP_XY_DIR(ppdev, pjBase, 0);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, 0);
}

/******************************Public*Routine******************************\
* VOID vssSolidDiagonalVertical
*
* Draws left-to-right y-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vssSolidDiagonalVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    PBYTE   pjYCount = ((BYTE*) ppdev->pjMmu2);
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    i;
    LONG    xyOffset;
    ULONG   ulDst;
    LONG    cLen;

    DISPDBG((1,"vssSolidDiagonalVertical"));

    ASSERTDD((ppdev->ulChipID != W32P),
             "The strip code won't work on a W32p");

    xyOffset = ppdev->xyOffset;

    WAIT_FOR_IDLE_ACL(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, CPU_Y_COUNT);
    CP_XCNT(ppdev, pjBase, (cBpp - 1));

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta + cBpp - 1));

        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            cLen = (*pStrips);
            CP_MMU_BP2(ppdev, pjBase, ulDst);
            *pjYCount = (BYTE)(cLen - 1);
            y += cLen;
            x += (cLen - 1);
            pStrips++;
        }
    }
    else
    {
        CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta - cBpp - 1));
        CP_XY_DIR(ppdev, pjBase, BOTTOM_TO_TOP);

        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            cLen = (*pStrips);
            CP_MMU_BP2(ppdev, pjBase, ulDst);
            *pjYCount = (BYTE)(cLen - 1);
            y -= cLen;
            x += (cLen - 1);
            pStrips++;
        }

        WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
        CP_XY_DIR(ppdev, pjBase, 0);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, 0);
}

//}------------------------------------------------------------------------

/******************************Public*Routine******************************\
* VOID vStripStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vStripStyledHorizontal(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    DISPDBG((1,"vStripStyledHorizontal"));
    return;
}

/******************************Public*Routine******************************\
* VOID vStripStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vStripStyledVertical(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    DISPDBG((1,"vStripStyledVertical"));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\i386\lines.inc ===
;---------------------------- Include File Header ---------------------------;
; Module Name: lines.inc
;
; Line drawing constants and structures.
;
; NOTE: This file mirrors LINES.H.  Changes here must be reflected in
; the .h file!
;
; Copyright (c) 1993-1994 Microsoft Corporation
;----------------------------------------------------------------------------;

; We have special strip routines when all strips have at most this many
; pixels:

MAX_SHORT_STROKE_LENGTH equ 15

; # of strip drawers in every group:

NUM_STRIP_DRAW_DIRECTIONS equ 4

; # of strip drawers for doing either solid lines or styled lines:

NUM_STRIP_DRAW_STYLES equ 8

STYLE_MAX_COUNT         equ 16
STYLE_MAX_VALUE         equ 3fffh
RUN_MAX                 equ 20
STRIP_MAX               equ 100
STYLE_DENSITY           equ 3

; Flip and round flags:

FL_H_ROUND_DOWN         equ 00000080h   ; Set if x = 1/2 rounds to x = 1
FL_V_ROUND_DOWN         equ 00008000h   ; Set if y = 1/2 rounds to y = 1

FL_FLIP_D               equ 00000005h   ; Diagonal flip
FL_FLIP_V               equ 00000008h   ; Vertical flip
FL_FLIP_SLOPE_ONE       equ 00000010h   ; If slope is exactly one
FL_FLIP_HALF            equ 00000002h   ; Half flip
FL_FLIP_H               equ 00000200h   ; Horizontal (right-to-left) exchange

FL_ROUND_MASK           equ 0000001ch   ; Rounding is dependent on diagonal,
FL_ROUND_SHIFT          equ 2           ;  vertical flips and if slope is one

FL_RECTLCLIP_MASK       equ 0000000ch   ; When we unflip to do clipping, we
FL_RECTLCLIP_SHIFT      equ 2           ;  only have to look at diagonal and
                                        ;  vertical flips

FL_STRIP_MASK           equ 00000003h   ; Which strip drawer we call is based
FL_STRIP_SHIFT          equ 0           ;  on if we did diagonal and/or half
                                        ;  flips

FL_SIMPLE_CLIP          equ 00000020h   ; Denotes our clipping complexity
FL_COMPLEX_CLIP         equ 00000040h
FL_CLIP                 equ (FL_SIMPLE_CLIP + FL_COMPLEX_CLIP)

FL_SET                  equ 00000800h   ; If ROP is such that we don't have to
                                        ;  read video memory
FL_ARBITRARYSTYLED      equ 00000400h   ; If the line is styled
FL_STYLED               equ (FL_ARBITRARYSTYLED)

FL_STRIP_ARRAY_MASK     equ 00000C00h   ; Which strip arrays we look up depends
FL_STRIP_ARRAY_SHIFT    equ 10          ;  on if we're doing style and/or have
                                        ;  a 'set' style ROP

; Simple flag bits in high byte:

FL_DONT_DO_HALF_FLIP    equ 00002000h
FL_PHYSICAL_DEVICE      equ 00004000h

; Miscellaneous DDA defines:

F                       equ 16
FLOG2                   equ 4

;------------------------------------------------------------------------
; NOTE: The following structures must exactly match those declared in
;       lines.h!

STRIPS struc
    ST_cStrips	        dd  ?
    ST_flFlips          dd  ?
    ST_ptlStart         dd  2 dup(?)
    ST_alStrips	        dd  STRIP_MAX dup (?)
STRIPS ends

LINESTATE struc
    LS_pspStart         dd  ?
    LS_pspEnd           dd  ?
    LS_psp              dd  ?
    LS_spRemaining      dd  ?
    LS_spTotal          dd  ?
    LS_spTotal2         dd  ?
    LS_spNext           dd  ?
    LS_spComplex        dd  ?
    LS_aspRtoL          dd  ?
    LS_aspLtoR          dd  ?
    LS_jStyleMask       db  ?
    LS_filler2          db  3 dup (?)
    LS_xyDensity        dd  ?
    LS_cStyle           dd  ?
    LS_ulStyleMaskLtoR  dd  ?
    LS_ulStyleMaskRtoL  dd  ?
    LS_jStartMask       db  ?
    LS_filler3          db  3 dup (?)
LINESTATE ends

RUN struc
    RUN_iStart          dd  ?
    RUN_iStop           dd  ?
RUN ends

DEFAULT_DRAW_CMD	    equ (DRAW_LINE+DRAW+DIR_TYPE_XY+MULTIPLE_PIXELS+WRITE+ \
                             LAST_PIXEL_OFF)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\strips_p.c ===
/******************************Module*Header*******************************\
* Module Name: Strips.c
*
* All the line code in this driver amounts to a big bag of dirt.  Someday,
* I'm going to rewrite it all.  Not today, though (sigh)...
*
* Copyright (c) 1992-1994 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

//
// I will try to optimize it a bit.
//


/******************************Public*Routine******************************\
* VOID vrlSolidHorizontalP
*
* Draws left-to-right x-major near-horizontal lines using radial lines.
*
* Assumes fgRop, BgRop, and Color are already set correctly.
*
\**************************************************************************/

VOID vrlSolidHorizontalP(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    yInc     = 1;
    LONG    i;
    LONG    xyOffset;
    ULONG   ulDst;

    DISPDBG((1,"vrlSolidHorizontalP"));

    xyOffset = ppdev->xyOffset;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        BYTE jDir = (0x80) |
                    (NO_Y_FLIP<<4) |
                    (X_MAJOR<<2) |
                    (NO_Y_FLIP<<1) |
                    (NO_X_FLIP);

        CP_XY_DIR(ppdev, pjBase, jDir);

        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            SETUP_DRAW_LINE(pjBase,*pStrips,0,X_MAJOR,cBpp);
            CP_DST_ADDR(ppdev, pjBase, ulDst);

            x += *pStrips;
            y++;
            pStrips++;
        }
    }
    else
    {
        BYTE jDir = (0x80) |
                    (Y_FLIP<<4) |
                    (X_MAJOR<<2) |
                    (Y_FLIP<<1) |
                    (NO_X_FLIP);

        CP_XY_DIR(ppdev, pjBase, jDir);

        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            SETUP_DRAW_LINE(pjBase,*pStrips,0,X_MAJOR,cBpp);
            CP_DST_ADDR(ppdev, pjBase, ulDst);

            x += *pStrips;
            y--;
            pStrips++;
        }
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_XY_DIR(ppdev, pjBase, 0);
}

/******************************Public*Routine******************************\
* VOID vrlSolidVerticalP
*
* Draws left-to-right y-major near-vertical lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidVerticalP(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    i;
    LONG    xyOffset;
    ULONG   ulDst;

    DISPDBG((1,"vrlSolidVerticalP"));

    xyOffset = ppdev->xyOffset;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta - 1));

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        BYTE jDir = (0x80) |
                    (NO_Y_FLIP<<4) |
                    (Y_MAJOR<<2) |
                    (NO_Y_FLIP<<1) |
                    (NO_X_FLIP);

        CP_XY_DIR(ppdev, pjBase, jDir);

        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            SETUP_DRAW_LINE(pjBase,0,*pStrips,Y_MAJOR,cBpp);
            CP_DST_ADDR(ppdev, pjBase, ulDst);

            y += *pStrips;
            x++;
            pStrips++;
        }
    }
    else
    {
        BYTE jDir = (0x80) |
                    (Y_FLIP<<4) |
                    (Y_MAJOR<<2) |
                    (Y_FLIP<<1) |
                    (NO_X_FLIP);

        CP_XY_DIR(ppdev, pjBase, jDir);

        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            SETUP_DRAW_LINE(pjBase,0,*pStrips,Y_MAJOR,cBpp);
            CP_DST_ADDR(ppdev, pjBase, ulDst);

            y -= *pStrips;
            x++;
            pStrips++;
        }
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_XY_DIR(ppdev, pjBase, 0);
}

/******************************Public*Routine******************************\
* VOID vrlSolidDiagonalHorizontalP
*
* Draws left-to-right x-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidDiagonalHorizontalP(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    i;
    LONG    xyOffset;
    ULONG   ulDst;

    DISPDBG((1,"vrlSolidDiagonalHorizontalP"));

    xyOffset = ppdev->xyOffset;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta - 1));

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        BYTE jDir = (0x80) |
                    (NO_Y_FLIP<<4) |
                    (X_MAJOR<<2) |
                    (NO_Y_FLIP<<1) |
                    (NO_X_FLIP);

        CP_XY_DIR(ppdev, pjBase, jDir);

        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            SETUP_DRAW_LINE(pjBase,*pStrips,*pStrips,X_MAJOR,cBpp);
            CP_DST_ADDR(ppdev, pjBase, ulDst);

            y += (*pStrips - 1);
            x += *pStrips;
            pStrips++;
        }
    }
    else
    {
        BYTE jDir = (0x80) |
                    (Y_FLIP<<4) |
                    (X_MAJOR<<2) |
                    (Y_FLIP<<1) |
                    (NO_X_FLIP);

        CP_XY_DIR(ppdev, pjBase, jDir);

        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            SETUP_DRAW_LINE(pjBase,*pStrips,*pStrips,X_MAJOR,cBpp);
            CP_DST_ADDR(ppdev, pjBase, ulDst);

            y -= (*pStrips - 1);
            x += *pStrips;
            pStrips++;
        }
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_XY_DIR(ppdev, pjBase, 0);
}

/******************************Public*Routine******************************\
* VOID vrlSolidDiagonalVerticalP
*
* Draws left-to-right y-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidDiagonalVerticalP(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    i;
    LONG    xyOffset;
    ULONG   ulDst;

    DISPDBG((1,"vrlSolidDiagonalVerticalP"));

    xyOffset = ppdev->xyOffset;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta - 1));

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        BYTE jDir = (0x80) |
                    (NO_Y_FLIP<<4) |
                    (Y_MAJOR<<2) |
                    (NO_Y_FLIP<<1) |
                    (NO_X_FLIP);

        CP_XY_DIR(ppdev, pjBase, jDir);

        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            SETUP_DRAW_LINE(pjBase,*pStrips,*pStrips,Y_MAJOR,cBpp);
            CP_DST_ADDR(ppdev, pjBase, ulDst);

            y += *pStrips;
            x += (*pStrips - 1);
            pStrips++;
        }
    }
    else
    {
        BYTE jDir = (0x80) |
                    (Y_FLIP<<4) |
                    (Y_MAJOR<<2) |
                    (Y_FLIP<<1) |
                    (NO_X_FLIP);

        CP_XY_DIR(ppdev, pjBase, jDir);

        for (i = 0; i < cStrips; i++)
        {
            ulDst = (y * lDelta) + (cBpp * x);
            ulDst += xyOffset;

            SETUP_DRAW_LINE(pjBase,*pStrips,*pStrips,Y_MAJOR,cBpp);
            CP_DST_ADDR(ppdev, pjBase, ulDst);

            y -= *pStrips;
            x += (*pStrips - 1);
            pStrips++;
        }
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_XY_DIR(ppdev, pjBase, 0);
}

//{------------------------------------------------------------------------
//}------------------------------------------------------------------------

/******************************Public*Routine******************************\
* VOID vStripStyledHorizontalP
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vStripStyledHorizontalP(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    DISPDBG((1,"vStripStyledHorizontalP"));
    return;
}

/******************************Public*Routine******************************\
* VOID vStripStyledVerticalP
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vStripStyledVerticalP(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    DISPDBG((1,"vStripStyledVerticalP"));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\i386\fasttext.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: fasttext.asm
;
; Copyright (c) 1992-1994 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; VOID vFastText(GLYPHPOS * pGlyphPos, ULONG ulGlyphCount, PBYTE pTempBuffer,
;                ULONG ulBufDelta, ULONG ulCharInc,
;                RECTL * prclText, RECTL * prclOpaque,
;                ULONG fDrawFlags, RECTL * prclClip,
;                RECTL * prclExtra);
; pGlyphPos -
; ulGlyphCount - # of glyphs to draw. Must never be 0.
; pTempBuffer -
; ulBufDelta -
; ulCharInc -
; prclText -
; prclOpaque -
; fDrawFlags -
; prclClip -     array of clipping rectangles
; prclExtra -    array of extra rectangles to fill in foreground color
;
; Draws glyphs into a 1bpp buffer using the CPU, so that the hardware
; can later colour-expand to the screen to draw text.
;
;-----------------------------------------------------------------------;
;
; Note: prclClip and prclExtra are null rectangle (yBottom=0) terminated
; arrays.
;
; Note: Assumes the text rectangle has a positive height and width. Will
; not work properly if this is not the case.
;
; Note: The opaquing rectangle is assumed to match the text bounding
; rectangle exactly; prclOpaque is used only to determine whether or
; not opaquing is required.
;
; Note: For maximum performance, we should not bother to draw fully-
; clipped characters to the temp buffer.
;
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc

        .list

;-----------------------------------------------------------------------;

        .data

;-----------------------------------------------------------------------;
; Tables used to branch into glyph-drawing optimizations.
;
; Handles narrow (1-4 bytes wide) glyph drawing, for case where initial byte
; should be MOVed even if it's not aligned (intended for use in drawing the
; first glyph in a string). Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
MovInitialTableNarrow   label   dword
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      mov_first_1_wide_rotated_need_last ;nonalign, 1 wide, need last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      mov_first_1_wide_rotated_no_last   ;nonalign, 1 wide, no last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      mov_first_2_wide_rotated_need_last ;nonalign, 2 wide, need last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      mov_first_2_wide_rotated_no_last   ;nonalign, 2 wide, no last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      mov_first_3_wide_rotated_need_last ;nonalign, 3 wide, need last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      mov_first_3_wide_rotated_no_last   ;nonalign, 3 wide, no last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      mov_first_4_wide_rotated_need_last ;nonalign, 4 wide, need last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide
        dd      mov_first_4_wide_rotated_no_last   ;nonalign, 4 wide, no last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide

; Handles narrow (1-4 bytes wide) glyph drawing, for case where initial byte
; ORed if it's not aligned (intended for use in drawing all but the first glyph
; in a string). Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrInitialTableNarrow    label   dword
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      or_first_1_wide_rotated_need_last  ;nonalign, 1 wide, need last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      or_first_1_wide_rotated_no_last    ;nonalign, 1 wide, no last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      or_first_2_wide_rotated_need_last  ;nonalign, 2 wide, need last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      or_first_2_wide_rotated_no_last    ;nonalign, 2 wide, no last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      or_first_3_wide_rotated_need_last  ;nonalign, 3 wide, need last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      or_first_3_wide_rotated_no_last    ;nonalign, 3 wide, no last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      or_first_4_wide_rotated_need_last  ;nonalign, 4 wide, need last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide
        dd      or_first_4_wide_rotated_no_last    ;nonalign, 4 wide, no last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide

; Handles narrow (1-4 bytes wide) glyph drawing, for case where all bytes
; should be ORed (intended for use in drawing potentially overlapping glyphs).
; Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrAllTableNarrow        label   dword
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      or_all_1_wide_rotated_need_last    ;nonalign, 1 wide, need last
        dd      or_all_1_wide_unrotated            ;aligned, 1 wide
        dd      or_all_1_wide_rotated_no_last      ;nonalign, 1 wide, no last
        dd      or_all_1_wide_unrotated            ;aligned, 1 wide
        dd      or_all_2_wide_rotated_need_last    ;nonalign, 2 wide, need last
        dd      or_all_2_wide_unrotated            ;aligned, 2 wide
        dd      or_all_2_wide_rotated_no_last      ;nonalign, 2 wide, no last
        dd      or_all_2_wide_unrotated            ;aligned, 2 wide
        dd      or_all_3_wide_rotated_need_last    ;nonalign, 3 wide, need last
        dd      or_all_3_wide_unrotated            ;aligned, 3 wide
        dd      or_all_3_wide_rotated_no_last      ;nonalign, 3 wide, no last
        dd      or_all_3_wide_unrotated            ;aligned, 3 wide
        dd      or_all_4_wide_rotated_need_last    ;nonalign, 4 wide, need last
        dd      or_all_4_wide_unrotated            ;aligned, 4 wide
        dd      or_all_4_wide_rotated_no_last      ;nonalign, 4 wide, no last
        dd      or_all_4_wide_unrotated            ;aligned, 4 wide

; Handles arbitrarily wide glyph drawing, for case where initial byte should be
; MOVed even if it's not aligned (intended for use in drawing the first glyph
; in a string). Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
MovInitialTableWide     label   dword
        dd      mov_first_N_wide_rotated_need_last      ;nonalign, need last
        dd      mov_first_N_wide_unrotated              ;aligned
        dd      mov_first_N_wide_rotated_no_last        ;nonalign, no last
        dd      mov_first_N_wide_unrotated              ;aligned

; Handles arbitrarily wide glyph drawing, for case where initial byte should be
; ORed if it's not aligned (intended for use in drawing all but the first glyph
; in a string). Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrInitialTableWide      label   dword
        dd      or_first_N_wide_rotated_need_last       ;nonalign, need last
        dd      mov_first_N_wide_unrotated              ;aligned
        dd      or_first_N_wide_rotated_no_last         ;nonalign, no last
        dd      mov_first_N_wide_unrotated              ;aligned

; Handles arbitrarily wide glyph drawing, for case where all bytes should
; be ORed (intended for use in drawing potentially overlapping glyphs).
; Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrAllTableWide  label   dword
        dd      or_all_N_wide_rotated_need_last ;nonalign, need last
        dd      or_all_N_wide_unrotated         ;aligned
        dd      or_all_N_wide_rotated_no_last   ;nonalign, no last
        dd      or_all_N_wide_unrotated         ;aligned

; Vectors to entry points for drawing various types of text. '*' means works as
; is but could be acclerated with a custom scanning loop.
        align   4
MasterTextTypeTable     label   dword       ;tops aligned  overlap  fixed pitch
        dd      draw_nf_ntb_o_to_temp_start ;      N          N          N *
        dd      draw_f_ntb_o_to_temp_start  ;      N          N          Y *
        dd      draw_nf_ntb_o_to_temp_start ;      N          Y          N
        dd      draw_f_ntb_o_to_temp_start  ;      N          Y          Y
        dd      draw_nf_tb_no_to_temp_start ;      Y          N          N
        dd      draw_f_tb_no_to_temp_start  ;      Y          N          Y
        dd      draw_nf_ntb_o_to_temp_start ;      Y          Y          N *
        dd      draw_f_ntb_o_to_temp_start  ;      Y          Y          Y *

;-----------------------------------------------------------------------;

                .code

_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;-----------------------------------------------------------------------;

cProc vFastText,40,<\
 uses esi edi ebx,\
 pGlyphPos:ptr,\
 ulGlyphCount:dword,\
 pTempBuffer:ptr,\
 ulBufDelta:dword,\
 ulCharInc:dword,\
 prclText:ptr,\
 prclOpaque:ptr,\
 fDrawFlags:dword,\
 prclClip:dword,\
 prclExtra:dword>

        local ulGlyDelta:dword  ;width per scan of source glyph, in bytes
        local ulWidthInBytes:dword ;width of glyph, in bytes
        local ulTmpWidthInBytes:dword ;working byte-width count
        local ulGlyphX:dword    ;for fixed-pitch text, maintains the current
                                ; glyph's left-edge X coordinate
        local pGlyphLoop:dword  ;pointer to glyph-processing loop
        local ulTempLeft:dword  ;X coordinate on screen of left edge of temp
                                ; buffer
        local ulTempTop:dword   ;Y coordinate on screen of top edge of temp
                                ; buffer
        local ulTmpSrcDelta:dword ;distance from end of one buffer text scan to
                                  ; start of next
        local ulTmpDstDelta:dword ;distance from end of one screen text scan to
                                  ; start of next
        local ulYOrigin:dword   ;Y origin of text in string (all glyphs are at
                                ; the same Y origin)
        local rclClippedBounds[16]:byte ;clipped destination rectangle;
                                        ; defined as "byte" due to assembler
                                        ; limitations

        local pTempBufferSaved:dword

;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Draws either a fixed or a non-fixed-pitch string to the temporary
; buffer. Assumes this is a horizontal string, so the origins of all glyphs
; are at the same Y coordinate. Draws leftmost glyph entirely with MOVs,
; even if it's not aligned, in order to ensure that the leftmost byte
; gets cleared when we're working with butted characters. For other
; non-aligned glyphs, leftmost byte is ORed, other bytes are MOVed.
;
; Input:
;       pGlyphPos = pointer to array of GLYPHPOS structures to draw
;       ulGlyphCount = # of glyphs to draw
;       ulTempLeft = X coordinate on dest of left edge of temp buffer pointed
;               to by pTempBuffer
;       pTempBuffer = pointer to first byte (upper left corner) of
;               temp buffer into which we're drawing. This should be
;               dword-aligned with the destination
;       ulBufDelta = destination scan-to-scan offset
;       ulCharInc = offset from one glyph to next (fixed-pitch only)
;       fDrawFlags = indicate the type of text to be drawn
;       Temp buffer zeroed if text doesn't cover every single pixel
;
; Fixed-pitch means equal spacing between glyph positions, not that all
; glyphs butt together or equal spacing between upper left corners.
;-----------------------------------------------------------------------;

        mov     ebx,prclText
        mov     eax,[ebx].yTop
        mov     ulTempTop,eax   ;Y screen coordinate of top edge of temp buf
        mov     eax,[ebx].xLeft
        mov     ulTempLeft,eax  ;X screen coordinate of left edge of temp buf

        mov     eax,fDrawFlags

        jmp     MasterTextTypeTable[eax*4]

;-----------------------------------------------------------------------;
; Entry point for fixed-pitch | tops and bottoms aligned | no overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_f_tb_no_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,[ebx].gp_x          ;dest X coordinate
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer (we assume the text is
                                        ; right at the top of the text rect
                                        ; and hence the buffer)
        mov     ulGlyphX,edi            ;remember where this glyph started
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        mov     pGlyphLoop,offset draw_f_tb_no_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        jmp     short draw_to_temp_start_entry

;-----------------------------------------------------------------------;
; Entry point for non-fixed-pitch | tops and bottoms aligned | no overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_nf_tb_no_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,[ebx].gp_x          ;dest X coordinate
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        mov     pGlyphLoop,offset draw_nf_tb_no_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
draw_to_temp_start_entry::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        add     edi,pTempBuffer         ;initial dest byte in temp buffer

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes per scan

        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     MovInitialTableNarrow[eax*4]
                                        ;branch to draw the first glyph; never
                                        ; need to OR first glyph, because
                                        ; there's nothing there yet

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     MovInitialTableWide[eax*4]
                                        ;branch to draw the first glyph; never
                                        ; need to OR first glyph, because
                                        ; there's nothing there yet

;-----------------------------------------------------------------------;
; Entry point for fixed-pitch | tops and bottoms not aligned | overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_f_ntb_o_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     pGlyphLoop,offset draw_f_ntb_o_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     ulGlyphX,edi            ;remember where this glyph started
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        jmp     short draw_to_temp_start_entry2

;-----------------------------------------------------------------------;
; Entry point for non-fixed-pitch | tops and bottoms not aligned | overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_nf_ntb_o_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     pGlyphLoop,offset draw_nf_ntb_o_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
draw_to_temp_start_entry2::
        mov     eax,[ebx].gp_y          ;dest origin Y coordinate
        sub     eax,ulTempTop           ;coord of glyph origin in temp buffer
        mov     ulYOrigin,eax           ;remember the Y origin of all glyphs
                                        ; (necessary because glyph positions
                                        ; after first aren't set for fixed-
                                        ; pitch strings)
        add     eax,[esi].gb_y          ;adjust to position of upper left glyph
                                        ; corner in dest
        mul     ulBufDelta              ;offset in buffer of top glyph scan
        add     eax,pTempBuffer         ;initial dest byte
        add     edi,eax

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes per scan

        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableNarrow[eax*4] ;branch to draw the first glyph; OR all
                                        ; glyphs, because text may overlap

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableWide[eax*4]   ;branch to draw the first glyph; OR all
                                        ; glyphs, because text may overlap

;-----------------------------------------------------------------------;
; Loop to draw all fixed-pitch | tops and bottoms aligned | no overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_f_tb_no_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one
        mov     pGlyphPos,ebx           ; we're going to draw this time)
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,ulGlyphX            ;last glyph's dest X start in temp buf
        add     edi,ulCharInc           ;this glyph's dest X start in temp buf
        mov     ulGlyphX,edi            ;remember for next glyph
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        jmp     short draw_to_temp_loop_entry

;-----------------------------------------------------------------------;
; Loop to draw all non-fixed-pitch | tops and bottoms aligned | no overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_nf_tb_no_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        sub     edi,ulTempLeft          ;adjust relative to the left edge of
                                        ; the temp buffer

draw_to_temp_loop_entry::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi                 ;pixel X coordinate in temp buffer
        shr     edi,3                   ;byte offset of first column = dest
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        add     edi,pTempBuffer         ;initial dest byte

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes to copy to per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes to copy from per
                                        ; scan
        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrInitialTableNarrow[eax*4] ;branch to draw the first glyph;
                                            ; need to OR the 1st byte if
                                            ; non-aligned to avoid overwriting
                                            ; what's already there
@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrInitialTableWide[eax*4] ;branch to draw the next glyph;
                                          ; need to OR the 1st byte if
                                          ; non-aligned to avoid overwriting
                                          ; what's already there

;-----------------------------------------------------------------------;
; Loop to draw all fixed-pitch | tops and bottoms not aligned | overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_f_ntb_o_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)

        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,ulGlyphX            ;last glyph's dest X start in temp buf
        add     edi,ulCharInc           ;this glyph's dest X start in temp buf
        mov     ulGlyphX,edi            ;remember for next glyph
        mov     esi,[esi].gdf_pgb       ;point to glyph bits

        mov     eax,ulYOrigin           ;dest Y coordinate
        jmp     short draw_to_temp_loop_entry2

;-----------------------------------------------------------------------;
; Loop to draw all non-fixed-pitch | tops and bottoms not aligned | overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_nf_ntb_o_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)

        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        sub     edi,ulTempLeft          ;adjust relative to the left edge of
                                        ; the temp buffer
        mov     eax,[ebx].gp_y          ;dest origin Y coordinate
        sub     eax,ulTempTop           ;coord of glyph origin in temp buffer
draw_to_temp_loop_entry2::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi                 ;pixel X coordinate in temp buffer
        shr     edi,3                   ;byte offset of first column = dest
                                        ; offset of upper left of glyph in temp
                                        ; buffer

        add     eax,[esi].gb_y          ;adjust to position of upper left glyph
                                        ; corner in dest
        mul     ulBufDelta              ;offset in buffer of top glyph scan
        add     eax,pTempBuffer         ;initial dest byte
        add     edi,eax

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes to copy to per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes to copy from per
                                        ; scan
        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableNarrow[eax*4] ;branch to draw the next glyph

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableWide[eax*4]   ;branch to draw the next glyph

;-----------------------------------------------------------------------;
; Routines to draw all scans of a single glyph into the temp buffer,
; optimized for the following cases:
;
;       1 to 4 byte-wide destination rectangles for each of:
;               No rotation needed
;               Rotation needed, same # of source as dest bytes needed
;               Rotation needed, one less source than dest bytes needed
;
; Additionally, the three cases are handled for 5 and wider cases by a
; general routine for each case.
;
; If rotation is needed, there are three sorts of routines:
;
; 1) The leftmost byte is MOVed, to initialize the byte. Succeeding bytes are
;    MOVed. This is generally used for the leftmost glyph of a string.
; 2) The leftmost byte is ORed into the existing byte. Succeeding bytes are
;    MOVed. This is generally used after the leftmost glyph, because this may
;    not be the first data written to that byte.
; 3) All bytes are ORed. This is for drawing when characters might overlap.
;
; If rotation is not needed, there are two sorts of routines:
;
; 1) The leftmost byte is MOVed, to initialize the byte. Succeeding bytes are
;    MOVed. This is generally used for the leftmost glyph of a string.
; 2) All bytes are ORed. This is for drawing when characters might overlap.
;
; On entry:
;       EBX = # of scans to copy
;       CL  = right rotation
;       EDX = ulBufDelta = width per scan of destination buffer, in bytes
;       ESI = pointer to first glyph byte
;       EDI = pointer to first dest buffer byte
;       DF  = cleared
;       ulGlyDelta = width per scan of source glyph, in bytes (wide case only)
;       ulWidthInBytes = width of glyph, in bytes (required only for 5 and
;               wider cases)
;
; On exit:
;       Any or all of EAX, EBX, ECX, EDX, ESI, and EDI may be trashed.

;-----------------------------------------------------------------------;
; OR first byte, 1 byte wide dest, rotated.
;-----------------------------------------------------------------------;
or_all_1_wide_rotated_need_last::
or_all_1_wide_rotated_no_last::
or_first_1_wide_rotated_need_last::
or_first_1_wide_rotated_no_last::
or_first_1_wide_rotated_loop::
        mov     ch,[esi]
        inc     esi
        shr     ch,cl
        or      [edi],ch
        add     edi,edx
        dec     ebx
        jnz     or_first_1_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 1 byte wide dest, rotated.
;-----------------------------------------------------------------------;
mov_first_1_wide_rotated_need_last::
mov_first_1_wide_rotated_no_last::
mov_first_1_wide_rotated_loop::
        mov     ch,[esi]
        inc     esi
        shr     ch,cl
        mov     [edi],ch
        add     edi,edx
        dec     ebx
        jnz     mov_first_1_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 1 byte wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_1_wide_unrotated::
mov_first_1_wide_unrotated_loop::
        mov     al,[esi]
        inc     esi
        mov     [edi],al
        add     edi,edx
        dec     ebx
        jnz     mov_first_1_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 1 byte wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_1_wide_unrotated::
or_all_1_wide_unrotated_loop::
        mov     al,[esi]
        inc     esi
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     or_all_1_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_2_wide_rotated_need_last::
or_first_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        or      [edi],al
        mov     [edi+1],ah
        add     edi,edx
        dec     ebx
        jnz     or_first_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_2_wide_rotated_need_last::
or_all_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_2_wide_rotated_need_last::
mov_first_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_2_wide_rotated_no_last::
or_first_2_wide_rotated_loop::
        sub     eax,eax
        mov     ah,[esi]
        inc     esi
        shr     eax,cl
        or      [edi],ah
        mov     [edi+1],al
        add     edi,edx
        dec     ebx
        jnz     or_first_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_2_wide_rotated_no_last::
or_all_2_wide_rotated_loop::
        sub     eax,eax
        mov     al,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_2_wide_rotated_no_last::
mov_first_2_wide_rotated_loop::
        sub     eax,eax
        mov     al,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_2_wide_unrotated::
mov_first_2_wide_unrotated_loop::
        mov     ax,[esi]
        add     esi,2
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_2_wide_unrotated::
or_all_2_wide_unrotated_loop::
        mov     ax,[esi]
        add     esi,2
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        or      [edi],al
        mov     ax,[esi]
        ror     ax,cl
        mov     [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        mov     [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        or      [edi],al
        mov     ax,[esi]
        ror     ax,cl
        or      [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        or      [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        mov     [edi],al
        mov     ax,[esi]
        ror     ax,cl
        mov     [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        mov     [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        mov     [edi+1],ah
        mov     [edi+2],al
        shr     eax,16
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        xchg    ah,al
        or      [edi+1],ax
        shr     eax,16
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        mov     [edi+1],ah
        mov     [edi+2],al
        shr     eax,16
        mov     [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_3_wide_unrotated::
@@:
        mov     ax,[esi]
        mov     [edi],ax
        mov     al,[esi+2]
        add     esi,3
        mov     [edi+2],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 3 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_3_wide_unrotated::
@@:
        mov     ax,[esi]
        or      [edi],ax
        mov     al,[esi+2]
        add     esi,3
        or      [edi+2],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        mov     [edi+2],ax
        shr     eax,16
        mov     [edi+1],al
        or      [edi],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    al,ah
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        mov     [edi+2],ax
        shr     eax,16
        mov     [edi+1],al
        or      [edi],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_4_wide_unrotated::
@@:
        mov     eax,[esi]
        add     esi,4
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_4_wide_unrotated::
@@:
        mov     eax,[esi]
        add     esi,4
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
ofNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     ofNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
oaNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     oaNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        mov     eax,ulWidthInBytes
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
mfNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial byte separately
        shr     al,cl
        mov     [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     mfNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
ofNwr_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        mov     [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     ofNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
oaNwr_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        or      [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     oaNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
mfNwr_scan_loop:
        mov     al,[esi]        ;do the initial byte separately
        shr     al,cl
        mov     [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        mov     [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     mfNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, N bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_N_wide_unrotated::
        mov     edx,ulBufDelta
        mov     eax,ulWidthInBytes
        sub     edx,eax
        shr     eax,1           ;width in words
        jc      short odd_width ;there's at least one odd byte
        shr     eax,1           ;width in dwords
        jc      short two_odd_bytes ;there's an odd word
                                ;copy width is a dword multiple
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

odd_width::
        shr     eax,1           ;width in dwords
        jc      short three_odd_bytes ;there's an odd word and an odd byte
                                ;there's just an odd byte
        inc     edx             ;because we won't advance after last byte
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cl,[esi]
        inc     esi
        mov     [edi],cl
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

two_odd_bytes::
        add     edx,2           ;because we won't advance after last word
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cx,[esi]
        add     esi,2
        mov     [edi],cx
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

three_odd_bytes::
        add     edx,3           ;because we won't advance after last word/byte
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cx,[esi]
        mov     [edi],cx
        mov     cl,[esi+2]
        add     esi,3
        mov     [edi+2],cl
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, N bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_N_wide_unrotated::
        mov     edx,ulBufDelta
        mov     eax,ulWidthInBytes
        sub     edx,eax
        shr     eax,1           ;width in words
        jc      short or_odd_width ;there's at least one odd byte
        shr     eax,1           ;width in dwords
        jc      short or_two_odd_bytes ;there's an odd word
                                ;copy width is a dword multiple
or_no_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_no_odd_bytes_loop
        jmp     pGlyphLoop

or_odd_width::
        shr     eax,1           ;width in dwords
        jc      short or_three_odd_bytes ;there's an odd word and an odd byte
                                ;there's just an odd byte
        inc     edx             ;skip over last byte too
or_one_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cl,[esi]
        or      [edi],cl
        inc     esi
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_one_odd_bytes_loop
        jmp     pGlyphLoop

or_two_odd_bytes::
        add     edx,2           ;skip over last 2 bytes too
or_two_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cx,[esi]
        or      [edi],cx
        add     esi,2
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_two_odd_bytes_loop
        jmp     pGlyphLoop

or_three_odd_bytes::
        add     edx,3           ;skip over last 3 bytes too
or_three_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cx,[esi]
        or      [edi],cx
        mov     cl,[esi+2]
        or      [edi+2],cl
        add     esi,3
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_three_odd_bytes_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; At this point, the text is drawn to the temp buffer.
; Now, draw the extra rectangles to the temp buffer.
;
; Input:
;       prclText = pointer to text bounding rectangle
;       prclOpaque = pointer to opaquing rectangle, if there is one
;       ulTempLeft = X coordinate on dest of left edge of temp buffer pointed
;               to by pTempBuffer
;       pTempBuffer = pointer to first byte (upper left corner) of
;               temp buffer into which we're drawing. This should be
;               dword-aligned with the destination
;       ulBufDelta = destination scan-to-scan offset
;       Text drawn to temp buffer
;
;-----------------------------------------------------------------------;
glyphs_are_done::
        mov     esi,prclExtra
        test    esi,esi                         ;is prclExtra NULL?
        jz      extra_rects_are_done            ;yes

        ; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        ; !!! Should handle prclExtra here and set GCAPS_HORIZSTRIKE !!!
        ; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

;-----------------------------------------------------------------------;
; At this point, the text is drawn to the temp buffer, and any extra
; rectangles (underline, strikeout) are drawn to the temp buffer.
; Now, draw the temp buffer to the screen.
;
; Input:
;       prclText = pointer to text bounding rectangle
;       prclOpaque = pointer to opaquing rectangle, if there is one
;       ulTempLeft = X coordinate on dest of left edge of temp buffer pointed
;               to by pTempBuffer
;       pTempBuffer = pointer to first byte (upper left corner) of
;               temp buffer into which we're drawing. This should be
;               dword-aligned with the destination
;       ulBufDelta = destination scan-to-scan offset
;       Text drawn to temp buffer
;
;-----------------------------------------------------------------------;
extra_rects_are_done::

;-----------------------------------------------------------------------;
; Clip to the clip rectangle, if necessary.
;-----------------------------------------------------------------------;

        mov     esi,prclText
        mov     edi,prclClip
        test    edi,edi                 ;is there clipping?
        jz      exit_fast_text          ;no

        mov     ebx,pTempBuffer
        mov     pTempBufferSaved,ebx
        jmp     short do_opaque_clip

;-----------------------------------------------------------------------;
; Handle rectangle clipping.
;-----------------------------------------------------------------------;

get_next_clip_rect::
        mov     esi,prclText
        mov     edi,prclClip            ;make sure edi has prclClip
        test    edi,edi                 ;was this null?
        jz      exit_fast_text          ;yep
        add     edi,size RECTL          ;no, next rect
        mov     prclClip,edi            ;don't forget the increment

        mov     ebx,pTempBufferSaved
        mov     pTempBuffer,ebx

do_opaque_clip::
        mov     ebx,[edi].yBottom
        test    ebx,ebx                 ;is it a null rectangle?
        jz      exit_fast_text          ;yes

        mov     ebx,[esi].yBottom
        cmp     [edi].yBottom,ebx ;is the bottom edge of the text box clipped?
        jg      short @F          ;no
        mov     ebx,[edi].yBottom ;yes
@@:
        mov     dword ptr rclClippedBounds.yBottom,ebx ;set the (possibly
                                                       ; clipped) bottom edge
        mov     eax,[esi].yTop
        cmp     [edi].yTop,eax  ;is the top edge of the text box clipped?
        jle     short @F        ;no
                                ;yes
        sub     eax,[edi].yTop
        neg     eax             ;# of scans we just clipped off
        mul     ulBufDelta      ;# of bytes by which to advance through source
        add     pTempBuffer,eax ;advance in source to account for Y clipping
        mov     eax,[edi].yTop  ;new top edge
@@:
        mov     dword ptr rclClippedBounds.yTop,eax ;set the (possibly clipped)
                                                    ; top edge
        cmp     eax,ebx         ;is there a gap between clipped top & bottom?
        jnl     get_next_clip_rect ;no, fully clipped

        mov     edx,[esi].xRight
        cmp     [edi].xRight,edx ;is the right edge of the text box clipped?
        jg      short @F         ;no
        mov     edx,[edi].xRight ;yes
@@:
        mov     dword ptr rclClippedBounds.xRight,edx ;set the (possibly
                                                      ; clipped) right edge
        mov     eax,[esi].xLeft
        cmp     [edi].xLeft,eax ;is the left edge of the text box clipped?
        jle     short @F        ;no
                                ;yes
        mov     ebx,[edi].xLeft ;EBX = new left edge
        and     eax,not 0111b   ;floor the old left edge in its byte
        sub     ebx,eax
        shr     ebx,3           ;# of bytes to advance in source
        add     pTempBuffer,ebx ;advance in source to account for X clipping
        mov     eax,[edi].xLeft ;new left edge
@@:
        mov     dword ptr rclClippedBounds.xLeft,eax ;set the (possibly
                                                     ; clipped) left edge
        cmp     eax,edx         ;is there a gap between clipped left & right?
        jnl     get_next_clip_rect ;no, fully clipped

        lea     esi,rclClippedBounds ;this is now the destination rect

;-----------------------------------------------------------------------;
; ESI->destination text rectangle at this point
;-----------------------------------------------------------------------;
exit_fast_text::

        cRet    vFastText

endProc vFastText

;-----------------------------------------------------------------------;
; VOID vClearMemDword(ULONG * pulBuffer, ULONG ulDwordCount);
;
; Clears ulCount dwords starting at pjBuffer.
;-----------------------------------------------------------------------;

pulBuffer    equ [esp+8]
ulDwordCount equ [esp+12]

cProc vClearMemDword,8,<>

        push    edi
        mov     edi,pulBuffer
        mov     ecx,ulDwordCount
        sub     eax,eax
        rep     stosd
        pop     edi

        cRet  vClearMemDword

endProc vClearMemDword

public draw_f_tb_no_to_temp_start
public draw_nf_tb_no_to_temp_start
public draw_to_temp_start_entry
public draw_f_ntb_o_to_temp_start
public draw_nf_ntb_o_to_temp_start
public draw_to_temp_start_entry2
public draw_f_tb_no_to_temp_loop
public draw_nf_tb_no_to_temp_loop
public draw_to_temp_loop_entry
public draw_f_ntb_o_to_temp_loop
public draw_nf_ntb_o_to_temp_loop
public draw_to_temp_loop_entry2
public or_all_1_wide_rotated_need_last
public or_all_1_wide_rotated_no_last
public or_first_1_wide_rotated_need_last
public or_first_1_wide_rotated_no_last
public or_first_1_wide_rotated_loop
public mov_first_1_wide_rotated_need_last
public mov_first_1_wide_rotated_no_last
public mov_first_1_wide_rotated_loop
public mov_first_1_wide_unrotated
public mov_first_1_wide_unrotated_loop
public or_all_1_wide_unrotated
public or_all_1_wide_unrotated_loop
public or_first_2_wide_rotated_need_last
public or_first_2_wide_rotated_need_loop
public or_all_2_wide_rotated_need_last
public or_all_2_wide_rotated_need_loop
public mov_first_2_wide_rotated_need_last
public mov_first_2_wide_rotated_need_loop
public or_first_2_wide_rotated_no_last
public or_first_2_wide_rotated_loop
public or_all_2_wide_rotated_no_last
public or_all_2_wide_rotated_loop
public mov_first_2_wide_rotated_no_last
public mov_first_2_wide_rotated_loop
public mov_first_2_wide_unrotated
public mov_first_2_wide_unrotated_loop
public or_all_2_wide_unrotated
public or_all_2_wide_unrotated_loop
public or_first_3_wide_rotated_need_last
public or_all_3_wide_rotated_need_last
public mov_first_3_wide_rotated_need_last
public or_first_3_wide_rotated_no_last
public or_all_3_wide_rotated_no_last
public mov_first_3_wide_rotated_no_last
public mov_first_3_wide_unrotated
public or_all_3_wide_unrotated
public or_first_4_wide_rotated_need_last
public or_all_4_wide_rotated_need_last
public mov_first_4_wide_rotated_need_last
public or_first_4_wide_rotated_no_last
public or_all_4_wide_rotated_no_last
public mov_first_4_wide_rotated_no_last
public mov_first_4_wide_unrotated
public or_all_4_wide_unrotated
public or_first_N_wide_rotated_need_last
public or_all_N_wide_rotated_need_last
public mov_first_N_wide_rotated_need_last
public or_first_N_wide_rotated_no_last
public or_all_N_wide_rotated_no_last
public mov_first_N_wide_rotated_no_last
public mov_first_N_wide_unrotated
public odd_width
public two_odd_bytes
public three_odd_bytes
public or_all_N_wide_unrotated
public or_no_odd_bytes_loop
public or_odd_width
public or_one_odd_bytes_loop
public or_two_odd_bytes
public or_two_odd_bytes_loop
public or_three_odd_bytes
public or_three_odd_bytes_loop
public glyphs_are_done
public extra_rects_are_done
public get_next_clip_rect
public do_opaque_clip

_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\i386\str.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: str.asm
;
; Contains the x86 'Asm' versions of some inner-loop routines for the
; partially hardware accelerated StretchBlt.
;
; Copyright (c) 1994-1995 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\hw.inc
        .list

        .data

;
;  stack based params and local variables
;

STACK_STRUC             struc

; Feel free to add any local variables here:

sp_TempXFrac            dd      ?
sp_YCarry               dd      ?
sp_LeftCase             dd      ?
sp_RightCase            dd      ?
sp_pjSrcScan            dd      ?
sp_SrcIntStep           dd      ?
sp_DstStride            dd      ?
sp_XCntHW               dd      ?
sp_XCount               dd      ?
sp_xyOFfset             dd      ?
sp_isNonW32P            dd      ?
sp_yDst                 dd      ?
sp_pjBase               dd      ?
sp_pMmu2                dd      ?   ; pointer to the aperture
sp_pdev                 dd      ?
sp_ulSrcAddr            dd      ?   ; Src Address for accelerator

; Don't add any fields below here without modifying PROC_MEM_SIZE!

sp_ebp                  dd      ?
sp_esi                  dd      ?
sp_edi                  dd      ?
sp_ebx                  dd      ?
sp_RetAddr              dd      ?
sp_pSTR_BLT             dd      ?   ; If adding parameters, adjust 'ret' value!
STACK_STRUC             ends

PROC_MEM_SIZE           equ     6 * 4

;
; Make sure this STR_BLT matches that declared in driver.h!
;

STR_BLT                 struc
str_ppdev               dd      ?
str_pjSrcScan           dd      ?
str_lDeltaSrc           dd      ?
str_XSrcStart           dd      ?
str_pjDstScan           dd      ?
str_lDeltaDst           dd      ?
str_XDstStart           dd      ?
str_XDstEnd             dd      ?
str_YDstStart           dd      ?
str_YDstCount           dd      ?
str_ulXDstToSrcIntCeil  dd      ?
str_ulXDstToSrcFracCeil dd      ?
str_ulYDstToSrcIntCeil  dd      ?
str_ulYDstToSrcFracCeil dd      ?
str_ulXFracAccumulator  dd      ?
str_ulYFracAccumulator  dd      ?
STR_BLT                 ends

        .code

;---------------------------Public-Routine------------------------------;
; VOID vDirectStretch8(pStrBlt)
;
; NOTE: This routine doesn't handle cases where the blt stretch starts
;       and ends in the same destination dword!  vDirectStretchNarrow
;       is expected to have been called for that case.
;
; Stretch blt 8 -> 8
;-----------------------------------------------------------------------;

        public vDirectStretch8@4

vDirectStretch8@4 proc near
        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size STACK_STRUC) - PROC_MEM_SIZE  ; make room for local variables

        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

        ;
        ; load up some stack-based parameters to be used by our scan
        ; duplicator when doing vertical stretches
        ;

        mov     eax,[ebp].str_ppdev
        mov     ecx,[ebp].str_YDstStart                 ; get start y coordinate
        mov     [esp].sp_pdev,eax                       ; save ppdev pointer

        mov     ebx,[eax].pdev_xyOffset
        mov     [esp].sp_xyOffset,ebx                   ; save xyOffset
        mov     ebx,[eax].pdev_ulChipID
        cmp     ebx, ET6000
        jne     @F
        mov     [esp].sp_isNonW32P, 0
        jmp     GotET6K
@@:
        xor     ebx,W32P
        mov     [esp].sp_isNonW32P,ebx                  ; save ChipID
GotET6K:
        mov     ebx,[eax].pdev_pjMmu2
        mov     [esp].sp_pMmu2,ebx                      ; save mmu2 addr
        mov     eax,[eax].pdev_pjBase
        mov     [esp].sp_pjBase,eax                     ; save pjBase pointer

        mov     [esp].sp_yDst,ecx                       ; save current y coordinate

        ;
        ; calc starting addressing parameters
        ;

        mov     esi,[ebp].str_pjSrcScan                 ; load src DIB pointer
        add     esi,[ebp].str_XSrcStart                 ; add starting Src Pixel
        mov     edi,[ebp].str_pjDstScan                 ; load dst DIB pointer
        add     edi,[ebp].str_XDstStart                 ; add strarting Dst Pixel
        mov     [esp].sp_pjSrcScan,esi                  ; save scan line start pointer
        mov     eax,[ebp].str_ulYDstToSrcIntCeil        ; number of src scan lines to step
        mul     [ebp].str_lDeltaSrc                     ; calc scan line int lines to step
        mov     [esp].sp_SrcIntStep,eax                 ; save int portion of Y src step
        mov     edx,4                                   ; calc left bytes = (4 - LeftCase) & 0x03
        sub     edx,edi
        and     edx,3                                   ; left edge bytes
        mov     [esp].sp_LeftCase,edx                   ; save left edge case pixels (4-LeftCase)&0x03
        mov     eax,[ebp].str_pjDstScan                 ; make copy
        mov     ecx,[ebp].str_XDstEnd                   ; load x end
        add     eax,ecx                                 ; ending dst addr
        and     eax,3                                   ; calc right edge case
        mov     [esp].sp_RightCase,eax                  ; save right edge case
        sub     ecx,[ebp].str_XDstStart                 ; calc x count

        dec     ecx
        mov     [esp].sp_XCntHW,ecx                     ; x width for accelerator
        inc     ecx

        mov     ebx,[ebp].str_lDeltaDst                 ; dst scan line stride
        sub     ebx,ecx                                 ; distance from end of one line to start of next
        mov     [esp].sp_DstStride,ebx                  ; save dst scan line stride
        sub     ecx,eax                                 ; sub right edge from XCount
        sub     ecx,edx                                 ; sub left edge from XCount
        shr     ecx,2                                   ; convert from byte to DWORD count
        mov     [esp].sp_XCount,ecx                     ; save DWORD count
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get x frac
        mov     [esp].sp_TempXFrac,ebx                  ; save x frac to a esp based location

        ;
        ; Pre-calculate the Accelerator Source Address.
        ; We'll always derive the dst from the src.
        ;

        mov     ebx, [esp].sp_yDst                      ; ebx <- yDst
        imul    ebx, [ebp].str_lDeltaDst
        add     ebx, [esp].sp_xyOffset
        add     ebx, [ebp].str_xDstStart
        sub     ebx, [ebp].str_lDeltaDst
        mov     [esp].sp_ulSrcAddr, ebx

        ;
        ; Set up edx to access accelerator registers
        ;

        mov     edx,[esp].sp_pjBase

        ;
        ; Wait until the accelerator will accept commands into the queue
        ;


@@:     mov     al,[edx+OFFSET_jAclStatus]
        test    eax,1
        jnz     short @b

        ;
        ; Set up the accelerator with constant data
        ;

        mov     ebx,[esp].sp_XCntHW

        ; Do I need this?  What is RECT_HEIGHT, and why do I
        ; care if it is not zero?

        .errnz  RECT_HEIGHT

        mov     [edx+OFFSET_wXCnt],bx
        mov     word ptr [edx+OFFSET_wYCnt], 0


NextScan:

        ;
        ; esi and edi are assumed to be correctly loaded
        ;

        mov     eax,[ebp].str_ulXDstToSrcIntCeil        ; get src integer step for step in dst
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get src frac step for step in dst
        mov     edx,[ebp].str_ulXFracAccumulator        ; put it in edx as tmp

        mov     ebp,edi                                 ; get dst pointer to ebp

        ;
        ; Can't directly access pSTR_BLT variables through ebp
        ;

        mov     edi,edx                                 ; get accumulator where we want it
        mov     ecx,[esp].sp_LeftCase

        ; eax = integer step in source
        ; ebx = fractional step in source
        ; ecx = left edge case
        ; edx = free for pixel data
        ; esi = pointer to source pixel
        ; edi = fractional accumulator
        ; ebp = pointer to dest pixel

        ;
        ; first do the left side to align dwords
        ;

        test    ecx,ecx
        jz      DwordAligned

@@:
        mov     dl,[esi]                                ; fetch pixel
        mov     [ebp],dl                                ; write it out
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add in integer and possible carry
        inc     ebp                                     ; step 1 in dest
        dec     ecx                                     ; dec left count
        jne     @B                                      ; repeat until done

DwordAligned:

        mov     ecx,[esp].sp_XCount                     ; get run length

@@:
        mov     dl,[esi]                                ; get a source pixel edx = ???0
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add integer and carry

        add     edi,ebx                                 ; step fraction
        mov     dh,[esi]                                ; get source pixel edx = ??10
        adc     esi,eax                                 ; add integer and carry

        shl     edx,16                                  ; edx = 10??

        add     edi,ebx                                 ; step fraction
        mov     dl,[esi]                                ; get a source pixel edx = 10?2
        adc     esi,eax                                 ; add integer and carry

        add     edi,ebx                                 ; step fraction
        mov     dh,[esi]                                ; get source pixel edx = 0132
        adc     esi,eax                                 ; add integer and carry

        ror     edx,16                                  ; edx = 3210

        mov     [ebp],edx                               ; write everything to dest

        add     ebp,4                                   ; increment dest pointer by 1 dword
        dec     ecx                                     ; decrement count
        jnz     @b                                      ; do more pixels

        ;
        ; now do the right side trailing bytes
        ;

        mov     ecx,[esp].sp_RightCase
        test    ecx,ecx
        jz      EndScanLine

@@:

        mov     dl,[esi]                                ; fetch pixel
        mov     [ebp],dl                                ; write it out
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add in integer and possible carry
        inc     ebp                                     ; step 1 in dest
        dec     ecx                                     ; dec right count
        jnz     @b                                      ; repeat until done

EndScanLine:

        mov     edi,ebp                                 ; get dst pointer back
        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

EndSkipScan:

        mov     esi,[esp].sp_pjSrcScan                  ; load src scan start addr
        mov     ebx,esi                                 ; save a copy
        mov     eax,[ebp].str_ulYFracAccumulator        ; get .32 part of Y pointer
        add     eax,[ebp].str_ulYDstToSrcFracCeil       ; add in fractional step
        jnc     @f
        add     esi,[ebp].str_lDeltaSrc                 ; step one extra in src
@@:     mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        add     esi,[esp].sp_SrcIntStep                 ; step int part
        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan addr
        add     edi,[esp].sp_DstStride                  ; step to next scan in dst
        dec     [ebp].str_YDstCount                     ; decrement scan count
        jz      Done                                    ; no more scans

        mov     edx, [ebp].str_lDeltaDst
        add     [esp].sp_ulSrcAddr, edx
        cmp     esi,ebx                                 ; is src scan same as before?
        jne     NextScan                                ; if so, fall through to dupe scan

        ;--------------------------------------------------------------------
        ; The source scan is the same one used for the previous destination
        ; scan, so we can simply use the hardware to copy the previous
        ; destination scan.
        ;
        ; Since on the S3 we can set up a 'rolling blt' to copy one scan
        ; line to several scans in a single command, we will count up how
        ; many times this scan should be duplicated.  If your hardware
        ; cannot do a rolling blt, simply issue a new blt command for
        ; every time the scan should be duplicated.
        ;
        ; eax = ulYFracAccumulator
        ; ebx = original pjSrcScan
        ; esi = current pjSrcScan
        ; ebp = pSTR_BLT
        ;

        mov     ecx,-1                                  ; number of times scan is to be
                                                        ;  duplicated, less one
AnotherDuplicate:

        inc     ecx                                     ; one scan further down
        dec     [ebp].str_YDstCount                     ; decrement scan count
        jz      OutputDuplicates                        ; no more scans
        add     eax,[ebp].str_ulYDstToSrcFracCeil       ; add in fractional step
        jnc     @f
        add     esi,[ebp].str_lDeltaSrc                 ; step one extra in src
@@:     add     esi,[esp].sp_SrcIntStep                 ; step int part
        add     edi,[ebp].str_lDeltaDst                 ; step entire dest scan
        cmp     esi,ebx                                 ; is src scan same as before?
        je      AnotherDuplicate

OutputDuplicates:

        inc     ecx                                     ; ecx now equals number
                                                        ; of times to duplicate
                                                        ; the scan

        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan address
        mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        ;
        ; Now set up to duplicate the scan line
        ;

        mov     edx,[esp].sp_pjBase

        ;
        ; Wait until the accelerator will accept commands into the queue
        ;


@@:     mov     al,[edx+OFFSET_jAclStatus]
        test    eax,1
        jnz     short @b

        ; ecx = cy        -- Number of times scan is to be duplicated
        ; edx = pjBase    -- Pointer to memory mapped accelerator registers
        ; ebp = pSTR_BLT  -- Stretch blt info

        ;
        ; Set up Accelerator Source
        ;

        mov     ebx, [esp].sp_ulSrcAddr
        mov     [edx+OFFSET_ulSrcAddr],ebx

        ;
        ; Copy a scan at a time
        ;

DuplicateOneScan:

        add     ebx, [ebp].str_lDeltaDst                ; Dst = Src + lDelta

        cmp     [esp].sp_isNonW32P,0
        je      @f

        ; non w32p
        ; set mmu2 to ebx
        mov     [edx+OFFSET_ulMmuBasePtr2],ebx
        ; write to mmu2
        mov     eax,[esp].sp_pMmu2
        mov     byte ptr [eax],0
        jmp     DoneSetDestAddr

@@:     ; w32p
        mov     [edx+OFFSET_ulDstAddr],ebx


DoneSetDestAddr:

        dec     ecx
        jz      DoneDuplicate

        ;
        ; Wait until the accelerator will accept commands into the queue
        ;

@@:     mov     al,[edx+OFFSET_jAclStatus]
        test    eax,1
        jnz     short @b

        jmp     DuplicateOneScan

DoneDuplicate:

        mov     [esp].sp_ulSrcAddr, ebx                 ; store the updated src

        cmp     [ebp].str_YDstCount,0                   ; we might be all done
        jne     NextScan

Done:

        add     esp,(size STACK_STRUC) - PROC_MEM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     4

vDirectStretch8@4 endp

;---------------------------Public-Routine------------------------------;
; VOID vDirectStretch16(pStrBlt)
;
; Stretch blt 16 -> 16
;-----------------------------------------------------------------------;

        public vDirectStretch16@4

vDirectStretch16@4 proc near
        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size STACK_STRUC) - PROC_MEM_SIZE  ; make room for local variables

        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

        ;
        ; load up some stack-based parameters to be used by our scan
        ; duplicator when doing vertical stretches
        ;

        mov     eax,[ebp].str_ppdev
        mov     ecx,[ebp].str_YDstStart                 ; get start y coordinate
        mov     [esp].sp_pdev,eax                       ; save ppdev pointer

        mov     ebx,[eax].pdev_xyOffset
        mov     [esp].sp_xyOffset,ebx                   ; save xyOffset
        mov     ebx,[eax].pdev_ulChipID
        cmp     ebx, ET6000
        jne     @F
        mov     [esp].sp_isNonW32P, 0
        jmp     GotET6K
@@:
        xor     ebx,W32P
        mov     [esp].sp_isNonW32P,ebx                  ; save ChipID
GotET6K:
        mov     ebx,[eax].pdev_pjMmu2
        mov     [esp].sp_pMmu2,ebx                      ; save mmu2 addr
        mov     eax,[eax].pdev_pjBase
        mov     [esp].sp_pjBase,eax                     ; save pjBase pointer

        mov     [esp].sp_yDst,ecx                       ; save current y coordinate

        ;
        ; calc starting addressing parameters
        ;

        mov     esi,[ebp].str_pjSrcScan                 ; load src DIB pointer
        mov     eax,[ebp].str_XSrcStart
        mov     edi,[ebp].str_pjDstScan                 ; load dst DIB pointer
        mov     ebx,[ebp].str_XDstStart
        add     esi,eax
        add     edi,ebx
        add     esi,eax                                 ; add starting Src Pixel
        add     edi,ebx                                 ; add starting Dst Pixel
        mov     [esp].sp_pjSrcScan,esi                  ; save scan line start pointer
        mov     eax,[ebp].str_ulYDstToSrcIntCeil        ; number of src scan lines to step
        mul     [ebp].str_lDeltaSrc                     ; calc scan line int lines to step
        mov     [esp].sp_SrcIntStep,eax                 ; save int portion of Y src step
        mov     edx,edi                                 ; make copy of pjDst
        and     edx,2                                   ; calc left edge case
        shr     edx,1                                   ; left edge pixels
        mov     [esp].sp_LeftCase,edx                   ; save left edge case pixels
        mov     eax,[ebp].str_pjDstScan                 ; make copy
        mov     ecx,[ebp].str_XDstEnd                   ; load x end
        add     eax,ecx
        add     eax,ecx                                 ; ending dst addr
        and     eax,2                                   ; calc right edge case
        shr     eax,1                                   ; right edge pixels
        mov     [esp].sp_RightCase,eax                  ; save right edge case
        sub     ecx,[ebp].str_XDstStart                 ; calc x count

        shl     ecx,1
        dec     ecx
        mov     [esp].sp_XCntHW,ecx                     ; x width for accelerator
        inc     ecx
        shr     ecx,1

        mov     ebx,[ebp].str_lDeltaDst                 ; dst scan line stride
        sub     ebx,ecx
        sub     ebx,ecx                                 ; distance from end of one line to start of next
        mov     [esp].sp_DstStride,ebx                  ; save dst scan line stride
        sub     ecx,eax                                 ; sub right edge from XCount
        sub     ecx,edx                                 ; sub left edge from XCount
        shr     ecx,1                                   ; convert from pixels to DWORD count
        mov     [esp].sp_XCount,ecx                     ; save DWORD count
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get x frac
        mov     [esp].sp_TempXFrac,ebx                  ; save x frac to a esp based location

        ;
        ; Pre-calculate the Accelerator Source Address.
        ; We'll always derive the dst from the src.
        ;

        mov     ebx, [esp].sp_yDst                      ; ebx <- yDst
        imul    ebx, [ebp].str_lDeltaDst
        add     ebx, [esp].sp_xyOffset
        add     ebx, [ebp].str_xDstStart
        add     ebx, [ebp].str_xDstStart
        sub     ebx, [ebp].str_lDeltaDst
        mov     [esp].sp_ulSrcAddr, ebx

        ;
        ; Set up edx to access accelerator registers
        ;

        mov     edx,[esp].sp_pjBase

        ;
        ; Wait until the accelerator will accept commands into the queue
        ;


@@:     mov     al,[edx+OFFSET_jAclStatus]
        test    eax,1
        jnz     short @b

        ;
        ; Set up the accelerator with constant data
        ;

        mov     ebx,[esp].sp_XCntHW

        ; Do I need this?  What is RECT_HEIGHT, and why do I
        ; care if it is not zero?

        .errnz  RECT_HEIGHT

        mov     [edx+OFFSET_wXCnt],bx
        mov     word ptr [edx+OFFSET_wYCnt], 0

NextScan:

        ;
        ; esi and edi are assumed to be correctly loaded
        ;

        mov     eax,[ebp].str_ulXDstToSrcIntCeil        ; get src integer step for step in dst
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get src frac step for step in dst
        mov     edx,[ebp].str_ulXFracAccumulator        ; put it in edx as tmp

        mov     ebp,edi                                 ; get dst pointer to ebp

        ;
        ; Can't directly access pSTR_BLT variables through ebp
        ;

        mov     edi,edx                                 ; get accumulator where we want it
        mov     ecx,[esp].sp_LeftCase

        ; eax = integer step in source
        ; ebx = fractional step in source
        ; ecx = left edge case
        ; edx = free for pixel data
        ; esi = pointer to source pixel
        ; edi = fractional accumulator
        ; ebp = pointer to dest pixel

        ;
        ; divide 'esi' by 2 so that we can always dereference it by
        ; [2*esi] -- this allows us to still use an 'add with carry'
        ; to jump to the next pixel
        ;

        shr     esi,1

        ;
        ; first do the left side to align dwords
        ;

        test    ecx,ecx
        jz      DwordAligned

        mov     dx,[2*esi]                              ; fetch pixel
        mov     [ebp],dx                                ; write it out
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add in integer and possible carry
        add     ebp,2                                   ; step 1 in dest

DwordAligned:

        mov     ecx,[esp].sp_XCount                     ; get run length
        test    ecx,ecx
        jz      TrailingBytes                           ; watch for zero dword case

@@:
        mov     dx,[2*esi]                              ; get a source pixel
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add integer and carry

        shl     edx,16

        add     edi,ebx                                 ; step fraction
        mov     dx,[2*esi]                              ; get source pixel
        adc     esi,eax                                 ; add integer and carry

        ror     edx,16

        mov     [ebp],edx                               ; write everything to dest

        add     ebp,4                                   ; increment dest pointer by 1 dword
        dec     ecx                                     ; decrement count
        jnz     @b                                      ; do more pixels

TrailingBytes:

        ;
        ; now do the right side trailing bytes
        ;

        mov     ecx,[esp].sp_RightCase
        test    ecx,ecx
        jz      EndScanLine

        mov     dx,[2*esi]                              ; fetch pixel
        mov     [ebp],dx                                ; write it out
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add in integer and possible carry
        add     ebp,2                                   ; step 1 in dest

EndScanLine:

        mov     edi,ebp                                 ; get dst pointer back
        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

EndSkipScan:

        mov     esi,[esp].sp_pjSrcScan                  ; load src scan start addr
        mov     ebx,esi                                 ; save a copy
        mov     eax,[ebp].str_ulYFracAccumulator        ; get .32 part of Y pointer
        add     eax,[ebp].str_ulYDstToSrcFracCeil       ; add in fractional step
        jnc     @f
        add     esi,[ebp].str_lDeltaSrc                 ; step one extra in src
@@:     mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        add     esi,[esp].sp_SrcIntStep                 ; step int part
        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan addr
        add     edi,[esp].sp_DstStride                  ; step to next scan in dst
        dec     [ebp].str_YDstCount                     ; decrement scan count
        jz      Done                                    ; no more scans

        mov     edx, [ebp].str_lDeltaDst
        add     [esp].sp_ulSrcAddr, edx
        cmp     esi,ebx                                 ; is src scan same as before?
        jne     NextScan                                ; if so, fall through to dupe scan

        ;--------------------------------------------------------------------
        ; The source scan is the same one used for the previous destination
        ; scan, so we can simply use the hardware to copy the previous
        ; destination scan.
        ;
        ; Since on the S3 we can set up a 'rolling blt' to copy one scan
        ; line to several scans in a single command, we will count up how
        ; many times this scan should be duplicated.  If your hardware
        ; cannot do a rolling blt, simply issue a new blt command for
        ; every time the scan should be duplicated.
        ;
        ; eax = ulYFracAccumulator
        ; ebx = original pjSrcScan
        ; esi = current pjSrcScan
        ; ebp = pSTR_BLT
        ;

        mov     ecx,-1                                  ; number of times scan is to be
                                                        ;  duplicated, less one
AnotherDuplicate:

        inc     ecx                                     ; one scan further down
        dec     [ebp].str_YDstCount                     ; decrement scan count
        jz      OutputDuplicates                        ; no more scans
        add     eax,[ebp].str_ulYDstToSrcFracCeil       ; add in fractional step
        jnc     @f
        add     esi,[ebp].str_lDeltaSrc                 ; step one extra in src
@@:     add     esi,[esp].sp_SrcIntStep                 ; step int part
        add     edi,[ebp].str_lDeltaDst                 ; step entire dest scan
        cmp     esi,ebx                                 ; is src scan same as before?
        je      AnotherDuplicate

OutputDuplicates:

        inc     ecx                                     ; ecx now equals number
                                                        ; of times to duplicate
                                                        ; the scan

        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan address
        mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        ;
        ; Now set up to duplicate the scan line
        ;

        mov     edx,[esp].sp_pjBase

        ;
        ; Wait until the accelerator will accept commands into the queue
        ;


@@:     mov     al,[edx+OFFSET_jAclStatus]
        test    eax,1
        jnz     short @b

        ; ecx = cy        -- Number of times scan is to be duplicated
        ; edx = pjBase    -- Pointer to memory mapped accelerator registers
        ; ebp = pSTR_BLT  -- Stretch blt info

        ;
        ; Set up Accelerator source
        ;

        mov     ebx, [esp].sp_ulSrcAddr
        mov     [edx+OFFSET_ulSrcAddr],ebx

        ;
        ; Copy a scan at a time
        ;

DuplicateOneScan:

        add     ebx, [ebp].str_lDeltaDst                ; Dst = Src + lDelta

        cmp     [esp].sp_isNonW32P,0
        je      @f

        ; non w32p
        ; set mmu2 to ebx
        mov     [edx+OFFSET_ulMmuBasePtr2],ebx
        ; write to mmu2
        mov     eax,[esp].sp_pMmu2
        mov     byte ptr [eax],0
        jmp     DoneSetDestAddr

@@:     ; w32p
        mov     [edx+OFFSET_ulDstAddr],ebx

DoneSetDestAddr:

        dec     ecx
        jz      DoneDuplicate

        ;
        ; Wait until the accelerator will accept commands into the queue
        ;


@@:     mov     al,[edx+OFFSET_jAclStatus]
        test    eax,1
        jnz     short @b

        jmp     DuplicateOneScan

DoneDuplicate:

        mov     [esp].sp_ulSrcAddr, ebx                 ; store the updated src

        cmp     [ebp].str_YDstCount,0                   ; we might be all done
        jne     NextScan


Done:

        add     esp,(size STACK_STRUC) - PROC_MEM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     4

vDirectStretch16@4 endp

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\i386\strucs.inc ===
;---------------------------- Include File Header ---------------------------;
; Module Name: strucs.inc
;
; Most of these definitions are pulled straight from winddi.h.  We have
; to copy these here because we don't have any good 'h2inc' C-include-to-
; Asm-include program for NT.
;
; Copyright (c) 1993-1994 Microsoft Corporation
;----------------------------------------------------------------------------;

BMF_1BPP        equ     1
BMF_4BPP        equ     2
BMF_8BPP        equ     3
BMF_16BPP       equ     4
BMF_24BPP       equ     5
BMF_32BPP       equ     6

;-----------------------------------------------------------------------;
; POINTL is used for points with a range of +/- 2G.
;-----------------------------------------------------------------------;

POINTL          STRUC
ptl_x           DD      0
ptl_y           DD      0
POINTL          ENDS

;-----------------------------------------------------------------------;
; SIZEL is used for extents with a range of +/- 2G
;-----------------------------------------------------------------------;

SIZEL           STRUC
sizl_cx         DD      0
sizl_cy         DD      0
SIZEL           ENDS

;-----------------------------------------------------------------------;
; Definition of a rectangle
;-----------------------------------------------------------------------;


RECTL               struc           ; /* rcl */
xLeft               dd      ?
yTop                dd      ?
xRight              dd      ?
yBottom             dd      ?
RECTL               ends

;-----------------------------------------------------------------------;
; Definition of the physical device data structure
;
; NOTE: Changes to this structure must be reflected in driver.h!
;-----------------------------------------------------------------------;

PDEV                struc           ; /* pdev, ppdev */
pdev_xOffset            dd  ?
pdev_yOffset            dd  ?
pdev_xyOffset           dd  ?
pdev_pjBase             dd  ?
pdev_pjScreen           dd  ?
pdev_iBoard             dd  ?
pdev_iBitmapFormat      dd  ?
pdev_ulChipID           dd  ?
pdev_ulRevLevel         dd  ?
pdev_pjMmu0             dd  ?
pdev_pjMmu1             dd  ?
pdev_pjMmu2             dd  ?
PDEV                ends

;-----------------------------------------------------------------------;
; Definition of our realized brush structures.
;
; NOTE: Changes to these structure must be reflected in driver.h!
;-----------------------------------------------------------------------;

RBRUSH              struc           ; /* rb, prb */
rb_fl                   dd  ?
rb_bTransparent         dd  ?
rb_ulForeColor          dd  ?
rb_ulBackColor          dd  ?
rb_ptlBrushOrg          db  (size POINTL) dup(?)
rb_apbe                 dd  ?

; I haven't declared rb_aulPattern because we don't know the size of the
; rb_apbe array here.

RBRUSH              ends

BRUSHENTRY          struc           ; /* be, pbe */
be_prbVerify            dd  ?
be_x                    dd  ?
be_y                    dd  ?
BRUSHENTRY          ends

;-----------------------------------------------------------------------;
; Definitions for text output
;-----------------------------------------------------------------------;

GLYPHPOS    struc           ; /* gp */
gp_hg       dd      ?       ; hglyph (unused by vga)
gp_pgdf     dd      ?       ; glyphdef
gp_x        dd      ?       ; glyph x position
gp_y        dd      ?       ; glyph y position
GLYPHPOS    ends

GLYPHDEF struc              ; /* gdf */
gdf_pgb     dd      ?       ; points to GLYPHBITS
GLYPHDEF ends

GLYPHBITS struc             ; /* gb */
gb_x        dd      ?       ; glyph x offset
gb_y        dd      ?       ; glyph y offset
gb_cx       dd      ?       ; glyph width in pels
gb_cy       dd      ?       ; glyph height in pels
gb_aj       db      ?       ; glyph bit mask
GLYPHBITS ends

;-----------------------------------------------------------------------;
; Macro to do a simple RET, with no stack stuff, in a proc.
;-----------------------------------------------------------------------;

PLAIN_RET macro
        db      0c3h
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\textout.c ===
/******************************Module*Header*******************************\
* Module Name: textout.c
*
* On every TextOut, GDI provides an array of 'GLYPHPOS' structures
* for every glyph to be drawn.  Each GLYPHPOS structure contains a
* glyph handle and a pointer to a monochrome bitmap that describes
* the glyph.  (Note that unlike Windows 3.1, which provides a column-
* major glyph bitmap, Windows NT always provides a row-major glyph
* bitmap.)  As such, there are three basic methods for drawing text
* with hardware acceleration:
*
* 1) Glyph caching -- Glyph bitmaps are cached by the accelerator
*       (probably in off-screen memory), and text is drawn by
*       referring the hardware to the cached glyph locations.
*
* 2) Glyph expansion -- Each individual glyph is color-expanded
*       directly to the screen from the monochrome glyph bitmap
*       supplied by GDI.
*
* 3) Buffer expansion -- The CPU is used to draw all the glyphs into
*       a 1bpp monochrome bitmap, and the hardware is then used
*       to color-expand the result.
*
* The fastest method depends on a number of variables, such as the
* color expansion speed, bus speed, CPU speed, average glyph size,
* and average string length.
*
* Glyph expansion is typically faster than buffer expansion for very
* large glyphs, even on the ISA bus, because less copying by the CPU
* needs to be done.  Unfortunately, large glyphs are pretty rare.
*
* An advantange of the buffer expansion method is that opaque text will
* never flash -- the other two methods typically need to draw the
* opaquing rectangle before laying down the glyphs, which may cause
* a flash if the raster is caught at the wrong time.
*
* This driver implements glyph expansion and buffer expansion --
* methods 2) and 3).  Depending on the hardware capabilities at
* run-time, we'll use whichever one will be faster.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"


POINTL gptlZero = { 0, 0 };         // Specifies that the origin of the
                                    //   temporary buffer given to the 1bpp
                                    //   transfer routine for fasttext is
                                    //   at (0, 0)

#define     FIFTEEN_BITS        ((1 << 15)-1)

/******************************Public*Routine******************************\
* VOID vClipSolid
*
* Fills the specified rectangles with the specified color, honoring
* the requested clipping.  No more than four rectangles should be passed in.
* Intended for drawing the areas of the opaquing rectangle that extend
* beyond the text box.  The rectangles must be in left to right, top to
* bottom order.  Assumes there is at least one rectangle in the list.
*
\**************************************************************************/

VOID vClipSolid(
PDEV*       ppdev,
LONG        crcl,
RECTL*      prcl,
ULONG       iColor,
CLIPOBJ*    pco)
{
    BOOL            bMore;              // Flag for clip enumeration
    CLIPENUM        ce;                 // Clip enumeration object
    ULONG           i;
    ULONG           j;
    RECTL           arclTmp[4];
    ULONG           crclTmp;
    RECTL*          prclTmp;
    RECTL*          prclClipTmp;
    LONG            iLastBottom;
    RECTL*          prclClip;
    RBRUSH_COLOR    rbc;

    ASSERTDD((crcl > 0) && (crcl <= 4), "Expected 1 to 4 rectangles");
    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
                       "Expected a non-null clip object");

    rbc.iSolidColor = iColor;
    if (pco->iDComplexity == DC_RECT)
    {
        crcl = cIntersect(&pco->rclBounds, prcl, crcl);
        if (crcl != 0)
        {
            (ppdev->pfnFillSolid)(ppdev, crcl, prcl, R4_PATCOPY,
                                  rbc, NULL);
        }
    }
    else // iDComplexity == DC_COMPLEX
    {
        // Bottom of last rectangle to fill

        iLastBottom = prcl[crcl - 1].bottom;

        // Initialize the clip rectangle enumeration to right-down so we can
        // take advantage of the rectangle list being right-down:

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

        // Scan through all the clip rectangles, looking for intersects
        // of fill areas with region rectangles:

        do {
            // Get a batch of region rectangles:

            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*)&ce);

            // Clip the rect list to each region rect:

            for (j = ce.c, prclClip = ce.arcl; j-- > 0; prclClip++)
            {
                // Since the rectangles and the region enumeration are both
                // right-down, we can zip through the region until we reach
                // the first fill rect, and are done when we've passed the
                // last fill rect.

                if (prclClip->top >= iLastBottom)
                {
                    // Past last fill rectangle; nothing left to do:

                    return;
                }

                // Do intersection tests only if we've reached the top of
                // the first rectangle to fill:

                if (prclClip->bottom > prcl->top)
                {
                    // We've reached the top Y scan of the first rect, so
                    // it's worth bothering checking for intersection.

                    // Generate a list of the rects clipped to this region
                    // rect:

                    prclTmp     = prcl;
                    prclClipTmp = arclTmp;

                    for (i = crcl, crclTmp = 0; i-- != 0; prclTmp++)
                    {
                        // Intersect fill and clip rectangles

                        if (bIntersect(prclTmp, prclClip, prclClipTmp))
                        {
                            // Add to list if anything's left to draw:

                            crclTmp++;
                            prclClipTmp++;
                        }
                    }

                    // Draw the clipped rects

                    if (crclTmp != 0)
                    {
                        (ppdev->pfnFillSolid)(ppdev, crclTmp, &arclTmp[0],
                                             R4_PATCOPY, rbc, NULL);
                    }
                }
            }
        } while (bMore);
    }
}


BOOL bVerifyStrObj(STROBJ* pstro)
{
    BOOL bMoreGlyphs;
    LONG cGlyph;
    GLYPHPOS * pgp;
    LONG iGlyph = 0;
    RECTL * prclDraw;
    GLYPHPOS * pgpTmp;
    POINTL ptlPlace;

    do
    {
        // Get the next batch of glyphs:

        if (pstro->pgp != NULL)
        {
            // There's only the one batch of glyphs, so save ourselves
            // a call:

            pgp         = pstro->pgp;
            cGlyph      = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
        }

        prclDraw = &pstro->rclBkGround;
        pgpTmp = pgp;

        ptlPlace = pgpTmp->ptl;

        while (cGlyph)
        {
            if (((ptlPlace.x + pgpTmp->pgdf->pgb->ptlOrigin.x + pgpTmp->pgdf->pgb->sizlBitmap.cx) > (prclDraw->right)) ||
                ((ptlPlace.x + pgpTmp->pgdf->pgb->ptlOrigin.x) < (prclDraw->left)) ||
                ((ptlPlace.y + pgpTmp->pgdf->pgb->ptlOrigin.y + pgpTmp->pgdf->pgb->sizlBitmap.cy) > (prclDraw->bottom)) ||
                ((ptlPlace.y + pgpTmp->pgdf->pgb->ptlOrigin.y) < (prclDraw->top))
               )
            {
                DISPDBG((0,"------------------------------------------------------------"));
                DISPDBG((0,"Glyph %d extends beyond pstro->rclBkGround", iGlyph));
                DISPDBG((0,"\tpstro->rclBkGround (%d,%d,%d,%d)",
                            pstro->rclBkGround.left,
                            pstro->rclBkGround.top,
                            pstro->rclBkGround.right,
                            pstro->rclBkGround.bottom));
                DISPDBG((0,"\teffective glyph rect (%d,%d,%d,%d)",
                            (ptlPlace.x + pgpTmp->pgdf->pgb->ptlOrigin.x),
                            (ptlPlace.y + pgpTmp->pgdf->pgb->ptlOrigin.y),
                            (ptlPlace.x + pgpTmp->pgdf->pgb->ptlOrigin.x + pgpTmp->pgdf->pgb->sizlBitmap.cx),
                            (ptlPlace.y + pgpTmp->pgdf->pgb->ptlOrigin.y + pgpTmp->pgdf->pgb->sizlBitmap.cy)));
                DISPDBG((0,"\tglyph pos (%d,%d)",ptlPlace.x,ptlPlace.y));
                DISPDBG((0,"\tglyph origin (%d,%d)",
                            pgpTmp->pgdf->pgb->ptlOrigin.x,
                            pgpTmp->pgdf->pgb->ptlOrigin.y));
                DISPDBG((0,"\tglyph sizl (%d,%d)",
                            pgpTmp->pgdf->pgb->sizlBitmap.cx,
                            pgpTmp->pgdf->pgb->sizlBitmap.cy));
                DISPDBG((0,"------------------------------------------------------------"));
                RIP("time to call the font guys...");
                return(FALSE);
            }

            cGlyph--;
            iGlyph++;
            pgpTmp++;

            if (pstro->ulCharInc == 0)
            {
                ptlPlace = pgpTmp->ptl;
            }
            else
            {
                ptlPlace.x += pstro->ulCharInc;
            }
        }
    } while (bMoreGlyphs);

    return(TRUE);
}



/******************************Public*Routine******************************\
* BOOL bBufferExpansion
*
* Outputs text using the 'buffer expansion' method.  The CPU draws to a
* 1bpp buffer, and the result is color-expanded to the screen using the
* hardware.
*
* Note that this is x86 only ('vFastText', which draws the glyphs to the
* 1bpp buffer, is writen in Asm).
*
* If you're just getting your driver working, this is the fastest way to
* bring up working accelerated text.  All you have to do is write the
* 'Xfer1bpp' function that's also used by the blt code.  This
* 'bBufferExpansion' routine shouldn't need to be modified at all.
*
\**************************************************************************/

#if defined(i386)

BOOL bBufferExpansion(
PDEV*     ppdev,
STROBJ*   pstro,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque)
{
    BYTE            jClip;
    BOOL            bMore;              // Flag for clip enumeration
    GLYPHPOS*       pgp;                // Points to the first glyph
    BOOL            bMoreGlyphs;        // Glyph enumeration flag
    ULONG           cGlyph;             // # of glyphs in one batch
    RECTL           arclTmp[4];         // Temporary storage for portions
                                        //   of opaquing rectangle
    RECTL*          prclClip;           // Points to list of clip rectangles
    RECTL*          prclDraw;           // Actual text to be drawn
    RECTL           rclDraw;
    ULONG           crcl;               // Temporary rectangle count
    ULONG           ulBufferBytes;
    ULONG           ulBufferHeight;
    BOOL            bTextPerfectFit;
    ULONG           flDraw;
    BOOL            bTmpAlloc;
    SURFOBJ         so;
    CLIPENUM        ce;
    RBRUSH_COLOR    rbc;
    ROP4            rop4MonoExpand;     // Dictates whether opaque or
                                        //   transparent text
    XLATEOBJ        xlo;                // Temporary for passing colors
    XLATECOLORS     xlc;                // Temporary for keeping colors

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    // The foreground color will always be solid:

    xlc.iForeColor = pboFore->iSolidColor;

    ASSERTDD(xlc.iForeColor != -1, "Expected solid foreground color");

    // See if the temporary buffer is big enough for the text; if
    // not, try to allocate enough memory.  We round up to the
    // nearest dword multiple:

    so.lDelta = ((((pstro->rclBkGround.right + 31) & ~31) -
                              (pstro->rclBkGround.left & ~31)) >> 3);

    ulBufferHeight = pstro->rclBkGround.bottom - pstro->rclBkGround.top;

    ulBufferBytes = so.lDelta * ulBufferHeight;

    if (((ULONG)so.lDelta > FIFTEEN_BITS) ||
        (ulBufferHeight > FIFTEEN_BITS))
    {
        // the math will have overflowed
        return(FALSE);
    }

    // Use our temporary buffer if it's big enough, otherwise
    // allocate a buffer on the fly:

    if (ulBufferBytes >= TMP_BUFFER_SIZE)
    {
        // The textout is so big that I doubt this allocation will
        // cost a significant amount in performance:

        bTmpAlloc  = TRUE;
        so.pvScan0 = EngAllocUserMem(ulBufferBytes, ALLOC_TAG);
        if (so.pvScan0 == NULL)
            return(FALSE);
    }
    else
    {
        bTmpAlloc  = FALSE;
        so.pvScan0 = ppdev->pvTmpBuffer;
    }

    // Set fixed pitch, overlap, and top and bottom 'y' alignment
    // flags:

    if (!(pstro->flAccel & SO_HORIZONTAL) ||
         (pstro->flAccel & SO_REVERSED))
    {
        flDraw = 0;
    }
    else
    {
        flDraw = ((pstro->ulCharInc != 0) ? 0x01 : 0) |
                     (((pstro->flAccel & (SO_ZERO_BEARINGS |
                      SO_FLAG_DEFAULT_PLACEMENT)) !=
                      (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT))
                      ? 0x02 : 0) |
                     (((pstro->flAccel & (SO_ZERO_BEARINGS |
                      SO_FLAG_DEFAULT_PLACEMENT |
                      SO_MAXEXT_EQUAL_BM_SIDE)) ==
                      (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
                      SO_MAXEXT_EQUAL_BM_SIDE)) ? 0x04 : 0);
    }

    // If there's an opaque rectangle, we'll do as much opaquing
    // as possible as we do the text.  If the opaque rectangle is
    // larger than the text rectangle, then we'll do the fringe
    // areas right now, and the text and associated background
    // areas together later:

    rop4MonoExpand = R4_XPAR_EXPAND;

    DISPDBG((11,"[%d] rop4MonoExpand(%04x)", __LINE__, rop4MonoExpand));

    if (prclOpaque != NULL)
    {
        rop4MonoExpand = R4_SRCCOPY;
        DISPDBG((11,"[%d] rop4MonoExpand(%04x)", __LINE__, rop4MonoExpand));

        // Since we didn't set GCAPS_ARBRUSHOPAQUE (yes, it's
        // missing a 'b'), we don't have to worry about getting
        // anything other than a solid opaquing brush.  I wouldn't
        // recommend handling it anyway, since I'll bet it would
        // break quite a few applications:

        xlc.iBackColor = pboOpaque->iSolidColor;

        ASSERTDD(xlc.iBackColor != -1, "Expected solid background color");

        // See if we have fringe areas to do.  If so, build a list of
        // rectangles to fill, in right-down order:

        crcl = 0;

        // Top fragment:

        if (pstro->rclBkGround.top > prclOpaque->top)
        {
            arclTmp[crcl].top      = prclOpaque->top;
            arclTmp[crcl].left     = prclOpaque->left;
            arclTmp[crcl].right    = prclOpaque->right;
            arclTmp[crcl++].bottom = pstro->rclBkGround.top;
        }

        // Left fragment:

        if (pstro->rclBkGround.left > prclOpaque->left)
        {
            arclTmp[crcl].top      = pstro->rclBkGround.top;
            arclTmp[crcl].left     = prclOpaque->left;
            arclTmp[crcl].right    = pstro->rclBkGround.left;
            arclTmp[crcl++].bottom = pstro->rclBkGround.bottom;
        }

        // Right fragment:

        if (pstro->rclBkGround.right < prclOpaque->right)
        {
            arclTmp[crcl].top      = pstro->rclBkGround.top;
            arclTmp[crcl].right    = prclOpaque->right;
            arclTmp[crcl].left     = pstro->rclBkGround.right;
            arclTmp[crcl++].bottom = pstro->rclBkGround.bottom;
        }

        // Bottom fragment:

        if (pstro->rclBkGround.bottom < prclOpaque->bottom)
        {
            arclTmp[crcl].bottom = prclOpaque->bottom;
            arclTmp[crcl].left   = prclOpaque->left;
            arclTmp[crcl].right  = prclOpaque->right;
            arclTmp[crcl++].top  = pstro->rclBkGround.bottom;
        }

        // Fill any fringe rectangles we found:

        if (crcl != 0)
        {
            if (jClip == DC_TRIVIAL)
            {
                rbc.iSolidColor = xlc.iBackColor;
                (ppdev->pfnFillSolid)(ppdev, crcl, arclTmp, R4_PATCOPY, rbc, NULL);
            }
            else
            {
                vClipSolid(ppdev, crcl, arclTmp, xlc.iBackColor, pco);
            }
        }
    }

    // We're done with separate opaquing; any further opaquing will
    // happen as part of the text drawing.

    // Clear the buffer if the text isn't going to set every bit:

    bTextPerfectFit = (pstro->flAccel & (SO_ZERO_BEARINGS |
            SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE |
            SO_CHAR_INC_EQUAL_BM_BASE)) ==
            (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
            SO_MAXEXT_EQUAL_BM_SIDE | SO_CHAR_INC_EQUAL_BM_BASE);

    if (!bTextPerfectFit)
    {
        // Note that we already rounded up to a dword multiple size.

        vClearMemDword((ULONG*) so.pvScan0, ulBufferBytes >> 2);
    }

    // Fake up the translate object that will provide the 1bpp
    // transfer routine the foreground and background colors:

    xlo.pulXlate = (ULONG*) &xlc;

    // Draw the text into the temp buffer, and thence to the screen:

#if DBG
    if (!bVerifyStrObj(pstro))
    {
         return FALSE;
    }
    STROBJ_vEnumStart(pstro);
#endif

    do
    {
        // Get the next batch of glyphs:

        if (pstro->pgp != NULL)
        {
            // There's only the one batch of glyphs, so save ourselves
            // a call:

            pgp         = pstro->pgp;
            cGlyph      = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
        }

        // LATER: remove double clip intersection from ASM code

        if (cGlyph)
        {
            prclClip = NULL;
            prclDraw = &pstro->rclBkGround;

            if (jClip == DC_TRIVIAL)
            {

            Output_Text:

                vFastText(pgp,
                          cGlyph,
                          so.pvScan0,
                          so.lDelta,
                          pstro->ulCharInc,
                          &pstro->rclBkGround,
                          prclOpaque,
                          flDraw,
                          prclClip,
                          prclExtra);

                if (!bMoreGlyphs)
                {
                    DISPDBG((11,"[%d] rop4MonoExpand(%04x)", __LINE__, rop4MonoExpand));
                    (ppdev->pfnXfer1bpp)(ppdev,
                                         1,
                                         prclDraw,
                                         rop4MonoExpand,
                                         &so,
                                         &gptlZero,
                                         &pstro->rclBkGround,
                                         &xlo);
                }
            }
            else if (jClip == DC_RECT)
            {
                if (bIntersect(&pco->rclBounds, &pstro->rclBkGround,
                               &rclDraw))
                {
                    DISPDBG((11,"text was DC_RECT clipping"));
                    arclTmp[0]        = pco->rclBounds;
                    arclTmp[1].bottom = 0;          // Terminate list
                    prclClip          = &arclTmp[0];
                    prclDraw          = &rclDraw;

                    // Save some code size by jumping to the common
                    // functions calls:

                    goto Output_Text;
                }
            }
            else // jClip == DC_COMPLEX
            {
                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                   CD_ANY, 0);

                do
                {
                    bMore = CLIPOBJ_bEnum(pco,
                                    sizeof(ce) - sizeof(RECTL),
                                    (ULONG*) &ce);

                    ce.c = cIntersect(&pstro->rclBkGround,
                                      ce.arcl, ce.c);

                    if (ce.c != 0)
                    {
                        ce.arcl[ce.c].bottom = 0;   // Terminate list

                        vFastText(pgp,
                                  cGlyph,
                                  so.pvScan0,
                                  so.lDelta,
                                  pstro->ulCharInc,
                                  &pstro->rclBkGround,
                                  prclOpaque,
                                  flDraw,
                                  &ce.arcl[0],
                                  prclExtra);

                        if (!bMoreGlyphs)
                        {
                            DISPDBG((11,"[%d] rop4MonoExpand(%04x)", __LINE__, rop4MonoExpand));
                            (ppdev->pfnXfer1bpp)(ppdev,
                                                 ce.c,
                                                 &ce.arcl[0],
                                                 rop4MonoExpand,
                                                 &so,
                                                 &gptlZero,
                                                 &pstro->rclBkGround,
                                                 &xlo);
                        }
                    }
                } while (bMore);

                break;
            }
        }
    } while (bMoreGlyphs);

    // Free up any memory we allocated for the temp buffer:

    if (bTmpAlloc)
    {
        EngFreeUserMem(so.pvScan0);
    }

    return(TRUE);
}

#endif // defined(i386)

/******************************Public*Routine******************************\
* BOOL DrvTextOut
*
* If it's the fastest method, outputs text using the 'glyph expansion'
* method.  Each individual glyph is color-expanded directly to the
* screen from the monochrome glyph bitmap supplied by GDI.
*
* If it's not the fastest method, calls the routine that implements the
* 'buffer expansion' method.
*
\**************************************************************************/

BOOL DrvTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,    // If we had set GCAPS_HORIZSTRIKE, we would have
                        //   to fill these extra rectangles (it is used
                        //   largely for underlines).  It's not a big
                        //   performance win (GDI will call our DrvBitBlt
                        //   to draw the extra rectangles).
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlBrush,
MIX       mix)
{
    PDEV*           ppdev;
    DSURF*          pdsurf;
    OH*             poh;
    BOOL            bTextPerfectFit;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    GLYPHBITS*      pgb;
    BYTE*           pjGlyph;
    LONG            cyGlyph;
    POINTL          ptlOrigin;
    LONG            ulCharInc;
    BYTE            iDComplexity;
    LONG            lDelta;
    LONG            cw;

    // The DDI spec says we'll only ever get foreground and background
    // mixes of R2_COPYPEN:

    ASSERTDD(mix == 0x0d0d, "GDI should only give us a copy mix");

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;

    if (pdsurf->dt != DT_DIB)
    {
        // We'll be drawing to the screen or an off-screen DFB; copy the
        // surface's offset now so that we won't need to refer to the DSURF
        // again:

        poh   = pdsurf->poh;
        ppdev = (PDEV*) pso->dhpdev;

        ppdev->xOffset  = poh->x;
        ppdev->yOffset  = poh->y;
        ppdev->xyOffset = (poh->x * ppdev->cBpp) +
                          (poh->y * ppdev->lDelta);

        if (ppdev->bAutoBanking)
        {
            PVOID pvScan0;
            BOOL  bRet;
            BYTE* pjBase = ppdev->pjBase;

            pvScan0 = ppdev->psoFrameBuffer->pvScan0;

            (BYTE*)ppdev->psoFrameBuffer->pvScan0 += ppdev->xyOffset;

            WAIT_FOR_IDLE_ACL(ppdev, pjBase);
            bRet = EngTextOut(ppdev->psoFrameBuffer, pstro, pfo, pco, prclExtra,
                              prclOpaque, pboFore, pboOpaque, pptlBrush, mix);

            ppdev->psoFrameBuffer->pvScan0 = pvScan0;
            return(bRet);
        }


        {
            #if defined(i386)
            {
                // We don't want to use the 'glyph expansion' method, so use
                // the 'buffer expansion' method instead:

                return(bBufferExpansion(ppdev, pstro, pco, prclExtra, prclOpaque,
                                        pboFore, pboOpaque));
            }
            #else
            {
                BANK    bnk;
                BOOL    b;
                RECTL   rclDraw;
                RECTL  *prclDst = &pco->rclBounds;

                // The bank manager requires that the 'draw' rectangle be
                // well-ordered:

                rclDraw = *prclDst;
                if (rclDraw.left > rclDraw.right)
                {
                    rclDraw.left   = prclDst->right;
                    rclDraw.right  = prclDst->left;
                }
                if (rclDraw.top > rclDraw.bottom)
                {
                    rclDraw.top    = prclDst->bottom;
                    rclDraw.bottom = prclDst->top;
                }

                vBankStart(ppdev, &rclDraw, pco, &bnk);

                b = TRUE;
                do {
                    b &= EngTextOut(bnk.pso,
                                    pstro,
                                    pfo,
                                    bnk.pco,
                                    prclExtra,
                                    prclOpaque,
                                    pboFore,
                                    pboOpaque,
                                    pptlBrush,
                                    mix);
                } while (bBankEnum(&bnk));

                return(b);
            }

            #endif
        }
    }
    else
    {
        // We're drawing to a DFB we've converted to a DIB, so just call GDI
        // to handle it:

        return(EngTextOut(pdsurf->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                          pboFore, pboOpaque, pptlBrush, mix));
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bEnableText
*
* Performs the necessary setup for the text drawing subcomponent.
*
\**************************************************************************/

BOOL bEnableText(
PDEV*   ppdev)
{
    // Our text algorithms require no initialization.  If we were to
    // do glyph caching, we would probably want to allocate off-screen
    // memory and do a bunch of other stuff here.

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableText
*
* Performs the necessary clean-up for the text drawing subcomponent.
*
\**************************************************************************/

VOID vDisableText(PDEV* ppdev)
{
    // Here we free any stuff allocated in 'bEnableText'.
}

/******************************Public*Routine******************************\
* VOID vAssertModeText
*
* Disables or re-enables the text drawing subcomponent in preparation for
* full-screen entry/exit.
*
\**************************************************************************/

VOID vAssertModeText(
PDEV*   ppdev,
BOOL    bEnable)
{
    // If we were to do off-screen glyph caching, we would probably want
    // to invalidate our cache here, because it will get destroyed when
    // we switch to full-screen.
}

/******************************Public*Routine******************************\
* VOID DrvDestroyFont
*
* We're being notified that the given font is being deallocated; clean up
* anything we've stashed in the 'pvConsumer' field of the 'pfo'.
*
\**************************************************************************/

VOID DrvDestroyFont(FONTOBJ *pfo)
{
    // This call isn't hooked, so GDI will never call it.
    //
    // This merely exists as a stub function for the sample multi-screen
    // support, so that MulDestroyFont can illustrate how multiple screen
    // text supports when the driver caches glyphs.  If this driver did
    // glyph caching, we might have used the 'pvConsumer' field of the
    //  'pfo', which we would have to clean up.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\stroke.c ===
/******************************Module*Header*******************************\
* Module Name: Stroke.c
*
* DrvStrokePath for the display driver
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// Note:  the following table has 17 entries

BYTE aMixToRop3[] = {
        0xFF,         /* 0    1       */
        0x00,         /* 1    0       */
        0x05,         /* 2   DPon     */
        0x0A,         /* 3   DPna     */
        0x0F,         /* 4   PN       */
        0x50,         /* 5   PDna     */
        0x55,         /* 6   Dn       */
        0x5a,         /* 7   DPx      */
        0x5f,         /* 8   DPan     */
        0xA0,         /* 9   DPa      */
        0xA5,         /* 10  DPxn     */
        0xAA,         /* 11  D        */
        0xAF,         /* 12  DPno     */
        0xF0,         /* 13  P        */
        0xF5,         /* 14  PDno     */
        0xFA,         /* 15  DPo      */
        0xFF          /* 16   1       */
};

VOID (*gapfnStripI[])(PDEV*, STRIP*, LINESTATE*) = {
    vrlSolidHorizontal,
    vrlSolidVertical,
    vrlSolidDiagonalHorizontal,
    vrlSolidDiagonalVertical,

// Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    vssSolidHorizontal,
    vssSolidVertical,
    vssSolidDiagonalHorizontal,
    vssSolidDiagonalVertical,

// Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
// solid lines, and the same number for non-solid lines:

    vStripStyledHorizontal,
    vStripStyledVertical,
    vStripStyledVertical,       // Diagonal goes here
    vStripStyledVertical,       // Diagonal goes here

    vStripStyledHorizontal,
    vStripStyledVertical,
    vStripStyledVertical,       // Diagonal goes here
    vStripStyledVertical,       // Diagonal goes here
};

VOID (*gapfnStripP[])(PDEV*, STRIP*, LINESTATE*) = {
    vrlSolidHorizontalP,
    vrlSolidVerticalP,
    vrlSolidDiagonalHorizontalP,
    vrlSolidDiagonalVerticalP,

// Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    vrlSolidHorizontalP,
    vrlSolidVerticalP,
    vrlSolidDiagonalHorizontalP,
    vrlSolidDiagonalVerticalP,

// Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
// solid lines, and the same number for non-solid lines:

    vStripStyledHorizontalP,
    vStripStyledVerticalP,
    vStripStyledVerticalP,      // Diagonal goes here
    vStripStyledVerticalP,      // Diagonal goes here

    vStripStyledHorizontalP,
    vStripStyledVerticalP,
    vStripStyledVerticalP,      // Diagonal goes here
    vStripStyledVerticalP,      // Diagonal goes here
};


// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

/******************************Public*Routine******************************\
* BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix)
*
* Strokes the path.
*
\**************************************************************************/

BOOL DrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    PDEV    *ppdev = (PDEV*) pso->dhpdev;
    DSURF   *pdsurf;
    OH*      poh;
    BYTE*    pjBase;
    LONG     cBpp;

    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE ls;
    PFNSTRIP* apfn;
    FLONG     fl;
    RECTL     arclClip[4];                  // For rectangular clipping

    if ((mix & 0xf) != 0x0d) DISPDBG((3,"Line with mix(%x)", mix));

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt == DT_DIB)
    {
        return(EngStrokePath(pdsurf->pso, ppo, pco, pxo, pbo, pptlBrush,
                             pla, mix));
    }

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:

    poh   = pdsurf->poh;
    cBpp  = ppdev->cBpp;

    ppdev->xOffset = poh->x;
    ppdev->yOffset = poh->y;
    ppdev->xyOffset = (poh->x * cBpp) +
                      (poh->y * ppdev->lDelta);

    if (DRIVER_PUNT_ALL ||
        (pla->fl & LA_ALTERNATE) ||
        (pla->pstyle != (FLOAT_LONG*) NULL) ||
        ((cBpp == 3) && (ppdev->ulChipID != W32P) && (ppdev->ulChipID != ET6000)))
    {
        if (ppdev->bAutoBanking)
        {
            PVOID pvScan0;
            BOOL  bRet;
            BYTE* pjBase = ppdev->pjBase;

            pvScan0 = ppdev->psoFrameBuffer->pvScan0;

            (BYTE*)ppdev->psoFrameBuffer->pvScan0 += ppdev->xyOffset;

            WAIT_FOR_IDLE_ACL(ppdev, pjBase);
            bRet = EngStrokePath(ppdev->psoFrameBuffer,ppo,pco,pxo,pbo,
                                 pptlBrush,pla,mix);




            ppdev->psoFrameBuffer->pvScan0 = pvScan0;
            return(bRet);
        }

        //
        // Bank and punt call to the engine (line was styled)
        //

        {
            BANK    bnk;
            BOOL    b;
            RECTL   rclDraw;
            RECTL  *prclDst = &pco->rclBounds;

            FLOAT_LONG  elSavedStyleState = pla->elStyleState;

            {
                DISPDBG((110,"Simulating StrokePath\n"));

                // The bank manager requires that the 'draw' rectangle be
                // well-ordered:

                rclDraw = *prclDst;
                if (rclDraw.left > rclDraw.right)
                {
                    rclDraw.left   = prclDst->right;
                    rclDraw.right  = prclDst->left;
                }
                if (rclDraw.top > rclDraw.bottom)
                {
                    rclDraw.top    = prclDst->bottom;
                    rclDraw.bottom = prclDst->top;
                }

                vBankStart(ppdev, &rclDraw, pco, &bnk);

                b = TRUE;
                do {
                    pla->elStyleState = elSavedStyleState;

                    b &= EngStrokePath(bnk.pso,
                                       ppo,
                                       bnk.pco,
                                       pxo,
                                       pbo,
                                       pptlBrush,
                                       pla,
                                       mix);
                } while (bBankEnum(&bnk));

                return(b);
            }
        }
    }

// Get the device ready:

    pjBase = ppdev->pjBase;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

    CP_FG_ROP(ppdev, pjBase, (aMixToRop3[mix & 0xf]));
    CP_PAT_WRAP(ppdev, pjBase, (SOLID_COLOR_PATTERN_WRAP));
    CP_PAT_Y_OFFSET(ppdev, pjBase, (SOLID_COLOR_PATTERN_OFFSET - 1));
    CP_PAT_ADDR(ppdev, pjBase, (ppdev->ulSolidColorOffset));

    {
        ULONG ulSolidColor = pbo->iSolidColor;

        if (cBpp == 1)
        {
            ulSolidColor &= 0x000000FF;        //  We may get some extraneous data in the
            ulSolidColor |= ulSolidColor << 8;
        }
        if (cBpp <= 2)
        {
            ulSolidColor &= 0x0000FFFF;
            ulSolidColor |= ulSolidColor << 16;
        }

        WAIT_FOR_IDLE_ACL(ppdev, pjBase);

        // Set the color in offscreen memory

        if (ppdev->bAutoBanking)
        {
            *(PULONG)(ppdev->pjScreen + ppdev->ulSolidColorOffset) = ulSolidColor;
        }
        else
        {
            CP_MMU_BP0(ppdev, pjBase, ppdev->ulSolidColorOffset);
            CP_WRITE_MMU_DWORD(ppdev, 0, 0, ulSolidColor);
        }
    }

    fl = 0;

// Look after styling initialization:

    if (pla->fl & LA_ALTERNATE)
    {
        ls.cStyle      = 1;
        ls.spTotal     = 1;
        ls.spTotal2    = 2;
        ls.spRemaining = 1;
        ls.aspRtoL     = &gaspAlternateStyle[0];
        ls.aspLtoR     = &gaspAlternateStyle[0];
        ls.spNext      = HIWORD(pla->elStyleState.l);
        ls.xyDensity   = 1;
        fl            |= FL_STYLED;
        ls.ulStartMask = 0L;
    }
    else if (pla->pstyle != (FLOAT_LONG*) NULL)
    {
        PFLOAT_LONG pstyle;
        STYLEPOS*   pspDown;
        STYLEPOS*   pspUp;

        pstyle = &pla->pstyle[pla->cstyle];

        ls.xyDensity = STYLE_DENSITY;
        ls.spTotal   = 0;
        while (pstyle-- > pla->pstyle)
        {
            ls.spTotal += pstyle->l;
        }
        ls.spTotal *= STYLE_DENSITY;
        ls.spTotal2 = 2 * ls.spTotal;

    // Compute starting style position (this is guaranteed not to overflow):

        ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                    LOWORD(pla->elStyleState.l);

        fl        |= FL_STYLED;
        ls.cStyle  = pla->cstyle;
        ls.aspRtoL = aspRtoL;
        ls.aspLtoR = aspLtoR;

        if (pla->fl & LA_STARTGAP)
            ls.ulStartMask = 0xffffffffL;
        else
            ls.ulStartMask = 0L;

        pstyle  = pla->pstyle;
        pspDown = &ls.aspRtoL[ls.cStyle - 1];
        pspUp   = &ls.aspLtoR[0];

        while (pspDown >= &ls.aspRtoL[0])
        {
            *pspDown = pstyle->l * STYLE_DENSITY;
            *pspUp   = *pspDown;

            pspUp++;
            pspDown--;
            pstyle++;
        }
    }

    if ((ppdev->ulChipID == W32P) || (ppdev->ulChipID == ET6000))
    {
        apfn = &gapfnStripP[NUM_STRIP_DRAW_STYLES *
                            ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];
        CP_PEL_DEPTH(ppdev, pjBase, ((cBpp - 1) << 4));
    }
    else
    {
        apfn = &gapfnStripI[NUM_STRIP_DRAW_STYLES *
                            ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];
    }


// Set up to enumerate the path:

    if (pco->iDComplexity != DC_COMPLEX)
    {
        PATHDATA  pd;
        RECTL*    prclClip = (RECTL*) NULL;
        BOOL      bMore;
        ULONG     cptfx;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;

        if (pco->iDComplexity == DC_RECT)
        {
            fl |= FL_SIMPLE_CLIP;

            arclClip[0]        =  pco->rclBounds;

        // FL_FLIP_D:

            arclClip[1].top    =  pco->rclBounds.left;
            arclClip[1].left   =  pco->rclBounds.top;
            arclClip[1].bottom =  pco->rclBounds.right;
            arclClip[1].right  =  pco->rclBounds.bottom;

        // FL_FLIP_V:

            arclClip[2].top    = -pco->rclBounds.bottom + 1;
            arclClip[2].left   =  pco->rclBounds.left;
            arclClip[2].bottom = -pco->rclBounds.top + 1;
            arclClip[2].right  =  pco->rclBounds.right;

        // FL_FLIP_V | FL_FLIP_D:

            arclClip[3].top    =  pco->rclBounds.left;
            arclClip[3].left   = -pco->rclBounds.bottom + 1;
            arclClip[3].bottom =  pco->rclBounds.right;
            arclClip[3].right  = -pco->rclBounds.top + 1;

            prclClip = arclClip;
        }

        pd.flags = 0;

        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            cptfx = pd.count;
            if (cptfx == 0)
            {
                break;
            }

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if (pd.flags & PD_RESETSTYLE)
                ls.spNext = 0;

            if (cptfx > 0)
            {
                if (!bLines(ppdev,
                            pptfxFirst,
                            pptfxBuf,
                            (RUN*) NULL,
                            cptfx,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    goto ReturnFalse;
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (!bLines(ppdev,
                            &ptfxLast,
                            &ptfxStartFigure,
                            (RUN*) NULL,
                            1,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    goto ReturnFalse;
            }
        } while (bMore);

        if (fl & FL_STYLED)
        {
        // Save the style state:

            ULONG ulHigh;
            ULONG ulLow;

        // Masked styles don't normalize the style state.  It's a good
        // thing to do, so let's do it now:

            if ((ULONG) ls.spNext >= (ULONG) ls.spTotal2)
                ls.spNext = (ULONG) ls.spNext % (ULONG) ls.spTotal2;

            ulHigh = ls.spNext / ls.xyDensity;
            ulLow  = ls.spNext % ls.xyDensity;

            pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    }
    else
    {
    // Local state for path enumeration:

        BOOL bMore;
        union {
            BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

    // We use the clip object when non-simple clipping is involved:

        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        do {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if (cl.cl.c != 0)
            {
                if (fl & FL_STYLED)
                {
                    ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                 + LOWORD(cl.cl.lStyleState);
                }
                if (!bLines(ppdev,
                            &cl.cl.ptfxA,
                            &cl.cl.ptfxB,
                            &cl.cl.arun[0],
                            cl.cl.c,
                            &ls,
                            (RECTL*) NULL,
                            apfn,
                            fl))
                    goto ReturnFalse;
            }
        } while (bMore);
    }

    CP_PEL_DEPTH(ppdev, pjBase, 0);
    return(TRUE);

ReturnFalse:
    CP_PEL_DEPTH(ppdev, pjBase, 0);
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\i386\hw.inc ===
;---------------------------- Include File Header ---------------------------;
; Module Name: hw.inc
;
; All the hardware specific driver file stuff.  Mirrors some of 'hw.h'.
;
; Copyright (c) 1993-1994 Microsoft Corporation
;----------------------------------------------------------------------------;

;--------------------------------------------------------------------------
; The following are reflected in hw.inc.  Don't change these
; without changing that file.  Actually, don't change these
; without inventing a new chip.

OFFSET_ulMmuBasePtr0       equ 0000h
OFFSET_ulMmuBasePtr1       equ 0004h
OFFSET_ulMmuBasePtr2       equ 0008h
OFFSET_jMmuCtrl            equ 0013h
OFFSET_jSuspendTerminate   equ 0030h
OFFSET_jOperationState     equ 0031h
OFFSET_jSyncEnable         equ 0032h
OFFSET_jIntrMask           equ 0034h
OFFSET_jIntrStatus         equ 0035h
OFFSET_jAclStatus          equ 0036h
OFFSET_wXPosW32P           equ 0038h    // W32p only
OFFSET_wYPosW32P           equ 003Ah    // W32p only
OFFSET_ulPatAddr           equ 0080h
OFFSET_ulSrcAddr           equ 0084h
OFFSET_wPatYOffset         equ 0088h
OFFSET_wSrcYOffset         equ 008Ah
OFFSET_wDstYOffset         equ 008Ch
OFFSET_jBusSizeW32         equ 008Eh    // W32 and W32i only
OFFSET_jPixelDepthW32P     equ 008Eh    // W32p only
OFFSET_jXYDir              equ 008Fh
OFFSET_jPatWrap            equ 0090h
OFFSET_jSrcWrap            equ 0092h
OFFSET_wXPosW32            equ 0094h    // W32 and W32i only
OFFSET_wYPosW32            equ 0096h    // W32 and W32i only
OFFSET_wXCnt               equ 0098h
OFFSET_wYCnt               equ 009Ah
OFFSET_jRoutCtrl           equ 009Ch
OFFSET_jReloadCtrlW32      equ 009Dh    // W32 and W32i only
OFFSET_jBkRop              equ 009Eh
OFFSET_jFgRop              equ 009Fh
OFFSET_ulDstAddr           equ 00A0h
OFFSET_ulMixAddr           equ 00A4h
OFFSET_wMixYOffset         equ 00A8h
OFFSET_wErrTerm            equ 00AAh
OFFSET_wDeltaMinor         equ 00ACh
OFFSET_wDeltaMajor         equ 00AEh

;--------------------------------------------------------------------------
; The following are reflected in hw.inc.  Don't change these
; without changing that file.

ET3000          equ 1
ET4000          equ 2
W32             equ 3
W32I            equ 4
W32P            equ 5
ET6000          equ 6

REV_UNDEF       equ 1
REV_A           equ 2
REV_B           equ 3
REV_C           equ 4
REV_D           equ 5


;--------------------------------------------------------------------------
; Chip equates

STATUS_1                        equ 03DAh
VSY_NOT                         equ 08h

CRTC_INDEX                      equ 03D4h
CRTC_DATA                       equ 03D5h

S3R8                            equ 038h
S3R9                            equ 039h
S3R1                            equ 031h
S3R5                            equ 035h

CR39                            equ 039h
CR4C                            equ 04Ch
CR4D                            equ 04Dh

HGC_MODE                        equ 045h
HGC_ENABLE                      equ 001h
HGC_DISABLE                     equ 000h

HGC_ORGX_LSB                    equ 047h
HGC_ORGX_MSB                    equ 046h
HGC_ORGY_LSB                    equ 049h
HGC_ORGY_MSB                    equ 048h

HGC_DX                          equ 04Eh
HGC_DY                          equ 04Fh

REG_UNLOCK_1                    equ 048h
CPUA_BASE                       equ 001h

SYSCTL_UNLOCK                   equ 0A0h
SYSCTL_LOCK                     equ 000h

SYS_CNFG                        equ 040h
LAW_CTL                         equ 058h
EX_SCTL_2                       equ 051h
EX_DAC_CT                       equ 055h

MISC_1                          equ 03Ah

; Command types:

DRAW_LINE                       equ 02000h
RECTANGLE_FILL                  equ 04000h
BITBLT                          equ 0C000h
PATTERN_FILL                    equ 0E000h

BYTE_SWAP                       equ 01000h
BUS_SIZE_16                     equ 00200h
BUS_SIZE_8                      equ 00000h
WAIT_CPU                        equ 00100h

; Drawing directions (radial):

DRAWING_DIRECTION_0             equ 0000h
DRAWING_DIRECTION_45            equ 0020h
DRAWING_DIRECTION_90            equ 0040h
DRAWING_DIRECTION_135           equ 0060h
DRAWING_DIRECTION_180           equ 0080h
DRAWING_DIRECTION_225           equ 00A0h
DRAWING_DIRECTION_270           equ 00C0h
DRAWING_DIRECTION_315           equ 00E0h

; Drawing directions (x/y):

DRAWING_DIR_BTRLXM              equ 0000h
DRAWING_DIR_BTLRXM              equ 0020h
DRAWING_DIR_BTRLYM              equ 0040h
DRAWING_DIR_BTLRYM              equ 0060h
DRAWING_DIR_TBRLXM              equ 0080h
DRAWING_DIR_TBLRXM              equ 00A0h
DRAWING_DIR_TBRLYM              equ 00C0h
DRAWING_DIR_TBLRYM              equ 00E0h

; Drawing direction bits:

PLUS_X                          equ 0020h
PLUS_Y                          equ 0080h
MAJOR_Y                         equ 0040h

; Draw:

DRAW                            equ 0010h

; Direction type:

DIR_TYPE_RADIAL                 equ 0008h
DIR_TYPE_XY                     equ 0000h

; Last pixel:

LAST_PIXEL_OFF                  equ 0004h
LAST_PIXEL_ON                   equ 0000h

; Pixel mode:

MULTIPLE_PIXELS                 equ 0002h
SINGLE_PIXEL                    equ 0000h

; Read/write:

READ                            equ 0000h
WRITE                           equ 0001h

; Graphics processor status:

HARDWARE_BUSY                   equ 0200h
READ_DATA_AVAILABLE             equ 0100h
GP_ALL_EMPTY                    equ 0400h

; Fifo status in terms of empty entries:

FIFO_1_EMPTY                    equ 0080h
FIFO_2_EMPTY                    equ 0040h
FIFO_3_EMPTY                    equ 0020h
FIFO_4_EMPTY                    equ 0010h
FIFO_5_EMPTY                    equ 0008h
FIFO_6_EMPTY                    equ 0004h
FIFO_7_EMPTY                    equ 0002h
FIFO_8_EMPTY                    equ 0001h

; These are the defines for the multifunction control register.
; The 4 MSBs define the function of the register.

RECT_HEIGHT                     equ 00000h

CLIP_TOP                        equ 01000h
CLIP_LEFT                       equ 02000h
CLIP_BOTTOM                     equ 03000h
CLIP_RIGHT                      equ 04000h

DATA_EXTENSION                  equ 0A000h
MULT_MISC_INDEX                 equ 0E000h
READ_SEL_INDEX                  equ 0F000h

ALL_ONES                        equ 00000h
CPU_DATA                        equ 00080h
DISPLAY_MEMORY                  equ 000C0h

; Colour source:

BACKGROUND_COLOR                equ 000h
FOREGROUND_COLOR                equ 020h
SRC_CPU_DATA                    equ 040h
SRC_DISPLAY_MEMORY              equ 060h

; Mix modes:

NOT_SCREEN                      equ 00h
LOGICAL_0                       equ 01h
LOGICAL_1                       equ 02h
LEAVE_ALONE                     equ 03h
NOT_NEW                         equ 04h
SCREEN_XOR_NEW                  equ 05h
NOT_SCREEN_XOR_NEW              equ 06h
OVERPAINT                       equ 07h
NOT_SCREEN_OR_NOT_NEW           equ 08h
SCREEN_OR_NOT_NEW               equ 09h
NOT_SCREEN_OR_NEW               equ 0Ah
SCREEN_OR_NEW                   equ 0Bh
SCREEN_AND_NEW                  equ 0Ch
NOT_SCREEN_AND_NEW              equ 0Dh
SCREEN_AND_NOT_NEW              equ 0Eh
NOT_SCREEN_AND_NOT_NEW          equ 0Fh

; When one of the following bits is set in a hardware mix, it means
; that a pattern is needed (i.e., is none of NOT_SCREEN, LOGICAL_0,
; LOGICAL_1 or LEAVE_ALONE):

MIX_NEEDSPATTERN                equ 0Ch

; ////////////////////////////////////////////////////////////////////
; // S3 port control
; ////////////////////////////////////////////////////////////////////

; Accelerator port addresses:

CUR_Y                           equ 082E8h
CUR_X                           equ 086E8h
DEST_Y                          equ 08AE8h
DEST_X                          equ 08EE8h
AXSTP                           equ 08AE8h
DIASTP                          equ 08EE8h
ERR_TERM                        equ 092E8h
MAJ_AXIS_PCNT                   equ 096E8h
CMD                             equ 09AE8h
SHORT_STROKE                    equ 09EE8h
BKGD_COLOR                      equ 0A2E8h
FRGD_COLOR                      equ 0A6E8h
WRT_MASK                        equ 0AAE8h
RD_MASK                         equ 0AEE8h
COLOR_CMP                       equ 0B2E8h
BKGD_MIX                        equ 0B6E8h
FRGD_MIX                        equ 0BAE8h
MULTIFUNC_CNTL                  equ 0BEE8h
MIN_AXIS_PCNT                   equ 0BEE8h
SCISSORS_T                      equ 0BEE8h
SCISSORS_L                      equ 0BEE8h
SCISSORS_B                      equ 0BEE8h
SCISSORS_R                      equ 0BEE8h
PIX_CNTL                        equ 0BEE8h
PIX_TRANS                       equ 0E2E8h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\w32blt.c ===
/******************************Module*Header*******************************\
* Module Name: w32blt.c
*
* Contains the low-level memory-mapped IO blt functions.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1996 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/**************************************************************************
* All functions using the accelerator must...
*   Wait for the ACL queue to be empty before loading any of the registers.
**************************************************************************/

/**************************************************************************
*   The following tables are heinous, but required.  The monochrome data
*   (also known as Mix-Map or Mask) expander intereprets the data such that
*   the least significant bit of a byte is pixel 0 and the most significant
*   bit is pixel 7.  This is backwards from the way monochrome data is
*   interpreted by Windows and Windows NT.  Also, the expander will ONLY
*   do 1 to 8 expansion, so we need to replicate each bit by the number of
*   bytes per pel in the current color depth.
**************************************************************************/

BYTE jReverse[] =
{
    // Each element is the bitwise reverse of it's index.
    //
    // ie.  10000000 -> 00000001 and
    //      10010100 -> 00101001.

    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
};

WORD wReverse2x[] =
{
    // Each element is the bit doubled bitwise reverse of it's index.
    //
    // ie.  10000000 -> 0000000000000011 and
    //      10010100 -> 0000110011000011.

    0x0000, 0xc000, 0x3000, 0xf000, 0x0c00, 0xcc00, 0x3c00, 0xfc00,
    0x0300, 0xc300, 0x3300, 0xf300, 0x0f00, 0xcf00, 0x3f00, 0xff00,
    0x00c0, 0xc0c0, 0x30c0, 0xf0c0, 0x0cc0, 0xccc0, 0x3cc0, 0xfcc0,
    0x03c0, 0xc3c0, 0x33c0, 0xf3c0, 0x0fc0, 0xcfc0, 0x3fc0, 0xffc0,
    0x0030, 0xc030, 0x3030, 0xf030, 0x0c30, 0xcc30, 0x3c30, 0xfc30,
    0x0330, 0xc330, 0x3330, 0xf330, 0x0f30, 0xcf30, 0x3f30, 0xff30,
    0x00f0, 0xc0f0, 0x30f0, 0xf0f0, 0x0cf0, 0xccf0, 0x3cf0, 0xfcf0,
    0x03f0, 0xc3f0, 0x33f0, 0xf3f0, 0x0ff0, 0xcff0, 0x3ff0, 0xfff0,
    0x000c, 0xc00c, 0x300c, 0xf00c, 0x0c0c, 0xcc0c, 0x3c0c, 0xfc0c,
    0x030c, 0xc30c, 0x330c, 0xf30c, 0x0f0c, 0xcf0c, 0x3f0c, 0xff0c,
    0x00cc, 0xc0cc, 0x30cc, 0xf0cc, 0x0ccc, 0xcccc, 0x3ccc, 0xfccc,
    0x03cc, 0xc3cc, 0x33cc, 0xf3cc, 0x0fcc, 0xcfcc, 0x3fcc, 0xffcc,
    0x003c, 0xc03c, 0x303c, 0xf03c, 0x0c3c, 0xcc3c, 0x3c3c, 0xfc3c,
    0x033c, 0xc33c, 0x333c, 0xf33c, 0x0f3c, 0xcf3c, 0x3f3c, 0xff3c,
    0x00fc, 0xc0fc, 0x30fc, 0xf0fc, 0x0cfc, 0xccfc, 0x3cfc, 0xfcfc,
    0x03fc, 0xc3fc, 0x33fc, 0xf3fc, 0x0ffc, 0xcffc, 0x3ffc, 0xfffc,
    0x0003, 0xc003, 0x3003, 0xf003, 0x0c03, 0xcc03, 0x3c03, 0xfc03,
    0x0303, 0xc303, 0x3303, 0xf303, 0x0f03, 0xcf03, 0x3f03, 0xff03,
    0x00c3, 0xc0c3, 0x30c3, 0xf0c3, 0x0cc3, 0xccc3, 0x3cc3, 0xfcc3,
    0x03c3, 0xc3c3, 0x33c3, 0xf3c3, 0x0fc3, 0xcfc3, 0x3fc3, 0xffc3,
    0x0033, 0xc033, 0x3033, 0xf033, 0x0c33, 0xcc33, 0x3c33, 0xfc33,
    0x0333, 0xc333, 0x3333, 0xf333, 0x0f33, 0xcf33, 0x3f33, 0xff33,
    0x00f3, 0xc0f3, 0x30f3, 0xf0f3, 0x0cf3, 0xccf3, 0x3cf3, 0xfcf3,
    0x03f3, 0xc3f3, 0x33f3, 0xf3f3, 0x0ff3, 0xcff3, 0x3ff3, 0xfff3,
    0x000f, 0xc00f, 0x300f, 0xf00f, 0x0c0f, 0xcc0f, 0x3c0f, 0xfc0f,
    0x030f, 0xc30f, 0x330f, 0xf30f, 0x0f0f, 0xcf0f, 0x3f0f, 0xff0f,
    0x00cf, 0xc0cf, 0x30cf, 0xf0cf, 0x0ccf, 0xcccf, 0x3ccf, 0xfccf,
    0x03cf, 0xc3cf, 0x33cf, 0xf3cf, 0x0fcf, 0xcfcf, 0x3fcf, 0xffcf,
    0x003f, 0xc03f, 0x303f, 0xf03f, 0x0c3f, 0xcc3f, 0x3c3f, 0xfc3f,
    0x033f, 0xc33f, 0x333f, 0xf33f, 0x0f3f, 0xcf3f, 0x3f3f, 0xff3f,
    0x00ff, 0xc0ff, 0x30ff, 0xf0ff, 0x0cff, 0xccff, 0x3cff, 0xfcff,
    0x03ff, 0xc3ff, 0x33ff, 0xf3ff, 0x0fff, 0xcfff, 0x3fff, 0xffff,
};

ULONG aulLeadCnt[] = {0x0, 0x3, 0x2, 0x1};

FNLOWXFER* afnXferI_Narrow[16] =
{
    NULL,
    vXferI_1_Byte,
    vXferI_2_Bytes,
    vXferI_3_Bytes
};

FNLOWXFER* afnXferP_Narrow[16] =
{
    NULL,
    vXferP_1_Byte,
    vXferP_2_Bytes,
    vXferP_3_Bytes
};

/**************************************************************************
*
* Realizes a pattern into offscreen memory.
*
**************************************************************************/

VOID vFastPatRealize(           // Type FNFASTPATREALIZE
PDEV*   ppdev,
RBRUSH* prb,                    // Points to brush realization structure
POINTL* pptlBrush,              // Ignored
BOOL    bTransparent)           // FALSE for normal patterns; TRUE for
                                //   patterns with a mask when the background
                                //   mix is LEAVE_ALONE.
{
    BRUSHENTRY* pbe;
    LONG        iBrushCache;
    ULONG       ulOffset;
    BYTE*       pjPattern;
    LONG        culPattern;
    LONG        cjPattern;
    BYTE*       pjDst;
    ULONG       ulDstOffset;

    BYTE*       pjBase = ppdev->pjBase;

    DISPDBG((10,"vFastPatRealize called"));

    //
    // Make sure we can write to the video registers.
    //

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

    pbe = prb->pbe;
    if ((pbe == NULL) || (pbe->prbVerify != prb))
    {
        // We have to allocate a new offscreen cache brush entry for
        // the brush:

        iBrushCache = ppdev->iBrushCache;
        pbe         = &ppdev->abe[iBrushCache];

        iBrushCache++;
        if (iBrushCache >= ppdev->cBrushCache)
            iBrushCache = 0;

        ppdev->iBrushCache = iBrushCache;

        // Update our links:

        pbe->prbVerify           = prb;
        prb->pbe = pbe;
    }

    prb->bTransparent = bTransparent;

    ulDstOffset = ((pbe->y * ppdev->lDelta) + (pbe->x * ppdev->cBpp));
    pjPattern = (PBYTE) &prb->aulPattern[0];        // Copy from brush buffer
    cjPattern = PATTERN_SIZE * ppdev->cBpp;
    if ((ppdev->ulChipID != W32P) && (ppdev->ulChipID != ET6000))
    {
        cjPattern *= 4;
    }

    START_DIRECT_ACCESS(ppdev, pjBase);

    if (!ppdev->bAutoBanking)
    {
        // Set the address where we're going to put the pattern data.
        // All data transfers to video memory take place through aperature 0.

        CP_MMU_BP0(ppdev, pjBase, ulDstOffset);
        pjDst = (PBYTE) ppdev->pjMmu0;
    }
    else
    {
        pjDst = ppdev->pjScreen + ulDstOffset;
    }

    RtlCopyMemory(pjDst, pjPattern, cjPattern);

    END_DIRECT_ACCESS(ppdev, pjBase);
}



/**************************************************************************
*
* Does a pattern fill to a list of rectangles.
*
**************************************************************************/

VOID vPatternFillScr(
PDEV*           ppdev,
LONG            c,          // Can't be zero
RECTL*          prcl,       // Array of relative coordinate destination rects
ROP4            rop4,       // Obvious?
RBRUSH_COLOR    rbc,        // Drawing color is rbc.iSolidColor
POINTL*         pptlBrush)  //
{
    BYTE*       pjBase = ppdev->pjBase;
    LONG        lDelta = ppdev->lDelta;
    LONG        cBpp = ppdev->cBpp;
    BOOL        bTransparent;
    ULONG       ulPatternAddrBase;
    ULONG       cTile = 0;
    BRUSHENTRY* pbe;        // Pointer to brush entry data, which is used
                            //   for keeping track of the location and status
                            //   of the pattern bits cached in off-screen
                            //   memory

    DISPDBG((10,"vPatternFillScr called"));

    bTransparent = ((rop4 & 0xff) != (rop4 >> 8));
    ASSERTDD(!bTransparent, "We don't handle transparent brushes yet.");

    if ((ppdev->ulChipID != W32P) && (ppdev->ulChipID != ET6000))
    {
        //
        // Patterns are duplicated horizontally and vertically (4 tiles)
        //

        cTile = 1;  // Look, it means one extra to the right
    }

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    if ((rbc.prb->pbe->prbVerify != rbc.prb))
    {
        vFastPatRealize(ppdev, rbc.prb, NULL, FALSE);
    }

    ASSERTDD(rbc.prb->bTransparent == bTransparent,
             "Not realized with correct transparency");

    pbe = rbc.prb->pbe;

    //
    // Make sure we can write to the video registers.
    //

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

    CP_FG_ROP(ppdev, pjBase, (rop4 >> 8));
    CP_BK_ROP(ppdev, pjBase, (rop4 & 0xff));
    CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta - 1));

    //
    // ### precalc & store the PAT_Y_OFFSET const in the pdev
    //

    CP_PAT_WRAP(ppdev, pjBase, ppdev->w32PatternWrap);
    CP_PAT_Y_OFFSET(ppdev, pjBase, (((PATTERN_OFFSET * cBpp) << cTile) - 1));

    //
    // Fill the list of rectangles
    //

    ulPatternAddrBase = (pbe->y * lDelta) + (pbe->x * cBpp);

    do {
        ULONG offset;

        offset = cBpp * (
            (((prcl->top-pptlBrush->y)&7) << (3+cTile)) +
            ((prcl->left-pptlBrush->x)&7)
        );

        WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

        CP_PAT_ADDR(ppdev, pjBase, (ulPatternAddrBase + offset));

        CP_XCNT(ppdev, pjBase, (((prcl->right - prcl->left) * cBpp) - 1));
        CP_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top - 1));

        // Set the blit destination address as the base address of MMU aperture 2
        // Then start the accelerated operation by writing something to this
        // aperture.

        SET_DEST_ADDR(ppdev, ((prcl->top * lDelta) + (cBpp * prcl->left)));
        START_ACL(ppdev);

        prcl++;

    } while (--c != 0);
}


/**************************************************************************
*
* Does a solid fill to a list of rectangles.
*
**************************************************************************/

VOID vSolidFillScr(
PDEV*           ppdev,
LONG            c,          // Can't be zero
RECTL*          prcl,       // Array of relative coordinate destination rects
ROP4            rop4,       // Obvious?
RBRUSH_COLOR    rbc,        // Drawing color is rbc.iSolidColor
POINTL*         pptlBrush)  // Not used
{
    BYTE*       pjBase = ppdev->pjBase;
    LONG        lDelta = ppdev->lDelta;
    LONG        cBpp = ppdev->cBpp;
    ULONG       ulSolidColor;

    DISPDBG((10,"vSolidFillScr called"));

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD((ppdev->cBpp < 3),
              "vSolidFillScr only works for 8bpp and 16bpp");

    // Make sure we can write to the video registers.

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

    CP_FG_ROP(ppdev, pjBase, (rop4 >> 8));
    CP_BK_ROP(ppdev, pjBase, (rop4 & 0xff));
    CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta - 1));
    CP_PAT_WRAP(ppdev, pjBase, SOLID_COLOR_PATTERN_WRAP);
    CP_PAT_Y_OFFSET(ppdev, pjBase, (SOLID_COLOR_PATTERN_OFFSET - 1));
    CP_PAT_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset);

    ulSolidColor = rbc.iSolidColor;

    if (cBpp == 1)
    {
        ulSolidColor &= 0x000000FF;        //  We may get some extraneous data in the
        ulSolidColor |= ulSolidColor << 8;
    }
    if (cBpp <= 2)
    {
        ulSolidColor &= 0x0000FFFF;
        ulSolidColor |= ulSolidColor << 16;
    }

    // Set the color in offscreen memory

    WAIT_FOR_IDLE_ACL(ppdev, pjBase);

    if (ppdev->bAutoBanking)
    {
        *(PULONG)(ppdev->pjScreen + ppdev->ulSolidColorOffset) = ulSolidColor;
    }
    else
    {
        CP_MMU_BP0(ppdev, pjBase, ppdev->ulSolidColorOffset);
        CP_WRITE_MMU_DWORD(ppdev, 0, 0, ulSolidColor);
    }

    //
    // Fill the list of rectangles
    //

    do {
        WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

        CP_XCNT(ppdev, pjBase, ((prcl->right - prcl->left) * cBpp - 1));
        CP_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top - 1));

        // Set the blt destination address as the base address of MMU aperture 2
        // Then start the accelerated operation by writing something to this
        // aperture.

        SET_DEST_ADDR(ppdev, ((prcl->top * lDelta) + (cBpp * prcl->left)));
        START_ACL(ppdev);

        prcl++;

    } while (--c != 0);
}


VOID vSolidFillScr24(
PDEV*           ppdev,
LONG            c,          // Can't be zero
RECTL*          prcl,       // Array of relative coordinate destination rects
ROP4            rop4,       // Obvious?
RBRUSH_COLOR    rbc,        // Drawing color is rbc.iSolidColor
POINTL*         pptlBrush)  // Not used
{
    BYTE*       pjBase = ppdev->pjBase;
    LONG        lDelta = ppdev->lDelta;
    ULONG       ulSolidColor = rbc.iSolidColor;

    DISPDBG((10,"vSolidFillScr24 called"));

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    ASSERTDD((ppdev->cBpp == 3),
              "vSolidFillScr24 called when not in 24bpp mode");

    ASSERTDD(((ppdev->ulChipID == W32P) || (ppdev->ulChipID == ET6000)),
              "24bpp solid fills only accelerated for w32p/ET6000");

    #define CBPP    3

    //
    // Make sure we can write to the video registers.
    //

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

    CP_FG_ROP(ppdev, pjBase, (rop4 >> 8));
    CP_BK_ROP(ppdev, pjBase, (rop4 & 0xff));
    CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta - 1));
    //
    //  This must be special cased for the ET6000.  I'm not sure why it worked
    //  for the others, because we have a 3 byte wide pattern, but were setting the
    //  pattern wrap for a 4 byte wide pattern.  We were also setting the Y_offset
    //  to be 3 when it should be 2, which really means 3 bytes per line.  Strange.
    //
    //  Anyway, I've left the code for the others in place and it will get executed
    //  for them.
    //

    CP_PAT_WRAP(ppdev, pjBase, SOLID_COLOR_PATTERN_WRAP_24BPP);                 // 1 line, 3 bytes per line
    CP_PAT_Y_OFFSET(ppdev, pjBase, (SOLID_COLOR_PATTERN_OFFSET_24BPP - 1)); // indicates 3 bytes per line

    CP_PAT_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset);

    // Set the color in offscreen memory

    WAIT_FOR_IDLE_ACL(ppdev, pjBase);

    if (ppdev->bAutoBanking)
    {
        *(PULONG)(ppdev->pjScreen + ppdev->ulSolidColorOffset) = ulSolidColor;
    }
    else
    {
        CP_MMU_BP0(ppdev, pjBase, ppdev->ulSolidColorOffset);
        CP_WRITE_MMU_DWORD(ppdev, 0, 0, ulSolidColor);
    }

    //
    // We know that the ACL is idle now, so no wait
    //

    CP_PEL_DEPTH(ppdev, pjBase, HW_PEL_DEPTH_24BPP);

    //
    // Fill the list of rectangles
    //

    do {
        WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

        if (ppdev->ulChipID == ET6000)
        {
            CP_XCNT(ppdev, pjBase, (((prcl->right - prcl->left) * CBPP) - 1));
        }
        else
        {
            CP_XCNT(ppdev, pjBase, ((prcl->right - prcl->left - 1) * CBPP));
        }
        CP_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top - 1));

        // Set the blt destination address as the base address of MMU aperture 2
        // Then start the accelerated operation by writing something to this
        // aperture.

        SET_DEST_ADDR(ppdev, ((prcl->top * lDelta) + (CBPP * prcl->left)));
        START_ACL(ppdev);

        prcl++;

    } while (--c != 0);

    // set pixel depth back to 1
    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_PEL_DEPTH(ppdev, pjBase, HW_PEL_DEPTH_8BPP);
    #undef  CBPP
}


/**************************************************************************
*
* Does a screen-to-screen blt of a list of rectangles.
*
**************************************************************************/

VOID vScrToScr(
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ROP4    rop4,       // Obvious?
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    LONG        dx;
    LONG        dy;     // Add delta to destination to get source

    LONG        xyOffset = ppdev->xyOffset;
    BYTE*       pjBase = ppdev->pjBase;
    LONG        lDelta = ppdev->lDelta;
    LONG        cBpp = ppdev->cBpp;

    DISPDBG((10,"vScrToScr called"));

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    //
    // The src-dst delta will be the same for all rectangles
    //

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    //
    // Make sure we can write to the video registers.
    //

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

    CP_FG_ROP(ppdev, pjBase, (rop4 >> 8));
    CP_BK_ROP(ppdev, pjBase, (rop4 & 0xff));
    CP_SRC_WRAP(ppdev, pjBase, NO_PATTERN_WRAP);
    CP_SRC_Y_OFFSET(ppdev, pjBase, (lDelta - 1));
    CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta - 1));

    // ### I don't think this is necessary - WAIT_FOR_IDLE_ACL(ppdev, pjBase);

    //
    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:
    //

    if (!OVERLAP(prclDst, pptlSrc))
        goto Top_Down_Left_To_Right;

    if (prclDst->top <= pptlSrc->y)
    {
        if (prclDst->left <= pptlSrc->x)
        {

Top_Down_Left_To_Right:

            //
            // Top to Bottom - Left to Right
            //

            DISPDBG((12,"Top to Bottom - Left to Right"));

            CP_XY_DIR(ppdev, pjBase, 0);  // Top to Bottom - Left to Right

            do {

                WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

                CP_XCNT(ppdev, pjBase, (cBpp * (prcl->right - prcl->left) - 1));
                CP_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top - 1));

                CP_SRC_ADDR(ppdev, pjBase, (xyOffset + ((prcl->top + dy) * lDelta) + cBpp * (prcl->left + dx)));

                // Set the blt destination address as the base address of MMU aperture 2
                // Then start the accelerated operation by writing something to this
                // aperture.

                SET_DEST_ADDR(ppdev, ((prcl->top * lDelta) + (cBpp * prcl->left)));
                START_ACL(ppdev);

                prcl++;

            } while (--c != 0);
        }
        else
        {
            //
            // Top to Bottom - Right to left
            //

            DISPDBG((12,"Top to Bottom - Right to left"));

            CP_XY_DIR(ppdev, pjBase, RIGHT_TO_LEFT);

            do {

                WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

                CP_XCNT(ppdev, pjBase, (cBpp * (prcl->right - prcl->left) - 1));
                CP_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top - 1));

                CP_SRC_ADDR(ppdev, pjBase, (xyOffset + ((prcl->top + dy) * lDelta) + cBpp * (prcl->right + dx) - 1));

                // Set the blt destination address as the base address of MMU aperture 2
                // Then start the accelerated operation by writing something to this
                // aperture.

                SET_DEST_ADDR(ppdev, ((prcl->top * lDelta) + (cBpp * prcl->right) - 1));
                START_ACL(ppdev);

                prcl++;

            } while (--c != 0);
        }
    }
    else
    {
        if (prclDst->left <= pptlSrc->x)
        {
            //
            // Bottom to Top - Left to Right
            //

            DISPDBG((12,"Bottom to Top - Left to Right"));

            CP_XY_DIR(ppdev, pjBase, BOTTOM_TO_TOP);

            do {

                WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

                CP_XCNT(ppdev, pjBase, (cBpp * (prcl->right - prcl->left) - 1));
                CP_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top - 1));

                CP_SRC_ADDR(ppdev, pjBase, (xyOffset + ((prcl->bottom - 1 + dy) * lDelta) + cBpp * (prcl->left + dx)));

                // Set the blt destination address as the base address of MMU aperture 2
                // Then start the accelerated operation by writing something to this
                // aperture.

                SET_DEST_ADDR(ppdev, (((prcl->bottom - 1) * lDelta) + (cBpp * prcl->left)));
                START_ACL(ppdev);

                prcl++;

            } while (--c != 0);
        }
        else
        {
            //
            // Bottom to Top - Right to Left
            //

            DISPDBG((12,"Bottom to Top - Right to Left"));

            CP_XY_DIR(ppdev, pjBase, (BOTTOM_TO_TOP | RIGHT_TO_LEFT));

            do {

                WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

                CP_XCNT(ppdev, pjBase, (cBpp * (prcl->right - prcl->left) - 1));
                CP_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top - 1));

                CP_SRC_ADDR(ppdev, pjBase, (xyOffset + ((prcl->bottom - 1 + dy) * lDelta) + cBpp * (prcl->right + dx) - 1));

                // Set the blt destination address as the base address of MMU aperture 2
                // Then start the accelerated operation by writing something to this
                // aperture.

                SET_DEST_ADDR(ppdev, (((prcl->bottom - 1) * lDelta) + cBpp * (prcl->right) - 1));
                START_ACL(ppdev);

                prcl++;

            } while (--c != 0);
        }
    }

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_XY_DIR(ppdev, pjBase, 0);  // Top to Bottom - Left to Right
}

/**************************************************************************
*
* Does a monochrome expansion to video memory.
*
* Make this Xfer1to8bpp and create another for Xfer1to16bpp?
*
**************************************************************************/

VOID vSlowXfer1bpp(     // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // Actually had better be a rop3
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides color-expansion information
{
    LONG        dx;
    LONG        dy;
    LONG        lSrcDelta;
    BYTE*       pjSrcScan0;
    BYTE*       pjSrc;
    LONG        cjSrc;
    LONG        cjTrail;
    LONG        culSrc;
    BYTE        jFgRop3;
    BYTE        jBgRop3;
    BOOL        bW32p;

    ULONG       ulSolidColorOffset  = ppdev->ulSolidColorOffset;
    BYTE*       pjBase              = ppdev->pjBase;
    LONG        lDelta              = ppdev->lDelta;
    LONG        cBpp                = ppdev->cBpp;
    ULONG       ulFgColor           = pxlo->pulXlate[1];
    ULONG       ulBgColor           = pxlo->pulXlate[0];

    LONG        xyOffset = (ppdev->cBpp * ppdev->xOffset) +
                           (ppdev->yOffset * ppdev->lDelta);



    DISPDBG((10,"vSlowXfer1bpp called"));

    DISPDBG((11,"rop4(%04x)", rop4));

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(pptlSrc != NULL && psoSrc != NULL, "Can't have NULL sources");
    ASSERTDD(ppdev->cBpp <= 2, "vSlowXfer1bpp doesn't work at 24 bpp");

    bW32p = (ppdev->ulChipID == W32P);

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

    jFgRop3 = (BYTE)(rop4 >> 8);    // point to src color where src is indicated
                                    // point to pat color where src is indicated

    if ((BYTE) rop4 != R3_NOP)
    {
        jBgRop3 = (BYTE)((rop4 & 0xc3) | ((rop4 & 0xf0) >> 2));
    }
    else
    {
        jBgRop3 = (BYTE) rop4;
    }

    DISPDBG((11,"jFgRop3(%04x), jBgRop3(%04x)", jFgRop3, jBgRop3));

    CP_FG_ROP(ppdev, pjBase, jFgRop3);
    CP_BK_ROP(ppdev, pjBase, jBgRop3);
    CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta - 1));

    CP_PAT_WRAP(ppdev, pjBase, SOLID_COLOR_PATTERN_WRAP);
    CP_PAT_Y_OFFSET(ppdev, pjBase, (SOLID_COLOR_PATTERN_OFFSET - 1));
    CP_SRC_WRAP(ppdev, pjBase, SOLID_COLOR_PATTERN_WRAP);
    CP_SRC_Y_OFFSET(ppdev, pjBase, (SOLID_COLOR_PATTERN_OFFSET - 1));
    CP_PAT_ADDR(ppdev, pjBase, ulSolidColorOffset + 4);
    CP_SRC_ADDR(ppdev, pjBase, ulSolidColorOffset);

    {
        //
        // Set the address where we're going to put the solid color data.
        // All data transfers to video memory take place through aperature 0.
        //

        WAIT_FOR_IDLE_ACL(ppdev, pjBase);

        CP_MMU_BP0(ppdev, pjBase, ppdev->ulSolidColorOffset);

        //
        // Set the color in offscreen memory
        //

        if (cBpp == 1)
        {
            ulFgColor |= ulFgColor << 8;
            ulBgColor |= ulBgColor << 8;
        }
        if (cBpp <= 2)
        {
            ulFgColor |= ulFgColor << 16;
            ulBgColor |= ulBgColor << 16;
        }

        CP_WRITE_MMU_DWORD(ppdev, 0, 0, ulFgColor);
        CP_WRITE_MMU_DWORD(ppdev, 0, 4, ulBgColor);
    }

    CP_ROUTING_CTRL(ppdev, pjBase, CPU_MIX_DATA);

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;      // Add to destination to get source

    pjSrcScan0 = psoSrc->pvScan0;

    DISPDBG((2,"lSrcDelta(%x)", psoSrc->lDelta));

    do {
        ULONG   ulDst;
        RECTL   rclSrc;
        RECTL   rclDst;
        LONG    xBitsPad;
        LONG    xBitsUsed;
        LONG    xBytesPad;

        //
        // load lSrcDelta inside the loop because we adjust it later.
        //

        lSrcDelta  = psoSrc->lDelta;

        rclDst          = *prcl;
        rclSrc.left     = rclDst.left + dx;
        rclSrc.right    = rclDst.right + dx;
        rclSrc.top      = rclDst.top + dy;
        rclSrc.bottom   = rclDst.bottom + dy;

        // x = prcl->left;
        // y = prcl->top;

        //
        // Calculate number of bits used in first partial.
        //

        xBitsPad  = rclSrc.left & 7;
        xBitsUsed = min((8-xBitsPad),(rclSrc.right-rclSrc.left));
        xBytesPad = rclDst.left & 3;

        if (xBitsPad != 0) // (0 < xBitsUsed < 8)
        {

            DISPDBG((2,"xBitsUsed(%d) xBitsPad(%d)", xBitsUsed, xBitsPad));
            DISPDBG((2,"rclSrc(%d,%d,%d,%d) rclDst(%d,%d,%d,%d)",
                 rclSrc.left,
                 rclSrc.top,
                 rclSrc.right,
                 rclSrc.bottom,
                 rclDst.left,
                 rclDst.top,
                 rclDst.right,
                 rclDst.bottom));

            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

            // Do the column of the first xBitsUsed pixels

            if (!bW32p)
            {
                CP_BUS_SIZE(ppdev, pjBase, VIRTUAL_BUS_8_BIT);
            }

            CP_XCNT(ppdev, pjBase, ((xBitsUsed * cBpp) - 1));
            CP_YCNT(ppdev, pjBase, (rclDst.bottom - rclDst.top - 1));

            pjSrc = pjSrcScan0 + rclSrc.top * lSrcDelta
                               + (rclSrc.left >> 3);

            ulDst = (rclDst.top * lDelta) + (cBpp * rclDst.left);
            ulDst += xyOffset;

            if (bW32p)
            {
                // We will align the data ourselves.
                CP_MIX_ADDR(ppdev, pjBase, 0);
                CP_MIX_Y_OFFSET(ppdev, pjBase, -1);
            }

            CP_MMU_BP2(ppdev, pjBase, ulDst);

            CP_DST_ADDR(ppdev, pjBase, ulDst);

            if (bW32p) WAIT_FOR_BUSY_ACL(ppdev, pjBase);

            if (cBpp == 1)
            {
                LONG i;

                for (i = rclDst.bottom - rclDst.top; i; i--)
                {
                    CP_WRITE_MMU_BYTE(ppdev, 2, 0, jReverse[(*pjSrc << xBitsPad) & 0xff]);
                    pjSrc += lSrcDelta;
                }
            }
            else // if (cBpp == 2)
            {
                LONG i;
                WORD wTmp;
                BYTE * pjCvt = (BYTE *) &wTmp;

                for (i = rclDst.bottom - rclDst.top; i; i--)
                {
                    wTmp = wReverse2x[(*pjSrc << xBitsPad) & 0xff];
                    CP_WRITE_MMU_BYTE(ppdev, 2, 0, pjCvt[0]);
                    if (xBitsUsed > 4)
                    {
                        CP_WRITE_MMU_BYTE(ppdev, 2, 1, pjCvt[1]);
                    }
                    pjSrc += lSrcDelta;
                }
            }

            rclSrc.left += xBitsUsed;
            rclDst.left += xBitsUsed;
        }

        // If the entire blt wasn't contained in the first partial byte,
        // the we have to do the rest.

        if (rclSrc.left < rclSrc.right)
        {
            DISPDBG((2,"rclSrc(%d,%d,%d,%d) rclDst(%d,%d,%d,%d)",
                 rclSrc.left,
                 rclSrc.top,
                 rclSrc.right,
                 rclSrc.bottom,
                 rclDst.left,
                 rclDst.top,
                 rclDst.right,
                 rclDst.bottom));

            //
            // Legend has it that we need a WAIT_FOR_IDLE_ACL, instead of just
            // a WAIT_FOR_EMPTY_ACL_QUEUE, to prevent hanging W32
            //

            WAIT_FOR_IDLE_ACL(ppdev, pjBase);

            if (!bW32p)
            {
                CP_BUS_SIZE(ppdev, pjBase, VIRTUAL_BUS_32_BIT);
            }

            CP_XCNT(ppdev, pjBase, (cBpp * (rclDst.right - rclDst.left) - 1));
            CP_YCNT(ppdev, pjBase, (rclDst.bottom - rclDst.top - 1));

            cjSrc = (((rclSrc.right * cBpp) + 7) >> 3) -
                     ((rclSrc.left * cBpp) >> 3);     // # bytes to transfer

            culSrc = (cjSrc >> 2);
            cjTrail = (cjSrc & 3);

            DISPDBG((2,"cjSrc(%d)", cjSrc));
            DISPDBG((2,"culSrc(%d)", culSrc));
            DISPDBG((2,"cjTrail(%d)", cjTrail));

            pjSrc = pjSrcScan0 + rclSrc.top * lSrcDelta
                               + (rclSrc.left >> 3);

            DISPDBG((2,"pjSrc(%x)", pjSrc));

            ulDst = (rclDst.top * lDelta) + (cBpp * rclDst.left);
            ulDst += xyOffset;

            if (bW32p)
            {
                // We will align the data ourselves.
                CP_MIX_ADDR(ppdev, pjBase, 0);
                CP_MIX_Y_OFFSET(ppdev, pjBase, -1);
            }
            CP_MMU_BP2(ppdev, pjBase, ulDst);

            CP_DST_ADDR(ppdev, pjBase, ulDst);

            if (bW32p) WAIT_FOR_BUSY_ACL(ppdev, pjBase);

            {
                LONG i;
                LONG j;

                if (cBpp == 1)
                {
                    lSrcDelta -= cjSrc;

                    for (i = rclDst.bottom - rclDst.top; i; i--)
                    {
                        ULONG cjTmp = cjTrail;
                        volatile BYTE * pjTmp;
                        volatile ULONG * pulTmp;

                        DISPDBG((2,"pjSrc(%x)", pjSrc));

                        for (j = culSrc; j; j--)
                        {
                            ULONG ulTmp = 0;

                            ulTmp |= (ULONG)jReverse[*pjSrc++];
                            ulTmp |= (ULONG)jReverse[*pjSrc++] << 8;
                            ulTmp |= (ULONG)jReverse[*pjSrc++] << 16;
                            ulTmp |= (ULONG)jReverse[*pjSrc++] << 24;
                            CP_WRITE_MMU_DWORD(ppdev, 2, 0, ulTmp);

                            DISPDBG((2,"Src(%08x) Tmp(%08x)",
                                *((ULONG *)(pjSrc-4)),
                                ulTmp
                                ));
                        }

                        if (bW32p)
                        {
                            int ndx = 0;
                            while (cjTmp--)
                            {
                                CP_WRITE_MMU_BYTE(ppdev, 2, ndx, jReverse[*pjSrc]);
                                pjSrc++;
                                ndx++;
                            }
                        }
                        else
                        {
                            if (cjTmp)
                            {
                                ULONG ulTmp = 0;
                                if (cjTmp == 1) goto do_1_byte;
                                if (cjTmp == 2) goto do_2_bytes;

                                //
                                // do all three bytes of the partial
                                //

                                ulTmp |= (ULONG)jReverse[pjSrc[2]] << 16;
do_2_bytes:
                                ulTmp |= (ULONG)jReverse[pjSrc[1]] << 8;
do_1_byte:
                                ulTmp |= (ULONG)jReverse[pjSrc[0]];

                                //*pulTmp = ulTmp;
                                CP_WRITE_MMU_DWORD(ppdev, 2, 0, ulTmp);

                                pjSrc += cjTmp;
                            }
                        }

                        pjSrc += lSrcDelta;
                    }
                }
                else // if (cBpp == 2)
                {
                    lSrcDelta -= (cjSrc + 1) >> 1;

                    for (i = rclDst.bottom - rclDst.top; i; i--)
                    {
                        ULONG cjTmp = cjTrail;
                        int ndx = 0;

                        DISPDBG((2,"pjSrc(%x)", pjSrc));

                        for (j = culSrc; j; j--)
                        {
                            ULONG ulTmp;

                            ulTmp = (ULONG)wReverse2x[*pjSrc++];
                            ulTmp |= (ULONG)wReverse2x[*pjSrc++] << 16;
                            CP_WRITE_MMU_DWORD(ppdev, 2, 0, ulTmp);
                        }

                        if (bW32p)
                        {
                            while (cjTmp--)
                            {
                                WORD wCvt;
                                BYTE * pjCvt = (BYTE *) &wCvt;

                                wCvt = wReverse2x[*pjSrc++];
                                CP_WRITE_MMU_BYTE(ppdev, 2, ndx, pjCvt[0]);
                                ndx++;
                                if (cjTmp)
                                {
                                    CP_WRITE_MMU_BYTE(ppdev, 2, ndx, pjCvt[1]);
                                    ndx++;
                                    cjTmp--;
                                }
                            }
                        }
                        else
                        {
                            if (cjTmp)
                            {
                                ULONG ulTmp;

                                ulTmp = (ULONG)wReverse2x[pjSrc[0]];
                                ulTmp |= (ULONG)wReverse2x[pjSrc[1]] << 16;
                                CP_WRITE_MMU_DWORD(ppdev, 2, 0, ulTmp);

                                pjSrc += (cjTmp+1) >> 1;
                            }
                        }

                        pjSrc += lSrcDelta;
                    }
                }
            }
        }

        prcl++;
    } while (--c != 0);

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, 0);
    if (!bW32p)
    {
        CP_BUS_SIZE(ppdev, pjBase, VIRTUAL_BUS_8_BIT);
    }
}

VOID vXferBlt8i(
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ROP4        rop4,       // Obvious?
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    BYTE*       pjBase              = ppdev->pjBase;
    BYTE*       pjSrcScan0          = (BYTE*) psoSrc->pvScan0;
    LONG        lDeltaDst           = ppdev->lDelta;
    LONG        lDeltaSrc           = psoSrc->lDelta;
    POINTL      ptlSrc              = *pptlSrc;
    RECTL       rclDst              = *prclDst;
    LONG        cBpp                = ppdev->cBpp;
    SIZEL       sizlBlt;
    ULONG       ulDstAddr;
    BYTE*       pjSrc;
    INT         ix, iy;
    LONG        dx;
    LONG        dy;                 // Add delta to destination to get source
    LONG        cjLead;
    LONG        cjTrail;
    LONG        culMiddle;
    LONG        xyOffset = (cBpp * ppdev->xOffset) +
                           (lDeltaDst * ppdev->yOffset);

    //
    // The src-dst delta will be the same for all rectangles
    //

    dx = ptlSrc.x - rclDst.left;
    dy = ptlSrc.y - rclDst.top;

    // Note: Legend has it that if we don't wait for the ACL to become idle,
    //       then the code will hang on the W32, but not on the W32i.
    //
    //       Since we do a WAIT_FOR_IDLE_ACL we don't need to
    //       WAIT_FOR_EMPTY_ACL_QUEUE

    WAIT_FOR_IDLE_ACL(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, CPU_SOURCE_DATA);
    CP_FG_ROP(ppdev, pjBase, (rop4 >> 8));
    CP_DST_Y_OFFSET(ppdev, pjBase, (lDeltaDst - 1));

    do {
        // Calculate blt dimensions in bytes

        sizlBlt.cx = cBpp * (prcl->right - prcl->left);
        sizlBlt.cy = prcl->bottom - prcl->top;

        pjSrc = pjSrcScan0 +
                ((prcl->top + dy) * lDeltaSrc) +
                ((prcl->left + dx) * cBpp);

        cjTrail = cjLead = (LONG)((ULONG_PTR)pjSrc);
        cjLead = aulLeadCnt[cjLead & 3];
        if (cjLead < sizlBlt.cx)
        {
            cjTrail += sizlBlt.cx;
            cjTrail &= 3;
            culMiddle = (sizlBlt.cx - (cjLead + cjTrail)) >> 2;
        }
        else
        {
            cjLead = sizlBlt.cx;
            cjTrail = 0;
            culMiddle = 0;
        }

        ASSERTDD(culMiddle >= 0, "vXferBlt8i: culMiddle < 0");

        ulDstAddr = (prcl->top * lDeltaDst) +
                    (prcl->left * cBpp) +
                    (xyOffset);

        if ((sizlBlt.cx - (cjLead + cjTrail)) & 3)
            DISPDBG((0, "WARNING: cx - (cjLead+cjTail) not multiple of 4"));

        DISPDBG((8, "rclSrc(%d,%d,%d,%d)",
                    prcl->left+dx,
                    prcl->top+dy,
                    prcl->right+dx,
                    prcl->bottom+dy
               ));

        DISPDBG((8, "rclDst(%d,%d,%d,%d)",
                    prcl->left,
                    prcl->top,
                    prcl->right,
                    prcl->bottom
               ));

        DISPDBG((8, "pjSrc(%x) cx(%d) ulDstAddr(%xh) (%d,%d,%d)",
                    pjSrc,
                    sizlBlt.cx,
                    ulDstAddr,
                    cjLead,
                    culMiddle,
                    cjTrail
               ));

        if (cjLead)
        {
            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            CP_XCNT(ppdev, pjBase, (cjLead - 1));
            CP_YCNT(ppdev, pjBase, (sizlBlt.cy - 1));
            CP_MMU_BP2(ppdev, pjBase, (ulDstAddr));
            afnXferI_Narrow[cjLead](ppdev,
                                    pjSrc,
                                    0,
                                    sizlBlt.cy,
                                    lDeltaSrc);
        }

        if (cjTrail)
        {
            LONG cjOffset = cjLead + (culMiddle<<2);
            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            CP_XCNT(ppdev, pjBase, (cjTrail - 1));
            CP_YCNT(ppdev, pjBase, (sizlBlt.cy - 1));
            CP_MMU_BP2(ppdev, pjBase, (ulDstAddr+cjOffset));
            afnXferI_Narrow[cjTrail](ppdev,
                                     (pjSrc+cjOffset),
                                     0,
                                     sizlBlt.cy,
                                     lDeltaSrc);
        }

        if (culMiddle)
        {
            LONG cjOffset = cjLead;
            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            CP_XCNT(ppdev, pjBase, ((culMiddle<<2) - 1));
            CP_YCNT(ppdev, pjBase, (sizlBlt.cy - 1));
            CP_BUS_SIZE(ppdev, pjBase, VIRTUAL_BUS_32_BIT);
            CP_MMU_BP2(ppdev, pjBase, (ulDstAddr+cjOffset));
            vXfer_DWORDS(ppdev,
                         (pjSrc+cjOffset),
                         culMiddle,
                         sizlBlt.cy,
                         lDeltaSrc);
            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            CP_BUS_SIZE(ppdev, pjBase, VIRTUAL_BUS_8_BIT);
        }

        prcl++;
    } while (--c != 0);

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, 0);
}

VOID vXferBlt8p(
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ROP4        rop4,       // Obvious?
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    BYTE*       pjBase              = ppdev->pjBase;
    BYTE*       pjSrcScan0          = (BYTE*) psoSrc->pvScan0;
    LONG        lDeltaDst           = ppdev->lDelta;
    LONG        lDeltaSrc           = psoSrc->lDelta;
    POINTL      ptlSrc              = *pptlSrc;
    RECTL       rclDst              = *prclDst;
    LONG        cBpp                = ppdev->cBpp;
    SIZEL       sizlBlt;
    ULONG       ulDstAddr;
    BYTE*       pjSrc;
    INT         ix, iy;
    LONG        dx;
    LONG        dy;                 // Add delta to destination to get source
    LONG        iLeadNdx;
    LONG        cjLead;
    LONG        cjTrail;
    LONG        culMiddle;
    LONG        xyOffset = (cBpp * ppdev->xOffset) +
                           (lDeltaDst * ppdev->yOffset);

    //
    // The src-dst delta will be the same for all rectangles
    //

    dx = ptlSrc.x - rclDst.left;
    dy = ptlSrc.y - rclDst.top;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, CPU_SOURCE_DATA);
    CP_FG_ROP(ppdev, pjBase, (rop4 >> 8));
    CP_DST_Y_OFFSET(ppdev, pjBase, (lDeltaDst - 1));
    CP_SRC_ADDR(ppdev, pjBase, 0);
    CP_SRC_Y_OFFSET(ppdev, pjBase, -1);

    do {
        // Calculate blt dimensions in bytes

        sizlBlt.cx = cBpp * (prcl->right - prcl->left);
        sizlBlt.cy = prcl->bottom - prcl->top;

        pjSrc = pjSrcScan0 +
                ((prcl->top + dy) * lDeltaSrc) +
                ((prcl->left + dx) * cBpp);

        cjTrail = iLeadNdx = (LONG)((ULONG_PTR)pjSrc);
        iLeadNdx &= 3;
        cjLead = aulLeadCnt[iLeadNdx];
        if (cjLead < sizlBlt.cx)
        {
            cjTrail += sizlBlt.cx;
            cjTrail &= 3;
            culMiddle = (sizlBlt.cx - (cjLead + cjTrail)) >> 2;
        }
        else
        {
            cjLead = sizlBlt.cx;
            cjTrail = 0;
            culMiddle = 0;
        }

        ASSERTDD(culMiddle >= 0, "vXferBlt8i: culMiddle < 0");

        ulDstAddr = (prcl->top * lDeltaDst) +
                    (prcl->left * cBpp) +
                    (xyOffset);

        if ((sizlBlt.cx - (cjLead + cjTrail)) & 3)
            DISPDBG((0, "WARNING: cx - (cjLead+cjTail) not multiple of 4"));

        DISPDBG((8, "rclSrc(%d,%d,%d,%d)",
                    prcl->left+dx,
                    prcl->top+dy,
                    prcl->right+dx,
                    prcl->bottom+dy
               ));

        DISPDBG((8, "rclDst(%d,%d,%d,%d)",
                    prcl->left,
                    prcl->top,
                    prcl->right,
                    prcl->bottom
               ));

        DISPDBG((8, "pjSrc(%x) cx(%d) ulDstAddr(%xh) (%d,%d,%d)",
                    pjSrc,
                    sizlBlt.cx,
                    ulDstAddr,
                    cjLead,
                    culMiddle,
                    cjTrail
               ));

        if (cjLead)
        {
            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            CP_XCNT(ppdev, pjBase, (cjLead - 1));
            CP_YCNT(ppdev, pjBase, (sizlBlt.cy - 1));
            // The next two turn off src to dst alignment
            CP_DST_ADDR(ppdev, pjBase, (ulDstAddr));
            WAIT_FOR_BUSY_ACL(ppdev, pjBase);
            afnXferP_Narrow[cjLead](ppdev,
                                    pjSrc,
                                    0,
                                    sizlBlt.cy,
                                    lDeltaSrc);
        }

        if (cjTrail)
        {
            LONG cjOffset = cjLead + (culMiddle<<2);
            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            CP_XCNT(ppdev, pjBase, (cjTrail - 1));
            CP_YCNT(ppdev, pjBase, (sizlBlt.cy - 1));
            // The next two turn off src to dst alignment
            CP_DST_ADDR(ppdev, pjBase, (ulDstAddr+cjOffset));
            WAIT_FOR_BUSY_ACL(ppdev, pjBase);
            afnXferP_Narrow[cjTrail](ppdev,
                                     (pjSrc+cjOffset),
                                     0,
                                     sizlBlt.cy,
                                     lDeltaSrc);
        }

        if (culMiddle)
        {
            LONG cjOffset = cjLead;
            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            CP_XCNT(ppdev, pjBase, ((culMiddle<<2) - 1));
            CP_YCNT(ppdev, pjBase, (sizlBlt.cy - 1));
            // The next two turn off src to dst alignment
            CP_DST_ADDR(ppdev, pjBase, (ulDstAddr+cjOffset));
            WAIT_FOR_BUSY_ACL(ppdev, pjBase);
            vXfer_DWORDS(ppdev,
                         (pjSrc+cjOffset),
                         culMiddle,
                         sizlBlt.cy,
                         lDeltaSrc);
        }

        prcl++;
    } while (--c != 0);

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, 0);
}



//////////////////////////////////////////////////////////////////////
// N DWORD low level blt routines for vXferNativeI and vXferNativeP


// A DWORD at a time

VOID vXfer_DWORDS(PPDEV ppdev, BYTE* pjSrc, LONG culX, LONG cy, LONG lDeltaSrc)
{
    LONG    iy;
    LONG    ix;
    BYTE*   pjTmp = pjSrc;
    BYTE*   pjBase = ppdev->pjBase;

    // We had better be in 32 bit virtual bus mode

    for (iy = 0; iy < cy; iy++)
    {
        for (ix = 0; ix < culX; ix++)
        {
            CP_WRITE_MMU_DWORD(ppdev, 2, 0, *((ULONG*)pjTmp));
            pjTmp += 4;
        }
        pjTmp = (pjSrc += lDeltaSrc);
    }
}

// A BYTE at a time

VOID vXfer_BYTES(PPDEV ppdev, BYTE* pjSrc, LONG culX, LONG cy, LONG lDeltaSrc)
{
    LONG    iy;
    LONG    ix;
    BYTE*   pjTmp = pjSrc;
    BYTE*   pjBase = ppdev->pjBase;
    LONG    cjX = (culX << 2);

    // We had better be in 8 bit virtual bus mode

    for (iy = 0; iy < cy; iy++)
    {
        for (ix = 0; ix < cjX; ix++)
        {
            CP_WRITE_MMU_BYTE(ppdev, 2, 0, *pjTmp);
            pjTmp++;
        }
        pjTmp = (pjSrc += lDeltaSrc);
    }
}

//////////////////////////////////////////////////////////////////////
// Narrow low level blt routines for vXferNativeI

VOID vXferI_1_Byte(PPDEV ppdev, BYTE* pjSrc, LONG culX, LONG cy, LONG lDeltaSrc)
{
    LONG    iy;
    LONG    ix;
    BYTE*   pjTmp = pjSrc;
    BYTE*   pjBase = ppdev->pjBase;

    for (iy = 0; iy < cy; iy++)
    {
        CP_WRITE_MMU_BYTE(ppdev, 2, 0, *pjSrc);

        pjSrc += lDeltaSrc;
    }
}

VOID vXferI_2_Bytes(PPDEV ppdev, BYTE* pjSrc, LONG culX, LONG cy, LONG lDeltaSrc)
{
    LONG    iy;
    LONG    ix;
    BYTE*   pjTmp = pjSrc;
    BYTE*   pjBase = ppdev->pjBase;

    for (iy = 0; iy < cy; iy++)
    {
        CP_WRITE_MMU_BYTE(ppdev, 2, 0, *pjTmp);     pjTmp++;
        CP_WRITE_MMU_BYTE(ppdev, 2, 0, *pjTmp);

        pjTmp = (pjSrc += lDeltaSrc);
    }
}

VOID vXferI_3_Bytes(PPDEV ppdev, BYTE* pjSrc, LONG culX, LONG cy, LONG lDeltaSrc)
{
    LONG    iy;
    LONG    ix;
    BYTE*   pjTmp = pjSrc;
    BYTE*   pjBase = ppdev->pjBase;

    for (iy = 0; iy < cy; iy++)
    {
        CP_WRITE_MMU_BYTE(ppdev, 2, 0, *pjTmp);     pjTmp++;
        CP_WRITE_MMU_BYTE(ppdev, 2, 0, *pjTmp);     pjTmp++;
        CP_WRITE_MMU_BYTE(ppdev, 2, 0, *pjTmp);

        pjTmp = (pjSrc += lDeltaSrc);
    }
}

//////////////////////////////////////////////////////////////////////
// Narrow low level blt routines for vXferNativeP

VOID vXferP_1_Byte(PPDEV ppdev, BYTE* pjSrc, LONG index, LONG cy, LONG lDeltaSrc)
{
    LONG    iy;
    LONG    ix;
    BYTE*   pjTmp = pjSrc;
    BYTE*   pjBase = ppdev->pjBase;

    for (iy = 0; iy < cy; iy++)
    {
        CP_WRITE_MMU_BYTE(ppdev, 2, index, *pjSrc);

        pjSrc += lDeltaSrc;
    }
}

VOID vXferP_2_Bytes(PPDEV ppdev, BYTE* pjSrc, LONG index, LONG cy, LONG lDeltaSrc)
{
    LONG    iy;
    LONG    ix;
    BYTE*   pjTmp = pjSrc;
    BYTE*   pjBase = ppdev->pjBase;

    for (iy = 0; iy < cy; iy++)
    {
        CP_WRITE_MMU_WORD(ppdev, 2, index, *((WORD*)pjTmp));

        pjTmp = (pjSrc += lDeltaSrc);
    }
}

VOID vXferP_3_Bytes(PPDEV ppdev, BYTE* pjSrc, LONG index, LONG cy, LONG lDeltaSrc)
{
    LONG    iy;
    LONG    ix;
    BYTE*   pjTmp = pjSrc;
    BYTE*   pjBase = ppdev->pjBase;

    if (index & 1)
    {
        for (iy = 0; iy < cy; iy++)
        {
            CP_WRITE_MMU_BYTE(ppdev, 2, index, *pjTmp);
            pjTmp++;
            CP_WRITE_MMU_WORD(ppdev, 2, index+1, *((WORD*)pjTmp));


            pjTmp = (pjSrc += lDeltaSrc);
        }
    }
    else
    {
        for (iy = 0; iy < cy; iy++)
        {
            CP_WRITE_MMU_WORD(ppdev, 2, index, *((WORD*)pjTmp));
            pjTmp+=2;
            CP_WRITE_MMU_BYTE(ppdev, 2, index+2, *pjTmp);


            pjTmp = (pjSrc += lDeltaSrc);
        }
    }
}

//  This routine was added to perform accelerated host to screen blts for the
//  ET6000.  The W32 had a path from host memory to display memory which allowed
//  ROPs to be performed as the data was transferred.  The ET6000 does not have
//  that feature, so to provide accelerated host to screen support we must
//  buffer each scanline of the source in offscreen memory and then perform
//  a blt to move it into the appropriate area of display memory.  This is
//  much more efficient than hand coding each rop or punting to GDI.

VOID vXferET6000(
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ROP4        rop4,       // Obvious?
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    BYTE*       pjBase              = ppdev->pjBase;
    BYTE*       pjSrcScan0          = (BYTE*) psoSrc->pvScan0;
    LONG        lDeltaDst           = ppdev->lDelta;
    LONG        lDeltaSrc           = psoSrc->lDelta;
    POINTL      ptlSrc              = *pptlSrc;
    RECTL       rclDst              = *prclDst;
    LONG        cBpp                = ppdev->cBpp;
    SIZEL       sizlBlt;
    ULONG       ulDstAddr;
    BYTE*       pjSrc;
    BYTE*       pjDst;
    INT         ix, iy;
    LONG        dx;
    LONG        dy;                 // Add delta to destination to get source
    LONG        iLeadNdx;
    LONG        cjLead;
    LONG        cjTrail;
    LONG        culMiddle;
    LONG        xyOffset = (cBpp * ppdev->xOffset) +
                           (lDeltaDst * ppdev->yOffset);
    ULONG       ulBltBufferOffset = (cBpp * ppdev->pohBltBuffer->x) +
                                    (lDeltaDst * ppdev->pohBltBuffer->y);
    ULONG       BltScanOffset = 0;

    //
    // The src-dst delta will be the same for all rectangles
    //

    dx = ptlSrc.x - rclDst.left;
    dy = ptlSrc.y - rclDst.top;

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_FG_ROP(ppdev, pjBase, (rop4 >> 8));
    CP_BK_ROP(ppdev, pjBase, (rop4 & 0xff));
    CP_SRC_WRAP(ppdev, pjBase, NO_PATTERN_WRAP);
    CP_SRC_Y_OFFSET(ppdev, pjBase, (lDeltaDst - 1));
    CP_DST_Y_OFFSET(ppdev, pjBase, (lDeltaDst - 1));

    do
    {
        BYTE*   pjTmp;

        // Calculate blt dimensions in bytes

        sizlBlt.cx = cBpp * (prcl->right - prcl->left);
        sizlBlt.cy = prcl->bottom - prcl->top;

        pjSrc = pjSrcScan0 +
                ((prcl->top + dy) * lDeltaSrc) +
                ((prcl->left + dx) * cBpp);

        pjTmp = pjSrc;

        cjTrail = iLeadNdx = (LONG)((ULONG_PTR)pjSrc);
        iLeadNdx &= 3;
        cjLead = aulLeadCnt[iLeadNdx];
        if (cjLead < sizlBlt.cx)
        {
            cjTrail += sizlBlt.cx;
            cjTrail &= 3;
            culMiddle = (sizlBlt.cx - (cjLead + cjTrail)) >> 2;
        }
        else
        {
            cjLead = sizlBlt.cx;
            cjTrail = 0;
            culMiddle = 0;
        }

        ASSERTDD(culMiddle >= 0, "vXferET6000: culMiddle < 0");

        ulDstAddr = (prcl->top * lDeltaDst) +
                    (prcl->left * cBpp) +
                    (xyOffset);

        if ((sizlBlt.cx - (cjLead + cjTrail)) & 3)
            DISPDBG((0, "WARNING: cx - (cjLead+cjTail) not multiple of 4"));

        DISPDBG((8, "rclSrc(%d,%d,%d,%d)",
                    prcl->left+dx,
                    prcl->top+dy,
                    prcl->right+dx,
                    prcl->bottom+dy
               ));

        DISPDBG((8, "rclDst(%d,%d,%d,%d)",
                    prcl->left,
                    prcl->top,
                    prcl->right,
                    prcl->bottom
               ));

        DISPDBG((8, "pjSrc(%x) cx(%d) ulDstAddr(%xh) (%d,%d,%d)",
                    pjSrc,
                    sizlBlt.cx,
                    ulDstAddr,
                    cjLead,
                    culMiddle,
                    cjTrail
               ));

        for (iy = 0; iy < sizlBlt.cy; iy++)
        {
            LONG    ix, lScanLineOffset;

            // We'll first load the first scan line of
            // the BltBuffer and then load the second.  The second scan line
            // will be loaded into the BltBuffer while the first is still being
            // processed.  We'll alternate between the two segments of our
            // BltBuffer until all scans have been processed.

            pjDst = ppdev->pjScreen + ulBltBufferOffset + BltScanOffset;

            if (cjLead)
            {
                for (ix = 0; ix < cjLead; ix++)
                {
                    *pjDst++ = *pjTmp++;
                }
            }

            if (culMiddle)
            {
                for (ix = 0; ix < culMiddle; ix++)
                {
                    *((ULONG*)pjDst)++ = *((ULONG*)pjTmp)++;
                }
            }
            if (cjTrail)
            {
                for (ix = 0; ix < cjTrail; ix++)
                {
                    *pjDst++ = *pjTmp++;
                }
            }

            // Now that we've loaded our scanline into a segment of our BltBuffer,
            // we need to trigger an accelerator operation to transfer it into
            // visible screen memory.  Our static stuff will have already been setup
            // prior to entering any of our loops.

            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            CP_XCNT(ppdev, pjBase, (sizlBlt.cx - 1));
            CP_YCNT(ppdev, pjBase, 0);                  //  Only 1 scan at a time

            CP_SRC_ADDR(ppdev, pjBase, (ulBltBufferOffset + BltScanOffset));
            WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
            CP_DST_ADDR(ppdev, pjBase, ulDstAddr);

            BltScanOffset ^= ppdev->lBltBufferPitch;
            pjTmp = (pjSrc += lDeltaSrc);

            ulDstAddr += lDeltaDst;
        }   // next cy

        prcl++;
    } while (--c != 0);
}
/**************************************************************************
*
* Does a monochrome expansion to video memory.
*
**************************************************************************/

VOID vET6000SlowXfer1bpp(     // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // Actually had better be a rop3
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides color-expansion information
{
    LONG        dx;
    LONG        dy;
    LONG        lSrcDelta;
    BYTE*       pjSrcScan0;
    BYTE*       pjSrc;
    LONG        cjSrc;
    LONG        cjTrail;
    LONG        culSrc;
    BYTE        jFgRop3;
    BYTE        jBgRop3;

    ULONG       ulSolidColorOffset  = ppdev->ulSolidColorOffset;
    BYTE*       pjBase              = ppdev->pjBase;
    LONG        lDelta              = ppdev->lDelta;
    LONG        cBpp                = ppdev->cBpp;
    ULONG       ulFgColor           = pxlo->pulXlate[1];
    ULONG       ulBgColor           = pxlo->pulXlate[0];

    LONG        xyOffset    = (ppdev->cBpp * ppdev->xOffset) +
                              (ppdev->yOffset * ppdev->lDelta);
    LONG        lBltBuffer  = (ppdev->pohBltBuffer->x * ppdev->cBpp) +
                              (ppdev->pohBltBuffer->y * ppdev->lDelta);

    DISPDBG((10,"vET6000SlowXfer1bpp called"));

    DISPDBG((11,"rop4(%04x)", rop4));

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(pptlSrc != NULL && psoSrc != NULL, "Can't have NULL sources");

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

    jFgRop3 = (BYTE)(rop4 >> 8);    // point to src color where src is indicated
                                    // point to pat color where src is indicated

    if ((BYTE) rop4 != R3_NOP)
    {
        jBgRop3 = (BYTE)((rop4 & 0xc3) | ((rop4 & 0xf0) >> 2));
    }
    else
    {
        jBgRop3 = (BYTE) rop4;
    }

    DISPDBG((11,"jFgRop3(%04x), jBgRop3(%04x)", jFgRop3, jBgRop3));

    CP_FG_ROP(ppdev, pjBase, jFgRop3);
    CP_BK_ROP(ppdev, pjBase, jBgRop3);
    CP_DST_Y_OFFSET(ppdev, pjBase, (lDelta - 1));

    CP_PAT_WRAP(ppdev, pjBase, SOLID_COLOR_PATTERN_WRAP);
    CP_PAT_Y_OFFSET(ppdev, pjBase, (SOLID_COLOR_PATTERN_OFFSET - 1));
    CP_SRC_WRAP(ppdev, pjBase, SOLID_COLOR_PATTERN_WRAP);
    CP_SRC_Y_OFFSET(ppdev, pjBase, (SOLID_COLOR_PATTERN_OFFSET - 1));
    CP_PAT_ADDR(ppdev, pjBase, ulSolidColorOffset + 4);
    CP_SRC_ADDR(ppdev, pjBase, ulSolidColorOffset);
    CP_PEL_DEPTH(ppdev, pjBase, (cBpp - 1) << 4);

    //  Here we are going to load the foreground and background colors into
    //  display memory.  We'll use the area for solid colors that we allocated
    //  earlier.

    {
        // Set the color in offscreen memory

        if (cBpp == 1)
        {
            ulFgColor &= 0x000000FF;        //  We may get some extraneous data in the
            ulBgColor &= 0x000000FF;        //  unused portion of our color.  Clear it.
            ulFgColor |= ulFgColor << 8;
            ulBgColor |= ulBgColor << 8;
        }
        if (cBpp <= 2)
        {
            ulFgColor &= 0x0000FFFF;
            ulBgColor &= 0x0000FFFF;
            ulFgColor |= ulFgColor << 16;
            ulBgColor |= ulBgColor << 16;
        }

        //  We don't want to change the colors if the accelerator is active, because
        //  a previous oepration might be using them.

        WAIT_FOR_IDLE_ACL(ppdev, pjBase);

        *(PULONG)(ppdev->pjScreen + ppdev->ulSolidColorOffset) = ulFgColor;
        *(PULONG)(ppdev->pjScreen + ppdev->ulSolidColorOffset + 4) = ulBgColor;
    }

    //  This is the mix control register for the ET6000.  We are setting it to
    //  use a mix ROP of 2, which specifies that a 0 in the mixmap selects the
    //  background color and 1 selects the foreground color.  Bit 7 says that
    //  we want bit 7 of each byte in our mix data to be pixel 0.  This should
    //  be the way that NT wants it.  We also have to set our mask ROP so we
    //  can get the data onto the screen.

    CP_ROUTING_CTRL(ppdev, pjBase, 0xB2);

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;      // Add to destination to get source

    pjSrcScan0 = psoSrc->pvScan0;

    DISPDBG((2,"lSrcDelta(%x)", psoSrc->lDelta));

    do
    {
        ULONG   ulDst;
        RECTL   rclSrc;
        RECTL   rclDst;
        BYTE*   pjTmp;
        BYTE*   pjDst;
        LONG    i;
        BYTE    *pjMmu1 = ppdev->pjMmu1;
        long    lDwords, lBytes, lStart;
        int     cBitsToSkip;

        // load lSrcDelta inside the loop because we adjust it later.

        lSrcDelta  = psoSrc->lDelta;

        rclDst          = *prcl;
        rclSrc.left     = rclDst.left + dx;
        rclSrc.right    = rclDst.right + dx;
        rclSrc.top      = rclDst.top + dy;
        rclSrc.bottom   = rclDst.bottom + dy;

        // x = prcl->left;
        // y = prcl->top;

        DISPDBG((2,"rclSrc(%d,%d,%d,%d) rclDst(%d,%d,%d,%d)",
             rclSrc.left,
             rclSrc.top,
             rclSrc.right,
             rclSrc.bottom,
             rclDst.left,
             rclDst.top,
             rclDst.right,
             rclDst.bottom));

        WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);

        CP_XCNT(ppdev, pjBase, ((rclSrc.right - rclSrc.left) * cBpp) - 1);
        CP_YCNT(ppdev, pjBase, 0);      //  1 scan at a time

        pjSrc = pjSrcScan0 + rclSrc.top * lSrcDelta
                           + (rclSrc.left >> 3);
        cBitsToSkip = rclSrc.left % 8;
        pjTmp = pjSrc;

        ulDst = (rclDst.top * lDelta) + (cBpp * rclDst.left);
        ulDst += xyOffset;

        WAIT_FOR_IDLE_ACL(ppdev, pjBase);

        //  We are going to transfer the mix map into our BltBuffer so
        //  we can get it to the screen.

        CP_MIX_Y_OFFSET(ppdev, pjBase, 0);      // 1 scan at a time

        //  We are using the rectangle dimensions to determine how many pixels per line to move.  This
        //  fixes a bug exposed by the HCT when we had to clip a large temporary buffer and would draw
        //  using data close to the end of the buffer.  We would get a protection exception depending on
        //  whether we ran too close to the end of the buffer.  lSrcDelta will still be used when
        //  stepping through the source bitmap, but not to determine how many pixels will be drawn.
        //
        //  We're adding cBitsToSkip back into here because it's necessary to compute the correct number
        //  of bytes to move.  We always round to the next byte.

        // i = abs(lSrcDelta);  // this doesn't work
        i = ((rclSrc.right - rclSrc.left) + cBitsToSkip + 7) >> 3;    //  Round up before shift.

        lDwords = i / 4;
        lBytes = i % 4;
        lStart = 0;

        //  Here we are going to transfer the monochrome bitmap to the screen.
        //  We'll double buffer it to get some more throughput.

        for (i=0; i < (rclSrc.bottom - rclSrc.top); i++)
        {
            long    ix;

            pjDst = ppdev->pjScreen + lBltBuffer + lStart;
            ix = lDwords;

            while (ix--)
            {
                *((ULONG*)pjDst)++ = *((ULONG*)pjTmp)++;
            }

            ix = lBytes;
            while (ix--)
            {
                *pjDst++ = *pjTmp++;
            }

            WAIT_FOR_IDLE_ACL(ppdev, pjBase);

            //  We have to add in rclSrc.left mod 8 to compensate for the possibility
            //  of starting to draw to soon in our bitmap.  This generally occurs when
            //  clipping text or moving windows where we are only asked to draw
            //  part of a monochrome bitmap.

            CP_MIX_ADDR(ppdev, pjBase, ((lBltBuffer + lStart) * 8) + cBitsToSkip);
            CP_DST_ADDR(ppdev, pjBase, ulDst);
            pjTmp = (pjSrc += lSrcDelta);
            ulDst += lDelta;
            lStart ^= ppdev->lBltBufferPitch;
        }
        prcl++;
    } while (--c != 0);

    WAIT_FOR_EMPTY_ACL_QUEUE(ppdev, pjBase);
    CP_ROUTING_CTRL(ppdev, pjBase, 0x33);
    CP_PEL_DEPTH(ppdev, pjBase, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\wd\mini\cmdcnst.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    cmdcnst.h

Abstract:

    This is the command string interpreter definitions

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//--------------------------------------------------------------------------
//   Definition of the set/clear mode command language.
//
//   Each command is composed of a major portion and a minor portion.
//   The major portion of a command can be found in the most significant
//   nibble of a command byte, while the minor portion is in the least
//   significant portion of a command byte.
//
//   maj  minor      Description
//   ---- -----      --------------------------------------------
//   00              End of data
//
//   10              in and out type commands as described by flags
//        flags:
//
//        xxxx
//        ||||
//        |||+-------- unused
//        ||+--------- 0/1 single/multiple values to output (in's are always 
//        |+---------- 0/1 8/16 bit operation                  single)
//        +----------- 0/1 out/in instruction
//
//       Outs
//       ----------------------------------------------
//       0           reg:W val:B
//       2           reg:W cnt:W val1:B val2:B...valN:B
//       4           reg:W val:W
//       6           reg:W cnt:W val1:W val2:W...valN:W
//
//       Ins
//       ----------------------------------------------
//       8           reg:W
//       a           reg:W cnt:W
//       c           reg:W
//       e           reg:W cnt:W
//
//   20              Special purpose outs
//       00          do indexed outs for seq, crtc, and gdc
//                   indexreg:W cnt:B startindex:B val1:B val2:B...valN:B
//       01          do indexed outs for atc
//                   index-data_reg:W cnt:B startindex:B val1:B val2:B...valN:B
//       02          do masked outs
//                   indexreg:W andmask:B xormask:B
//
//   F0              Nop
//
//---------------------------------------------------------------------------

// some useful equates - major commands

#define EOD     0x000                   // end of data
#define INOUT   0x010                   // do ins or outs
#define METAOUT 0x020                   // do special types of outs
#define NCMD    0x0f0                   // Nop command


// flags for INOUT major command

//#define UNUSED    0x01                    // reserved
#define MULTI   0x02                    // multiple or single outs
#define BW      0x04                    // byte/word size of operation
#define IO      0x08                    // out/in instruction

// minor commands for metout

#define INDXOUT 0x00                    // do indexed outs
#define ATCOUT  0x01                    // do indexed outs for atc
#define MASKOUT 0x02                    // do masked outs using and-xor masks


// composite inout type commands

#define OB      (INOUT)                 // output 8 bit value
#define OBM     (INOUT+MULTI)           // output multiple bytes
#define OW      (INOUT+BW)              // output single word value
#define OWM     (INOUT+BW+MULTI)        // output multiple words

#define IB      (INOUT+IO)              // input byte
#define IBM     (INOUT+IO+MULTI)        // input multiple bytes
#define IW      (INOUT+IO+BW)           // input word
#define IWM     (INOUT+IO+BW+MULTI)     // input multiple words
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\wd\mini\modeset.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    modeset.c

Abstract:

    This is the modeset code for the WD VGA miniport driver.

Environment:

    kernel mode only

Notes:

Revision History:

--*/
#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "wdvga.h"

#include "cmdcnst.h"

#include "pvgaequ.h"

VP_STATUS
VgaInterpretCmdStream(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pusCmdStream
    );

VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    );

VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VOID
VgaZeroVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
VgaValidateModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VP_STATUS
VgaSetActiveDisplay(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG ActiveDisplay
    );

//
// Private functions
//

VOID
DisableLCD(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
EnableLCD(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
DisableCRT(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
EnableCRT(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
UnlockAll(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,VgaSetMode)
#pragma alloc_text(PAGE,VgaQueryAvailableModes)
#pragma alloc_text(PAGE,VgaQueryNumberOfAvailableModes)
#pragma alloc_text(PAGE,VgaQueryCurrentMode)
#pragma alloc_text(PAGE,VgaZeroVideoMemory)
#pragma alloc_text(PAGE,VgaValidateModes)

//
// This routine is NOT pagable because it is called a high IRQL
//

//#pragma alloc_text(PAGE,ExternalMonitorPresent)

//
// This routine is NOT pagable because it is called during WdResetHw,
// which can be called when paging is disabled.
//

//#pragma alloc_text(PAGE,VgaInterpretCmdStream)
#endif


VP_STATUS
VgaInterpretCmdStream(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pusCmdStream
    )

/*++

Routine Description:

    Interprets the appropriate command array to set up VGA registers for the
    requested mode. Typically used to set the VGA into a particular mode by
    programming all of the registers

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    pusCmdStream - array of commands to be interpreted.

Return Value:

    The status of the operation (can only fail on a bad command); TRUE for
    success, FALSE for failure.

--*/

{
    ULONG ulCmd;
    ULONG ulPort;
    UCHAR jValue;
    USHORT usValue;
    ULONG culCount;
    ULONG ulIndex;
    ULONG ulBase;

    if (pusCmdStream == NULL) {

        VideoDebugPrint((1, "VgaInterpretCmdStream - Invalid pusCmdStream\n"));
        return TRUE;
    }

    ulBase = (ULONG)HwDeviceExtension->IOAddress;

    //
    // Now set the adapter to the desired mode.
    //

    while ((ulCmd = *pusCmdStream++) != EOD) {

        //
        // Determine major command type
        //

        switch (ulCmd & 0xF0) {

            //
            // Basic input/output command
            //

            case INOUT:

                //
                // Determine type of inout instruction
                //

                if (!(ulCmd & IO)) {

                    //
                    // Out instruction. Single or multiple outs?
                    //

                    if (!(ulCmd & MULTI)) {

                        //
                        // Single out. Byte or word out?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // Single byte out
                            //

                            ulPort = *pusCmdStream++;
                            jValue = (UCHAR) *pusCmdStream++;
                            VideoPortWritePortUchar((PUCHAR)(ulBase+ulPort),
                                    jValue);

                        } else {

                            //
                            // Single word out
                            //

                            ulPort = *pusCmdStream++;
                            usValue = *pusCmdStream++;
                            VideoPortWritePortUshort((PUSHORT)(ulBase+ulPort),
                                    usValue);

                        }

                    } else {

                        //
                        // Output a string of values
                        // Byte or word outs?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // String byte outs. Do in a loop; can't use
                            // VideoPortWritePortBufferUchar because the data
                            // is in USHORT form
                            //

                            ulPort = ulBase + *pusCmdStream++;
                            culCount = *pusCmdStream++;

                            while (culCount--) {
                                jValue = (UCHAR) *pusCmdStream++;
                                VideoPortWritePortUchar((PUCHAR)ulPort,
                                        jValue);

                            }

                        } else {

                            //
                            // String word outs
                            //

                            ulPort = *pusCmdStream++;
                            culCount = *pusCmdStream++;
                            VideoPortWritePortBufferUshort((PUSHORT)
                                    (ulBase + ulPort), pusCmdStream, culCount);
                            pusCmdStream += culCount;

                        }
                    }

                } else {

                    // In instruction
                    //
                    // Currently, string in instructions aren't supported; all
                    // in instructions are handled as single-byte ins
                    //
                    // Byte or word in?
                    //

                    if (!(ulCmd & BW)) {
                        //
                        // Single byte in
                        //

                        ulPort = *pusCmdStream++;
                        jValue = VideoPortReadPortUchar((PUCHAR)ulBase+ulPort);

                    } else {

                        //
                        // Single word in
                        //

                        ulPort = *pusCmdStream++;
                        usValue = VideoPortReadPortUshort((PUSHORT)
                                (ulBase+ulPort));

                    }

                }

                break;

            //
            // Higher-level input/output commands
            //

            case METAOUT:

                //
                // Determine type of metaout command, based on minor
                // command field
                //
                switch (ulCmd & 0x0F) {

                    //
                    // Indexed outs
                    //

                    case INDXOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            usValue = (USHORT) (ulIndex +
                                      (((ULONG)(*pusCmdStream++)) << 8));
                            VideoPortWritePortUshort((PUSHORT)ulPort, usValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // Masked out (read, AND, XOR, write)
                    //

                    case MASKOUT:

                        ulPort = *pusCmdStream++;
                        jValue = VideoPortReadPortUchar((PUCHAR)ulBase+ulPort);

                        jValue &= *pusCmdStream++;
                        jValue ^= *pusCmdStream++;
                        VideoPortWritePortUchar((PUCHAR)ulBase + ulPort,
                                jValue);

                        break;

                    //
                    // Attribute Controller out
                    //

                    case ATCOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            // Write Attribute Controller index
                            VideoPortWritePortUchar((PUCHAR)ulPort,
                                    (UCHAR)ulIndex);

                            // Write Attribute Controller data
                            jValue = (UCHAR) *pusCmdStream++;
                            VideoPortWritePortUchar((PUCHAR)ulPort, jValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // None of the above; error
                    //
                    default:

                        return FALSE;

                }


                break;

            //
            // NOP
            //

            case NCMD:

                break;

            //
            // Unknown command; error
            //

            default:

                return FALSE;

        }

    }

    return TRUE;

} // end VgaInterpretCmdStream()


VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    )

/*++

Routine Description:

    This routine sets the VGA into the requested mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    Mode - Pointer to the structure containing the information about the
        font to be set.

    ModeSize - Length of the input buffer supplied by the user.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    ERROR_INVALID_PARAMETER if the mode number is invalid.

    NO_ERROR if the operation completed successfully.

--*/

{

    PVIDEOMODE pRequestedMode;
    VP_STATUS status;
    UCHAR temp;
    UCHAR dummy;
    UCHAR bIsColor;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    UCHAR frequencySetting;
    PUCHAR CrtAddressPort, CrtDataPort;
    UCHAR bModeFirst = 1;
    BOOLEAN bMonitorPresent;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (ModeSize < sizeof(VIDEO_MODE)) {

        VideoDebugPrint((1, "VgaSetMode: ERROR_INSUFFICIENT_BUFFER\n"));

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Extract the clear memory bit.
    //

    if (Mode->RequestedMode & VIDEO_MODE_NO_ZERO_MEMORY) {

        Mode->RequestedMode &= ~VIDEO_MODE_NO_ZERO_MEMORY;

    }  else {

        VgaZeroVideoMemory(HwDeviceExtension);

    }

    //
    // Check to see if we are requesting a valid mode
    //

    if ( (Mode->RequestedMode >= NumVideoModes) ||
         (!ModesVGA[Mode->RequestedMode].ValidMode) ) {

        VideoDebugPrint((1, "VgaSetMode: ERROR_INVALID_PARAMETER\n"));

        return ERROR_INVALID_PARAMETER;

    }

    pRequestedMode = &ModesVGA[Mode->RequestedMode];

#ifdef INT10_MODE_SET

    //
    // Make sure we unlock extended registers since the BIOS on some machines
    // does not do it properly.
    //

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                             GRAPH_ADDRESS_PORT), 0x050F);

    //
    // Initialize CrtAddressPort, and CrtDataPort
    //

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            MISC_OUTPUT_REG_READ_PORT) & 0x01) {

        bIsColor = TRUE;
        CrtAddressPort = HwDeviceExtension->IOAddress + CRTC_ADDRESS_PORT_COLOR;
        CrtDataPort    = HwDeviceExtension->IOAddress + CRTC_DATA_PORT_COLOR;

    } else {

        bIsColor = FALSE;
        CrtAddressPort = HwDeviceExtension->IOAddress + CRTC_ADDRESS_PORT_MONO;
        CrtDataPort    = HwDeviceExtension->IOAddress + CRTC_DATA_PORT_MONO;

    }

    //
    // Make sure we unlock extended registers since the BIOS on some machines
    // does not do it properly.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, 0x0F);

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, 0x05);


    VideoPortWritePortUchar(CrtAddressPort, 0x2b);

    temp = VideoPortReadPortUchar(CrtDataPort);

    //
    // Adjust the frequency setting register and write it back out.
    // Also support Diamond changes to frequency settings
    //

    temp &= pRequestedMode->FrequencyMask;

    frequencySetting = pRequestedMode->FrequencySetting;


    if ( (HwDeviceExtension->BoardID == SPEEDSTAR31) &&
         (pRequestedMode->hres == 1024) ) {

        //
        // Diamond has inversed the refresh rates of interlaced and 72 Hz
        // on the 1024 modes
        //

        if (pRequestedMode->Frequency == 72) {

            frequencySetting = 0x00;

        } else {

            if (pRequestedMode->Frequency == 44) {

                frequencySetting = 0x30;

            }
        }
    }

    temp |= frequencySetting;

    VideoPortWritePortUchar(CrtDataPort, temp);

    //
    // Mode set block that can be repeated.
    //

SetAgain:

    //
    // Set the mode
    //

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    if (HwDeviceExtension->IsIBM &&
        (pRequestedMode->Int10ModeNumber & 0xffff0000))
    {
        biosArguments.Eax = 0x4f02;
        biosArguments.Ebx = pRequestedMode->Int10ModeNumber >> 16;
    }
    else
    {
        biosArguments.Eax = pRequestedMode->Int10ModeNumber & 0xff;
    }

    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

    if (status != NO_ERROR) {

       return status;

    }

    //
    // Check to see if the modeset worked.  If not, then if we
    // don't have an SVGA Bios, and do have a modetable, then
    // set the mode.  Else, fail.
    //

    if (HwDeviceExtension->BoardID == WD90C24A)
    {
        biosArguments.Eax = 0x0f00;
        VideoPortInt10(HwDeviceExtension, &biosArguments);

        if ((biosArguments.Eax & 0xff) != (pRequestedMode->Int10ModeNumber & 0xff))
        {
            if ((HwDeviceExtension->SVGABios < FULL_SVGA_BIOS) &&
                (pRequestedMode->ModeTable != NULL))
            {
                BOOLEAN bLCD=FALSE;

                VideoDebugPrint((1, "\n*** Setting mode with mode table!\n\n"));

                //
                // NOTE: Certain models of IBM Thinkpads can switch
                // between LCD, Monitor, and Simultaneous modes while
                // the machine is running.  Other models cannot.
                // Currently we have noticed a coralation between
                // machines which have SVGA Bios's and machines which
                // can set the mode.
                //
                //   IF MACHINE HAS SVGA BIOS THEN
                //       MACHINE CAN TURN ON/OFF LCD ON THE FLY
                //   ELSE
                //       MACHINE CANNOT TURN ON/OFF LCD ON THE FLY
                //
                // If a user has a machine where the LCD can be turned
                // on dynamically, then it is possible that the user
                // will turn on the LCD when we think it is off.  Then
                // we may try to set a mode which does not work with
                // the LCD off.  To avoid this problem, we will try
                // to determine if the LCD is on/off before setting
                // the mode.  If the LCD is on, and it needs to be
                // off in order for the modeset to succeed, we'll fail
                // the modeset.
                //
                // Unfortunately, this does not solve all of our
                // problems.  The code which we use to try to detect
                // whether or not the LCD is on fails on some
                // machines.  The code seems to fail on machines
                // which do not have SVGA Bios's.  As mentioned above
                // machines which do not have SVGA Bios's can not
                // switch on their LCD's dynamically.  Therefore we
                // do not need to execute this special code on these
                // machines because the LCD state wont change on us
                // anyway.
                //

                if (HwDeviceExtension->SVGABios > NO_SVGA_BIOS)
                {
                    //
                    // If the LCD is enabled we also need to SET bit 0
                    // of PR2.
                    //
                    // We will check to see if the LCD is enabled by
                    // checking bit 2 of CRTC register 0x31, and bit
                    // 4 of CRTC register 0x32.  If either of these
                    // is set, then we'll assume an LCD is enabled.
                    //

                    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                            CRTC_ADDRESS_PORT_COLOR, 0x31);
                    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                            CRTC_DATA_PORT_COLOR) & 0x04)
                    {
                        bLCD = TRUE;
                    }

                    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                            CRTC_ADDRESS_PORT_COLOR, 0x32);
                    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                            CRTC_DATA_PORT_COLOR) & 0x10)
                    {
                        bLCD = TRUE;
                    }

                    //
                    // For some reason, on the 755CDV, if we set a high res mode,
                    // while the LCD is on, then the LCD won't be disabled
                    // properly.  Therefore, fail the mode set if the LCD
                    // is on, and we need to turn it off to set this mode.
                    //

                    if (bLCD &&
                        !(HwDeviceExtension->DisplayType &
                          pRequestedMode->LCDtype &
                          ~MONITOR))
                    {
                        return ERROR_INVALID_PARAMETER;
                    }
                }

                VgaSetActiveDisplay(HwDeviceExtension, LCD_DISABLE | CRT_ENABLE);

                VgaInterpretCmdStream(HwDeviceExtension, pRequestedMode->ModeTable);

                //
                // if the LCD can do this mode, then turn the LCD
                // back on.  Else, leave it off.
                //
                // add the code!!
                //

                if (pRequestedMode->LCDtype & HwDeviceExtension->DisplayType & ~MONITOR)
                {
                    VgaSetActiveDisplay(HwDeviceExtension, LCD_ENABLE | CRT_ENABLE);

                    VideoDebugPrint((1, "LCD Enabled!\n"));
                }
                else
                {
                    VgaSetActiveDisplay(HwDeviceExtension, LCD_DISABLE | CRT_ENABLE);

                    VideoDebugPrint((1, "LCD Disabled!\n"));
                }
            }
            else
            {
                return ERROR_INVALID_PARAMETER;
            }
        }
    }

    if (pRequestedMode->CmdStrings != NULL)
    {
        VgaInterpretCmdStream(HwDeviceExtension, pRequestedMode->CmdStrings);
    }

    if (!(pRequestedMode->fbType & VIDEO_MODE_GRAPHICS)) {

        //
        // Fix to make sure we always set the colors in text mode to be
        // intensity, and not flashing
        // For this zero out the Mode Control Regsiter bit 3 (index 0x10
        // of the Attribute controller).
        //

        if (bIsColor) {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_COLOR);
        } else {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_MONO);
        }

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (0x10 | VIDEO_ENABLE));
        temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_READ_PORT);

        temp &= 0xF7;

        if (bIsColor) {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_COLOR);
        } else {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_MONO);
        }

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (0x10 | VIDEO_ENABLE));
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_WRITE_PORT, temp);

    }

    //
    // A few wd cards do not work properly on the first mode set. You have
    // to set the mode twice. So lets set it twice!
    //

    if (bModeFirst == 1 && HwDeviceExtension->BoardID != WD90C24A)
    {

        bModeFirst = 0;
        goto SetAgain;

    }

#else

    VgaInterpretCmdStream(HwDeviceExtension, pRequestedMode->CmdStrings);

#endif

    //
    // Make sure we unlock extended registers since the BIOS on some machines
    // does not do it properly.
    //

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                             GRAPH_ADDRESS_PORT), 0x050F);

    if (HwDeviceExtension->BoardID == WD90C24A)
    {
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT, 0xFF);
    }

    //
    // Update the location of the physical frame buffer within video memory.
    //

    HwDeviceExtension->PhysicalFrameLength =
            MemoryMaps[pRequestedMode->MemMap].MaxSize;

    HwDeviceExtension->PhysicalFrameBase.LowPart =
            MemoryMaps[pRequestedMode->MemMap].Start;

    //
    // Store the new mode value.
    //

    HwDeviceExtension->CurrentMode = pRequestedMode;
    HwDeviceExtension->ModeIndex = Mode->RequestedMode;

    return NO_ERROR;

} //end VgaSetMode()


VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the list of all available available modes on the
    card.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ModeInformation - Pointer to the output buffer supplied by the user.
        This is where the list of all valid modes is stored.

    ModeInformationSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    PVIDEO_MODE_INFORMATION videoModes = ModeInformation;
    ULONG i;

    //
    // Find out the size of the data to be put in the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (ModeInformationSize < (*OutputSize =
            HwDeviceExtension->NumAvailableModes *
            sizeof(VIDEO_MODE_INFORMATION)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // For each mode supported by the card, store the mode characteristics
    // in the output buffer.
    //

    for (i = 0; i < NumVideoModes; i++) {

        if (ModesVGA[i].ValidMode) {

            videoModes->Length = sizeof(VIDEO_MODE_INFORMATION);
            videoModes->ModeIndex  = i;
            videoModes->VisScreenWidth = ModesVGA[i].hres;
            videoModes->ScreenStride = ModesVGA[i].wbytes;
            videoModes->VisScreenHeight = ModesVGA[i].vres;
            videoModes->NumberOfPlanes = ModesVGA[i].numPlanes;
            videoModes->BitsPerPlane = ModesVGA[i].bitsPerPlane;
            videoModes->Frequency = ModesVGA[i].Frequency;
            videoModes->XMillimeter = 320;        // temporary hardcoded constant
            videoModes->YMillimeter = 240;        // temporary hardcoded constant
            videoModes->AttributeFlags = ModesVGA[i].fbType;
            videoModes->AttributeFlags |= ModesVGA[i].Interlaced ?
                 VIDEO_MODE_INTERLACED : 0;
            videoModes->DriverSpecificAttributeFlags = 0;

            //
            // Calculate the VideoMemoryBitmapWidth
            //

            {
                LONG x;

                x = videoModes->BitsPerPlane;

                if( x == 15 ) x = 16;

                videoModes->VideoMemoryBitmapWidth =
                    (videoModes->ScreenStride * 8 ) / x;
            }

            videoModes->VideoMemoryBitmapHeight =
                     HwDeviceExtension->AdapterMemorySize / videoModes->ScreenStride;

            if (ModesVGA[i].bitsPerPlane == 16)
            {

                videoModes->NumberRedBits = 5;
                videoModes->NumberGreenBits = 6;
                videoModes->NumberBlueBits = 5;
                videoModes->RedMask = 0xF800;
                videoModes->GreenMask = 0x07E0;
                videoModes->BlueMask = 0x001F;

            }
            else
            {

                videoModes->NumberRedBits = 6;
                videoModes->NumberGreenBits = 6;
                videoModes->NumberBlueBits = 6;
                videoModes->RedMask = 0;
                videoModes->GreenMask = 0;
                videoModes->BlueMask = 0;
                videoModes->AttributeFlags |= VIDEO_MODE_PALETTE_DRIVEN |
                     VIDEO_MODE_MANAGED_PALETTE;

            }

            videoModes++;

        }
    }

    return NO_ERROR;

} // end VgaGetAvailableModes()

VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the number of available modes for this particular
    video card.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    NumModes - Pointer to the output buffer supplied by the user. This is
        where the number of modes is stored.

    NumModesSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (NumModesSize < (*OutputSize = sizeof(VIDEO_NUM_MODES)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Validate the modes each time on the portables since an external monitor
    // can be connected or disconnected dynamically.
    //

    VgaValidateModes(HwDeviceExtension);

    //
    // Store the number of modes into the buffer.
    //

    NumModes->NumModes = HwDeviceExtension->NumAvailableModes;
    NumModes->ModeInformationLength = sizeof(VIDEO_MODE_INFORMATION);

    return NO_ERROR;

} // end VgaGetNumberOfAvailableModes()

VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns a description of the current video mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ModeInformation - Pointer to the output buffer supplied by the user.
        This is where the current mode information is stored.

    ModeInformationSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    //
    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (ModeInformationSize < (*OutputSize = sizeof(VIDEO_MODE_INFORMATION))) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the characteristics of the current mode into the buffer.
    //

    ModeInformation->Length = sizeof(VIDEO_MODE_INFORMATION);
    ModeInformation->ModeIndex = HwDeviceExtension->ModeIndex;
    ModeInformation->VisScreenWidth = HwDeviceExtension->CurrentMode->hres;
    ModeInformation->ScreenStride = HwDeviceExtension->CurrentMode->wbytes;
    ModeInformation->VisScreenHeight = HwDeviceExtension->CurrentMode->vres;
    ModeInformation->NumberOfPlanes = HwDeviceExtension->CurrentMode->numPlanes;
    ModeInformation->BitsPerPlane = HwDeviceExtension->CurrentMode->bitsPerPlane;
    ModeInformation->Frequency = HwDeviceExtension->CurrentMode->Frequency;
    ModeInformation->XMillimeter = 320;        // temporary hardcoded constant
    ModeInformation->YMillimeter = 240;        // temporary hardcoded constant

    ModeInformation->AttributeFlags = HwDeviceExtension->CurrentMode->fbType |
        (HwDeviceExtension->CurrentMode->Interlaced ?
         VIDEO_MODE_INTERLACED : 0);

    ModeInformation->DriverSpecificAttributeFlags = 0;

    if (ModeInformation->BitsPerPlane == 16) {

        ModeInformation->NumberRedBits = 5;
        ModeInformation->NumberGreenBits = 6;
        ModeInformation->NumberBlueBits = 5;
        ModeInformation->RedMask = 0xF800;
        ModeInformation->GreenMask = 0x07E0;
        ModeInformation->BlueMask = 0x1F;

    } else {

        ModeInformation->NumberRedBits = 6;
        ModeInformation->NumberGreenBits = 6;
        ModeInformation->NumberBlueBits = 6;
        ModeInformation->RedMask = 0;
        ModeInformation->GreenMask = 0;
        ModeInformation->BlueMask = 0;
        ModeInformation->AttributeFlags |=
            VIDEO_MODE_PALETTE_DRIVEN | VIDEO_MODE_MANAGED_PALETTE;

    }

    //
    // Calculate the VideoMemoryBitmapWidth
    //

    {
        LONG x;

        x = ModeInformation->BitsPerPlane;

        if( x == 15 ) x = 16;

        ModeInformation->VideoMemoryBitmapWidth =
            (ModeInformation->ScreenStride * 8 ) / x;
    }

    ModeInformation->VideoMemoryBitmapHeight =
             HwDeviceExtension->AdapterMemorySize / ModeInformation->ScreenStride;

    return NO_ERROR;

} // end VgaQueryCurrentMode()


VOID
VgaZeroVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
/*++

Routine Description:

    This routine zeros the first 256K on the VGA.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.


Return Value:

    None.

--*/
{
    UCHAR temp;

    //
    // Map font buffer at A0000
    //

    VgaInterpretCmdStream(HwDeviceExtension, EnableA000Data);

    //
    // Enable all planes.
    //
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
            IND_MAP_MASK);

    temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) | (UCHAR)0x0F;

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
            temp);

    //
    // Zero the memory.
    //

    VideoPortZeroDeviceMemory(HwDeviceExtension->VideoMemoryAddress, 0xFFFF);

    VgaInterpretCmdStream(HwDeviceExtension, DisableA000Color);

}


VOID
VgaValidateModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Determines which modes are valid and which are not.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/
{

    ULONG i;

    HwDeviceExtension->NumAvailableModes = 0;

    VideoDebugPrint((1, "VgaValidateModes:\n"));

    VideoDebugPrint((1, "Avail Adapter Mem: 0x%x\n"
                        "Avail Monitor Type: 0x%x\n",
                        HwDeviceExtension->AdapterMemorySize,
                        HwDeviceExtension->DisplayType));

    for (i = 0; i < NumVideoModes; i++) {

        VideoDebugPrint((1, "Mode %d %dx%d at %d bpp\n"
                            "\tAdapterMemoryRequired: 0x%x\n"
                            "\tMonitorType 0x%x\n",
                            i, ModesVGA[i].hres, ModesVGA[i].vres,
                            ModesVGA[i].bitsPerPlane * ModesVGA[i].numPlanes,
                            ModesVGA[i].numPlanes * ModesVGA[i].sbytes,
                            ModesVGA[i].LCDtype));

        if ((HwDeviceExtension->AdapterMemorySize >=
            ModesVGA[i].numPlanes * ModesVGA[i].sbytes) &&
            (HwDeviceExtension->DisplayType &
            ModesVGA[i].LCDtype))
        {
   
            ModesVGA[i].ValidMode = TRUE;
            HwDeviceExtension->NumAvailableModes++;
        }


        //
        // invalidates some modes we may have enabled based on some specific
        // chip\machine problems
        //

        if ( (ModesVGA[i].ValidMode) &&
             (HwDeviceExtension->BoardID == WD90C24A))

        {
            if (HwDeviceExtension->IsIBM == TRUE)
            {
                //
                // get rid of 256 color modes > 640x480 on
                // machines with STN displays
                //

                if ((ModesVGA[i].bitsPerPlane == 8) &&
                    (ModesVGA[i].hres > 640) &&
                    (HwDeviceExtension->DisplayType & TOSHIBA_DSTNC))
                {
                    ModesVGA[i].ValidMode = FALSE;
                    HwDeviceExtension->NumAvailableModes--;
                }

                //
                // get rid of 64K color support for machines without
                // SVGABios support
                //

                else if ((ModesVGA[i].bitsPerPlane == 16) &&
                         (HwDeviceExtension->SVGABios == NO_SVGA_BIOS))
                {
                    ModesVGA[i].ValidMode = FALSE;
                    HwDeviceExtension->NumAvailableModes--;
                }
            }
        }

        //
        // 16bpp modes only work on the WD90C24A chip sets.
        //

        if( (ModesVGA[i].ValidMode) &&
            (HwDeviceExtension->BoardID != WD90C24A) &&
            (ModesVGA[i].bitsPerPlane == 16))
        {
            ModesVGA[i].ValidMode = FALSE;
            HwDeviceExtension->NumAvailableModes--;
        }

        //
        // Older boards do not support 72HZ in 1024x768 modes.
        // So disable those.
        //

        if ( (ModesVGA[i].ValidMode) &&
             (HwDeviceExtension->BoardID < WD90C31) &&
             (ModesVGA[i].hres == 1024) &&
             (ModesVGA[i].vres == 768) &&
             (ModesVGA[i].Frequency == 72) )
        {

            ModesVGA[i].ValidMode = FALSE;
            HwDeviceExtension->NumAvailableModes--;
   
        }

        if (ModesVGA[i].ValidMode == FALSE)
        {
            VideoDebugPrint((1, "The mode is not valid.\n"));
        }
        else
        {
            VideoDebugPrint((1, "The mode is valid.\n"));
        }
    }
}

BOOLEAN
ExternalMonitorPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
/*++

Routine Description:

    Determine whether an external monitor is connected to the
    machine.  This routine should only be called if the
    BoardID == WD90C24A.

    Note: This routine expects to be called after the WD extended
          registers have been unlocked.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    Updated the DisplayType field in HwDeviceExtension to indicate
    whether a monitor is connected.

    The routine always returns TRUE.

--*/
{
    UCHAR dac[3];
    UCHAR _pr19, _pr1b;
    int i,j;
    int bExternal = 0;

    //
    // If we are on an IBM machine, use SMAPI routines
    // instead of detetecting the monitor ourselves.
    //

    if (HwDeviceExtension->IsIBM)
    {
        bExternal = LCDIsMonitorPresent();

        if (bExternal)
        {
            HwDeviceExtension->DisplayType |= MONITOR;
        }
        else
        {
            HwDeviceExtension->DisplayType &= ~MONITOR;
        }

        return TRUE;
    }

    //
    // Only refresh display with value in DAC 0
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
        DAC_PIXEL_MASK_PORT, 0x00);


    //
    // lets preserve what's in the DAC
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                            DAC_ADDRESS_READ_PORT,
                            (UCHAR) 0);

    for (j=0; j<3; j++)
    {
        dac[j]= VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                          DAC_DATA_REG_PORT);
    }

    //
    // Fill in DAC 0 with a value for the test
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + DAC_DATA_REG_PORT, 0x04);    // Red
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + DAC_DATA_REG_PORT, 0x12);    // Green
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + DAC_DATA_REG_PORT, 0x04);    // Blue

    //
    // We need to check bit 4 of 0x3c2.  We only want to check
    // this bit during actual display output.  Therefore we will
    // wait for a vertical refresh, and then try to wait 300
    // nanoseconds for the monitor detection circuits to
    // stabalize, and then read the bit.  (I may have to adjust
    // crtc registers to prevent refresh cycles).
    //
    // There are two bits in the Input Status #1 Register which
    // will help us to detect if we are in a refresh cycle.  If
    // bit 3 is on then we are in a verticle refresh.  If bit 0
    // is off (0) then we are in a display mode, else we are in
    // some sort of a refresh.
    //
    // Therefore, for our purposes, we will do the following.  We
    // will wait for a verticle refresh (bit 3 = 1) then we will
    // wait for it to turn off.  We are now starting to draw the
    // screen.  Now we will examine the monitor connection bit
    // (bit 4 of 0x3c2) until the display mode bit (bit 0 of
    // 0x3da) goes high. Now we will use our last recorded value
    // for monitor detection.
    //

    //
    // wait for V retrace
    //

    while ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                   INPUT_STATUS_1_COLOR) & 0x8) == 0);

    //
    // wait for V retrace to end
    //

    while ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                   INPUT_STATUS_1_COLOR) & 0x8) != 0);

    //
    // wait for display enable to start
    //

    while ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                   INPUT_STATUS_1_COLOR) & 0x1) != 0);

    //
    // wait for display enable to end.  Use last value of
    // bExternal to determine if an external monitor is
    // connected.
    //

    {
        int LoopCount=0, OnCount=0;

        bExternal = FALSE;

        while ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                       INPUT_STATUS_1_COLOR) & 0x1) == 0)
        {
            if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                       INPUT_STATUS_0_PORT) & 0x10) == 0x10)
            {
                OnCount++;
            }

            LoopCount++;
        }

        if (OnCount > (LoopCount / 2))  // should compile as LoopCount >> 1
        {
            bExternal = TRUE;
        }

    }

    //
    // restore the DAC
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                            DAC_ADDRESS_WRITE_PORT,
                            (UCHAR) 0);

    for (j=0; j<3; j++)
    {
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT,
                                dac[j]);
    }

    //
    // Re-enable the DAC
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
        DAC_PIXEL_MASK_PORT, 0xFF);

    //
    // restore _pr19, and _pr1b state
    //

    if (bExternal)
    {
        HwDeviceExtension->DisplayType |= MONITOR;
    }
    else
    {
        HwDeviceExtension->DisplayType &= ~MONITOR;
    }

    return TRUE;
}

VP_STATUS
VgaSetActiveDisplay(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG ActiveDisplay
    )
/*++

Routine Description:

    This routine selects the active display device(s).

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ActiveDisplay     - Devices to be active.
                        (See WD90C24A.H for the definition)

Return Value:

    If successful, return NO_ERROR, else return FALSE.

--*/

{
    VP_STATUS  status = ERROR_INVALID_PARAMETER;

    //
    // Unlock paradise registers
    //

    UnlockAll(HwDeviceExtension);

    //
    // Enable or Disable LCD output
    //
    // Note: To prevent the fuse of LCD from blowing up, LCD should be turns off
    //       while output is disabled.
    //
    //       If VideoPortPowerControl() returns an error for the absence of HALPM.SYS,
    //       we will try to control LCD by accessing the hardware directly.
    //

    if (ActiveDisplay & LCD_ENABLE) {

        EnableLCD(HwDeviceExtension);

    } else if (ActiveDisplay & LCD_DISABLE) {

        DisableLCD(HwDeviceExtension);

    }

    //
    // Enable or Disable CRT output
    //

    if (ActiveDisplay & CRT_ENABLE) {
        EnableCRT(HwDeviceExtension);
    } else {
        DisableCRT(HwDeviceExtension);
    }

    return NO_ERROR;
} // end VgaSetActiveDisplay()


VOID
DisableLCD(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
/*++

Routine Description:

    This routine disables LCD interface of WD90C24A/A2.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    None.

--*/
{
    PUCHAR     IoBase = HwDeviceExtension->IOAddress;

    //
    // Wait until next vertical retrace interval
    //

    while (0 == (VideoPortReadPortUchar(IoBase + INPUT_STATUS_1_COLOR) & 0x08));

    //
    // Disables LCD interface
    //

    VideoPortWritePortUchar(IoBase + CRTC_ADDRESS_PORT_COLOR, pr19);
    VideoPortWritePortUchar(
        IoBase + CRTC_DATA_PORT_COLOR,
        (UCHAR)(VideoPortReadPortUchar(IoBase + CRTC_DATA_PORT_COLOR) & ~0x10));

    //
    // Tristates LCD control and data signals
    //

    VideoPortWritePortUchar(IoBase + GRAPH_ADDRESS_PORT, pr4);
    VideoPortWritePortUchar(
        IoBase + GRAPH_DATA_PORT,
        (CHAR)(VideoPortReadPortUchar(IoBase + GRAPH_DATA_PORT) | 0x20));

    //
    // Unlocks CRTC shadow registers
    //

    VideoPortWritePortUshort(
        (PUSHORT)(IoBase + CRTC_ADDRESS_PORT_COLOR),
        (USHORT)pr1b | ((USHORT)pr1b_unlock << 8));

} // end DisableLCD()


VOID
EnableLCD(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
/*++

Routine Description:

    This routine enables LCD interface of WD90C24A/A2.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    None.

--*/
{
    PUCHAR     IoBase = HwDeviceExtension->IOAddress;

    //
    // Locks CRTC shadow registers
    //

    VideoPortWritePortUshort(
        (PUSHORT)(IoBase + CRTC_ADDRESS_PORT_COLOR),
        (USHORT)pr1b | ((USHORT)pr1b_unlock_pr << 8));

    //
    // Wait until next vertical retrace interval
    //

    while (0 == (VideoPortReadPortUchar(IoBase + INPUT_STATUS_1_COLOR) & 0x08));

    //
    // Drives LCD control and data signals
    //

    VideoPortWritePortUchar(IoBase + GRAPH_ADDRESS_PORT, pr4);
    VideoPortWritePortUchar(
        IoBase + GRAPH_DATA_PORT,
        (CHAR)(VideoPortReadPortUchar(IoBase + GRAPH_DATA_PORT) & ~0x20));

    //
    // Enables LCD interface
    //

    VideoPortWritePortUchar(IoBase + CRTC_ADDRESS_PORT_COLOR, pr19);
    VideoPortWritePortUchar(
        IoBase + CRTC_DATA_PORT_COLOR,
        (CHAR)(VideoPortReadPortUchar(IoBase + CRTC_DATA_PORT_COLOR) | 0x10));

} // end EnableLCD()


VOID
DisableCRT(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
/*++

Routine Description:

    This routine disables CRT interface of WD90C24A/A2

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    None.

--*/
{
    PUCHAR     IoBase = HwDeviceExtension->IOAddress;

    //
    // Disables CRT interface
    //

    VideoPortWritePortUchar(IoBase + CRTC_ADDRESS_PORT_COLOR, pr19);
    VideoPortWritePortUchar(
        IoBase + CRTC_DATA_PORT_COLOR,
        (UCHAR)(VideoPortReadPortUchar(IoBase + CRTC_DATA_PORT_COLOR) & ~0x20));

    //
    // Shuts off internal RAMDAC
    //

    VideoPortWritePortUchar(IoBase + CRTC_ADDRESS_PORT_COLOR, pr18);
    VideoPortWritePortUchar(
        IoBase + CRTC_DATA_PORT_COLOR,
        (UCHAR)(VideoPortReadPortUchar(IoBase + CRTC_DATA_PORT_COLOR) | 0x80));

    //
    // Disables CRT H-sync and V-sync signals
    //

    VideoPortWritePortUchar(IoBase + CRTC_ADDRESS_PORT_COLOR, pr39);
    VideoPortWritePortUchar(
        IoBase + CRTC_DATA_PORT_COLOR,
        (UCHAR)(VideoPortReadPortUchar(IoBase + CRTC_DATA_PORT_COLOR) & ~0x04));

} // end DisableCRT()


VOID
EnableCRT(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
/*++

Routine Description:

    This routine enables CRT interface of WD90C24A/A2

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    None.

--*/
{
    PUCHAR     IoBase = HwDeviceExtension->IOAddress;

    //
    // Enables CRT interface
    //

    VideoPortWritePortUchar(IoBase + CRTC_ADDRESS_PORT_COLOR, pr19);
    VideoPortWritePortUchar(
        IoBase + CRTC_DATA_PORT_COLOR,
        (UCHAR)(VideoPortReadPortUchar(IoBase + CRTC_DATA_PORT_COLOR) | 0x20));

    //
    // Enables internal RAMDAC
    //

    VideoPortWritePortUchar(IoBase + CRTC_ADDRESS_PORT_COLOR, pr18);
    VideoPortWritePortUchar(
        IoBase + CRTC_DATA_PORT_COLOR,
        (UCHAR)(VideoPortReadPortUchar(IoBase + CRTC_DATA_PORT_COLOR) & ~0x80));

    //
    // Enables CRT H-sync and V-sync signals
    //

    VideoPortWritePortUchar(IoBase + CRTC_ADDRESS_PORT_COLOR, pr39);
    VideoPortWritePortUchar(
        IoBase + CRTC_DATA_PORT_COLOR,
        (UCHAR)(VideoPortReadPortUchar(IoBase + CRTC_DATA_PORT_COLOR) | 0x04));

} // end EnableCRT()


VOID
UnlockAll(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
/*++

Routine Description:

    This routine unlocks all WD registers, except CRTC shadow registers

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    None.

--*/
{
    PUCHAR     IoBase = HwDeviceExtension->IOAddress;

    //
    // Unlocks the all WD registers
    //

    VideoPortWritePortUshort(
        (PUSHORT)(IoBase + GRAPH_ADDRESS_PORT),
        (USHORT)pr5  | ((USHORT)pr5_unlock << 8));

    VideoPortWritePortUshort(
        (PUSHORT)(IoBase + CRTC_ADDRESS_PORT_COLOR),
        (USHORT)pr10 | ((USHORT)pr10_unlock << 8));

    VideoPortWritePortUshort(
        (PUSHORT)(IoBase + CRTC_ADDRESS_PORT_COLOR),
        (USHORT)pr11 | ((USHORT)pr11_unlock << 8));

    VideoPortWritePortUshort(
        (PUSHORT)(IoBase + SEQ_ADDRESS_PORT),
        (USHORT)pr20 | ((USHORT)pr20_unlock << 8));

    VideoPortWritePortUshort(
        (PUSHORT)(IoBase + SEQ_ADDRESS_PORT),
        (USHORT)pr72 | ((USHORT)pr72_unlock << 8));

    VideoPortWritePortUshort(
        (PUSHORT)(IoBase + CRTC_ADDRESS_PORT_COLOR),
        (USHORT)pr1b | ((USHORT)pr1b_unlock_pr << 8));

    VideoPortWritePortUshort(
        (PUSHORT)(IoBase + CRTC_ADDRESS_PORT_COLOR),
        (USHORT)pr30 | ((USHORT)pr30_unlock << 8));

    return;
} // end UnlockAll()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\wd\mini\wddata.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    wddata.h

Abstract:

    This module contains all the global data used by the Western Digital driver.

Environment:

    Kernel mode

Revision History:


--*/

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "wdvga.h"

#include "cmdcnst.h"
#include "pvgaequ.h"


//
// On machines without a SVGA BIOS, we need to reset the WD chip into a
// state where the standard VGA BIOS can set a mode.  The reset code
// below sets the WD chip back into this state.
//

USHORT Reset[] =
{

    OW, CRTC_ADDRESS_PORT_COLOR, pr13 + 0x100 * pr13_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr14 + 0x100 * pr14_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr15 + 0x100 * pr15_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr16 + 0x100 * (pr16_all & 0x00) ,

    //
    // a strange strip which duplicates scan lines appears on the
    // stn panel if I execute this reset code.
    //
    // here is the line which causes the problem.  Lets just leave it
    // out.  If I need it for the other thinkpads, I'll figure out
    // a way to add it back.
    //

    //OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * pr17_all     ,
    //OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * pr17_244LP     ,

    OW, GRAPH_ADDRESS_PORT, 0x0009,
    OW, GRAPH_ADDRESS_PORT, 0x000a,
    OW, GRAPH_ADDRESS_PORT, 0x400e,

    OW, CRTC_ADDRESS_PORT_COLOR, 0x4f09,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x0d0a,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x0e0b,
    OW, GRAPH_ADDRESS_PORT, 0xc50b,
    OW, GRAPH_ADDRESS_PORT, 0xc52b,
    OW, SEQ_ADDRESS_PORT, 0x6511,
    OW, SEQ_ADDRESS_PORT, 0x0d31,

    /*
    OW, 0x24, 0x4f09,
    OW, 0x24, 0x0d0a,
    OW, 0x24, 0x0e0b,
    OW, 0x1e, 0xc50b,
    OW, 0x1e, 0xc52b,
    OW, 0x14, 0x6511,
    OW, 0x14, 0x0d31,
    */

    EOD

};


//
//
// Make everything else in this module pageable
//
//


#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE")
#endif


//
// This structure describes to which ports access is required.
//

VIDEO_ACCESS_RANGE VgaAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,                // 64-bit linear base address
                                                 // of range
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1, // # of ports
    1,                                           // range is in I/O space
    1,                                           // range should be visible
    0                                            // range should be shareable
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    0
},
{
    0x000A0000, 0x00000000,
    0x00020000,
    0,
    1,
    0
},
//
// These are extended registers found only on SOME advanced WD cards.
// so try to map them in if possible
//
{
    WD_EXT_PORT_START, 0x00000000,
    WD_EXT_PORT_END - WD_EXT_PORT_START + 1,
    1,
    1,
    0
},

//
// Video Setup
//
{
    0x00000102,
    0x00000000,
    1,
    1,
    1,
    0
},

//
// Flat Panel Control Addresss/Data
//

{
    0x00000D00,
    0x00000000,
    2,
    1,
    1,
    0
},

//
// IBM's System Management API Port location
//

{
    0x000015EE,
    0x00000000,
    2,
    1,
    1,
    0
}

};



//
// Validator Port list.
// This structure describes all the ports that must be hooked out of the V86
// emulator when a DOS app goes to full-screen mode.
// The structure determines to which routine the data read or written to a
// specific port should be sent.
//

EMULATOR_ACCESS_ENTRY VgaEmulatorAccessEntries[] = {

    //
    // Traps for byte OUTs.
    //

    {
        0x000003b0,                   // range start I/O address
        0xC,                         // range length
        Uchar,                        // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                        // does not support string accesses
        (PVOID)VgaValidatorUcharEntry // routine to which to trap
    },

    {
        0x000003c0,                   // range start I/O address
        0x20,                         // range length
        Uchar,                        // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                        // does not support string accesses
        (PVOID)VgaValidatorUcharEntry // routine to which to trap
    },

    //
    // Let the BIOS read the extended registers when it's running a DOS
    // app from fullscreen
    //

    {
        WD_EXT_PORT_START,            // range start I/O address
        WD_EXT_PORT_END - WD_EXT_PORT_START + 1, // length
        Uchar,                        // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                        // does not support string accesses
        (PVOID)VgaValidatorUcharEntry // routine to which to trap
    },

    //
    // Traps for word OUTs.
    //

    {
        0x000003b0,
        0x06,
        Ushort,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUshortEntry
    },

    {
        0x000003c0,
        0x10,
        Ushort,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUshortEntry
    },

    //
    // Let the BIOS read the extended registers when it's running a DOS
    // app from fullscreen
    //

    {
        WD_EXT_PORT_START,
        (WD_EXT_PORT_END - WD_EXT_PORT_START + 1)/2,
        Ushort,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUshortEntry
    },

    //
    // Traps for dword OUTs.
    //

    {
        0x000003b0,
        0x03,
        Ulong,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUlongEntry
    },

    {
        0x000003c0,
        0x08,
        Ulong,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUlongEntry
    },

    //
    // Let the BIOS read the extended registers when it's running a DOS
    // app from fullscreen
    //

    {
        WD_EXT_PORT_START,
        (WD_EXT_PORT_END - WD_EXT_PORT_START + 1)/4,
        Ulong,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUlongEntry
    }


};


//
// Used to trap only the sequncer and the misc output registers
//

VIDEO_ACCESS_RANGE MinimalVgaValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,
    1,
    1,        // <- enable range IOPM so that it is not trapped.
    0
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    0
},
{
    VGA_BASE_IO_PORT + MISC_OUTPUT_REG_WRITE_PORT, 0x00000000,
    0x00000001,
    1,
    0,
    0
},
{
    VGA_BASE_IO_PORT + SEQ_ADDRESS_PORT, 0x00000000,
    0x00000002,
    1,
    0,
    0
}
};

//
// Used to trap all registers
//

VIDEO_ACCESS_RANGE FullVgaValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,
    1,
    0,        // <- disable range in the IOPM so that it is trapped.
    0
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    0,
    0
}
};

USHORT MODESET_MODEX_320_200[] = {
    OW,
    SEQ_ADDRESS_PORT,
    0x0604,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    2,
    0xe317,
    0x0014,

    EOD
};

USHORT MODESET_MODEX_320_240[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0604,
    0x0100,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,
    SEQ_ADDRESS_PORT,
    0x0300,

    OB,
    CRTC_ADDRESS_PORT_COLOR,
    0x11,

    METAOUT+MASKOUT,
    CRTC_DATA_PORT_COLOR,
    0x7f, 0x00,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    10,
    0x0d06,
    0x3e07,
    0x4109,
    0xea10,
    0xac11,
    0xdf12,
    0x0014,
    0xe715,
    0x0616,
    0xe317,

    OW,
    SEQ_ADDRESS_PORT,
    0x0f02,

    EOD
};

USHORT MODESET_MODEX_320_400[] = {
    OW,
    SEQ_ADDRESS_PORT,
    0x0604,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    3,
    0xe317,
    0x0014,
    0x4009,

    EOD
};

USHORT MODESET_MODEX_320_480[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0604,
    0x0100,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,
    SEQ_ADDRESS_PORT,
    0x0300,

    OB,
    CRTC_ADDRESS_PORT_COLOR,
    0x11,

    METAOUT+MASKOUT,
    CRTC_DATA_PORT_COLOR,
    0x7f, 0x00,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    10,
    0x0d06,
    0x3e07,
    0x4109,
    0xea10,
    0xac11,
    0xdf12,
    0x0014,
    0xe715,
    0x0616,
    0xe317,

    OW,
    SEQ_ADDRESS_PORT,
    0x0f02,

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x4009,

    EOD
};



/**************************************************************************
*                                                                         *
*    Western Digital Color text mode, 640x350, 8x14 char                  *
*                                                                         *
**************************************************************************/

USHORT WDVGA_TEXT_1[] = {
//  SEQ index 7h-9h, 10h-14h
    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    8,
    0xf807,0x0008,0x0009,0xc510,0x6511,0x0412,0x8013,0x1014,

    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0101,0x0302,0x0003,0x0204,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xa3,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0e06,
    
//  EndSyncResetCmd
    OB,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

//  CRTC index 2ah-30h, 3eh
    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    7,                              // count
    0x2a,                              // start index
    0xf0,0x05,0x00,0x00,0x00,0x42,0x00,

    OW,                             //
    CRTC_ADDRESS_PORT_COLOR,
    0x003e,                         

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,0x00,0x4d,0xb,0xc,0x0,0x0,0x0,0x0,
    0x83,0x85,0x5d,0x28,0x1f,0x63,0xba,0xa3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x00,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    7,                              // count       
    9,                              // start index 
    0x00,0x00,0xc6,0x02,0x00,0x00,0x05,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x10,0x0e,0x0,0x0FF,

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    EOD
};

USHORT WDVGA_640x480x256_60hz[] = {

    OW, CRTC_ADDRESS_PORT_COLOR, 0x8c11,
    OW, GRAPH_ADDRESS_PORT, 0x410e,
    OW, GRAPH_ADDRESS_PORT, 0x412e,
    OW, SEQ_ADDRESS_PORT, 0x1d31,

    /*
    OW, 0x24, 0x8c11,
    OW, 0x1e, 0x410e,
    OW, 0x1e, 0x412e,
    OW, 0x14, 0x1d31,
    */

//  OW, CRTC_ADDRESS_PORT_COLOR, pr12 + 0x100 * pr12_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr13 + 0x100 * pr13_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr14 + 0x100 * pr14_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr15 + 0x100 * pr15_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr16 + 0x100 * (pr16_all & 0x00) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * pr17_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr18 + 0x100 * pr18_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr19 + 0x100 * pr19_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr39 + 0x100 * pr39_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1a + 0x100 * pr1a_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr36 + 0x100 * pr36_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr37 + 0x100 * pr37_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr18a+ 0x100 * pr18a_all    ,
//  OW, CRTC_ADDRESS_PORT_COLOR, pr41 + 0x100 * pr41_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr44 + 0x100 * pr44_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr35 + 0x100 * pr35_all     ,

// CRTC shadows
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * (crtc11_s32 & ~0x80),
    OW, CRTC_ADDRESS_PORT_COLOR, 0x00 + 0x100 * crtc00_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x02 + 0x100 * crtc02_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x03 + 0x100 * crtc03_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x04 + 0x100 * crtc04_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x05 + 0x100 * crtc05_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x06 + 0x100 * crtc06_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x07 + 0x100 * crtc07_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x09 + 0x100 * 0x00         ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x10 + 0x100 * crtc10_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * crtc11_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x15 + 0x100 * crtc15_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x16 + 0x100 * crtc16_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock_pr ,

//  SEQ index 1h-4h
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100, 0x0101,0x0f02,0x0003,0x0e04,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
  ( 0x23 | 0xc0 | 0x00 ),           //   Sync Polarity (H,V)=(-,-)

    OW, SEQ_ADDRESS_PORT       , pr68 + 0x100 * 0x0d         ,
                                    //   Dot Clock = 25.175MHz

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x2c11,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,0x53,0x9f,0x0B,0x3E,0x00,0x40,0x0,0x0,0x0,0x0,0x0,0x0,
    0xEA,0x2C,0xDF,0x50,0x40,0xE7,0x4,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x41,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    OB,                             // feature control
    FEAT_CTRL_WRITE_PORT_COLOR,
    0x04,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
//  Video Mode:   640x480x8bpp @ 72Hz
//  Displays:     640x480 Color TFT LCD + External CRT simultaneous display mode
//

USHORT WDVGA_640x480x256_72hz[] = {

    OW, CRTC_ADDRESS_PORT_COLOR, 0x8c11,
    OW, GRAPH_ADDRESS_PORT, 0x410e,
    OW, GRAPH_ADDRESS_PORT, 0x412e,
    OW, SEQ_ADDRESS_PORT, 0x1d31,

    OW, 0x24, 0x8c11,
    OW, 0x1e, 0x410e,
    OW, 0x1e, 0x412e,
    OW, 0x14, 0x1d31,

//  OW, CRTC_ADDRESS_PORT_COLOR, pr12 + 0x100 * pr12_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr13 + 0x100 * pr13_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr14 + 0x100 * pr14_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr15 + 0x100 * pr15_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr16 + 0x100 * (pr16_all & 0x00) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * pr17_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr18 + 0x100 * pr18_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr19 + 0x100 * pr19_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr39 + 0x100 * pr39_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1a + 0x100 * pr1a_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr36 + 0x100 * pr36_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr37 + 0x100 * pr37_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr18a+ 0x100 * pr18a_all    ,
//  OW, CRTC_ADDRESS_PORT_COLOR, pr41 + 0x100 * pr41_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr44 + 0x100 * pr44_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr35 + 0x100 * pr35_all     ,

// CRTC shadows
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * (crtc11_s32 & ~0x80),
    OW, CRTC_ADDRESS_PORT_COLOR, 0x00 + 0x100 * 0x63   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x02 + 0x100 * crtc02_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x03 + 0x100 * 0x86   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x04 + 0x100 * 0x54   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x05 + 0x100 * 0x99   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x06 + 0x100 * crtc06_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x07 + 0x100 * crtc07_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x09 + 0x100 * 0x00         ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x10 + 0x100 * crtc10_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * crtc11_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x15 + 0x100 * crtc15_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x16 + 0x100 * crtc16_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock_pr ,

//  SEQ index 1h-4h
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100, 0x0101,0x0f02,0x0003,0x0e04,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
  ( 0x23 | 0xc0 | 0x00 ),           //   Sync Polarity (H,V)=(-,-)

    OW, SEQ_ADDRESS_PORT       , pr68 + 0x100 * 0x1d         ,
                                    //   Dot Clock = 31.500MHz

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x2F11,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x63,0x4F,0x50,0x86,0x54,0x99,0x0B,0x3E,0x00,0x40,0x0,0x0,0x0,0x0,0x0,0x0,
    0xEC,0x2F,0xDF,0x50,0x40,0xE7,0x4,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x41,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    OB,                             // feature control
    FEAT_CTRL_WRITE_PORT_COLOR,
    0x04,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
//  Video Mode:   640x480x8bpp @ 75Hz
//  Displays:     640x480 Color TFT LCD + External CRT simultaneous display mode
//

USHORT WDVGA_640x480x256_75hz[] = {

    OW, CRTC_ADDRESS_PORT_COLOR, 0x8c11,
    OW, GRAPH_ADDRESS_PORT, 0x410e,
    OW, GRAPH_ADDRESS_PORT, 0x412e,
    OW, SEQ_ADDRESS_PORT, 0x1d31,

    OW, 0x24, 0x8c11,
    OW, 0x1e, 0x410e,
    OW, 0x1e, 0x412e,
    OW, 0x14, 0x1d31,

//  OW, CRTC_ADDRESS_PORT_COLOR, pr12 + 0x100 * pr12_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr13 + 0x100 * pr13_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr14 + 0x100 * pr14_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr15 + 0x100 * pr15_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr16 + 0x100 * (pr16_all & 0x00) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * pr17_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr18 + 0x100 * pr18_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr19 + 0x100 * pr19_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr39 + 0x100 * pr39_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1a + 0x100 * pr1a_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr36 + 0x100 * pr36_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr37 + 0x100 * pr37_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr18a+ 0x100 * pr18a_all    ,
//  OW, CRTC_ADDRESS_PORT_COLOR, pr41 + 0x100 * pr41_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr44 + 0x100 * pr44_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr35 + 0x100 * pr35_all     ,

// CRTC shadows
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * (crtc11_s32 & ~0x80),
    OW, CRTC_ADDRESS_PORT_COLOR, 0x00 + 0x100 * crtc00_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x02 + 0x100 * crtc02_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x03 + 0x100 * crtc03_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x04 + 0x100 * crtc04_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x05 + 0x100 * crtc05_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x06 + 0x100 * crtc06_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x07 + 0x100 * crtc07_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x09 + 0x100 * 0x00         ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x10 + 0x100 * crtc10_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * crtc11_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x15 + 0x100 * crtc15_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x16 + 0x100 * crtc16_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock_pr ,

//  SEQ index 1h-4h
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100, 0x0101,0x0f02,0x0003,0x0e04,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
  ( 0x23 | 0xc0 | 0x00 ),           //   Sync Polarity (H,V)=(-,-)

    OW, SEQ_ADDRESS_PORT       , pr68 + 0x100 * 0x1d         ,
                                    //   Dot Clock = 31.500MHz

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x2C11,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,0x53,0x9f,0x0B,0x3E,0x00,0x40,0x0,0x0,0x0,0x0,0x0,0x0,
    0xEA,0x2C,0xDF,0x50,0x40,0xE7,0x4,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x41,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    OB,                             // feature control
    FEAT_CTRL_WRITE_PORT_COLOR,
    0x04,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
//  Video Mode:   640x480x16bpp @ 60Hz
//  Displays:     640x480 Color TFT LCD + External CRT simultaneous display mode
//

USHORT WDVGA_640x480x64k_60hz[] = {

    OW, CRTC_ADDRESS_PORT_COLOR, 0x8c11,
    OW, GRAPH_ADDRESS_PORT, 0x410e,
    OW, GRAPH_ADDRESS_PORT, 0x412e,
    OW, SEQ_ADDRESS_PORT, 0x1d31,

    OW, 0x24, 0x8c11,
    OW, 0x1e, 0x410e,
    OW, 0x1e, 0x412e,
    OW, 0x14, 0x1d31,

//  OW, CRTC_ADDRESS_PORT_COLOR, pr12 + 0x100 * pr12_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr13 + 0x100 * pr13_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr14 + 0x100 * pr14_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr15 + 0x100 * pr15_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr16 + 0x100 * (pr16_all & 0x00) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * (pr17_all | 0x10) ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr18 + 0x100 * pr18_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr19 + 0x100 * pr19_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr39 + 0x100 * pr39_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1a + 0x100 * pr1a_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr36 + 0x100 * pr36_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr37 + 0x100 * pr37_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr18a+ 0x100 * pr18a_all    ,
//  OW, CRTC_ADDRESS_PORT_COLOR, pr41 + 0x100 * pr41_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr44 + 0x100 * pr44_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr35 + 0x100 * pr35_all     ,

// CRTC shadows
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * (crtc11_s32 & ~0x80),
    OW, CRTC_ADDRESS_PORT_COLOR, 0x00 + 0x100 * crtc00_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x02 + 0x100 * crtc02_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x03 + 0x100 * crtc03_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x04 + 0x100 * crtc04_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x05 + 0x100 * crtc05_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x06 + 0x100 * crtc06_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x07 + 0x100 * crtc07_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x09 + 0x100 * 0x00         ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x10 + 0x100 * crtc10_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * crtc11_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x15 + 0x100 * crtc15_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x16 + 0x100 * crtc16_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock_pr ,

//  SEQ index 1h-4h
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100, 0x0101,0x0f02,0x0003,0x0e04,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
  ( 0x23 | 0xc0 | 0x00 ),           //   Sync Polarity (H,V)=(-,-)

    OW, SEQ_ADDRESS_PORT       , pr68 + 0x100 * 0x0d         ,
                                    //   Dot Clock = 25.175MHz

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x2C11,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,0x53,0x9f,0x0B,0x3E,0x00,0x40,0x0,0x0,0x0,0x0,0x0,0x0,
    0xEA,0x2C,0xDF,0xA0,0x40,0xE7,0x4,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x41,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    OB,                             // feature control
    FEAT_CTRL_WRITE_PORT_COLOR,
    0x04,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
//  Video Mode:   640x480x16bpp @ 72Hz
//  Displays:     640x480 Color TFT LCD + External CRT simultaneous display mode
//

USHORT WDVGA_640x480x64k_72hz[] = {

    OW, CRTC_ADDRESS_PORT_COLOR, 0x8c11,
    OW, GRAPH_ADDRESS_PORT, 0x410e,
    OW, GRAPH_ADDRESS_PORT, 0x412e,
    OW, SEQ_ADDRESS_PORT, 0x1d31,

    OW, 0x24, 0x8c11,
    OW, 0x1e, 0x410e,
    OW, 0x1e, 0x412e,
    OW, 0x14, 0x1d31,

//  OW, CRTC_ADDRESS_PORT_COLOR, pr12 + 0x100 * pr12_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr13 + 0x100 * pr13_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr14 + 0x100 * pr14_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr15 + 0x100 * pr15_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr16 + 0x100 * (pr16_all & 0x00) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * (pr17_all | 0x10) ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr18 + 0x100 * pr18_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr19 + 0x100 * pr19_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr39 + 0x100 * pr39_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1a + 0x100 * pr1a_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr36 + 0x100 * pr36_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr37 + 0x100 * pr37_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr18a+ 0x100 * pr18a_all    ,
//  OW, CRTC_ADDRESS_PORT_COLOR, pr41 + 0x100 * pr41_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr44 + 0x100 * pr44_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr35 + 0x100 * pr35_all     ,

// CRTC shadows
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * (crtc11_s32 & ~0x80),
    OW, CRTC_ADDRESS_PORT_COLOR, 0x00 + 0x100 * 0x63   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x02 + 0x100 * crtc02_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x03 + 0x100 * 0x86   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x04 + 0x100 * 0x54   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x05 + 0x100 * 0x99   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x06 + 0x100 * crtc06_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x07 + 0x100 * crtc07_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x09 + 0x100 * 0x00         ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x10 + 0x100 * crtc10_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * crtc11_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x15 + 0x100 * crtc15_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x16 + 0x100 * crtc16_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock_pr ,

//  SEQ index 1h-4h
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100, 0x0101,0x0f02,0x0003,0x0e04,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
  ( 0x23 | 0xc0 | 0x00 ),           //   Sync Polarity (H,V)=(-,-)

    OW, SEQ_ADDRESS_PORT       , pr68 + 0x100 * 0x1d         ,
                                    //   Dot Clock = 31.500MHz

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x2F11,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x63,0x4F,0x50,0x86,0x54,0x99,0x0B,0x3E,0x00,0x40,0x0,0x0,0x0,0x0,0x0,0x0,
    0xEC,0x2F,0xDF,0xA0,0x40,0xE7,0x4,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x41,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    OB,                             // feature control
    FEAT_CTRL_WRITE_PORT_COLOR,
    0x04,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
//  Video Mode:   640x480x16bpp @ 75Hz
//  Displays:     640x480 Color TFT LCD + External CRT simultaneous display mode
//

USHORT WDVGA_640x480x64k_75hz[] = {

    OW, CRTC_ADDRESS_PORT_COLOR, 0x8c11,
    OW, GRAPH_ADDRESS_PORT, 0x410e,
    OW, GRAPH_ADDRESS_PORT, 0x412e,
    OW, SEQ_ADDRESS_PORT, 0x1d31,

    OW, 0x24, 0x8c11,
    OW, 0x1e, 0x410e,
    OW, 0x1e, 0x412e,
    OW, 0x14, 0x1d31,

//  OW, CRTC_ADDRESS_PORT_COLOR, pr12 + 0x100 * pr12_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr13 + 0x100 * pr13_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr14 + 0x100 * pr14_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr15 + 0x100 * pr15_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr16 + 0x100 * (pr16_all & 0x00) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * (pr17_all | 0x10) ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr18 + 0x100 * pr18_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr19 + 0x100 * pr19_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr39 + 0x100 * pr39_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1a + 0x100 * pr1a_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr36 + 0x100 * pr36_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr37 + 0x100 * pr37_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr18a+ 0x100 * pr18a_all    ,
//  OW, CRTC_ADDRESS_PORT_COLOR, pr41 + 0x100 * pr41_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr44 + 0x100 * pr44_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr35 + 0x100 * pr35_all     ,

// CRTC shadows
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * (crtc11_s32 & ~0x80),
    OW, CRTC_ADDRESS_PORT_COLOR, 0x00 + 0x100 * crtc00_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x02 + 0x100 * crtc02_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x03 + 0x100 * crtc03_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x04 + 0x100 * crtc04_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x05 + 0x100 * crtc05_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x06 + 0x100 * crtc06_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x07 + 0x100 * crtc07_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x09 + 0x100 * 0x00         ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x10 + 0x100 * crtc10_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * crtc11_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x15 + 0x100 * crtc15_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x16 + 0x100 * crtc16_s32   ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock_pr ,

//  SEQ index 1h-4h
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100, 0x0101,0x0f02,0x0003,0x0e04,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
  ( 0x23 | 0xc0 | 0x00 ),           //   Sync Polarity (H,V)=(-,-)

    OW, SEQ_ADDRESS_PORT       , pr68 + 0x100 * 0x1d         ,
                                    //   Dot Clock = 31.500MHz

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x2C11,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,0x53,0x9f,0x0B,0x3E,0x00,0x40,0x0,0x0,0x0,0x0,0x0,0x0,
    0xEA,0x2C,0xDF,0xA0,0x40,0xE7,0x4,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x41,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    OB,                             // feature control
    FEAT_CTRL_WRITE_PORT_COLOR,
    0x04,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
//  Video Mode:   800x600x8bpp @ 60Hz
//  Displays:     800x600 Color TFT LCD + External CRT simultaneous display mode
//

USHORT WDVGA_800x600x256_SVGA[] = {

    OW, CRTC_ADDRESS_PORT_COLOR, 0x8c11,
    OW, GRAPH_ADDRESS_PORT, 0x410e,
    OW, GRAPH_ADDRESS_PORT, 0x412e,
    OW, SEQ_ADDRESS_PORT, 0x1d31,

    OW, 0x24, 0x8c11,
    OW, 0x1e, 0x410e,
    OW, 0x1e, 0x412e,
    OW, 0x14, 0x1d31,

//  OW, CRTC_ADDRESS_PORT_COLOR, pr12 + 0x100 * pr12_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr13 + 0x100 * pr13_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr14 + 0x100 * pr14_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr15 + 0x100 * pr15_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr16 + 0x100 * (pr16_all & 0x00) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * pr17_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr18 + 0x100 * pr18_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr19 + 0x100 * pr19_tft800  ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr39 + 0x100 * pr39_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1a + 0x100 * pr1a_tft800  ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr36 + 0x100 * pr36_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr37 + 0x100 * pr37_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr18a+ 0x100 * pr18a_all    ,
//  OW, CRTC_ADDRESS_PORT_COLOR, pr41 + 0x100 * pr41_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr44 + 0x100 * pr44_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr35 + 0x100 * pr35_all     ,

// CRTC shadows
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * (crtc11_tft800 & ~0x80),
    OW, CRTC_ADDRESS_PORT_COLOR, 0x00 + 0x100 * crtc00_tft800,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x02 + 0x100 * crtc02_tft800,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x03 + 0x100 * crtc03_tft800,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x04 + 0x100 * crtc04_tft800,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x05 + 0x100 * crtc05_tft800,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x06 + 0x100 * crtc06_tft800,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x07 + 0x100 * crtc07_tft800,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x09 + 0x100 * 0x20         ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x10 + 0x100 * crtc10_tft800,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * crtc11_tft800,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x15 + 0x100 * crtc15_tft800,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x16 + 0x100 * crtc16_tft800,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock_pr ,

//  SEQ index 1h-4h
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100, 0x0101,0x0f02,0x0303,0x0e04,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
  ( 0x23 | 0x00 | 0x00 ),           //   Sync Polarity (H,V)=(+,+)

    OW, SEQ_ADDRESS_PORT       , pr68 + 0x100 * 0x15         ,
                                    //   Dot Clock = 39.822MHz

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x2c11,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x7f,0x63,0x64,0x82,0x6b,0x1b,0x72,0xf0,0x00,0x60,0x0,0x0,0x0,0x0,0x0,0x0,
    0x58,0x2c,0x57,0x64,0x40,0x58,0x71,0xe3,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x41,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    OB,                             // feature control
    FEAT_CTRL_WRITE_PORT_COLOR,
    0x04,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
//  Video Mode:   800x600x16bpp @ 56Hz
//  Displays:     800x600 Color TFT LCD + External CRT simultaneous display mode
//

USHORT WDVGA_800x600x64K_SVGA[] = {

    OW, CRTC_ADDRESS_PORT_COLOR, 0x8c11,
    OW, GRAPH_ADDRESS_PORT, 0x410e,
    OW, GRAPH_ADDRESS_PORT, 0x412e,
    OW, SEQ_ADDRESS_PORT, 0x1d31,

    OW, 0x24, 0x8c11,
    OW, 0x1e, 0x410e,
    OW, 0x1e, 0x412e,
    OW, 0x14, 0x1d31,

//  OW, CRTC_ADDRESS_PORT_COLOR, pr12 + 0x100 * pr12_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr13 + 0x100 * pr13_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr14 + 0x100 * pr14_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr15 + 0x100 * (pr15_all | 0x40) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr16 + 0x100 * (pr16_all & 0x00) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * (pr17_all | 0x10) ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr18 + 0x100 * pr18_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr19 + 0x100 * pr19_tft800  ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr39 + 0x100 * pr39_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1a + 0x100 * pr1a_tft800  ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr36 + 0x100 * pr36_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr37 + 0x100 * pr37_s32     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr18a+ 0x100 * pr18a_all    ,
//  OW, CRTC_ADDRESS_PORT_COLOR, pr41 + 0x100 * pr41_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr44 + 0x100 * pr44_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr35 + 0x100 * pr35_all     ,

// CRTC shadows
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * (crtc11_tft800 & ~0x80),
    OW, CRTC_ADDRESS_PORT_COLOR, 0x00 + 0x100 * 0x7b         ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x02 + 0x100 * crtc02_tft800,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x03 + 0x100 * 0x9e         ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x04 + 0x100 * 0x69         ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x05 + 0x100 * 0x92         ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x06 + 0x100 * 0x6f         ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x07 + 0x100 * crtc07_tft800,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x09 + 0x100 * 0x20         ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x10 + 0x100 * crtc10_tft800,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * 0x2a         ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x15 + 0x100 * crtc15_tft800,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x16 + 0x100 * 0x6f         ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock_pr ,

//  SEQ index 1h-4h
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100, 0x0101,0x0f02,0x0303,0x0e04,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
  ( 0x23 | 0x00 | 0x0c ),           //   Sync Polarity (H,V)=(+,+)

    OW, SEQ_ADDRESS_PORT       , pr68 + 0x100 * 0x0d         ,
                                    //   Dot Clock = 36.000MHz

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x2a11,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x7b,0x63,0x64,0x9e,0x69,0x92,0x6f,0xf0,0x00,0x60,0x0,0x0,0x0,0x0,0x0,0x0,
    0x58,0x2a,0x57,0xc8,0x40,0x58,0x6f,0xe3,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x41,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    OB,                             // feature control
    FEAT_CTRL_WRITE_PORT_COLOR,
    0x04,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
//  Video Mode:   800x600x8bpp @ 60Hz
//  Displays:     External CRT only display mode
//

USHORT WDVGA_800x600x256_60hz[] = {

    OW, CRTC_ADDRESS_PORT_COLOR, 0x8c11,
    OW, GRAPH_ADDRESS_PORT, 0x410e,
    OW, GRAPH_ADDRESS_PORT, 0x412e,
    OW, SEQ_ADDRESS_PORT, 0x1d31,

    OW, 0x24, 0x8c11,
    OW, 0x1e, 0x410e,
    OW, 0x1e, 0x412e,
    OW, 0x14, 0x1d31,

//  OW, CRTC_ADDRESS_PORT_COLOR, pr12 + 0x100 * pr12_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr13 + 0x100 * pr13_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr14 + 0x100 * pr14_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr15 + 0x100 * pr15_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr16 + 0x100 * (pr16_all & 0x00) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * pr17_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr18 + 0x100 * pr18_crt_tft ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr19 + 0x100 * pr19_crt     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr39 + 0x100 * pr39_crt     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1a + 0x100 * pr1a_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr36 + 0x100 * pr36_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr37 + 0x100 * pr37_crt     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr18a+ 0x100 * pr18a_all    ,
//  OW, CRTC_ADDRESS_PORT_COLOR, pr41 + 0x100 * pr41_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr44 + 0x100 * pr44_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr35 + 0x100 * pr35_all     ,

// CRTC shadows
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock  ,

//  SEQ index 1h-4h
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100, 0x0101,0x0f02,0x0303,0x0e04,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
  ( 0x23 | 0x00 | 0x00 ),           //   Sync Polarity (H,V)=(+,+)

    OW, SEQ_ADDRESS_PORT       , pr68 + 0x100 * 0x15         ,
                                    //   Dot Clock = 39.822MHz

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x2c11,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x7f,0x63,0x64,0x82,0x6b,0x1b,0x72,0xf0,0x00,0x60,0x0,0x0,0x0,0x0,0x0,0x0,
    0x58,0x2c,0x57,0x64,0x40,0x58,0x71,0xe3,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x41,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    OB,                             // feature control
    FEAT_CTRL_WRITE_PORT_COLOR,
    0x04,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
//  Video Mode:   800x600x8bpp @ 72Hz
//  Displays:     External CRT only display mode
//

USHORT WDVGA_800x600x256_72hz[] = {

    OW, CRTC_ADDRESS_PORT_COLOR, 0x8c11,
    OW, GRAPH_ADDRESS_PORT, 0x410e,
    OW, GRAPH_ADDRESS_PORT, 0x412e,
    OW, SEQ_ADDRESS_PORT, 0x1d31,

    OW, 0x24, 0x8c11,
    OW, 0x1e, 0x410e,
    OW, 0x1e, 0x412e,
    OW, 0x14, 0x1d31,


//  OW, CRTC_ADDRESS_PORT_COLOR, pr12 + 0x100 * pr12_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr13 + 0x100 * pr13_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr14 + 0x100 * pr14_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr15 + 0x100 * pr15_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr16 + 0x100 * (pr16_all & 0x00) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * pr17_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr18 + 0x100 * pr18_crt_tft ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr19 + 0x100 * pr19_crt     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr39 + 0x100 * pr39_crt     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1a + 0x100 * pr1a_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr36 + 0x100 * pr36_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr37 + 0x100 * pr37_crt     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr18a+ 0x100 * pr18a_all    ,
//  OW, CRTC_ADDRESS_PORT_COLOR, pr41 + 0x100 * pr41_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr44 + 0x100 * pr44_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr35 + 0x100 * pr35_all     ,

// CRTC shadows
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock  ,

//  SEQ index 1h-4h
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100, 0x0101,0x0f02,0x0303,0x0e04,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
  ( 0x23 | 0x00 | 0x04 ),           //   Sync Polarity (H,V)=(+,+)

    OW, SEQ_ADDRESS_PORT       , pr68 + 0x100 * 0x15         ,
                                    //   Dot Clock = 50.114MHz

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x7311,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x7E,0x63,0x64,0x81,0x6B,0x1A,0x96,0xF0,0x00,0x60,0x0,0x0,0x0,0x0,0x0,0x0,
    0x6D,0x73,0x57,0x64,0x40,0x5A,0x94,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x41,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    OB,                             // feature control
    FEAT_CTRL_WRITE_PORT_COLOR,
    0x04,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
//  Video Mode:   800x600x16bpp @ 56Hz
//  Displays:     External CRT only display mode
//

USHORT WDVGA_800x600x64k_56hz[] = {

    OW, CRTC_ADDRESS_PORT_COLOR, 0x8c11,
    OW, GRAPH_ADDRESS_PORT, 0x410e,
    OW, GRAPH_ADDRESS_PORT, 0x412e,
    OW, SEQ_ADDRESS_PORT, 0x1d31,

    OW, 0x24, 0x8c11,
    OW, 0x1e, 0x410e,
    OW, 0x1e, 0x412e,
    OW, 0x14, 0x1d31,

//  OW, CRTC_ADDRESS_PORT_COLOR, pr12 + 0x100 * pr12_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr13 + 0x100 * pr13_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr14 + 0x100 * pr14_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr15 + 0x100 * (pr15_all | 0x40) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr16 + 0x100 * (pr16_all & 0x00) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * (pr17_all | 0x10) ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr18 + 0x100 * pr18_crt_tft ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr19 + 0x100 * pr19_crt     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr39 + 0x100 * pr39_crt     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1a + 0x100 * pr1a_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr36 + 0x100 * pr36_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr37 + 0x100 * pr37_crt     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr18a+ 0x100 * pr18a_all    ,
//  OW, CRTC_ADDRESS_PORT_COLOR, pr41 + 0x100 * pr41_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr44 + 0x100 * pr44_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr35 + 0x100 * pr35_all     ,

// CRTC shadows
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock  ,

//  SEQ index 1h-4h
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100, 0x0101,0x0f02,0x0303,0x0e04,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
  ( 0x23 | 0x00 | 0x0c ),           //   Sync Polarity (H,V)=(+,+)

    OW, SEQ_ADDRESS_PORT       , pr68 + 0x100 * 0x0d         ,
                                    //   Dot Clock = 36.000MHz

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x2a11,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x7b,0x63,0x64,0x9e,0x69,0x92,0x6f,0xf0,0x00,0x60,0x0,0x0,0x0,0x0,0x0,0x0,
    0x58,0x2a,0x57,0xc8,0x40,0x58,0x6f,0xe3,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x41,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    OB,                             // feature control
    FEAT_CTRL_WRITE_PORT_COLOR,
    0x04,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
//  Video Mode:   1024x768x8bpp @ 60Hz
//  Displays:     External CRT only display mode
//

USHORT WDVGA_1024x768x256_60hz[] = {

    OW, CRTC_ADDRESS_PORT_COLOR, 0x8c11,
    OW, GRAPH_ADDRESS_PORT, 0x410e,
    OW, GRAPH_ADDRESS_PORT, 0x412e,
    OW, SEQ_ADDRESS_PORT, 0x1d31,

    OW, 0x24, 0x8c11,
    OW, 0x1e, 0x410e,
    OW, 0x1e, 0x412e,
    OW, 0x14, 0x1d31,

//  OW, CRTC_ADDRESS_PORT_COLOR, pr12 + 0x100 * pr12_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr13 + 0x100 * pr13_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr14 + 0x100 * pr14_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr15 + 0x100 * (pr15_all | 0x40) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr16 + 0x100 * (pr16_all & 0x00) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * pr17_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr18 + 0x100 * pr18_crt_tft ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr19 + 0x100 * pr19_crt     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr39 + 0x100 * pr39_crt     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1a + 0x100 * pr1a_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr36 + 0x100 * pr36_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr37 + 0x100 * pr37_crt     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr18a+ 0x100 * pr18a_all    ,
//  OW, CRTC_ADDRESS_PORT_COLOR, pr41 + 0x100 * pr41_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr44 + 0x100 * pr44_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr35 + 0x100 * pr35_all     ,

// CRTC shadows
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock  ,

//  SEQ index 1h-4h
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100, 0x0101,0x0f02,0x0303,0x0e04,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
  ( 0x23 | 0xc0 | 0x08 ),           //   Sync Polarity (H,V)=(-,-)

    OW, SEQ_ADDRESS_PORT       , pr68 + 0x100 * 0x0d         ,
                                    //   Dot Clock = 65.000MHz

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x2711,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0xa3,0x7f,0x80,0x06,0x84,0x95,0x24,0xfd,0x00,0x60,0x0,0x0,0x0,0x0,0x0,0x0,
    0x01,0x27,0xff,0x80,0x40,0x00,0x24,0xe3,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x41,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    OB,                             // feature control
    FEAT_CTRL_WRITE_PORT_COLOR,
    0x04,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
//  Video Mode:   1024x768x8bpp @ 43.5Hz (interlaced)
//  Displays:     External CRT only display mode
//

USHORT WDVGA_1024x768x256_int[] = {

    OW, CRTC_ADDRESS_PORT_COLOR, 0x8c11,
    OW, GRAPH_ADDRESS_PORT, 0x410e,
    OW, GRAPH_ADDRESS_PORT, 0x412e,
    OW, SEQ_ADDRESS_PORT, 0x1d31,

    OW, 0x24, 0x8c11,
    OW, 0x1e, 0x410e,
    OW, 0x1e, 0x412e,
    OW, 0x14, 0x1d31,

//  OW, CRTC_ADDRESS_PORT_COLOR, pr12 + 0x100 * pr12_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr13 + 0x100 * 0x34         ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr14 + 0x100 * 0x2a         ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr15 + 0x100 * 0x4b         ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr16 + 0x100 * (pr16_all & 0x00) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * pr17_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr18 + 0x100 * pr18_crt_tft ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr19 + 0x100 * pr19_crt     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr39 + 0x100 * pr39_crt     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1a + 0x100 * pr1a_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr36 + 0x100 * pr36_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr37 + 0x100 * pr37_crt     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr18a+ 0x100 * pr18a_all    ,
//  OW, CRTC_ADDRESS_PORT_COLOR, pr41 + 0x100 * pr41_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr44 + 0x100 * pr44_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr35 + 0x100 * pr35_all     ,

// CRTC shadows
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock  ,

//  SEQ index 1h-4h
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100, 0x0101,0x0f02,0x0303,0x0e04,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
  ( 0x23 | 0x00 | 0x08 ),           //   Sync Polarity (H,V)=(+,+)

    OW, SEQ_ADDRESS_PORT       , pr69 + 0x100 * 0x64         ,
    OW, SEQ_ADDRESS_PORT       , pr68 + 0x100 * 0x05         ,
                                    //   Dot Clock = 44.744MHz

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x2311,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x99,0x7F,0x7F,0x1C,0x82,0x19,0x97,0x1F,0x00,0x40,0x0,0x0,0x0,0x0,0x0,0x0,
    0x7F,0x23,0x7F,0x80,0x40,0x7F,0x96,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x41,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    OB,                             // feature control
    FEAT_CTRL_WRITE_PORT_COLOR,
    0x04,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
//  Video Mode:   640x480x8bpp @ 60Hz
//  Displays:     640x480 Color DSTN LCD + External CRT simultaneous display mode
//

USHORT WDVGA_640x480_60STN[] = {

    OW, CRTC_ADDRESS_PORT_COLOR, pr12 + 0x100 * pr12_244LP   ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr13 + 0x100 * pr13_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr14 + 0x100 * pr14_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr15 + 0x100 * pr15_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr16 + 0x100 * (pr16_all & 00) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * pr17_244LP   ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr18 + 0x100 * pr18_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr19 + 0x100 * pr19_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr39 + 0x100 * pr39_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1a + 0x100 * pr1a_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr36 + 0x100 * pr36_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr37 + 0x100 * pr37_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr18a+ 0x100 * pr18a_all    ,
//  OW, CRTC_ADDRESS_PORT_COLOR, pr41 + 0x100 * pr41_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr44 + 0x100 * pr44_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr35 + 0x100 * pr35_all     ,

// CRTC shadows
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * (crtc11_stnc & ~0x80),
    OW, CRTC_ADDRESS_PORT_COLOR, 0x02 + 0x100 * crtc02_stnc_a2 ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x03 + 0x100 * crtc03_stnc_a2 ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x04 + 0x100 * 0x53 ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x05 + 0x100 * 0x9f ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x06 + 0x100 * 0x0b  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x07 + 0x100 * crtc07_stnc  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x04 + 0x100 * 0x53 ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * crtc11_stnc  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x15 + 0x100 * crtc15_stnc  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x16 + 0x100 * crtc16_stnc  ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock_pr ,

//  SEQ index 1h-4h
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100, 0x0101,0x0f02,0x0003,0x0e04,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
  ( 0x23 | 0xc0 | 0x00 ),           //   Sync Polarity (H,V)=(-,-)

    OW, SEQ_ADDRESS_PORT       , pr68 + 0x100 * 0x0d         ,
                                    //   Dot Clock = 25.175MHz

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x2C11,


    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,0x53,0x9f,0x0B,0x3E,0x00,0x40,0x0,0x0,0x0,0x0,0x0,0x0,
    0xEA,0x8C,0xDF,0x50,0x40,0xE7,0x4,0xE3,0xFF,


    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,


    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x41,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    OB,                             // feature control
    FEAT_CTRL_WRITE_PORT_COLOR,
    0x04,

    OW, GRAPH_ADDRESS_PORT, 0x8d0b,
    OW, GRAPH_ADDRESS_PORT, 0x010c,
    OW, GRAPH_ADDRESS_PORT, 0x410e,
    OW, GRAPH_ADDRESS_PORT, 0x8d2b,
    OW, GRAPH_ADDRESS_PORT, 0x012c,
    OW, GRAPH_ADDRESS_PORT, 0x412e,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
//  Video Mode:   640x480x8bpp @ 72Hz
//  Displays:     640x480 Color DSTN LCD + External CRT simultaneous display mode
//

USHORT WDVGA_640x480_72STN[] = {

    /*
    OW, 0x24, 0x8c11,
    OW, 0x1e, 0x410e,
    OW, 0x1e, 0x412e,
    OW, 0x14, 0x1d31,
    */

    OW, CRTC_ADDRESS_PORT_COLOR, pr12 + 0x100 * pr12_244LP   ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr13 + 0x100 * pr13_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr14 + 0x100 * pr14_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr15 + 0x100 * pr15_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr16 + 0x100 * (pr16_all & 00) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * pr17_244LP   ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr18 + 0x100 * pr18_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr19 + 0x100 * pr19_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr39 + 0x100 * pr39_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1a + 0x100 * pr1a_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr36 + 0x100 * pr36_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr37 + 0x100 * pr37_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr18a+ 0x100 * pr18a_all    ,
//  OW, CRTC_ADDRESS_PORT_COLOR, pr41 + 0x100 * pr41_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr44 + 0x100 * pr44_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr35 + 0x100 * pr35_all     ,

// CRTC shadows
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock    ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * (crtc11_stnc & ~0x80),
    //OW, CRTC_ADDRESS_PORT_COLOR, 0x00 + 0x100 * crtc00_stnc_a2 ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x02 + 0x100 * crtc02_stnc_a2 ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x03 + 0x100 * crtc03_stnc_a2 ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x04 + 0x100 * crtc04_stnc_a2 ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x05 + 0x100 * crtc05_stnc_a2 ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x06 + 0x100 * crtc06_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x07 + 0x100 * crtc07_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x09 + 0x100 * 0x00           ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x10 + 0x100 * crtc10_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * crtc11_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x15 + 0x100 * crtc15_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x16 + 0x100 * crtc16_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock_pr ,

//  SEQ index 1h-4h
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100, 0x0101,0x0f02,0x0003,0x0e04,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
  ( 0x23 | 0xc0 | 0x00 ),           //   Sync Polarity (H,V)=(-,-)

    OW, SEQ_ADDRESS_PORT       , pr68 + 0x100 * 0x1d         ,
                                    //   Dot Clock = 31.500MHz

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x2F11,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x63,0x4F,0x50,0x86,0x54,0x99,0x0B,0x3E,0x00,0x40,0x0,0x0,0x0,0x0,0x0,0x0,
    0xEC,0x8F,0xDF,0x50,0x40,0xE7,0x4,0xE3,0xFF,

    //     ^ many need to by 0x8F

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x41,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    OB,                             // feature control
    FEAT_CTRL_WRITE_PORT_COLOR,
    0x04,

    OW, 0x1e, 0x8d0b,
    OW, 0x1e, 0x010c,
    OW, 0x1e, 0x410e,
    OW, 0x1e, 0x8d2b,
    OW, 0x1e, 0x012c,
    OW, 0x1e, 0x412e,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
//  Video Mode:   640x480x8bpp @ 75Hz
//  Displays:     640x480 Color DSTN LCD + External CRT simultaneous display mode
//

USHORT WDVGA_640x480_75STN[] = {

    /*
    OW, 0x24, 0x8c11,
    OW, 0x1e, 0x410e,
    OW, 0x1e, 0x412e,
    OW, 0x14, 0x1d31,
    */

    OW, CRTC_ADDRESS_PORT_COLOR, pr12 + 0x100 * pr12_244LP   ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr13 + 0x100 * pr13_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr14 + 0x100 * pr14_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr15 + 0x100 * pr15_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr16 + 0x100 * (pr16_all & 00) ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr17 + 0x100 * pr17_244LP   ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr18 + 0x100 * pr18_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr19 + 0x100 * pr19_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr39 + 0x100 * pr39_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1a + 0x100 * pr1a_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr36 + 0x100 * pr36_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr37 + 0x100 * pr37_stnc    ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr18a+ 0x100 * pr18a_all    ,
//  OW, CRTC_ADDRESS_PORT_COLOR, pr41 + 0x100 * pr41_all     ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr44 + 0x100 * pr44_all     ,

    OW, CRTC_ADDRESS_PORT_COLOR, pr35 + 0x100 * pr35_all     ,

// CRTC shadows
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * (crtc11_stnc & ~0x80),
    //OW, CRTC_ADDRESS_PORT_COLOR, 0x00 + 0x100 * crtc00_stnc_iso_a2 ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x02 + 0x100 * crtc02_stnc_iso_a2 ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x03 + 0x100 * crtc03_stnc_iso_a2 ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x04 + 0x100 * crtc04_stnc_iso_a2 ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x05 + 0x100 * crtc05_stnc_iso_a2 ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x06 + 0x100 * crtc06_stnc  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x07 + 0x100 * crtc07_stnc  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x09 + 0x100 * 0x00         ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x10 + 0x100 * crtc10_stnc  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x11 + 0x100 * crtc11_stnc  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x15 + 0x100 * crtc15_stnc  ,
    OW, CRTC_ADDRESS_PORT_COLOR, 0x16 + 0x100 * crtc16_stnc  ,
    OW, CRTC_ADDRESS_PORT_COLOR, pr1b + 0x100 * pr1b_unlock_pr ,

//  SEQ index 1h-4h
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100, 0x0101,0x0f02,0x0003,0x0e04,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
  ( 0x23 | 0xc0 | 0x00 ),           //   Sync Polarity (H,V)=(-,-)

    OW, SEQ_ADDRESS_PORT       , pr68 + 0x100 * 0x1d         ,
                                    //   Dot Clock = 31.500MHz

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x2C11,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,0x53,0x9f,0x0B,0x3E,0x00,0x40,0x0,0x0,0x0,0x0,0x0,0x0,
    0xEA,0x8C,0xDF,0x50,0x40,0xE7,0x4,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x41,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    OB,                             // feature control
    FEAT_CTRL_WRITE_PORT_COLOR,
    0x04,

    OW, 0x1e, 0x8d0b,
    OW, 0x1e, 0x010c,
    OW, 0x1e, 0x410e,
    OW, 0x1e, 0x8d2b,
    OW, 0x1e, 0x012c,
    OW, 0x1e, 0x412e,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

#ifndef INT10_MODE_SET      // should be #ifndef
/**************************************************************************
*                                                                         *
*    Western Digital Color text mode, 720x400, 9x16 char                  *
*                                                                         *
**************************************************************************/

USHORT WDVGA_TEXT_0[] = {
//  SEQ index 7h-9h, 10h-14h
    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    8,
    0xf807,0x0008,0x0009,0xc510,0x6511,0x0412,0x8013,0x1014,

    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW, 
    GRAPH_ADDRESS_PORT,
    0x0e06,
    
//  EndSyncResetCmd
    OB,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

//  CRTC index 2ah-30h, 3eh
    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    7,                              // count
    0x2a,                              // start index
    0xf0,0x05,0x00,0x00,0x00,0x42,0x00,

    OW,                             //
    CRTC_ADDRESS_PORT_COLOR,
    0x003e,                         

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,0x00,0x4f,0xd,0xe,0x0,0x0,0x0,0x0,
    0x9c,0x8e,0x8f,0x28,0x1f,0x96,0xb9,0xa3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x04,0x0,0x0F,0x8,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    7,                              // count       
    9,                              // start index 
    0x00,0x00,0xc6,0x02,0x00,0x00,0x05,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x10,0x0e,0x0,0x0FF,

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    EOD
};


/**************************************************************************
*                                                                         *
*    Western Digital Color graphics mode 0x12, 640x480 16 colors          *
*                                                                         *
**************************************************************************/

USHORT WDVGA_640x480[] = {

//  SEQ index 7h-9h, 10h-14h
    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    8,
    0xf807,0x0008,0x0009,0xc510,0x6511,0x0412,0x8013,0x1014,

    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0101,0x0f02,0x0003,0x0604,    

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
    0xe3,

    OW,                             // Set chain mode in sync reset
    GRAPH_ADDRESS_PORT,
    0x0506,
    
    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

//  CRTC index 2ah-30h, 3eh
    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    7,                              // count
    0x2a,                              // start index
    0xf0,0x05,0x00,0x00,0x00,0x42,0x00,

    OW,                             //
    CRTC_ADDRESS_PORT_COLOR,
    0x003e,                         

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,0x54,0x80,0x0B,0x3E,0x00,0x40,0x0,0x0,0x0,0x0,0x0,0x0,
    0xEA,0x8C,0xDF,0x28,0x0,0xE7,0x4,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    7,                              // count       
    9,                              // start index 
    0x00,0x00,0xc6,0x02,0x00,0x00,0x05,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    EOD
};

/********************************************************************
*     Western Digital 800x600 modes - vRefresh 60Hz.       *
*                                                                   *
*********************************************************************/

//
// Color graphics mode 0x58, 800x600 16 colors 60Hz.
//
USHORT WDVGA_800x600_60hz[] = {
//  SEQ index 7h-9h, 10h-14h
    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    8,
    0xf807,0x0008,0x0009,0xc510,0x6511,0x0412,0x8013,0x1014,

    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    5,
    0x0300,0x0101,0x0f02,0x0003,0x0604,    

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
    0x23,

    OW,                             // Set chain mode in sync reset
    GRAPH_ADDRESS_PORT,
    0x0506,
    
    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

//  CRTC index 2ah-30h, 3eh
    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    7,                              // count
    0x2a,                           // start index
    0xf0,0x45,0x00,0x00,0x00,0x00,0x00,

    OW,                             // CRTC index 3e
    CRTC_ADDRESS_PORT_COLOR,
    0x003e,                         

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x7f,0x63,0x64,0x82,0x6b,0x1b,0x72,0xf0,0x00,0x60,0x0,0x0,0x0,0x0,0x0,0x0,
    0x58,0x8c,0x57,0x32,0x0,0x58,0x71,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
    0x01,0x0,0x0F,0x0,0x0,

//  GRAPH index 9-fh
    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    7,                              // count       
    9,                              // start index 
    0x00,0x00,0xc6,0x00,0x00,0x00,0x05,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0F,0x0FF,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    EOD
};

/********************************************************************
*     Western Digital 800x600 modes - vRefresh6 72Hz.      *
*                                                                   *
*********************************************************************/

//
// Color graphics mode 0x58, 800x600 16 colors 72Hz.
//
USHORT WDVGA_800x600_72hz[] = {
//  SEQ index 7h-9h, 10h-14h
    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    8,
    0xf807,0x0008,0x0009,0xc510,0x6511,0x0412,0x8013,0x1014,

    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    5,
    0x0300,0x0101,0x0f02,0x0003,0x0604,    

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
    0x27,

    OW,                             // Set chain mode in sync reset
    GRAPH_ADDRESS_PORT,
    0x0506,
    
    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

//  CRTC index 2ah-30h, 3eh
    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    7,                              // count
    0x2a,                           // start index
    0xf0,0x85,0x00,0x00,0x00,0x00,0x00,

    OW,                             // CRTC index 3e
    CRTC_ADDRESS_PORT_COLOR,
    0x003e,                         

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x7e,0x63,0x64,0x81,0x6b,0x1a,0x96,0xf0,0x00,0x60,0x0,0x0,0x0,0x0,0x0,0x0,
    0x6d,0xf3,0x57,0x32,0x0,0x5a,0x94,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
    0x01,0x0,0x0F,0x0,0x0,

//  GRAPH index 9-fh
    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    7,                              // count       
    9,                              // start index 
    0x00,0x00,0xc6,0x00,0x00,0x00,0x05,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0F,0x0FF,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    EOD
};

/********************************************************************
*     Western Digital 800x600 modes - vRefresh 56Hz.       *
*                                                                   *
*********************************************************************/

//
// Color graphics mode 0x58, 800x600 16 colors 56Hz.
//
USHORT WDVGA_800x600_56hz[] = {
//  SEQ index 7h-9h, 10h-14h
    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    8,
    0xf807,0x0008,0x0009,0xc510,0x6511,0x0412,0x8013,0x1014,

    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    5,
    0x0300,0x0101,0x0f02,0x0003,0x0604,    

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
    0xef,

    OW,                             // Set chain mode in sync reset
    GRAPH_ADDRESS_PORT,
    0x0506,
    
    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

//  CRTC index 2ah-30h, 3eh
    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    7,                              // count
    0x2a,                           // start index
    0xf0,0x05,0x00,0x00,0x00,0x00,0x00,

    OW,                             // CRTC index 3e
    CRTC_ADDRESS_PORT_COLOR,
    0x003e,                         

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x7b,0x63,0x64,0x9e,0x69,0x92,0x6f,0xf0,0x00,0x60,0x0,0x0,0x0,0x0,0x0,0x0,
    0x58,0x8a,0x57,0x32,0x0,0x58,0x6f,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
    0x01,0x0,0x0F,0x0,0x0,

//  GRAPH index 9-fh
    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    7,                              // count       
    9,                              // start index 
    0x00,0x00,0xc6,0x02,0x00,0x00,0x05,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0F,0x0FF,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    EOD
};


/**************************************************************************
*    Western Digital 1024x768 modes - vRefresh 60Hz.     *
*                                                                         *
**************************************************************************/

//
// Color graphics mode 0x5d, 1024x768 16 colors. 60Hz non-interlace
//
USHORT WDVGA_1024x768_60hz[] = {
//  SEQ index 7h-9h, 10h-14h
    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    8,
    0xf807,0x0008,0x0009,0xc510,0x6511,0x0412,0x8013,0x1014,

    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    5,
    0x0300,0x0101,0x0f02,0x0003,0x0604,    

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
    0xeb,

    OW,                             // Set chain mode in sync reset
    GRAPH_ADDRESS_PORT,
    0x0506,
    
    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

//  CRTC index 2ah-30h, 3eh
    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    7,                              // count
    0x2a,                           // start index
    0xf0,0x95,0x00,0x00,0x01,0x00,0x00,

    OW,                             //
    CRTC_ADDRESS_PORT_COLOR,
    0x003e,                         

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0xa3,0x7f,0x80,0x06,0x87,0x98,0x24,0xf1,0x00,0x60,0x0,0x0,0x0,0x0,0x0,0x0,
    0xff,0x85,0xff,0x40,0x0,0xff,0x23,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    7,                              // count       
    9,                              // start index 
    0x00,0x00,0xc6,0x02,0x00,0x00,0x05,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0F,0x0FF,


    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    //start of enable 64k read/write bank mode.
    OW,                            // enable 64k single read/write bank
    SEQ_ADDRESS_PORT,              // set 3c4.11 bit #7
    0xe511,

    OW,                            // enable PR0B register
    GRAPH_ADDRESS_PORT,            // set 3ce.0b bit #3
    0xce0b,
    //end of enable 64k read/write bank mode.

    EOD
};


/**************************************************************************
*    Western Digital 1024x768 modes - vRefresh 70Hz.     *
*                                                                         *
**************************************************************************/

//
// Color graphics mode 0x5d, 1024x768 16 colors. 70Hz non-interlace
//
USHORT WDVGA_1024x768_70hz[] = {
//  SEQ index 7h-9h, 10h-14h
    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    8,
    0xf807,0x0008,0x0009,0xc510,0x6511,0x0012,0x8013,0x1014,

    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    5,
    0x0300,0x0101,0x0f02,0x0003,0x0604,    

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
    0xeb,

    OW,                             // Set chain mode in sync reset
    GRAPH_ADDRESS_PORT,
    0x0506,
    
    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

//  CRTC index 2ah-30h, 3eh
    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    7,                              // count
    0x2a,                           // start index
    0xf0,0xa5,0x00,0x00,0x01,0x00,0x00,

    OW,                             //
    CRTC_ADDRESS_PORT_COLOR,
    0x003e,                         

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0xa1,0x7f,0x80,0x04,0x86,0x97,0x24,0xf1,0x00,0x60,0x0,0x0,0x0,0x0,0x0,0x0,
    0xff,0x85,0xff,0x40,0x0,0xff,0x23,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    7,                              // count       
    9,                              // start index 
    0x00,0x00,0xc6,0x02,0x00,0x00,0x05,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0F,0x0FF,


    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    //start of enable 64k read/write bank mode.
    OW,                            // enable 64k single read/write bank
    SEQ_ADDRESS_PORT,              // set 3c4.11 bit #7
    0xe511,

    OW,                            // enable PR0B register
    GRAPH_ADDRESS_PORT,            // set 3ce.0b bit #3
    0xce0b,
    //end of enable 64k read/write bank mode.

    EOD
};


/**************************************************************************
*    Western Digital 1024x768 modes - vRefresh 72Hz.     *
*                                                                         *
**************************************************************************/

//
// Color graphics mode 0x5d, 1024x768 16 colors. 72Hz non-interlace
//
USHORT WDVGA_1024x768_72hz[] = {
//  SEQ index 7h-9h, 10h-14h
    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    8,
    0xf807,0x0008,0x0009,0xc510,0x6511,0x0012,0x8013,0x1014,

    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    5,
    0x0300,0x0101,0x0f02,0x0003,0x0604,    

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
    0xef,

    OW,                             // Set chain mode in sync reset
    GRAPH_ADDRESS_PORT,
    0x0506,
    
    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

//  CRTC index 2ah-30h, 3eh
    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    7,                              // count
    0x2a,                           // start index
    0xf0,0xb5,0x00,0x00,0x01,0x00,0x00,

    OW,                             //
    CRTC_ADDRESS_PORT_COLOR,
    0x003e,                         

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0xa3,0x7f,0x80,0x06,0x81,0x92,0x37,0xfd,0x00,0x60,0x0,0x0,0x0,0x0,0x0,0x0,
    0x01,0x87,0xff,0x40,0x0,0x00,0x37,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    7,                              // count       
    9,                              // start index 
    0x00,0x00,0xc6,0x00,0x00,0x00,0x05,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0F,0x0FF,


    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    //start of enable 64k read/write bank mode.
    OW,                            // enable 64k single read/write bank
    SEQ_ADDRESS_PORT,              // set 3c4.11 bit #7
    0xe511,

    OW,                            // enable PR0B register
    GRAPH_ADDRESS_PORT,            // set 3ce.0b bit #3
    0xce0b,
    //end of enable 64k read/write bank mode.

    EOD
};


/**************************************************************************
*    Western Digital 1024x768 modes - vRefresh Interlace.        *
*                                                                         *
**************************************************************************/

//
// Color graphics mode 0x5d, 1024x768 16 colors. Default - Interlace
//
USHORT WDVGA_1024x768_int[] = {
//  SEQ index 7h-9h, 10h-14h
    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    8,
    0xf807,0x0008,0x0009,0xc510,0x6511,0x0412,0x8013,0x1014,

    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    5,
    0x0300,0x0101,0x0f02,0x0003,0x0604,    

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
    0x2f,

    OW,                             // Set chain mode in sync reset
    GRAPH_ADDRESS_PORT,
    0x0506,
    
    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

//  CRTC index 2ah-30h, 3eh
    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    7,                              // count
    0x2a,                              // start index
    0xf0,0x05,0x34,0x2a,0x0b,0x00,0x00,

    OW,                             //
    CRTC_ADDRESS_PORT_COLOR,
    0x003e,                         

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x99,0x7f,0x7f,0x1c,0x83,0x19,0x97,0x1f,0x00,0x40,0x0,0x0,0x0,0x0,0x0,0x0,
    0x7f,0x83,0x7F,0x40,0x0,0x7f,0x96,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    7,                              // count       
    9,                              // start index 
    0x00,0x00,0xc6,0x00,0x00,0x00,0x05,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0F,0x0FF,


    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    //start of enable 64k read/write bank mode.
    OW,                            // enable 64k single read/write bank
    SEQ_ADDRESS_PORT,              // set 3c4.11 bit #7
    0xe511,

    OW,                            // enable PR0B register
    GRAPH_ADDRESS_PORT,            // set 3ce.0b bit #3
    0xce0b,
    //end of enable 64k read/write bank mode.

    EOD
};
#else//!INT10_MODE_SET

USHORT WDVGA_1K_WIDE[] = {
    OW,                             // stretch scans to 1k
    CRTC_ADDRESS_PORT_COLOR,
    0x8013,

    EOD
};

USHORT WDVGA_RW_BANK[] = {
    OW,                             //unlock SEQ ext. regs for 90c11
    SEQ_ADDRESS_PORT,
    0x4806,

    OB,
    SEQ_ADDRESS_PORT,              // set 3c4.11 bit #7
    0x11,
    METAOUT+MASKOUT,
    SEQ_DATA_PORT,
    0x7f,
    0x80,

    OB,                            // enable PR0B register
    GRAPH_ADDRESS_PORT,            // set 3ce.0b bit #3
    0x0b,
    METAOUT+MASKOUT,
    GRAPH_DATA_PORT,
    0xf7,
    0x08,

    EOD
};

USHORT WDVGA_RW_BANK_1K_WIDE[] = {
    OW,                             // stretch scans to 1k
    CRTC_ADDRESS_PORT_COLOR,
    0x8013,

    OW,                             //unlock SEQ ext. regs for 90c11
    SEQ_ADDRESS_PORT,
    0x4806,

    OB,
    SEQ_ADDRESS_PORT,              // set 3c4.11 bit #7
    0x11,
    METAOUT+MASKOUT,
    SEQ_DATA_PORT,
    0x7f,
    0x80,

    OB,                            // enable PR0B register
    GRAPH_ADDRESS_PORT,            // set 3ce.0b bit #3
    0x0b,
    METAOUT+MASKOUT,
    GRAPH_DATA_PORT,
    0xf7,
    0x08,

    EOD
};

USHORT WDVGA_1928_STRETCH[] = {
    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0xf113,                         // stretch to 1928 bytes

    OW,                             //unlock SEQ ext. regs for 90c11
    SEQ_ADDRESS_PORT,
    0x4806,

    OB,
    SEQ_ADDRESS_PORT,              // set 3c4.11 bit #7
    0x11,
    METAOUT+MASKOUT,
    SEQ_DATA_PORT,
    0x7f,
    0x80,

    OB,                            // enable PR0B register
    GRAPH_ADDRESS_PORT,            // set 3ce.0b bit #3
    0x0b,
    METAOUT+MASKOUT,
    GRAPH_DATA_PORT,
    0xf7,
    0x08,

    EOD
};

#endif
//
// Memory map table -
//
// These memory maps are used to save and restore the physical video buffer.
//

MEMORYMAPS MemoryMaps[] = {

//               length      start
//               ------      -----
    {           0x08000,    0xB0000},   // all mono text modes (7)
    {           0x08000,    0xB8000},   // all color text modes (0, 1, 2, 3,
    {           0x20000,    0xA0000},   // all VGA graphics modes
};

//
// Video mode table - contains information and commands for initializing each
// mode. These entries must correspond with those in VIDEO_MODE_VGA. The first
// entry is commented; the rest follow the same format, but are not so
// heavily commented.
//

VIDEOMODE ModesVGA[] = {

//
// Standard VGA modes.
//

//
// Mode index 0
// Color text mode 3, 720x400, 9x16 char cell (VGA).
//

{
  VIDEO_MODE_COLOR,  // flags that this mode is a color mode, but not graphics
  4,                 // four planes
  1,                 // one bit of color per plane
  80, 25,            // 80x25 text resolution
  720, 400,          // 720x400 pixels on screen
  160, 0x10000,      // 160 bytes per scan line, 64K of CPU-addressable bitmap
  60, 0,             // set frequency, non-interlaced mode.
  NoBanking,         // no banking supported or needed in this mode
  MemMap_CGA,        // the memory mapping is the standard CGA memory mapping
                     //  of 32K at B8000
  MONITOR | IBM_F8515 | IBM_F8532 | TOSHIBA_DSTNC | STN_MONO_LCD | UNKNOWN_LCD,
  FALSE,             // Is mode valid or not
#ifdef INT10_MODE_SET
  0xFF, 0x00,                // mask to AND in for frequency
                             //    Value used to set the frequency
  0x3,                       // int10 mode number
  NULL,
  NULL,
#else
  WDVGA_TEXT_0,              // pointer to the command strings 
#endif
},

//
// Mode index 1.
// Color text mode 3, 640x350, 8x14 char cell (EGA).
//

{
  VIDEO_MODE_COLOR, 4, 1, 80, 25,
  640, 350, 160, 0x10000, 60, 0, NoBanking, MemMap_CGA,
  MONITOR | IBM_F8515 | IBM_F8532 | TOSHIBA_DSTNC | STN_MONO_LCD | UNKNOWN_LCD,
  FALSE,
#ifdef INT10_MODE_SET
  0xFF, 0x00,
  0x3,
  NULL,
  NULL,
#else
  WDVGA_TEXT_1,              // pointer to the command strings 
#endif
},

//
//
// Mode index 2
// Standard VGA Color graphics mode 0x12, 640x480 16 colors.
//

{
  VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 80, 30,
  640, 480, 80, 0x10000, 60, 0, NoBanking, MemMap_VGA,
  MONITOR | IBM_F8515 | IBM_F8532 | TOSHIBA_DSTNC | STN_MONO_LCD | UNKNOWN_LCD,
  FALSE,
#ifdef INT10_MODE_SET
  0xFF, 0x00,
  0x12,
  NULL,
  NULL,
#else
  WDVGA_640x480,              // pointer to the command strings
#endif
},

#ifdef INT10_MODE_SET

//
// ModeX modes!
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 8, 1, 80,30,
  320, 200, 80, 0x10000, 70, 0, NoBanking, MemMap_VGA,
  MONITOR | IBM_F8515 | IBM_F8532 | TOSHIBA_DSTNC | STN_MONO_LCD | UNKNOWN_LCD,
  FALSE,
  0xFF, 0x00,
  0x13,
  NULL,
  MODESET_MODEX_320_200
},

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 8, 1, 80,30,
  320, 240, 80, 0x10000, 60, 0, NoBanking, MemMap_VGA,
  MONITOR | IBM_F8515 | IBM_F8532 | TOSHIBA_DSTNC | STN_MONO_LCD | UNKNOWN_LCD,
  FALSE,
  0xFF, 0x00,
  0x13,
  NULL,
  MODESET_MODEX_320_240
},

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 8, 1, 80,30,
  320, 400, 80, 0x10000, 70, 0, NoBanking, MemMap_VGA,
  MONITOR | IBM_F8515 | IBM_F8532 | TOSHIBA_DSTNC | STN_MONO_LCD | UNKNOWN_LCD,
  FALSE,
  0xFF, 0x00,
  0x13,
  NULL,
  MODESET_MODEX_320_400
},

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 8, 1, 80,30,
  320, 480, 80, 0x10000, 60, 0, NoBanking, MemMap_VGA,
  MONITOR | IBM_F8515 | IBM_F8532 | TOSHIBA_DSTNC | STN_MONO_LCD | UNKNOWN_LCD,
  FALSE,
  0xFF, 0x00,
  0x13,
  NULL,
  MODESET_MODEX_320_480
},

#endif

//
// Beginning of SVGA modes
//

//
// Mode index 3
// 800x600 16 colors. 60hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000, 60, 0, NoBanking, MemMap_VGA,
  MONITOR | IBM_F8532,
  FALSE,
#ifdef INT10_MODE_SET
  0x3F, 0x40,
  0x58,
  NULL,
  NULL,
#else
  WDVGA_800x600_60hz,           // pointer to the command strings
#endif
},

//
// Mode index 4
// 800x600 16 colors. 72hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000, 72, 0, NoBanking, MemMap_VGA,
  MONITOR,
  FALSE,
#ifdef INT10_MODE_SET
  0x3F, 0x80,
  0x58,
  NULL,
  NULL,
#else
  WDVGA_800x600_72hz,           // pointer to the command strings
#endif
},

//
// Mode index 5
// 800x600 16 colors. 56hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000, 56, 0, NoBanking, MemMap_VGA,
  MONITOR,
  FALSE,
#ifdef INT10_MODE_SET
  0x3F, 0x00,
  0x58,
  NULL,
  NULL,
#else
  WDVGA_800x600_56hz,           // pointer to the command strings
#endif
},

//
// Mode index 6
// 1024x768 non-interlaced 16 colors. 60hz
// Assumes 512K.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000, 60, 0, NormalBanking, MemMap_VGA,
  MONITOR,
  FALSE,
#ifdef INT10_MODE_SET
  0xCF, 0x10,
  0x5d,
  NULL,
  WDVGA_RW_BANK,
#else
  WDVGA_1024x768_60hz,            // pointer to the command strings
#endif
},

//
// Mode index 7
// 1024x768 non-interlaced 16 colors. 70hz
// Assumes 512K.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000, 70, 0, NormalBanking, MemMap_VGA,
  MONITOR,
  FALSE,
#ifdef INT10_MODE_SET
  0xCF, 0x20,
  0x5d,
  NULL,
  WDVGA_RW_BANK,
#else
  WDVGA_1024x768_70hz,            // pointer to the command strings
#endif
},

//
// Mode index 8
// 1024x768 non-interlaced 16 colors. 72hz
// Assumes 512K.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000, 72, 0, NormalBanking, MemMap_VGA,
  MONITOR,
  FALSE,
#ifdef INT10_MODE_SET
  0xCF, 0x30,
  0x5d,
  NULL,
  WDVGA_RW_BANK,
#else
  WDVGA_1024x768_72hz,            // pointer to the command strings
#endif
},

//
// Mode index 9
// 1024x768 interlaced 16 colors. 44hz
// Assumes 512K.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000, 44, 1, NormalBanking, MemMap_VGA,
  MONITOR,
  FALSE,
#ifdef INT10_MODE_SET
  0xCF, 0x00,
  0x5d,
  NULL,
  WDVGA_RW_BANK,
#else
  WDVGA_1024x768_int,             // pointer to the command strings
#endif
},

#ifdef INT10_MODE_SET
// NOTE: 800x600 modes need 1Meg until we support broken rasters

//
// Mode index 11
// 800x600x256  56Hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 56, 0, NormalBanking, MemMap_VGA,
  MONITOR,
  FALSE,
  0x3F, 0x00,
  0x5c,
  NULL,
  WDVGA_RW_BANK_1K_WIDE,
},

//
// Mode index 12
// 800x600x256  60Hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 60, 0, NormalBanking, MemMap_VGA,
  MONITOR | IBM_F8532,
  FALSE,
  0x3F, 0x40,
  0x5c,
  WDVGA_800x600x256_60hz,
  WDVGA_RW_BANK_1K_WIDE,
},

//
// Mode index 13
// 800x600x256  72Hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 72, 0, NormalBanking, MemMap_VGA,
  MONITOR | IBM_F8532,
  FALSE,
  0x3F, 0x80,
  0x5c,
  WDVGA_800x600x256_72hz,
  WDVGA_RW_BANK_1K_WIDE,
},

//
// Mode index 14
// 1024x768x256  60Hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 60, 0, NormalBanking, MemMap_VGA,
  MONITOR,
  FALSE,
  0xCF, 0x10,
  0x60,
  WDVGA_1024x768x256_60hz,
  WDVGA_RW_BANK,
},

//
// Mode index 15
// 1024x768x256  70hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 70, 0, NormalBanking, MemMap_VGA,
  MONITOR,
  FALSE,
  0xCF, 0x20,
  0x60,
  NULL,
  WDVGA_RW_BANK,
},

//
//
// Mode index 16
// 1024x768x256  72hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 72, 0, NormalBanking, MemMap_VGA,
  MONITOR,
  FALSE,
  0xCF, 0x30,
  0x60,
  NULL,
  WDVGA_RW_BANK,
},

// Mode index 17
// 1024x768x256  44Hz (Interlaced)
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 44, 1, NormalBanking, MemMap_VGA,
  MONITOR,
  FALSE,
  0xCF, 0x00,
  0x60,
  WDVGA_1024x768x256_int,
  WDVGA_RW_BANK,
},

//
// Mode index 18
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1928, 0x100000, 60, 0, NormalBanking, MemMap_VGA,
  MONITOR | IBM_F8515 | IBM_F8532 | TOSHIBA_DSTNC,
  FALSE,
  0xFF, 0x00,
  0x01110072,
  NULL,
  WDVGA_1928_STRETCH,
},

#endif//INT10_MODE_SET

#ifdef INT10_MODE_SET
//
// Mode index 10
// 640x480x256
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 60, 0, NormalBanking, MemMap_VGA,
  IBM_F8515 | IBM_F8532 | UNKNOWN_LCD,
  FALSE,
  0xFF, 0x00,
  0x5f,
  WDVGA_640x480x256_60hz,
  WDVGA_RW_BANK_1K_WIDE,
},

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 72, 0, NormalBanking, MemMap_VGA,
  IBM_F8515 | IBM_F8532,
  FALSE,
  0xFF, 0x00,
  0x5f,
  WDVGA_640x480x256_72hz,
  WDVGA_RW_BANK_1K_WIDE,
},

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 75, 0, NormalBanking, MemMap_VGA,
  IBM_F8515 | IBM_F8532,
  FALSE,
  0xFF, 0x00,
  0x5f,
  WDVGA_640x480x256_75hz,
  WDVGA_RW_BANK_1K_WIDE,
},

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 60, 0, NormalBanking, MemMap_VGA,
  TOSHIBA_DSTNC,
  FALSE,
  0xFF, 0x00,
  0x5f,
  WDVGA_640x480_60STN,
  WDVGA_RW_BANK_1K_WIDE,
},

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 60, 0, NormalBanking, MemMap_VGA,
  MONITOR,
  FALSE,
  0xFF, 0x00,
  0x5f,
  NULL,
  WDVGA_RW_BANK_1K_WIDE,
},

#endif


};


ULONG NumVideoModes = sizeof(ModesVGA) / sizeof(VIDEOMODE);

//
//
// Data used to set the Graphics and Sequence Controllers to put the
// VGA into a planar state at A0000 for 64K, with plane 2 enabled for
// reads and writes, so that a font can be loaded, and to disable that mode.
//

// Settings to enable planar mode with plane 2 enabled.
//

USHORT EnableA000Data[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0204,     // Read Map = plane 2
    0x0005, // Graphics Mode = read mode 0, write mode 0
    0x0406, // Graphics Miscellaneous register = A0000 for 64K, not odd/even,
            //  graphics mode
    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0402, // Map Mask = write to plane 2 only
    0x0404, // Memory Mode = not odd/even, not full memory, graphics mode
    0x0300,  // end sync reset
    EOD
};

//
// Settings to disable the font-loading planar mode.
//

USHORT DisableA000Color[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0004, 0x1005, 0x0E06,

    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0302, 0x0204, 0x0300,  // end sync reset
    EOD

};


#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\wd\mini\i386\lcd.asm ===
;
; This files implements a set of routines used to manage the LCD
; display on IBM Thinkpads.
;

        .386p

_DATA   SEGMENT DWORD   PUBLIC  'DATA'

OLD             equ     0
NEW             equ     1

IOPort          dw      15EEh
ThinkpadVersion dd      ?

msg1            db      "Unknown Thinkpad Version.", 0dh, 0ah, 0

_DATA   ENDS

_TEXT   SEGMENT DWORD   PUBLIC  'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        public  _LCDInit@0
        public  _LCDDisplay@4
        public  _LCDIsMonitorPresent@0

;IF DBG
;        extrn   _VideoPortDebugPrint:proc
;ENDIF

        align   4

;
; There are two versions of the Thinkpad System Management API.
; One is used on old thinkpads such as the 755C, the other is
; used on new thinkpads such as the 755CE and 755CD.  I'll refer
; to the two as OLD and NEW.
;
; Instead of having a routine which determines whether the display
; type is old or new, I'll figure it out once in an init routine, and
; then have all other LCDxxx routines use it.
;

_LCDInit@0    proc

        pushad                      ; preserve registers

        mov ax, 05380h
        mov bx, 0F04Dh
        mov cx, 04942h
        mov dx, IOPort
        out dx, ax                  ; invoke the SMAPI

        ;
        ; Now check to see if this is a new, or old thinkpad
        ;
        ; It is a new thinkpad if
        ;
        ;   AH == 0x86
        ;
        ; it is old if
        ;
        ;   AX == 0x5380 && BH == 0x00
        ;

        cmp ah, 086h
        jnz L100

        mov ThinkpadVersion, NEW
        jmp L120

L100:
        cmp ax, 05380h
        jnz L110
        cmp bh, 00h
        jnz L110

        mov ThinkpadVersion, OLD
        jmp L120

L110:

        mov ThinkpadVersion, OLD    ; we don't know the version, so assume
                                    ; its the old.

        ; add a debug print here to notify of situation, or
        ; add a DbgBreakpoint

;IF DBG
;        push offset msg1
;        push 0
;        call _VideoPortDebugPrint
;        add esp, 8                  ; remove parameters from stack
;ENDIF

L120:

        popad                       ; restore registers

        ret

_LCDInit@0    endp

;
; The following routine is used to determine whether or not an
; external monitor is present.  It will return a TRUE if an
; external monitor is conected, and a false otherwise.
;

_LCDIsMonitorPresent@0    proc

        pushad                      ; preserve registers

        mov dx, IOPort
        mov ax, 05380h

        cmp ThinkpadVersion, OLD
        jnz L200

        ;
        ; this is an old thinkpad
        ;

        mov bx, 08000h
        out dx, ax
        mov ch, bh
        jmp L210

L200:

        ;
        ; this is a new thinkpad
        ;

        mov bx, 00002h
        out dx, ax

L210:

        ;
        ; the result is now in ch
        ;

        and ch, 030h
        jz L220

        popad                       ; restore registers
        mov eax, 01h
        jmp L230

L220:
        popad                       ; restore registers
        sub eax, eax

L230:

        ret

_LCDIsMonitorPresent@0    endp

;
; The following routine will turn on, or turn off the LCD display.
; This routine takes one parameter as an argument (a DWORD).
; a zero in this DWORD means turn off the LCD, anything else
; means turn it on.
;

_LCDDisplay@4             proc

        pushad

        mov ebp, esp                ; ebp was saved by pusha

        mov ax, 05380h
        mov dx, IOPort

        cmp ThinkpadVersion, OLD
        jnz L300

        ;
        ; Old thinkpad
        ;

        mov bx, 08701h
        mov cx, 00100h              ; assume we'll be turning lcd off
        jmp L310

L300:

        ;
        ; New thinkpad
        ;

        mov bx, 01001h
        mov cx, 00200h              ; assume we'll be turning lcd off

L310:

        cmp [ebp+36], 0             ; check parameter to see if we turn
                                    ; display on or off

        jz L320

        ;
        ; We want to turn the display on
        ;

        mov cx, 08300h

L320:

        ;
        ; change the display state
        ;

        out dx, ax

        popad
        ret 4

_LCDDisplay@4             endp


_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\wd\mini\pvgaequ.h ===
/*++

Copyright (c) 1994-1995  IBM Corporation

Module Name:

    pvgaequ.h

Abstract:

    This module contains the constants/macros for WD90C24A/A2 registers

Environment:

    kernel mode only

Notes:


Revision History:

--*/

/*                                                                           */
/* Regular Paradise Registers    (0x3CE/0x3CF)                               */
/*                                                                           */
#define  pr0a        0x09        // Address Offset A
#define  pr0b        0x0a        // Address Offset B
#define  pr1         0x0b        // Memory Size
#define  pr2         0x0c        // Video Select
#define  pr3         0x0d        // CRT Lock Control
#define  pr4         0x0e        // Video Control
#define  pr5         0x0f        // Unlock PR0-PR4
#define  pr5_lock    0x00        //   protect PR0-PR4
#define  pr5_unlock  0x05        //   unprotect PR0-PR4
/*                                                                           */
/* Regular Paradise Registers    (0x3?4/0x3?5)                               */
/*                                                                           */
#define  pr10        0x29        // Unlock PR11-PR17 & Device ID registers
#define  pr10_lock   0x00        //   protect PR11-PR17
#define  pr10_unlock 0x85        //   unprotect PR11-PR17
#define  pr11        0x2a        // EGA Switches
#define  pr11_lock   0x95        //   protect Misc. Output & Clocking Mode
#define  pr11_unlock 0x90        //   unprotect Misc. Output & Clocking Mode
#define  pr12        0x2b        // Scratch Pad
#define  pr13        0x2c        // Interlace H/2 Start
#define  pr14        0x2d        // Interlace H/2 End
#define  pr15        0x2e        // Miscellaneous Control 1
#define  pr16        0x2f        // Miscellaneous Control 2
#define  pr17        0x30        // Miscellaneous Control 3
#define  pr18a       0x3d        // CRTC Vertical Timing Overflow
/*                                                                           */
/* Paradise Extended Registers   (0x3C4/0x3C5)                               */
/*                                                                           */
#define  pr20        0x06        // Unlock Paradise Extended Registers
#define  pr20_lock   0x00        //   protect PR21-PR73
#define  pr20_unlock 0x48        //   unprotect PR21-PR73
#define  pr21        0x07        // Display Configuraiton Status
#define  pr22        0x08        // Scratch Pad
#define  pr23        0x09        // Scratch Pad
#define  pr30a       0x10        // Write Buffer & FIFO Control
#define  pr31        0x11        // System Interface Control
#define  pr32        0x12        // Miscellaneous Control 4
#define  pr33a       0x13        // DRAM Timing & 0 Wait State Control
#define  pr34a       0x14        // Display Memory Mapping
#define  pr35a       0x15        // FPUSR0, FPUSR1 Output Select
#define  pr45        0x16        // Video Signal Analyzer Control
#define  pr45a       0x17        // Signal Analyzer Data I
#define  pr45b       0x18        // Signal Analyzer Data II
#define  pr57        0x19        // Feature Register I
#define  pr58        0x20        // Feature Register II
#define  pr59        0x21        // Memory Arbitration Cycle Setup
#define  pr62        0x24        // FR Timing
#define  pr63        0x25        // Read/Write FIFO Control
#define  pr58a       0x26        // Memory Map to I/O Register for BitBlt
#define  pr64        0x27        // CRT Lock Control II
#define  pr65        0x28        // reserved
#define  pr66        0x29        // Feature Register III
#define  pr68        0x31        // Programmable Clock Selection
#define  pr69        0x32        // Programmable VCLK Frequency
#define  pr70        0x33        // Mixed Voltage Override
#define  pr71        0x34        // Programmable Refresh Timing
#define  pr72        0x35        // Unlock PR68
#define  pr72_lock   0x00        //   protect PR68
#define  pr72_unlock 0x50        //   unprotect PR68
#define  pr73        0x36        // VGA Status Detect
/*                                                                           */
/* Flat Panel Paradise Registers (0x3?4/0x3?5)                               */
/*                                                                           */
#define  pr18        0x31        // Flat Panel Status
#define  pr19        0x32        // Flat Panel Control I
#define  pr1a        0x33        // Flat Panel Control II
#define  pr1b        0x34        // Unlock Flat Panel Registers
#define  pr1b_lock          0x00 //   protect PR18-PR44 & shadow registers
#define  pr1b_unlock_shadow 0x06 //   unprotect shadow CRTC registers
#define  pr1b_unlock_pr     0xa0 //   unprotect PR18-PR44
#define  pr1b_unlock        (pr1b_unlock_shadow | pr1b_unlock_pr)
#define  pr36        0x3b        // Flat Panel Height Select
#define  pr37        0x3c        // Flat Panel Blinking Control
#define  pr39        0x3e        // Color LCD Control
#define  pr41        0x37        // Vertical Expansion Initial Value
#define  pr44        0x3f        // Powerdown & Memory Refresh Control
/*                                                                           */
/* Mapping RAM Registers         (0x3?4/0x3?5)                               */
/*                                                                           */
#define  pr30        0x35        // Unlock Mapping RAM
#define  pr30_lock   0x00        //   protect PR33-PR35
#define  pr30_unlock 0x30        //   unprotect PR33-PR35
#define  pr33        0x38        // Mapping RAM Address Counter
#define  pr34        0x39        // Mapping RAM Data
#define  pr35        0x3a        // Mapping RAM & Powerdown Control

/*                                                                           */
/* Register Initialization Parameters                                        */
/*                                                                           */
#define  pr0a_all             0x00
#define  pr0b_all             0x00
#define  pr1_all              0xc5

#define  pr2_crt              0x00
#define  pr2_tft              0x01
#define  pr2_s32              0x01
#define  pr2_stn              0x01
#define  pr2_s16              0x01
#define  pr2_stnc             0x01

#define  pr3_all              0x02 // <- 0x00
#define  pr3_tft800s          0x02
#define  pr3_tft800e          0x21
#define  pr4_all              0x61 // <- 0x40

#define  pr12_all             0x00
#define  pr12_244LP           0xe8

#define  pr13_all             0x00
#define  pr14_all             0x00
#define  pr15_all             0x00
#define  pr15_tft800          0x40
#define  pr16_all             0x42

#define  pr17_all             0x00
#define  pr17_244LP           0x40

#define  pr18_crt_tft         0x43
#define  pr18_crt_stn         0x00
#define  pr18_tft             0xc7
#define  pr18_s32             0x47
#define  pr18_stn             0x80
#define  pr18_s16             0x00
#define  pr18_stnc            0x00
#define  pr18_tft800          0x47

#define  pr19_disable         0x40
#define  pr19_crt             0x64
#define  pr19_tft             0x44 // <- 0x54
#define  pr19_s32             0x64 // <- 0x74
#define  pr19_stn             0x44 // <- 0x54
#define  pr19_s16             0x64 // <- 0x74
#define  pr19_stnc            0x64 // <- 0x74
#define  pr19_stnc_only       0x44 // <- 0x54
#define  pr19_tft800          0x60 // <- 0x70

#define  pr39_crt             0x24
#define  pr39_tft             0x24
#define  pr39_s32             0x24
#define  pr39_stn             0x00
#define  pr39_s16             0x04
#define  pr39_stnc            0x24
#define  pr39_tft800          0x24

#define  pr1a_all             0x00
#define  pr1a_stnc            0x60
#define  pr1a_tft800          0x90

#define  pr36_all             0xef

#define  pr37_crt             0x9a
#define  pr37_tft             0x9a
#define  pr37_s32             0x9a
#define  pr37_stn             0x9a
#define  pr37_s16             0x1a
#define  pr37_stnc            0x9a

#define  pr18a_all            0x00
#define  pr41_all             0x00
#define  pr44_all             0x00
#define  pr33_all             0x00
#define  pr34_all             0x00

#define  pr35_all             0x22 // <- 0x02
#define  pr35_suspend         0xa2

#define  pr21_all             0x00
#define  pr22_all             0x00
#define  pr23_all             0x00

#define  pr30a_crt            0xc1
#define  pr30a_tft            0xc1
#define  pr30a_s32            0xc1
#define  pr30a_stn            0xc1
#define  pr30a_s16            0xe1
#define  pr30a_stnc           0xe1

#define  pr31_all             0x25 // <- 0x21
#define  pr32_all             0x00

#define  pr33a_all            0x82
#define  pr33a_stnc           0x82

#define  pr34a_all            0x00
#define  pr35a_all            0x00

#define  pr45_all             0x00
#define  pr45a_all            0x00
#define  pr45b_all            0x00

#define  pr57_all             0x31 // <- 0x33

#define  pr58_all             0x00
#define  pr58a_all            0x00

#define  pr59_all_sivA        0x35
#define  pr59_crt             0x15
#define  pr59_tft             0x15
#define  pr59_s32             0x15
#define  pr59_stn             0x35
#define  pr59_s16             0x35
#define  pr59_stnc            0x03
#define  pr59_stnc_a2         0x02
#define  pr59_tft800          0x10

#define  pr62_all             0x3c
#define  pr63_all             0x00

#define  pr64_all             0x03

#define  pr66_crt             0x40
#define  pr66_tft             0x40
#define  pr66_s32             0x40
#define  pr66_stn             0x40
#define  pr66_s16             0x40
#define  pr66_stnc            0x40

#define  pr68_crt             0x0d
#define  pr68_tft             0x0d
#define  pr68_s32             0x0d
#define  pr68_stn             0x1d
#define  pr68_s16             0x0d
#define  pr68_stnc            0x0d
#define  pr68_stnc_only       0x05
#define  pr68_stnc_only_a2    0x05

#define  pr69_all             0x00
#define  pr69_stnc_only       0x4c
#define  pr69_stnc_only_a2    0x45

#define  pr70_all             0x36 // <- 0x32
#define  pr71_all             0x00 // <- 0x27
#define  pr73_all             0x01

/*                                                                           */
/* CRTC shadow registers                                                     */
/*                                                                           */
#define  crtc00_tft           0x5f // TFT color LCD only
#define  crtc02_tft           0x50
#define  crtc03_tft           0x82
#define  crtc04_tft           0x54
#define  crtc05_tft           0x80
#define  crtc06_tft           0x0b
#define  crtc07_tft           0x3e
#define  crtc10_tft           0xea
#define  crtc11_tft           0x2c // <- 0x8c
#define  crtc15_tft           0xe7
#define  crtc16_tft           0x04

#define  crtc00_s32           0x5f // TFT color simultaneous
#define  crtc02_s32           0x50
#define  crtc03_s32           0x82
#define  crtc04_s32           0x54
#define  crtc05_s32           0x80
#define  crtc06_s32           0x0b
#define  crtc07_s32           0x3e
#define  crtc10_s32           0xea
#define  crtc11_s32           0x2c // <- 0x8c
#define  crtc15_s32           0xe7
#define  crtc16_s32           0x04

#define  crtc00_stn           0x5f // STN mono LCD only
#define  crtc02_stn           0x50
#define  crtc03_stn           0x82
#define  crtc04_stn           0x54
#define  crtc05_stn           0x80
#define  crtc06_stn           0xf2
#define  crtc07_stn           0x12
#define  crtc10_stn           0xf0
#define  crtc11_stn           0x22 // <- 0x82
#define  crtc15_stn           0xf0
#define  crtc16_stn           0xf2

#define  crtc00_s16           0x5f // STN mono simultaneous
#define  crtc02_s16           0x50
#define  crtc03_s16           0x82
#define  crtc04_s16           0x54
#define  crtc05_s16           0x80
#define  crtc06_s16           0x12
#define  crtc07_s16           0x3e
#define  crtc10_s16           0xea
#define  crtc11_s16           0x2c // <- 0x8c
#define  crtc15_s16           0xe7
#define  crtc16_s16           0x04

#define  crtc00_stnc          0x60 // STN color simultaneous (WD90C24A.C)
#define  crtc02_stnc          0x50
#define  crtc03_stnc          0x83
#define  crtc04_stnc          0x55
#define  crtc05_stnc          0x81
#define  crtc06_stnc          0x0e
#define  crtc07_stnc          0x3e
#define  crtc10_stnc          0xea
#define  crtc11_stnc          0x2e // <- 0x8e
#define  crtc15_stnc          0xe7
#define  crtc16_stnc          0x04

#define  crtc00_stnc_iso      0x67 // STN color simultaneous (WD90C24A.C & 75Hz)
#define  crtc02_stnc_iso      0x50
#define  crtc03_stnc_iso      0x8a
#define  crtc04_stnc_iso      0x57
#define  crtc05_stnc_iso      0x88

#define  crtc00_stnc_a2       0x5f // STN color simultaneous (WD90C24A2.D)
#define  crtc02_stnc_a2       0x50
#define  crtc03_stnc_a2       0x82
#define  crtc04_stnc_a2       0x54
#define  crtc05_stnc_a2       0x80

#define  crtc00_stnc_iso_a2   0x5f // STN color simultaneous (WD90C24A2.D & 75Hz)
#define  crtc02_stnc_iso_a2   0x50
#define  crtc03_stnc_iso_a2   0x82
#define  crtc04_stnc_iso_a2   0x54
#define  crtc05_stnc_iso_a2   0x80

#define  crtc00_stnc_only     0x67 // STN color LCD only
#define  crtc02_stnc_only     0x50
#define  crtc03_stnc_only     0x82
#define  crtc04_stnc_only     0x55
#define  crtc05_stnc_only     0x81
#define  crtc06_stnc_only     0xe6
#define  crtc07_stnc_only     0x1f
#define  crtc10_stnc_only     0xe0
#define  crtc11_stnc_only     0x22 // <- 0x82
#define  crtc15_stnc_only     0xe0
#define  crtc16_stnc_only     0xe2

#define  crtc00_tft800        0x7f // TFT 800x600 color simultaneous
#define  crtc01_tft800        0x63
#define  crtc02_tft800        0x64
#define  crtc03_tft800        0x82
#define  crtc04_tft800        0x6b // <- 0x69
#define  crtc05_tft800        0x1b // <- 0x79
#define  crtc06_tft800        0x72 // <- 0x71
#define  crtc07_tft800        0xf0
#define  crtc09_tft800        0x6f
#define  crtc10_tft800        0x58
#define  crtc11_tft800        0x2c
#define  crtc12_tft800        0x57
#define  crtc13_tft800        0x32
#define  crtc15_tft800        0x58
#define  crtc16_tft800        0x71

/*                                                                           */
/* Extended Paradise Registers ... BitBlt, H/W Cursor, and Line Drawing      */
/*                                                                           */
#define  EPR_INDEX   0x23C0      // Index Control
#define  EPR_DATA    0x23C2      // Register Access Port
#define  EPR_BITBLT  0x23C4      // BitBlt I/O Port

#define  BLT_CTRL1   0x0000      // Index 0 - BITBLT Control 1
#define  BLT_CTRL2   0x1000      // Index 1 - BITBLT Control 1
#define  BLT_SRC_LO  0x2000      // Index 2 - BITBLT Source Low
#define  BLT_SRC_HI  0x3000      // Index 3 - BITBLT Source High
#define  BLT_DST_LO  0x4000      // Index 4 - BITBLT Destination Low
#define  BLT_DST_HI  0x5000      // Index 5 - BITBLT Destination High
#define  BLT_SIZE_X  0x6000      // Index 6 - BITBLT Dimension X
#define  BLT_SIZE_Y  0x7000      // Index 7 - BITBLT Dimension Y
#define  BLT_DELTA   0x8000      // Index 8 - BITBLT Row Pitch
#define  BLT_ROPS    0x9000      // Index 9 - BITBLT Raster Operation
#define  BLT_F_CLR   0xA000      // Index A - BITBLT Foreground Color
#define  BLT_B_CLR   0xB000      // Index B - BITBLT Background Color
#define  BLT_T_CLR   0xC000      // Index C - BITBLT Transparency Color
#define  BLT_T_MASK  0xD000      // Index D - BITBLT Transparency Mask
#define  BLT_PLANE   0xE000      // Index E - BITBLT Map and Plane Mask

#define  BLT_IN_PROG 0x0800      // BITBLT Activation Status

#define  CUR_CTRL    0x0000      // Index 0 - Cursor Control
#define  CUR_PAT_LO  0x1000      // Index 1 - Cursor Pattern Address Low
#define  CUR_PAT_HI  0x2000      // Index 2 - Cursor Pattern Address High
#define  CUR_PRI_CLR 0x3000      // Index 3 - Cursor Primary Color
#define  CUR_SEC_CLR 0x4000      // Index 4 - Cursor Secondary Color
#define  CUR_ORIGIN  0x5000      // Index 5 - Cursor Origin
#define  CUR_POS_X   0x6000      // Index 6 - Cursor Display Position X
#define  CUR_POS_Y   0x7000      // Index 7 - Cursor Display Position Y
#define  CUR_AUX_CLR 0x8000      // Index 8 - Cursor Auxiliary Color

#define  CUR_ENABLE  0x0800      // Cursor Enable (Index 0)
/*                                                                           */
/* Local Bus Registers                                                       */
/*                                                                           */
#define  LBUS_REG_0  0x2DF0      // Local Bus Register 0
#define  LBUS_REG_1  0x2DF1      // Local Bus Register 1
#define  LBUS_REG_2  0x2DF2      // Local Bus Register 2


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\wd\mini\i386\wdhard.asm ===
title  "Wd Hard.asm"
;++
;
; Copyright (c) 1992  Microsoft Corporation
; Copyright (c) 1993  Western Digital Corporation
;
; Module Name:
;
;     vgahard.asm
;
; Abstract:
;
;     This module implements the baning code for the WD90Cxx.
;
; Environment:
;
;    Kernel mode only.
;
; Author:
;
;    Chung-I Chiang, Harold Huang     	Western Digital Corporation
;
; Revision History:
;
;
;--

.386p
        .xlist
include callconv.inc                    ; calling convention macros
        .list

;---------------------------------------
;
; Western Digital banking control port.
;

SEGMENT_SELECT_PORT equ     03ceh      ;banking control here
SEQ_ADDRESS_PORT equ        03C4h      ;Sequencer Address register
WD_PR0A          equ        09h
WD_PR0B          equ        0Ah
IND_MEMORY_MODE  equ        04h        ;Memory Mode register index in Sequencer
CHAIN4_MASK      equ        08h        ;Chain4 bit in Memory Mode register


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Bank Switching Stub"

;
;    Bank switching code. This is a 1-64K-read/1-64K-write bank adapter
;    (VideoBanked1R1W).
;
;    Input:
;          EAX = desired read bank mapping
;          EDX = desired write bank mapping
;
;    Note: values must be correct, with no stray bits set; no error
;       checking is performed.
;
	public _BankSwitchStart
	public _BankSwitchEnd

        align 4

_BankSwitchStart proc ;start of bank switch code

	push	ebx			
	push	eax
	push	edx
	mov	dx,SEGMENT_SELECT_PORT
	in	al,dx
	mov	ebx,eax		;must save 3CE current index
	pop	edx
	pop	eax

	push	edx
	shl	eax,12			;read bank in PRO0A
	mov	al,WD_PR0A
	mov	dx,SEGMENT_SELECT_PORT
	out	dx,ax
	pop	edx

	mov	eax,edx
	shl	eax,12			;write bank in PRO0B
	mov	al,WD_PR0B
	mov	dx,SEGMENT_SELECT_PORT
	out	dx,ax

	mov	eax,ebx			;restore 3CE index
	mov	dx,SEGMENT_SELECT_PORT
	out	dx,al
	pop	ebx

        ret           ; This should be a fatal error ...

_BankSwitchEnd:

_BankSwitchStart endp

_TEXT   ends
        end




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\wd\mini\wdvga.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation
Copyright (c) 1993  Western Digital Corporation

Module Name:

    wdvga.h

Abstract:

    This module contains the definitions for the code that implements the
    WDVGA device driver.

Environment:

    Kernel mode

Revision History:

--*/

#ifndef NO_INT10_MODE_SET
#define INT10_MODE_SET 1
#endif

//
// Do full save and restore.
//

// #define EXTENDED_REGISTER_SAVE_RESTORE 1

//
// Define type of WD boards
//

typedef ULONG BOARD_TYPE;

#define WD90C00     0x00000001
#define WD90C30     0x00000002
#define SPEEDSTAR30 0x00000004
#define WD90C31     0x00000008
#define SPEEDSTAR31 0x00000010
#define WD90C24A    0x00000020

#define OTHER       0x80000000

#define ALL (WD90C00 | WD90C30 | SPEEDSTAR30 | WD90C31 | SPEEDSTAR31 | WD90C24A)
#define NOT_WD90C24A (ALL & ~WD90C24A)

#define MONITOR        0x01
#define IBM_F8515      0x02
#define IBM_F8532      0x04
#define TOSHIBA_DSTNC  0x08
#define STN_MONO_LCD   0x10
#define UNKNOWN_LCD    0x20


//
// Base address of VGA memory range.  Also used as base address of VGA
// memory when loading a font, which is done with the VGA mapped at A0000.
//

#define MEM_VGA      0xA0000
#define MEM_VGA_SIZE 0x20000

//
// Port definitions for filling the ACCSES_RANGES structure in the miniport
// information, defines the range of I/O ports the VGA spans.
// There is a break in the IO ports - a few ports are used for the parallel
// port. Those cannot be defined in the ACCESS_RANGE, but are still mapped
// so all VGA ports are in one address range.
//

#define VGA_BASE_IO_PORT      0x000003B0
#define VGA_START_BREAK_PORT  0x000003BB
#define VGA_END_BREAK_PORT    0x000003C0
#define VGA_MAX_IO_PORT       0x000003DF

#define WD_EXT_PORT_START     0x000023C0
#define WD_EXT_PORT_END       0x000023C7

//
// VGA port-related definitions.
//

//
// VGA register definitions
//
                                            // ports in monochrome mode
#define CRTC_ADDRESS_PORT_MONO      0x0004  // CRT Controller Address and
#define CRTC_DATA_PORT_MONO         0x0005  // Data registers in mono mode
#define FEAT_CTRL_WRITE_PORT_MONO   0x000A  // Feature Control write port
                                            // in mono mode
#define INPUT_STATUS_1_MONO         0x000A  // Input Status 1 register read
                                            // port in mono mode
#define ATT_INITIALIZE_PORT_MONO    INPUT_STATUS_1_MONO
                                            // Register to read to reset
                                            // Attribute Controller index/data

#define ATT_ADDRESS_PORT            0x0010  // Attribute Controller Address and
#define ATT_DATA_WRITE_PORT         0x0010  // Data registers share one port
                                            // for writes, but only Address is
                                            // readable at 0x3C0
#define ATT_DATA_READ_PORT          0x0011  // Attribute Controller Data reg is
                                            // readable here
#define MISC_OUTPUT_REG_WRITE_PORT  0x0012  // Miscellaneous Output reg write
                                            // port
#define INPUT_STATUS_0_PORT         0x0012  // Input Status 0 register read
                                            // port
#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x0013  // Bit 0 enables/disables the
                                            // entire VGA subsystem
#define SEQ_ADDRESS_PORT            0x0014  // Sequence Controller Address and
#define SEQ_DATA_PORT               0x0015  // Data registers
#define DAC_PIXEL_MASK_PORT         0x0016  // DAC pixel mask reg
#define DAC_ADDRESS_READ_PORT       0x0017  // DAC register read index reg,
                                            // write-only
#define DAC_STATE_PORT              0x0017  // DAC state (read/write),
                                            // read-only
#define DAC_ADDRESS_WRITE_PORT      0x0018  // DAC register write index reg
#define DAC_DATA_REG_PORT           0x0019  // DAC data transfer reg
#define FEAT_CTRL_READ_PORT         0x001A  // Feature Control read port
#define MISC_OUTPUT_REG_READ_PORT   0x001C  // Miscellaneous Output reg read
                                            // port
#define GRAPH_ADDRESS_PORT          0x001E  // Graphics Controller Address
#define GRAPH_DATA_PORT             0x001F  // and Data registers

#define CRTC_ADDRESS_PORT_COLOR     0x0024  // CRT Controller Address and
#define CRTC_DATA_PORT_COLOR        0x0025  // Data registers in color mode
#define FEAT_CTRL_WRITE_PORT_COLOR  0x002A  // Feature Control write port
#define INPUT_STATUS_1_COLOR        0x002A  // Input Status 1 register read
                                            // port in color mode
#define ATT_INITIALIZE_PORT_COLOR   INPUT_STATUS_1_COLOR
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in color mode

//
// Offsets in HardwareStateHeader->PortValue[] of save areas for non-indexed
// VGA registers.
//

#define CRTC_ADDRESS_MONO_OFFSET      0x04
#define FEAT_CTRL_WRITE_MONO_OFFSET   0x0A
#define ATT_ADDRESS_OFFSET            0x10
#define MISC_OUTPUT_REG_WRITE_OFFSET  0x12
#define VIDEO_SUBSYSTEM_ENABLE_OFFSET 0x13
#define SEQ_ADDRESS_OFFSET            0x14
#define DAC_PIXEL_MASK_OFFSET         0x16
#define DAC_STATE_OFFSET              0x17
#define DAC_ADDRESS_WRITE_OFFSET      0x18
#define GRAPH_ADDRESS_OFFSET          0x1E
#define CRTC_ADDRESS_COLOR_OFFSET     0x24
#define FEAT_CTRL_WRITE_COLOR_OFFSET  0x2A

//
// VGA indexed register indexes.
//

#define IND_CURSOR_START        0x0A    // index in CRTC of the Cursor Start
#define IND_CURSOR_END          0x0B    //  and End registers
#define IND_CURSOR_HIGH_LOC     0x0E    // index in CRTC of the Cursor Location
#define IND_CURSOR_LOW_LOC      0x0F    //  High and Low Registers
#define IND_VSYNC_END           0x11    // index in CRTC of the Vertical Sync
                                        //  End register, which has the bit
                                        //  that protects/unprotects CRTC
                                        //  index registers 0-7
#define IND_SET_RESET_ENABLE    0x01    // index of Set/Reset Enable reg in GC
#define IND_DATA_ROTATE         0x03    // index of Data Rotate reg in GC
#define IND_READ_MAP            0x04    // index of Read Map reg in Graph Ctlr
#define IND_GRAPH_MODE          0x05    // index of Mode reg in Graph Ctlr
#define IND_GRAPH_MISC          0x06    // index of Misc reg in Graph Ctlr
#define IND_BIT_MASK            0x08    // index of Bit Mask reg in Graph Ctlr
#define IND_SYNC_RESET          0x00    // index of Sync Reset reg in Seq
#define IND_MAP_MASK            0x02    // index of Map Mask in Sequencer
#define IND_MEMORY_MODE         0x04    // index of Memory Mode reg in Seq
#define IND_CRTC_PROTECT        0x11    // index of reg containing regs 0-7 in
                                        //  CRTC

#define START_SYNC_RESET_VALUE  0x01    // value for Sync Reset reg to start
                                        //  synchronous reset
#define END_SYNC_RESET_VALUE    0x03    // value for Sync Reset reg to end
                                        //  synchronous reset

//
// Values for Attribute Controller Index register to turn video off
// and on, by setting bit 5 to 0 (off) or 1 (on).
//

#define VIDEO_DISABLE 0
#define VIDEO_ENABLE  0x20

//
// Value written to the Read Map register when identifying the existence of
// a VGA in VgaInitialize. This value must be different from the final test
// value written to the Bit Mask in that routine.
//

#define READ_MAP_TEST_SETTING 0x03

//
// Masks to keep only the significant bits of the Graphics Controller and
// Sequencer Address registers. Masking is necessary because some VGAs, such
// as S3-based ones, don't return unused bits set to 0, and some SVGAs use
// these bits if extensions are enabled.
//

#define GRAPH_ADDR_MASK 0x0F
#define SEQ_ADDR_MASK   0x07

//
// Mask used to toggle Chain4 bit in the Sequencer's Memory Mode register.
//

#define CHAIN4_MASK 0x08

//
// Default text mode setting for various registers, used to restore their
// states if VGA detection fails after they've been modified.
//

#define MEMORY_MODE_TEXT_DEFAULT 0x02
#define BIT_MASK_DEFAULT 0xFF
#define READ_MAP_DEFAULT 0x00

//
// Palette-related info.
//

//
// Highest valid DAC color register index.
//

#define VIDEO_MAX_COLOR_REGISTER  0xFF

//
// Highest valid palette register index
//

#define VIDEO_MAX_PALETTE_REGISTER 0x0F

//
// Indices for type of memory mapping; used in ModesVGA[], must match
// MemoryMap[].
//

typedef enum _VIDEO_MEMORY_MAP {
    MemMap_Mono,
    MemMap_CGA,
    MemMap_VGA
} VIDEO_MEMORY_MAP, *PVIDEO_MEMORY_MAP;

//
// Memory map table definition
//

typedef struct {
    ULONG   MaxSize;        // Maximum addressable size of memory.
    ULONG   Start;          // Start address of mode.
} MEMORYMAPS;

//
// For a mode, the type of banking supported. Controls the information
// returned in VIDEO_BANK_SELECT. PlanarHCBanking includes NormalBanking.
//

typedef enum _BANK_TYPE {
    NoBanking = 0,
    NormalBanking,
    PlanarHCBanking
} BANK_TYPE, *PBANK_TYPE;


#define  LCD_ENABLE        1
#define  LCD_DISABLE       4
#define  CRT_ENABLE        2
#define  CRT_DISABLE       0

#define  NO_SVGA_BIOS      0
#define  LIMITED_SVGA_BIOS 1
#define  FULL_SVGA_BIOS    2

//
// Structure used to describe each video mode in ModesVGA[].
//

typedef struct {
    USHORT  fbType; // color or monochrome, text or graphics, via
                    //  VIDEO_MODE_COLOR and VIDEO_MODE_GRAPHICS
    USHORT  numPlanes;    // # of video memory planes
    USHORT  bitsPerPlane; // # of bits of color in each plane
    SHORT   col;    // # of text columns across screen with default font
    SHORT   row;    // # of text rows down screen with default font
    USHORT  hres;   // # of pixels across screen
    USHORT  vres;   // # of scan lines down screen
    USHORT  wbytes; // # of bytes from start of one scan line to start of next
    ULONG   sbytes; // total size of addressable display memory in bytes
    ULONG   Frequency;  // Vertical Frequency
    ULONG   Interlaced; // Determines if the mode is interlaced or not
    BANK_TYPE banktype; // NoBanking, NormalBanking, PlanarHCBanking
    VIDEO_MEMORY_MAP   MemMap; // index from VIDEO_MEMORY_MAP of memory
                               //  mapping used by this mode
    ULONG   LCDtype;           // LCD types to be supported by this mode
    BOOLEAN ValidMode;         //Determines which modes are valid.
#ifdef INT10_MODE_SET
    UCHAR   FrequencyMask;     // value used to mask the mode frequency
    UCHAR   FrequencySetting;  // value used to set the mode frequency
    ULONG   Int10ModeNumber;   // Mode number via Int 10
    PUSHORT ModeTable;
#endif

    PUSHORT CmdStrings;   // pointer to array of register-setting commands
} VIDEOMODE, *PVIDEOMODE;


//
// Mode into which to put the VGA before starting a VDM, so it's a plain
// vanilla VGA.  (This is the mode's index in ModesVGA[], currently standard
// 80x25 text mode.)
//

#define DEFAULT_MODE 0


//
// Info for the validator functions.
//

//
// Number of each type of indexed register in a standard VGA, used by
// validator and state save/restore functions.
//
// Note: VDMs currently only support basic VGAs only.
//

#define VGA_NUM_SEQUENCER_PORTS     5
#define VGA_NUM_CRTC_PORTS         25
#define VGA_NUM_GRAPH_CONT_PORTS    9
#define VGA_NUM_ATTRIB_CONT_PORTS  21
#define VGA_NUM_DAC_ENTRIES       256

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

//
// Indices to start save/restore in extension registers:
// For both chip types

#define WD_GRAPH_EXT_START         0x09
#define WD_GRAPH_EXT_END           0x0E

#define WD_SEQUENCER_EXT_START     0x07
#define WD_SEQUENCER_EXT_END       0x09
#define WD_SEQUENCER_1_EXT_START   0x10
#define WD_SEQUENCER_1_EXT_END     0x14

#define WD_CRTC_EXT_START          0x2A
#define WD_CRTC_EXT_END            0x30
#define WD_CRTC_1_EXT_START        0x3E
#define WD_CRTC_1_EXT_END          0x3E

//
// Number of extended regs for both chip types.
//

#define WD_NUM_GRAPH_EXT_PORTS     (WD_GRAPH_EXT_END - WD_GRAPH_EXT_START + 1)
#define WD_NUM_SEQUENCER_EXT_PORTS (WD_SEQUENCER_EXT_END - WD_SEQUENCER_EXT_START + 1) + \
                                   (WD_SEQUENCER_1_EXT_END - WD_SEQUENCER_1_EXT_START + 1)
#define WD_NUM_CRTC_EXT_PORTS      (WD_CRTC_EXT_END - WD_CRTC_EXT_START + 1) + \
                                   (WD_CRTC_1_EXT_END - WD_CRTC_1_EXT_START + 1)

//
// set values for save/restore area based on largest value for a chipset.
//

#define EXT_NUM_GRAPH_CONT_PORTS    WD_NUM_GRAPH_EXT_PORTS
#define EXT_NUM_SEQUENCER_PORTS     WD_NUM_SEQUENCER_EXT_PORTS
#define EXT_NUM_CRTC_PORTS          WD_NUM_CRTC_EXT_PORTS
#define EXT_NUM_ATTRIB_CONT_PORTS   0
#define EXT_NUM_DAC_ENTRIES         0

#else 

#define EXT_NUM_GRAPH_CONT_PORTS    0
#define EXT_NUM_SEQUENCER_PORTS     0
#define EXT_NUM_CRTC_PORTS          0
#define EXT_NUM_ATTRIB_CONT_PORTS   0
#define EXT_NUM_DAC_ENTRIES         0

#endif        

//
// Info used by the Validator functions and save/restore code.
// Structure used to trap register accesses that must be done atomically.
//

#define VGA_MAX_VALIDATOR_DATA             100

#define VGA_VALIDATOR_UCHAR_ACCESS   1
#define VGA_VALIDATOR_USHORT_ACCESS  2
#define VGA_VALIDATOR_ULONG_ACCESS   3

typedef struct _VGA_VALIDATOR_DATA {
   ULONG Port;
   UCHAR AccessType;
   ULONG Data;
} VGA_VALIDATOR_DATA, *PVGA_VALIDATOR_DATA;


//
// Info for the save and restore state functions.
//

//
// Number of bytes to save in each plane.
//

#define VGA_PLANE_SIZE 0x10000

//
// These constants determine the offsets within the
// VIDEO_HARDWARE_STATE_HEADER structure that are used to save and
// restore the VGA's state.
//

#define VGA_HARDWARE_STATE_SIZE sizeof(VIDEO_HARDWARE_STATE_HEADER)

#define VGA_BASIC_SEQUENCER_OFFSET (VGA_HARDWARE_STATE_SIZE + 0)
#define VGA_BASIC_CRTC_OFFSET (VGA_BASIC_SEQUENCER_OFFSET + \
         VGA_NUM_SEQUENCER_PORTS)
#define VGA_BASIC_GRAPH_CONT_OFFSET (VGA_BASIC_CRTC_OFFSET + \
         VGA_NUM_CRTC_PORTS)
#define VGA_BASIC_ATTRIB_CONT_OFFSET (VGA_BASIC_GRAPH_CONT_OFFSET + \
         VGA_NUM_GRAPH_CONT_PORTS)
#define VGA_BASIC_DAC_OFFSET (VGA_BASIC_ATTRIB_CONT_OFFSET + \
         VGA_NUM_ATTRIB_CONT_PORTS)
#define VGA_BASIC_LATCHES_OFFSET (VGA_BASIC_DAC_OFFSET + \
         (3 * VGA_NUM_DAC_ENTRIES))

#define VGA_EXT_SEQUENCER_OFFSET (VGA_BASIC_LATCHES_OFFSET + 4)
#define VGA_EXT_CRTC_OFFSET (VGA_EXT_SEQUENCER_OFFSET + \
         EXT_NUM_SEQUENCER_PORTS)
#define VGA_EXT_GRAPH_CONT_OFFSET (VGA_EXT_CRTC_OFFSET + \
         EXT_NUM_CRTC_PORTS)
#define VGA_EXT_ATTRIB_CONT_OFFSET (VGA_EXT_GRAPH_CONT_OFFSET + \
         EXT_NUM_GRAPH_CONT_PORTS)
#define VGA_EXT_DAC_OFFSET (VGA_EXT_ATTRIB_CONT_OFFSET + \
         EXT_NUM_ATTRIB_CONT_PORTS)

#define VGA_VALIDATOR_OFFSET (VGA_EXT_DAC_OFFSET + 4 * EXT_NUM_DAC_ENTRIES)

#define VGA_VALIDATOR_AREA_SIZE  sizeof (ULONG) + (VGA_MAX_VALIDATOR_DATA * \
                                 sizeof (VGA_VALIDATOR_DATA)) +             \
                                 sizeof (ULONG) +                           \
                                 sizeof (ULONG) +                           \
                                 sizeof (PVIDEO_ACCESS_RANGE)

#define VGA_MISC_DATA_AREA_OFFSET VGA_VALIDATOR_OFFSET + VGA_VALIDATOR_AREA_SIZE

#define VGA_MISC_DATA_AREA_SIZE  0

#define VGA_PLANE_0_OFFSET VGA_MISC_DATA_AREA_OFFSET + VGA_MISC_DATA_AREA_SIZE

#define VGA_PLANE_1_OFFSET VGA_PLANE_0_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_2_OFFSET VGA_PLANE_1_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_3_OFFSET VGA_PLANE_2_OFFSET + VGA_PLANE_SIZE

//
// Space needed to store all state data.
//

#define VGA_TOTAL_STATE_SIZE VGA_PLANE_3_OFFSET + VGA_PLANE_SIZE


//
// Device extension for the driver object.  This data is only used
// locally, so this structure can be added to as needed.
//

typedef struct _HW_DEVICE_EXTENSION {

    PHYSICAL_ADDRESS PhysicalVideoMemoryBase; // physical memory address and
    PHYSICAL_ADDRESS PhysicalFrameBase;       // physical memory address and
    ULONG PhysicalVideoMemoryLength;          // length of display memory
    ULONG PhysicalFrameLength;                // length of display memory for
                                              // the current mode.

    PUCHAR  IOAddress;             // base I/O address of VGA ports
    PVOID   VideoMemoryAddress;    // base virtual memory address of VGA memory
    ULONG   AdapterMemorySize;     // size, in bytes, of the memory on the
                                   // board.
    ULONG   ModeIndex;             // index of current mode in ModesVGA[]
    ULONG   NumAvailableModes;     // number of valid modes on this device
    PVIDEOMODE CurrentMode;        // pointer to VIDEOMODE structure for
                                   // current mode

    USHORT  FontPelColumns;        // Width of the font in pels
    USHORT  FontPelRows;           // height of the font in pels

    VIDEO_CURSOR_POSITION CursorPosition;     // current cursor position

    UCHAR CursorEnable;            // whether cursor is enabled or not
    UCHAR CursorTopScanLine;       // Cursor Start register setting (top scan)
    UCHAR CursorBottomScanLine;    // Cursor End register setting (bottom scan)

    UCHAR BoardID;                 // Used to identify different boards
                                   // supported.

    UCHAR DisplayType;             // type of attached LCD display
    ULONG SVGABios;                // Indicates range of SVGA support
    BOOLEAN IsIBM;                 // True if this is an IBM machine

    ULONG ExtendedRegisters;       // Determines if extended registers have
                                   // been claimed.

    //
    // These 4 fields must be at the end of the device extension and must be
    // kept in this order since this data will be copied to and from the save
    // state buffer that is passed to and from the VDM.
    //

    ULONG TrappedValidatorCount;   // number of entries in the Trapped
                                   // validator data Array.
    VGA_VALIDATOR_DATA TrappedValidatorData[VGA_MAX_VALIDATOR_DATA];
                                   // Data trapped by the validator routines
                                   // but not yet played back into the VGA
                                   // register.

    ULONG SequencerAddressValue;   // Determines if the Sequencer Address Port
                                   // is currently selecting the SyncReset data
                                   // register.

    ULONG CurrentNumVdmAccessRanges;           // Number of access ranges in
                                               // the access range array pointed
                                               // to by the next field
    PVIDEO_ACCESS_RANGE CurrentVdmAccessRange; // Access range currently
                                               // associated to the VDM


} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


//
// Function prototypes.
//

//
// Entry points for the VGA validator. Used in VgaEmulatorAccessEntries[].
//

VP_STATUS
VgaValidatorUcharEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    );

VP_STATUS
VgaValidatorUshortEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    );

VP_STATUS
VgaValidatorUlongEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    );

BOOLEAN
VgaPlaybackValidatorData (
    PVOID Context
    );

extern USHORT m640[];
extern USHORT Reset[];

//
// Bank switch code start and end labels, define in HARDWARE.ASM
//

extern UCHAR BankSwitchStart;
extern UCHAR BankSwitchEnd;

//
// Vga init scripts for font loading
//

extern USHORT EnableA000Data[];
extern USHORT DisableA000Color[];

extern MEMORYMAPS MemoryMaps[];
extern VIDEOMODE ModesVGA[];
extern ULONG NumVideoModes;

//
// Defines used to determine the number of access ranges which are
// Verified.  Stored in HwDeviceExtension->ExtendedRegisters
//

#define EXTENDED_AND_FLAT_PANEL_REGISTERS    2
#define EXTENDED_REGISTERS                   1
#define NO_EXTENDED_REGISTERS                0

#define NUM_IBM_ACCESS_RANGES 7
#define NUM_ALL_ACCESS_RANGES 6
#define NUM_WD_ACCESS_RANGES  4
#define NUM_VGA_ACCESS_RANGES 3
extern VIDEO_ACCESS_RANGE VgaAccessRange[];

#define VGA_NUM_EMULATOR_ACCESS_ENTRIES     6
extern EMULATOR_ACCESS_ENTRY VgaEmulatorAccessEntries[];

#define NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE 4
extern VIDEO_ACCESS_RANGE MinimalVgaValidatorAccessRange[];

#define NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE 2
extern VIDEO_ACCESS_RANGE FullVgaValidatorAccessRange[];

//
// Prototypes for IBM SMAPI routines
//

void LCDInit(void);
void LCDDisplay(int);
int LCDIsMonitorPresent(void);

BOOLEAN
ExternalMonitorPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\wd\mini\wdvga.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    vga.c

Abstract:

    This is the miniport driver for the VGA card.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "wdvga.h"

extern USHORT Reset[];


//
// Function declarations
//
// Functions that start with 'VGA' are entry points for the OS port driver.
//

VP_STATUS
VgaFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
VgaInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
VgaStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

//
// Private function prototypes.
//

VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    );

VP_STATUS
VgaLoadAndSetFont(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_LOAD_FONT_INFORMATION FontInformation,
    ULONG FontInformationSize
    );

VP_STATUS
VgaQueryCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize
    );

VP_STATUS
VgaQueryCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize
    );

BOOLEAN
VgaIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
WdIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
VgaSizeMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
VgaInterpretCmdStream(
    PVOID HwDeviceExtension,
    PUSHORT pusCmdStream
    );

VP_STATUS
VgaSetPaletteReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_PALETTE_DATA PaletteBuffer,
    ULONG PaletteBufferSize
    );

VP_STATUS
VgaSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    );

VP_STATUS
VgaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    );

VP_STATUS
VgaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    PULONG OutputSize
    );

VP_STATUS
VgaGetBankSelectCode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_BANK_SELECT BankSelect,
    ULONG BankSelectSize,
    PULONG OutputSize
    );

VOID
VgaValidateModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
vBankMap(
    ULONG iBankRead,
    ULONG iBankWrite,
    PVOID pvContext
    );

VOID
GetPanelType(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
WdResetHw(
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    );

//
// New entry points added for NT 5.0.
//

#if (_WIN32_WINNT >= 500)

//
// Routine to set a desired DPMS power management state.
//
VP_STATUS
VGASetPower50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    );

//
// Routine to retrieve possible DPMS power management states.
//
VP_STATUS
VGAGetPower50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    );

//
// Routine to retrieve the Enhanced Display ID structure via DDC
//
ULONG
VGAGetVideoChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    );
#endif  // _WIN32_WINNT >= 500


#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,VgaFindAdapter)
#pragma alloc_text(PAGE,VgaInitialize)
#pragma alloc_text(PAGE,VgaStartIO)
#pragma alloc_text(PAGE,VgaLoadAndSetFont)
#pragma alloc_text(PAGE,VgaQueryCursorPosition)
#pragma alloc_text(PAGE,VgaSetCursorPosition)
#pragma alloc_text(PAGE,VgaQueryCursorAttributes)
#pragma alloc_text(PAGE,VgaSetCursorAttributes)
#pragma alloc_text(PAGE,VgaIsPresent)
#pragma alloc_text(PAGE,WdIsPresent)
#pragma alloc_text(PAGE,VgaSizeMemory)
#pragma alloc_text(PAGE,VgaSetPaletteReg)
#pragma alloc_text(PAGE,VgaSetColorLookup)
#pragma alloc_text(PAGE,VgaRestoreHardwareState)
#pragma alloc_text(PAGE,VgaSaveHardwareState)
#pragma alloc_text(PAGE,VgaGetBankSelectCode)

#pragma alloc_text(PAGE,VgaValidatorUcharEntry)
#pragma alloc_text(PAGE,VgaValidatorUshortEntry)
#pragma alloc_text(PAGE,VgaValidatorUlongEntry)
#pragma alloc_text(PAGE,GetPanelType)
#if (_WIN32_WINNT >= 500)
#pragma alloc_text(PAGE_COM, VGASetPower50)
#pragma alloc_text(PAGE_COM, VGAGetPower50)
#pragma alloc_text(PAGE_COM, VGAGetVideoChildDescriptor)
#endif  // _WIN32_WINNT >= 500

#endif


ULONG
DriverEntry(
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    Context1 - First context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

    Context2 - Second context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

--*/

{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG status;
    ULONG initializationStatus;

    //
    // Zero out structure.
    //

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    //
    // Specify sizes of structure and extension.
    //

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitData.HwFindAdapter = VgaFindAdapter;
    hwInitData.HwInitialize = VgaInitialize;
    hwInitData.HwInterrupt = NULL;
    hwInitData.HwStartIO = VgaStartIO;
    hwInitData.HwResetHw = WdResetHw;

#if (_WIN32_WINNT >= 500)

    //
    // Set new entry points added for NT 5.0.
    //

    hwInitData.HwSetPowerState           = VGASetPower50;
    hwInitData.HwGetPowerState           = VGAGetPower50;
    hwInitData.HwGetVideoChildDescriptor = VGAGetVideoChildDescriptor;

#endif // _WIN32_WINNT >= 500


    //
    // Determine the size we require for the device extension.
    //

    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //
    // Always start with parameters for device0 in this case.
    // We can leave it like this since we know we will only ever find one
    // VGA type adapter in a machine.
    //

//    hwInitData.StartingDeviceNumber = 0;

    //
    // Once all the relevant information has been stored, call the video
    // port driver to do the initialization.
    // For this device we will repeat this call three times, for ISA, EISA
    // and MCA.
    // We will return the minimum of all return values.
    //

    hwInitData.AdapterInterfaceType = Isa;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    hwInitData.AdapterInterfaceType = Eisa;

    status = VideoPortInitialize(Context1,
                                 Context2,
                                 &hwInitData,
                                 NULL);

    if (initializationStatus > status) {
        initializationStatus = status;
    }

    hwInitData.AdapterInterfaceType = MicroChannel;

    status = VideoPortInitialize(Context1,
                                 Context2,
                                 &hwInitData,
                                 NULL);

    if (initializationStatus > status) {
        initializationStatus = status;
    }

    return initializationStatus;

} // end DriverEntry()

VP_STATUS
VgaFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

/*++

Routine Description:

    This routine is called to determine if the adapter for this driver
    is present in the system.
    If it is present, the function fills out some information describing
    the adapter.

Arguments:

    HwDeviceExtension - Supplies the miniport driver's adapter storage. This
        storage is initialized to zero before this call.

    HwContext - Supplies the context value which was passed to
        VideoPortInitialize(). Must be NULL for PnP drivers.

    ArgumentString - Supplies a NULL terminated ASCII string. This string
        originates from the user.

    ConfigInfo - Returns the configuration information structure which is
        filled by the miniport driver. This structure is initialized with
        any known configuration information (such as SystemIoBusNumber) by
        the port driver. Where possible, drivers should have one set of
        defaults which do not require any supplied configuration information.

    Again - Indicates if the miniport driver wants the port driver to call
        its VIDEO_HW_FIND_ADAPTER function again with a new device extension
        and the same config info. This is used by the miniport drivers which
        can search for several adapters on a bus.

Return Value:

    This routine must return:

    NO_ERROR - Indicates a host adapter was found and the
        configuration information was successfully determined.

    ERROR_INVALID_PARAMETER - Indicates an adapter was found but there was an
        error obtaining the configuration information. If possible an error
        should be logged.

    ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
        supplied configuration information.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;

    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // No interrupt information is necessary.
    //

    //
    // Check to see if there is a hardware resource conflict.
    // Start by including the exted register. If that fails, then only use
    // the normal registers.
    //

    hwDeviceExtension->ExtendedRegisters = EXTENDED_AND_FLAT_PANEL_REGISTERS;

    status = VideoPortVerifyAccessRanges(hwDeviceExtension,
                                         NUM_ALL_ACCESS_RANGES,
                                         VgaAccessRange);

    if (status != NO_ERROR)
    {
        hwDeviceExtension->ExtendedRegisters = EXTENDED_REGISTERS;

        status = VideoPortVerifyAccessRanges(hwDeviceExtension,
                                             NUM_WD_ACCESS_RANGES,
                                             VgaAccessRange);

        if (status != NO_ERROR) {

            hwDeviceExtension->ExtendedRegisters = NO_EXTENDED_REGISTERS;

            status = VideoPortVerifyAccessRanges(hwDeviceExtension,
                                                 NUM_VGA_ACCESS_RANGES,
                                                 VgaAccessRange);

            if (status != NO_ERROR) {

                return status;

            }
        }
    }

    //
    // Get logical IO port addresses.
    //

    if ( (hwDeviceExtension->IOAddress =
              VideoPortGetDeviceBase(hwDeviceExtension,
                                     VgaAccessRange->RangeStart,
                                     VGA_MAX_IO_PORT - VGA_BASE_IO_PORT + 1,
                                     TRUE)) == NULL) {

        VideoDebugPrint((2, "VgaFindAdapter - Fail to get io address\n"));

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Determine whether a VGA is present.
    //

    if (!VgaIsPresent(hwDeviceExtension)) {

        return ERROR_DEV_NOT_EXIST;

    }

    //
    // Determine whether a WDVGA chipset is present.
    //

    if (!WdIsPresent(hwDeviceExtension)) {

        return ERROR_DEV_NOT_EXIST;

    }

    //
    // Pass a pointer to the emulator range we are using.
    //

    ConfigInfo->NumEmulatorAccessEntries = VGA_NUM_EMULATOR_ACCESS_ENTRIES;
    ConfigInfo->EmulatorAccessEntries = VgaEmulatorAccessEntries;
    ConfigInfo->EmulatorAccessEntriesContext = (ULONG) hwDeviceExtension;

    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart = MEM_VGA;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength = MEM_VGA_SIZE;

    //
    // Minimum size of the buffer required to store the hardware state
    // information returned by IOCTL_VIDEO_SAVE_HARDWARE_STATE.
    //

    ConfigInfo->HardwareStateSize = VGA_TOTAL_STATE_SIZE;

    //
    // Video memory information
    //

    hwDeviceExtension->PhysicalVideoMemoryBase.HighPart = 0x00000000;
    hwDeviceExtension->PhysicalVideoMemoryBase.LowPart = MEM_VGA;
    hwDeviceExtension->PhysicalVideoMemoryLength = MEM_VGA_SIZE;

    //
    // Map the video memory into the system virtual address space so we can
    // clear it out and use it for save and restore.
    //

    if ( (hwDeviceExtension->VideoMemoryAddress =
              VideoPortGetDeviceBase(hwDeviceExtension,
              hwDeviceExtension->PhysicalVideoMemoryBase,
              hwDeviceExtension->PhysicalVideoMemoryLength, FALSE)) == NULL) {

        VideoDebugPrint((1, "VgaFindAdapter - Fail to get memory address\n"));

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Indicate we do not wish to be called again for another initialization.
    //

    *Again = 0;

    //
    // Indicate a successful completion status.
    //

    return NO_ERROR;

} // VgaFindAdapter()

BOOLEAN
VgaInitialize(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    None.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;

    //
    // set up the default cursor position and type.
    //

    hwDeviceExtension->CursorPosition.Column = 0;
    hwDeviceExtension->CursorPosition.Row = 0;
    hwDeviceExtension->CursorTopScanLine = 0;
    hwDeviceExtension->CursorBottomScanLine = 31;
    hwDeviceExtension->CursorEnable = TRUE;

    //
    // Assume no BIOS for now
    //

    hwDeviceExtension->SVGABios = FALSE;

#ifdef INT10_MODE_SET

    //
    // Make sure we unlock extended registers since the BIOS on some machines
    // does not do it properly.
    //

    VideoPortWritePortUshort((PUSHORT)(hwDeviceExtension->IOAddress +
                             GRAPH_ADDRESS_PORT), 0x050F);

    //
    // Mode set block that can be repeated.
    //

    //
    // Lets try to check and see what level of SVGA Bios
    // support we have.
    //

    if (hwDeviceExtension->BoardID == WD90C24A)
    {
        //
        // IsIBM is set during detection
        //

        if (hwDeviceExtension->IsIBM == TRUE)
        {
            ULONG Modes[3] = {0x5f, 0x5c, 0x60};
            ULONG SVGASupport[3] = {LIMITED_SVGA_BIOS,
                                    LIMITED_SVGA_BIOS,
                                    FULL_SVGA_BIOS};
            ULONG i;

            hwDeviceExtension->SVGABios = NO_SVGA_BIOS;

            for(i=0; i<3; i++)
            {
                VideoPortZeroMemory(&biosArguments,
                                    sizeof(VIDEO_X86_BIOS_ARGUMENTS));

                biosArguments.Eax = Modes[i];
                VideoPortInt10(hwDeviceExtension, &biosArguments);

                //
                // now lets see if the modeset worked
                //

                biosArguments.Eax = 0x0f00;
                VideoPortInt10(hwDeviceExtension, &biosArguments);

                if ((biosArguments.Eax & 0xff) == Modes[i])
                {
                    hwDeviceExtension->SVGABios = SVGASupport[i];
                }
            }

            //
            // IMPORTANT NOTE:
            //
            // The 750 Thinkpad has an STN panel.  However, we detect it
            // as an TFT 800x600 panel.  So, if we detect this type of
            // panel, but no SVGA support, we'll reset the panel type
            // to STN_MONO_LCD.
            //

            if ((hwDeviceExtension->SVGABios == NO_SVGA_BIOS) &&
                (hwDeviceExtension->DisplayType & IBM_F8532))
            {
                hwDeviceExtension->DisplayType &= ~IBM_F8532;
                hwDeviceExtension->DisplayType |= STN_MONO_LCD;
            }

            //
            // On IBM machines, we will use the Thinkpad System
            // Management API.  We call LCDInit to initialize.
            //

            LCDInit();
        }
        else
        {
            //
            // If this is not an IBM machine, then we will
            // simply assume that it has a SVGA Bios.
            //
            // The reason we do this is because I know of no
            // non-IBM machines which do not have an SVGA Bios.
            // Also, some of these machines BIOS's do not
            // do the mode set into high res modes if the LCD
            // is enabled.  Therefore, it looks like it does
            // not have an SVGA when it really does.
            //

            hwDeviceExtension->SVGABios = FULL_SVGA_BIOS;
        }
    }

    if (hwDeviceExtension->BoardID == WD90C24A)
    {

        //
        // Check to see if an external monitor is present.
        //
        // Note: Do not check for an external monitor, if the panel
        //       type is STN_MONO_LCD.  This check may corrupt the
        //       display.
        //

        if (!(hwDeviceExtension->DisplayType & STN_MONO_LCD))
        {
            VideoPortSynchronizeExecution(hwDeviceExtension,
                                          VpHighPriority,
                                          (PMINIPORT_SYNCHRONIZE_ROUTINE) ExternalMonitorPresent,
                                          hwDeviceExtension);

            VideoDebugPrint((1, "\nHwDeviceExtension->DisplayType = 0x%x\n\n",
                                 hwDeviceExtension->DisplayType));
        }
        else
        {
            //
            // We'll have to assume that no external monitor is connected.
            //

            hwDeviceExtension->DisplayType &= ~MONITOR;
        }
    }
    else
    {
        hwDeviceExtension->DisplayType |= MONITOR;
    }

#endif

    return TRUE;

} // VgaInitialize()

BOOLEAN
VgaStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    acceptss a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

    RequestPacket - Pointer to the video request packet. This structure
        contains all the parameters passed to the VideoIoControl function.

Return Value:

    This routine will return error codes from the various support routines
    and will also return ERROR_INSUFFICIENT_BUFFER for incorrectly sized
    buffers and ERROR_INVALID_FUNCTION for unsupported functions.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;
    VIDEO_MODE videoMode;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    ULONG inIoSpace;

    PVIDEO_SHARE_MEMORY pShareMemory;
    PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
    PHYSICAL_ADDRESS shareAddress;
    PVOID virtualAddress;
    ULONG sharedViewSize;
    ULONG ulBankSize;

    VOID (*pfnBank)(ULONG,ULONG,PVOID);

    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //

    switch (RequestPacket->IoControlCode) {


    case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - ShareVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength < sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;
            VideoDebugPrint((1, "VgaStartIO - ShareVideoMemory - ERROR_INSUFFICIENT_BUFFER\n"));
            break;

        }

        pShareMemory = RequestPacket->InputBuffer;

        if ( (pShareMemory->ViewOffset > hwDeviceExtension->AdapterMemorySize) ||
             ((pShareMemory->ViewOffset + pShareMemory->ViewSize) >
                  hwDeviceExtension->AdapterMemorySize) ) {

            status = ERROR_INVALID_PARAMETER;
            VideoDebugPrint((1, "VgaStartIO - ShareVideoMemory - ERROR_INVALID_PARAMETER\n"));
            break;

        }

        RequestPacket->StatusBlock->Information =
                                    sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

        //
        // Beware: the input buffer and the output buffer are the same
        // buffer, and therefore data should not be copied from one to the
        // other
        //

        virtualAddress = pShareMemory->ProcessHandle;
        sharedViewSize = pShareMemory->ViewSize;

        inIoSpace = 0;

        //
        // NOTE: we are ignoring ViewOffset
        //

        shareAddress.QuadPart =
            hwDeviceExtension->PhysicalFrameBase.QuadPart;


        pfnBank = vBankMap;
        ulBankSize = 0x10000; // 64K banks

        status = VideoPortMapBankedMemory(hwDeviceExtension,
                                          shareAddress,
                                          &sharedViewSize,
                                          &inIoSpace,
                                          &virtualAddress,
                                          ulBankSize,   // bank size
                                          FALSE,        // we have separate read/write
                                          pfnBank,
                                          (PVOID)hwDeviceExtension);

        pShareMemoryInformation = RequestPacket->OutputBuffer;

        pShareMemoryInformation->SharedViewOffset = pShareMemory->ViewOffset;
        pShareMemoryInformation->VirtualAddress = virtualAddress;
        pShareMemoryInformation->SharedViewSize = sharedViewSize;

        break;


    case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - UnshareVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;

        }

        pShareMemory = RequestPacket->InputBuffer;

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      pShareMemory->RequestedVirtualAddress,
                                      pShareMemory->ProcessHandle);

        break;


    case IOCTL_VIDEO_MAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - MapVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength <
              (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MEMORY_INFORMATION))) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;
        }

        memoryInformation = RequestPacket->OutputBuffer;

        memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
                (RequestPacket->InputBuffer))->RequestedVirtualAddress;

        memoryInformation->VideoRamLength =
                hwDeviceExtension->PhysicalVideoMemoryLength;

        inIoSpace = 0;

        status = VideoPortMapMemory(hwDeviceExtension,
                                    hwDeviceExtension->PhysicalVideoMemoryBase,
                                    &(memoryInformation->VideoRamLength),
                                    &inIoSpace,
                                    &(memoryInformation->VideoRamBase));

        memoryInformation->FrameBufferBase =
                ((PUCHAR) (memoryInformation->VideoRamBase)) +
                (hwDeviceExtension->PhysicalFrameBase.LowPart -
                hwDeviceExtension->PhysicalVideoMemoryBase.LowPart);

        memoryInformation->FrameBufferLength =
            hwDeviceExtension->PhysicalFrameLength;

        break;


    case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - UnMapVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
        }

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      ((PVIDEO_MEMORY)
                                       (RequestPacket->InputBuffer))->
                                           RequestedVirtualAddress,
                                      0);

        break;

    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        VideoDebugPrint((2, "VgaStartIO - QueryAvailableModes\n"));

        status = VgaQueryAvailableModes(HwDeviceExtension,
                                        (PVIDEO_MODE_INFORMATION)
                                            RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        &RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((2, "VgaStartIO - QueryNumAvailableModes\n"));

        status = VgaQueryNumberOfAvailableModes(HwDeviceExtension,
                                                (PVIDEO_NUM_MODES)
                                                    RequestPacket->OutputBuffer,
                                                RequestPacket->OutputBufferLength,
                                                &RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        VideoDebugPrint((2, "VgaStartIO - QueryCurrentMode\n"));

        status = VgaQueryCurrentMode(HwDeviceExtension,
                                     (PVIDEO_MODE_INFORMATION) RequestPacket->OutputBuffer,
                                     RequestPacket->OutputBufferLength,
                                     &RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_SET_CURRENT_MODE:

        VideoDebugPrint((2, "VgaStartIO - SetCurrentModes\n"));

        status = VgaSetMode(HwDeviceExtension,
                            (PVIDEO_MODE) RequestPacket->InputBuffer,
                            RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_RESET_DEVICE:

        VideoDebugPrint((2, "VgaStartIO - Reset Device\n"));

        //
        // If we are running on an IBM machine with a VGA
        // chip, then we need to execute some special reset code.
        //

        WdResetHw(HwDeviceExtension, 0, 0);

        videoMode.RequestedMode = DEFAULT_MODE;

        status = VgaSetMode(HwDeviceExtension,
                            (PVIDEO_MODE) &videoMode,
                            sizeof(videoMode));

        break;


    case IOCTL_VIDEO_LOAD_AND_SET_FONT:

        VideoDebugPrint((2, "VgaStartIO - LoadAndSetFont\n"));

        status = VgaLoadAndSetFont(HwDeviceExtension,
                                   (PVIDEO_LOAD_FONT_INFORMATION) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_QUERY_CURSOR_POSITION:

        VideoDebugPrint((2, "VgaStartIO - QueryCursorPosition\n"));

        status = VgaQueryCursorPosition(HwDeviceExtension,
                                        (PVIDEO_CURSOR_POSITION) RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        &RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_SET_CURSOR_POSITION:

        VideoDebugPrint((2, "VgaStartIO - SetCursorPosition\n"));

        status = VgaSetCursorPosition(HwDeviceExtension,
                                      (PVIDEO_CURSOR_POSITION)
                                          RequestPacket->InputBuffer,
                                      RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_QUERY_CURSOR_ATTR:

        VideoDebugPrint((2, "VgaStartIO - QueryCursorAttributes\n"));

        status = VgaQueryCursorAttributes(HwDeviceExtension,
                                          (PVIDEO_CURSOR_ATTRIBUTES) RequestPacket->OutputBuffer,
                                          RequestPacket->OutputBufferLength,
                                          &RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_SET_CURSOR_ATTR:

        VideoDebugPrint((2, "VgaStartIO - SetCursorAttributes\n"));

        status = VgaSetCursorAttributes(HwDeviceExtension,
                                        (PVIDEO_CURSOR_ATTRIBUTES) RequestPacket->InputBuffer,
                                        RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_SET_PALETTE_REGISTERS:

        VideoDebugPrint((2, "VgaStartIO - SetPaletteRegs\n"));

        status = VgaSetPaletteReg(HwDeviceExtension,
                                  (PVIDEO_PALETTE_DATA) RequestPacket->InputBuffer,
                                  RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        VideoDebugPrint((2, "VgaStartIO - SetColorRegs\n"));

        status = VgaSetColorLookup(HwDeviceExtension,
                                   (PVIDEO_CLUT) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_ENABLE_VDM:

        VideoDebugPrint((2, "VgaStartIO - EnableVDM\n"));

        hwDeviceExtension->TrappedValidatorCount = 0;
        hwDeviceExtension->SequencerAddressValue = 0;

        hwDeviceExtension->CurrentNumVdmAccessRanges =
            NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE;
        hwDeviceExtension->CurrentVdmAccessRange =
            MinimalVgaValidatorAccessRange;

        VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                         hwDeviceExtension->CurrentNumVdmAccessRanges,
                                         hwDeviceExtension->CurrentVdmAccessRange);

        status = NO_ERROR;

        break;


    case IOCTL_VIDEO_RESTORE_HARDWARE_STATE:

        VideoDebugPrint((2, "VgaStartIO - RestoreHardwareState\n"));

        status = VgaRestoreHardwareState(HwDeviceExtension,
                                         (PVIDEO_HARDWARE_STATE) RequestPacket->InputBuffer,
                                         RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_SAVE_HARDWARE_STATE:

        VideoDebugPrint((2, "VgaStartIO - SaveHardwareState\n"));

        status = VgaSaveHardwareState(HwDeviceExtension,
                                      (PVIDEO_HARDWARE_STATE) RequestPacket->OutputBuffer,
                                      RequestPacket->OutputBufferLength,
                                      &RequestPacket->StatusBlock->Information);

        break;

    case IOCTL_VIDEO_GET_BANK_SELECT_CODE:

        VideoDebugPrint((2, "VgaStartIO - GetBankSelectCode\n"));

        status = VgaGetBankSelectCode(HwDeviceExtension,
                                        (PVIDEO_BANK_SELECT) RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        &RequestPacket->StatusBlock->Information);

        break;


    //
    // if we get here, an invalid IoControlCode was specified.
    //

    default:

        VideoDebugPrint((1, "Fell through vga startIO routine - invalid command\n"));

        status = ERROR_INVALID_FUNCTION;

        break;

    }

    RequestPacket->StatusBlock->Status = status;

    return TRUE;

} // VgaStartIO()

//
// private routines
//

VP_STATUS
VgaLoadAndSetFont(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_LOAD_FONT_INFORMATION FontInformation,
    ULONG FontInformationSize
    )

/*++

Routine Description:

    Takes a buffer containing a user-defined font and loads it into the
    VGA soft font memory and programs the VGA to the appropriate character
    cell size.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FontInformation - Pointer to the structure containing the information
        about the loadable ROM font to be set.

    FontInformationSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    PUCHAR destination;
    PUCHAR source;
    USHORT width;
    ULONG i;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough
    // and that it contains all the data.
    //

    if ( (FontInformationSize < sizeof(VIDEO_LOAD_FONT_INFORMATION)) ||
         (FontInformationSize < sizeof(VIDEO_LOAD_FONT_INFORMATION) +
                        sizeof(UCHAR) * (FontInformation->FontSize - 1)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check for the width and height of the font
    //

    if ( ((FontInformation->WidthInPixels != 8) &&
          (FontInformation->WidthInPixels != 9)) ||
         (FontInformation->HeightInPixels > 32) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check the size of the font buffer is the right size for the size
    // font being passed down.
    //

    if (FontInformation->FontSize < FontInformation->HeightInPixels * 256 *
                                    sizeof(UCHAR) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Since the font parameters are valid, store the parameters in the
    // device extension and load the font.
    //

    HwDeviceExtension->FontPelRows = FontInformation->HeightInPixels;
    HwDeviceExtension->FontPelColumns = FontInformation->WidthInPixels;

    HwDeviceExtension->CurrentMode->row =
        HwDeviceExtension->CurrentMode->vres / HwDeviceExtension->FontPelRows;

    width =
      HwDeviceExtension->CurrentMode->hres / HwDeviceExtension->FontPelColumns;

    if (width < (USHORT)HwDeviceExtension->CurrentMode->col) {

        HwDeviceExtension->CurrentMode->col = width;

    }

    source = &(FontInformation->Font[0]);

    //
    // Set up the destination and source pointers for the font
    //

    destination = (PUCHAR)HwDeviceExtension->VideoMemoryAddress;

    //
    // Map font buffer at A0000
    //

    VgaInterpretCmdStream(HwDeviceExtension, EnableA000Data);

    //
    // Move the font to its destination
    //

    for (i = 1; i <= 256; i++) {

        VideoPortWriteRegisterBufferUchar(destination,
                                          source,
                                          FontInformation->HeightInPixels);

        destination += 32;
        source += FontInformation->HeightInPixels;

    }

    VgaInterpretCmdStream(HwDeviceExtension, DisableA000Color);

    //
    // Restore to a text mode.
    //

    //
    // Set Height of font.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0x9);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR,
            (UCHAR)(FontInformation->HeightInPixels - 1));

    //
    // Set Width of font.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0x12);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR,
            (UCHAR)(((USHORT)FontInformation->HeightInPixels *
            (USHORT)HwDeviceExtension->CurrentMode->row) - 1));

    i = HwDeviceExtension->CurrentMode->vres /
        HwDeviceExtension->CurrentMode->row;

    //
    // Set Cursor End
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0xb);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR)--i);

    //
    // Set Cursor Statr
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0xa);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR)--i);

    return NO_ERROR;

} //end VgaLoadAndSetFont()

VP_STATUS
VgaQueryCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the row and column of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorPosition - Pointer to the output buffer supplied by the user. This
        is where the cursor position is stored.

    CursorPositionSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        *OutputSize = 0;
        return ERROR_INVALID_PARAMETER;

    }

    //
    // If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (CursorPositionSize < (*OutputSize = sizeof(VIDEO_CURSOR_POSITION)) ) {

        *OutputSize = 0;
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the postition of the cursor into the buffer.
    //

    CursorPosition->Column = HwDeviceExtension->CursorPosition.Column;
    CursorPosition->Row = HwDeviceExtension->CursorPosition.Row;

    return NO_ERROR;

} // end VgaQueryCursorPosition()

VP_STATUS
VgaSetCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize
    )

/*++

Routine Description:

    This routine verifies that the requested cursor position is within
    the row and column bounds of the current mode and font. If valid, then
    it sets the row and column of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorPosition - Pointer to the structure containing the cursor position.

    CursorPositionSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    USHORT position;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (CursorPositionSize < sizeof(VIDEO_CURSOR_POSITION)) {

            return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check if the new values for the cursor positions are in the valid
    // bounds for the screen.
    //

    if ((CursorPosition->Column >= HwDeviceExtension->CurrentMode->col) ||
        (CursorPosition->Row >= HwDeviceExtension->CurrentMode->row)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Store these new values in the device extension so we can use them in
    // a QUERY.
    //

    HwDeviceExtension->CursorPosition.Column = CursorPosition->Column;
    HwDeviceExtension->CursorPosition.Row = CursorPosition->Row;

    //
    // Calculate the position on the screen at which the cursor must be
    // be displayed
    //

    position = (USHORT) (HwDeviceExtension->CurrentMode->col *
                         CursorPosition->Row + CursorPosition->Column);


    //
    // Address Cursor Location Low Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, IND_CURSOR_LOW_LOC);

    //
    // Set Cursor Location Low Register
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR) (position & 0x00FF));

    //
    // Address Cursor Location High Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, IND_CURSOR_HIGH_LOC);

    //
    // Set Cursor Location High Register
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR) (position >> 8));

    return NO_ERROR;

} // end VgaSetCursorPosition()

VP_STATUS
VgaQueryCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns information about the height and visibility of the
    cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorAttributes - Pointer to the output buffer supplied by the user.
        This is where the cursor type is stored.

    CursorAttributesSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        *OutputSize = 0;
        return ERROR_INVALID_PARAMETER;

    }

    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (CursorAttributesSize < (*OutputSize =
            sizeof(VIDEO_CURSOR_ATTRIBUTES)) ) {

        *OutputSize = 0;
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the cursor information into the buffer.
    //

    CursorAttributes->Height = (USHORT) HwDeviceExtension->CursorTopScanLine;
    CursorAttributes->Width = (USHORT) HwDeviceExtension->CursorBottomScanLine;
    CursorAttributes->Enable = HwDeviceExtension->CursorEnable;

    return NO_ERROR;

} // end VgaQueryCursorAttributes()

VP_STATUS
VgaSetCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize
    )

/*++

Routine Description:

    This routine verifies that the requested cursor height is within the
    bounds of the character cell. If valid, then it sets the new
    visibility and height of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorType - Pointer to the structure containing the cursor information.

    CursorTypeSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    UCHAR cursorLine;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (CursorAttributesSize < sizeof(VIDEO_CURSOR_ATTRIBUTES)) {

            return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check if the new values for the cursor type are in the valid range.
    //

    if ((CursorAttributes->Height >= HwDeviceExtension->FontPelRows) ||
        (CursorAttributes->Width > 31)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Store the cursor information in the device extension so we can use
    // them in a QUERY.
    //

    HwDeviceExtension->CursorTopScanLine = (UCHAR) CursorAttributes->Height;
    HwDeviceExtension->CursorBottomScanLine = (UCHAR) CursorAttributes->Width;
    HwDeviceExtension->CursorEnable = CursorAttributes->Enable;

    //
    // Address Cursor Start Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR,
                            IND_CURSOR_START);

    //
    // Set Cursor Start Register by writting to CRTCtl Data Register
    // Preserve the high three bits of this register.
    //
    // Only the Five low bits are used for the cursor height.
    // Bit 5 is cursor enable, bit 6 and 7 preserved.
    //

    cursorLine = (UCHAR) CursorAttributes->Height & 0x1F;

    cursorLine |= VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        CRTC_DATA_PORT_COLOR) & 0xC0;

    if (!CursorAttributes->Enable) {

        cursorLine |= 0x20; // Flip cursor off bit

    }

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + CRTC_DATA_PORT_COLOR,
                                cursorLine);

    //
    // Address Cursor End Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR,
                            IND_CURSOR_END);

    //
    // Set Cursor End Register. Preserve the high three bits of this
    // register.
    //

    cursorLine =
        (CursorAttributes->Width < (USHORT)(HwDeviceExtension->FontPelRows - 1)) ?
        CursorAttributes->Width : (HwDeviceExtension->FontPelRows - 1);

    cursorLine &= 0x1f;

    cursorLine |= VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR) & 0xE0;

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + CRTC_DATA_PORT_COLOR,
                            cursorLine);

    return NO_ERROR;

} // end VgaSetCursorAttributes()

BOOLEAN
VgaIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine returns TRUE if a VGA is present. Determining whether a VGA
    is present is a two-step process. First, this routine walks bits through
    the Bit Mask register, to establish that there are readable indexed
    registers (EGAs normally don't have readable registers, and other adapters
    are unlikely to have indexed registers). This test is done first because
    it's a non-destructive EGA rejection test (correctly rejects EGAs, but
    doesn't potentially mess up the screen or the accessibility of display
    memory). Normally, this would be an adequate test, but some EGAs have
    readable registers, so next, we check for the existence of the Chain4 bit
    in the Memory Mode register; this bit doesn't exist in EGAs. It's
    conceivable that there are EGAs with readable registers and a register bit
    where Chain4 is stored, although I don't know of any; if a better test yet
    is needed, memory could be written to in Chain4 mode, and then examined
    plane by plane in non-Chain4 mode to make sure the Chain4 bit did what it's
    supposed to do. However, the current test should be adequate to eliminate
    just about all EGAs, and 100% of everything else.

    If this function fails to find a VGA, it attempts to undo any damage it
    may have inadvertently done while testing. The underlying assumption for
    the damage control is that if there's any non-VGA adapter at the tested
    ports, it's an EGA or an enhanced EGA, because: a) I don't know of any
    other adapters that use 3C4/5 or 3CE/F, and b), if there are other
    adapters, I certainly don't know how to restore their original states. So
    all error recovery is oriented toward putting an EGA back in a writable
    state, so that error messages are visible. The EGA's state on entry is
    assumed to be text mode, so the Memory Mode register is restored to the
    default state for text mode.

    If a VGA is found, the VGA is returned to its original state after
    testing is finished.

Arguments:

    None.

Return Value:

    TRUE if a VGA is present, FALSE if not.

--*/

{
    UCHAR originalGCAddr;
    UCHAR originalSCAddr;
    UCHAR originalBitMask;
    UCHAR originalReadMap;
    UCHAR originalMemoryMode;
    UCHAR testMask;
    BOOLEAN returnStatus;

    //
    // Remember the original state of the Graphics Controller Address register.
    //

    originalGCAddr = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT);

    //
    // Write the Read Map register with a known state so we can verify
    // that it isn't changed after we fool with the Bit Mask. This ensures
    // that we're dealing with indexed registers, since both the Read Map and
    // the Bit Mask are addressed at GRAPH_DATA_PORT.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    //
    // If we can't read back the Graphics Address register setting we just
    // performed, it's not readable and this isn't a VGA.
    //

    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        GRAPH_ADDRESS_PORT) & GRAPH_ADDR_MASK) != IND_READ_MAP) {

        return FALSE;
    }

    //
    // Set the Read Map register to a known state.
    //

    originalReadMap = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, READ_MAP_TEST_SETTING);

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) != READ_MAP_TEST_SETTING) {

        //
        // The Read Map setting we just performed can't be read back; not a
        // VGA. Restore the default Read Map state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);

        return FALSE;
    }

    //
    // Remember the original setting of the Bit Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_BIT_MASK);
    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT) & GRAPH_ADDR_MASK) != IND_BIT_MASK) {

        //
        // The Graphics Address register setting we just made can't be read
        // back; not a VGA. Restore the default Read Map state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, IND_READ_MAP);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);

        return FALSE;
    }

    originalBitMask = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);

    //
    // Set up the initial test mask we'll write to and read from the Bit Mask.
    //

    testMask = 0xBB;

    do {

        //
        // Write the test mask to the Bit Mask.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, testMask);

        //
        // Make sure the Bit Mask remembered the value.
        //

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT) != testMask) {

            //
            // The Bit Mask is not properly writable and readable; not a VGA.
            // Restore the Bit Mask and Read Map to their default states.
            //

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT, BIT_MASK_DEFAULT);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_ADDRESS_PORT, IND_READ_MAP);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT, READ_MAP_DEFAULT);

            return FALSE;
        }

        //
        // Cycle the mask for next time.
        //

        testMask >>= 1;

    } while (testMask != 0);

    //
    // There's something readable at GRAPH_DATA_PORT; now switch back and
    // make sure that the Read Map register hasn't changed, to verify that
    // we're dealing with indexed registers.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);
    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT) != READ_MAP_TEST_SETTING) {

        //
        // The Read Map is not properly writable and readable; not a VGA.
        // Restore the Bit Mask and Read Map to their default states, in case
        // this is an EGA, so subsequent writes to the screen aren't garbled.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, IND_BIT_MASK);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, BIT_MASK_DEFAULT);

        return FALSE;
    }

    //
    // We've pretty surely verified the existence of the Bit Mask register.
    // Put the Graphics Controller back to the original state.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, originalReadMap);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_BIT_MASK);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, originalBitMask);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, originalGCAddr);

    //
    // Now, check for the existence of the Chain4 bit.
    //

    //
    // Remember the original states of the Sequencer Address and Memory Mode
    // registers.
    //

    originalSCAddr = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT) & SEQ_ADDR_MASK) != IND_MEMORY_MODE) {

        //
        // Couldn't read back the Sequencer Address register setting we just
        // performed.
        //

        return FALSE;
    }
    originalMemoryMode = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT);

    //
    // Toggle the Chain4 bit and read back the result. This must be done during
    // sync reset, since we're changing the chaining state.
    //

    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
             SEQ_ADDRESS_PORT),
             (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Toggle the Chain4 bit.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT, (UCHAR)(originalMemoryMode ^ CHAIN4_MASK));

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT) != (UCHAR) (originalMemoryMode ^ CHAIN4_MASK)) {

        //
        // Chain4 bit not there; not a VGA.
        // Set text mode default for Memory Mode register.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, MEMORY_MODE_TEXT_DEFAULT);
        //
        // End sync reset.
        //

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),
                (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

        returnStatus = FALSE;

    } else {

        //
        // It's a VGA.
        //

        //
        // Restore the original Memory Mode setting.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, originalMemoryMode);

        //
        // End sync reset.
        //

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),
                (USHORT)(IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

        //
        // Restore the original Sequencer Address setting.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, originalSCAddr);

        returnStatus = TRUE;
    }

    return returnStatus;

} // VgaIsPresent()

BOOLEAN
WdIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine returns TRUE if an WDVGA is present. It assumes that it's
    already been established that a VGA is present.  It performs the Western
    Digital recommended ID test.  If all this works, then this is indeed an
    chip from Western Digital.

    All the registers will be preserved either this function fails to find a
    WD vga or a WD vga is found.

Arguments:

    None.

Return Value:

    TRUE if a WDVGA is present, FALSE if not.

--*/

{
    #define MAX_ROM_SCAN 4096

    UCHAR   *pRomAddr;
    PHYSICAL_ADDRESS paRom = {0x000C0000,0x00000000};

    UCHAR GraphSave0c;
    UCHAR GraphSave0f;
    UCHAR temp1, temp2;

    BOOLEAN status = TRUE;
    PWSTR pwszChipString;
    ULONG cbChipString;

    //
    // write 3ce.0c
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, 0x0c);
    GraphSave0c = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);
    temp1 = GraphSave0c & 0xbf;
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, temp1);

    //
    // write 3ce.0f
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, 0x0f);
    GraphSave0f = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, 0x0);

    //
    // write 3ce.09
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, 0x09);
    temp1 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, (UCHAR)(temp1+1));
    temp2 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, temp1);

    if ((temp1+1) == temp2) {

        status = FALSE;
        goto NOT_WDVGA;

    }

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), 0x050f);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, 0x09);
    temp1 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, (UCHAR)(temp1+1));
    temp2 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, temp1);

    if ((temp1+1) != temp2) {

        status = FALSE;
        goto NOT_WDVGA;

    }

    //
    // it *is* a WDVGA!
    //

    //
    // Assume a 90c30
    //

    HwDeviceExtension->BoardID = WD90C30;
    pwszChipString = L"WD 90C30";
    cbChipString = sizeof(L"WD 90C30");

    //
    // Look for extended regsiters that are only in WD90C31 and over
    //

    if (HwDeviceExtension->ExtendedRegisters) {

        UCHAR save;
        PUCHAR ExtendedIOAddress;

        //
        // Get WDC31 extended port base address.
        //

        if ((ExtendedIOAddress =
             VideoPortGetDeviceBase(HwDeviceExtension,
                                    VgaAccessRange[3].RangeStart,
                                    VgaAccessRange[3].RangeLength,
                                    VgaAccessRange[3].RangeInIoSpace)) == NULL) {

            VideoDebugPrint((2, "WDVGAIsPresent - Fail to get ext. io address\n"));
            status = FALSE;
            goto NOT_WDVGA;

        }

        save = VideoPortReadPortUchar(ExtendedIOAddress);

        VideoPortWritePortUchar(ExtendedIOAddress, 0x02);

        temp1 = VideoPortReadPortUchar(ExtendedIOAddress);

        if (temp1 == 0x02)
        {
            UCHAR    temp, pr72;
            BOOLEAN  IsVGA = FALSE;

            //
            // Assume we have a WD90C31
            //

            HwDeviceExtension->BoardID = WD90C31;
            pwszChipString = L"WD 90C31";
            cbChipString = sizeof(L"WD 90C31");

            //
            // The following code was derived from IBM's
            // VESA TSR for the WDVGA.  This code
            // detects the presence of a VGA chip.
            //

            VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                     SEQ_ADDRESS_PORT),
                                     0x4806);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                     SEQ_ADDRESS_PORT,
                                     0x35);
            temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                     SEQ_ADDRESS_PORT);
            if (temp == 0x35)
            {
                //
                // We don't know if it is a VGA yet or not,
                // but we have passed our first test.
                //

                pr72 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                        SEQ_DATA_PORT);
                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                        SEQ_DATA_PORT,
                                        0x70);
                temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                        SEQ_DATA_PORT);
                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                        SEQ_DATA_PORT,
                                        pr72);

                if (temp == 0x70)
                {
                    IsVGA = TRUE;
                }
            }

            if (IsVGA)
            {
                //
                // VGA
                //

                HwDeviceExtension->BoardID = WD90C24A;
                pwszChipString = L"Western Digital 90C24A";
                cbChipString = sizeof(L"Western Digital 90C24A");

                //
                // H/W cursor off for initial phase. Probably enabled after
                // pointer related IOControl calling.
                // This is not required if the HAL display initialization code
                // has already done this. For most of Intel machines this code
                // is not required because no codes enable this hardware cursor
                // but the PowerPC firmware did it.
                //

                VideoPortWritePortUchar(ExtendedIOAddress+0, 0x02);
                VideoPortWritePortUchar(ExtendedIOAddress+1, 0x00);
                VideoPortWritePortUchar(ExtendedIOAddress+2, 0x00);
                VideoPortWritePortUchar(ExtendedIOAddress+3, 0x00);
                VideoPortWritePortUchar(ExtendedIOAddress+0, 0x00);

                //
                // Now that we know we have a VGA chip, lets
                // see if we are on an IBM machine.  We'll check
                // this by looking at address 0xf000:0xe00e.  This
                // address should contain the ANSI string IBM if
                // we are running on an IBM machine.
                //
                // Well have to map this range in to examine it.
                //

                {
                    PHYSICAL_ADDRESS ID_String;
                    PVOID VirtualAddress;

                    //
                    // This is the address in the machine ROM
                    // where the string "IBM" should appear, if
                    // the machine is an IBM machine.
                    //

                    ID_String.HighPart = 0;
                    ID_String.LowPart = 0xF0016;

                    VirtualAddress =
                        VideoPortGetDeviceBase(HwDeviceExtension,
                                               ID_String,
                                               sizeof("IBM"),
                                               FALSE);

                    HwDeviceExtension->IsIBM = FALSE;

                    if (VirtualAddress != NULL)
                    {
                        //
                        // check to see if the string IBM is at the location
                        // we are examining.
                        //
                        // NOTE: sizeof("IBM") = 4, but we only want to look
                        // at the first 3 characters. (There won't be a NULL
                        // terminator.)
                        //

                        if (VideoPortCompareMemory(VirtualAddress,
                                                   "IBM",
                                                   sizeof("IBM")-1) ==
                                                   sizeof("IBM")-1)
                        {
                            VP_STATUS status;

                            HwDeviceExtension->IsIBM = TRUE;

                            VideoDebugPrint((1, "Machine Type detected as IBM\n"));

                            //
                            // If this is an IBM machine, we need to verify another
                            // access range so that we can use IBMs System
                            // Management API.
                            //

                            status = VideoPortVerifyAccessRanges(HwDeviceExtension,
                                                                 NUM_IBM_ACCESS_RANGES,
                                                                 VgaAccessRange);

                            if (status != NO_ERROR)
                            {
                                //
                                // We can't load if we don't get this access range.
                                //

                                VideoDebugPrint((1, "Couldn't reserve additional access "
                                                    "range required by IBM Thinkpad.\n"));

                                goto NOT_WDVGA;
                            }

                        }

                        //
                        // Free the memory we got...
                        //

                        VideoPortFreeDeviceBase(HwDeviceExtension,
                                                VirtualAddress);
                    }
                }

                //
                // get the panel type
                //

                GetPanelType(HwDeviceExtension);

            }
            else
            {
                //
                // we aren't a VGA, so lets release our
                // our claim on the the panel detection registers.
                //

                VideoPortVerifyAccessRanges(HwDeviceExtension,
                                            NUM_WD_ACCESS_RANGES,
                                            VgaAccessRange);

                HwDeviceExtension->ExtendedRegisters = EXTENDED_REGISTERS;

            }

        }
        else
        {
            //
            // Release the extended registers since they don't
            // exist on this chip.
            //

            VideoPortVerifyAccessRanges(HwDeviceExtension,
                                        NUM_VGA_ACCESS_RANGES,
                                        VgaAccessRange);

            HwDeviceExtension->ExtendedRegisters = NO_EXTENDED_REGISTERS;
        }

        VideoPortWritePortUchar(ExtendedIOAddress, save);

        VideoPortFreeDeviceBase(HwDeviceExtension,
                                ExtendedIOAddress);

    }

    //
    // If it is a WD, always unlock the extended sequencer register, since
    // in some cases the cirrus will cause them to get locked.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                            0x06);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
                            0x48);

    //
    // Get chip type to determine if we have a 90c30 or 90c00
    //

    if (HwDeviceExtension->BoardID < WD90C31) {

        UCHAR SeqSave08;

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, 0x08);
        SeqSave08 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, 0x5A);
        temp1 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT);

        if ( temp1 != 0x5A ) {

            //
            // old chip, can't support 1R1W banking
            //

            HwDeviceExtension->BoardID = WD90C00;
            pwszChipString = L"WD 90C00 / 90C10";
            cbChipString = sizeof(L"WD 90C00 / 90C10");
        }

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, 0x08);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, SeqSave08);

    }

    //
    // Detect a Speestart 90c31 board.
    //
    // Map in the ROM address space at 0xc000:0
    //

    pRomAddr = VideoPortGetDeviceBase(HwDeviceExtension,
                                      paRom,
                                      (ULONG)0x00008000,
                                      FALSE);

    if (pRomAddr) {       // Valid ROM address?

        PWSTR pwszDeviceString;
        ULONG cbDeviceString;

        //
        // Look for brand name signatures (from DIAMOND) in the ROM.
        //

        //
        // We will try to recognize a few boards.
        // make sure we are looking at a bios!
        //

        pwszDeviceString = L"Western Digital";
        cbDeviceString = sizeof(L"Western Digital");

        if (*((PUSHORT) pRomAddr) == 0xAA55) {

            if (VideoPortScanRom(HwDeviceExtension,
                                 pRomAddr,
                                 MAX_ROM_SCAN,
                                 "  SpeedStar 24X")) {

                pwszDeviceString = L"Diamond Speedstar 24X";
                cbDeviceString = sizeof(L"Diamond Speedstar 24X");

                if (HwDeviceExtension->BoardID == WD90C31) {

                    HwDeviceExtension->BoardID = SPEEDSTAR31;

                } else if (HwDeviceExtension->BoardID == WD90C30) {

                    HwDeviceExtension->BoardID = SPEEDSTAR30;

                }
            }
        }

        VideoPortFreeDeviceBase(HwDeviceExtension,
                                pRomAddr);

        VideoPortSetRegistryParameters(HwDeviceExtension,
                                       L"HardwareInformation.AdapterString",
                                       pwszDeviceString,
                                       cbDeviceString);

    }

    //
    // Get the memory size.
    //

    VgaSizeMemory(HwDeviceExtension);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.ChipType",
                                   pwszChipString,
                                   cbChipString);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &HwDeviceExtension->AdapterMemorySize,
                                   sizeof(ULONG));

NOT_WDVGA:

    //
    // Restore registers to what they were.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, 0x0c);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, GraphSave0c);

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, 0x0f);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, GraphSave0f);

    return status;

} // end WdIsPresent()


VOID
VgaSizeMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine determines the amount of VideoMemory on the adapter.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/
{

    UCHAR data;

    if (HwDeviceExtension->BoardID == WD90C24A) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0x29);

        data = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                   CRTC_DATA_PORT_COLOR);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR,
            (UCHAR)((data & (UCHAR)0x077) | (UCHAR)0x080));
                                                // unlock PR11 3d4.2a

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0x2a);

        if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                 CRTC_DATA_PORT_COLOR) & 0x020) == 0x020)
        {

            HwDeviceExtension->AdapterMemorySize = 0x00080000;

        } else {

            HwDeviceExtension->AdapterMemorySize = 0x00100000;

        }

    } else {

        //
        // Use 3CF.B to determine memory size on other WD's
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, 0x0B);

        data = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT);

        switch ( data & 0xC0 ) {

        case 0x00:
        case 0x40:

            HwDeviceExtension->AdapterMemorySize = 0x00040000;
            break;

        case 0x80:

            HwDeviceExtension->AdapterMemorySize = 0x00080000;
            break;

        case 0xC0:

            HwDeviceExtension->AdapterMemorySize = 0x00100000;
            break;

        default:
            break;

        }
    }
} // end VgaSizeMemory();


VP_STATUS
VgaSetPaletteReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_PALETTE_DATA PaletteBuffer,
    ULONG PaletteBufferSize
    )

/*++

Routine Description:

    This routine sets a specified portion of the EGA (not DAC) palette
    registers.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    PaletteBuffer - Pointer to the structure containing the palette data.

    PaletteBufferSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid palette size.

--*/

{
    USHORT i;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ((PaletteBufferSize) < (sizeof(VIDEO_PALETTE_DATA)) ||
        (PaletteBufferSize < (sizeof(VIDEO_PALETTE_DATA) +
                (sizeof(USHORT) * (PaletteBuffer->NumEntries -1)) ))) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (PaletteBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER ) ||
         (PaletteBuffer->NumEntries == 0) ||
         (PaletteBuffer->FirstEntry + PaletteBuffer->NumEntries >
             VIDEO_MAX_PALETTE_REGISTER + 1 ) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Reset ATC to index mode
    //

    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                           ATT_INITIALIZE_PORT_COLOR);

    //
    // Blast out our palette values.
    //

    for (i = 0; i < PaletteBuffer->NumEntries; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ATT_ADDRESS_PORT,
                                (UCHAR)(i+PaletteBuffer->FirstEntry));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    ATT_DATA_WRITE_PORT,
                                (UCHAR)PaletteBuffer->Colors[i]);
    }

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ATT_ADDRESS_PORT,
                            VIDEO_ENABLE);


    return NO_ERROR;

} // end VgaSetPaletteReg()


VP_STATUS
VgaSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )

/*++

Routine Description:

    This routine sets a specified portion of the DAC color lookup table
    settings.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ClutBufferSize - Length of the input buffer supplied by the user.

    ClutBuffer - Pointer to the structure containing the color lookup table.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid clut size.

--*/

{
    ULONG i;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ( (ClutBufferSize < sizeof(VIDEO_CLUT) - sizeof(ULONG)) ||
         (ClutBufferSize < sizeof(VIDEO_CLUT) +
                     (sizeof(ULONG) * (ClutBuffer->NumEntries - 1)) ) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (ClutBuffer->NumEntries == 0) ||
         (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
         (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
                                     VIDEO_MAX_COLOR_REGISTER + 1) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Set CLUT registers directly on the hardware
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, (UCHAR) ClutBuffer->FirstEntry);

    for (i = 0; i < ClutBuffer->NumEntries; i++) {

        VideoPortWritePortBufferUchar((PUCHAR)HwDeviceExtension->IOAddress +
                                          DAC_DATA_REG_PORT,
                                      &(ClutBuffer->LookupTable[i].RgbArray.Red),
                                          0x03);

    }

    return NO_ERROR;

} // end VgaSetColorLookup()

VP_STATUS
VgaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    )

/*++

Routine Description:

    Restores all registers and memory of the VGA.

    Note: HardwareState points to the actual buffer from which the state
    is to be restored. This buffer will always be big enough (we specified
    the required size at DriverEntry).

    Note: The offset in the hardware state header from which each general
    register is restored is the offset of the write address of that register
    from the base I/O address of the VGA.


    !!! NOTE
    We assume the miniport and the display driver have UNLOCKED the extended
    registers so we can READ and WRITE them.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    HardwareState - Pointer to a structure from which the saved state is to be
        restored (actually only info about and a pointer to the actual save
        buffer).

    HardwareStateSize - Length of the input buffer supplied by the user.
        (Actually only the size of the HardwareState structure, not the
        buffer it points to from which the state is actually restored. The
        pointed-to buffer is assumed to be big enough.)

Return Value:

    NO_ERROR - restore performed successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough to provide data

--*/

{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    ULONG i;
    UCHAR dummy;
    PUCHAR pScreen;
    PUCHAR pucLatch;
    PULONG pulBuffer;
    PUCHAR port;
    PUCHAR portValue;
    PUCHAR portValueDAC;
    ULONG bIsColor;


    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ((HardwareStateSize < sizeof(VIDEO_HARDWARE_STATE)) ||
            (HardwareState->StateLength < VGA_TOTAL_STATE_SIZE)) {

            return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Point to the buffer where the restore data is actually stored.
    //

    hardwareStateHeader = HardwareState->StateHeader;

    //
    // Make sure the offset are in the structure ...
    //

    if ((hardwareStateHeader->BasicSequencerOffset + VGA_NUM_SEQUENCER_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicCrtContOffset + VGA_NUM_CRTC_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicGraphContOffset + VGA_NUM_GRAPH_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicAttribContOffset + VGA_NUM_ATTRIB_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicDacOffset + (3 * VGA_NUM_DAC_ENTRIES) >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicLatchesOffset + 4 >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedSequencerOffset + EXT_NUM_SEQUENCER_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedCrtContOffset + EXT_NUM_CRTC_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedGraphContOffset + EXT_NUM_GRAPH_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedAttribContOffset + EXT_NUM_ATTRIB_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedDacOffset + (4 * EXT_NUM_DAC_ENTRIES) >
            HardwareState->StateLength) ||

        //
        // Only check the validator state offset if there is unemulated data.
        //

        ((hardwareStateHeader->VGAStateFlags & VIDEO_STATE_UNEMULATED_VGA_STATE) &&
            (hardwareStateHeader->ExtendedValidatorStateOffset + VGA_VALIDATOR_AREA_SIZE >
            HardwareState->StateLength)) ||

        (hardwareStateHeader->ExtendedMiscDataOffset + VGA_MISC_DATA_AREA_OFFSET >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane1Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane2Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane3Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane4Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->DIBOffset +
            hardwareStateHeader->DIBBitsPerPixel / 8 *
            hardwareStateHeader->DIBXResolution *
            hardwareStateHeader->DIBYResolution  > HardwareState->StateLength) ||

        (hardwareStateHeader->DIBXlatOffset + hardwareStateHeader->DIBXlatLength >
            HardwareState->StateLength)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Set DAC register 0 to display black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);

    //
    // Set the DAC mask register to force DAC register 0 to display all the
    // time (this is the register we just set to display black). From now on,
    // nothing but black will show up on the screen.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT, 0);


    //
    // Restore the latches and the contents of display memory.
    //
    // Set up the VGA's hardware to allow us to copy to each plane in turn.
    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Turn off Chain mode and map display memory at A0000 for 64K.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MISC);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, (UCHAR) ((VideoPortReadPortUchar(
            HwDeviceExtension->IOAddress + GRAPH_DATA_PORT) & 0xF1) | 0x04));

    //
    // Turn off Chain4 mode and odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) & 0xF3) | 0x04));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (END_SYNC_RESET_VALUE << 8)));

    //
    // Set the write mode to 0, the read mode to 0, and turn off odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xE4) | 0x00));

    //
    // Set the Bit Mask to 0xFF to allow all CPU bits through.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_BIT_MASK + (0xFF << 8)));

    //
    // Set the Data Rotation and Logical Function fields to 0 to allow CPU
    // data through unmodified.
    //

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_DATA_ROTATE + (0 << 8)));

    //
    // Set Set/Reset Enable to 0 to select CPU data for all planes.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_SET_RESET_ENABLE + (0 << 8)));

    //
    // Point the Sequencer Index to the Map Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
             SEQ_ADDRESS_PORT, IND_MAP_MASK);

    //
    // Restore the latches.
    //
    // Point to the saved data for the first latch.
    //

    pucLatch = ((PUCHAR) (hardwareStateHeader)) +
            hardwareStateHeader->BasicLatchesOffset;

    //
    // Point to first byte of display memory.
    //

    pScreen = (PUCHAR) HwDeviceExtension->VideoMemoryAddress;

    //
    // Write the contents to be restored to each of the four latches in turn.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Map Mask to select the plane we want to restore next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, (UCHAR)(1<<i));

        //
        // Write this plane's latch.
        //

        VideoPortWriteRegisterUchar(pScreen, *pucLatch++);

    }

    //
    // Read the latched data into the latches, and the latches are set.
    //

    dummy = VideoPortReadRegisterUchar(pScreen);


    //
    // Point to the offset of the saved data for the first plane.
    //

    pulBuffer = &(hardwareStateHeader->Plane1Offset);

    //
    // Restore each of the four planes in turn.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Map Mask to select the plane we want to restore next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, (UCHAR)(1<<i));

        //
        // Restore this plane from the buffer.
        //

        VideoPortMoveMemory((PUCHAR) HwDeviceExtension->VideoMemoryAddress,
                           ((PUCHAR) (hardwareStateHeader)) + *pulBuffer,
                           hardwareStateHeader->PlaneLength);

        pulBuffer++;

    }

    //
    // If we have some unemulated data, put it back into the buffer
    //

    if (hardwareStateHeader->VGAStateFlags & VIDEO_STATE_UNEMULATED_VGA_STATE) {

        if (!hardwareStateHeader->ExtendedValidatorStateOffset) {

            return ERROR_INVALID_PARAMETER;

        }

        //
        // Get the right offset in the struct and save all the data associated
        // with the trapped validator data.
        //

        VideoPortMoveMemory(&(HwDeviceExtension->TrappedValidatorCount),
                            ((PUCHAR) (hardwareStateHeader)) +
                                hardwareStateHeader->ExtendedValidatorStateOffset,
                            VGA_VALIDATOR_AREA_SIZE);

        //
        // Check to see if this is an appropriate access range.
        // We are trapping - so we must have the trapping access range enabled.
        //

        if (((HwDeviceExtension->CurrentVdmAccessRange != FullVgaValidatorAccessRange) ||
             (HwDeviceExtension->CurrentNumVdmAccessRanges != NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE)) &&
            ((HwDeviceExtension->CurrentVdmAccessRange != MinimalVgaValidatorAccessRange) ||
             (HwDeviceExtension->CurrentNumVdmAccessRanges != NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE))) {

            return ERROR_INVALID_PARAMETER;

        }

        VideoPortSetTrappedEmulatorPorts(HwDeviceExtension,
                                         HwDeviceExtension->CurrentNumVdmAccessRanges,
                                         HwDeviceExtension->CurrentVdmAccessRange);

    }

    //
    // Set the critical registers (clock and timing states) during sync reset.
    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (START_SYNC_RESET_VALUE << 8)));

    //
    // Restore the Miscellaneous Output register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            MISC_OUTPUT_REG_WRITE_PORT,
            (UCHAR) (hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT] & 0xF7));

    //
    // Restore all Sequencer registers except the Sync Reset register, which
    // is always not in reset (except when we send out a batched sync reset
    // register set, but that can't be interrupted, so we know we're never in
    // sync reset at save/restore time).
    //

    portValue = ((PUCHAR) hardwareStateHeader) +
            hardwareStateHeader->BasicSequencerOffset + 1;

    for (i = 1; i < VGA_NUM_SEQUENCER_PORTS; i++) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT), (USHORT) (i + ((*portValue++) << 8)) );

    }

    //
    // Restore extended sequencer registers
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    if (hardwareStateHeader->ExtendedSequencerOffset) {

        portValue = ((PUCHAR) hardwareStateHeader) +
                          hardwareStateHeader->ExtendedSequencerOffset;

        for (i = WD_SEQUENCER_EXT_START; i <= WD_SEQUENCER_EXT_END; i++) {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                         SEQ_ADDRESS_PORT),
                                     (USHORT) (i + ((*portValue++) << 8)) );

        }

        //
        // Restore the second set of sequencer registers.
        //

        for (i = WD_SEQUENCER_1_EXT_START; i <= WD_SEQUENCER_1_EXT_END; i++) {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                         SEQ_ADDRESS_PORT),
                                     (USHORT) (i + ((*portValue++) << 8)) );

        }
    }

#endif

    //
    // Restore the Graphics Controller Miscellaneous register, which contains
    // the Chain bit.
    //

    portValue = ((PUCHAR) hardwareStateHeader) +
                hardwareStateHeader->BasicGraphContOffset + IND_GRAPH_MISC;

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT)(IND_GRAPH_MISC + (*portValue << 8)));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (END_SYNC_RESET_VALUE << 8)));

    //
    // Figure out if color/mono switchable registers are at 3BX or 3DX.
    // At the same time, save the state of the Miscellaneous Output register
    // which is read from 3CC but written at 3C2.
    //

    if (hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT] & 0x01) {
        bIsColor = TRUE;
    } else {
        bIsColor = FALSE;
    }


    //
    // Restore the CRT Controller indexed registers.
    //
    // Unlock CRTC registers 0-7.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicCrtContOffset;

    if (bIsColor) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR), (USHORT) (IND_CRTC_PROTECT +
                (((*(portValue + IND_CRTC_PROTECT)) & 0x7F) << 8)));

    } else {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO), (USHORT) (IND_CRTC_PROTECT +
                (((*(portValue + IND_CRTC_PROTECT)) & 0x7F) << 8)));

    }



    //
    // Restore extended crtc registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    if (hardwareStateHeader->ExtendedCrtContOffset) {

        portValue = (PUCHAR) hardwareStateHeader +
                         hardwareStateHeader->ExtendedCrtContOffset;

        for (i = WD_CRTC_EXT_START; i <= WD_CRTC_EXT_END; i++) {

            if (bIsColor) {

                VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                             CRTC_ADDRESS_PORT_COLOR),
                                         (USHORT) (i + ((*portValue++) << 8)));

            } else {

                VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                             CRTC_ADDRESS_PORT_MONO),
                                         (USHORT) (i + ((*portValue++) << 8)));

            }
        }

        //
        // Second set of crtc registers
        //

        for (i = WD_CRTC_1_EXT_START; i <= WD_CRTC_1_EXT_END; i++) {

            if (bIsColor) {

                VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                             CRTC_ADDRESS_PORT_COLOR),
                                         (USHORT) (i + ((*portValue++) << 8)));

            } else {

                VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                             CRTC_ADDRESS_PORT_MONO),
                                         (USHORT) (i + ((*portValue++) << 8)));

            }
        }
    }

#endif

    //
    // Now restore the CRTC registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicCrtContOffset;

    for (i = 0; i < VGA_NUM_CRTC_PORTS; i++) {

        if (bIsColor) {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_COLOR),
                    (USHORT) (i + ((*portValue++) << 8)));

        } else {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_MONO),
                    (USHORT) (i + ((*portValue++) << 8)));

        }

    }


    //
    // Restore the Graphics Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicGraphContOffset;

    for (i = 0; i < VGA_NUM_GRAPH_CONT_PORTS; i++) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT), (USHORT) (i + ((*portValue++) << 8)));

    }


    //
    // Restore extended graphics controller registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    //
    // The extended lock register (index 0x0F) will be restored last, so we do
    // not need to do anything special with it.
    //

    if (hardwareStateHeader->ExtendedGraphContOffset) {

        portValue = (PUCHAR) hardwareStateHeader +
                             hardwareStateHeader->ExtendedGraphContOffset;

        for (i = WD_GRAPH_EXT_START; i <= WD_GRAPH_EXT_END; i++) {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                         GRAPH_ADDRESS_PORT),
                                     (USHORT) (i + ((*portValue++) << 8)));

        }
    }

#endif

    //
    // Restore the Attribute Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicAttribContOffset;

    //
    // Reset the AC index/data toggle, then blast out all the register
    // settings.
    //

    if (bIsColor) {
        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                INPUT_STATUS_1_COLOR);
    } else {
        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                INPUT_STATUS_1_MONO);
    }

    for (i = 0; i < VGA_NUM_ATTRIB_CONT_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (UCHAR)i);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_WRITE_PORT, *portValue++);

    }


    //
    // Restore DAC registers 1 through 255. We'll do register 0, the DAC Mask,
    // and the index registers later.
    // Set the DAC address port Index, then write out the DAC Data registers.
    // Each three reads get Red, Green, and Blue components for that register.
    //
    // Write them one at a time due to problems on local bus machines.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader +
                   hardwareStateHeader->BasicDacOffset + 3;

    for (i = 1; i < VGA_NUM_DAC_ENTRIES; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_ADDRESS_WRITE_PORT, (UCHAR)i);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

    }

    //
    // Extended registers are not CURRENTLY supported in this driver.
    //


    //
    // Restore the Feature Control register.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                FEAT_CTRL_WRITE_PORT_COLOR,
                hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_COLOR]);

    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                FEAT_CTRL_WRITE_PORT_MONO,
                hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_MONO]);

    }


    //
    // Restore the Sequencer Index.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT,
            hardwareStateHeader->PortValue[SEQ_ADDRESS_PORT]);

    //
    // Restore the CRT Controller Index.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR,
                hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_COLOR]);

    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO,
                hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_MONO]);

    }


    //
    // Restore the Graphics Controller Index.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT,
            hardwareStateHeader->PortValue[GRAPH_ADDRESS_PORT]);


    //
    // Restore the Attribute Controller Index and index/data toggle state.
    //

    if (bIsColor) {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR;
    } else {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_MONO;
    }

    VideoPortReadPortUchar(port);  // reset the toggle to Index state

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            ATT_ADDRESS_PORT,  // restore the AC Index
            hardwareStateHeader->PortValue[ATT_ADDRESS_PORT]);

    //
    // If the toggle should be in Data state, we're all set. If it should be in
    // Index state, reset it to that condition.
    //

    if (hardwareStateHeader->AttribIndexDataState == 0) {

        //
        // Reset the toggle to Index state.
        //

        VideoPortReadPortUchar(port);

    }


    //
    // Restore DAC register 0 and the DAC Mask, to unblank the screen.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicDacOffset;

    //
    // Restore the DAC Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT,
            hardwareStateHeader->PortValue[DAC_PIXEL_MASK_PORT]);

    //
    // Restore DAC register 0.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);


    //
    // Restore the read/write state and the current index of the DAC.
    //
    // See whether the Read or Write Index was written to most recently.
    // (The upper nibble stored at DAC_STATE_PORT is the # of reads/writes
    // for the current index.)
    //

    if ((hardwareStateHeader->PortValue[DAC_STATE_PORT] & 0x0F) == 3) {

        //
        // The DAC Read Index was written to last. Restore the DAC by setting
        // up to read from the saved index - 1, because the way the Read
        // Index works is that it autoincrements after reading, so you actually
        // end up reading the data for the index you read at the DAC Write
        // Mask register - 1.
        //
        // Set the Read Index to the index we read, minus 1, accounting for
        // wrap from 255 back to 0. The DAC hardware immediately reads this
        // register into a temporary buffer, then adds 1 to the index.
        //

        if (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT] == 0) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_READ_PORT, 255);

        } else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_READ_PORT, (UCHAR)
                    (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT] -
                    1));

        }

        //
        // Now read the hardware however many times are required to get to
        // the partial read state we saved.
        //

        for (i = hardwareStateHeader->PortValue[DAC_STATE_PORT] >> 4;
                i > 0; i--) {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT);

        }

    } else {

        //
        // The DAC Write Index was written to last. Set the Write Index to the
        // index value we read out of the DAC. Then, if a partial write
        // (partway through an RGB triplet) was in place, write the partial
        // values, which we obtained by writing them to the current DAC
        // register. This DAC register will be wrong until the write is
        // completed, but at least the values will be right once the write is
        // finished, and most importantly we won't have messed up the sequence
        // of RGB writes (which can be as long as 768 in a row).
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_ADDRESS_WRITE_PORT,
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]);

        //
        // Now write to the hardware however many times are required to get to
        // the partial write state we saved (if any).
        //
        // Point to the saved value for the DAC register that was in the
        // process of being written to; we wrote the partial value out, so now
        // we can restore it.
        //

        portValueDAC = (PUCHAR) hardwareStateHeader +
                hardwareStateHeader->BasicDacOffset +
                (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT] * 3);

        for (i = hardwareStateHeader->PortValue[DAC_STATE_PORT] >> 4;
                i > 0; i--) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT, *portValueDAC++);

        }

    }

    return NO_ERROR;

} // end VgaRestoreHardwareState()

VP_STATUS
VgaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    Saves all registers and memory of the VGA.

    Note: HardwareState points to the actual buffer in which the state
    is saved. This buffer will always be big enough (we specified
    the required size at DriverEntry).

    Note: This routine leaves registers in any state it cares to, except
    that it will not mess with any of the CRT or Sequencer parameters that
    might make the monitor unhappy. It leaves the screen blanked by setting
    the DAC Mask and DAC register 0 to all zero values. The next video
    operation we expect after this is a mode set to take us back to Win32.

    Note: The offset in the hardware state header in which each general
    register is saved is the offset of the write address of that register from
    the base I/O address of the VGA.

    !!! NOTE
    We must force the extended registers to be unlocked.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    HardwareState - Pointer to a structure in which the saved state will be
        returned (actually only info about and a pointer to the actual save
        buffer).

    HardwareStateSize - Length of the output buffer supplied by the user.
        (Actually only the size of the HardwareState structure, not the
        buffer it points to where the state is actually saved. The pointed-
        to buffer is assumed to be big enough.)

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data returned in the buffer.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

--*/

{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    PUCHAR pScreen;
    PUCHAR portValue;
    PUCHAR portValueDAC;
    PUCHAR bufferPointer;
    ULONG i;
    UCHAR dummy, originalACIndex, originalACData;
    UCHAR ucCRTC03;
    ULONG bIsColor;


    //
    // See if the buffer is big enough to hold the hardware state structure.
    // (This is only the HardwareState structure itself, not the buffer it
    // points to.)
    //

    if (HardwareStateSize < sizeof(VIDEO_HARDWARE_STATE) ) {

        *OutputSize = 0;  // nothing returned
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Amount of data we're going to return in the output buffer.
    // (The VIDEO_HARDWARE_STATE in the output buffer points to the actual
    // buffer in which the state is stored, which is assumed to be large
    // enough.)
    //

    *OutputSize = sizeof(VIDEO_HARDWARE_STATE);

    //
    // Indicate the size of the full state save info.
    //

    HardwareState->StateLength = VGA_TOTAL_STATE_SIZE;

    //
    // hardwareStateHeader is a structure of offsets at the start of the
    // actual save area that indicates the locations in which various VGA
    // register and memory components are saved.
    //

    hardwareStateHeader = HardwareState->StateHeader;

    //
    // Zero out the structure.
    //

    VideoPortZeroMemory(hardwareStateHeader, sizeof(VIDEO_HARDWARE_STATE_HEADER));

    //
    // Set the Length field, which is basically a version ID.
    //

    hardwareStateHeader->Length = sizeof(VIDEO_HARDWARE_STATE_HEADER);

    //
    // Set the basic register offsets properly.
    //

    hardwareStateHeader->BasicSequencerOffset = VGA_BASIC_SEQUENCER_OFFSET;
    hardwareStateHeader->BasicCrtContOffset = VGA_BASIC_CRTC_OFFSET;
    hardwareStateHeader->BasicGraphContOffset = VGA_BASIC_GRAPH_CONT_OFFSET;
    hardwareStateHeader->BasicAttribContOffset = VGA_BASIC_ATTRIB_CONT_OFFSET;
    hardwareStateHeader->BasicDacOffset = VGA_BASIC_DAC_OFFSET;
    hardwareStateHeader->BasicLatchesOffset = VGA_BASIC_LATCHES_OFFSET;

    //
    // Set the entended register offsets properly.
    //

    hardwareStateHeader->ExtendedSequencerOffset = VGA_EXT_SEQUENCER_OFFSET;
    hardwareStateHeader->ExtendedCrtContOffset = VGA_EXT_CRTC_OFFSET;
    hardwareStateHeader->ExtendedGraphContOffset = VGA_EXT_GRAPH_CONT_OFFSET;
    hardwareStateHeader->ExtendedAttribContOffset = VGA_EXT_ATTRIB_CONT_OFFSET;
    hardwareStateHeader->ExtendedDacOffset = VGA_EXT_DAC_OFFSET;

    //
    // Figure out if color/mono switchable registers are at 3BX or 3DX.
    // At the same time, save the state of the Miscellaneous Output register
    // which is read from 3CC but written at 3C2.
    //

    if ((hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    MISC_OUTPUT_REG_READ_PORT))
            & 0x01) {
        bIsColor = TRUE;
    } else {
        bIsColor = FALSE;
    }

    //
    // Force the video subsystem enable state to enabled.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            VIDEO_SUBSYSTEM_ENABLE_PORT, 1);

    //
    // Save the DAC state first, so we can set the DAC to blank the screen
    // so nothing after this shows up at all.
    //
    // Save the DAC Mask register.
    //

    hardwareStateHeader->PortValue[DAC_PIXEL_MASK_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_PIXEL_MASK_PORT);

    //
    // Save the DAC Index register. Note that there is actually only one DAC
    // Index register, which functions as either the Read Index or the Write
    // Index as needed.
    //

    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT);

    //
    // Save the DAC read/write state. We determine if the DAC has been written
    // to or read from at the current index 0, 1, or 2 times (the application
    // is in the middle of reading or writing a DAC register triplet if the
    // count is 1 or 2), and save enough info so we can restore things
    // properly. The only hole is if the application writes to the Write Index,
    // then reads from instead of writes to the Data register, or vice-versa,
    // or if they do a partial read write, then never finish it.
    // This is fairly ridiculous behavior, however, and anyway there's nothing
    // we can do about it.
    //

    hardwareStateHeader->PortValue[DAC_STATE_PORT] =
             VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_STATE_PORT);

    if (hardwareStateHeader->PortValue[DAC_STATE_PORT] == 3) {

        //
        // The DAC Read Index was written to last. Figure out how many reads
        // have been done from the current index. We'll restart this on restore
        // by setting the Read Index to the current index - 1 (the read index
        // is one greater than the index being read), then doing the proper
        // number of reads.
        //
        // Read the Data register once, and see if the index changes.
        //

        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                DAC_DATA_REG_PORT);

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT) !=
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]) {

            //
            // The DAC Index changed, so two reads had already been done from
            // the current index. Store the count "2" in the upper nibble of
            // the read/write state field.
            //

            hardwareStateHeader->PortValue[DAC_STATE_PORT] |= 0x20;

        } else {

            //
            // Read the Data register again, and see if the index changes.
            //

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT);

            if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        DAC_ADDRESS_WRITE_PORT) !=
                    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]) {

                //
                // The DAC Index changed, so one read had already been done
                // from the current index. Store the count "1" in the upper
                // nibble of the read/write state field.
                //

                hardwareStateHeader->PortValue[DAC_STATE_PORT] |= 0x10;
            }

            //
            // If neither 2 nor 1 reads had been done from the current index,
            // then 0 reads were done, and we're all set, since the upper
            // nibble of the read/write state field is already 0.
            //

        }

    } else {

        //
        // The DAC Write Index was written to last. Figure out how many writes
        // have been done to the current index. We'll restart this on restore
        // by setting the Write Index to the proper index, then doing the
        // proper number of writes. When we do the DAC register save, we'll
        // read out the value that gets written (if there was a partial write
        // in progress), so we can restore the proper data later. This will
        // cause this current DAC location to be briefly wrong in the 1- and
        // 2-bytes-written case (until the app finishes the write), but that's
        // better than having the wrong DAC values written for good.
        //
        // Write the Data register once, and see if the index changes.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_DATA_REG_PORT, 0);

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT) !=
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]) {

            //
            // The DAC Index changed, so two writes had already been done to
            // the current index. Store the count "2" in the upper nibble of
            // the read/write state field.
            //

            hardwareStateHeader->PortValue[DAC_STATE_PORT] |= 0x20;

        } else {

            //
            // Write the Data register again, and see if the index changes.
            //

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT, 0);

            if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        DAC_ADDRESS_WRITE_PORT) !=
                    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]) {

                //
                // The DAC Index changed, so one write had already been done
                // to the current index. Store the count "1" in the upper
                // nibble of the read/write state field.
                //

                hardwareStateHeader->PortValue[DAC_STATE_PORT] |= 0x10;
            }

            //
            // If neither 2 nor 1 writes had been done to the current index,
            // then 0 writes were done, and we're all set.
            //

        }

    }


    //
    // Now, read out the 256 18-bit DAC palette registers (256 RGB triplets),
    // and blank the screen.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader + VGA_BASIC_DAC_OFFSET;

    //
    // Read out DAC register 0, so we can set it to black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_ADDRESS_READ_PORT, 0);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);

    //
    // Set DAC register 0 to display black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);

    //
    // Set the DAC mask register to force DAC register 0 to display all the
    // time (this is the register we just set to display black). From now on,
    // nothing but black will show up on the screen.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT, 0);

    //
    // Wait until we've gotten the Attribute Controller toggle state to save
    // the rest of the DAC registers, so we can wait for vertical sync.
    //


    //
    // Read out the Attribute Controller Index state, and deduce the Index/Data
    // toggle state at the same time.
    //
    // Save the state of the Attribute Controller, both Index and Data,
    // so we can test in which state the toggle currently is.
    //

    originalACIndex = hardwareStateHeader->PortValue[ATT_ADDRESS_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    ATT_ADDRESS_PORT);
    originalACData = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            ATT_DATA_READ_PORT);

    //
    // Sequencer Index.
    //

    hardwareStateHeader->PortValue[SEQ_ADDRESS_PORT] =
             VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                     SEQ_ADDRESS_PORT);

    //
    // Begin sync reset, just in case this is an SVGA and the currently
    // indexed Attribute Controller register controls clocking stuff (a
    // normal VGA won't require this).
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Now, write a different Index setting to the Attribute Controller, and
    // see if the Index changes.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            ATT_ADDRESS_PORT, (UCHAR) (originalACIndex ^ 0x10));

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT) == originalACIndex) {

        //
        // The Index didn't change, so the toggle was in the Data state.
        //

        hardwareStateHeader->AttribIndexDataState = 1;

        //
        // Restore the original Data state; we just corrupted it, and we need
        // to read it out later; also, it may glitch the screen if not
        // corrected. The toggle is already in the Index state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, originalACIndex);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_WRITE_PORT, originalACData);

    } else {

        //
        // The Index did change, so the toggle was in the Index state.
        // No need to restore anything, because the Data register didn't
        // change, and we've already read out the Index register.
        //

        hardwareStateHeader->AttribIndexDataState = 0;

    }

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));



    //
    // Save the rest of the DAC registers.
    // Set the DAC address port Index, then read out the DAC Data registers.
    // Each three reads get Red, Green, and Blue components for that register.
    //
    // Read them one at a time due to problems on local bus machines.
    //

    for (i = 1; i < VGA_NUM_DAC_ENTRIES; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_ADDRESS_READ_PORT, (UCHAR)i);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

    }

    //
    // The Feature Control register is read from 3CA but written at 3BA/3DA.
    //

    if (bIsColor) {

        hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_COLOR] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        FEAT_CTRL_READ_PORT);

    } else {

        hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_MONO] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        FEAT_CTRL_READ_PORT);

    }



    //
    // CRT Controller Index.
    //

    if (bIsColor) {

        hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_COLOR] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_ADDRESS_PORT_COLOR);

    } else {

        hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_MONO] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_ADDRESS_PORT_MONO);

    }


    //
    // Graphics Controller Index.
    //

    hardwareStateHeader->PortValue[GRAPH_ADDRESS_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_ADDRESS_PORT);


    //
    // Graphics Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_GRAPH_CONT_OFFSET;

    for (i = 0; i < VGA_NUM_GRAPH_CONT_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT);

    }

    //
    // Save extended graphics controller registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    //
    // Read the lock register (index 0x0F) value and save that.
    //

    *(((PUCHAR) hardwareStateHeader) + VGA_EXT_GRAPH_CONT_OFFSET +
    (WD_GRAPH_EXT_END - WD_GRAPH_EXT_START)) =
	VideoPortReadPortUchar(HwDeviceExtension->IOAddress + 0x0F);

    //
    // Unlock all extended registers so they can be read or written.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + 0x0F, 0x05);

    portValue = (PUCHAR) hardwareStateHeader + VGA_EXT_GRAPH_CONT_OFFSET;

    for (i = WD_GRAPH_EXT_START; i <= WD_GRAPH_EXT_END -1; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                GRAPH_ADDRESS_PORT, (UCHAR)i);

        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                              GRAPH_DATA_PORT);

    }

#endif

    //
    // Sequencer indexed registers.
    //

    portValue = ((PUCHAR) hardwareStateHeader) + VGA_BASIC_SEQUENCER_OFFSET;

    for (i = 0; i < VGA_NUM_SEQUENCER_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT);

    }


    //
    // Save extended sequencer registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    portValue = ((PUCHAR) hardwareStateHeader) + VGA_EXT_SEQUENCER_OFFSET;

    for (i = WD_SEQUENCER_EXT_START; i <= WD_SEQUENCER_EXT_END; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, (UCHAR)i);

        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                              SEQ_DATA_PORT);

    }

    //
    // Second set of sequencer registers
    //

    for (i = WD_SEQUENCER_1_EXT_START; i <= WD_SEQUENCER_1_EXT_END; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, (UCHAR)i);

        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                              SEQ_DATA_PORT);

    }

#endif

    //
    // CRT Controller indexed registers.
    //

    //
    // Remember the state of CRTC register 3, then force bit 7
    // to 1 so we will read back the Vertical Retrace start and
    // end registers rather than the light pen info.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR, 3);
        ucCRTC03 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_DATA_PORT_COLOR);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_DATA_PORT_COLOR, (UCHAR) (ucCRTC03 | 0x80));
    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO, 3);
        ucCRTC03 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_DATA_PORT_MONO);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_DATA_PORT_MONO, (UCHAR) (ucCRTC03 | 0x80));
    }

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_CRTC_OFFSET;

    for (i = 0; i < VGA_NUM_CRTC_PORTS; i++) {

        if (bIsColor) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_COLOR, (UCHAR)i);
            *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            CRTC_DATA_PORT_COLOR);
        } else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_MONO, (UCHAR)i);
            *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            CRTC_DATA_PORT_MONO);
        }

    }

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_CRTC_OFFSET;
    portValue[3] = ucCRTC03;


    //
    // Save extended crtc registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    portValue = (PUCHAR) hardwareStateHeader + VGA_EXT_CRTC_OFFSET;

    for (i = WD_CRTC_EXT_START; i <= WD_CRTC_EXT_END; i++) {

        if (bIsColor) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    CRTC_ADDRESS_PORT_COLOR, (UCHAR)i);

            *portValue++ =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                       CRTC_DATA_PORT_COLOR);

        } else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    CRTC_ADDRESS_PORT_MONO, (UCHAR)i);

            *portValue++ =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                       CRTC_DATA_PORT_MONO);
        }
    }

    //
    // Save second set of crtc registers.
    //

    for (i = WD_CRTC_1_EXT_START; i <= WD_CRTC_1_EXT_END; i++) {

        if (bIsColor) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    CRTC_ADDRESS_PORT_COLOR, (UCHAR)i);

            *portValue++ =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                       CRTC_DATA_PORT_COLOR);

        } else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    CRTC_ADDRESS_PORT_MONO, (UCHAR)i);

            *portValue++ =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                       CRTC_DATA_PORT_MONO);
        }
    }

#endif

    //
    // Attribute Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_ATTRIB_CONT_OFFSET;

    //
    // For each indexed AC register, reset the flip-flop for reading the
    // attribute register, then write the desired index to the AC Index,
    // then read the value of the indexed register from the AC Data register.
    //

    for (i = 0; i < VGA_NUM_ATTRIB_CONT_PORTS; i++) {

        if (bIsColor) {
            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_COLOR);
        } else {
            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_MONO);
        }

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_READ_PORT);

    }

    //
    // Save the latches. This destroys one byte of display memory in each
    // plane, which is unfortunate but unavoidable. Chips that provide
    // a way to read back the latches can avoid this problem.
    //
    // Set up the VGA's hardware so we can write the latches, then read them
    // back.
    //

    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Set the Miscellaneous register to make sure we can access video RAM.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            MISC_OUTPUT_REG_WRITE_PORT, (UCHAR)(
            hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT] |
            0x02));

    //
    // Turn off Chain mode and map display memory at A0000 for 64K.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MISC);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xF1) | 0x04));

    //
    // Turn off Chain4 mode and odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) & 0xF3) | 0x04));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

    //
    // Set the Map Mask to write to all planes.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_MAP_MASK + (0x0F << 8)));

    //
    // Set the write mode to 0, the read mode to 0, and turn off odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xE4) | 0x01));

    //
    // Point to the last byte of display memory.
    //

    pScreen = (PUCHAR) HwDeviceExtension->VideoMemoryAddress +
            VGA_PLANE_SIZE - 1;

    //
    // Write the latches to the last byte of display memory.
    //

    VideoPortWriteRegisterUchar(pScreen, 0);

    //
    // Cycle through the four planes, reading the latch data from each plane.
    //

    //
    // Point the Graphics Controller Index to the Read Map register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_LATCHES_OFFSET;

    for (i=0; i<4; i++) {

        //
        // Set the Read Map for the current plane.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, (UCHAR)i);

        //
        // Read the latched data we've written to memory.
        //

        *portValue++ = VideoPortReadRegisterUchar(pScreen);

    }

    //
    // Set the VDM flags
    // We are a standard VGA, and then check if we have unemulated state.
    //

    hardwareStateHeader->VGAStateFlags = 0;

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    hardwareStateHeader->VGAStateFlags |= VIDEO_STATE_NON_STANDARD_VGA;

#endif

    if (HwDeviceExtension->TrappedValidatorCount) {

        hardwareStateHeader->VGAStateFlags |= VIDEO_STATE_UNEMULATED_VGA_STATE;

        //
        // Save the VDM Emulator data
        // No need to save the state of the seuencer port register for our
        // emulated data since it may change when we come back. It will be
        // recomputed.
        //

        hardwareStateHeader->ExtendedValidatorStateOffset = VGA_VALIDATOR_OFFSET;

        VideoPortMoveMemory(((PUCHAR) (hardwareStateHeader)) +
                                hardwareStateHeader->ExtendedValidatorStateOffset,
                            &(HwDeviceExtension->TrappedValidatorCount),
                            VGA_VALIDATOR_AREA_SIZE);

    } else {

        hardwareStateHeader->ExtendedValidatorStateOffset = 0;

    }

    //
    // Set the size of each plane.
    //

    hardwareStateHeader->PlaneLength = VGA_PLANE_SIZE;

    //
    // Store all the offsets for the planes in the structure.
    //

    hardwareStateHeader->Plane1Offset = VGA_PLANE_0_OFFSET;
    hardwareStateHeader->Plane2Offset = VGA_PLANE_1_OFFSET;
    hardwareStateHeader->Plane3Offset = VGA_PLANE_2_OFFSET;
    hardwareStateHeader->Plane4Offset = VGA_PLANE_3_OFFSET;

    //
    // Now copy the contents of video VRAM into the buffer.
    //
    // The VGA hardware is already set up so that video memory is readable;
    // we already turned off Chain mode, mapped in at A0000, turned off Chain4,
    // turned off odd/even, and set read mode 0 when we saved the latches.
    //
    // Point the Graphics Controller Index to the Read Map register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    //
    // Point to the save area for the first plane.
    //

    bufferPointer = ((PUCHAR) (hardwareStateHeader)) +
                     hardwareStateHeader->Plane1Offset;

    //
    // Save the four planes consecutively.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Read Map to select the plane we want to save next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, (UCHAR)i);

        //
        // Copy this plane into the buffer.
        //

        VideoPortMoveMemory(bufferPointer,
                           (PUCHAR) HwDeviceExtension->VideoMemoryAddress,
                           VGA_PLANE_SIZE);
        //
        // Point to the next plane's save area.
        //

        bufferPointer += VGA_PLANE_SIZE;
    }

    return NO_ERROR;

} // end VgaSaveHardwareState()

VP_STATUS
VgaGetBankSelectCode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_BANK_SELECT BankSelect,
    ULONG BankSelectSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    Returns information needed in order for caller to implement bank
         management.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BankSelect - Pointer to a VIDEO_BANK_SELECT structure in which the bank
             select data will be returned (output buffer).

    BankSelectSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a variable in which to return the actual size of
        the data returned in the output buffer.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_MORE_DATA - output buffer not large enough to hold all info (but
        Size is returned, so caller can tell how large a buffer to allocate)

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode selection

--*/

{
    ULONG codeSize;
    PUCHAR pCodeDest;
    PUCHAR pCodeBank;

    PVIDEOMODE pMode = HwDeviceExtension->CurrentMode;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // The minimum passed buffer size is a VIDEO_BANK_SELECT
    // structure, so that we can return the required size; we can't do
    // anything if we don't have at least that much buffer.
    //

    if (BankSelectSize < sizeof(VIDEO_BANK_SELECT)) {

            return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Determine the banking type, and set whether any banking is actually
    // supported in this mode.
    //

    BankSelect->BankingFlags = 0;
    codeSize = 0;
    pCodeBank = NULL;

    switch(pMode->banktype) {

    case NoBanking:

        BankSelect->BankingType = VideoNotBanked;
        BankSelect->Granularity = 0;

        break;

    case PlanarHCBanking:

        VideoDebugPrint((1, "Unsupported planarHC banking\n"));

    //
    // Fall through to NormalBanking...
    //

    case NormalBanking:

        //
        // The WDVGA supports independent 64K read and write banks except
        // for the older ships that only have 1RW
        //

        if (HwDeviceExtension->BoardID <= WD90C00) {

            BankSelect->BankingType = VideoBanked1RW;

        } else {

            BankSelect->BankingType = VideoBanked1R1W;

        }

        BankSelect->Granularity = 0x10000;    // 64K bank start adjustment

        pCodeBank = &BankSwitchStart;
        codeSize = ((ULONG)&BankSwitchEnd) - ((ULONG)&BankSwitchStart);

        break;

    }

    //
    // Size of banking info.
    //

    BankSelect->Size = sizeof(VIDEO_BANK_SELECT) + codeSize;

    //
    // This serves an a ID for the version of the structure we're using.
    //

    BankSelect->Length = sizeof(VIDEO_BANK_SELECT);

    //
    // If the buffer isn't big enough to hold all info, just return
    // ERROR_MORE_DATA; Size is already set.
    //

    if (BankSelectSize < BankSelect->Size ) {

        //
        // We're returning only the VIDEO_BANK_SELECT structure.
        //

        *OutputSize = sizeof(VIDEO_BANK_SELECT);
        return ERROR_MORE_DATA;
    }

    //
    // There's room enough for everything, so fill in all fields in
    // VIDEO_BANK_SELECT. (All fields are always returned; the caller can
    // just choose to ignore them, based on BankingFlags and BankingType.)
    //

    BankSelect->BitmapWidthInBytes = pMode->wbytes;
    BankSelect->BitmapSize = pMode->sbytes;

    //
    // Copy all banking code into the output buffer.
    //

    pCodeDest = (PUCHAR)BankSelect + sizeof(VIDEO_BANK_SELECT);

    if (pCodeBank != NULL) {

        BankSelect->CodeOffset = pCodeDest - (PUCHAR)BankSelect;
        VideoPortMoveMemory(pCodeDest, pCodeBank, codeSize);
        pCodeDest += codeSize;
    }

    //
    // Number of bytes we're returning is the full banking info size.
    //

    *OutputSize = BankSelect->Size;

    return NO_ERROR;

} // end VgaGetBankSelectCode()

VP_STATUS
VgaValidatorUcharEntry(
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    )

/*++

Routine Description:

    Entry point into the validator for byte I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;

    Port -= VGA_BASE_IO_PORT;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xF7;

            }

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_UCHAR_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if ( (Port == SEQ_DATA_PORT) &&
                 ((*Data & END_SYNC_RESET_VALUE) == END_SYNC_RESET_VALUE) &&
                 (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If we are accessing the seq address port, keep track of the
                // data value
                //

                if (Port == SEQ_ADDRESS_PORT) {

                    hwDeviceExtension->SequencerAddressValue = *Data;

                }

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

                    return NO_ERROR;

                }

                endEmulation = 0;
            }
        }

        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);

        //
        // Write back the real value of the sequencer address port.
        //

        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT,
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);

        //
        // If we are in a READ path, read the data
        //

        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUchar(hwDeviceExtension->IOAddress + Port);

            endEmulation = 0;

        }

        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //

        if (endEmulation) {

            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);

            return NO_ERROR;

        }

        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //

        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {

        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                                  SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + Port,
                                         (UCHAR) (*Data & 0xF7) );

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                            SEQ_ADDRESS_PORT,
                                        temp);

                return NO_ERROR;

            }

            //
            // If we get an access to the sequencer register, start trapping.
            //

            if ( (Port == SEQ_DATA_PORT) &&
                 ((*Data & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 (VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                         SEQ_ADDRESS_PORT) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                                 FullVgaValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_UCHAR_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;

                //
                // Start keeping track of the state of the sequencer port.
                //

                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + Port,
                                        *Data);

            }

        } else {

            *Data = VideoPortReadPortUchar(hwDeviceExtension->IOAddress + Port);

        }
    }

    return NO_ERROR;

} // end VgaValidatorUcharEntry()

VP_STATUS
VgaValidatorUshortEntry(
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    )

/*++

Routine Description:

    Entry point into the validator for word I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;

    Port -= VGA_BASE_IO_PORT;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xFFF7;

            }

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if (Port == SEQ_ADDRESS_PORT) {

                //
                // If we are accessing the seq address port, keep track of its
                // value
                //

                hwDeviceExtension->SequencerAddressValue = (*Data & 0xFF);

            }

            if ((Port == SEQ_ADDRESS_PORT) &&
                ( ((*Data >> 8) & END_SYNC_RESET_VALUE) ==
                   END_SYNC_RESET_VALUE) &&
                (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

                    return NO_ERROR;

                }

                endEmulation = 0;
            }
        }

        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);

        //
        // Write back the real value of the sequencer address port.
        //

        VideoPortWritePortUchar((PUCHAR) (hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT),
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);

        //
        // If we are in a READ path, read the data
        //

        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUshort((PUSHORT)(hwDeviceExtension->IOAddress
                                                + Port));

            endEmulation = 0;

        }

        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //

        if (endEmulation) {

            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);

            return NO_ERROR;

        }

        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //

        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {

        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                                  SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             (ULONG)Port),
                                         (USHORT) (*Data & 0xFFF7) );

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                        temp);

                return NO_ERROR;

            }

            if ( (Port == SEQ_ADDRESS_PORT) &&
                 (((*Data>> 8) & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 ((*Data & 0xFF) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                                 FullVgaValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_USHORT_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;

                //
                // Start keeping track of the state of the sequencer port.
                //

                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {

                VideoPortWritePortUshort((PUSHORT)(hwDeviceExtension->IOAddress +
                                             Port),
                                         *Data);

            }

        } else {

            *Data = VideoPortReadPortUshort((PUSHORT)(hwDeviceExtension->IOAddress +
                                            Port));

        }
    }

    return NO_ERROR;

} // end VgaValidatorUshortEntry()

VP_STATUS
VgaValidatorUlongEntry(
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    )

/*++

Routine Description:

    Entry point into the validator for dword I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;

    Port -= VGA_BASE_IO_PORT;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xFFFFFFF7;

            }

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_ULONG_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if (Port == SEQ_ADDRESS_PORT) {

                //
                // If we are accessing the seq address port, keep track of its
                // value
                //

                hwDeviceExtension->SequencerAddressValue = (*Data & 0xFF);

            }

            if ((Port == SEQ_ADDRESS_PORT) &&
                ( ((*Data >> 8) & END_SYNC_RESET_VALUE) ==
                   END_SYNC_RESET_VALUE) &&
                (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

                    return NO_ERROR;

                }

                endEmulation = 0;
            }
        }

        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);

        //
        // Write back the real value of the sequencer address port.
        //

        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT,
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);

        //
        // If we are in a READ path, read the data
        //

        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                               Port));

            endEmulation = 0;

        }

        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //

        if (endEmulation) {

            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);

            return NO_ERROR;

        }

        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //

        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {

        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                                  SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                             Port),
                                         (ULONG) (*Data & 0xFFFFFFF7) );

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                        temp);

                return NO_ERROR;

            }

            if ( (Port == SEQ_ADDRESS_PORT) &&
                 (((*Data>> 8) & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 ((*Data & 0xFF) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                                 FullVgaValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_ULONG_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;

                //
                // Start keeping track of the state of the sequencer port.
                //

                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {

                VideoPortWritePortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                            Port),
                                        *Data);

            }

        } else {

            *Data = VideoPortReadPortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                               Port));

        }
    }

    return NO_ERROR;

} // end VgaValidatorUlongEntry()


BOOLEAN
VgaPlaybackValidatorData(
    PVOID Context
    )

/*++

Routine Description:

    Performs all the DOS apps IO port accesses that were trapped by the
    validator. Only IO accesses that can be processed are WRITEs

    The number of outstanding IO access in deviceExtension is set to
    zero as a side effect.

    This function must be called via a call to VideoPortSynchronizeRoutine.

Arguments:

    Context - Context parameter passed to the synchronized routine.
        Must be a pointer to the miniport driver's device extension.

Return Value:

    TRUE.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = Context;
    ULONG ioBaseAddress = (ULONG) hwDeviceExtension->IOAddress;
    UCHAR i;
    PVGA_VALIDATOR_DATA validatorData = hwDeviceExtension->TrappedValidatorData;

    //
    // Loop through the array of data and do instructions one by one.
    //

    for (i = 0; i < hwDeviceExtension->TrappedValidatorCount;
         i++, validatorData++) {

        //
        // Calculate base address first
        //

        ioBaseAddress = (ULONG)hwDeviceExtension->IOAddress +
                            validatorData->Port;


        //
        // This is a write operation. We will automatically stop when the
        // buffer is empty.
        //

        switch (validatorData->AccessType) {

        case VGA_VALIDATOR_UCHAR_ACCESS :

            VideoPortWritePortUchar((PUCHAR)ioBaseAddress,
                                    (UCHAR) validatorData->Data);

            break;

        case VGA_VALIDATOR_USHORT_ACCESS :

            VideoPortWritePortUshort((PUSHORT)ioBaseAddress,
                                     (USHORT) validatorData->Data);

            break;

        case VGA_VALIDATOR_ULONG_ACCESS :

            VideoPortWritePortUlong((PULONG)ioBaseAddress,
                                    (ULONG) validatorData->Data);

            break;

        default:

            VideoDebugPrint((1, "InvalidValidatorAccessType\n" ));

        }
    }

    hwDeviceExtension->TrappedValidatorCount = 0;

    return TRUE;

} // end VgaPlaybackValidatorData()

//---------------------------------------------------------------------------
//
// The memory manager needs a "C" interface to the banking function
//

/*++

Routine Description:

    This function is a "C" callable interface to the ASM banking
    function.  It is NON paged because it is called from the
    Memory Manager during some page faults.

Arguments:

    iBankRead -     Index of bank we want mapped in to read from.
    iBankWrite -    Index of bank we want mapped in to write to.

Return Value:

    None.

--*/


VOID
vBankMap(
    ULONG iBankRead,
    ULONG iBankWrite,
    PVOID pvContext
    )
{
    VideoDebugPrint((1, "vBankMap(%d,%d) - enter\n",iBankRead,iBankWrite));
#ifdef _X86_
    _asm {
        mov     eax,iBankRead
        mov     edx,iBankWrite
        lea     ebx,BankSwitchStart
        call    ebx
    }
#endif
    VideoDebugPrint((1, "vBankMap - exit\n"));
}

//
// This routines was taken from the VGA miniport sources for
// the PPC thinkpad.  We need this driver to be generic, and
// to work with any portable with a WD90C24 chip.  The addresses
// used below to test for the panel type (0x102, 0xD00, 0xD01)
// may be exclusive to Thinkpad's only.  I have tested this routine
// on a non-ibm machine, and all seemed to work, but it would be
// nice to determine exactly what these registers are, and how
// they are used.
//

VOID
GetPanelType(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine get the type of attached LCD display.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/
{
    UCHAR   i;
    PUCHAR  VAddress[2];

    //
    // Assume CRT only mode
    //

    HwDeviceExtension->DisplayType = MONITOR;

    //
    // if we weren't able to claim the address ranges for the panel
    // detection registers, then we can't try to detect the panel
    // type.
    //

    if (HwDeviceExtension->ExtendedRegisters !=
        EXTENDED_AND_FLAT_PANEL_REGISTERS)
    {
        return;
    }

    for (i = 0; i < 2; i++) {

        if ((VAddress[i] =
             VideoPortGetDeviceBase(HwDeviceExtension,
                                    VgaAccessRange[i+4].RangeStart,
                                    VgaAccessRange[i+4].RangeLength,
                                    VgaAccessRange[i+4].RangeInIoSpace)) == NULL) {

            VideoDebugPrint((1, "GetPanelType - Fail to get address\n"));
            return;

        }

    }

    VideoPortWritePortUchar(VAddress[0], 0x01);
    VideoPortWritePortUchar(VAddress[1], 0xff);

#if 0
    {
        UCHAR temp;

        temp = VideoPortReadPortUchar(VAddress[1] + 1);

        VideoDebugPrint((1, "Pre Panel type = 0x%x\n", temp));
    }
#endif

    switch (VideoPortReadPortUchar(VAddress[1] + 1) & 0x0f) {
        case 0x0e : HwDeviceExtension->DisplayType |= IBM_F8515;
                    break;
        case 0x0c : HwDeviceExtension->DisplayType |= IBM_F8532;
                    break;
        case 0x0d : HwDeviceExtension->DisplayType |= TOSHIBA_DSTNC;
                    break;
        default   : HwDeviceExtension->DisplayType |= UNKNOWN_LCD;
                    break;
    }

    VideoDebugPrint((2, "GetPanelType - PanelID = %d\n",HwDeviceExtension->DisplayType & 0x0e));

    for (i = 0; i < 2; i++) {

        VideoPortFreeDeviceBase(HwDeviceExtension,VAddress[i]);

    }
}

BOOLEAN
WdResetHw(
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    )

/*++

Routine Description:

    This routine preps the Wd card for return to a VGA mode.

    This routine is called during system shutdown.  By returning
    a FALSE we inform the HAL to do an int 10 to go into text
    mode before shutting down.  Shutdown would fail with some Wd
    cards without this.

    We do some clean up before returning so that the int 10
    will work.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    The return value of FALSE informs the hal to go into text mode.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    UNREFERENCED_PARAMETER(Columns);
    UNREFERENCED_PARAMETER(Rows);

    if ((hwDeviceExtension->BoardID == WD90C24A) &&
        (hwDeviceExtension->IsIBM   == TRUE))
    {
        BOOLEAN bLCD=FALSE;

        VgaInterpretCmdStream(HwDeviceExtension, Reset);

        //
        // If the LCD is enabled we also need to SET bit 0
        // of PR2.
        //
        // We will check to see if the LCD is enabled by
        // checking bit 2 of CRTC register 0x31, and bit
        // 4 of CRTC register 0x32.  If either of these
        // is set, then we'll assume an LCD is enabled.
        //

        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR, 0x31);
        if (VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                CRTC_DATA_PORT_COLOR) & 0x04)
        {
            bLCD = TRUE;
        }

        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR, 0x32);
        if (VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                CRTC_DATA_PORT_COLOR) & 0x10)
        {
            bLCD = TRUE;
        }

        if (bLCD == TRUE)
        {
            VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    GRAPH_ADDRESS_PORT, 0x0c);
            VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    GRAPH_DATA_PORT, (UCHAR)0x01);
        }
        else
        {
            VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    GRAPH_ADDRESS_PORT, 0x0c);
            VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    GRAPH_DATA_PORT, (UCHAR)0x00);
        }
    }

    return FALSE;
}

//
// Routine to set a desired DPMS power management state.
//
VP_STATUS
VGASetPower50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    )
{
    if ((pVideoPowerMgmt->PowerState == VideoPowerOn) ||
        (pVideoPowerMgmt->PowerState == VideoPowerHibernate)) {

        return NO_ERROR;

    } else {

        return ERROR_INVALID_FUNCTION;
    }
}

//
// Routine to retrieve possible DPMS power management states.
//
VP_STATUS
VGAGetPower50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    )
{
    if ((pVideoPowerMgmt->PowerState == VideoPowerOn) ||
        (pVideoPowerMgmt->PowerState == VideoPowerHibernate)) {

        return NO_ERROR;

    } else {

        return ERROR_INVALID_FUNCTION;
    }
}


//
// Routine to retrieve the Enhanced Display ID structure via DDC
//
ULONG
VGAGetVideoChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    )
{
    PHW_DEVICE_EXTENSION pHwDeviceExtension = HwDeviceExtension;
    ULONG                Status;

    ASSERT(pHwDeviceExtension != NULL && pMoreChildren != NULL);

    VideoDebugPrint((2, "WDVGA VGAGetVideoChildDescriptor: *** Entry point ***\n"));

    //
    // Determine if the graphics adapter in the system supports
    // DDC2 (our miniport only supports DDC2, not DDC1). This has
    // the side effect (assuming both monitor and card support
    // DDC2) of switching the monitor from DDC1 mode (repeated
    // "blind" broadcast of EDID clocked by the vertical sync
    // signal) to DDC2 mode (query/response not using any of the
    // normal video lines - can transfer information rapidly
    // without first disrupting the screen by switching into
    // a pseudo-mode with a high vertical sync frequency).
    //
    // Since we must support hot-plugging of monitors, and our
    // routine to obtain the EDID structure via DDC2 assumes that
    // the monitor is in DDC2 mode, we must make this test each
    // time this entry point is called.
    //

    switch (ChildEnumInfo->ChildIndex) {
    case 0:

        //
        // Case 0 is used to enumerate devices found by the ACPI firmware.
        //
        // Since we do not support ACPI devices yet, we must return failure.
        //

        Status = ERROR_NO_MORE_DEVICES;
        break;

    case 1:

        //
        // We do not support monitor enumeration
        //

        Status = ERROR_NO_MORE_DEVICES;
        break;

    case DISPLAY_ADAPTER_HW_ID:
    {

        PUSHORT     pPnpDeviceDescription = NULL;
        ULONG       stringSize            = sizeof(L"*PNPXXXX");


        //
        // Special ID to handle return legacy PnP IDs for root enumerated
        // devices.
        //

        *pChildType = VideoChip;
        *pHwId      = DISPLAY_ADAPTER_HW_ID;

        //
        //  Figure out which card type and set pPnpDeviceDescription at
        //  associated string.
        //

        //
        //  [Mfg.Diamond]
        //  %SpeedStar24X%=WD,, *PNP0907
        //
        //  [Mfg.DFI]
        //  %WG6000%=WD,, *PNP0907
        //
        //  [Mfg.IBM]
        //  %TP755CX%=TP755CX,MSDisp_TP755CX, *PNP0907
        //
        //  [Mfg.Paradise]
        //  %PortsOCall%=WD,, *PNP0907
        //  %AccelVL%=WD,, *PNP0907
        //  %ParaSVGA%=WD,, *PNP0907
        //
        //  [Mfg.WD]
        //  %*PNP0907.DeviceDesc%=WD, *PNP0907
        //  %*PNP0907.DeviceDesc%=WD, *PNP0908  BUGBUG
        //  %WD512%=WD512,, *PNP0907, *PNP0908  BUGBUG
        //

        if ((pHwDeviceExtension->BoardID == WD90C24A))
            pPnpDeviceDescription = L"*PNP0907";

        else if (pHwDeviceExtension->BoardID == SPEEDSTAR30)
            pPnpDeviceDescription = L"*PNP0908";
        else
            pPnpDeviceDescription = L"*PNP0908";

        //
        //  Now just copy the string into memory provided.
        //

        memcpy(pvChildDescriptor, pPnpDeviceDescription, stringSize);

        Status = ERROR_MORE_DATA;
        break;
        }

    default:

        Status = ERROR_NO_MORE_DEVICES;
        break;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\bitblt.c ===
/******************************Module*Header*******************************\
* Module Name: bitblt.c
*
* Contains the high-level DrvBitBlt and DrvCopyBits functions.  The low-
* level stuff lives in 'blt.c'.
*
* !!! Change note about 'iType'
*
* Note: Since we've implemented device-bitmaps, any surface that GDI passes
*       to us can have 3 values for its 'iType': STYPE_BITMAP, STYPE_DEVICE
*       or STYPE_DEVBITMAP.  We filter device-bitmaps that we've stored
*       as DIBs fairly high in the code, so after we adjust its 'pptlSrc',
*       we can treat STYPE_DEVBITMAP surfaces the same as STYPE_DEVICE
*       surfaces (e.g., a blt from an off-screen device bitmap to the screen
*       gets treated as a normal screen-to-screen blt).  So throughout
*       this code, we will compare a surface's 'iType' to STYPE_BITMAP:
*       if it's equal, we've got a true DIB, and if it's unequal, we have
*       a screen-to-screen operation.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Data*********************************\
* Rop-needs-pattern table
*
* Determines if a rop2 needs uses a pattern.
*
* Use 'gabRopNeedsPattern[(rop3 >> 2) & 0xf]', but note that this can only
* be done if it is known that the rop3 doesn't use a source.
*
\**************************************************************************/

BYTE gabRopNeedsPattern[] =
{
    FALSE, // R2_BLACK
    TRUE,  // R2_NOTMERGEPEN
    TRUE,  // R2_MASKNOTPEN
    TRUE,  // R2_NOTCOPYPEN
    TRUE,  // R2_MASKPENNOT
    FALSE, // R2_NOT
    TRUE,  // R2_XORPEN
    TRUE,  // R2_NOTMASKPEN
    TRUE,  // R2_MASKPEN
    TRUE,  // R2_NOTXORPEN
    FALSE, // R2_NOP
    TRUE,  // R2_MERGENOTPEN
    TRUE,  // R2_COPYPEN
    TRUE,  // R2_MERGEPENNOT
    TRUE,  // R2_MERGEPEN
    FALSE, // R2_WHITE
};

/******************************Public*Data*********************************\
* Mix-needs-pattern table
*
* Determines if a mix uses a pattern.
*
* Use 'gabMixNeedsPattern[mix & 0xf]' or 'gabMixNeedsPattern[mix & 0xff]'.
*
\**************************************************************************/

BYTE gabMixNeedsPattern[] =
{
    FALSE, // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0x0F]
    FALSE, // R2_BLACK
    TRUE,  // R2_NOTMERGEPEN
    TRUE,  // R2_MASKNOTPEN
    TRUE,  // R2_NOTCOPYPEN
    TRUE,  // R2_MASKPENNOT
    FALSE, // R2_NOT
    TRUE,  // R2_XORPEN
    TRUE,  // R2_NOTMASKPEN
    TRUE,  // R2_MASKPEN
    TRUE,  // R2_NOTXORPEN
    FALSE, // R2_NOP
    TRUE,  // R2_MERGENOTPEN
    TRUE,  // R2_COPYPEN
    TRUE,  // R2_MERGEPENNOT
    TRUE,  // R2_MERGEPEN
    FALSE, // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0xFF]
};

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaRop3FromMix[] =
{
    0xFF,  // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0xFF]
};

#if DBG

// This table is big, so we only use to aid in debugging...

/******************************Public*Data*********************************\
* ROP3 translation table - Use only for debugging
*
* Translates the usual ternary rop into A-vector notation.  Each bit in
* this new notation corresponds to a term in a polynomial translation of
* the rop.
*
* Rop(D,S,P) = a + a D + a S + a P + a  DS + a  DP + a  SP + a   DSP
*               0   d     s     p     ds      dp      sp      dsp
*
\**************************************************************************/

BYTE gajRop3[] =
{
    0x00, 0xff, 0xb2, 0x4d, 0xd4, 0x2b, 0x66, 0x99,
    0x90, 0x6f, 0x22, 0xdd, 0x44, 0xbb, 0xf6, 0x09,
    0xe8, 0x17, 0x5a, 0xa5, 0x3c, 0xc3, 0x8e, 0x71,
    0x78, 0x87, 0xca, 0x35, 0xac, 0x53, 0x1e, 0xe1,
    0xa0, 0x5f, 0x12, 0xed, 0x74, 0x8b, 0xc6, 0x39,
    0x30, 0xcf, 0x82, 0x7d, 0xe4, 0x1b, 0x56, 0xa9,
    0x48, 0xb7, 0xfa, 0x05, 0x9c, 0x63, 0x2e, 0xd1,
    0xd8, 0x27, 0x6a, 0x95, 0x0c, 0xf3, 0xbe, 0x41,
    0xc0, 0x3f, 0x72, 0x8d, 0x14, 0xeb, 0xa6, 0x59,
    0x50, 0xaf, 0xe2, 0x1d, 0x84, 0x7b, 0x36, 0xc9,
    0x28, 0xd7, 0x9a, 0x65, 0xfc, 0x03, 0x4e, 0xb1,
    0xb8, 0x47, 0x0a, 0xf5, 0x6c, 0x93, 0xde, 0x21,
    0x60, 0x9f, 0xd2, 0x2d, 0xb4, 0x4b, 0x06, 0xf9,
    0xf0, 0x0f, 0x42, 0xbd, 0x24, 0xdb, 0x96, 0x69,
    0x88, 0x77, 0x3a, 0xc5, 0x5c, 0xa3, 0xee, 0x11,
    0x18, 0xe7, 0xaa, 0x55, 0xcc, 0x33, 0x7e, 0x81,
    0x80, 0x7f, 0x32, 0xcd, 0x54, 0xab, 0xe6, 0x19,
    0x10, 0xef, 0xa2, 0x5d, 0xc4, 0x3b, 0x76, 0x89,
    0x68, 0x97, 0xda, 0x25, 0xbc, 0x43, 0x0e, 0xf1,
    0xf8, 0x07, 0x4a, 0xb5, 0x2c, 0xd3, 0x9e, 0x61,
    0x20, 0xdf, 0x92, 0x6d, 0xf4, 0x0b, 0x46, 0xb9,
    0xb0, 0x4f, 0x02, 0xfd, 0x64, 0x9b, 0xd6, 0x29,
    0xc8, 0x37, 0x7a, 0x85, 0x1c, 0xe3, 0xae, 0x51,
    0x58, 0xa7, 0xea, 0x15, 0x8c, 0x73, 0x3e, 0xc1,
    0x40, 0xbf, 0xf2, 0x0d, 0x94, 0x6b, 0x26, 0xd9,
    0xd0, 0x2f, 0x62, 0x9d, 0x04, 0xfb, 0xb6, 0x49,
    0xa8, 0x57, 0x1a, 0xe5, 0x7c, 0x83, 0xce, 0x31,
    0x38, 0xc7, 0x8a, 0x75, 0xec, 0x13, 0x5e, 0xa1,
    0xe0, 0x1f, 0x52, 0xad, 0x34, 0xcb, 0x86, 0x79,
    0x70, 0x8f, 0xc2, 0x3d, 0xa4, 0x5b, 0x16, 0xe9,
    0x08, 0xf7, 0xba, 0x45, 0xdc, 0x23, 0x6e, 0x91,
    0x98, 0x67, 0x2a, 0xd5, 0x4c, 0xb3, 0xfe, 0x01
};

#define AVEC_NOT            0x01
#define AVEC_D              0x02
#define AVEC_S              0x04
#define AVEC_P              0x08
#define AVEC_DS             0x10
#define AVEC_DP             0x20
#define AVEC_SP             0x40
#define AVEC_DSP            0x80
#define AVEC_NEED_SOURCE    (AVEC_S | AVEC_DS | AVEC_SP | AVEC_DSP)
#define AVEC_NEED_PATTERN   (AVEC_P | AVEC_DP | AVEC_SP | AVEC_DSP)
#define AVEC_NEED_DEST      (AVEC_D | AVEC_DS | AVEC_DP | AVEC_DSP)

#endif // DBG

/******************************Public*Table********************************\
* BYTE gajLeftMask[] and BYTE gajRightMask[]
*
* Edge tables for vXferScreenTo1bpp.
\**************************************************************************/

BYTE gajLeftMask[]  = { 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01 };
BYTE gajRightMask[] = { 0xff, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe };

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'.  If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL bIntersect(
RECTL*  prcl1,
RECTL*  prcl2,
RECTL*  prclResult)
{
    prclResult->left  = max(prcl1->left,  prcl2->left);
    prclResult->right = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
        prclResult->top    = max(prcl1->top,    prcl2->top);
        prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

        if (prclResult->top < prclResult->bottom)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* LONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'.  The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
\**************************************************************************/

LONG cIntersect(
RECTL*  prclClip,
RECTL*  prclIn,         // List of rectangles
LONG    c)              // Can be zero
{
    LONG    cIntersections;
    RECTL*  prclOut;

    cIntersections = 0;
    prclOut        = prclIn;

    for (; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}

/******************************Public*Routine******************************\
* VOID vXferScreenTo1bpp
*
* Performs a SRCCOPY transfer from the screen (when it's 8bpp) to a 1bpp
* bitmap.
*
\**************************************************************************/

#if defined(i386)

VOID vXferScreenTo1bpp(         // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
                                //   coordinates
ULONG       ulHwMix,            // Not used
SURFOBJ*    psoDst,             // Destination surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo)               // Provides colour-compressions information
{
    LONG    cjPel;
    VOID*   pfnCompute;
    SURFOBJ soTmp;
    ULONG*  pulXlate;
    ULONG   ulForeColor;
    POINTL  ptlSrc;
    RECTL   rclTmp;
    BYTE*   pjDst;
    BYTE    jLeftMask;
    BYTE    jRightMask;
    BYTE    jNotLeftMask;
    BYTE    jNotRightMask;
    LONG    cjMiddle;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    LONG    cyTmpScans;
    LONG    cyThis;
    LONG    cyToGo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(psoDst->iBitmapFormat == BMF_1BPP, "Only 1bpp destinations");
    ASSERTDD(TMP_BUFFER_SIZE >= (ppdev->cxMemory * ppdev->cjPel),
                "Temp buffer has to be larger than widest possible scan");

    // When the destination is a 1bpp bitmap, the foreground colour
    // maps to '1', and any other colour maps to '0'.

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // When the source is 8bpp or less, we find the forground colour
        // by searching the translate table for the only '1':

        pulXlate = pxlo->pulXlate;
        while (*pulXlate != 1)
            pulXlate++;

        ulForeColor = pulXlate - pxlo->pulXlate;
    }
    else
    {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_32BPP),
                 "This routine only supports 8, 16 or 32bpp");

        // When the source has a depth greater than 8bpp, the foreground
        // colour will be the first entry in the translate table we get
        // from calling 'piVector':

        pulXlate = XLATEOBJ_piVector(pxlo);

        ulForeColor = 0;
        if (pulXlate != NULL)           // This check isn't really needed...
            ulForeColor = pulXlate[0];
    }

    // We use the temporary buffer to keep a copy of the source
    // rectangle:

    soTmp.pvScan0 = ppdev->pvTmpBuffer;

    do {
        // ptlSrc points to the upper-left corner of the screen rectangle
        // for the current batch:

        ptlSrc.x = prcl->left + (pptlSrc->x - prclDst->left);
        ptlSrc.y = prcl->top  + (pptlSrc->y - prclDst->top);

        // vGetBits takes absolute coordinates for the source point:

        ptlSrc.x += ppdev->xOffset;
        ptlSrc.y += ppdev->yOffset;

        pjDst = (BYTE*) psoDst->pvScan0 + (prcl->top * psoDst->lDelta)
                                        + (prcl->left >> 3);

        cjPel = ppdev->cjPel;

        soTmp.lDelta = (((prcl->right + 7L) & ~7L) - (prcl->left & ~7L))
                       * cjPel;

        // Our temporary buffer, into which we read a copy of the source,
        // may be smaller than the source rectangle.  In that case, we
        // process the source rectangle in batches.
        //
        // cyTmpScans is the number of scans we can do in each batch.
        // cyToGo is the total number of scans we have to do for this
        // rectangle.
        //
        // We take the buffer size less four so that the right edge case
        // can safely read one dword past the end:

        cyTmpScans = (TMP_BUFFER_SIZE - 4) / soTmp.lDelta;
        cyToGo     = prcl->bottom - prcl->top;

        ASSERTDD(cyTmpScans > 0, "Buffer too small for largest possible scan");

        // Initialize variables that don't change within the batch loop:

        rclTmp.top    = 0;
        rclTmp.left   = prcl->left & 7L;
        rclTmp.right  = (prcl->right - prcl->left) + rclTmp.left;

        // Note that we have to be careful with the right mask so that it
        // isn't zero.  A right mask of zero would mean that we'd always be
        // touching one byte past the end of the scan (even though we
        // wouldn't actually be modifying that byte), and we must never
        // access memory past the end of the bitmap (because we can access
        // violate if the bitmap end is exactly page-aligned).

        jLeftMask     = gajLeftMask[rclTmp.left & 7];
        jRightMask    = gajRightMask[rclTmp.right & 7];
        cjMiddle      = ((rclTmp.right - 1) >> 3) - (rclTmp.left >> 3) - 1;

        if (cjMiddle < 0)
        {
            // The blt starts and ends in the same byte:

            jLeftMask &= jRightMask;
            jRightMask = 0;
            cjMiddle   = 0;
        }

        jNotLeftMask  = ~jLeftMask;
        jNotRightMask = ~jRightMask;
        lDstDelta     = psoDst->lDelta - cjMiddle - 2;
                                // Delta from the end of the destination
                                //  to the start on the next scan, accounting
                                //  for 'left' and 'right' bytes

        lSrcDelta     = soTmp.lDelta - ((8 * (cjMiddle + 2)) * cjPel);
                                // Compute source delta for special cases
                                //  like when cjMiddle gets bumped up to '0',
                                //  and to correct aligned cases

        do {
            // This is the loop that breaks the source rectangle into
            // manageable batches.

            cyThis  = cyTmpScans;
            cyToGo -= cyThis;
            if (cyToGo < 0)
                cyThis += cyToGo;

            rclTmp.bottom = cyThis;

            vGetBits(ppdev, &soTmp, &rclTmp, &ptlSrc);

            ptlSrc.y += cyThis;         // Get ready for next batch loop

            _asm {
                mov     eax,ulForeColor     ;eax = foreground colour
                                            ;ebx = temporary storage
                                            ;ecx = count of middle dst bytes
                                            ;dl  = destination byte accumulator
                                            ;dh  = temporary storage
                mov     esi,soTmp.pvScan0   ;esi = source pointer
                mov     edi,pjDst           ;edi = destination pointer

                ; Figure out the appropriate compute routine:

                mov     ebx,cjPel
                mov     pfnCompute,offset Compute_Destination_Byte_From_8bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_16bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_32bpp

            Do_Left_Byte:
                call    pfnCompute
                and     dl,jLeftMask
                mov     dh,jNotLeftMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi
                mov     ecx,cjMiddle
                dec     ecx
                jl      short Do_Right_Byte

            Do_Middle_Bytes:
                call    pfnCompute
                mov     [edi],dl
                inc     edi
                dec     ecx
                jge     short Do_Middle_Bytes

            Do_Right_Byte:
                call    pfnCompute
                and     dl,jRightMask
                mov     dh,jNotRightMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi

                add     edi,lDstDelta
                add     esi,lSrcDelta
                dec     cyThis
                jnz     short Do_Left_Byte

                mov     pjDst,edi               ;save for next batch

                jmp     All_Done

            Compute_Destination_Byte_From_8bpp:
                mov     bl,[esi]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 0

                mov     bl,[esi+1]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 1

                mov     bl,[esi+2]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 2

                mov     bl,[esi+3]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 3

                mov     bl,[esi+4]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 4

                mov     bl,[esi+5]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 5

                mov     bl,[esi+6]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 6

                mov     bl,[esi+7]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 7

                add     esi,8                   ;advance the source
                ret

            Compute_Destination_Byte_From_16bpp:
                mov     bx,[esi]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 0

                mov     bx,[esi+2]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 1

                mov     bx,[esi+4]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 2

                mov     bx,[esi+6]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 3

                mov     bx,[esi+8]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 4

                mov     bx,[esi+10]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 5

                mov     bx,[esi+12]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 6

                mov     bx,[esi+14]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 7

                add     esi,16                  ;advance the source
                ret

            Compute_Destination_Byte_From_32bpp:
                mov     ebx,[esi]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 0

                mov     ebx,[esi+4]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 1

                mov     ebx,[esi+8]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 2

                mov     ebx,[esi+12]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 3

                mov     ebx,[esi+16]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 4

                mov     ebx,[esi+20]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 5

                mov     ebx,[esi+24]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 6

                mov     ebx,[esi+28]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 7

                add     esi,32                  ;advance the source
                ret

            All_Done:
            }
        } while (cyToGo > 0);

        prcl++;
    } while (--c != 0);
}

#endif // i386

/******************************Public*Routine******************************\
* BOOL bPuntBlt
*
* Has GDI do any drawing operations that we don't specifically handle
* in the driver.
*
\**************************************************************************/

BOOL bPuntBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*   ppdev;
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    OH*     pohSrc;
    OH*     pohDst;
    POINTL  ptlSrc;

    #if DBG

    {
        //////////////////////////////////////////////////////////////////////
        // Diagnostics
        //
        // Since calling the engine to do any drawing can be rather painful,
        // particularly when the source is an off-screen DFB (since GDI will
        // have to allocate a DIB and call us to make a temporary copy before
        // it can even start drawing), we'll try to avoid it as much as
        // possible.
        //
        // Here we simply spew out information describing the blt whenever
        // this routine gets called (checked builds only, of course):

        ULONG ulClip;
        PDEV* ppdev;
        ULONG ulAvec;

        if (psoDst->dhpdev != NULL)
            ppdev = (PDEV*) psoDst->dhpdev;
        else
            ppdev = (PDEV*) psoSrc->dhpdev;

        ulClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

        DISPDBG((1, ">> Punt << Dst format: %li Dst type: %li Clip: %li Rop: %lx",
            psoDst->iBitmapFormat, psoDst->iType, ulClip, rop4));

        if (psoSrc != NULL)
            DISPDBG((1, "        << Src format: %li Src type: %li",
                psoSrc->iBitmapFormat, psoSrc->iType));

        if ((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL) && (psoSrc != NULL))
        {
            if (((psoSrc->dhsurf == NULL) &&
                 (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)) ||
                ((psoDst->dhsurf == NULL) &&
                 (psoDst->iBitmapFormat != ppdev->iBitmapFormat)))
            {
                // Don't bother printing the 'xlate' message when the source
                // is a different bitmap format from the destination -- in
                // those cases we know there always has to be a translate.
            }
            else
            {
                DISPDBG((1, "        << With xlate"));
            }
        }

        // The high 2 bytes of rop4 is not guaranteed to be zero. So in order
        // to get the low 8 bits as index, we have to &ffff before do >>
        ulAvec = gajRop3[rop4 & 0xff] | gajRop3[(rop4 & 0xffff) >> 8];

        if ((ulAvec & AVEC_NEED_PATTERN) && (pbo->iSolidColor == -1))
        {
            if (pbo->pvRbrush == NULL)
                DISPDBG((1, "        << With brush -- Not created"));
            else
                DISPDBG((1, "        << With brush -- Created Ok"));
        }
    }
    #endif

    if (psoDst->dhsurf != NULL)
    {
        ppdev           = (PDEV*)  psoDst->dhpdev;
        pdsurfDst       = (DSURF*) psoDst->dhsurf;
        psoDst          = ppdev->psoPunt;
        psoDst->pvScan0 = pdsurfDst->poh->pvScan0;

        if (psoSrc != NULL)
        {
            pdsurfSrc = (DSURF*) psoSrc->dhsurf;
            if ((pdsurfSrc != NULL) &&
                (pdsurfSrc != pdsurfDst))
            {
                // If we're doing a BitBlt between different off-screen
                // surfaces, we have to be sure to give GDI different
                // surfaces, otherwise it may get confused when it has
                // to do screen-to-screen blts with a translate...

                pohSrc = pdsurfSrc->poh;
                pohDst = pdsurfDst->poh;

                psoSrc          = ppdev->psoPunt2;
                psoSrc->pvScan0 = pohSrc->pvScan0;

                // Undo the source pointer adjustment we did earlier:

                ptlSrc.x = pptlSrc->x + (pohDst->x - pohSrc->x);
                ptlSrc.y = pptlSrc->y + (pohDst->y - pohSrc->y);
                pptlSrc  = &ptlSrc;
            }
        }
    }
    else
    {
        ppdev           = (PDEV*)  psoSrc->dhpdev;
        pdsurfSrc       = (DSURF*) psoSrc->dhsurf;
        psoSrc          = ppdev->psoPunt;
        psoSrc->pvScan0 = pdsurfSrc->poh->pvScan0;
    }

    return(EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst, pptlSrc,
                     pptlMsk, pbo, pptlBrush, rop4));
}

/******************************Public*Routine******************************\
* BOOL DrvBitBlt
*
* Implements the workhorse routine of a display driver.
*
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*           ppdev;
    DSURF*          pdsurfDst;
    DSURF*          pdsurfSrc;
    POINTL          ptlSrc;
    BYTE            jClip;
    OH*             poh;
    BOOL            bMore;
    CLIPENUM        ce;
    LONG            c;
    RECTL           rcl;
    ULONG           rop3;
    FNFILL*         pfnFill;
    RBRUSH_COLOR    rbc;         // Realized brush or solid colour
    FNXFER*         pfnXfer;
    ULONG           iSrcBitmapFormat;
    ULONG           iDir;

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    pdsurfDst = (DSURF*) psoDst->dhsurf;    // May be NULL

    if (psoSrc == NULL)
    {
        ///////////////////////////////////////////////////////////////////
        // Fills
        ///////////////////////////////////////////////////////////////////

        // Fills are this function's "raison d'etre" (which is French
        // for "purple armadillo"), so we handle them as quickly as
        // possible:

        ASSERTDD(pdsurfDst != NULL,
                 "Expect only device destinations when no source");

        if (pdsurfDst->dt == DT_SCREEN)
        {
            ppdev = (PDEV*) psoDst->dhpdev;

            poh = pdsurfDst->poh;
            ppdev->xOffset = poh->x;
            ppdev->yOffset = poh->y;

            // Make sure it doesn't involve a mask (i.e., it's really a
            // Rop3):

            if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
            {
                // Since 'psoSrc' is NULL, the rop3 had better not indicate
                // that we need a source.

                ASSERTDD((((rop4 >> 2) ^ (rop4)) & 0x33) == 0,
                         "Need source but GDI gave us a NULL 'psoSrc'");

            Fill_It:

                pfnFill = ppdev->pfnFillSolid;
                if (gabRopNeedsPattern[(rop4 >> 2) & 0xf])
                {
                    rbc.iSolidColor = pbo->iSolidColor;
                    if (rbc.iSolidColor == -1)
                    {
                        // Try and realize the pattern brush; by doing
                        // this call-back, GDI will eventually call us
                        // again through DrvRealizeBrush:

                        rbc.prb = pbo->pvRbrush;
                        if (rbc.prb == NULL)
                        {
                            rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                            if (rbc.prb == NULL)
                            {
                                // If we couldn't realize the brush, punt
                                // the call (it may have been a non 8x8
                                // brush or something, which we can't be
                                // bothered to handle, so let GDI do the
                                // drawing):

                                goto Punt_It;
                            }
                        }
                        pfnFill = ppdev->pfnFillPat;
                    }
                }

                // Note that these 2 'if's are more efficient than
                // a switch statement:

                if (jClip == DC_TRIVIAL)
                {
                    pfnFill(ppdev, 1, prclDst, rop4, rbc, pptlBrush);
                    goto All_Done;
                }
                else if (jClip == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                        pfnFill(ppdev, 1, &rcl, rop4, rbc, pptlBrush);
                    goto All_Done;
                }
                else
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    do {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                        c = cIntersect(prclDst, ce.arcl, ce.c);

                        if (c != 0)
                            pfnFill(ppdev, c, ce.arcl, rop4, rbc, pptlBrush);

                    } while (bMore);
                    goto All_Done;
                }
            }
        }
    }

    if ((psoSrc != NULL) && (psoSrc->dhsurf != NULL))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        if (pdsurfSrc->dt == DT_DIB)
        {
            // Here we consider putting a DIB DFB back into off-screen
            // memory.  If there's a translate, it's probably not worth
            // moving since we won't be able to use the hardware to do
            // the blt (a similar argument could be made for weird rops
            // and stuff that we'll only end up having GDI simulate, but
            // those should happen infrequently enough that I don't care).

            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                ppdev = (PDEV*) psoSrc->dhpdev;

                // See 'DrvCopyBits' for some more comments on how this
                // moving-it-back-into-off-screen-memory thing works:

                if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                {
                    if (--pdsurfSrc->cBlt == 0)
                    {
                        if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))
                            goto Continue_It;
                    }
                }
                else
                {
                    // Some space was freed up in off-screen memory,
                    // so reset the counter for this DFB:

                    pdsurfSrc->iUniq = ppdev->iHeapUniq;
                    pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                }
            }

            psoSrc = pdsurfSrc->pso;

            // Handle the case where the source is a DIB DFB and the
            // destination is a regular bitmap:

            if (psoDst->dhsurf == NULL)
                goto EngBitBlt_It;

        }
    }

Continue_It:

    if (pdsurfDst != NULL)
    {
        if (pdsurfDst->dt == DT_DIB)
        {
            psoDst = pdsurfDst->pso;

            // If the destination is a DIB, we can only handle this
            // call if the source is not a DIB:

            if ((psoSrc == NULL) || (psoSrc->dhsurf == NULL))
                goto EngBitBlt_It;
        }
    }

    // At this point, we know that either the source or the destination is
    // not a DIB.  Check for a DFB to screen, DFB to DFB, or screen to DFB
    // case:

    if ((psoSrc != NULL) &&
        (psoDst->dhsurf != NULL) &&
        (psoSrc->dhsurf != NULL))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        pdsurfDst = (DSURF*) psoDst->dhsurf;

        ASSERTDD(pdsurfSrc->dt == DT_SCREEN, "Expected screen source");
        ASSERTDD(pdsurfDst->dt == DT_SCREEN, "Expected screen destination");

        ptlSrc.x = pptlSrc->x - (pdsurfDst->poh->x - pdsurfSrc->poh->x);
        ptlSrc.y = pptlSrc->y - (pdsurfDst->poh->y - pdsurfSrc->poh->y);

        pptlSrc  = &ptlSrc;
    }

    if (psoDst->dhsurf != NULL)
    {
        pdsurfDst = (DSURF*) psoDst->dhsurf;
        ppdev     = (PDEV*)  psoDst->dhpdev;

        ppdev->xOffset = pdsurfDst->poh->x;
        ppdev->yOffset = pdsurfDst->poh->y;
    }
    else
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        ppdev     = (PDEV*)  psoSrc->dhpdev;

        ppdev->xOffset = pdsurfSrc->poh->x;
        ppdev->yOffset = pdsurfSrc->poh->y;
    }

    // We bail here if we're running in a high-colour mode on the P9000:

    if (ppdev->flStat & STAT_UNACCELERATED)
        goto EngBitBlt_It;

    if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
    {
        // Since we've already handled the cases where the ROP4 is really
        // a ROP3 and no source is required, we can assert...

        ASSERTDD((psoSrc != NULL) && (pptlSrc != NULL),
                 "Expected no-source case to already have been handled");

        ///////////////////////////////////////////////////////////////////
        // Bitmap transfers
        ///////////////////////////////////////////////////////////////////

        // Since the foreground and background ROPs are the same, we
        // don't have to worry about no stinking masks (it's a simple
        // Rop3).

        rop3 = (rop4 & 0xff);   // Make it into a Rop3 (we keep the rop4
                                //  around in case we decide to punt)

        if (psoDst->dhsurf != NULL)
        {
            // The destination is the screen:

            if ((rop3 >> 4) == (rop3 & 0xf))
            {
                // The ROP3 doesn't require a pattern:

                if (psoSrc->dhsurf == NULL)
                {
                    //////////////////////////////////////////////////
                    // DIB-to-screen blt

                    // This section handles 1bpp, 4bpp and 8bpp sources.

                    iSrcBitmapFormat = psoSrc->iBitmapFormat;
                    if (iSrcBitmapFormat == BMF_1BPP)
                    {
                        pfnXfer = ppdev->pfnXfer1bpp;
                        goto Xfer_It;
                    }
                    else if ((iSrcBitmapFormat == ppdev->iBitmapFormat) &&
                             ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
                    {
                        pfnXfer = ppdev->pfnXferNative;
                        goto Xfer_It;
                    }
                    else if ((iSrcBitmapFormat == BMF_4BPP) &&
                             (ppdev->iBitmapFormat == BMF_8BPP))
                    {
                        pfnXfer = ppdev->pfnXfer4bpp;
                        goto Xfer_It;
                    }
                }
                else // psoSrc->dhsurf != NULL
                {
                    if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
                    {
                        //////////////////////////////////////////////////
                        // Screen-to-screen blt with no translate

                        if (jClip == DC_TRIVIAL)
                        {
                            (ppdev->pfnCopyBlt)(ppdev, 1, prclDst, rop4,
                                pptlSrc, prclDst);
                            goto All_Done;
                        }
                        else if (jClip == DC_RECT)
                        {
                            if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                            {
                                (ppdev->pfnCopyBlt)(ppdev, 1, &rcl, rop4,
                                    pptlSrc, prclDst);
                            }
                            goto All_Done;
                        }
                        else
                        {
                            // Don't forget that we'll have to draw the
                            // rectangles in the correct direction:

                            if (pptlSrc->y >= prclDst->top)
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTDOWN;
                                else
                                    iDir = CD_LEFTDOWN;
                            }
                            else
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTUP;
                                else
                                    iDir = CD_LEFTUP;
                            }

                            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                               iDir, 0);

                            do {
                                bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                                      (ULONG*) &ce);

                                c = cIntersect(prclDst, ce.arcl, ce.c);

                                if (c != 0)
                                {
                                    (ppdev->pfnCopyBlt)(ppdev, c, ce.arcl,
                                        rop4, pptlSrc, prclDst);
                                }

                            } while (bMore);
                            goto All_Done;
                        }
                    }
                }
            }
        }
        else
        {
            #if defined(i386)
            {
                // We special case screen to monochrome blts because they
                // happen fairly often.  We only handle SRCCOPY rops and
                // monochrome destinations (to handle a true 1bpp DIB
                // destination, we would have to do near-colour searches
                // on every colour; as it is, the foreground colour gets
                // mapped to '1', and everything else gets mapped to '0'):

                if ((psoDst->iBitmapFormat == BMF_1BPP) &&
                    (rop3 == 0xcc) &&
                    (pxlo->flXlate & XO_TO_MONO) &&
                    (ppdev->iBitmapFormat != BMF_24BPP))
                {
                    pfnXfer = vXferScreenTo1bpp;
                    psoSrc  = psoDst;               // A misnomer, I admit
                    goto Xfer_It;
                }
            }
            #endif // i386
        }
    }
    else if ((psoMsk == NULL) && (rop4 == 0xaacc))
    {
        // The only time GDI will ask us to do a true rop4 using the brush
        // mask is when the brush is 1bpp, and the background rop is AA
        // (meaning it's a NOP):

        goto Fill_It;
    }

    // Just fall through to Punt_It...

Punt_It:

    return(bPuntBlt(psoDst,
                    psoSrc,
                    psoMsk,
                    pco,
                    pxlo,
                    prclDst,
                    pptlSrc,
                    pptlMsk,
                    pbo,
                    pptlBrush,
                    rop4));

//////////////////////////////////////////////////////////////////////
// Common bitmap transfer

Xfer_It:
    if (jClip == DC_TRIVIAL)
    {
        pfnXfer(ppdev, 1, prclDst, rop4, psoSrc, pptlSrc, prclDst, pxlo);
        goto All_Done;
    }
    else if (jClip == DC_RECT)
    {
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            pfnXfer(ppdev, 1, &rcl, rop4, psoSrc, pptlSrc, prclDst, pxlo);
        goto All_Done;
    }
    else
    {
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                           CD_ANY, 0);

        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                  (ULONG*) &ce);

            c = cIntersect(prclDst, ce.arcl, ce.c);

            if (c != 0)
            {
                pfnXfer(ppdev, c, ce.arcl, rop4, psoSrc,
                        pptlSrc, prclDst, pxlo);
            }

        } while (bMore);
        goto All_Done;
    }

////////////////////////////////////////////////////////////////////////
// Common DIB blt

EngBitBlt_It:

    // Our driver doesn't handle any blt's between two DIBs.  Normally
    // a driver doesn't have to worry about this, but we do because
    // we have DFBs that may get moved from off-screen memory to a DIB,
    // where we have GDI do all the drawing.  GDI does DIB drawing at
    // a reasonable speed (unless one of the surfaces is a device-
    // managed surface...)
    //
    // If either the source or destination surface in an EngBitBlt
    // call-back is a device-managed surface (meaning it's not a DIB
    // that GDI can draw with), GDI will automatically allocate memory
    // and call the driver's DrvCopyBits routine to create a DIB copy
    // that it can use.  So this means that this could handle all 'punts',
    // and we could conceivably get rid of bPuntBlt.  But this would have
    // a bad performance impact because of the extra memory allocations
    // and bitmap copies -- you really don't want to do this unless you
    // have to (or your surface was created such that GDI can draw
    // directly onto it) -- I've been burned by this because it's not
    // obvious that the performance impact is so bad.
    //
    // That being said, we only call EngBitBlt when all the surfaces
    // are DIBs:

    return(EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst,
                     pptlSrc, pptlMsk, pbo, pptlBrush, rop4));

All_Done:
    return(TRUE);

}

/******************************Public*Routine******************************\
* BOOL DrvCopyBits
*
* Do fast bitmap copies.
*
* Note that GDI will (usually) automatically adjust the blt extents to
* adjust for any rectangular clipping, so we'll rarely see DC_RECT
* clipping in this routine (and as such, we don't bother special casing
* it).
*
* I'm not sure if the performance benefit from this routine is actually
* worth the increase in code size, since SRCCOPY BitBlts are hardly the
* most common drawing operation we'll get.  But what the heck.
*
\**************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    PDEV*   ppdev;
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    POINTL  ptl;
    OH*     pohSrc;
    OH*     pohDst;

    // DrvCopyBits is a fast-path for SRCCOPY blts.  But it can still be
    // pretty complicated: there can be translates, clipping, RLEs,
    // bitmaps that aren't the same format as the screen, plus
    // screen-to-screen, DIB-to-screen or screen-to-DIB operations,
    // not to mention DFBs (device format bitmaps).
    //
    // Rather than making this routine almost as big as DrvBitBlt, I'll
    // handle here only the speed-critical cases, and punt the rest to
    // our DrvBitBlt routine.
    //
    // We'll try to handle anything that doesn't involve clipping:

    if (((pco  == NULL) || (pco->iDComplexity == DC_TRIVIAL)) &&
        ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        if (psoDst->dhsurf != NULL)
        {
            // We know the destination is either a DFB or the screen:

            ppdev     = (PDEV*)  psoDst->dhpdev;
            pdsurfDst = (DSURF*) psoDst->dhsurf;

            // See if the source is a plain DIB:

            if (psoSrc->dhsurf != NULL)
            {
                pdsurfSrc = (DSURF*) psoSrc->dhsurf;

                // Make sure the destination is really the screen or an
                // off-screen DFB (i.e., not a DFB that we've converted
                // to a DIB):

                if (pdsurfDst->dt == DT_SCREEN)
                {
                    ASSERTDD(psoSrc->dhsurf != NULL, "Can't be a DIB");

                    if (pdsurfSrc->dt == DT_SCREEN)
                    {

                    Screen_To_Screen:

                        //////////////////////////////////////////////////////
                        // Screen-to-screen

                        ASSERTDD((psoSrc->dhsurf != NULL)        &&
                                 (pdsurfSrc->dt == DT_SCREEN)    &&
                                 (psoDst->dhsurf != NULL)        &&
                                 (pdsurfDst->dt == DT_SCREEN),
                                 "Should be a screen-to-screen case");

                        // pfnCopyBlt takes relative coordinates (relative
                        // to the destination surface, that is), so we have
                        // to change the start point to be relative to the
                        // destination surface too:

                        pohSrc = pdsurfSrc->poh;
                        pohDst = pdsurfDst->poh;

                        ptl.x = pptlSrc->x - (pohDst->x - pohSrc->x);
                        ptl.y = pptlSrc->y - (pohDst->y - pohSrc->y);

                        ppdev->xOffset = pohDst->x;
                        ppdev->yOffset = pohDst->y;

                        (ppdev->pfnCopyBlt)(ppdev, 1, prclDst, 0xCCCC, &ptl,
                            prclDst);
                        return(TRUE);
                    }
                    else // (pdsurfSrc->dt != DT_SCREEN)
                    {
                        // Ah ha, the source is a DFB that's really a DIB.

                        ASSERTDD(psoDst->dhsurf != NULL,
                                "Destination can't be a DIB here");

                        /////////////////////////////////////////////////////
                        // Put It Back Into Off-screen?
                        //
                        // We take this opportunity to decide if we want to
                        // put the DIB back into off-screen memory.  This is
                        // a pretty good place to do it because we have to
                        // copy the bits to some portion of the screen,
                        // anyway.  So we would incur only an extra screen-to-
                        // screen blt at this time, much of which will be
                        // over-lapped with the CPU.
                        //
                        // The simple approach we have taken is to move a DIB
                        // back into off-screen memory only if there's already
                        // room -- we won't throw stuff out to make space
                        // (because it's tough to know what ones to throw out,
                        // and it's easy to get into thrashing scenarios).
                        //
                        // Because it takes some time to see if there's room
                        // in off-screen memory, we only check one in
                        // HEAP_COUNT_DOWN times if there's room.  To bias
                        // in favour of bitmaps that are often blt, the
                        // counters are reset every time any space is freed
                        // up in off-screen memory.  We also don't bother
                        // checking if no space has been freed since the
                        // last time we checked for this DIB.

                        if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                        {
                            if (--pdsurfSrc->cBlt == 0)
                            {
                                if (bMoveDibToOffscreenDfbIfRoom(ppdev,
                                                                 pdsurfSrc))
                                    goto Screen_To_Screen;
                            }
                        }
                        else
                        {
                            // Some space was freed up in off-screen memory,
                            // so reset the counter for this DFB:

                            pdsurfSrc->iUniq = ppdev->iHeapUniq;
                            pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                        }

                        // Since the destination is definitely the screen,
                        // we don't have to worry about creating a DIB to
                        // DIB copy case (for which we would have to call
                        // EngCopyBits):

                        psoSrc = pdsurfSrc->pso;

                        goto DIB_To_Screen;
                    }
                }
                else // (pdsurfDst->dt != DT_SCREEN)
                {
                    // Because the source is not a DIB, we don't have to
                    // worry about creating a DIB to DIB case here (although
                    // we'll have to check later to see if the source is
                    // really a DIB that's masquerading as a DFB...)

                    ASSERTDD(psoSrc->dhsurf != NULL,
                             "Source can't be a DIB here");

                    psoDst = pdsurfDst->pso;

                    goto Screen_To_DIB;
                }
            }
            else if (psoSrc->iBitmapFormat == ppdev->iBitmapFormat)
            {
                // Make sure the destination is really the screen:

                if (pdsurfDst->dt == DT_SCREEN)
                {

                DIB_To_Screen:

                    //////////////////////////////////////////////////////
                    // DIB-to-screen

                    ASSERTDD((psoDst->dhsurf != NULL)        &&
                             (pdsurfDst->dt == DT_SCREEN)    &&
                             (psoSrc->dhsurf == NULL)        &&
                             (psoSrc->iBitmapFormat == ppdev->iBitmapFormat),
                             "Should be a DIB-to-screen case");

                    pohDst = pdsurfDst->poh;
                    ppdev->xOffset = pohDst->x;
                    ppdev->yOffset = pohDst->y;

                    ppdev->pfnXferNative(ppdev, 1, prclDst, 0xCCCC, psoSrc,
                                         pptlSrc, prclDst, NULL);
                    return(TRUE);
                }
            }
        }
        else // (psoDst->dhsurf == NULL)
        {

        Screen_To_DIB:

            pdsurfSrc = (DSURF*) psoSrc->dhsurf;
            ppdev     = (PDEV*)  psoSrc->dhpdev;

            if (psoDst->iBitmapFormat == ppdev->iBitmapFormat)
            {
                if (pdsurfSrc->dt == DT_SCREEN)
                {
                    //////////////////////////////////////////////////////
                    // Screen-to-DIB

                    ASSERTDD((psoSrc->dhsurf != NULL)        &&
                             (pdsurfSrc->dt == DT_SCREEN)    &&
                             (psoDst->dhsurf == NULL)        &&
                             (psoDst->iBitmapFormat == ppdev->iBitmapFormat),
                             "Should be a screen-to-DIB case");

                    // vGetBits takes absolute screen coordinates, so we have
                    // to muck with the source point:

                    pohSrc = pdsurfSrc->poh;

                    ptl.x = pptlSrc->x + pohSrc->x;
                    ptl.y = pptlSrc->y + pohSrc->y;

                    vGetBits(ppdev, psoDst, prclDst, &ptl);
                    return(TRUE);
                }
                else
                {
                    // The source is a DFB that's really a DIB.  Since we
                    // know that the destination is a DIB, we've got a DIB
                    // to DIB operation, and should call EngCopyBits:

                    psoSrc = pdsurfSrc->pso;
                    goto EngCopyBits_It;
                }
            }
        }
    }

    // We can't call DrvBitBlt if we've accidentally converted both
    // surfaces to DIBs, because it isn't equipped to handle it:

    ASSERTDD((psoSrc->dhsurf != NULL) ||
             (psoDst->dhsurf != NULL),
             "Accidentally converted both surfaces to DIBs");

    /////////////////////////////////////////////////////////////////
    // A DrvCopyBits is after all just a simplified DrvBitBlt:

    return(DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc, NULL,
                     NULL, NULL, 0x0000CCCC));

EngCopyBits_It:

    ASSERTDD((psoDst->dhsurf == NULL) &&
             (psoSrc->dhsurf == NULL),
             "Both surfaces should be DIBs to call EngCopyBits");

    return(EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

#if DBG

ULONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
    }

    va_end(ap);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\***************************************************************************/

#if DBG

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#define ASSERTDD(x, y) if (!(x)) RIP (y)
#define STATEDBG(level)
#define LOGDBG(arg)

#else

#define DISPDBG(arg)
#define RIP(x)
#define ASSERTDD(x, y)
#define STATEDBG(level)
#define LOGDBG(arg)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\brush.c ===
/******************************Module*Header*******************************\
* Module Name: Brush.c
*
* Handles all brush/pattern initialization and realization.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vRealizeDitherPattern
*
* Generates an 8x8 dither pattern, in our internal realization format, for
* the colour ulRGBToDither.  Note that the high byte of ulRGBToDither does
* not need to be set to zero, because vComputeSubspaces ignores it.
\**************************************************************************/

VOID vRealizeDitherPattern(
RBRUSH*     prb,
ULONG       ulRGBToDither)
{
    ULONG           ulNumVertices;
    VERTEX_DATA     vVertexData[4];
    VERTEX_DATA*    pvVertexData;
    LONG            i;

    // Calculate what colour subspaces are involved in the dither:

    pvVertexData = vComputeSubspaces(ulRGBToDither, vVertexData);

    // Now that we have found the bounding vertices and the number of
    // pixels to dither for each vertex, we can create the dither pattern

    ulNumVertices = (ULONG)(pvVertexData - vVertexData);
                      // # of vertices with more than zero pixels in the dither

    // Do the actual dithering:

    vDitherColor(&prb->aulPattern[0], vVertexData, pvVertexData, ulNumVertices);

    // Initialize the fields we need:

    prb->fl = 0;

    for (i = 0; i < MAX_BOARDS; i++)
    {
        prb->apbe[i] = NULL;
    }
}

/******************************Public*Routine******************************\
* BOOL DrvRealizeBrush
*
* This function allows us to convert GDI brushes into an internal form
* we can use.  It may be called directly by GDI at SelectObject time, or
* it may be called by GDI as a result of us calling BRUSHOBJ_pvGetRbrush
* to create a realized brush in a function like DrvBitBlt.
*
* Note that we have no way of determining what the current Rop or brush
* alignment are at this point.
*
\**************************************************************************/

BOOL DrvRealizeBrush(
BRUSHOBJ*   pbo,
SURFOBJ*    psoDst,
SURFOBJ*    psoPattern,
SURFOBJ*    psoMask,
XLATEOBJ*   pxlo,
ULONG       iHatch)
{
    PDEV*   ppdev;
    ULONG   iPatternFormat;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    BYTE    jSrc;
    LONG    lSrcDelta;
    LONG    cj;
    LONG    i;
    LONG    j;
    RBRUSH* prb;
    ULONG*  pulXlate;
    ULONG   ulColor;

    ppdev = (PDEV*) psoDst->dhpdev;

    // We don't do brushes in high-colour modes on the P9000:

    if (ppdev->flStat & STAT_UNACCELERATED)
        goto ReturnFalse;

    // We have a fast path for dithers when we set GCAPS_DITHERONREALIZE:

    if (iHatch & RB_DITHERCOLOR)
    {
        // Implementing DITHERONREALIZE increased our score on a certain
        // unmentionable benchmark by 0.4 million 'megapixels'.  Too bad
        // this didn't work in the first version of NT.

        prb = BRUSHOBJ_pvAllocRbrush(pbo,
              sizeof(RBRUSH) + (TOTAL_BRUSH_SIZE * ppdev->cjPel));
        if (prb == NULL)
            goto ReturnFalse;

        if (!P9000(ppdev))
        {
            ASSERTDD(ppdev->iBitmapFormat == BMF_8BPP,
                 "GCAPS_COLOR_DITHER shouldn't be set at higher than 8bpp");

            // Oh goody, we get to use the P9100's 4-colour pattern
            // support:

            vRealize4ColorDither(prb, iHatch);
            goto ReturnTrue;
        }
        else
        {
            // We do coloured patterns on the P9000 only at 8bpp, and only
            // if we've successfully managed to allocate an off-screen
            // brush cache:

            if (!(ppdev->flStat & STAT_BRUSH_CACHE))
                goto ReturnFalse;

            vRealizeDitherPattern(prb, iHatch);
            goto ReturnTrue;
        }
    }

    // We only accelerate 8x8 patterns.  Since Win3.1 and Chicago don't
    // support patterns of any other size, it's a safe bet that 99.9%
    // of the patterns we'll ever get will be 8x8:

    if ((psoPattern->sizlBitmap.cx != 8) ||
        (psoPattern->sizlBitmap.cy != 8))
        goto ReturnFalse;

    // At 8bpp, we handle patterns at 1bpp, 4bpp and 8bpp with/without an xlate.
    // At 16bpp, we handle patterns at 1bpp on the P9100.
    // At 32bpp, we handle patterns at 1bpp on the P9100.

    iPatternFormat = psoPattern->iBitmapFormat;

    // We only handle arbitrary color brushes if we have an off-screen
    // brush cache available.

    if ((iPatternFormat != BMF_1BPP) && !(ppdev->flStat & STAT_BRUSH_CACHE))
        goto ReturnFalse;

    if ((iPatternFormat == BMF_1BPP)             ||
        (iPatternFormat == ppdev->iBitmapFormat) ||
        (iPatternFormat == BMF_4BPP) && (ppdev->iBitmapFormat == BMF_8BPP))
    {
        prb = BRUSHOBJ_pvAllocRbrush(pbo,
              sizeof(RBRUSH) + (TOTAL_BRUSH_SIZE * ppdev->cjPel));
        if (prb == NULL)
            goto ReturnFalse;

        // Initialize the fields we need:

        prb->fl = 0;

        for (i = 0; i < MAX_BOARDS; i++)
        {
            prb->apbe[i] = NULL;
        }

        lSrcDelta = psoPattern->lDelta;
        pjSrc     = (BYTE*) psoPattern->pvScan0;
        pjDst     = (BYTE*) &prb->aulPattern[0];

        if (ppdev->iBitmapFormat == iPatternFormat)
        {
            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                DISPDBG((1, "Realizing un-translated brush"));

                // The pattern is the same colour depth as the screen, and
                // there's no translation to be done:

                cj = (8 * ppdev->cjPel);    // Every pattern is 8 pels wide

                for (i = 8; i != 0; i--)
                {
                    RtlCopyMemory(pjDst, pjSrc, cj);

                    pjSrc += lSrcDelta;
                    pjDst += cj;
                }
            }
            else if (ppdev->iBitmapFormat == BMF_8BPP)
            {
                DISPDBG((1, "Realizing 8bpp translated brush"));

                // The screen is 8bpp, and there's translation to be done:

                pulXlate = pxlo->pulXlate;

                for (i = 8; i != 0; i--)
                {
                    for (j = 8; j != 0; j--)
                    {
                        *pjDst++ = (BYTE) pulXlate[*pjSrc++];
                    }

                    pjSrc += lSrcDelta - 8;
                }
            }
            else
            {
                // I don't feel like writing code to handle translations
                // when our screen is 16bpp or higher (although I probably
                // should; we could allocate a temporary buffer and use
                // GDI to convert, like is done in the VGA driver).

                goto ReturnFalse;
            }
        }
        else if (iPatternFormat == BMF_1BPP)
        {
            DISPDBG((1, "Realizing 1bpp brush"));

            // We word align the monochrome bitmap so that every row starts
            // on a new word (so that we can do word writes later to transfer
            // the bitmap):

            for (i = 4; i != 0; i--)
            {
                // The P9000 uses a monochrome 16x16 pattern, but we're
                // given an 8x8 source pattern.  So copy each source row
                // horizontally.
                //
                // This works for the P9100 too, because although it supports
                // only an 8x8 monochrome pattern, it ignores the high byte
                // in every word.

                jSrc   = *pjSrc;
                pjSrc += lSrcDelta;

                // The pattern register we use has little-endian byte ordering:

                *(pjDst    ) = jSrc;
                *(pjDst + 1) = jSrc;

                jSrc   = *pjSrc;
                pjSrc += lSrcDelta;

                *(pjDst + 2) = jSrc;
                *(pjDst + 3) = jSrc;

                pjDst += 4;
            }

            pulXlate = pxlo->pulXlate;
            prb->fl  = RBRUSH_2COLOR;

            // The P9100 require that colours be 'packed' into a dword.
            // We do it here rather than when we go to draw because
            // we may draw using the same brush multiple times...

            PACK_COLOR(ppdev, pulXlate[0], ulColor);
            prb->ulColor[0] = ulColor;

            PACK_COLOR(ppdev, pulXlate[1], ulColor);
            prb->ulColor[1] = ulColor;
        }
        else
        {
            DISPDBG((1, "Realizing 4bpp brush"));

            // The screen is 8bpp and the pattern is 4bpp:

            ASSERTDD((ppdev->iBitmapFormat == BMF_8BPP) &&
                     (iPatternFormat == BMF_4BPP),
                     "Messed up brush logic");

            pulXlate = pxlo->pulXlate;

            for (i = 8; i != 0; i--)
            {
                // Inner loop is repeated only 4 times because each loop
                // handles 2 pixels:

                for (j = 4; j != 0; j--)
                {
                    *pjDst++ = (BYTE) pulXlate[*pjSrc >> 4];
                    *pjDst++ = (BYTE) pulXlate[*pjSrc & 15];
                    pjSrc++;
                }

                pjSrc += lSrcDelta - 4;
            }
        }

ReturnTrue:

        // The last time I checked, GDI took some 500 odd instructions to
        // get from here back to whereever we called 'BRUSHOBJ_pvGetRbrush'.
        // We can at least use this time to get some overlap between the
        // CPU and the display hardware: we'll initialize the 72x72 off-
        // screen cache entry now, which will keep the accelerator busy for
        // a while.

        if (!prb->fl & (RBRUSH_2COLOR | RBRUSH_4COLOR))
        {
            ASSERTDD(ppdev->bEnabled, "Realizing brush when in full-screen?");

            vSlowPatRealize(ppdev, prb);
        }

        return(TRUE);
    }

ReturnFalse:

    if (psoPattern != NULL)
    {
        DISPDBG((1, "Failed realization -- Type: %li Format: %li cx: %li cy: %li",
                    psoPattern->iType, psoPattern->iBitmapFormat,
                    psoPattern->sizlBitmap.cx, psoPattern->sizlBitmap.cy));
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vAssertModeBrushCache
*
* Resets the brush cache when we exit out of full-screen.
\**************************************************************************/

VOID vAssertModeBrushCache(
PDEV*   ppdev,
BOOL    bEnable)
{
    BRUSHENTRY*     pbe;
    CIRCLEENTRY*    pce;
    LONG            i;
    BYTE*           pjBase;

    if (bEnable)
    {
        // Invalidate the brush cache:

        pbe = &ppdev->abe[0];

        for (i = ppdev->cBrushCache; i != 0; i--)
        {
            pbe->prbVerify = NULL;
            pbe++;
        }

        // Invalidate the circle cache:

        pce = &ppdev->ace[0];

        for (i = TOTAL_CIRCLE_COUNT; i != 0; i--)
        {
            pce->rcfxCircle.xLeft  = 0;
            pce->rcfxCircle.xRight = 0;
            pce++;
        }

        // Download our favourite pattern for doing solid fills when
        // running 16bpp on the P9000:

        if ((ppdev->flStat & STAT_UNACCELERATED) &&
            (ppdev->iBitmapFormat == BMF_16BPP))
        {
            pjBase = ppdev->pjBase;

            CP_WAIT(ppdev, pjBase);
            for (i = 0; i < 8; i++)
            {
                CP_PATTERN(ppdev, pjBase, i, 0xAAAAAAAA);
            }

            // Anchor the pattern origin, too:

            CP_PATTERN_ORGX(ppdev, pjBase, 0);
            CP_PATTERN_ORGY(ppdev, pjBase, 0);
        }
    }
}

/******************************Public*Routine******************************\
* BOOL bEnableBrushCache
*
* Allocates off-screen memory for storing the brush cache.
\**************************************************************************/

BOOL bEnableBrushCache(
PDEV*   ppdev)
{
    OH*             poh;        // Points to off-screen chunk of memory
    BRUSHENTRY*     pbe;        // Pointer to the brush-cache entry
    LONG            i;
    LONG            j;
    CIRCLEENTRY*    pce;

    // On the P9000, we draw coloured patterns using screen-to-screen
    // copies.  When a coloured pattern is used, we first expand the
    // 8 x 8 pattern to a 64 x 64 pattern in off-screen memory; we
    // then use this as the basis for our screen-to-screen blts to the
    // target rectangle.  The off-screen 64 x 64 pattern is cached for
    // future use.
    //
    // Coloured patterns are used primarily at 8bpp, for dithers.  The
    // P9100 has direct support for 4-coloured patterns at 8bpp, which
    // allows it to to draw any dithered colours using the hardware
    // (our dithers are always a maximum of 4 colours).  Consequently,
    // we only use the off-screen brush cache on the P9000, and only
    // at 8bpp.

    if (P9000(ppdev) && (ppdev->flStat & STAT_8BPP))
    {
        // Typically, we'll be running at 1024x768x256 on a 1meg board,
        // giving us off-screen memory of the dimension 1024x253 (accounting
        // for the space taken by the hardware pointer).  If we allocate
        // the brush cache as one long one-high row of brushes, the heap
        // manager would shave that amount off the largest chunk of memory
        // we could allocate (meaning the largest bitmap potentially stored
        // in off-screen memory couldn't be larger than 253 - 64 = 189 pels
        // high, but it could be 1024 wide).
        //
        // To make this more square, I want to shave off a left-side chunk
        // for the brush cache, and I want at least 8 brushes cached.
        // Since floor(253/64) = 3, we'll allocate a 3 x 3 cache:

        poh = pohAllocatePermanent(ppdev,
                    SLOW_BRUSH_CACHE_DIM * SLOW_BRUSH_ALLOCATION,
                    SLOW_BRUSH_CACHE_DIM * SLOW_BRUSH_ALLOCATION);

        if (poh == NULL)
            goto ReturnTrue;    // See note about why we can return TRUE...

        ppdev->cBrushCache = SLOW_BRUSH_COUNT;

        pbe = &ppdev->abe[0];       // Points to where we'll put the first brush
                                    //   cache entry
        for (i = 0; i < SLOW_BRUSH_CACHE_DIM; i++)
        {
            for (j = 0; j < SLOW_BRUSH_CACHE_DIM; j++)
            {
                pbe->x = poh->x + (i * SLOW_BRUSH_ALLOCATION);
                pbe->y = poh->y + (j * SLOW_BRUSH_ALLOCATION);
                pbe++;
            }
        }

        // Note that we don't have to remember 'poh' for when we have
        // to disable brushes -- the off-screen heap frees any
        // off-screen heap allocations automatically.

        // We successfully allocated the brush cache, so let's turn
        // on the switch showing that we can use it:

        ppdev->flStat |= STAT_BRUSH_CACHE;
    }

    // Now allocate our circle cache.
    //
    // Note that we don't have to initially mark the entries as invalid,
    // as the ppdev was zero-filled, and so we are assured that every
    // 'rcfxBound' will be {0, 0, 0, 0}, which will never match any
    // circle when looking for a matching entry.

    poh = pohAllocatePermanent(ppdev, CIRCLE_ALLOCATION_CX * TOTAL_CIRCLE_COUNT,
                                      CIRCLE_ALLOCATION_CY);
    if (poh == NULL)
        goto ReturnTrue;

    pce = &ppdev->ace[0];       // Points to where we'll put the first circle
                                //   cache entry
    for (i = 0; i < TOTAL_CIRCLE_COUNT; i++)
    {
        pce->x = poh->x + (i * CIRCLE_ALLOCATION_CX);
        pce->y = poh->y;
        pce++;
    }

    ppdev->flStat |= STAT_CIRCLE_CACHE;

ReturnTrue:

    // Invalidate our caches and initialize our high-colour pattern:

    vAssertModeBrushCache(ppdev, TRUE);

    // If we couldn't allocate a brush cache, it's not a catastrophic
    // failure; patterns will still work, although they'll be a bit
    // slower since they'll go through GDI.  As a result we don't
    // actually have to fail this call:

    DISPDBG((5, "Passed bEnableBrushCache"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableBrushCache
*
* Cleans up anything done in bEnableBrushCache.
\**************************************************************************/

VOID vDisableBrushCache(PDEV* ppdev)
{
    // We ain't gotta do nothin'
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft products
* is prohibited without the expressed written consent of Microsoft Corp.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-7 and 9-15 of the Windows standard (required)
* 16-color palette, where vertices 0-7 are the vertices of the inner color
* cube, and 0 plus 9-15 are the vertices of the full color cube. Vertex 8 is
* 75% gray; this could be used in the dither, but that would break apps that
* depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Note that as a result of the compatibility requirement, the dither
* produced by this algorithm is the exact same dither as that produced
* by the default Windows 3.1 16 color and 256 color VGA drivers.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDword[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.
BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* vComputeSubspaces
*
* Calculates the subspace data associated with rgb, stores the data at
* pvVertexData, in the form of an array of VERTEX_DATA structures,
* suitable for vDitherColor. Returns a pointer to the byte after the
* last VERTEX_DATA structure.
*
* Ignores the high byte of rgb.
*
\**************************************************************************/

VERTEX_DATA* vComputeSubspaces(
ULONG           rgb,
VERTEX_DATA*    pvVertexData)
{
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulSymmetry;
    ULONG   ulRed, ulGre, ulBlu, ulTemp;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;

    // Split the color into red, green, and blue components
    ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
    ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
    ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

    // Sort the RGB so that the point is transformed into subspace 0, and
    // keep track of the swaps in ulSymmetry so we can unravel it again
    // later.  We want r >= g >= b (subspace 0).
    ulSymmetry = 0;
    if (ulBlueTemp > ulRedTemp) {
        SWAPTHEM(ulBlueTemp,ulRedTemp);
        ulSymmetry = SWAP_RB;
    }

    if (ulBlueTemp > ulGreenTemp) {
        SWAPTHEM(ulBlueTemp,ulGreenTemp);
        ulSymmetry |= SWAP_GB;
    }

    if (ulGreenTemp > ulRedTemp) {
        SWAPTHEM(ulGreenTemp,ulRedTemp);
        ulSymmetry |= SWAP_RG;
    }

    ulSymmetry <<= 4;   // for lookup purposes

    // Scale the values from 0-255 to 0-64. Note that the scaling is not
    // symmetric at the ends; this is done to match Windows 3.1 dithering
    ulRed = (ulRedTemp + 1) >> 2;
    ulGre = (ulGreenTemp + 1) >> 2;
    ulBlu = (ulBlueTemp + 1) >> 2;

    // Compute the subsubspace within subspace 0 in which the point lies,
    // then calculate the # of pixels to dither in the colors that are the
    // four vertexes of the tetrahedron bounding the color we're emulating.
    // Only vertices with more than zero pixels are stored, and the
    // vertices are stored in order of increasing intensity, saving us the
    // need to sort them later
    if ((ulRedTemp + ulGreenTemp) > 256) {
        // Subsubspace 2 or 3
        if ((ulRedTemp + ulBlueTemp) > 256) {
            // Subsubspace 3
            // Calculate the number of pixels per vertex, still in
            // subsubspace 3, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 3 is:
            // 7, 9, 0x0B, 0x0F
            if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            ulVertex2Temp = ulGre - ulBlu;
            ulVertex3Temp = (ulRed - 64) + ulBlu;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
            }
        } else {
            // Subsubspace 2
            // Calculate the number of pixels per vertex, still in
            // subsubspace 2, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 2 is:
            // 3, 7, 9, 0x0B
            ulVertex1Temp = ulBlu << 1;
            ulVertex2Temp = ulRed - ulGre;
            ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
            if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex1Temp != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
        }
    } else {
        // Subsubspace 0 or 1
        if (ulRedTemp > 128) {
            // Subsubspace 1
            // Calculate the number of pixels per vertex, still in
            // subsubspace 1, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 1 is:
            // 1, 3, 7, 9
            if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex2Temp = ulBlu << 1;
            ulVertex3Temp = (ulRed - 32) << 1;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
        } else {
            // Subsubspace 0
            // Calculate the number of pixels per vertex, still in
            // subsubspace 0, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 0 is:
            // 0, 1, 3, 7
            if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
            }
            if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex3Temp = ulBlu << 1;
            if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex1Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
        }
    }

    return(pvVertexData);
}

/******************************Public*Routine******************************\
* vDitherColor
*
* Dithers the ulNumVertices vertices described by vVertexData into pulDest.
*
\**************************************************************************/

VOID vDitherColor(
ULONG*          pulDest,
VERTEX_DATA*    vVertexData,
VERTEX_DATA*    pvVertexDataEnd,
ULONG           ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulDitherOrder;
    BYTE    jColor;
    BYTE   *pjDither = (BYTE *)pulDest;

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleToDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDitherOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) ajConvert[pvVertexData->ulVertex];
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        pjDither[*(pulDitherOrder+2)] = jColor;
                    case 2:
                        pjDither[*(pulDitherOrder+1)] = jColor;
                    case 1:
                        pjDither[*(pulDitherOrder+0)] = jColor;
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        pjDither[*pulDitherOrder] = jColor;
                        pjDither[*(pulDitherOrder+1)] = jColor;
                        pjDither[*(pulDitherOrder+2)] = jColor;
                        pjDither[*(pulDitherOrder+3)] = jColor;
                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);

    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) ajConvert[vVertexData[1].ulVertex];
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleToDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) ajConvert[vVertexData[0].ulVertex];
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder;
        }

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                pjDither[*(pulDitherOrder+2)] = jColor;
            case 2:
                pjDither[*(pulDitherOrder+1)] = jColor;
            case 1:
                pjDither[*(pulDitherOrder+0)] = jColor;
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {
                pjDither[*pulDitherOrder] = jColor;
                pjDither[*(pulDitherOrder+1)] = jColor;
                pjDither[*(pulDitherOrder+2)] = jColor;
                pjDither[*(pulDitherOrder+3)] = jColor;
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;
    }
}

/******************************Public*Routine******************************\
* VOID vRealize4ColorDither
*
* Generates an 8x8 dither pattern, into the P9100's 4-colour pattern
* format.  Note that the high byte of ulRGBToDither does not need to
* be set to zero, because vComputeSubspaces ignores it.
\**************************************************************************/

VOID vRealize4ColorDither(
RBRUSH*     prb,
ULONG       ulRGBToDither)
{
    ULONG           ulNumVertices;
    VERTEX_DATA     vVertexData[4];
    VERTEX_DATA*    pvVertexData;
    ULONG           i;
    ULONG*          pulDitherOrder;
    LONG            iMax;
    LONG            iVertex;
    BYTE*           pjPattern;
    LONG            iByte;
    LONG            iBit;

    // Calculate what colour subspaces are involved in the dither:

    pvVertexData = vComputeSubspaces(ulRGBToDither, vVertexData);

    // Now that we have found the bounding vertices and the number of
    // pixels to dither for each vertex, we can create the dither pattern

    ulNumVertices = (ULONG)(pvVertexData - vVertexData);
                      // # of vertices with more than zero pixels in the dither

    // As a bit of an optimization, we find the most common colour
    // and assign that index zero, so that we don't have to 'or'
    // quite so many bits:

    for (iMax = 0, i = 1; i < ulNumVertices; i++)
    {
        if (vVertexData[i].ulCount > vVertexData[iMax].ulCount)
            iMax = i;
    }

    //
    // Colour 0:
    //

    prb->fl = RBRUSH_4COLOR;

    prb->ulColor[0] = ulNibbleToDword[vVertexData[iMax].ulVertex];

    prb->aulPattern[0] = 0;
    prb->aulPattern[1] = 0;
    prb->aulPattern[2] = 0;
    prb->aulPattern[3] = 0;

    if (ulNumVertices > 1)
    {
        iVertex        = 0;
        pjPattern      = (BYTE*) prb->aulPattern;
        pulDitherOrder = aulDitherOrder;

        //
        // Colour 1:
        //

        if (iVertex == iMax)
        {
            pulDitherOrder += vVertexData[iVertex].ulCount;
            iVertex++;
        }
        prb->ulColor[1] = ulNibbleToDword[vVertexData[iVertex].ulVertex];
        for (i = vVertexData[iVertex].ulCount; i != 0; i--)
        {
            iByte = (*pulDitherOrder) >> 3;
            iBit  = (*pulDitherOrder) & 7;
            pulDitherOrder++;
            pjPattern[2 * iByte + 1] |= (0x80 >> iBit);
        }
        iVertex++;

        if (ulNumVertices > 2)
        {
            //
            // Colour 2:
            //

            if (iVertex == iMax)
            {
                pulDitherOrder += vVertexData[iVertex].ulCount;
                iVertex++;
            }
            prb->ulColor[2] = ulNibbleToDword[vVertexData[iVertex].ulVertex];
            for (i = vVertexData[iVertex].ulCount; i != 0; i--)
            {
                iByte = (*pulDitherOrder) >> 3;
                iBit  = (*pulDitherOrder) & 7;
                pulDitherOrder++;
                pjPattern[2 * iByte] |= (0x80 >> iBit);
            }
            iVertex++;

            if (ulNumVertices > 3)
            {
                //
                // Colour 3:
                //

                if (iVertex == iMax)
                {
                    pulDitherOrder += vVertexData[iVertex].ulCount;
                    iVertex++;
                }
                prb->ulColor[3] = ulNibbleToDword[vVertexData[iVertex].ulVertex];
                for (i = vVertexData[iVertex].ulCount; i != 0; i--)
                {
                    iByte = (*pulDitherOrder) >> 3;
                    iBit  = (*pulDitherOrder) & 7;
                    pulDitherOrder++;
                    pjPattern[2 * iByte    ] |= (0x80 >> iBit);
                    pjPattern[2 * iByte + 1] |= (0x80 >> iBit);
                }
            }
        }
    }
}

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA
* colours.
*
\**************************************************************************/

ULONG DrvDitherColor(
DHPDEV  dhpdev,
ULONG   iMode,
ULONG   rgb,
ULONG*  pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;

    // Figure out if we need a full color dither or only a monochrome dither.

    // Note: we'll get colour dithers only at 8bpp, because that's the
    //       only colour depth at which we set GCAPS_COLOR_DITHER.

    if (iMode != DM_MONOCHROME)
    {
        // Full color dither

        // Calculate what color subspaces are involved in the dither
        pvVertexData = vComputeSubspaces(rgb, vVertexData);

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = (ULONG)(pvVertexData - vVertexData); // # of vertices with more than
                                                //  zero pixels in the dither

        vDitherColor(pul, vVertexData, pvVertexData, ulTemp);
    }
    else
    {
        // Note: we can get monochrome dithers at any colour depth because
        //       we always set GCAPS_MONO_DITHER.

        // For monochrome we will only use the Intensity (grey level)

        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\driver.h ===
/******************************Module*Header*******************************\
* Module Name: driver.h
*
* Contains prototypes for the display driver.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

//////////////////////////////////////////////////////////////////////
// Put all the conditional-compile constants here.  There had better
// not be many!

// Multi-board support can be enabled by setting this to 1:

#define MULTI_BOARDS            0

// This is the maximum number of boards we'll support in a single
// virtual driver:

#if MULTI_BOARDS
    #define MAX_BOARDS          16
    #define IBOARD(ppdev)       ((ppdev)->iBoard)
#else
    #define MAX_BOARDS          1
    #define IBOARD(ppdev)       0
#endif

// Useful for visualizing the 2-d heap:

#define DEBUG_HEAP              0

//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#define DLL_NAME                L"Weitekp9" // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "Weitek: "  // All debug output is prefixed
                                            //   by this string
#define ALLOC_TAG               '9pwD'      // Dwp9
                                            // Four byte tag (characters in
                                            // reverse order) used for memory
                                            // allocations

#define CLIP_LIMIT          50  // We'll be taking 800 bytes of stack space

#define DRIVER_EXTRA_SIZE   0   // Size of the DriverExtra information in the
                                //   DEVMODE structure

#define TMP_BUFFER_SIZE     8192  // Size in bytes of 'pvTmpBuffer'.  Has to
                                  //   be at least enough to store an entire
                                  //   scan line (i.e., 6400 for 1600x1200x32).

#if defined(ALPHA)
    #define XFER_BUFFERS    16  // Defines the maximum number of write buffers
                                //   possible on any Alpha.  Must be a power
#else                           //   of two.
    #define XFER_BUFFERS    1   // On non-alpha systems, we don't have to
                                //   worry about the chip caching our bus
#endif                          //   writes.

#define XFER_MASK           (XFER_BUFFERS - 1)

typedef struct _CLIPENUM {
    LONG    c;
    RECTL   arcl[CLIP_LIMIT];   // Space for enumerating complex clipping

} CLIPENUM;                         /* ce, pce */

typedef struct _PDEV PDEV;      // Handy forward declaration

VOID vSetClipping(PDEV*, RECTL*);
VOID vResetClipping(PDEV*);
VOID vPutBits(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vGetBits(PDEV*, SURFOBJ*, RECTL*, POINTL*);

////////////////////////////////////////////////////////////////////////
// Status flags

typedef enum {
    STAT_P9000              = 0x0001,   // P9000 running (as opposed to a P9100)
    STAT_UNACCELERATED      = 0x0002,   // P9000 running at 16bpp or higher
    STAT_8BPP               = 0x0004,   // Running at 8bpp
    STAT_16BPP              = 0x0008,   // Running at 16bpp
    STAT_24BPP              = 0x0010,   // Running at 24bpp
    STAT_BRUSH_CACHE        = 0x0020,   // Brush cache successfully allocated
    STAT_CIRCLE_CACHE       = 0x0040,   // Circle cache successfully allocated
} STATUS;

// P9000() returns TRUE if running on a P9000:

#define P9000(ppdev) (ppdev->flStat & STAT_P9000)

//////////////////////////////////////////////////////////////////////
// DriverSpecificAttributeFlags
//
// These flags must match those defined in p9.h for the weitekp9 miniport
//

#define CAPS_WEITEK_CHIPTYPE_IS_P9000 0x0001  // The video card has a p9000

//////////////////////////////////////////////////////////////////////
// Text stuff

BOOL bEnableText(PDEV*);
VOID vDisableText(PDEV*);
VOID vAssertModeText(PDEV*, BOOL);

//////////////////////////////////////////////////////////////////////
// Brush stuff

// 'Slow' brushes are used when we don't have hardware pattern capability,
// and we have to handle patterns using screen-to-screen blts:

#define SLOW_BRUSH_CACHE_DIM    3   // Controls the number of brushes cached
                                    //   in off-screen memory, when we don't
                                    //   have hardware pattern support.
                                    //   We allocate 3 x 3 brushes, so we can
                                    //   cache a total of 9 brushes:
#define SLOW_BRUSH_COUNT        (SLOW_BRUSH_CACHE_DIM * SLOW_BRUSH_CACHE_DIM)
#define SLOW_BRUSH_DIMENSION    64  // After alignment is taken care of,
                                    //   every off-screen brush cache entry
                                    //   will be 64 pels in both dimensions
#define SLOW_BRUSH_ALLOCATION   (SLOW_BRUSH_DIMENSION + 8)
                                    // Actually allocate 72x72 pels for each
                                    //   pattern, using the 8 extra for brush
                                    //   alignment

#define RBRUSH_2COLOR           1   // Monochrome brush
#define RBRUSH_4COLOR           2   // 4-colour brush

#define TOTAL_BRUSH_COUNT       SLOW_BRUSH_COUNT
                                    // This is the maximum number of brushes
                                    //   we can possibly have cached off-screen
#define TOTAL_BRUSH_SIZE        64  // We'll only ever handle 8x8 patterns,
                                    //   and this is the number of pels

typedef struct _BRUSHENTRY BRUSHENTRY;

// NOTE: Changes to the RBRUSH or BRUSHENTRY structures must be reflected
//       in strucs.inc!

typedef struct _RBRUSH {
    FLONG       fl;             // Type flags
    ULONG       ulColor[4];     // 0 -- background colour if 2-colour brush
                                // 1 -- foreground colour if 2-colour brush
                                // 2 -- 3rd colour if 4-colour brush
                                // 3 -- 4th colour if 4-colour brush
    BRUSHENTRY* apbe[MAX_BOARDS];// Points to brush-entry that keeps track
                                //   of the cached off-screen brush bits
    ULONG       aulPattern[1];  // Open-ended array for keeping copy of the
      // Don't put anything     //   actual pattern bits in case the brush
      //   after here, or       //   origin changes, or someone else steals
      //   you'll be sorry!     //   our brush entry (declared as a ULONG
                                //   for proper dword alignment)

} RBRUSH;                           /* rb, prb */

typedef struct _BRUSHENTRY {
    RBRUSH*     prbVerify;      // We never dereference this pointer to
                                //   find a brush realization; it is only
                                //   ever used in a compare to verify
                                //   that for a given realized brush, our
                                //   off-screen brush entry is still valid.
    LONG        x;              // x-position of cached pattern
    LONG        y;              // y-position of cached pattern

} BRUSHENTRY;                       /* be, pbe */

typedef union _RBRUSH_COLOR {
    RBRUSH*     prb;
    ULONG       iSolidColor;
} RBRUSH_COLOR;                     /* rbc, prbc */

#define CIRCLE_DIMENSION        32  // Maximum size of a cached circle
#define CIRCLE_ALLOCATION_CX    (CIRCLE_DIMENSION + 4)
#define CIRCLE_ALLOCATION_CY    (CIRCLE_DIMENSION)
                                    // Actually allocate 36x32 pels for each
                                    //   circle, using the 4 extra for dword
                                    //   alignment
#define TOTAL_CIRCLE_COUNT      4   // Number of cached circles

typedef struct _CIRCLEENTRY {
    LONG        x;              // x-position of off-screen circle allocation
    LONG        y;              // y-position of off-screen circle allocation
    LONG        xCached;        // x-position in allocation where circle starts
    LONG        yCached;        // y-position in allocation where circle starts
    RECTFX      rcfxCircle;     // Normalized bound-box of circle
    BOOL        bStroke;        // TRUE if stroked, FALSE if filled
} CIRCLEENTRY;

VOID vSlowPatRealize(PDEV*, RBRUSH*);

BOOL bEnableBrushCache(PDEV*);
VOID vDisableBrushCache(PDEV*);
VOID vAssertModeBrushCache(PDEV*, BOOL);

//////////////////////////////////////////////////////////////////////
// Stretch stuff

typedef struct _STR_BLT {
    PDEV*   ppdev;
    PBYTE   pjSrcScan;
    LONG    lDeltaSrc;
    LONG    XSrcStart;
    PBYTE   pjDstScan;
    LONG    lDeltaDst;
    LONG    XDstStart;
    LONG    XDstEnd;
    LONG    YDstStart;
    LONG    YDstCount;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
} STR_BLT;

typedef VOID (*PFN_DIRSTRETCH)(STR_BLT*);

VOID vDirectStretch8Narrow(STR_BLT*);
VOID vDirectStretch8(STR_BLT*);
VOID vDirectStretch16(STR_BLT*);
VOID vDirectStretch32(STR_BLT*);

//////////////////////////////////////////////////////////////////////
// Dither stuff

// Describes a single colour tetrahedron vertex for dithering:

typedef struct _VERTEX_DATA {
    ULONG ulCount;              // Number of pixels in this vertex
    ULONG ulVertex;             // Vertex number
} VERTEX_DATA;                      /* vd, pv */

VERTEX_DATA*    vComputeSubspaces(ULONG, VERTEX_DATA*);
VOID            vDitherColor(ULONG*, VERTEX_DATA*, VERTEX_DATA*, ULONG);
VOID            vRealize4ColorDither(RBRUSH*, ULONG);

/////////////////////////////////////////////////////////////////////////
// Heap stuff

typedef enum {
    OFL_INUSE       = 1,    // The device bitmap is no longer located in
                            //   off-screen memory; it's been converted to
                            //   a DIB
    OFL_AVAILABLE   = 2,    // Space is in-use
    OFL_PERMANENT   = 4     // Space is available
} OHFLAGS;                  // Space is permanently allocated; never free it

typedef struct _DSURF DSURF;
typedef struct _OH OH;
typedef struct _OH
{
    OHFLAGS  ofl;           // OH_ flags
    LONG     x;             // x-coordinate of left edge of allocation
    LONG     y;             // y-coordinate of top edge of allocation
    LONG     cx;            // Width in pixels of allocation
    LONG     cy;            // Height in pixels of allocation
    OH*      pohNext;       // When OFL_AVAILABLE, points to the next free node,
                            //   in ascending cxcy value.  This is kept as a
                            //   circular doubly-linked list with a sentinel
                            //   at the end.
                            // When OFL_INUSE, points to the next most recently
                            //   blitted allocation.  This is kept as a circular
                            //   doubly-linked list so that the list can be
                            //   quickly be updated on every blt.
    OH*      pohPrev;       // Opposite of 'pohNext'
    ULONG    cxcy;          // Width and height in a dword for searching
    OH*      pohLeft;       // Adjacent allocation when in-use or available
    OH*      pohUp;
    OH*      pohRight;
    OH*      pohDown;
    DSURF*   pdsurf;        // Points to our DSURF structure
    VOID*    pvScan0;       // Points to start of first scan-line
};                              /* oh, poh */

// This is the smallest structure used for memory allocations:

typedef struct _OHALLOC OHALLOC;
typedef struct _OHALLOC
{
    OHALLOC* pohaNext;
    OH       aoh[1];
} OHALLOC;                      /* oha, poha */

typedef struct _HEAP
{
    LONG     cxMax;         // Largest possible free space by area
    LONG     cyMax;
    OH       ohAvailable;   // Head of available list (pohNext points to
                            //   smallest available rectangle, pohPrev
                            //   points to largest available rectangle,
                            //   sorted by cxcy)
    OH       ohDfb;         // Head of the list of all DFBs currently in
                            //   offscreen memory that are eligible to be
                            //   tossed out of the heap (pohNext points to
                            //   the most recently blitted; pohPrev points
                            //   to least recently blitted)
    OH*      pohFreeList;   // List of OH node data structures available
    OHALLOC* pohaChain;     // Chain of allocations
} HEAP;                         /* heap, pheap */

typedef enum {
    DT_SCREEN,              // Surface is kept in screen memory
    DT_DIB                  // Surface is kept as a DIB
} DSURFTYPE;                    /* dt, pdt */

typedef struct _DSURF
{
    DSURFTYPE dt;           // DSURF status (whether off-screen or in a DIB)
    SIZEL     sizl;         // Size of the original bitmap (could be smaller
                            //   than poh->sizl)
    PDEV*     ppdev;        // Need this for deleting the bitmap
    union {
        OH*         poh;    // If DT_SCREEN, points to off-screen heap node
        SURFOBJ*    pso;    // If DT_DIB, points to locked GDI surface
    };

    // The following are used for DT_DIB only...

    ULONG     cBlt;         // Counts down the number of blts necessary at
                            //   the current uniqueness before we'll consider
                            //   putting the DIB back into off-screen memory
    ULONG     iUniq;        // Tells us whether there have been any heap
                            //   'free's since the last time we looked at
                            //   this DIB

} DSURF;                          /* dsurf, pdsurf */

// GDI expects dword alignment for any bitmaps on which it is expected
// to draw.  Since we occasionally ask GDI to draw directly on our off-
// screen bitmaps, this means that any off-screen bitmaps must be dword
// aligned in the frame buffer.  We enforce this merely by ensuring that
// all off-screen bitmaps are four-pel aligned (we may waste a couple of
// pixels at the higher colour depths):

#define HEAP_X_ALIGNMENT    4

// Number of blts necessary before we'll consider putting a DIB DFB back
// into off-screen memory:

#define HEAP_COUNT_DOWN     6

// Flags for 'pohAllocate':

typedef enum {
    FLOH_ONLY_IF_ROOM       = 0x00000001,   // Don't kick stuff out of off-
                                            //   screen memory to make room
} FLOH;

BOOL bEnableOffscreenHeap(PDEV*);
VOID vDisableOffscreenHeap(PDEV*);
BOOL bAssertModeOffscreenHeap(PDEV*, BOOL);

OH*  pohMoveOffscreenDfbToDib(PDEV*, OH*);
BOOL bMoveDibToOffscreenDfbIfRoom(PDEV*, DSURF*);
OH*  pohAllocatePermanent(PDEV*, LONG, LONG);
BOOL bMoveAllDfbsFromOffscreenToDibs(PDEV* ppdev);

/////////////////////////////////////////////////////////////////////////
// Pointer stuff

BOOL bEnablePointer(PDEV*);
VOID vDisablePointer(PDEV*);
VOID vAssertModePointer(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Palette stuff

BOOL bEnablePalette(PDEV*);
VOID vDisablePalette();
VOID vAssertModePalette(PDEV*, BOOL);

BOOL bInitializePalette(PDEV*, DEVINFO*);
VOID vUninitializePalette(PDEV*);

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

//////////////////////////////////////////////////////////////////////
// Low-level blt function prototypes

typedef VOID (FNFILL)(PDEV*, LONG, RECTL*, ULONG, RBRUSH_COLOR, POINTL*);
typedef VOID (FNXFER)(PDEV*, LONG, RECTL*, ULONG, SURFOBJ*, POINTL*,
                      RECTL*, XLATEOBJ*);
typedef VOID (FNCOPY)(PDEV*, LONG, RECTL*, ULONG, POINTL*, RECTL*);
typedef BOOL (FNFASTFILL)(PDEV*, LONG, POINTFIX*, ULONG, ULONG, RBRUSH*, POINTL*);

FNFILL              vFillPat;
FNFILL              vFillSolid;
FNFILL              vFillSolidP9000HighColor;
FNXFER              vXfer1bpp;
FNXFER              vXfer4bpp;
FNXFER              vXferNative;
FNCOPY              vCopyBlt;
FNFASTFILL          bFastFill;

////////////////////////////////////////////////////////////////////////
// Capabilities flags
//
// These are private flags passed to us from the miniport.  They
// come from the high word of the 'AttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to us via an 'VIDEO_QUERY_AVAIL_MODES' or 'VIDEO_QUERY_CURRENT_MODE'
// IOCTL.
//
// NOTE: These definitions must match those in the miniport's header!

typedef enum {
} CAPS;

////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
    LONG        xOffset;
    LONG        yOffset;
    BYTE*       pjBase;                 // Points to coprocessor base address
    BYTE*       pjScreen;               // Points to base screen address
    LONG        lDelta;                 // Distance from one scan to the next.
    LONG        iBoard;                 // Logical multi-board identifier
                                        //   (zero by default)
    ULONG       iBitmapFormat;          // BMF_8BPP, BMF_16BPP, BMF_24BPP or
                                        //   BMF_32BPP (our current colour
                                        //   depth)
    VOID*       pvTmpBuffer;            // General purpose temporary buffer,
                                        //   TMP_BUFFER_SIZE bytes in size
                                        //   (Remember to synchronize if you
                                        //   use this for device bitmaps or
                                        //   async pointers)
    // -------------------------------------------------------------------
    // NOTE: Changes up to here in the PDEV structure must be reflected in
    // i386\strucs.inc (assuming you're on an x86, of course)!

    BOOL        bEnabled;               // In graphics mode (not full-screen)
    CAPS        flCaps;                 // Capabilities flags
    STATUS      flStat;                 // Status flags
    LONG        cjScreen;               // Screen size in bytes

    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfScreen;            // Engine's handle to screen surface
    DSURF*      pdsurfScreen;           // Our private DSURF for the screen

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    LONG        cxMemory;               // Width of Video RAM
    LONG        cyMemory;               // Height of Video RAM
    LONG        cBitsPerPel;            // Bits per pel (8, 15, 16, 24 or 32)
    ULONG       ulMode;                 // Mode the mini-port driver is in.

    FLONG       flHooks;                // What we're hooking from GDI
    LONG        cjPel;                  // Number of bytes per pel
    ULONG       ulWhite;                // 0xff if 8bpp, 0xffff if 16bpp,
                                        //   0xffffffff if 32bpp
    UCHAR*      pucCsrBase;             // Mapped IO port base for this PDEV

    ////////// Low-level blt function pointers:

    FNFILL*     pfnFillSolid;
    FNFILL*     pfnFillPat;
    FNXFER*     pfnXfer1bpp;
    FNXFER*     pfnXfer4bpp;
    FNXFER*     pfnXferNative;
    FNCOPY*     pfnCopyBlt;

    ////////// Palette stuff:

    PALETTEENTRY* pPal;                 // The palette if palette managed
    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    FLONG       flRed;                  // Red mask for 16/32bpp bitfields
    FLONG       flGreen;                // Green mask for 16/32bpp bitfields
    FLONG       flBlue;                 // Blue mask for 16/32bpp bitfields
    ULONG       cPaletteShift;          // number of bits the 8-8-8 palette must
                                        // be shifted by to fit in the hardware
                                        // palette.
    ////////// Heap stuff:

    HEAP        heap;                   // All our off-screen heap data
    ULONG       iHeapUniq;              // Incremented every time room is freed
                                        //   in the off-screen heap
    SURFOBJ*    psoPunt;                // Wrapper surface for having GDI draw
                                        //   on off-screen bitmaps
    SURFOBJ*    psoPunt2;               // Another one for off-screen to off-
                                        //   screen blts
    OH*         pohScreen;              // Off-screen heap structure for the
                                        //   visible screen

    ////////// Pointer stuff:

    ULONG       cjPointerAttributes;    // Size of pPointerAttributes buffer
    BOOL        bHwPointerActive;       // Currently using the h/w pointer?
    POINTL      ptlHotSpot;             // For remembering pointer hot spot
    VIDEO_POINTER_CAPABILITIES  PointerCapabilities;
    VIDEO_POINTER_ATTRIBUTES*   pPointerAttributes;

    ////////// Brush stuff:

    LONG        iBrushCache;            // Index for next brush to be allocated
    LONG        cBrushCache;            // Total number of brushes cached
    BRUSHENTRY  abe[TOTAL_BRUSH_COUNT]; // Keeps track of brush cache
    LONG        iCircleCache;           // Index for next circle to be allocated
    CIRCLEENTRY ace[TOTAL_CIRCLE_COUNT];// Keeps track of circle cache

} PDEV, *PPDEV;

/////////////////////////////////////////////////////////////////////////
// Miscellaneous prototypes:

BOOL bIntersect(RECTL*, RECTL*, RECTL*);
LONG cIntersect(RECTL*, RECTL*, LONG);
DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION*, DWORD*);

BOOL bInitializeModeFields(PDEV*, GDIINFO*, DEVINFO*, DEVMODEW*);

BOOL bEnableHardware(PDEV*);
VOID vDisableHardware(PDEV*);
BOOL bAssertModeHardware(PDEV*, BOOL);

extern BYTE gaRop3FromMix[];
extern BYTE gabMixNeedsPattern[];
extern BYTE gabRopNeedsPattern[];
extern ULONG gaulP9000OpaqueFromRop2[];
extern ULONG gaulP9000TransparentFromRop2[];

/////////////////////////////////////////////////////////////////////////
// The x86 C compiler insists on making a divide and modulus operation
// into two DIVs, when it can in fact be done in one.  So we use this
// macro.
//
// Note: QUOTIENT_REMAINDER implicitly takes unsigned arguments.

#if defined(i386)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#endif

/////////////////////////////////////////////////////////////////////////
// OVERLAP - Returns TRUE if the same-size lower-right exclusive
//           rectangles defined by 'pptl' and 'prcl' overlap:

#define OVERLAP(prcl, pptl)                                             \
    (((prcl)->right  > (pptl)->x)                                   &&  \
     ((prcl)->bottom > (pptl)->y)                                   &&  \
     ((prcl)->left   < ((pptl)->x + (prcl)->right - (prcl)->left))  &&  \
     ((prcl)->top    < ((pptl)->y + (prcl)->bottom - (prcl)->top)))

//////////////////////////////////////////////////////////////////////
// These Mul prototypes are thunks for multi-board support:

ULONG   MulGetModes(HANDLE, ULONG, DEVMODEW*);
DHPDEV  MulEnablePDEV(DEVMODEW*, PWSTR, ULONG, HSURF*, ULONG, ULONG*,
                      ULONG, DEVINFO*, HDEV, PWSTR, HANDLE);
VOID    MulCompletePDEV(DHPDEV, HDEV);
HSURF   MulEnableSurface(DHPDEV);
BOOL    MulStrokePath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, XFORMOBJ*, BRUSHOBJ*,
                      POINTL*, LINEATTRS*, MIX);
BOOL    MulFillPath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*,
                    MIX, FLONG);
BOOL    MulBitBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                  RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);
VOID    MulDisablePDEV(DHPDEV);
VOID    MulDisableSurface(DHPDEV);
BOOL    MulAssertMode(DHPDEV, BOOL);
VOID    MulMovePointer(SURFOBJ*, LONG, LONG, RECTL*);
ULONG   MulSetPointerShape(SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*, LONG,
                           LONG, LONG, LONG, RECTL*, FLONG);
ULONG   MulDitherColor(DHPDEV, ULONG, ULONG, ULONG*);
BOOL    MulSetPalette(DHPDEV, PALOBJ*, FLONG, ULONG, ULONG);
BOOL    MulCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);
BOOL    MulTextOut(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, RECTL*,
                   BRUSHOBJ*, BRUSHOBJ*, POINTL*, MIX);
VOID    MulDestroyFont(FONTOBJ*);
BOOL    MulPaint(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*, MIX);
BOOL    MulRealizeBrush(BRUSHOBJ*, SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*,
                        ULONG);
HBITMAP MulCreateDeviceBitmap(DHPDEV, SIZEL, ULONG);
VOID    MulDeleteDeviceBitmap(DHSURF);
BOOL    MulStretchBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                      COLORADJUSTMENT*, POINTL*, RECTL*, RECTL*, POINTL*,
                      ULONG);
VOID    MulSynchronize(DHPDEV, RECTL*);

// These Dbg prototypes are thunks for debugging:

ULONG   DbgGetModes(HANDLE, ULONG, DEVMODEW*);
DHPDEV  DbgEnablePDEV(DEVMODEW*, PWSTR, ULONG, HSURF*, ULONG, ULONG*,
                      ULONG, DEVINFO*, HDEV, PWSTR, HANDLE);
VOID    DbgCompletePDEV(DHPDEV, HDEV);
HSURF   DbgEnableSurface(DHPDEV);
BOOL    DbgStrokePath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, XFORMOBJ*, BRUSHOBJ*,
                      POINTL*, LINEATTRS*, MIX);
BOOL    DbgFillPath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*,
                    MIX, FLONG);
BOOL    DbgBitBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                  RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);
VOID    DbgDisablePDEV(DHPDEV);
VOID    DbgDisableSurface(DHPDEV);
BOOL    DbgAssertMode(DHPDEV, BOOL);
VOID    DbgMovePointer(SURFOBJ*, LONG, LONG, RECTL*);
ULONG   DbgSetPointerShape(SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*, LONG,
                           LONG, LONG, LONG, RECTL*, FLONG);
ULONG   DbgDitherColor(DHPDEV, ULONG, ULONG, ULONG*);
BOOL    DbgSetPalette(DHPDEV, PALOBJ*, FLONG, ULONG, ULONG);
BOOL    DbgCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);
BOOL    DbgTextOut(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, RECTL*,
                   BRUSHOBJ*, BRUSHOBJ*, POINTL*, MIX);
VOID    DbgDestroyFont(FONTOBJ*);
BOOL    DbgPaint(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*, MIX);
BOOL    DbgRealizeBrush(BRUSHOBJ*, SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*,
                        ULONG);
HBITMAP DbgCreateDeviceBitmap(DHPDEV, SIZEL, ULONG);
VOID    DbgDeleteDeviceBitmap(DHSURF);
BOOL    DbgStretchBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                      COLORADJUSTMENT*, POINTL*, RECTL*, RECTL*, POINTL*,
                      ULONG);
VOID    DbgSynchronize(DHPDEV, RECTL*);
ULONG   DbgEscape(SURFOBJ*, ULONG, ULONG, VOID*, ULONG, VOID*);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\blt.c ===
/******************************Module*Header*******************************\
* Module Name: blt.c
*
* Contains the low-level in/out blt functions.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Table********************************\
* BYTE gaulP9000OpaqueFromRop2[]
*
* Convert an opaque Rop2 to a P9000 minterm.
*
\**************************************************************************/

#define P9000_P       ((P9000_S & P9000_F) | (~P9000_S & P9000_B))
#define P9000_DSo     (P9000_S | P9000_D)
#define P9000_DSna    (~P9000_S & P9000_D)

ULONG gaulP9000OpaqueFromRop2[] = {
    (0                   ) & 0xFFFF, // 0  -- 0
    (~(P9000_P | P9000_D)) & 0xFFFF, // 1  -- DPon
    (~P9000_P & P9000_D  ) & 0xFFFF, // 2  -- DPna
    (~P9000_P            ) & 0xFFFF, // 3  -- Pn
    (~P9000_D & P9000_P  ) & 0xFFFF, // 4  -- PDna
    (~P9000_D            ) & 0xFFFF, // 5  -- Dn
    (P9000_D ^ P9000_P   ) & 0xFFFF, // 6  -- DPx
    (~(P9000_P & P9000_D)) & 0xFFFF, // 7  -- DPan
    (P9000_P & P9000_D   ) & 0xFFFF, // 8  -- DPa
    (~(P9000_P ^ P9000_D)) & 0xFFFF, // 9  -- DPxn
    (P9000_D             ) & 0xFFFF, // 10 -- D
    (~P9000_P | P9000_D  ) & 0xFFFF, // 11 -- DPno
    (P9000_P             ) & 0xFFFF, // 12 -- P
    (~P9000_D | P9000_P  ) & 0xFFFF, // 13 -- PDno
    (P9000_P | P9000_D   ) & 0xFFFF, // 14 -- DPo
    (~0                  ) & 0xFFFF, // 15 -- 1
};

/******************************Public*Table********************************\
* BYTE gaulP9000TransparentFromRop2[]
*
* Convert a transparent Rop2 to a P9000 minterm.
*
\**************************************************************************/

ULONG gaulP9000TransparentFromRop2[] = {
    (((0                   ) & P9000_DSo) | P9000_DSna) & 0xFFFF, // 0  -- 0
    (((~(P9000_P | P9000_D)) & P9000_DSo) | P9000_DSna) & 0xFFFF, // 1  -- DPon
    (((~P9000_P & P9000_D  ) & P9000_DSo) | P9000_DSna) & 0xFFFF, // 2  -- DPna
    (((~P9000_P            ) & P9000_DSo) | P9000_DSna) & 0xFFFF, // 3  -- Pn
    (((~P9000_D & P9000_P  ) & P9000_DSo) | P9000_DSna) & 0xFFFF, // 4  -- PDna
    (((~P9000_D            ) & P9000_DSo) | P9000_DSna) & 0xFFFF, // 5  -- Dn
    (((P9000_D ^ P9000_P   ) & P9000_DSo) | P9000_DSna) & 0xFFFF, // 6  -- DPx
    (((~(P9000_P & P9000_D)) & P9000_DSo) | P9000_DSna) & 0xFFFF, // 7  -- DPan
    (((P9000_P & P9000_D   ) & P9000_DSo) | P9000_DSna) & 0xFFFF, // 8  -- DPa
    (((~(P9000_P ^ P9000_D)) & P9000_DSo) | P9000_DSna) & 0xFFFF, // 9  -- DPxn
    (((P9000_D             ) & P9000_DSo) | P9000_DSna) & 0xFFFF, // 10 -- D
    (((~P9000_P | P9000_D  ) & P9000_DSo) | P9000_DSna) & 0xFFFF, // 11 -- DPno
    (((P9000_P             ) & P9000_DSo) | P9000_DSna) & 0xFFFF, // 12 -- P
    (((~P9000_D | P9000_P  ) & P9000_DSo) | P9000_DSna) & 0xFFFF, // 13 -- PDno
    (((P9000_P | P9000_D   ) & P9000_DSo) | P9000_DSna) & 0xFFFF, // 14 -- DPo
    (((~0                  ) & P9000_DSo) | P9000_DSna) & 0xFFFF, // 15 -- 1
};

/******************************Public*Routine******************************\
* VOID vFillSolid
*
* Fills a list of rectangles with a solid colour.
*
\**************************************************************************/

VOID vFillSolid(                // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           ulHwMix,        // Hardware mix mode
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used
{
    BYTE*   pjBase;

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    pjBase = ppdev->pjBase;

    CP_METARECT(ppdev, pjBase, prcl->left, prcl->top);
    CP_METARECT(ppdev, pjBase, prcl->right, prcl->bottom);

    CP_WAIT(ppdev, pjBase);
    if (P9000(ppdev))
    {
        CP_BACKGROUND(ppdev, pjBase, rbc.iSolidColor);
        CP_RASTER(ppdev, pjBase, ulHwMix);
    }
    else
    {
        CP_COLOR0(ppdev, pjBase, rbc.iSolidColor);
        CP_RASTER(ppdev, pjBase, ulHwMix & 0xff);
    }

    CP_START_QUAD(ppdev, pjBase);

    while (prcl++, --c)
    {
        CP_METARECT(ppdev, pjBase, prcl->left, prcl->top);
        CP_METARECT(ppdev, pjBase, prcl->right, prcl->bottom);
        CP_START_QUAD_WAIT(ppdev, pjBase);
    }
}

/******************************Public*Routine******************************\
* VOID vSlowPatRealize
*
* This routine transfers an 8x8 pattern to off-screen display memory, and
* duplicates it to make a 64x64 cached realization which is then used by
* vFillPatSlow as the basic building block for doing 'slow' pattern output
* via repeated screen-to-screen blts.
*
\**************************************************************************/

VOID vSlowPatRealize(
PDEV*   ppdev,
RBRUSH* prb)                    // Points to brush realization structure
{
    BYTE*       pjBase;
    LONG        cjPel;
    BRUSHENTRY* pbe;
    LONG        iBrushCache;
    LONG        x;
    LONG        y;
    ULONG*      pulSrc;
    LONG        i;

    ASSERTDD(!(prb->fl & (RBRUSH_2COLOR | RBRUSH_4COLOR)),
             "Shouldn't realize hardware brushes");

    pbe = prb->apbe[IBOARD(ppdev)];
    if ((pbe == NULL) || (pbe->prbVerify != prb))
    {
        // We have to allocate a new off-screen cache brush entry for
        // the brush:

        iBrushCache = ppdev->iBrushCache;
        pbe         = &ppdev->abe[iBrushCache];

        iBrushCache++;
        if (iBrushCache >= ppdev->cBrushCache)
            iBrushCache = 0;

        ppdev->iBrushCache = iBrushCache;

        // Update our links:

        pbe->prbVerify           = prb;
        prb->apbe[IBOARD(ppdev)] = pbe;
    }

    pjBase = ppdev->pjBase;
    cjPel  = ppdev->cjPel;

    // Load some pointer variables onto the stack, so that we don't have
    // to keep dereferencing their pointers:

    x = pbe->x;
    y = pbe->y;

    CP_ABS_XY0(ppdev, pjBase, x * cjPel, y);
    CP_ABS_XY1(ppdev, pjBase, x * cjPel, y);
    CP_ABS_XY2(ppdev, pjBase, (x + 8) * cjPel, y);
    CP_ABS_Y3(ppdev, pjBase, 1);

    pulSrc = (ULONG*) &prb->aulPattern[0];

    CP_WAIT(ppdev, pjBase);
    CP_RASTER(ppdev, pjBase, P9000(ppdev) ? P9000_S : P9100_S);

    for (i = 4 * cjPel; i != 0; i--)
    {
        CP_PIXEL8(ppdev, pjBase, *(pulSrc));
        CP_PIXEL8(ppdev, pjBase, *(pulSrc + 1));
        CP_PIXEL8(ppdev, pjBase, *(pulSrc + 2));
        CP_PIXEL8(ppdev, pjBase, *(pulSrc + 3));
        pulSrc += 4;
    }

    // Ŀ
    // 0123  4       We now have an 8x8 colour-expanded copy of
    // Ĵ the pattern sitting in off-screen memory,
    // 5                 represented here by square '0'.
    // Ĵ
    // 6                 We're now going to expand the pattern to
    // Ĵ 72x72 by repeatedly copying larger rectangles
    // 7                 in the indicated order.
    //                  
    //                  
    // Ĵ
    // 8                
    //                  
    //                  
    //                  
    //                  
    // 

    // Copy '1':

    CP_ABS_XY1(ppdev, pjBase, x + 7, y + 7);
    CP_ABS_XY3(ppdev, pjBase, x + 15, y + 7);
    CP_WAIT(ppdev, pjBase);
    CP_START_BLT(ppdev, pjBase);

    // Copy '2':

    CP_ABS_X2(ppdev, pjBase, x + 16);
    CP_ABS_X3(ppdev, pjBase, x + 23);
    CP_START_BLT_WAIT(ppdev, pjBase);

    // Copy '3':

    CP_ABS_X1(ppdev, pjBase, x + 15);
    CP_ABS_X2(ppdev, pjBase, x + 24);
    CP_ABS_X3(ppdev, pjBase, x + 39);
    CP_START_BLT_WAIT(ppdev, pjBase);

    // Copy '4':

    CP_ABS_X1(ppdev, pjBase, x + 31);
    CP_ABS_X2(ppdev, pjBase, x + 40);
    CP_ABS_X3(ppdev, pjBase, x + 71);
    CP_START_BLT_WAIT(ppdev, pjBase);

    // Copy '5':

    CP_ABS_XY1(ppdev, pjBase, x + 71, y + 7);
    CP_ABS_XY2(ppdev, pjBase, x, y + 8);
    CP_ABS_XY3(ppdev, pjBase, x + 71, y + 15);
    CP_START_BLT_WAIT(ppdev, pjBase);

    // Copy '6':

    CP_ABS_Y2(ppdev, pjBase, y + 16);
    CP_ABS_Y3(ppdev, pjBase, y + 23);
    CP_START_BLT_WAIT(ppdev, pjBase);

    // Copy '7':

    CP_ABS_Y1(ppdev, pjBase, y + 15);
    CP_ABS_Y2(ppdev, pjBase, y + 24);
    CP_ABS_Y3(ppdev, pjBase, y + 39);
    CP_START_BLT_WAIT(ppdev, pjBase);

    // Copy '8':

    CP_ABS_Y1(ppdev, pjBase, y + 31);
    CP_ABS_Y2(ppdev, pjBase, y + 40);
    CP_ABS_Y3(ppdev, pjBase, y + 71);
    CP_START_BLT_WAIT(ppdev, pjBase);
}

/******************************Public*Routine******************************\
* VOID vFillSlowPat
*
\**************************************************************************/

VOID vFillSlowPat(              // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           ulHwMix,        // Hardware mix mode
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*       pjBase;
    BOOL        bExponential;
    ULONG       ulRaster;
    LONG        xBrush;
    LONG        yBrush;
    LONG        xSrc;
    LONG        ySrc;
    LONG        x;
    LONG        y;
    LONG        xFrom;
    LONG        yFrom;
    LONG        cxToGo;
    LONG        cyToGo;
    LONG        cxThis;
    LONG        cyThis;
    LONG        xOrg;
    LONG        yOrg;
    LONG        cyOriginal;
    LONG        yOriginal;
    LONG        xOriginal;
    BRUSHENTRY* pbe;        // Pointer to brush entry data, which is used
                            //   for keeping track of the location and status
                            //   of the pattern bits cached in off-screen
                            //   memory

    if (rbc.prb->apbe[IBOARD(ppdev)]->prbVerify != rbc.prb)
    {
        vSlowPatRealize(ppdev, rbc.prb);
    }

    pjBase = ppdev->pjBase;

    // We special case PATCOPY mixes because we can implement
    // an exponential fill: every blt will double the size of
    // the current rectangle by using the portion of the pattern
    // that has already been done for this rectangle as the source.
    //
    // Note that there's no point in also checking for BLACK
    // or WHITE because those will be taken care of by the
    // solid fill routines, and I can't be bothered to check for
    // NOTCOPYPEN:

    bExponential = (ulHwMix == 0xf0f0);

    // Convert the rop from a Rop3 between P and D to the corresponding
    // Rop3 between S and D:

    ulRaster  = (ulHwMix & 0x3C) >> 2;
    ulRaster |= (ulRaster << 4);

    if (P9000(ppdev))
    {
        // Make the Rop3 into a true P9000 minterm:

        ulRaster |= (ulRaster << 8);
    }

    // Note that since we do our brush alignment calculations in
    // relative coordinates, we should keep the brush origin in
    // relative coordinates as well:

    xOrg = pptlBrush->x;
    yOrg = pptlBrush->y;

    pbe    = rbc.prb->apbe[IBOARD(ppdev)];
    xBrush = pbe->x;
    yBrush = pbe->y;

    do {
        x = prcl->left;
        y = prcl->top;

        xSrc = xBrush + ((x - xOrg) & 7);
        ySrc = yBrush + ((y - yOrg) & 7);

        cxToGo = prcl->right  - x;
        cyToGo = prcl->bottom - y;

        if ((cxToGo <= SLOW_BRUSH_DIMENSION) &&
            (cyToGo <= SLOW_BRUSH_DIMENSION))
        {
            CP_ABS_XY0(ppdev, pjBase, xSrc, ySrc);
            CP_ABS_XY1(ppdev, pjBase, xSrc + cxToGo - 1, ySrc + cyToGo - 1);
            CP_XY2(ppdev, pjBase, x, y);
            CP_XY3(ppdev, pjBase, x + cxToGo - 1, y + cyToGo - 1);

            CP_WAIT(ppdev, pjBase);
            CP_RASTER(ppdev, pjBase, ulRaster);
            CP_START_BLT(ppdev, pjBase);
        }

        else if (bExponential)
        {
            cyThis  = SLOW_BRUSH_DIMENSION;
            cyToGo -= cyThis;
            if (cyToGo < 0)
                cyThis += cyToGo;

            cxThis  = SLOW_BRUSH_DIMENSION;
            cxToGo -= cxThis;
            if (cxToGo < 0)
                cxThis += cxToGo;

            CP_ABS_XY0(ppdev, pjBase, xSrc, ySrc);
            CP_ABS_XY1(ppdev, pjBase, xSrc + cxThis - 1, ySrc + cyThis - 1);
            CP_XY2(ppdev, pjBase, x, y);
            CP_XY3(ppdev, pjBase, x + cxThis - 1, y + cyThis - 1);

            CP_WAIT(ppdev, pjBase);
            CP_RASTER(ppdev, pjBase, ulRaster);
            CP_START_BLT(ppdev, pjBase);

            CP_XY0(ppdev, pjBase, x, y);

            xOriginal = x;

            x += cxThis;
            y += cyThis;

            while (cxToGo > 0)
            {
                // First, expand out to the right, doubling our size
                // each time:

                xFrom = x;
                cxToGo -= cxThis;
                if (cxToGo < 0)
                {
                    cxThis += cxToGo;
                    xFrom  += cxToGo;
                }

                CP_XY1(ppdev, pjBase, xFrom - 1, y - 1);
                CP_X2(ppdev, pjBase, x);
                CP_X3(ppdev, pjBase, x + cxThis - 1);
                CP_START_BLT_WAIT(ppdev, pjBase);

                x      += cxThis;
                cxThis *= 2;
            }

            while (cyToGo > 0)
            {
                // Now do the same thing vertically:

                yFrom = y;
                cyToGo -= cyThis;
                if (cyToGo < 0)
                {
                    cyThis += cyToGo;
                    yFrom  += cyToGo;
                }

                CP_XY1(ppdev, pjBase, x - 1, yFrom - 1);
                CP_XY2(ppdev, pjBase, xOriginal, y);
                CP_Y3(ppdev, pjBase, y + cyThis - 1);
                CP_START_BLT_WAIT(ppdev, pjBase);

                y      += cyThis;
                cyThis *= 2;
            }
        }
        else
        {
            // We handle arbitrary mixes simply by repeatedly tiling
            // our cached pattern over the entire rectangle:

            CP_ABS_XY0(ppdev, pjBase, xSrc, ySrc);

            CP_WAIT(ppdev, pjBase);
            CP_RASTER(ppdev, pjBase, ulRaster);

            cyOriginal = cyToGo;        // Have to remember for later...
            yOriginal  = y;

            do {
                cxThis  = SLOW_BRUSH_DIMENSION;
                cxToGo -= cxThis;
                if (cxToGo < 0)
                    cxThis += cxToGo;

                cyToGo = cyOriginal;    // Have to reset for each new column
                y      = yOriginal;

                do {
                    cyThis  = SLOW_BRUSH_DIMENSION;
                    cyToGo -= cyThis;
                    if (cyToGo < 0)
                        cyThis += cyToGo;

                    CP_ABS_XY1(ppdev, pjBase, xSrc + cxThis - 1,
                                              ySrc + cyThis - 1);
                    CP_XY2(ppdev, pjBase, x, y);
                    CP_XY3(ppdev, pjBase, x + cxThis - 1,
                                          y + cyThis - 1);
                    CP_START_BLT_WAIT(ppdev, pjBase);

                    y += cyThis;

                } while (cyToGo > 0);

                x += cxThis;        // Get ready for next column

            } while (cxToGo > 0);
        }
        prcl++;
    } while (--c != 0);
}

/******************************Public*Routine******************************\
* VOID vFillPat
*
\**************************************************************************/

VOID vFillPat(                  // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           ulHwMix,        // Hardware mix mode
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*       pjBase;
    LONG        i;
    ULONG*      pulPattern;
    ULONG       ulPattern;

    ASSERTDD(((ulHwMix >> 8) == (ulHwMix & 0xff)) ||
             ((ulHwMix & 0xff00) == 0xaa00),
             "This routine handles only opaque or transparent mixes");

    if (rbc.prb->fl & (RBRUSH_2COLOR | RBRUSH_4COLOR))
    {
        // Hardware pattern

        pjBase = ppdev->pjBase;

        CP_METARECT(ppdev, pjBase, prcl->left, prcl->top);
        CP_METARECT(ppdev, pjBase, prcl->right, prcl->bottom);
        CP_WAIT(ppdev, pjBase);

        if (P9000(ppdev))
        {
            CP_PATTERN_ORGX(ppdev, pjBase, ppdev->xOffset + pptlBrush->x);
            CP_PATTERN_ORGY(ppdev, pjBase, ppdev->yOffset + pptlBrush->y);
            CP_BACKGROUND(ppdev, pjBase, rbc.prb->ulColor[0]);
            CP_FOREGROUND(ppdev, pjBase, rbc.prb->ulColor[1]);
            pulPattern = &rbc.prb->aulPattern[0];
            for (i = 0; i < 4; i++)
            {
                ulPattern = *pulPattern++;
                CP_PATTERN(ppdev, pjBase, i, ulPattern);
                CP_PATTERN(ppdev, pjBase, i + 4, ulPattern);
            }

            if (((ulHwMix >> 8) & 0xff) == (ulHwMix & 0xff))
            {
                ulHwMix = gaulP9000OpaqueFromRop2[(ulHwMix & 0x3C) >> 2];
                CP_RASTER(ppdev, pjBase, ulHwMix | P9000_ENABLE_PATTERN);
            }
            else
            {
                ulHwMix = gaulP9000TransparentFromRop2[(ulHwMix & 0x3C) >> 2];
                CP_RASTER(ppdev, pjBase, ulHwMix | P9000_ENABLE_PATTERN);
            }
        }
        else
        {
            CP_PATTERN_ORGX(ppdev, pjBase, -(ppdev->xOffset + pptlBrush->x));
            CP_PATTERN_ORGY(ppdev, pjBase, -(ppdev->yOffset + pptlBrush->y));
            CP_COLOR0_FAST(ppdev, pjBase, rbc.prb->ulColor[0]);
            CP_COLOR1_FAST(ppdev, pjBase, rbc.prb->ulColor[1]);
            CP_PATTERN(ppdev, pjBase, 0, rbc.prb->aulPattern[0]);
            CP_PATTERN(ppdev, pjBase, 1, rbc.prb->aulPattern[1]);
            CP_PATTERN(ppdev, pjBase, 2, rbc.prb->aulPattern[2]);
            CP_PATTERN(ppdev, pjBase, 3, rbc.prb->aulPattern[3]);
            if (rbc.prb->fl & RBRUSH_2COLOR)
            {
                if (((ulHwMix >> 8) & 0xff) == (ulHwMix & 0xff))
                {
                    CP_RASTER(ppdev, pjBase, (ulHwMix & 0xff)
                             | P9100_ENABLE_PATTERN);
                }
                else
                {
                    CP_RASTER(ppdev, pjBase, (ulHwMix & 0xff)
                             | P9100_ENABLE_PATTERN | P9100_TRANSPARENT_PATTERN);
                }
            }
            else
            {

                CP_COLOR2_FAST(ppdev, pjBase, rbc.prb->ulColor[2]);
                CP_COLOR3_FAST(ppdev, pjBase, rbc.prb->ulColor[3]);
                CP_RASTER(ppdev, pjBase, (ulHwMix & 0xff)
                          | P9100_ENABLE_PATTERN | P9100_FOUR_COLOR_PATTERN);
            }
        }

        CP_START_QUAD(ppdev, pjBase);

        while (prcl++, --c)
        {
            CP_METARECT(ppdev, pjBase, prcl->left, prcl->top);
            CP_METARECT(ppdev, pjBase, prcl->right, prcl->bottom);
            CP_START_QUAD_WAIT(ppdev, pjBase);
        }
    }
    else
    {
        vFillSlowPat(ppdev, c, prcl, ulHwMix, rbc, pptlBrush);
    }
}

/******************************Public*Routine******************************\
* VOID vXfer1bpp
*
* This routine colour expands a monochrome bitmap.
*
\**************************************************************************/

VOID vXfer1bpp(         // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       ulHwMix,    // Foreground and background hardware mix
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjBase;
    LONG    dx;
    LONG    dy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    ULONG*  pulXlate;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    cyScan;
    LONG    xBias;
    LONG    culScan;
    LONG    lSrcSkip;
    ULONG*  pulSrc;
    LONG    cRem;
    LONG    i;

    ASSERTDD(((ulHwMix >> 8) & 0xff) == (ulHwMix & 0xff),
             "Expected only an opaquing rop");

    pjBase = ppdev->pjBase;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    lSrcDelta    = psoSrc->lDelta;
    pjSrcScan0   = psoSrc->pvScan0;

    do {
        xLeft  = prcl->left;
        xRight = prcl->right;
        yTop   = prcl->top;

        xBias  = (xLeft + dx) & 31;
        xLeft -= xBias;

        CP_XY1(ppdev, pjBase, xLeft, yTop);
        CP_X0(ppdev, pjBase, xLeft);
        CP_X2(ppdev, pjBase, xRight);
        CP_ABS_Y3(ppdev, pjBase, 1);

        culScan = ((xRight - xLeft) >> 5);
        cRem    = ((xRight - xLeft) & 31) - 1;
        if (cRem < 0)
        {
            culScan--;
            cRem = 31;
        }

        pulSrc   = (ULONG*) (pjSrcScan0 + (yTop + dy) * lSrcDelta
                                        + ((xLeft + dx) >> 3));
        lSrcSkip = lSrcDelta - (culScan << 2);
        cyScan   = (prcl->bottom - yTop);

        CP_WAIT(ppdev, pjBase);
        CP_WLEFT(ppdev, pjBase, prcl->left);

        // The following three accelerator states are invariant to this
        // loop, but we set them each time anyway because we expect
        // usually to have only to do one iteration of this loop, and this
        // state must to be set after doing a CP_WAIT, which we want to
        // delay until we get as much processing done as possible, for
        // maximum overlap.

        pulXlate = pxlo->pulXlate;
        if (P9000(ppdev))
        {
            CP_BACKGROUND(ppdev, pjBase, pulXlate[0]);
            CP_FOREGROUND(ppdev, pjBase, pulXlate[1]);
            CP_RASTER(ppdev, pjBase, gaulP9000OpaqueFromRop2[ulHwMix & 0xf]);
        }
        else
        {
            CP_COLOR0(ppdev, pjBase, pulXlate[0]);
            CP_COLOR1(ppdev, pjBase, pulXlate[1]);
            CP_RASTER(ppdev, pjBase, ulHwMix & 0xff);
        }

        CP_START_PIXEL1(ppdev, pjBase);

        do {
            for (i = culScan; i != 0; i--)
            {
                CP_PIXEL1(ppdev, pjBase, *pulSrc);
                pulSrc++;
            }
            CP_PIXEL1_REM(ppdev, pjBase, cRem, *pulSrc);

            pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);

        } while (--cyScan != 0);

        CP_END_PIXEL1(ppdev, pjBase);

    } while (prcl++, --c);

    // Don't forget to reset the clip register:

    CP_WAIT(ppdev, pjBase);
    CP_ABS_WMIN(ppdev, pjBase, 0, 0);
}

/******************************Public*Routine******************************\
* VOID vXfer4bpp
*
* Does a 4bpp transfer from a bitmap to the screen.
*
* NOTE: The screen must be 8bpp for this function to be called!
*
* The reason we implement this is that a lot of resources are kept as 4bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

VOID vXfer4bpp(         // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       ulHwMix,    // Hardware mix
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjBase;
    LONG    dx;
    LONG    dy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    ULONG*  pulXlate;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    cyScan;
    LONG    xBias;
    LONG    cwSrc;
    LONG    lSrcSkip;
    LONG    cw;
    BYTE*   pjSrc;
    BYTE    jSrc;
    ULONG   ul;

    ASSERTDD(ppdev->cjPel == 1, "This function assumes 8bpp");

    pjBase = ppdev->pjBase;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;
    pulXlate   = pxlo->pulXlate;

    do {
        xLeft  = prcl->left;
        xRight = prcl->right;
        yTop   = prcl->top;

        // We compute 'xBias' in order to word-align the source pointer.
        // This way, since we're processing a word of the source at a
        // time, we're guaranteed not to read even a byte past the end of
        // the bitmap.

        xBias = ((xLeft + dx) & 3);
        xLeft -= xBias;

        CP_XY1(ppdev, pjBase, xLeft, yTop);
        CP_X0(ppdev, pjBase, xLeft);
        CP_X2(ppdev, pjBase, xRight);
        CP_ABS_Y3(ppdev, pjBase, 1);

        // Every word in the source is one dword in the destination:

        cwSrc    = ((xRight - xLeft) + 3) >> 2;
        lSrcSkip = lSrcDelta - (cwSrc << 1);
        pjSrc    = pjSrcScan0 + (yTop + dy) * lSrcDelta + ((xLeft + dx) >> 1);
        cyScan   = prcl->bottom - yTop;

        ASSERTDD(((ULONG_PTR) pjSrc & 1) == 0, "Source should be word aligned");

        // Yes, we're setting the raster every time in the loop.  But we
        // have to wait for not-busy before setting the raster, and the
        // chances are that we'll only have one rectangle to blt, so
        // we do this here:

        CP_WAIT(ppdev, pjBase);
        CP_WLEFT(ppdev, pjBase, prcl->left);
        CP_RASTER(ppdev, pjBase, P9000(ppdev) ? ulHwMix : (ulHwMix & 0xff));

        CP_START_PIXEL8(ppdev, pjBase);

        do {
            cw = cwSrc;

            do {
                jSrc = *(pjSrc + 1);

                ul   = pulXlate[jSrc & 0xf];
                ul <<= 8;
                ul  |= pulXlate[jSrc >> 4];

                jSrc = *(pjSrc);

                ul <<= 8;
                ul  |= pulXlate[jSrc & 0xf];
                ul <<= 8;
                ul  |= pulXlate[jSrc >> 4];

                CP_PIXEL8(ppdev, pjBase, ul);
                pjSrc += 2;

            } while (--cw != 0);

            pjSrc += lSrcSkip;

        } while (--cyScan != 0);

        CP_END_PIXEL8(ppdev, pjBase);

    } while (prcl++, --c);

    // Don't forget to reset the clip register:

    CP_WAIT(ppdev, pjBase);
    CP_ABS_WMIN(ppdev, pjBase, 0, 0);
}

/******************************Public*Routine******************************\
* VOID vXferNative
*
* Transfers a bitmap that is the same colour depth as the display to
* the screen via the data transfer register, with no translation.
*
\**************************************************************************/

VOID vXferNative(       // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ULONG       ulHwMix,    // Hardware mix
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    BYTE*   pjBase;
    LONG    cjPel;
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    cyScan;
    LONG    xBias;
    LONG    culScan;
    LONG    lSrcSkip;
    LONG    cu;
    ULONG*  pulSrc;

    pjBase = ppdev->pjBase;
    cjPel  = ppdev->cjPel;

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    do {
        xLeft  = prcl->left;
        xRight = prcl->right;
        yTop   = prcl->top;

        // We compute 'xBias' in order to dword-align the source pointer.
        // This way, we don't have to do unaligned reads of the source,
        // and we're guaranteed not to read even a byte past the end of
        // the bitmap.
        //
        // Note that this bias works at 24bpp, too:

        xBias = ((xLeft + dx) & 3);
        xLeft -= xBias;

        CP_ABS_XY1(ppdev, pjBase, (xLeft + xOffset) * cjPel, yTop + yOffset);
        CP_ABS_X0(ppdev, pjBase, (xLeft + xOffset) * cjPel);
        CP_ABS_X2(ppdev, pjBase, (xRight + xOffset) * cjPel);
        CP_ABS_Y3(ppdev, pjBase, 1);

        culScan  = ((xRight - xLeft) * cjPel + 3) >> 2;
        lSrcSkip = lSrcDelta - (culScan << 2);
        pulSrc   = (ULONG*) (pjSrcScan0 + (yTop + dy) * lSrcDelta
                                        + (xLeft + dx) * cjPel);
        cyScan   = prcl->bottom - yTop;

        ASSERTDD(((ULONG_PTR)pulSrc & 3) == 0, "Source should be dword aligned");

        // Yes, we're setting the raster every time in the loop.  But we
        // have to wait for not-busy before setting the raster, and the
        // chances are that we'll only have one rectangle to blt, so
        // we do this here:

        CP_WAIT(ppdev, pjBase);
        CP_ABS_WLEFT(ppdev, pjBase, prcl->left + xOffset);

        CP_RASTER(ppdev, pjBase, P9000(ppdev) ? ulHwMix : (ulHwMix & 0xff));
        CP_START_PIXEL8(ppdev, pjBase);

        do {
            cu = culScan;

            do {
                CP_PIXEL8(ppdev, pjBase, *pulSrc);
                pulSrc++;
            } while (--cu != 0);

            pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);

        } while (--cyScan != 0);

        CP_END_PIXEL8(ppdev, pjBase);

    } while (prcl++, --c);

    // Don't forget to reset the clip register:

    CP_WAIT(ppdev, pjBase);
    CP_ABS_WMIN(ppdev, pjBase, 0, 0);
}

/******************************Public*Routine******************************\
* VOID vCopyBlt
*
* Does a screen-to-screen blt of a list of rectangles.
*
* Note: We may call this function with weird ROPs to do colour-expansion
*       from off-screen monochrome bitmaps.
*
\**************************************************************************/

VOID vCopyBlt(      // Type FNCOPY
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   ulHwMix,    // Hardware mix
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    BYTE*   pjBase;
    LONG    cjPel;
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    LONG    xSrc;
    LONG    ySrc;

    pjBase = ppdev->pjBase;
    cjPel  = ppdev->cjPel;

    // Our DFB xOffset has to be scaled by the pixel size too:

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    xSrc = prcl->left + dx;
    ySrc = prcl->top  + dy;

    CP_ABS_XY0(ppdev, pjBase, (xOffset + xSrc) * cjPel,
                              (yOffset + ySrc));
    CP_ABS_XY1(ppdev, pjBase, (xOffset + xSrc + prcl->right - prcl->left) * cjPel - 1,
                              (yOffset + ySrc + prcl->bottom - prcl->top - 1));
    CP_ABS_XY2(ppdev, pjBase, (xOffset + prcl->left) * cjPel,
                              (yOffset + prcl->top));
    CP_ABS_XY3(ppdev, pjBase, (xOffset + prcl->right) * cjPel - 1,
                              (yOffset + prcl->bottom - 1));

    CP_WAIT(ppdev, pjBase);
    CP_RASTER(ppdev, pjBase, P9000(ppdev) ? ulHwMix : (ulHwMix & 0xff));
    CP_START_BLT(ppdev, pjBase);

    while (prcl++, --c)
    {
        xSrc = prcl->left + dx;
        ySrc = prcl->top  + dy;

        CP_ABS_XY0(ppdev, pjBase, (xOffset + xSrc) * cjPel,
                                  (yOffset + ySrc));
        CP_ABS_XY1(ppdev, pjBase, (xOffset + xSrc + prcl->right - prcl->left) * cjPel - 1,
                                  (yOffset + ySrc + prcl->bottom - prcl->top - 1));
        CP_ABS_XY2(ppdev, pjBase, (xOffset + prcl->left) * cjPel,
                                  (yOffset + prcl->top));
        CP_ABS_XY3(ppdev, pjBase, (xOffset + prcl->right) * cjPel - 1,
                                  (yOffset + prcl->bottom - 1));
        CP_START_BLT_WAIT(ppdev, pjBase);
    }
}

/******************************Public*Routine******************************\
* VOID vFillSolidP9000HighColor
*
* Fills a list of rectangles with a solid colour when running at 16bpp
* on the P9000, using the pattern hardware.
*
\**************************************************************************/

VOID vFillSolidP9000HighColor(  // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           ulHwMix,        // Hardware mix mode
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used
{
    BYTE*   pjBase;
    LONG    xOffset;
    LONG    yOffset;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(P9000(ppdev), "Shouldn't need to be called on the P9100");
    ASSERTDD(ppdev->iBitmapFormat == BMF_16BPP, "Only handle 16bpp for now");

    pjBase = ppdev->pjBase;

    // Our DFB xOffset has to be scaled by the pixel size too:

    xOffset = 2 * ppdev->xOffset;
    yOffset =     ppdev->yOffset;

    CP_ABS_METARECT(ppdev, pjBase, xOffset + 2 * prcl->left,
                                   yOffset + prcl->top);
    CP_ABS_METARECT(ppdev, pjBase, xOffset + 2 * prcl->right,
                                   yOffset + prcl->bottom);

    // We've already downloaded and set the pattern origin in
    // vAssertModeBrushCache:

    CP_WAIT(ppdev, pjBase);
    CP_RASTER(ppdev, pjBase, P9000_ENABLE_PATTERN |
              gaulP9000OpaqueFromRop2[(ulHwMix & 0x3C) >> 2]);

    CP_FOREGROUND(ppdev, pjBase, rbc.iSolidColor);
    CP_BACKGROUND(ppdev, pjBase, rbc.iSolidColor >> 8);
    CP_START_QUAD(ppdev, pjBase);

    while (prcl++, --c)
    {
        CP_ABS_METARECT(ppdev, pjBase, xOffset + 2 * prcl->left,
                                       yOffset + prcl->top);
        CP_ABS_METARECT(ppdev, pjBase, xOffset + 2 * prcl->right,
                                       yOffset + prcl->bottom);
        CP_START_QUAD_WAIT(ppdev, pjBase);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\enable.c ===
/******************************Module*Header*******************************\
* Module Name: enable.c
*
* This module contains the functions that enable and disable the
* driver, the pdev, and the surface.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Structure****************************\
* GDIINFO ggdiDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

GDIINFO ggdiDefault = {
    GDI_DRIVER_VERSION,
    DT_RASDISPLAY,          // ulTechnology
    0,                      // ulHorzSize (filled in later)
    0,                      // ulVertSize (filled in later)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    0,                      // cPlanes (filled in later)
    20,                     // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)

    0,                      // ulLogPixelsX (filled in later)
    0,                      // ulLogPixelsY (filled in later)

    TC_RA_ABLE,             // flTextCaps -- If we had wanted console windows
                            //   to scroll by repainting the entire window,
                            //   instead of doing a screen-to-screen blt, we
                            //   would have set TC_SCROLLBLT (yes, the flag is
                            //   bass-ackwards).

    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)

    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)

    1,                      // xStyleStep
    1,                      // yStyleSte;
    3,                      // denStyleStep -- Styles have a one-to-one aspect
                            //   ratio, and every 'dot' is 3 pixels long

    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize

    256,                    // ulNumPalReg

    // These fields are for halftone initialization.  The actual values are
    // a bit magic, but seem to work well on our display.

    {                       // ciDevice
       { 6700, 3300, 0 },   //      Red
       { 2100, 7100, 0 },   //      Green
       { 1400,  800, 0 },   //      Blue
       { 1750, 3950, 0 },   //      Cyan
       { 4050, 2050, 0 },   //      Magenta
       { 4400, 5200, 0 },   //      Yellow
       { 3127, 3290, 0 },   //      AlignmentWhite
       20000,               //      RedGamma
       20000,               //      GreenGamma
       20000,               //      BlueGamma
       0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh
    0,                       // ulBltAlignment
    0,                       // ulPanningHorzRes
    0,                       // ulPanningVertRes
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault = {
    (GCAPS_OPAQUERECT       |
     GCAPS_DITHERONREALIZE  |
     GCAPS_PALMANAGED       |
     GCAPS_ALTERNATEFILL    |
     GCAPS_WINDINGFILL      |
     GCAPS_MONO_DITHER      |
     GCAPS_COLOR_DITHER     |
     GCAPS_BEZIERS),                            // NOTE:
                                                // In the past, we tried
                                                // GCAPS_ASYNCMOVE, but we
                                                // ran into trouble on PPC
                                                // machines and had to remove
                                                // it.

                                                // flGraphicsFlags
    SYSTM_LOGFONT,                              // lfDefaultFont
    HELVE_LOGFONT,                              // lfAnsiVarFont
    COURI_LOGFONT,                              // lfAnsiFixFont
    0,                                          // cFonts
    BMF_8BPP,                                   // iDitherFormat
    8,                                          // cxDither
    8,                                          // cyDither
    0                                           // hpalDefault (filled in later)
};

/******************************Public*Structure****************************\
* DFVFN gadrvfn[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
* Why haven't we implemented DrvSaveScreenBits?  To save code.
*
* When the driver doesn't hook DrvSaveScreenBits, USER simulates on-
* the-fly by creating a temporary device-format-bitmap, and explicitly
* calling DrvCopyBits to save/restore the bits.  Since we already hook
* DrvCreateDeviceBitmap, we'll end up using off-screen memory to store
* the bits anyway (which would have been the main reason for implementing
* DrvSaveScreenBits).  So we may as well save some working set.
\**************************************************************************/

#if MULTI_BOARDS

// Multi-board support has its own thunks...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) MulEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) MulCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) MulDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) MulEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) MulDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) MulAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) MulMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) MulSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) MulDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) MulSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) MulCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) MulBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) MulTextOut            },
    {   INDEX_DrvGetModes,              (PFN) MulGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) MulStrokePath         },
    {   INDEX_DrvFillPath,              (PFN) MulFillPath           },
    {   INDEX_DrvPaint,                 (PFN) MulPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) MulRealizeBrush       },
    {   INDEX_DrvDestroyFont,           (PFN) MulDestroyFont        },
    // Note that DrvCreateDeviceBitmap is not supported for multi-boards
    // Note that DrvDeleteDeviceBitmap is not supported for multi-boards
    // Note that DrvStretchBlt is not supported for multi-boards
    // Note that DrvSynchronize is not supported for multi-boards
    // Note that DrvEscape is not supported for multi-boards
};

#elif DBG

// On Checked builds, or when we have to synchronize access, thunk
// everything through Dbg calls...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DbgEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DbgCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DbgDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DbgEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DbgDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DbgAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) DbgMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DbgSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DbgDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) DbgSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) DbgCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DbgBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DbgTextOut            },
    {   INDEX_DrvGetModes,              (PFN) DbgGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) DbgStrokePath         },
    {   INDEX_DrvFillPath,              (PFN) DbgFillPath           },
    {   INDEX_DrvPaint,                 (PFN) DbgPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) DbgRealizeBrush       },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DbgCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DbgDeleteDeviceBitmap },
    {   INDEX_DrvStretchBlt,            (PFN) DbgStretchBlt         },
    {   INDEX_DrvSynchronize,           (PFN) DbgSynchronize        },
    {   INDEX_DrvDestroyFont,           (PFN) DbgDestroyFont        },
};

#else

// On Free builds, directly call the appropriate functions...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath           },
    {   INDEX_DrvPaint,                 (PFN) DrvPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush       },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap },
    {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         },
    {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize        },
    {   INDEX_DrvDestroyFont,           (PFN) DrvDestroyFont        },
};

#endif

ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);

/******************************Public*Routine******************************\
* BOOL DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.

    // Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = gcdrvfn;

    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after DrvEnableDriver, when GDI
* wants to get some information about us.
*
* (This function mostly returns back information; DrvEnableSurface is used
* for initializing the hardware and driver components.)
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PDEV*   ppdev;

    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:

    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        DISPDBG((0, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
    }

    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:

    ppdev = (PDEV*) EngAllocMem(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);
    if (ppdev == NULL)
    {
        DISPDBG((0, "DrvEnablePDEV - Failed EngAllocMem"));
        goto ReturnFailure0;
    }

    ppdev->hDriver = hDriver;

    // Get the current screen mode information.  Set up device caps and
    // devinfo:

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializeModeFields"));
        goto ReturnFailure1;
    }

    // Initialize palette information.

    if (!bInitializePalette(ppdev, pdi))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
    }

    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((0, "Failed DrvEnablePDEV"));

    return(0);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
* Note that this function will be called when previewing modes in the
* Display Applet, but not at system shutdown.  If you need to reset the
* hardware at shutdown, you can do it in the miniport by providing a
* 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
*
* Note: In an error, we may call this before DrvEnablePDEV is done.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV  dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    vUninitializePalette(ppdev);
    EngFreeMem(ppdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}


/******************************Public*Routine******************************\
* HSURF DrvEnableSurface
*
* Creates the drawing surface, initializes the hardware, and initializes
* driver components.  This function is called after DrvEnablePDEV, and
* performs the final device initialization.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PDEV*       ppdev;
    HSURF       hsurf;
    SIZEL       sizl;
    DSURF*      pdsurf;
    VOID*       pvTmpBuffer;

    ppdev = (PDEV*) dhpdev;

    /////////////////////////////////////////////////////////////////////
    // First enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...

    if (!bEnableHardware(ppdev))
        goto ReturnFailure;

    if (!bEnableOffscreenHeap(ppdev))
        goto ReturnFailure;

    if (!bEnablePointer(ppdev))
        goto ReturnFailure;

    if (!bEnableText(ppdev))
        goto ReturnFailure;

    if (!bEnableBrushCache(ppdev))
        goto ReturnFailure;

    if (!bEnablePalette(ppdev))
        goto ReturnFailure;

    /////////////////////////////////////////////////////////////////////
    // Now create our private surface structure.
    //
    // Whenever we get a call to draw directly to the screen, we'll get
    // passed a pointer to a SURFOBJ whose 'dhpdev' field will point
    // to our PDEV structure, and whose 'dhsurf' field will point to the
    // following DSURF structure.
    //
    // Every device bitmap we create in DrvCreateDeviceBitmap will also
    // have its own unique DSURF structure allocated (but will share the
    // same PDEV).  To make our code more polymorphic for handling drawing
    // to either the screen or an off-screen bitmap, we have the same
    // structure for both.

    pdsurf = EngAllocMem(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG);
    if (pdsurf == NULL)
    {
        DISPDBG((0, "DrvEnableSurface - Failed pdsurf EngAllocMem"));
        goto ReturnFailure;
    }

    ppdev->pdsurfScreen = pdsurf;           // Remember it for clean-up
    pdsurf->poh     = ppdev->pohScreen;     // The screen is a surface, too
    pdsurf->dt      = DT_SCREEN;            // Not to be confused with a DIB
    pdsurf->sizl.cx = ppdev->cxScreen;
    pdsurf->sizl.cy = ppdev->cyScreen;
    pdsurf->ppdev   = ppdev;

    /////////////////////////////////////////////////////////////////////
    // Next, have GDI create the actual SURFOBJ.
    //
    // Since we can map the entire framebuffer linearly into main memory
    // (i.e., we didn't have to go through a 64k aperture), it is
    // beneficial to create the surface via EngCreateBitmap, giving GDI a
    // pointer to the framebuffer bits.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    {
        SURFOBJ*    pso;

        // Engine-managed surface:

        hsurf = (HSURF) EngCreateBitmap(sizl, ppdev->lDelta, ppdev->iBitmapFormat,
                                        BMF_TOPDOWN, ppdev->pjScreen);
        if (hsurf == 0)
        {
            DISPDBG((0, "DrvEnableSurface - Failed EngCreateBitmap"));
            goto ReturnFailure;
        }

        // Set it up so that the when we are passed a SURFOBJ for the
        // screen, the 'dhsurf' will point to the screen's surface structure:
        // !!! Grody?

        pso = EngLockSurface(hsurf);
        if (pso == NULL)
        {
            DISPDBG((0, "DrvEnableSurface - Couldn't lock our surface"));
            goto ReturnFailure;
        }
        pso->dhsurf = (DHSURF) pdsurf;
        EngUnlockSurface(pso);
    }

    ppdev->hsurfScreen = hsurf;             // Remember it for clean-up
    ppdev->bEnabled = TRUE;                 // We'll soon be in graphics mode

    /////////////////////////////////////////////////////////////////////
    // Now associate the surface and the PDEV.
    //
    // We have to associate the surface we just created with our physical
    // device so that GDI can get information related to the PDEV when
    // it's drawing to the surface (such as, for example, the length of
    // styles on the device when simulating styled lines).
    //

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks))
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngAssociateSurface"));
        goto ReturnFailure;
    }

    // Create our generic temporary buffer, which may be used by any
    // component.  Because this may get swapped out of memory any time
    // the driver is not active, we want to minimize the number of pages
    // it takes up.  We use 'VirtualAlloc' to get an exactly page-aligned
    // allocation (which 'EngAllocMem' will not do):

    pvTmpBuffer = EngAllocMem(0, TMP_BUFFER_SIZE, ALLOC_TAG);
    if (pvTmpBuffer == NULL)
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngAllocMem"));
        goto ReturnFailure;
    }

    ppdev->pvTmpBuffer = pvTmpBuffer;

    DISPDBG((5, "Passed DrvEnableSurface"));

    return(hsurf);

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((0, "Failed DrvEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
* Note that this function will be called when previewing modes in the
* Display Applet, but not at system shutdown.  If you need to reset the
* hardware at shutdown, you can do it in the miniport by providing a
* 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
*
* Note: In an error case, we may call this before DrvEnableSurface is
*       completely done.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.

    vDisablePalette(ppdev);
    vDisableBrushCache(ppdev);
    vDisableText(ppdev);
    vDisablePointer(ppdev);
    vDisableOffscreenHeap(ppdev);
    vDisableHardware(ppdev);

    EngFreeMem(ppdev->pvTmpBuffer);
    EngDeleteSurface(ppdev->hsurfScreen);
    EngFreeMem(ppdev->pdsurfScreen);
}

/******************************Public*Routine******************************\
* VOID DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL DrvAssertMode(
DHPDEV  dhpdev,
BOOL    bEnable)
{
    PDEV* ppdev;

    ppdev = (PDEV*) dhpdev;

    if (!bEnable)
    {
        //////////////////////////////////////////////////////////////
        // Disable - Switch to full-screen mode

        vAssertModePalette(ppdev, FALSE);

        vAssertModeBrushCache(ppdev, FALSE);

        vAssertModeText(ppdev, FALSE);

        vAssertModePointer(ppdev, FALSE);

        if (bAssertModeOffscreenHeap(ppdev, FALSE))
        {
            if (bAssertModeHardware(ppdev, FALSE))
            {
                ppdev->bEnabled = FALSE;

                return(TRUE);
            }

            //////////////////////////////////////////////////////////
            // We failed to switch to full-screen.  So undo everything:

            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
        }                                           //   return code with TRUE

        vAssertModePointer(ppdev, TRUE);

        vAssertModeText(ppdev, TRUE);

        vAssertModeBrushCache(ppdev, TRUE);

        vAssertModePalette(ppdev, TRUE);
    }
    else
    {
        //////////////////////////////////////////////////////////////
        // Enable - Switch back to graphics mode

        // We have to enable every subcomponent in the reverse order
        // in which it was disabled:

        if (bAssertModeHardware(ppdev, TRUE))
        {
            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
                                                    //   return code with TRUE
            vAssertModePointer(ppdev, TRUE);

            vAssertModeText(ppdev, TRUE);

            vAssertModeBrushCache(ppdev, TRUE);

            vAssertModePalette(ppdev, TRUE);

            ppdev->bEnabled = TRUE;

            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* ULONG DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)
{
    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    cModes = getAvailableModes(hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize);
    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return(0);
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG_PTR)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);


        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return(cbOutputSize);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeHardware
*
* Sets the appropriate hardware state for graphics mode or full-screen.
*
\**************************************************************************/

BOOL bAssertModeHardware(
PDEV* ppdev,
BOOL  bEnable)
{
    DWORD   ReturnedDataLength;
    ULONG   ulReturn;

    if (bEnable)
    {
        // Call the miniport via an IOCTL to set the graphics mode.

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_CURRENT_MODE,
                             &ppdev->ulMode,  // input buffer
                             sizeof(DWORD),
                             NULL,
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed VIDEO_SET_CURRENT_MODE"));
            return(FALSE);
        }

        vResetClipping(ppdev);
    }
    else
    {
        // Wait for all pending accelerator operations to finish:

        CP_WAIT(ppdev, ppdev->pjBase);

        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there:

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_RESET_DEVICE,
                             NULL,
                             0,
                             NULL,
                             0,
                             &ulReturn))
        {
            DISPDBG((0, "bAssertModeHardware - Failed reset IOCTL"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bAssertModeHardware"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bEnableHardware
*
* Puts the hardware in the requested mode and initializes it.
*
* Note: Should be called before any access is done to the hardware from
*       the display driver.
*
\**************************************************************************/

BOOL bEnableHardware(
PDEV*   ppdev)
{
    VIDEO_MEMORY                    VideoMemory;
    VIDEO_MEMORY_INFORMATION        VideoMemoryInfo;
    DWORD                           ReturnedDataLength;

    // Get the linear memory address range.

    VideoMemory.RequestedVirtualAddress = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                         &VideoMemory,      // input buffer
                         sizeof(VIDEO_MEMORY),
                         &VideoMemoryInfo,  // output buffer
                         sizeof(VideoMemoryInfo),
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - Error mapping buffer address"));
        goto ReturnFalse;
    }

    DISPDBG((1, "FrameBufferBase: %lx", VideoMemoryInfo.FrameBufferBase));

    // Record the Frame Buffer Linear Address.

    ppdev->pjScreen = (BYTE*) VideoMemoryInfo.FrameBufferBase;
    ppdev->cjScreen =         VideoMemoryInfo.FrameBufferLength;

    ppdev->cxMemory = ppdev->lDelta / ppdev->cjPel;
    ppdev->cyMemory = VideoMemoryInfo.VideoRamLength / ppdev->lDelta;

    // Now we can set the mode, unlock the accelerator, and reset the
    // clipping:

    if (!bAssertModeHardware(ppdev, TRUE))
        goto ReturnFalse;

    ppdev->pfnFillSolid         = vFillSolid;
    ppdev->pfnFillPat           = vFillPat;
    ppdev->pfnXfer1bpp          = vXfer1bpp;
    ppdev->pfnXfer4bpp          = vXfer4bpp;
    ppdev->pfnXferNative        = vXferNative;
    ppdev->pfnCopyBlt           = vCopyBlt;

    if (ppdev->flStat & STAT_UNACCELERATED)
    {
        // On the P9000, colour depths higher than 8bpp aren't fully
        // accelerated.  We do support screen-to-screen blts at any
        // colour depth, and solid fills at 16bpp:

        ppdev->pfnFillSolid     = vFillSolidP9000HighColor;
    }

    DISPDBG((5, "Passed bEnableHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableHardware
*
* Undoes anything done in bEnableHardware.
*
* Note: In an error case, we may call this before bEnableHardware is
*       completely done.
*
\**************************************************************************/

VOID vDisableHardware(
PDEV*   ppdev)
{
    DWORD        ReturnedDataLength;
    VIDEO_MEMORY VideoMemory;
    VIDEO_MEMORY CoprocMemory;

    //
    // When we get the coprocessor base from the miniport, we scale it
    // on P9100 cards.  Scale it back before freeing the address
    // range.
    //

    if (!P9000(ppdev))
    {
        ppdev->pjBase -= P9100_BASE_CORRECTION;
    }

    VideoMemory.RequestedVirtualAddress = (PVOID) ppdev->pjScreen;
    CoprocMemory.RequestedVirtualAddress = (PVOID) ppdev->pjBase;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                         &VideoMemory,
                         sizeof(VIDEO_MEMORY),
                         NULL,
                         0,
                         &ReturnedDataLength))
    {
        DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_UNMAP_VIDEO"));
    }

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES,
                         &CoprocMemory,
                         sizeof(VIDEO_MEMORY),
                         NULL,
                         0,
                         &ReturnedDataLength))
    {
        DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES"));
    }

}

/******************************Public*Routine******************************\
* BOOL bInitializeModeFields
*
* Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
* devinfo based on the requested mode.
*
\**************************************************************************/

BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)
{
    ULONG                           cModes;
    PVIDEO_MODE_INFORMATION         pVideoBuffer;
    PVIDEO_MODE_INFORMATION         pVideoModeSelected;
    PVIDEO_MODE_INFORMATION         pVideoTemp;
    BOOL                            bSelectDefault;
    VIDEO_MODE_INFORMATION          VideoModeInformation;
    ULONG                           cbModeSize;
    VIDEO_PUBLIC_ACCESS_RANGES      RangeInfo;
    DWORD                           ReturnedDataLength;

    // Call the miniport to get mode information

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);
    if (cModes == 0)
        goto ReturnFalse;

    // Now see if the requested mode has a match in that table.

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth        == 0) &&
        (pdm->dmPelsHeight       == 0) &&
        (pdm->dmBitsPerPel       == 0) &&
        (pdm->dmDisplayFrequency == 0))
    {
        DISPDBG((1, "Default mode requested"));
        bSelectDefault = TRUE;
    }
    else
    {
        DISPDBG((1, "Requested mode..."));
        DISPDBG((1, "   Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((1, "   Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((1, "   Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((1, "   Frequency     -- %li", pdm->dmDisplayFrequency));

        bSelectDefault = FALSE;
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            DISPDBG((2, "   Checking against miniport mode:"));
            DISPDBG((2, "      Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "      Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "      Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                      pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "      Frequency     -- %li", pVideoTemp->Frequency));

            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((1, "...Found a mode match!"));
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);

    }

    // If no mode has been found, return an error

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((1, "...Couldn't find a mode match!"));
        EngFreeMem(pVideoBuffer);
        goto ReturnFalse;
    }

    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.

    VideoModeInformation = *pVideoModeSelected;
    EngFreeMem(pVideoBuffer);

    #if DEBUG_HEAP
        VideoModeInformation.VisScreenWidth  = 640;
        VideoModeInformation.VisScreenHeight = 480;
    #endif

    // Get the chip type, and at the same time pick up the coprocessor
    // address base:

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                         NULL,
                         0,
                         &RangeInfo,
                         sizeof(VIDEO_PUBLIC_ACCESS_RANGES),
                         &ReturnedDataLength))
    {
        RIP("bEnableHardware - Failed IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES");
        goto ReturnFalse;
    }

    if (VideoModeInformation.DriverSpecificAttributeFlags &
        CAPS_WEITEK_CHIPTYPE_IS_P9000)
    {
        ppdev->flStat |= STAT_P9000;
    }

    ppdev->pjBase
        = (BYTE*) (RangeInfo.VirtualAddress);

    if (!P9000(ppdev))
    {
        ppdev->pjBase += P9100_BASE_CORRECTION;
    }

    // Set up screen information from the mini-port:

    ppdev->ulMode           = VideoModeInformation.ModeIndex;
    ppdev->cxScreen         = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen         = VideoModeInformation.VisScreenHeight;
    ppdev->lDelta           = VideoModeInformation.ScreenStride;
    ppdev->cBitsPerPel      = VideoModeInformation.BitsPerPlane;

    DISPDBG((1, "ScreenStride: %lx", VideoModeInformation.ScreenStride));

    ppdev->flHooks          = (HOOK_BITBLT     |
                               HOOK_TEXTOUT    |
                               HOOK_FILLPATH   |
                               HOOK_COPYBITS   |
                               HOOK_STROKEPATH |
                               HOOK_PAINT      |
                               HOOK_STRETCHBLT |
                               HOOK_SYNCHRONIZE);

    // Fill in the GDIINFO data structure with the default 8bpp values:

    *pgdi = ggdiDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;

    pgdi->cBitsPixel        = VideoModeInformation.BitsPerPlane;
    pgdi->cPlanes           = VideoModeInformation.NumberOfPlanes;
    pgdi->ulVRefresh        = VideoModeInformation.Frequency;

    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    // Fill in the devinfo structure with the default 8bpp values:

    *pdi = gdevinfoDefault;

    //
    // Disable 64 bit access if the hardware does not support it.
    //

    if (VideoModeInformation.AttributeFlags & VIDEO_MODE_NO_64_BIT_ACCESS)
    {
        DISPDBG((0, "Disable 64 bit access on this device !\n"));
        pdi->flGraphicsCaps |= GCAPS_NO64BITMEMACCESS;
    }

    if (P9000(ppdev))
    {
        // We only hook a couple of functions when higher than 8bpp on
        // the P9000:

        if (VideoModeInformation.BitsPerPlane != 8)
        {
            ppdev->flStat |= STAT_UNACCELERATED;

            if ((VideoModeInformation.BitsPerPlane == 15) ||
                (VideoModeInformation.BitsPerPlane == 16))
            {
                // We can do only accelerated solid fills and screen-to-screen
                // blts at 16bpp on the P9000:

                ppdev->flHooks = (HOOK_SYNCHRONIZE |
                                  HOOK_COPYBITS    |
                                  HOOK_STRETCHBLT  |
                                  HOOK_BITBLT);
            }
            else
            {
                // We can do only accelerated screen-to-screen blts at
                // 24bpp or 32bpp on the P9000:

                ppdev->flHooks = (HOOK_SYNCHRONIZE |
                                  HOOK_STRETCHBLT  |
                                  HOOK_COPYBITS);
            }
        }
    }

    if (VideoModeInformation.BitsPerPlane == 8)
    {
        ppdev->cjPel           = 1;
        ppdev->iBitmapFormat   = BMF_8BPP;
        ppdev->ulWhite         = 0xff;
        ppdev->flStat         |= STAT_8BPP;

        // Assuming palette is orthogonal - all colors are same size.

        ppdev->cPaletteShift   = 8 - pgdi->ulDACRed;

        DISPDBG((3, "palette shift = %d", ppdev->cPaletteShift));
    }
    else if ((VideoModeInformation.BitsPerPlane == 16) ||
             (VideoModeInformation.BitsPerPlane == 15))
    {
        ppdev->cjPel           = 2;
        ppdev->iBitmapFormat   = BMF_16BPP;
        ppdev->ulWhite         = 0xffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;
        ppdev->flStat         |= STAT_16BPP;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_16BPP;

        pdi->iDitherFormat     = BMF_16BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }
    else if (VideoModeInformation.BitsPerPlane == 24)
    {
        ppdev->cjPel           = 3;
        ppdev->iBitmapFormat   = BMF_24BPP;
        ppdev->ulWhite         = 0xffffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;
        ppdev->flStat         |= STAT_24BPP;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_24BPP;

        pdi->iDitherFormat     = BMF_24BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }
    else
    {
        ASSERTDD(VideoModeInformation.BitsPerPlane == 32,
                 "This driver supports only 8, 16, 24 and 32bpp");

        ppdev->cjPel           = 4;
        ppdev->iBitmapFormat   = BMF_32BPP;
        ppdev->ulWhite         = 0xffffffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_32BPP;

        pdi->iDitherFormat     = BMF_32BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }

    DISPDBG((5, "Passed bInitializeModeFields"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializeModeFields"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* DWORD getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,
DWORD*                   cbModeSize)
{
    ULONG                   ulTemp;
    VIDEO_NUM_MODES         modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
            NULL,
            0,
            &modes,
            sizeof(VIDEO_NUM_MODES),
            &ulTemp))
    {
        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(FL_ZERO_MEMORY,
                                   modes.NumModes *
                                   modes.ModeInformationLength, ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes - Failed EngAllocMem"));
        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_AVAIL_MODES,
            NULL,
            0,
            *modeInformation,
            modes.NumModes * modes.ModeInformationLength,
            &ulTemp))
    {

        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_AVAIL_MODES"));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8, 15, 16 or 32 bits per pel.
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
            ((pVideoTemp->BitsPerPlane != 8) &&
             (pVideoTemp->BitsPerPlane != 15) &&
             (pVideoTemp->BitsPerPlane != 16) &&
             (pVideoTemp->BitsPerPlane != 24) &&
             (pVideoTemp->BitsPerPlane != 32)))
        {
            DISPDBG((2, "Rejecting miniport mode:"));
            DISPDBG((2, "   Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "   Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "   Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                   pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "   Frequency     -- %li", pVideoTemp->Frequency));

            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return(modes.NumModes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\fastfill.c ===
/******************************Module*Header*******************************\
* Module Name: fastfill.c
*
* Draws fast unclipped, non-complex rectangles.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define RIGHT 0
#define LEFT  1
#define SWAP(a, b, tmp) { tmp = a; a = b; b = tmp; }

typedef struct _EDGEDATA {
LONG      x;                // Current x position
LONG      dx;               // # pixels to advance x on each scan
LONG      lError;           // Current DDA error
LONG      lErrorUp;         // DDA error increment on each scan
LONG      lErrorDown;       // DDA error adjustment
POINTFIX* pptfx;            // Points to start of current edge
LONG      dptfx;            // Delta (in bytes) from pptfx to next point
LONG      cy;               // Number of scans to go for this edge
} EDGEDATA;                         /* ed, ped */

/******************************Public*Routine******************************\
* BOOL bFastFill
*
* Draws a non-complex, unclipped polygon.  'Non-complex' is defined as
* having only two edges that are monotonic increasing in 'y'.  That is,
* the polygon cannot have more than one disconnected segment on any given
* scan.  Note that the edges of the polygon can self-intersect, so hourglass
* shapes are permissible.  This restriction permits this routine to run two
* simultaneous DDAs, and no sorting of the edges is required.
*
* Note that NT's fill convention is different from that of Win 3.1 or 4.0.
* With the additional complication of fractional end-points, our convention
* is the same as in 'X-Windows'.  But a DDA is a DDA is a DDA, so once you
* figure out how we compute the DDA terms for NT, you're golden.
*
* Returns TRUE if the polygon was drawn; FALSE if the polygon was complex.
*
\**************************************************************************/

BOOL bFastFill(
PDEV*       ppdev,
LONG        cEdges,         // Includes close figure edge
POINTFIX*   pptfxFirst,
ULONG       ulHwMix,
ULONG       iSolidColor,
RBRUSH*     prb,
POINTL*     pptlBrush)
{
    BYTE*     pjBase;
    ULONG     ulStat;
    LONG      yTrapezoid;   // Top scan for next trapezoid
    LONG      cyTrapezoid;  // Number of scans in current trapezoid
    LONG      yStart;       // y-position of start point in current edge
    LONG      dM;           // Edge delta in FIX units in x direction
    LONG      dN;           // Edge delta in FIX units in y direction
    LONG      i;
    POINTFIX* pptfxLast;    // Points to the last point in the polygon array
    POINTFIX* pptfxTop;     // Points to the top-most point in the polygon
    POINTFIX* pptfxOld;     // Start point in current edge
    POINTFIX* pptfxScan;    // Current edge pointer for finding pptfxTop
    LONG      cScanEdges;   // Number of edges scanned to find pptfxTop
                            //  (doesn't include the closefigure edge)
    ULONG*    pulPattern;
    ULONG     ulPattern;
    LONG      iEdge;
    LONG      lQuotient;
    LONG      lRemainder;

    EDGEDATA  aed[2];       // DDA terms and stuff
    EDGEDATA* ped;

    // Most polygons will be convex, and so

    pjBase = ppdev->pjBase;

    if (iSolidColor == -1)
    {
        /////////////////////////////////////////////////////////////////
        // Setup for patterns

        // Make sure accelerator is not buy for all types.
        //
        CP_WAIT(ppdev, pjBase);

        if (P9000(ppdev))
        {
            CP_PATTERN_ORGX(ppdev, pjBase, ppdev->xOffset + pptlBrush->x);
            CP_PATTERN_ORGY(ppdev, pjBase, ppdev->yOffset + pptlBrush->y);
            CP_BACKGROUND(ppdev, pjBase, prb->ulColor[0]);
            CP_FOREGROUND(ppdev, pjBase, prb->ulColor[1]);
            pulPattern = &prb->aulPattern[0];
            for (i = 0; i < 4; i++)
            {
                ulPattern = *pulPattern++;
                CP_PATTERN(ppdev, pjBase, i, ulPattern);
                CP_PATTERN(ppdev, pjBase, i + 4, ulPattern);
            }

            if (((ulHwMix >> 8) & 0xff) == (ulHwMix & 0xff))
            {
                ulHwMix = gaulP9000OpaqueFromRop2[(ulHwMix & 0x3C) >> 2];
                CP_RASTER(ppdev, pjBase, ulHwMix | P9000_ENABLE_PATTERN);
            }
            else
            {
                ulHwMix = gaulP9000TransparentFromRop2[(ulHwMix & 0x3C) >> 2];
                CP_RASTER(ppdev, pjBase, ulHwMix | P9000_ENABLE_PATTERN);
            }
        }
        else
        {
            CP_PATTERN_ORGX(ppdev, pjBase, -(ppdev->xOffset + pptlBrush->x));
            CP_PATTERN_ORGY(ppdev, pjBase, -(ppdev->yOffset + pptlBrush->y));
            CP_COLOR0_FAST(ppdev, pjBase, prb->ulColor[0]);
            CP_COLOR1_FAST(ppdev, pjBase, prb->ulColor[1]);
            CP_PATTERN(ppdev, pjBase, 0, prb->aulPattern[0]);
            CP_PATTERN(ppdev, pjBase, 1, prb->aulPattern[1]);
            CP_PATTERN(ppdev, pjBase, 2, prb->aulPattern[2]);
            CP_PATTERN(ppdev, pjBase, 3, prb->aulPattern[3]);
            if (prb->fl & RBRUSH_2COLOR)
            {
                if (((ulHwMix >> 8) & 0xff) == (ulHwMix & 0xff))
                {
                    CP_RASTER(ppdev, pjBase, (ulHwMix & 0xff)
                             | P9100_ENABLE_PATTERN);
                }
                else
                {
                    CP_RASTER(ppdev, pjBase, (ulHwMix & 0xff)
                             | P9100_ENABLE_PATTERN | P9100_TRANSPARENT_PATTERN);
                }
            }
            else
            {
                CP_COLOR2_FAST(ppdev, pjBase, prb->ulColor[2]);
                CP_COLOR3_FAST(ppdev, pjBase, prb->ulColor[3]);
                CP_RASTER(ppdev, pjBase, (ulHwMix & 0xff)
                          | P9100_ENABLE_PATTERN | P9100_FOUR_COLOR_PATTERN);
            }
        }
    }
    else
    {
        /////////////////////////////////////////////////////////////////
        // Setup the hardware for solid colours

        CP_WAIT(ppdev, pjBase);
        if (P9000(ppdev))
        {
            CP_BACKGROUND(ppdev, pjBase, iSolidColor);
            CP_RASTER(ppdev, pjBase, ulHwMix);
        }
        else
        {
            CP_COLOR0(ppdev, pjBase, iSolidColor);
            CP_RASTER(ppdev, pjBase, ulHwMix & 0xff);
        }
    }

    // We can do all integer triangles and convex quadrilaterals directly
    // with the hardware:

    if (cEdges <= 4)
    {
        ASSERTDD(cEdges >= 3, "What's with the degenerate polygon?");

        if ((((pptfxFirst)->x   | (pptfxFirst)->y   |
              (pptfxFirst+1)->x | (pptfxFirst+1)->y |
              (pptfxFirst+2)->x | (pptfxFirst+2)->y) & 0xF) == 0)
        {
            if (cEdges == 3)
            {
                CP_METATRI(ppdev, pjBase, (pptfxFirst)->x   >> 4, (pptfxFirst)->y   >> 4);
                CP_METATRI(ppdev, pjBase, (pptfxFirst+1)->x >> 4, (pptfxFirst+1)->y >> 4);
                CP_METATRI(ppdev, pjBase, (pptfxFirst+2)->x >> 4, (pptfxFirst+2)->y >> 4);

                CP_START_QUAD(ppdev, pjBase);
                return(TRUE);
            }
            else
            {
                if ((((pptfxFirst+3)->x | (pptfxFirst+3)->y) & 0xF) == 0)
                {
                    CP_METAQUAD(ppdev, pjBase, (pptfxFirst)->x   >> 4, (pptfxFirst)->y   >> 4);
                    CP_METAQUAD(ppdev, pjBase, (pptfxFirst+1)->x >> 4, (pptfxFirst+1)->y >> 4);
                    CP_METAQUAD(ppdev, pjBase, (pptfxFirst+2)->x >> 4, (pptfxFirst+2)->y >> 4);
                    CP_METAQUAD(ppdev, pjBase, (pptfxFirst+3)->x >> 4, (pptfxFirst+3)->y >> 4);

                    CP_START_QUAD_STAT(ppdev, pjBase, ulStat);
                    return(!(ulStat & QUADFAIL));
                }
            }
        }
    }

    /////////////////////////////////////////////////////////////////
    // See if the polygon is 'non-complex'

    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;                 // Assume for now that the first
                                            //  point in path is the topmost
    pptfxLast = pptfxFirst + cEdges - 1;

    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'cScanEdges' will the number of edges remaining, including
    // the current one:

    cScanEdges = cEdges - 1;     // The number of edges, not counting close figure

    if ((pptfxScan + 1)->y > pptfxScan->y)
    {
        // Collect all downs:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFillingCheck;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        // Collect all downs:

        pptfxTop = pptfxScan;

        do {
            if ((pptfxScan + 1)->y > pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        return(FALSE);
    }
    else
    {
        // Collect all ups:

        do {
            pptfxTop++;                 // We increment this now because we
                                        //  want it to point to the very last
                                        //  point if we early out in the next
                                        //  statement...
            if (--cScanEdges == 0)
                goto SetUpForFilling;
        } while ((pptfxTop + 1)->y <= pptfxTop->y);

        // Collect all downs:

        pptfxScan = pptfxTop;
        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if ((pptfxScan + 1)->y < pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        return(FALSE);
    }

SetUpForFillingCheck:

    // We check to see if the end of the current edge is higher
    // than the top edge we've found so far:

    if ((pptfxScan + 1)->y < pptfxTop->y)
        pptfxTop = pptfxScan + 1;

SetUpForFilling:

    /////////////////////////////////////////////////////////////////
    // Some Initialization

    yTrapezoid = (pptfxTop->y + 15) >> 4;

    // Make sure we initialize the DDAs appropriately:

    aed[LEFT].cy  = 0;
    aed[RIGHT].cy = 0;

    // For now, guess as to which is the left and which is the right edge:

    aed[LEFT].dptfx  = -(LONG) sizeof(POINTFIX);
    aed[RIGHT].dptfx = sizeof(POINTFIX);
    aed[LEFT].pptfx  = pptfxTop;
    aed[RIGHT].pptfx = pptfxTop;

NewTrapezoid:

    /////////////////////////////////////////////////////////////////
    // DDA initialization

    for (iEdge = 1; iEdge >= 0; iEdge--)
    {
        ped = &aed[iEdge];
        if (ped->cy == 0)
        {
            // Need a new DDA:

            do {
                cEdges--;
                if (cEdges < 0)
                    return(TRUE);

                // Find the next left edge, accounting for wrapping:

                pptfxOld = ped->pptfx;
                ped->pptfx = (POINTFIX*) ((BYTE*) ped->pptfx + ped->dptfx);

                if (ped->pptfx < pptfxFirst)
                    ped->pptfx = pptfxLast;
                else if (ped->pptfx > pptfxLast)
                    ped->pptfx = pptfxFirst;

                // Have to find the edge that spans yTrapezoid:

                ped->cy = ((ped->pptfx->y + 15) >> 4) - yTrapezoid;

                // With fractional coordinate end points, we may get edges
                // that don't cross any scans, in which case we try the
                // next one:

            } while (ped->cy <= 0);

            // 'pptfx' now points to the end point of the edge spanning
            // the scan 'yTrapezoid'.

            dN = ped->pptfx->y - pptfxOld->y;
            dM = ped->pptfx->x - pptfxOld->x;

            ASSERTDD(dN > 0, "Should be going down only");

            // Compute the DDA increment terms:

            if (dM < 0)
            {
                dM = -dM;
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = -1;
                    ped->lErrorUp = dN - dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = -lQuotient;     // - dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                    if (ped->lErrorUp > 0)
                    {
                        ped->dx--;
                        ped->lErrorUp = dN - ped->lErrorUp;
                    }
                }
            }
            else
            {
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = 0;
                    ped->lErrorUp = dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = lQuotient;      // dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                }
            }

            ped->lErrorDown = dN; // DDA limit
            ped->lError     = -1; // Error is initially zero (add dN - 1 for
                                  //  the ceiling, but subtract off dN so that
                                  //  we can check the sign instead of comparing
                                  //  to dN)

            ped->x = pptfxOld->x;
            yStart = pptfxOld->y;

            if ((yStart & 15) != 0)
            {
                // Advance to the next integer y coordinate

                for (i = 16 - (yStart & 15); i != 0; i--)
                {
                    ped->x      += ped->dx;
                    ped->lError += ped->lErrorUp;
                    if (ped->lError >= 0)
                    {
                        ped->lError -= ped->lErrorDown;
                        ped->x++;
                    }
                }
            }

            if ((ped->x & 15) != 0)
            {
                ped->lError -= ped->lErrorDown * (16 - (ped->x & 15));
                ped->x += 15;       // We'll want the ceiling in just a bit...
            }

            // Chop off those fractional bits:

            ped->x      >>= 4;
            ped->lError >>= 4;
        }
    }

    cyTrapezoid = min(aed[LEFT].cy, aed[RIGHT].cy); // # of scans in this trap
    aed[LEFT].cy  -= cyTrapezoid;
    aed[RIGHT].cy -= cyTrapezoid;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((aed[LEFT].lErrorUp | aed[RIGHT].lErrorUp) == 0) &&
        ((aed[LEFT].dx       | aed[RIGHT].dx) == 0))
    {
        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

    ContinueVertical:

        if (aed[LEFT].x < aed[RIGHT].x)
        {
            CP_METARECT(ppdev, pjBase, aed[LEFT].x, yTrapezoid);
            yTrapezoid += cyTrapezoid;
            CP_METARECT(ppdev, pjBase, aed[RIGHT].x, yTrapezoid);

            CP_START_QUAD_WAIT(ppdev, pjBase);
        }
        else if (aed[LEFT].x == aed[RIGHT].x)
        {
            // If the rectangle was too thin to light any pels, we still
            // have to advance the y current position:

            yTrapezoid += cyTrapezoid;
        }
        else
        {
            LONG      lTmp;
            POINTFIX* pptfxTmp;

            SWAP(aed[LEFT].x,          aed[RIGHT].x,          lTmp);
            SWAP(aed[LEFT].cy,         aed[RIGHT].cy,         lTmp);
            SWAP(aed[LEFT].dptfx,      aed[RIGHT].dptfx,      lTmp);
            SWAP(aed[LEFT].pptfx,      aed[RIGHT].pptfx,      pptfxTmp);
            goto ContinueVertical;
        }

        goto NewTrapezoid;
    }

    while (TRUE)
    {
        /////////////////////////////////////////////////////////////////
        // Run the DDAs

        if (aed[LEFT].x < aed[RIGHT].x)
        {
            CP_METARECT(ppdev, pjBase, aed[LEFT].x, yTrapezoid);
            yTrapezoid++;
            CP_METARECT(ppdev, pjBase, aed[RIGHT].x, yTrapezoid);

            CP_START_QUAD_WAIT(ppdev, pjBase);

    ContinueAfterZero:

            // Advance the right wall:

            aed[RIGHT].x      += aed[RIGHT].dx;
            aed[RIGHT].lError += aed[RIGHT].lErrorUp;

            if (aed[RIGHT].lError >= 0)
            {
                aed[RIGHT].lError -= aed[RIGHT].lErrorDown;
                aed[RIGHT].x++;
            }

            // Advance the left wall:

            aed[LEFT].x      += aed[LEFT].dx;
            aed[LEFT].lError += aed[LEFT].lErrorUp;

            if (aed[LEFT].lError >= 0)
            {
                aed[LEFT].lError -= aed[LEFT].lErrorDown;
                aed[LEFT].x++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                goto NewTrapezoid;
        }
        else if (aed[LEFT].x == aed[RIGHT].x)
        {
            yTrapezoid++;
            goto ContinueAfterZero;
        }
        else
        {
            // We certainly don't want to optimize for this case because we
            // should rarely get self-intersecting polygons (if we're slow,
            // the app gets what it deserves):

            LONG      lTmp;
            POINTFIX* pptfxTmp;

            SWAP(aed[LEFT].x,          aed[RIGHT].x,          lTmp);
            SWAP(aed[LEFT].dx,         aed[RIGHT].dx,         lTmp);
            SWAP(aed[LEFT].lError,     aed[RIGHT].lError,     lTmp);
            SWAP(aed[LEFT].lErrorUp,   aed[RIGHT].lErrorUp,   lTmp);
            SWAP(aed[LEFT].lErrorDown, aed[RIGHT].lErrorDown, lTmp);
            SWAP(aed[LEFT].cy,         aed[RIGHT].cy,         lTmp);
            SWAP(aed[LEFT].dptfx,      aed[RIGHT].dptfx,      lTmp);
            SWAP(aed[LEFT].pptfx,      aed[RIGHT].pptfx,      pptfxTmp);

            continue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\hw.h ===
/******************************Module*Header*******************************\
* Module Name: hw.h
*
* All the hardware specific driver file stuff.  Parts are mirrored in
* 'hw.inc'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

//
// Private IOCTL definitions for communicating with the Weitek miniport.
//
// NOTE: These must match the Weitek miniport definitions!
//

#define IOCTL_VIDEO_GET_BASE_ADDR \
        CTL_CODE (FILE_DEVICE_VIDEO, 2048, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _VIDEO_COPROCESSOR_INFORMATION {
    ULONG CoprocessorID;    // 0 == p9000, 1 = p9100
    ULONG FrameBufferBase;
    ULONG CoprocessorBase;
} VIDEO_COPROCESSOR_INFORMATION, *PVIDEO_COPROCESSOR_INFORMATION;

//////////////////////////////////////////////////////////////////////
// Shared p9000 and p9100 Coproc Registers Address Constant definitions
//

#define Status          0x80000         //status register
#define Wmin            0x80220         //pixel clipping window minimum register
#define Wmax            0x80224         //and maximum register
#define Woffset         0x80190         //window offset register

#define Quad            0x80008         //draw a quadrilateral
#define Bitblt          0x80004         //screen to screen blit
#define Pixel8          0xE000C         //host to screen color pixel transfer
#define Pixel1          0xE0080         //host to screen mono pixel transfer w/ expansion
#define Pixel1Full      0xE00FC         //same as above w/ 32bit wide pixels
#define Nextpixel       0x80014         //next pixel

#define PatternOrgX     0x80210         //pattern orgin x
#define PatternOrgY     0x80214         //pattern orgin y
#define PatternRAM      0xE0280         //pattern ram
#define Raster          0x80218         //raster register to write
#define Metacord        0x81218         //meta-coordinate  register

#define Xy0             0x81018         //abs screen addr
#define Xy1             0x81058         //r/w 16-bit x (hi)
#define Xy2             0x81098         //  and
#define Xy3             0x810D8         //    16-bit y (lo)

#define X0              0x81008         //abs screen addr
#define X1              0x81048
#define X2              0x81088
#define X3              0x810C8

#define Y0              0x81010         //abs screen addr
#define Y1              0x81050
#define Y2              0x81090
#define Y3              0x810D0

#define WoffsetBit      0x00020         //bit to set for coordinates relative
                                        //to window offset

//
// p9000 Coproc Registers Address Constant definitions
//

#define Foreground      0x80200         //P9000 foreground color register
#define Background      0x80204         //P9000 background color register

//
// p9100 Coproc Registers Address Constant definitions
//

#define Wmin_b          0x802A0         //byte clipping window minimum register
#define Wmax_b          0x802A4         //and maximum register
#define Color0          0xE0200         //P9100 color[0] register
#define Color1          0xE0204         //P9100 color[1] register
#define Color2          0xE0238         //P9100 color[2] register
#define Color3          0xE023C         //P9100 color[3] register

// We try to share as many register constants as we can between the
// P9000 and the P9100, so that we don't have to duplicate code.
// But the base offset for the registers we used changed somewhat;
// we apply this corrector to the I/O base pointer to compensate:

#define P9100_BASE_CORRECTION       (0x2000L - 0x80000L)

//////////////////////////////////////////////////////////////////////
// Shared p9000 and p9100 Coproc Registers bit template definitions
//

#define BUSY            0x40000000L     //busy, but can start quad or bitblit
#define QBUSY           0x80000000L     //busy, cannot start quad or bitblt
#define QUADFAIL        0x10            //QUAD failed, use software to draw this

#define MetaRect        0x100           //or with METACORD when entering rectangles
#define MetaLine        0x040           //or with METACORD when entering line
#define MetaQuad        0x0C0           //or with METACORD when entering quad
#define MetaTri         0x080           //or with METACORD when entering triangle

//
// p9000 Coproc Registers bit template definitions
//

// For the raster register:

#define P9000_ENABLE_PATTERN        0x20000 //enable pattern
#define P9000_OVERSIZED             0x10000 //enable oversized mode

#define P9000_F                     0xff00L
#define P9000_B                     0xf0f0L
#define P9000_S                     0xccccL
#define P9000_D                     0xaaaaL
#define P9000_OPAQUE_EXPAND         0xfc30L
#define P9000_TRANSPARENT_EXPAND    0xee22L

//
// p9100 Coproc Registers bit template definitions
//

// For the raster register:

#define P9100_TRANSPARENT_PATTERN   0x20000 //enable transparent pattern
#define P9100_OVERSIZED             0x10000 //enable oversized mode
#define P9100_PIXEL1_TRANSPARENT    0x08000 //enable pixel1 transparent mode
#define P9100_FOUR_COLOR_PATTERN    0x04000 //4 colour pattern (8bpp only)
#define P9100_ENABLE_PATTERN        0x02000 //enable pattern

#define P9100_P                     0x00f0L
#define P9100_S                     0x00ccL
#define P9100_D                     0x00aaL
#define P9100_OPAQUE_EXPAND         P9100_S
#define P9100_TRANSPARENT_EXPAND    (P9100_S | P9100_PIXEL1_TRANSPARENT)

//////////////////////////////////////////////////////////////////////
// Alpha and PowerPC considerations
//
// Both the Alpha and the PowerPC do not guarantee that I/O to
// separate addresses will be executed in order.  The Alpha and
// PowerPC differ, however, in that the PowerPC guarantees that
// output to the same address will be executed in order, while the
// Alpha may cache and 'collapse' consecutive output to become only
// one output.
//
// Consequently, we use the following synchronization macros.  They
// are relatively expensive in terms of performance, so we try to avoid
// them whereever possible.
//
// CP_EIEIO() 'Ensure In-order Execution of I/O'
//    - Used to flush any pending I/O in situations where we wish to
//      avoid out-of-order execution of I/O to separate addresses.
//
// CP_MEMORY_BARRIER()
//    - Used to flush any pending I/O in situations where we wish to
//      avoid out-of-order execution or 'collapsing' of I/O to
//      the same address.  On the PowerPC, this will be defined as
//      a null operation.

#if defined(_PPC_)

    // On PowerPC, CP_MEMORY_BARRIER doesn't do anything.

    #define CP_EIEIO()          MEMORY_BARRIER()
    #define CP_MEMORY_BARRIER()

#else

    // On Alpha, CP_EIEIO is the same thing as a CP_MEMORY_BARRIER.
    // On other systems, both CP_EIEIO and CP_MEMORY_BARRIER don't do anything.

    #define CP_EIEIO()          MEMORY_BARRIER()
    #define CP_MEMORY_BARRIER() MEMORY_BARRIER()

#endif

//////////////////////////////////////////////////////////////////////
// Access macros:
//

#define MAX_COORD           0x3fff

#define CP_OUT(pjBase, cjOffset, ul)                    \
    WRITE_REGISTER_ULONG((BYTE*) pjBase + (cjOffset), (ULONG) (ul))

#define CP_IN(pjBase, cjOffset)                         \
    READ_REGISTER_ULONG((BYTE*) pjBase + (cjOffset))

// Note that we have to be careful if 'y' is negative that its signed
// bits don't get ORed into the 'x' component:

#define PACKXY(x, y)        (((x) << 16) | ((y) & 0xffff))

#define CP_WAIT(ppdev, pjBase)                          \
{                                                       \
    do {CP_EIEIO();} while (CP_IN(pjBase, Status) & BUSY);        \
    CP_EIEIO();                                         \
}

#define CP_RASTER(ppdev, pjBase, x)                     \
{                                                       \
    ASSERTDD(P9000(ppdev) || ((x) & 0x01f00) == 0,      \
             "Illegal P9100 raster value");             \
    CP_OUT(pjBase, Raster, (x));                        \
}

#define CP_NEXT_PIXELS(ppdev, pjBase, x)                \
    CP_OUT(pjBase, Nextpixel, (x));

#define CP_START_QUAD(ppdev, pjBase)                    \
{                                                       \
    CP_EIEIO();                                         \
    CP_IN(pjBase, Quad);                                \
    CP_EIEIO();                                         \
}

#define CP_START_QUAD_STAT(ppdev, pjBase, stat)         \
{                                                       \
    CP_EIEIO();                                         \
    stat = CP_IN(pjBase, Quad);                         \
    CP_EIEIO();                                         \
}

#define CP_START_QUAD_WAIT(ppdev, pjBase)               \
{                                                       \
    do {                                                \
        CP_EIEIO();                                     \
    } while (CP_IN(pjBase, Quad) & QBUSY);              \
    CP_EIEIO();                                         \
}

#define CP_START_BLT(ppdev, pjBase)                     \
{                                                       \
    CP_EIEIO();                                         \
    CP_IN(pjBase, Bitblt);                              \
    CP_EIEIO();                                         \
}

#define CP_START_BLT_WAIT(ppdev, pjBase)                \
{                                                       \
    do {                                                \
        CP_EIEIO();                                     \
    } while (CP_IN(pjBase, Bitblt) & QBUSY);            \
    CP_EIEIO();                                         \
}

#define CP_START_QUAD(ppdev, pjBase)                    \
{                                                       \
    CP_EIEIO();                                         \
    CP_IN(pjBase, Quad);                                \
    CP_EIEIO();                                         \
}

#define CP_START_PIXEL8(ppdev, pjBase)                  \
    CP_EIEIO();

#define CP_END_PIXEL8(ppdev, pjBase)                    \
    CP_EIEIO();

#define CP_PIXEL8(ppdev, pjBase, x)                     \
{                                                       \
    CP_OUT(pjBase, Pixel8, (x));                        \
    CP_MEMORY_BARRIER();                                \
}

#define CP_START_PIXEL1(ppdev, pjBase)                  \
    CP_EIEIO();

#define CP_END_PIXEL1(ppdev, pjBase)                    \
    CP_EIEIO();

#define CP_PIXEL1(ppdev, pjBase, x)                     \
{                                                       \
    CP_OUT(pjBase, Pixel1Full, (x));                    \
    CP_MEMORY_BARRIER();                                \
}

// Note: 'count' must be pre-decremented by 1

#define CP_PIXEL1_REM(ppdev, pjBase, count, x)          \
{                                                       \
    /* This EIEIO is to ensure we don't get out of */   \
    /* order with normal full CP_PIXEL1 writes */       \
    CP_EIEIO();                                         \
    CP_OUT(pjBase, Pixel1 + ((count) << 2), (x));       \
}

#define CP_PIXEL1_REM_REGISTER(ppdev, pjBase, count)\
    ((BYTE*) (pjBase) + Pixel1 + ((count) << 2))

#define CP_PIXEL1_VIA_REGISTER(ppdev, pReg, x)          \
{                                                       \
    /* This EIEIO is to ensure we don't get out of */   \
    /* order with normal full CP_PIXEL1 writes */       \
    CP_EIEIO();                                         \
    WRITE_REGISTER_ULONG(pReg, (x));                    \
}

#define CP_PATTERN(ppdev, pjBase, index, x)             \
    CP_OUT(pjBase, PatternRAM + ((index) << 2), (x))

#define CP_PATTERN_ORGX(ppdev, pjBase, x)               \
    CP_OUT(pjBase, PatternOrgX, (x))

#define CP_PATTERN_ORGY(ppdev, pjBase, x)               \
    CP_OUT(pjBase, PatternOrgY, (x))

//

#define CP_METALINE(ppdev, pjBase, x, y)                \
{                                                       \
    CP_OUT(pjBase, Metacord | MetaLine,                 \
           PACKXY((x) + ppdev->xOffset, (y) + ppdev->yOffset));\
    CP_MEMORY_BARRIER();                                \
}

#define CP_METARECT(ppdev, pjBase, x, y)                \
{                                                       \
    CP_OUT(pjBase, Metacord | MetaRect,                 \
           PACKXY((x) + ppdev->xOffset, (y) + ppdev->yOffset));\
    CP_MEMORY_BARRIER();                                \
}

#define CP_METAQUAD(ppdev, pjBase, x, y)                \
{                                                       \
    CP_OUT(pjBase, Metacord | MetaQuad,                 \
           PACKXY((x) + ppdev->xOffset, (y) + ppdev->yOffset));\
    CP_MEMORY_BARRIER();                                \
}

#define CP_METATRI(ppdev, pjBase, x, y)                 \
{                                                       \
    CP_OUT(pjBase, Metacord | MetaTri,                  \
           PACKXY((x) + ppdev->xOffset, (y) + ppdev->yOffset));\
    CP_MEMORY_BARRIER();                                \
}

#define CP_WOFFSET(ppdev, pjBase, x, y)                 \
    CP_OUT(pjBase, Woffset, PACKXY((x), (y)))

#define CP_WMIN(ppdev, pjBase, x, y)                    \
    CP_OUT(pjBase, P9000(ppdev) ? Wmin : Wmin_b,        \
           PACKXY(((x) + ppdev->xOffset) * ppdev->cjPel, (y) + ppdev->yOffset))

#define CP_WMAX(ppdev, pjBase, x, y)                    \
    CP_OUT(pjBase, P9000(ppdev) ? Wmax : Wmax_b,        \
           PACKXY(((x) + ppdev->xOffset + 1) * ppdev->cjPel - 1, (y) + ppdev->yOffset))

#define CP_WLEFT(ppdev, pjBase, x)                      \
    CP_OUT(pjBase, P9000(ppdev) ? Wmin : Wmin_b,        \
           PACKXY(((x) + ppdev->xOffset) * ppdev->cjPel, 0))

#define CP_WRIGHT(ppdev, pjBase, x)                     \
    CP_OUT(pjBase, P9000(ppdev) ? Wmax : Wmax_b,        \
           PACKXY(((x) + ppdev->xOffset + 1) * ppdev->cjPel - 1, MAX_COORD))

#define CP_XY0(ppdev, pjBase, x, y)                     \
    CP_OUT(pjBase, Xy0, PACKXY((x) + ppdev->xOffset, (y) + ppdev->yOffset))

#define CP_XY1(ppdev, pjBase, x, y)                     \
    CP_OUT(pjBase, Xy1, PACKXY((x) + ppdev->xOffset, (y) + ppdev->yOffset))

#define CP_XY2(ppdev, pjBase, x, y)                     \
    CP_OUT(pjBase, Xy2, PACKXY((x) + ppdev->xOffset, (y) + ppdev->yOffset))

#define CP_XY3(ppdev, pjBase, x, y)                     \
    CP_OUT(pjBase, Xy3, PACKXY((x) + ppdev->xOffset, (y) + ppdev->yOffset))

#define CP_X0(ppdev, pjBase, x)                         \
    CP_OUT(pjBase, X0, (x) + ppdev->xOffset)

#define CP_X1(ppdev, pjBase, x)                         \
    CP_OUT(pjBase, X1, (x) + ppdev->xOffset)

#define CP_X2(ppdev, pjBase, x)                         \
    CP_OUT(pjBase, X2, (x) + ppdev->xOffset)

#define CP_X3(ppdev, pjBase, x)                         \
    CP_OUT(pjBase, X3, (x) + ppdev->xOffset)

#define CP_Y0(ppdev, pjBase, y)                         \
    CP_OUT(pjBase, Y0, (y) + ppdev->yOffset)

#define CP_Y1(ppdev, pjBase, y)                         \
    CP_OUT(pjBase, Y1, (y) + ppdev->yOffset)

#define CP_Y2(ppdev, pjBase, y)                         \
    CP_OUT(pjBase, Y2, (y) + ppdev->yOffset)

#define CP_Y3(ppdev, pjBase, y)                         \
    CP_OUT(pjBase, Y3, (y) + ppdev->yOffset)

//

#define CP_WOFF_PACKED_XY0(ppdev, pjBase, xy)           \
    CP_OUT(pjBase, Xy0 | WoffsetBit, (xy))

#define CP_WOFF_PACKED_XY1(ppdev, pjBase, xy)           \
    CP_OUT(pjBase, Xy1 | WoffsetBit, (xy))

#define CP_WOFF_PACKED_XY2(ppdev, pjBase, xy)           \
    CP_OUT(pjBase, Xy2 | WoffsetBit, (xy))

#define CP_WOFF_PACKED_XY3(ppdev, pjBase, xy)           \
    CP_OUT(pjBase, Xy3 | WoffsetBit, (xy))

#define CP_ABS_PACKED_XY0(ppdev, pjBase, xy)           \
    CP_OUT(pjBase, Xy0, (xy))

#define CP_ABS_PACKED_XY1(ppdev, pjBase, xy)           \
    CP_OUT(pjBase, Xy1, (xy))

#define CP_ABS_PACKED_XY2(ppdev, pjBase, xy)           \
    CP_OUT(pjBase, Xy2, (xy))

#define CP_ABS_PACKED_XY3(ppdev, pjBase, xy)           \
    CP_OUT(pjBase, Xy3, (xy))

//

#define CP_ABS_WMIN(ppdev, pjBase, x, y)                \
    CP_OUT(pjBase, P9000(ppdev) ? Wmin : Wmin_b,        \
           PACKXY((x) * ppdev->cjPel, (y)))

#define CP_ABS_WMAX(ppdev, pjBase, x, y)                \
    CP_OUT(pjBase, P9000(ppdev) ? Wmax : Wmax_b,        \
           PACKXY(((x) + 1) * ppdev->cjPel - 1, (y)))

#define CP_ABS_WLEFT(ppdev, pjBase, x)                  \
    CP_OUT(pjBase, P9000(ppdev) ? Wmin : Wmin_b,        \
           PACKXY((x) * ppdev->cjPel, 0))

#define CP_ABS_WRIGHT(ppdev, pjBase, x)                 \
    CP_OUT(pjBase, P9000(ppdev) ? Wmax : Wmax_b,        \
           PACKXY(((x) + 1) * ppdev->cjPel - 1, MAX_COORD))

#define CP_ABS_METARECT(ppdev, pjBase, x, y)            \
{                                                       \
    CP_OUT(pjBase, Metacord | MetaRect, PACKXY((x), (y)));\
    CP_MEMORY_BARRIER();                                \
}

#define CP_ABS_XY0(ppdev, pjBase, x, y)                 \
    CP_OUT(pjBase, Xy0, PACKXY((x), (y)))

#define CP_ABS_XY1(ppdev, pjBase, x, y)                 \
    CP_OUT(pjBase, Xy1, PACKXY((x), (y)))

#define CP_ABS_XY2(ppdev, pjBase, x, y)                 \
    CP_OUT(pjBase, Xy2, PACKXY((x), (y)))

#define CP_ABS_XY3(ppdev, pjBase, x, y)                 \
    CP_OUT(pjBase, Xy3, PACKXY((x), (y)))

#define CP_ABS_PACKED_XY0(ppdev, pjBase, x)             \
    CP_OUT(pjBase, Xy0, (x))

#define CP_ABS_PACKED_XY1(ppdev, pjBase, x)             \
    CP_OUT(pjBase, Xy1, (x))

#define CP_ABS_PACKED_XY2(ppdev, pjBase, x)             \
    CP_OUT(pjBase, Xy2, (x))

#define CP_ABS_PACKED_XY3(ppdev, pjBase, x)             \
    CP_OUT(pjBase, Xy3, (x))

#define CP_ABS_X0(ppdev, pjBase, y)                     \
    CP_OUT(pjBase, X0, (y))

#define CP_ABS_X1(ppdev, pjBase, y)                     \
    CP_OUT(pjBase, X1, (y))

#define CP_ABS_X2(ppdev, pjBase, y)                     \
    CP_OUT(pjBase, X2, (y))

#define CP_ABS_X3(ppdev, pjBase, y)                     \
    CP_OUT(pjBase, X3, (y))

#define CP_ABS_Y0(ppdev, pjBase, y)                     \
    CP_OUT(pjBase, Y0, (y))

#define CP_ABS_Y1(ppdev, pjBase, y)                     \
    CP_OUT(pjBase, Y1, (y))

#define CP_ABS_Y2(ppdev, pjBase, y)                     \
    CP_OUT(pjBase, Y2, (y))

#define CP_ABS_Y3(ppdev, pjBase, y)                     \
    CP_OUT(pjBase, Y3, (y))

///////////////////////////////////////////////////////////////////
// P9000 only macros
//

#define CP_FOREGROUND(ppdev, pjBase, x)                 \
{                                                       \
    ASSERTDD(ppdev->flStat & STAT_P9000, "Foreground"); \
    CP_OUT(pjBase, Foreground, (x));                    \
}

#define CP_BACKGROUND(ppdev, pjBase, x)                 \
{                                                       \
    ASSERTDD(ppdev->flStat & STAT_P9000, "Background"); \
    CP_OUT(pjBase, Background, (x));                    \
}

///////////////////////////////////////////////////////////////////
// P9100 only macros
//

#define PACK_COLOR(ppdev, x, ulResult)                  \
{                                                       \
    ulResult = (x);                                     \
    if (ppdev->flStat & STAT_8BPP)                      \
    {                                                   \
        ulResult |= (ulResult << 8);                    \
        ulResult |= (ulResult << 16);                   \
    }                                                   \
    else if (ppdev->flStat & STAT_16BPP)                \
        ulResult |= (ulResult << 16);                   \
    else if (ppdev->flStat & STAT_24BPP)                \
        ulResult |= (ulResult << 24);                   \
}

#define CP_COLOR0(ppdev, pjBase, x)                     \
{                                                       \
    ULONG ul;                                           \
    ASSERTDD(!(ppdev->flStat & STAT_P9000), "Color0");  \
    PACK_COLOR(ppdev, (x), ul);                         \
    CP_OUT(pjBase, Color0, ul);                         \
}

#define CP_COLOR1(ppdev, pjBase, x)                     \
{                                                       \
    ULONG ul;                                           \
    ASSERTDD(!(ppdev->flStat & STAT_P9000), "Color1");  \
    PACK_COLOR(ppdev, (x), ul);                         \
    CP_OUT(pjBase, Color1, ul);                         \
}

// The _FAST colour macros take colours that are pre-packed for
// the P9100:

#define CP_COLOR0_FAST(ppdev, pjBase, x)                \
{                                                       \
    ASSERTDD(!(ppdev->flStat & STAT_P9000), "Color0");  \
    CP_OUT(pjBase, Color0, (x));                        \
}

#define CP_COLOR1_FAST(ppdev, pjBase, x)                \
{                                                       \
    ASSERTDD(!(ppdev->flStat & STAT_P9000), "Color1");  \
    CP_OUT(pjBase, Color1, (x));                        \
}

#define CP_COLOR2_FAST(ppdev, pjBase, x)                \
{                                                       \
    ASSERTDD(!(ppdev->flStat & STAT_P9000), "Color2");  \
    ASSERTDD(ppdev->flStat & STAT_8BPP, "Color2");      \
    CP_OUT(pjBase, Color2, (x));                        \
}

#define CP_COLOR3_FAST(ppdev, pjBase, x)                \
{                                                       \
    ASSERTDD(!(ppdev->flStat & STAT_P9000), "Color3");  \
    ASSERTDD(ppdev->flStat & STAT_8BPP, "Color3");      \
    CP_OUT(pjBase, Color3, (x));                        \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\paint.c ===
/******************************Module*Header*******************************\
* Module Name: paint.c
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* BOOL DrvPaint
*
\**************************************************************************/

BOOL DrvPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    ROP4 rop4;

    rop4 = ((MIX) gaRop3FromMix[mix >> 8] << 8) | gaRop3FromMix[mix & 0xf];

    // Since our DrvFillPath routine handles almost all fills, DrvPaint
    // won't get called all that much (mainly via PaintRgn, FillRgn, or
    // complex clipped polygons).  As such, we save some code and simply
    // punt to DrvBitBlt:

    return(DrvBitBlt(pso, NULL, NULL, pco, NULL, &pco->rclBounds, NULL,
                     NULL, pbo, pptlBrush, rop4));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\heap.c ===
/******************************Module*Header*******************************\
* Module Name: heap.c
*
* This module contains the routines for a 2-d heap.  It is used primarily
* for allocating space for device-format-bitmaps in off-screen memory.
*
* Off-screen bitmaps are a big deal on NT because:
*
*    1) It reduces the working set.  Any bitmap stored in off-screen
*       memory is a bitmap that isn't taking up space in main memory.
*
*    2) There is a speed win by using the accelerator hardware for
*       drawing, in place of NT's GDI code.  NT's GDI is written entirely
*       in 'C++' and perhaps isn't as fast as it could be.
*
*    3) It leads naturally to nifty tricks that can take advantage of
*       the hardware, such as MaskBlt support and cheap double buffering
*       for OpenGL.
*
* The heap algorithm employed herein attempts to solve an unsolvable
* problem: the problem of keeping arbitrary sized bitmaps as packed as
* possible in a 2-d space, when the bitmaps can come and go at random.
*
* This problem is due entirely to the nature of the hardware for which this
* driver is written: the hardware treats everything as 2-d quantities.  If
* the hardware bitmap pitch could be changed so that the bitmaps could be
* packed linearly in memory, the problem would be infinitely easier (it is
* much easier to track the memory, and the accelerator can be used to re-pack
* the heap to avoid segmentation).
*
* If your hardware can treat bitmaps as one dimensional quantities (as can
* the XGA and ATI), by all means please implement a new off-screen heap.
*
* When the heap gets full, old allocations will automatically be punted
* from off-screen and copied to DIBs, which we'll let GDI draw on.
*
* Note that this heap manages reverse-L shape off-screen memory
* configurations (where the scan pitch is longer than the visible screen,
* such as happens at 800x600 when the scan length must be a multiple of
* 1024).
*
* NOTE: All heap operations must be done under some sort of synchronization,
*       whether it's controlled by GDI or explicitly by the driver.  All
*       the routines in this module assume that they have exclusive access
*       to the heap data structures; multiple threads partying in here at
*       the same time would be a Bad Thing.  (By default, GDI does NOT
*       synchronize drawing on device-created bitmaps.)
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define OH_ALLOC_SIZE   4000        // Do all memory allocations in 4k chunks
#define OH_QUANTUM      8           // The minimum dimension of an allocation
#define CXCY_SENTINEL   0x7fffffff  // The sentinel at the end of the available
                                    //  list has this very large 'cxcy' value

// This macro results in the available list being maintained with a
// cx-major, cy-minor sort:

#define CXCY(cx, cy) (((cx) << 16) | (cy))

/******************************Public*Routine******************************\
* OH* pohNewNode
*
* Allocates a basic memory unit in which we'll pack our data structures.
*
* Since we'll have a lot of OH nodes, most of which we will be
* occasionally traversing, we do our own memory allocation scheme to
* keep them densely packed in memory.
*
* It would be the worst possible thing for the working set to simply
* call EngAllocMem(sizeof(OH)) every time we needed a new node.  There
* would be no locality; OH nodes would get scattered throughout memory,
* and as we traversed the available list for one of our allocations,
* it would be far more likely that we would hit a hard page fault.
\**************************************************************************/

OH* pohNewNode(
PDEV*   ppdev)
{
    LONG     i;
    LONG     cOhs;
    OHALLOC* poha;
    OH*      poh;

    if (ppdev->heap.pohFreeList == NULL)
    {
        // We zero-init to initialize all the OH flags, and to help in
        // debugging (we can afford to do this since we'll be doing this
        // very infrequently):

        poha = EngAllocMem(FL_ZERO_MEMORY, OH_ALLOC_SIZE, ALLOC_TAG);
        if (poha == NULL)
            return(NULL);

        // Insert this OHALLOC at the begining of the OHALLOC chain:

        poha->pohaNext  = ppdev->heap.pohaChain;
        ppdev->heap.pohaChain = poha;

        // This has a '+ 1' because OHALLOC includes an extra OH in its
        // structure declaration:

        cOhs = (OH_ALLOC_SIZE - sizeof(OHALLOC)) / sizeof(OH) + 1;

        // The big OHALLOC allocation is simply a container for a bunch of
        // OH data structures in an array.  The new OH data structures are
        // linked together and added to the OH free list:

        poh = &poha->aoh[0];
        for (i = cOhs - 1; i != 0; i--)
        {
            poh->pohNext = poh + 1;
            poh          = poh + 1;
        }

        poh->pohNext      = NULL;
        ppdev->heap.pohFreeList = &poha->aoh[0];
    }

    poh = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh->pohNext;

    return(poh);
}

/******************************Public*Routine******************************\
* VOID vOhFreeNode
*
* Frees our basic data structure allocation unit by adding it to a free
* list.
*
\**************************************************************************/

VOID vOhFreeNode(
PDEV*   ppdev,
OH*     poh)
{
    if (poh == NULL)
        return;

    poh->pohNext            = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh;
    poh->ofl                = 0;
}

/******************************Public*Routine******************************\
* OH* pohFree
*
* Frees an off-screen heap allocation.  The free space will be combined
* with any adjacent free spaces to avoid segmentation of the 2-d heap.
*
* Note: A key idea here is that the data structure for the upper-left-
*       most node must be kept at the same physical CPU memory so that
*       adjacency links are kept correctly (when two free spaces are
*       merged, the lower or right node can be freed).
*
\**************************************************************************/

OH* pohFree(
PDEV*   ppdev,
OH*     poh)
{
    ULONG cxcy;
    OH*   pohBeside;
    OH*   pohNext;
    OH*   pohPrev;

    if (poh == NULL)
        return(NULL);

    DISPDBG((1, "Freeing %li x %li at (%li, %li)",
            poh->cx, poh->cy, poh->x, poh->y));

    // Update the uniqueness to show that space has been freed, so that
    // we may decide to see if some DIBs can be moved back into off-screen
    // memory:

    ppdev->iHeapUniq++;

MergeLoop:

    ASSERTDD(!(poh->ofl & OFL_PERMANENT), "Can't free permanents for now");

    // Try merging with the right sibling:

    pohBeside = poh->pohRight;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cy      == poh->cy)         &&
        (pohBeside->pohUp   == poh->pohUp)      &&
        (pohBeside->pohDown == poh->pohDown)    &&
        (pohBeside->pohRight->pohLeft != pohBeside))
    {
        // Add the right rectangle to ours:

        poh->cx      += pohBeside->cx;
        poh->pohRight = pohBeside->pohRight;

        // Remove 'pohBeside' from the ??? list and free it:

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Try merging with the lower sibling:

    pohBeside = poh->pohDown;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cx       == poh->cx)        &&
        (pohBeside->pohLeft  == poh->pohLeft)   &&
        (pohBeside->pohRight == poh->pohRight)  &&
        (pohBeside->pohDown->pohUp != pohBeside))
    {
        poh->cy     += pohBeside->cy;
        poh->pohDown = pohBeside->pohDown;

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Try merging with the left sibling:

    pohBeside = poh->pohLeft;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cy       == poh->cy)        &&
        (pohBeside->pohUp    == poh->pohUp)     &&
        (pohBeside->pohDown  == poh->pohDown)   &&
        (pohBeside->pohRight == poh)            &&
        (poh->pohRight->pohLeft != poh))
    {
        // We add our rectangle to the one to the left:

        pohBeside->cx      += poh->cx;
        pohBeside->pohRight = poh->pohRight;

        // Remove 'poh' from the ??? list and free it:

        poh->pohNext->pohPrev = poh->pohPrev;
        poh->pohPrev->pohNext = poh->pohNext;

        vOhFreeNode(ppdev, poh);

        poh = pohBeside;
        goto MergeLoop;
    }

    // Try merging with the upper sibling:

    pohBeside = poh->pohUp;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cx       == poh->cx)        &&
        (pohBeside->pohLeft  == poh->pohLeft)   &&
        (pohBeside->pohRight == poh->pohRight)  &&
        (pohBeside->pohDown  == poh)            &&
        (poh->pohDown->pohUp != poh))
    {
        pohBeside->cy      += poh->cy;
        pohBeside->pohDown  = poh->pohDown;

        poh->pohNext->pohPrev = poh->pohPrev;
        poh->pohPrev->pohNext = poh->pohNext;

        vOhFreeNode(ppdev, poh);

        poh = pohBeside;
        goto MergeLoop;
    }

    // Remove the node from the ???list if it was in use (we wouldn't
    // want to do this for a OFL_PERMANENT node that had been freed):

    poh->pohNext->pohPrev = poh->pohPrev;
    poh->pohPrev->pohNext = poh->pohNext;

    cxcy = CXCY(poh->cx, poh->cy);

    // Insert the node into the available list:

    pohNext = ppdev->heap.ohAvailable.pohNext;
    while (pohNext->cxcy < cxcy)
    {
        pohNext = pohNext->pohNext;
    }
    pohPrev = pohNext->pohPrev;

    pohPrev->pohNext    = poh;
    pohNext->pohPrev    = poh;
    poh->pohPrev        = pohPrev;
    poh->pohNext        = pohNext;

    poh->ofl            = OFL_AVAILABLE;
    poh->cxcy           = cxcy;

    // Return the node pointer for the new and improved available rectangle:

    return(poh);
}

/******************************Public*Routine******************************\
* OH* pohAllocate
*
* Allocates space for an off-screen rectangle.  It will attempt to find
* the smallest available free rectangle, and will allocate the block out
* of its upper-left corner.  The remaining two rectangles will be placed
* on the available free space list.
*
* If the rectangle would have been large enough to fit into off-screen
* memory, but there is not enough available free space, we will boot
* bitmaps out of off-screen and into DIBs until there is enough room.
*
\**************************************************************************/

OH* pohAllocate(
PDEV*   ppdev,
LONG    cxThis,             // Width of rectangle to be allocated
LONG    cyThis,             // Height of rectangle to be allocated
FLOH    floh)               // Allocation flags
{
    ULONG cxcyThis;         // Width and height search key
    OH*   pohThis;          // Points to found available rectangle we'll use
    ULONG cxcy;             // Temporary versions
    OH*   pohNext;
    OH*   pohPrev;

    LONG  cxRem;
    LONG  cyRem;

    OH*   pohBelow;
    LONG  cxBelow;
    LONG  cyBelow;

    OH*   pohBeside;
    LONG  cxBeside;
    LONG  cyBeside;

    DISPDBG((1, "Allocating %li x %li...", cxThis, cyThis));

    ASSERTDD((cxThis > 0) && (cyThis > 0), "Illegal allocation size");

    // Increase the width to get the proper alignment (thus ensuring that all
    // allocations will be properly aligned):

    cxThis = (cxThis + (HEAP_X_ALIGNMENT - 1)) & ~(HEAP_X_ALIGNMENT - 1);

    // We can't succeed if the requested rectangle is larger than the
    // largest possible available rectangle:

    if ((cxThis > ppdev->heap.cxMax) || (cyThis > ppdev->heap.cyMax))
        return(NULL);

    // Find the first available rectangle the same size or larger than
    // the requested one:

    cxcyThis = CXCY(cxThis, cyThis);
    pohThis  = ppdev->heap.ohAvailable.pohNext;
    while (pohThis->cxcy < cxcyThis)
    {
        pohThis = pohThis->pohNext;
    }

    while (pohThis->cy < cyThis)
    {
        pohThis = pohThis->pohNext;
    }

    if (pohThis->cxcy == CXCY_SENTINEL)
    {
        // There was no space large enough...

        if (floh & FLOH_ONLY_IF_ROOM)
            return(NULL);

        // We couldn't find an available rectangle that was big enough
        // to fit our request.  So throw things out of the heap until we
        // have room:

        do {
            pohThis = ppdev->heap.ohDfb.pohPrev;  // Least-recently blitted

            ASSERTDD(pohThis != &ppdev->heap.ohDfb, "Ran out of in-use entries");

            // We can safely exit here if we have to:

            pohThis = pohMoveOffscreenDfbToDib(ppdev, pohThis);
            if (pohThis == NULL)
                return(NULL);

        } while ((pohThis->cx < cxThis) || (pohThis->cy < cyThis));
    }

    // We've now found an available rectangle that is the same size or
    // bigger than our requested rectangle.  We're going to use the
    // upper-left corner of our found rectangle, and divide the unused
    // remainder into two rectangles which will go on the available
    // list.

    // Compute the width of the unused rectangle to the right, and the
    // height of the unused rectangle below:

    cyRem = pohThis->cy - cyThis;
    cxRem = pohThis->cx - cxThis;

    // Given finite area, we wish to find the two rectangles that are
    // most square -- i.e., the arrangement that gives two rectangles
    // with the least perimiter:

    cyBelow  = cyRem;
    cxBeside = cxRem;

    if (cxRem <= cyRem)
    {
        cxBelow  = cxThis + cxRem;
        cyBeside = cyThis;
    }
    else
    {
        cxBelow  = cxThis;
        cyBeside = cyThis + cyRem;
    }

    // We only make new available rectangles of the unused right and bottom
    // portions if they're greater in dimension than OH_QUANTUM (it hardly
    // makes sense to do the book-work to keep around a 2-pixel wide
    // available space, for example):

    pohBeside = NULL;
    if (cxBeside >= OH_QUANTUM)
    {
        pohBeside = pohNewNode(ppdev);
        if (pohBeside == NULL)
            return(NULL);
    }

    pohBelow = NULL;
    if (cyBelow >= OH_QUANTUM)
    {
        pohBelow = pohNewNode(ppdev);
        if (pohBelow == NULL)
        {
            vOhFreeNode(ppdev, pohBeside);
            return(NULL);
        }

        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBelow, cyBelow);
        pohNext = ppdev->heap.ohAvailable.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext   = pohBelow;
        pohNext->pohPrev   = pohBelow;
        pohBelow->pohPrev  = pohPrev;
        pohBelow->pohNext  = pohNext;

        // Now update the adjacency information:

        pohBelow->pohLeft  = pohThis->pohLeft;
        pohBelow->pohUp    = pohThis;
        pohBelow->pohRight = pohThis->pohRight;
        pohBelow->pohDown  = pohThis->pohDown;

        // Update the rest of the new node information:

        pohBelow->cxcy     = cxcy;
        pohBelow->ofl      = OFL_AVAILABLE;
        pohBelow->x        = pohThis->x;
        pohBelow->y        = pohThis->y + cyThis;
        pohBelow->cx       = cxBelow;
        pohBelow->cy       = cyBelow;

        // Modify the current node to reflect the changes we've made:

        pohThis->cy        = cyThis;
    }

    if (cxBeside >= OH_QUANTUM)
    {
        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBeside, cyBeside);
        pohNext = ppdev->heap.ohAvailable.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext    = pohBeside;
        pohNext->pohPrev    = pohBeside;
        pohBeside->pohPrev  = pohPrev;
        pohBeside->pohNext  = pohNext;

        // Now update the adjacency information:

        pohBeside->pohUp    = pohThis->pohUp;
        pohBeside->pohLeft  = pohThis;
        pohBeside->pohDown  = pohThis->pohDown;
        pohBeside->pohRight = pohThis->pohRight;

        // Update the rest of the new node information:

        pohBeside->cxcy     = cxcy;
        pohBeside->ofl      = OFL_AVAILABLE;
        pohBeside->x        = pohThis->x + cxThis;
        pohBeside->y        = pohThis->y;
        pohBeside->cx       = cxBeside;
        pohBeside->cy       = cyBeside;

        // Modify the current node to reflect the changes we've made:

        pohThis->cx         = cxThis;
    }

    if (pohBelow != NULL)
    {
        pohThis->pohDown = pohBelow;
        if ((pohBeside != NULL) && (cyBeside == pohThis->cy))
            pohBeside->pohDown = pohBelow;
    }
    if (pohBeside != NULL)
    {
        pohThis->pohRight = pohBeside;
        if ((pohBelow != NULL) && (cxBelow == pohThis->cx))
            pohBelow->pohRight  = pohBeside;
    }

    pohThis->ofl                 = OFL_INUSE;
    pohThis->cxcy                = CXCY(pohThis->cx, pohThis->cy);
    pohThis->pdsurf              = NULL;    // Caller is responsible for
                                            //   setting this field

    // Remove this from the available list:

    pohThis->pohPrev->pohNext    = pohThis->pohNext;
    pohThis->pohNext->pohPrev    = pohThis->pohPrev;

    // Now insert this at the head of the DFB list:

    pohThis->pohNext                   = ppdev->heap.ohDfb.pohNext;
    pohThis->pohPrev                   = &ppdev->heap.ohDfb;
    ppdev->heap.ohDfb.pohNext->pohPrev = pohThis;
    ppdev->heap.ohDfb.pohNext          = pohThis;

    DISPDBG((1, "   Allocated at (%li, %li)", pohThis->x, pohThis->y));

    // Calculate the effective start address for this bitmap in off-
    // screen memory:

    pohThis->pvScan0 = ppdev->pjScreen + (pohThis->y * ppdev->lDelta)
                                       + (pohThis->x * ppdev->cjPel);

    return(pohThis);
}

/******************************Public*Routine******************************\
* VOID vCalculateMaxmimum
*
* Traverses the list of in-use and available rectangles to find the one
* with the maximal area.
*
\**************************************************************************/

VOID vCalculateMaximum(
PDEV*   ppdev)
{
    OH*     poh;
    OH*     pohSentinel;
    LONG    lArea;
    LONG    lMaxArea;
    LONG    cxMax;
    LONG    cyMax;
    LONG    i;

    lMaxArea = 0;
    cxMax    = 0;
    cyMax    = 0;

    // First time through, loop through the list of available rectangles:

    pohSentinel = &ppdev->heap.ohAvailable;

    for (i = 2; i != 0; i--)
    {
        for (poh = pohSentinel->pohNext; poh != pohSentinel; poh = poh->pohNext)
        {
            ASSERTDD(!(poh->ofl & OFL_PERMANENT),
                     "Permanent in available/DFB chain?");

            // We don't have worry about this multiply overflowing
            // because we are dealing in physical screen coordinates,
            // which will probably never be more than 15 bits:

            lArea = poh->cx * poh->cy;
            if (lArea > lMaxArea)
            {
                cxMax    = poh->cx;
                cyMax    = poh->cy;
                lMaxArea = lArea;
            }
        }

        // Second time through, loop through the list of in-use rectangles:

        pohSentinel = &ppdev->heap.ohDfb;
    }

    // All that we are interested in is the dimensions of the rectangle
    // that has the largest possible available area (and remember that
    // there might not be any possible available area):

    ppdev->heap.cxMax = cxMax;
    ppdev->heap.cyMax = cyMax;
}

/******************************Public*Routine******************************\
* OH* pohAllocatePermanent
*
* Allocates an off-screen rectangle that can never be booted of the heap.
* It's the caller's responsibility to manage the rectangle, which includes
* what to do with the memory in DrvAssertMode when the display is changed
* to full-screen mode.
*
\**************************************************************************/

OH* pohAllocatePermanent(
PDEV*   ppdev,
LONG    cx,
LONG    cy)
{
    OH*     poh;

    poh = pohAllocate(ppdev, cx, cy, 0);
    if (poh != NULL)
    {
        // Mark the rectangle as permanent:

        poh->ofl = OFL_PERMANENT;

        // Remove the node from the most-recently blitted list:

        poh->pohPrev->pohNext = poh->pohNext;
        poh->pohNext->pohPrev = poh->pohPrev;
        poh->pohPrev = NULL;
        poh->pohNext = NULL;

        // Now calculate the new maximum size rectangle available in the
        // heap:

        vCalculateMaximum(ppdev);
    }

    return(poh);
}

/******************************Public*Routine******************************\
* BOOL bMoveDibToOffscreenDfbIfRoom
*
* Converts the DIB DFB to an off-screen DFB, if there's room for it in
* off-screen memory.
*
* Returns: FALSE if there wasn't room, TRUE if successfully moved.
*
\**************************************************************************/

BOOL bMoveDibToOffscreenDfbIfRoom(
PDEV*   ppdev,
DSURF*  pdsurf)
{
    OH*         poh;
    SURFOBJ*    pso;
    RECTL       rclDst;
    POINTL      ptlSrc;
    HSURF       hsurf;

    ASSERTDD(pdsurf->dt == DT_DIB,
             "Can't move a bitmap off-screen when it's already off-screen");

    // If we're in full-screen mode, we can't move anything to off-screen
    // memory:

    if (!ppdev->bEnabled)
        return(FALSE);

    poh = pohAllocate(ppdev, pdsurf->sizl.cx, pdsurf->sizl.cy,
                      FLOH_ONLY_IF_ROOM);
    if (poh == NULL)
    {
        // There wasn't any free room.

        return(FALSE);
    }

    // 'pdsurf->sizl' is the actual bitmap dimension, not 'poh->cx' or
    // 'poh->cy'.

    rclDst.left   = poh->x;
    rclDst.top    = poh->y;
    rclDst.right  = rclDst.left + pdsurf->sizl.cx;
    rclDst.bottom = rclDst.top  + pdsurf->sizl.cy;

    ptlSrc.x      = 0;
    ptlSrc.y      = 0;

    vPutBits(ppdev, pdsurf->pso, &rclDst, &ptlSrc);

    // Update the data structures to reflect the new off-screen node:

    pso           = pdsurf->pso;
    pdsurf->dt    = DT_SCREEN;
    pdsurf->poh   = poh;
    poh->pdsurf   = pdsurf;

    // Now free the DIB.  Get the hsurf from the SURFOBJ before we unlock
    // it (it's not legal to dereference psoDib when it's unlocked):

    hsurf = pso->hsurf;
    EngUnlockSurface(pso);
    EngDeleteSurface(hsurf);

    return(TRUE);
}

/******************************Public*Routine******************************\
* OH* pohMoveOffscreenDfbToDib
*
* Converts the DFB from being off-screen to being a DIB.
*
* Note: The caller does NOT have to call 'pohFree' on 'poh' after making
*       this call.
*
* Returns: NULL if the function failed (due to a memory allocation).
*          Otherwise, it returns a pointer to the coalesced off-screen heap
*          node that has been made available for subsequent allocations
*          (useful when trying to free enough memory to make a new
*          allocation).
\**************************************************************************/

OH* pohMoveOffscreenDfbToDib(
PDEV*   ppdev,
OH*     poh)
{
    DSURF*   pdsurf;
    HBITMAP  hbmDib;
    SURFOBJ* pso;
    RECTL    rclDst;
    POINTL   ptlSrc;

    DISPDBG((1, "Throwing out %li x %li at (%li, %li)!",
                 poh->cx, poh->cy, poh->x, poh->y));

    pdsurf = poh->pdsurf;

    ASSERTDD((poh->x != 0) || (poh->y != 0),
            "Can't make the visible screen into a DIB");
    ASSERTDD(pdsurf->dt != DT_DIB,
            "Can't make a DIB into even more of a DIB");

    hbmDib = EngCreateBitmap(pdsurf->sizl, 0, ppdev->iBitmapFormat,
                             BMF_TOPDOWN, NULL);
    if (hbmDib)
    {
        if (EngAssociateSurface((HSURF) hbmDib, ppdev->hdevEng, 0))
        {
            pso = EngLockSurface((HSURF) hbmDib);
            if (pso != NULL)
            {
                rclDst.left   = 0;
                rclDst.top    = 0;
                rclDst.right  = pdsurf->sizl.cx;
                rclDst.bottom = pdsurf->sizl.cy;

                ptlSrc.x      = poh->x;
                ptlSrc.y      = poh->y;

                vGetBits(ppdev, pso, &rclDst, &ptlSrc);

                pdsurf->dt    = DT_DIB;
                pdsurf->pso   = pso;

                // Don't even bother checking to see if this DIB should
                // be put back into off-screen memory until the next
                // heap 'free' occurs:

                pdsurf->iUniq = ppdev->iHeapUniq;
                pdsurf->cBlt  = 0;

                // Remove this node from the off-screen DFB list, and free
                // it.  'pohFree' will never return NULL:

                return(pohFree(ppdev, poh));
            }
        }

        // Fail case:

        EngDeleteSurface((HSURF) hbmDib);
    }

    return(NULL);
}

/******************************Public*Routine******************************\
* BOOL bMoveEverythingFromOffscreenToDibs
*
* This function is used when we're about to enter full-screen mode, which
* would wipe all our off-screen bitmaps.  GDI can ask us to draw on
* device bitmaps even when we're in full-screen mode, and we do NOT have
* the option of stalling the call until we switch out of full-screen.
* We have no choice but to move all the off-screen DFBs to DIBs.
*
* Returns TRUE if all DSURFs have been successfully moved.
*
\**************************************************************************/

BOOL bMoveAllDfbsFromOffscreenToDibs(
PDEV*   ppdev)
{
    OH*  poh;
    OH*  pohNext;
    BOOL bRet;

    bRet = TRUE;
    poh  = ppdev->heap.ohDfb.pohNext;
    while (poh != &ppdev->heap.ohDfb)
    {
        pohNext = poh->pohNext;

        // If something's already a DIB, we shouldn't try to make it even
        // more of a DIB:

        if (poh->pdsurf->dt == DT_SCREEN)
        {
            if (!pohMoveOffscreenDfbToDib(ppdev, poh))
                bRet = FALSE;
        }

        poh = pohNext;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* HBITMAP DrvCreateDeviceBitmap
*
* Function called by GDI to create a device-format-bitmap (DFB).  We will
* always try to allocate the bitmap in off-screen; if we can't, we simply
* fail the call and GDI will create and manage the bitmap itself.
*
* Note: We do not have to zero the bitmap bits.  GDI will automatically
*       call us via DrvBitBlt to zero the bits (which is a security
*       consideration).
*
\**************************************************************************/

HBITMAP DrvCreateDeviceBitmap(
DHPDEV  dhpdev,
SIZEL   sizl,
ULONG   iFormat)
{
    PDEV*   ppdev;
    OH*     poh;
    DSURF*  pdsurf;
    HBITMAP hbmDevice;
    FLONG   flHooks;

    // 8 bit stretch blts fail for unknown reasons on ppc, so preclude
    // accelerated offscreen bitmaps.
#ifdef PPC
    return (0);
#endif

    ppdev = (PDEV*) dhpdev;

    // We don't bother supporting device bitmaps with the P9000 when at
    // 16bpp or 32bpp:

    if (ppdev->flStat & STAT_UNACCELERATED)
        return(0);

    // If we're in full-screen mode, we hardly have any off-screen memory
    // in which to allocate a DFB.  LATER: We could still allocate an
    // OH node and put the bitmap on the DIB DFB list for later promotion.

    if (!ppdev->bEnabled)
        return(0);

    // We only support device bitmaps that are the same colour depth
    // as our display.
    //
    // Actually, those are the only kind GDI will ever call us with,
    // but we may as well check.  Note that this implies you'll never
    // get a crack at 1bpp bitmaps.

    if (iFormat != ppdev->iBitmapFormat)
        return(0);

    // We don't want anything 8x8 or smaller -- they're typically brush
    // patterns which we don't particularly want to stash in off-screen
    // memory:

    if ((sizl.cx <= 8) && (sizl.cy <= 8))
        return(0);

    poh = pohAllocate(ppdev, sizl.cx, sizl.cy, 0);
    if (poh != NULL)
    {
        pdsurf = EngAllocMem(0, sizeof(DSURF), ALLOC_TAG);
        if (pdsurf != NULL)
        {
            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, sizl, iFormat);
            if (hbmDevice != NULL)
            {
                flHooks = ppdev->flHooks;

                // Setting the SYNCHRONIZEACCESS flag tells GDI that we
                // want all drawing to the bitmaps to be synchronized (GDI
                // is multi-threaded and by default does not synchronize
                // device bitmap drawing -- it would be a Bad Thing for us
                // to have multiple threads using the accelerator at the
                // same time):

                flHooks |= HOOK_SYNCHRONIZEACCESS;

                // It's a device-managed surface; make sure we don't set
                // HOOK_SYNCHRONIZE, otherwise we may confuse GDI:

                flHooks &= ~HOOK_SYNCHRONIZE;

                if (EngAssociateSurface((HSURF) hbmDevice, ppdev->hdevEng,
                                        flHooks))
                {
                    pdsurf->dt    = DT_SCREEN;
                    pdsurf->poh   = poh;
                    pdsurf->sizl  = sizl;
                    pdsurf->ppdev = ppdev;
                    poh->pdsurf   = pdsurf;

                    return(hbmDevice);
                }

                EngDeleteSurface((HSURF) hbmDevice);
            }
            EngFreeMem(pdsurf);
        }
        pohFree(ppdev, poh);
    }

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDeleteDeviceBitmap
*
* Deletes a DFB.
*
\**************************************************************************/

VOID DrvDeleteDeviceBitmap(
DHSURF  dhsurf)
{
    DSURF*   pdsurf;
    PDEV*    ppdev;
    SURFOBJ* psoDib;
    HSURF    hsurfDib;

    pdsurf = (DSURF*) dhsurf;
    ppdev  = pdsurf->ppdev;

    if (pdsurf->dt == DT_SCREEN)
    {
        pohFree(ppdev, pdsurf->poh);
    }
    else
    {
        ASSERTDD(pdsurf->dt == DT_DIB, "Expected DIB type");

        psoDib = pdsurf->pso;

        // Get the hsurf from the SURFOBJ before we unlock it (it's not
        // legal to dereference psoDib when it's unlocked):

        hsurfDib = psoDib->hsurf;
        EngUnlockSurface(psoDib);
        EngDeleteSurface(hsurfDib);
    }

    EngFreeMem(pdsurf);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeOffscreenHeap
*
* This function is called whenever we switch in or out of full-screen
* mode.  We have to convert all the off-screen bitmaps to DIBs when
* we switch to full-screen (because we may be asked to draw on them even
* when in full-screen, and the mode switch would probably nuke the video
* memory contents anyway).
*
\**************************************************************************/

BOOL bAssertModeOffscreenHeap(
PDEV*   ppdev,
BOOL    bEnable)
{
    BOOL b;

    b = TRUE;

    if (!bEnable)
    {
        b = bMoveAllDfbsFromOffscreenToDibs(ppdev);
    }

    return(b);
}

/******************************Public*Routine******************************\
* VOID vDisableOffscreenHeap
*
* Frees any resources allocated by the off-screen heap.
*
\**************************************************************************/

VOID vDisableOffscreenHeap(
PDEV*   ppdev)
{
    OHALLOC* poha;
    OHALLOC* pohaNext;
    SURFOBJ* psoPunt;
    HSURF    hsurf;

    psoPunt = ppdev->psoPunt;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }

    psoPunt = ppdev->psoPunt2;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }

    poha = ppdev->heap.pohaChain;
    while (poha != NULL)
    {
        pohaNext = poha->pohaNext;  // Grab the next pointer before it's freed
        EngFreeMem(poha);
        poha = pohaNext;
    }
}

/******************************Public*Routine******************************\
* BOOL bEnableOffscreenHeap
*
* Initializes the off-screen heap using all available video memory,
* accounting for the portion taken by the visible screen.
*
* Input: ppdev->cxScreen
*        ppdev->cyScreen
*        ppdev->cxMemory
*        ppdev->cyMemory
*
\**************************************************************************/

BOOL bEnableOffscreenHeap(
PDEV*   ppdev)
{
    OH*         poh;
    SIZEL       sizl;
    HSURF       hsurf;

    DISPDBG((5, "Screen: %li x %li  Memory: %li x %li",
        ppdev->cxScreen, ppdev->cyScreen, ppdev->cxMemory, ppdev->cyMemory));

    ppdev->heap.pohaChain   = NULL;
    ppdev->heap.pohFreeList = NULL;

    // Initialize the available list, which will be a circular
    // doubly-linked list kept in ascending 'cxcy' order, with a
    // 'sentinel' at the end of the list:

    poh = pohNewNode(ppdev);
    if (poh == NULL)
        goto ReturnFalse;

    // The first node describes the entire video memory size:

    poh->pohNext  = &ppdev->heap.ohAvailable;
    poh->pohPrev  = &ppdev->heap.ohAvailable;
    poh->ofl      = OFL_AVAILABLE;
    poh->x        = 0;
    poh->y        = 0;
    poh->cx       = ppdev->cxMemory;
    poh->cy       = ppdev->cyMemory;
    poh->cxcy     = CXCY(ppdev->cxMemory, ppdev->cyMemory);
    poh->pohLeft  = &ppdev->heap.ohAvailable;
    poh->pohUp    = &ppdev->heap.ohAvailable;
    poh->pohRight = &ppdev->heap.ohAvailable;
    poh->pohDown  = &ppdev->heap.ohAvailable;
    poh->pvScan0  = ppdev->pjScreen;

    // The second node is our available list sentinel:

    ppdev->heap.ohAvailable.pohNext = poh;
    ppdev->heap.ohAvailable.pohPrev = poh;
    ppdev->heap.ohAvailable.cxcy    = CXCY_SENTINEL;
    ppdev->heap.ohAvailable.cx      = 0x7fffffff;
    ppdev->heap.ohAvailable.cy      = 0x7fffffff;
    ppdev->heap.ohAvailable.ofl     = OFL_PERMANENT;
    ppdev->heap.ohDfb.pohLeft       = NULL;
    ppdev->heap.ohDfb.pohUp         = NULL;
    ppdev->heap.ohDfb.pohRight      = NULL;
    ppdev->heap.ohDfb.pohDown       = NULL;

    // Initialize the most-recently-blitted DFB list, which will be
    // a circular doubly-linked list kept in order, with a sentinel at
    // the end.  This node is also used for the screen-surface, for its
    // offset:

    ppdev->heap.ohDfb.pohNext  = &ppdev->heap.ohDfb;
    ppdev->heap.ohDfb.pohPrev  = &ppdev->heap.ohDfb;
    ppdev->heap.ohDfb.ofl      = OFL_PERMANENT;

    // For the moment, make the max really big so that the first
    // allocation we're about to do will succeed:

    ppdev->heap.cxMax = 0x7fffffff;
    ppdev->heap.cyMax = 0x7fffffff;

    // Finally, reserve the upper-left corner for the screen.  We can
    // actually throw away 'poh' because we'll never need it again
    // (not even for disabling the off-screen heap since everything is
    // freed using OHALLOCs):

    poh = pohAllocatePermanent(ppdev, ppdev->cxScreen, ppdev->cyScreen);

    // Remember it so that we can associate the screen SURFOBJ with this
    // poh:

    ppdev->pohScreen = poh;

    ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y == 0),
             "We assumed allocator would use the upper-left corner");

    // Allocate a 'punt' SURFOBJ we'll use when the device-bitmap is in
    // off-screen memory, but we want GDI to draw to it directly as an
    // engine-managed surface:

    sizl.cx = ppdev->cxMemory;
    sizl.cy = ppdev->cyMemory;

    // We want to create it with exactly the same hooks, capabilities,
    // and screen delta as our primary surface:

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    ppdev->lDelta,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    ppdev->pjScreen);

    if ((hsurf == 0)                                                  ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks)) ||
        (!(ppdev->psoPunt = EngLockSurface(hsurf))))
    {
        DISPDBG((0, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    // We need another for doing DrvBitBlt and DrvCopyBits when both
    // surfaces are off-screen bitmaps:

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    ppdev->lDelta,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    ppdev->pjScreen);

    if ((hsurf == 0)                                                  ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks)) ||
        (!(ppdev->psoPunt2 = EngLockSurface(hsurf))))
    {
        DISPDBG((0, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    DISPDBG((5, "Passed bEnableOffscreenHeap"));

    if (poh != NULL)
        return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableOffscreenHeap"));

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\lines.c ===
/*************************************************************************\
* Module Name: Lines.c
*
* Contains most of the required GDI line support.  Supports drawing
* lines in short 'strips' when clipping is complex or coordinates
* are too large to be drawn by the line hardware.
*
* Copyright (c) 1990-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

///////////////////////////////////////////////////////////////////////

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// UUInt32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit ULONGs to produce a 64-bit DWORDLONG result.
//
// UInt64By32To32 is our own macro to divide a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// UInt64Mod32To32 is our own macro to modulus a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// 64 bit divides are usually very expensive.  Since it's very rare
// that we'll get lines where the upper 32 bits of the 64 bit result
// are used, we can almost always use 32-bit ULONG divides.  We still
// must correctly handle the larger cases:

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define UInt64Mod32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) % (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) % (ULONG)(b)))

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_V
    FL_V_ROUND_DOWN,                   // FL_FLIP_V | FL_FLIP_D
    FL_V_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE
    0xbaadf00d,                        // FL_FLIP_SLOPE_ONE | FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE | FL_FLIP_V
    0xbaadf00d                         // FL_FLIP_SLOPE_ONE | FL_FLIP_V | FL_FLIP_D
};

/******************************Public*Routine******************************\
* BOOL bLines(ppdev, pptfxFirst, pptfxBuf, cptfx, pls,
*                   prclClip, apfn[], flStart)
*
* Computes the DDA for the line and gets ready to draw it.  Puts the
* pixel data into an array of strips, and calls a strip routine to
* do the actual drawing.
*
\**************************************************************************/

BOOL bLines(
PDEV*      ppdev,
POINTFIX*  pptfxFirst,  // Start of first line
POINTFIX*  pptfxBuf,    // Pointer to buffer of all remaining lines
RUN*       prun,        // Pointer to runs if doing complex clipping
ULONG      cptfx,       // Number of points in pptfxBuf or number of runs
                        // in prun
LINESTATE* pls,         // Colour and style info
RECTL*     prclClip,    // Pointer to clip rectangle if doing simple clipping
PFNSTRIP*  apfn,        // Array of strip functions
FLONG      flStart,     // Flags for each line, which is a combination of:
                        //      FL_SIMPLE_CLIP
                        //      FL_COMPLEX_CLIP
                        //      FL_STYLED
                        //      FL_LAST_PEL_INCLUSIVE
                        //        - Should be set only for all integer lines,
                        //          and can't be used with FL_COMPLEX_CLIP
ULONG      ulHwMix)
{
    ULONG     M0;
    ULONG     dM;
    ULONG     N0;
    ULONG     dN;
    ULONG     dN_Original;
    FLONG     fl;
    LONG      x;
    LONG      y;

    LONGLONG  llBeta;
    LONGLONG  llGamma;
    LONGLONG  dl;
    LONGLONG  ll;

    ULONG     ulDelta;

    ULONG     x0;
    ULONG     y0;
    ULONG     x1;
    ULONG     cStylePels;    // Major length of line in pixels for styling
    ULONG     xStart;
    POINTL    ptlStart;
    STRIP     strip;
    PFNSTRIP  pfn;
    LONG      cPels;
    LONG*     plStrip;
    LONG*     plStripEnd;
    LONG      cStripsInNextRun;

    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx; // Last point in path record
    STYLEPOS  spThis;                         // Style pos for this line
    BYTE*     pjBase;

    pjBase = ppdev->pjBase;

    do {

/***********************************************************************\
* Start the DDA calculations.                                           *
\***********************************************************************/

        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;

        // Check for non-clipped, non-styled integer endpoint lines

        if ((fl & (FL_CLIP | FL_STYLED)) == 0)
        {
            // Special-case integer end-point lines:

            if (((M0 | dM | N0 | dN) & (F - 1)) == 0)
            {
                LONG x0;
                LONG y0;
                LONG x1;
                LONG y1;

                x0 = M0 >> FLOG2;
                x1 = dM >> FLOG2;
                y0 = N0 >> FLOG2;
                y1 = dN >> FLOG2;

                // Unfortunately, we can only use the Weitek's point-
                // to-point capability for perfectly horizontal and
                // vertical lines, because for other lines the tie-
                // breaker rule comes into play, and the Weitek has
                // exactly the wrong tie-breaker convention.

                if (y0 == y1)
                {
                    // Horizontal integer line.  Do last-pel exclusion:

                    if (x0 < x1)
                        x1--;
                    else if (x0 > x1)
                        x1++;
                    else
                        goto Next_Line;         // Zero-pel line

                    CP_METALINE(ppdev, pjBase, x0, y0);
                    CP_METALINE(ppdev, pjBase, x1, y1);
                    CP_START_QUAD_WAIT(ppdev, pjBase);
                    goto Next_Line;
                }
                else if (x0 == x1)
                {
                    // Vertical integer line.  Do last-pel exclusion:

                    if (y0 < y1)
                        y1--;
                    else
                        y1++;

                    CP_METALINE(ppdev, pjBase, x0, y0);
                    CP_METALINE(ppdev, pjBase, x1, y1);
                    CP_START_QUAD_WAIT(ppdev, pjBase);
                    goto Next_Line;
                }
            }
        }

        if ((LONG) M0 > (LONG) dM)
        {
        // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

    // Compute the delta dx.  The DDI says we can never have a valid delta
    // with a magnitued more than 2^31 - 1, but GDI never actually checks
    // its transforms.  So we have to check for this case to avoid overflow:

        dM -= M0;
        if ((LONG) dM < 0)
        {
            goto Next_Line;
        }

        if ((LONG) dN < (LONG) N0)
        {
        // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

        dN -= N0;

        if ((LONG) dN < 0)
        {
            goto Next_Line;
        }

    // We now have a line running left-to-right, top-to-bottom from (M0, N0)
    // to (M0 + dM, N0 + dN):

        if (dN >= dM)
        {
            if (dN == dM)
            {
            // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
            // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        x = LFLOOR((LONG) M0);
        y = LFLOOR((LONG) N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

        llGamma = UInt32x32To64(dM, N0 + F/2) - UInt32x32To64(M0, dN);
        if (fl & FL_V_ROUND_DOWN)   // Adjust so y = 1/2 rounds down
        {
            llGamma--;
        }

        llGamma >>= FLOG2;
        llBeta = ~llGamma;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.                  *
\***********************************************************************/

    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'.
    //
    // For lines that go left-to-right, we have the following grid:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 xxxxxxxx?.......
    //   |   1 xxxxxxx.........
    //   |   2 xxxxxx..........
    //   |   3 xxxxx...........
    //   |   4 xxxx............
    //   |   5 xxx.............
    //   |   6 xx..............
    //   |   7 x...............
    //   |   8 x...............
    //   |   9 x.....**........
    //   |   a xx......****....
    //   |   b xxx.........****
    //   |   c xxxx............****
    //   |   d xxxxx...........    ****
    //   |   e xxxxxx..........        ****
    //   |   f xxxxxxx.........
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one must be handled similarly to the right-to-
    // left case.

        {

        // Calculate x0, x1

            ULONG N1 = FXFRAC(N0 + dN);
            ULONG M1 = FXFRAC(M0 + dM);

            x1 = LFLOOR(M0 + dM);

            if (fl & FL_LAST_PEL_INCLUSIVE)
            {
            // It sure is easy to compute the first pel when lines have only
            // integer coordinates and are last-pel inclusive:

                x0 = 0;
                y0 = 0;

            // Last-pel inclusive lines that are exactly one pixel long
            // have a 'delta-x' and 'delta-y' equal to zero.  The problem is
            // that our clip code assumes that 'delta-x' is always non-zero
            // (since it never happens with last-pel exclusive lines).  As
            // an inelegant solution, we simply modify 'delta-x' in this
            // case -- because the line is exactly one pixel long, changing
            // the slope will obviously have no effect on rasterization.

                if (x1 == 0)
                {
                    dM      = 1;
                    llGamma = 0;
                    llBeta  = ~llGamma;
                }
            }
            else
            {
                if (fl & FL_FLIP_H)
                {
                // ---------------------------------------------------------------
                // Line runs right-to-left:  <----

                // Compute x1:

                    if (N1 == 0)
                    {
                        if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                        {
                            x1++;
                        }
                    }
                    else if (abs((LONG) (N1 - F/2)) + M1 > F)
                    {
                        x1++;
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((N1 > 0) && (M1 == N1 + 8))
                            x1++;

                    // Don't you love special cases?  Is this a rhetorical question?

                        if ((N0 > 0) && (M0 == N0 + 8))
                        {
                            x0      = 2;
                            ulDelta = dN;
                            goto right_to_left_compute_y0;
                        }
                    }

                // Compute x0:

                    x0      = 1;
                    ulDelta = 0;
                    if (N0 == 0)
                    {
                        if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                        {
                            x0      = 2;
                            ulDelta = dN;
                        }
                    }
                    else if (abs((LONG) (N0 - F/2)) + M0 > F)
                    {
                        x0      = 2;
                        ulDelta = dN;
                    }


                // Compute y0:

                right_to_left_compute_y0:

                    y0 = 0;
                    ll = llGamma + (LONGLONG) ulDelta;

                    if (ll >= (LONGLONG) (2 * dM - dN))
                        y0 = 2;
                    else if (ll >= (LONGLONG) (dM - dN))
                        y0 = 1;
                }
                else
                {
                // ---------------------------------------------------------------
                // Line runs left-to-right:  ---->

                // Compute x1:

                    if (!(fl & FL_LAST_PEL_INCLUSIVE))
                        x1--;

                    if (M1 > 0)
                    {
                        if (N1 == 0)
                        {
                            if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                                x1++;
                        }
                        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
                        {
                            x1++;
                        }
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((M1 > 0) && (N1 == M1 + 8))
                            x1--;

                        if ((M0 > 0) && (N0 == M0 + 8))
                        {
                            x0 = 0;
                            goto left_to_right_compute_y0;
                        }
                    }

                // Compute x0:

                    x0 = 0;
                    if (M0 > 0)
                    {
                        if (N0 == 0)
                        {
                            if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                                x0 = 1;
                        }
                        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
                        {
                            x0 = 1;
                        }
                    }

                // Compute y0:

                left_to_right_compute_y0:

                    y0 = 0;
                    if (llGamma >= (LONGLONG) (dM - (dN & (-(LONG) x0))))
                    {
                        y0 = 1;
                    }
                }
            }
        }

        cStylePels = x1 - x0 + 1;
        if ((LONG) cStylePels <= 0)
            goto Next_Line;

        xStart = x0;

/***********************************************************************\
* Complex clipping.                                                     *
\***********************************************************************/

        if (fl & FL_COMPLEX_CLIP)
        {
            dN_Original = dN;

        Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
            // Line runs right-to-left <-----

                x0 = xStart + cStylePels - prun->iStop - 1;
                x1 = xStart + cStylePels - prun->iStart - 1;
            }
            else
            {
            // Line runs left-to-right ----->

                x0 = xStart + prun->iStart;
                x1 = xStart + prun->iStop;
            }

            prun++;

        // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

        // No overflow since large integer math is used.  Both values
        // will be positive:

            dl = UInt32x32To64(x0, dN) + llGamma;

        // y0 = dl / dM:

            y0 = UInt64Div32To32(dl, dM);

            ASSERTDD((LONG) y0 >= 0, "y0 weird: Goofed up end pel calc?");
        }

/***********************************************************************\
* Simple rectangular clipping.                                          *
\***********************************************************************/

        if (fl & FL_SIMPLE_CLIP)
        {
            ULONG y1;
            LONG  xRight;
            LONG  xLeft;
            LONG  yBottom;
            LONG  yTop;

        // Note that y0 and y1 are actually the lower and upper bounds,
        // respectively, of the y coordinates of the line (the line may
        // have actually shrunk due to first/last pel clipping).
        //
        // Also note that x0, y0 are not necessarily zero.

            RECTL* prcl = &prclClip[(fl & FL_RECTLCLIP_MASK) >>
                                    FL_RECTLCLIP_SHIFT];

        // Normalize to the same point we've normalized for the DDA
        // calculations:

            xRight  = prcl->right  - x;
            xLeft   = prcl->left   - x;
            yBottom = prcl->bottom - y;
            yTop    = prcl->top    - y;

            if (yBottom <= (LONG) y0 ||
                xRight  <= (LONG) x0 ||
                xLeft   >  (LONG) x1)
            {
            Totally_Clipped:

                if (fl & FL_STYLED)
                {
                    pls->spNext += cStylePels;
                    if (pls->spNext >= pls->spTotal2)
                        pls->spNext %= pls->spTotal2;
                }

                goto Next_Line;
            }

            if ((LONG) x1 >= xRight)
                x1 = xRight - 1;

        // We have to know the correct y1, which we haven't bothered to
        // calculate up until now.  This multiply and divide is quite
        // expensive; we could replace it with code similar to that which
        // we used for computing y0.
        //
        // The reason why we need the actual value, and not an upper
        // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
        // careful when calculating x(y) that y0 <= y <= y1, otherwise
        // we can overflow on the divide (which, needless to say, is very
        // bad).

            dl = UInt32x32To64(x1, dN) + llGamma;

        // y1 = dl / dM:

            y1 = UInt64Div32To32(dl, dM);

            if (yTop > (LONG) y1)
                goto Totally_Clipped;

            if (yBottom <= (LONG) y1)
            {
                y1 = yBottom;
                dl = UInt32x32To64(y1, dM) + llBeta;

            // x1 = dl / dN:

                x1 = UInt64Div32To32(dl, dN);
            }

        // At this point, we've taken care of calculating the intercepts
        // with the right and bottom edges.  Now we work on the left and
        // top edges:

            if (xLeft > (LONG) x0)
            {
                x0 = xLeft;
                dl = UInt32x32To64(x0, dN) + llGamma;

            // y0 = dl / dM;

                y0 = UInt64Div32To32(dl, dM);

                if (yBottom <= (LONG) y0)
                    goto Totally_Clipped;
            }

            if (yTop > (LONG) y0)
            {
                y0 = yTop;
                dl = UInt32x32To64(y0, dM) + llBeta;

            // x0 = dl / dN + 1;

                x0 = UInt64Div32To32(dl, dN) + 1;

                if (xRight <= (LONG) x0)
                    goto Totally_Clipped;
            }

            ASSERTDD(x0 <= x1, "Improper rectangle clip");
        }

/***********************************************************************\
* Done clipping.  Unflip if necessary.                                 *
\***********************************************************************/

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }


        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        cPels = x1 - x0 + 1;

/***********************************************************************\
* Style calculations.                                                   *
\***********************************************************************/

        if (fl & FL_STYLED)
        {
            STYLEPOS sp;

            spThis       = pls->spNext;
            pls->spNext += cStylePels;

            {
                if (pls->spNext >= pls->spTotal2)
                    pls->spNext %= pls->spTotal2;

                if (fl & FL_FLIP_H)
                    sp = pls->spNext - x0 + xStart;
                else
                    sp = spThis + x0 - xStart;

                ASSERTDD(fl & FL_STYLED, "Oops");

            // Normalize our target style position:

                if ((sp < 0) || (sp >= pls->spTotal2))
                {
                    sp %= pls->spTotal2;

                // The modulus of a negative number is not well-defined
                // in C -- if it's negative we'll adjust it so that it's
                // back in the range [0, spTotal2):

                    if (sp < 0)
                        sp += pls->spTotal2;
                }

            // Since we always draw the line left-to-right, but styling is
            // always done in the direction of the original line, we have
            // to figure out where we are in the style array for the left
            // edge of this line.

                if (fl & FL_FLIP_H)
                {
                // Line originally ran right-to-left:

                    sp = -sp;
                    if (sp < 0)
                        sp += pls->spTotal2;

                    pls->ulStyleMask = ~pls->ulStartMask;
                    pls->pspStart    = &pls->aspRtoL[0];
                    pls->pspEnd      = &pls->aspRtoL[pls->cStyle - 1];
                }
                else
                {
                // Line originally ran left-to-right:

                    pls->ulStyleMask = pls->ulStartMask;
                    pls->pspStart    = &pls->aspLtoR[0];
                    pls->pspEnd      = &pls->aspLtoR[pls->cStyle - 1];
                }

                if (sp >= pls->spTotal)
                {
                    sp -= pls->spTotal;
                    if (pls->cStyle & 1)
                        pls->ulStyleMask = ~pls->ulStyleMask;
                }

                pls->psp = pls->pspStart;
                while (sp >= *pls->psp)
                    sp -= *pls->psp++;

                ASSERTDD(pls->psp <= pls->pspEnd,
                        "Flew off into NeverNeverLand");

                pls->spRemaining = *pls->psp - sp;
                if ((pls->psp - pls->pspStart) & 1)
                    pls->ulStyleMask = ~pls->ulStyleMask;
            }
        }

        plStrip    = &strip.alStrips[0];
        plStripEnd = &strip.alStrips[STRIP_MAX];    // Is exclusive
        cStripsInNextRun   = 0x7fffffff;

        strip.ptlStart = ptlStart;

        if (2 * dN > dM &&
            !(fl & FL_STYLED))
        {
        // Do a half flip!  Remember that we may doing this on the
        // same line multiple times for complex clipping (meaning the
        // affected variables should be reset for every clip run):

            fl |= FL_FLIP_HALF;

            llBeta  = llGamma - (LONGLONG) ((LONG) dM);
            dN = dM - dN;
            y0 = x0 - y0;       // Note this may overflow, but that's okay
        }

    // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips = fl;
        pfn           = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

    // Now calculate the DDA variables needed to figure out how many pixels
    // go in the very first strip:

        {
            register LONG  i;
            register ULONG dI;
            register ULONG dR;
                     ULONG r;

            if (dN == 0)
                i = 0x7fffffff;
            else
            {
                dl = UInt32x32To64(y0 + 1, dM) + llBeta;

                ASSERTDD(dl >= 0, "Oops!");

            // i = (dl / dN) - x0 + 1;
            // r = (dl % dN);

                i = UInt64Div32To32(dl, dN);
                r = UInt64Mod32To32(dl, dN);
                i = i - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN

                ASSERTDD(dI > 0, "Weird dI");
            }

            ASSERTDD(i > 0 && i <= 0x7fffffff, "Weird initial strip length");
            ASSERTDD(cPels > 0, "Zero pel line");

/***********************************************************************\
* Run the DDA!                                                          *
\***********************************************************************/

            while(TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
                    (*pfn)(ppdev, &strip, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            strip.cStrips = (ULONG)(plStrip - &strip.alStrips[0]);
            (*pfn)(ppdev, &strip, pls);


        }

    Next_Line:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }

    } while (pptfxBuf < pptfxBufEnd);

    return(TRUE);

}

/******************************Public*Routine******************************\
* BOOL bIntegerUnclippedLines
*
* Draws lines using the Weitek's point-to-point capabilities.
* Unfortunately, the Weitek has exactly the wrong rounding convention
* for tie-breakers, and GDI is very picky about this.
*
* Consequently, we can only use the line hardware when we know there
* will be no tie-breakers.  Fortunately, this is pretty easy to detect,
* and the odds are that 3 out of 4 lines will not have tie breakers.  For
* those cases where there are tie-breakers, we can still usually draw the
* lines using the hardware, this time by doing a one-wide trapezoid.
* Unfortunately, this works for only 6 of the 8 octants, so for the final
* case we punt to our strips routine.
*
* Additional complications include the fact that lines have to be last-pel
* exclusive, and that we try to optimize horizontal and vertical lines.
*
\**************************************************************************/

BOOL bIntegerUnclippedLines(
PDEV*      ppdev,
POINTFIX*  pptfxFirst,
POINTFIX*  pptfxBuf,
RUN*       prun,
ULONG      cptfx,
LINESTATE* pls,
RECTL*     prclClip,
PFNSTRIP*  apfn,
FLONG      flStart,
ULONG      ulHwMix)
{
    BYTE*   pjBase;
    BOOL    bClippingSet;
    ULONG   ulLineMix;
    ULONG   ulTrapezoidMix;
    LONG    x0;
    LONG    y0;
    LONG    x1;
    LONG    y1;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    yBottom;
    LONG    dx;
    LONG    dy;
    LONG    lOr;
    LONG    lBit;
    LONG    iShift;
    LONG    xDir;
    LONG    yDir;

    pjBase       = ppdev->pjBase;
    bClippingSet = FALSE;

    if (P9000(ppdev))
    {
        ulTrapezoidMix = ulHwMix;
        ulLineMix      = ulTrapezoidMix | P9000_OVERSIZED;
    }
    else
    {
        ulTrapezoidMix = ulHwMix & 0xff;
        ulLineMix      = ulTrapezoidMix | P9100_OVERSIZED;
    }

    while (TRUE)
    {
        x0 = pptfxFirst->x;
        y0 = pptfxFirst->y;
        x1 = pptfxBuf->x;
        y1 = pptfxBuf->y;

        // First, check to see if the line is has all-integer coordinates:

        if (((x0 | y0 | x1 | y1) & 0xf) != 0)
        {
            // Ack, this line has non-integer coordinates.  The rest of the
            // lines in this batch likely have non-integer coordinates
            // as well, so punt the entire batch to our strips routine:

            if (bClippingSet)
            {
                CP_WAIT(ppdev, pjBase);
                CP_RASTER(ppdev, pjBase, ulLineMix);
                CP_ABS_WMIN(ppdev, pjBase, 0, 0);
                CP_ABS_WMAX(ppdev, pjBase, MAX_COORD, MAX_COORD);
            }

            return(bLines(ppdev, pptfxFirst, pptfxBuf, prun, cptfx, pls,
                          prclClip, apfn, flStart, ulHwMix));
        }
        else
        {
            x0 >>= 4;
            x1 >>= 4;
            y0 >>= 4;
            y1 >>= 4;

            if ((y0 == y1) && (!bClippingSet))
            {
                // We special case horizontal lines:

                if (x0 < x1)
                    x1--;
                else if (x0 > x1)
                    x1++;
                else
                    goto Next_Line;     // Zero-length line

                CP_METALINE(ppdev, pjBase, x0, y0);
                CP_METALINE(ppdev, pjBase, x1, y0);
                CP_START_QUAD_WAIT(ppdev, pjBase);
                goto Next_Line;
            }
            else if (y0 < y1)
            {
                yTop    = y0;
                yBottom = y1;
            }
            else
            {
                yBottom = y0;
                yTop    = y1;
            }

            if ((x0 == x1) && (!bClippingSet))
            {
                // We special case vertical lines:

                if (y0 < y1)
                    y1--;
                else
                    y1++;

                CP_METALINE(ppdev, pjBase, x0, y0);
                CP_METALINE(ppdev, pjBase, x0, y1);
                CP_START_QUAD_WAIT(ppdev, pjBase);
                goto Next_Line;
            }
            else if (x0 < x1)
            {
                xLeft   = x0;
                xRight  = x1;
            }
            else
            {
                xRight  = x0;
                xLeft   = x1;
            }

            dx = xRight - xLeft;
            dy = yBottom - yTop;

            if (dx >= dy)
            {
                if (dx == 0)
                    goto Next_Line;     // Get rid of zero-length line case

                // We have an x-major line.  Adjust the clip box to
                // account for last-pel exclusion:

                if (x0 < x1)
                    xRight--;
                else
                    xLeft++;

                lOr    = (dx | dy);
                lBit   = 1;
                iShift = 1;
                while (!(lOr & lBit))
                {
                    lBit <<= 1;
                    iShift++;
                }

                if (dx & lBit)
                {

                Output_Simple_Line:

                    CP_METALINE(ppdev, pjBase, x0, y0);
                    CP_METALINE(ppdev, pjBase, x1, y1);

                    CP_WAIT(ppdev, pjBase);
                    CP_RASTER(ppdev, pjBase, ulLineMix);
                    CP_WMIN(ppdev, pjBase, xLeft, yTop);
                    CP_WMAX(ppdev, pjBase, xRight, yBottom);
                    CP_START_QUAD_WAIT(ppdev, pjBase);
                    bClippingSet = TRUE;
                    goto Next_Line;
                }
                else
                {
                    if ((dx ^ dy) > 0)
                        goto Punt_Line;

                    // Ick, this x-major line has tie-breaker cases.

                    xDir = 0;
                    yDir = 1;
                    dy >>= iShift;
                    if (y0 > y1)
                    {
                        dy = -dy;
                        yDir = -1;
                    }

                    y0 -= dy;
                    y1 += dy;

                    dx >>= iShift;
                    if (x0 > x1)
                        dx = -dx;

                    x0 -= dx;
                    x1 += dx;

                Output_Trapezoid_Line:

                    CP_METAQUAD(ppdev, pjBase, x0, y0);
                    CP_METAQUAD(ppdev, pjBase, x1 + xDir, y1 - yDir);
                    CP_METAQUAD(ppdev, pjBase, x1, y1);
                    CP_METAQUAD(ppdev, pjBase, x0 - xDir, y0 + yDir);

                    CP_WAIT(ppdev, pjBase);
                    CP_RASTER(ppdev, pjBase, ulTrapezoidMix);
                    CP_WMIN(ppdev, pjBase, xLeft, yTop);
                    CP_WMAX(ppdev, pjBase, xRight, yBottom);
                    CP_START_QUAD_WAIT(ppdev, pjBase);
                    bClippingSet = TRUE;
                    goto Next_Line;
                }
            }
            else
            {
                // We have a y-major line.  Adjust the clip box to
                // account for last-pel exclusion:

                if (y0 < y1)
                    yBottom--;
                else
                    yTop++;

                lOr    = (dx | dy);
                lBit   = 1;
                iShift = 1;
                while (!(lOr & lBit))
                {
                    lBit <<= 1;
                    iShift++;
                }

                if (dy & lBit)
                {
                    goto Output_Simple_Line;
                }
                else
                {
                    // Ick, this y-major line has tie-breaker cases.

                    yDir = 0;
                    xDir = 1;
                    dx >>= iShift;
                    if (x0 > x1)
                    {
                        dx = -dx;
                        xDir = -1;
                    }

                    x0 -= dx;
                    x1 += dx;

                    dy >>= iShift;
                    if (y0 > y1)
                        dy = -dy;

                    y0 -= dy;
                    y1 += dy;

                    goto Output_Trapezoid_Line;
                }
            }
        }

    Punt_Line:

        if (bClippingSet)
        {
            CP_WAIT(ppdev, pjBase);
            CP_RASTER(ppdev, pjBase, ulLineMix);
            CP_ABS_WMIN(ppdev, pjBase, 0, 0);
            CP_ABS_WMAX(ppdev, pjBase, MAX_COORD, MAX_COORD);
            bClippingSet = FALSE;
        }

        bLines(ppdev, pptfxFirst, pptfxBuf, NULL, 1, pls,
               prclClip, apfn, flStart, ulHwMix);

    Next_Line:

        --cptfx;
        if (cptfx == 0)
            break;

        pptfxFirst = pptfxBuf;
        pptfxBuf++;
    }

    if (bClippingSet)
    {
        CP_WAIT(ppdev, pjBase);
        CP_RASTER(ppdev, pjBase, ulLineMix);    // Might need for next batch
        CP_ABS_WMIN(ppdev, pjBase, 0, 0);
        CP_ABS_WMAX(ppdev, pjBase, MAX_COORD, MAX_COORD);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bIntegerClippedLines
*
* Draws lines using the hardware when there is a single clipping rectangle.
* See 'bIntegerUnclippedLines' above for more details.
*
\**************************************************************************/

BOOL bIntegerClippedLines(
PDEV*      ppdev,
POINTFIX*  pptfxFirst,
POINTFIX*  pptfxBuf,
RUN*       prun,
ULONG      cptfx,
LINESTATE* pls,
RECTL*     prclClip,
PFNSTRIP*  apfn,
FLONG      flStart,
ULONG      ulHwMix)
{
    BYTE*   pjBase;
    BOOL    bClippingSet;
    ULONG   ulLineMix;
    ULONG   ulTrapezoidMix;
    LONG    x0;
    LONG    y0;
    LONG    x1;
    LONG    y1;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    yBottom;
    LONG    dx;
    LONG    dy;
    LONG    lOr;
    LONG    lBit;
    LONG    iShift;
    LONG    xDir;
    LONG    yDir;

    ASSERTDD(flStart & FL_SIMPLE_CLIP, "Expected only simple clipping");

    pjBase       = ppdev->pjBase;
    bClippingSet = FALSE;

    if (P9000(ppdev))
    {
        ulTrapezoidMix = ulHwMix;
        ulLineMix      = ulTrapezoidMix | P9000_OVERSIZED;
    }
    else
    {
        ulTrapezoidMix = ulHwMix & 0xff;
        ulLineMix      = ulTrapezoidMix | P9100_OVERSIZED;
    }

    while (TRUE)
    {
        x0 = pptfxFirst->x;
        y0 = pptfxFirst->y;
        x1 = pptfxBuf->x;
        y1 = pptfxBuf->y;

        // First, check to see if the line is has all-integer coordinates:

        if (((x0 | y0 | x1 | y1) & 0xf) != 0)
        {
            // Ack, this line has non-integer coordinates.  The rest of the
            // lines in this batch likely have non-integer coordinates
            // as well, so punt the entire batch to our strips routine:

            if (bClippingSet)
            {
                CP_WAIT(ppdev, pjBase);
                CP_RASTER(ppdev, pjBase, ulLineMix);
                CP_ABS_WMIN(ppdev, pjBase, 0, 0);
                CP_ABS_WMAX(ppdev, pjBase, MAX_COORD, MAX_COORD);
            }

            return(bLines(ppdev, pptfxFirst, pptfxBuf, prun, cptfx, pls,
                          prclClip, apfn, flStart, ulHwMix));
        }
        else
        {
            x0 >>= 4;
            x1 >>= 4;
            y0 >>= 4;
            y1 >>= 4;

            if (y0 < y1)
            {
                yTop    = y0;
                yBottom = y1;
            }
            else
            {
                yBottom = y0;
                yTop    = y1;
            }

            if (x0 < x1)
            {
                xLeft   = x0;
                xRight  = x1;
            }
            else
            {
                xRight  = x0;
                xLeft   = x1;
            }

            // Do a trivial rejection test, remembering that the bound box
            // we just computed is lower-right inclusive:

            if ((xLeft   >= prclClip->right) ||
                (yTop    >= prclClip->bottom) ||
                (xRight  <  prclClip->left) ||
                (yBottom <  prclClip->top))
            {
                goto Next_Line;
            }
            else
            {
                dx = xRight - xLeft;
                dy = yBottom - yTop;

                if (dx >= dy)
                {
                    if (dx == 0)
                        goto Next_Line;     // Get rid of zero-length line case

                    // We have an x-major line.  Adjust the clip box to
                    // account for last-pel exclusion:

                    if (x0 < x1)
                        xRight--;
                    else
                        xLeft++;

                    lOr    = (dx | dy);
                    lBit   = 1;
                    iShift = 1;
                    while (!(lOr & lBit))
                    {
                        lBit <<= 1;
                        iShift++;
                    }

                    // The Weitek's clip registers are inclusive, and
                    // are expected to be well-ordered:

                    xLeft   = max(xLeft,   prclClip->left);
                    yTop    = max(yTop,    prclClip->top);
                    xRight  = min(xRight,  prclClip->right - 1);
                    yBottom = min(yBottom, prclClip->bottom - 1);

                    if ((xLeft <= xRight) && (yTop <= yBottom))
                    {
                        if (dx & lBit)
                        {

                        Output_Simple_Line:

                            CP_METALINE(ppdev, pjBase, x0, y0);
                            CP_METALINE(ppdev, pjBase, x1, y1);

                            CP_WAIT(ppdev, pjBase);
                            CP_RASTER(ppdev, pjBase, ulLineMix);
                            CP_WMIN(ppdev, pjBase, xLeft, yTop);
                            CP_WMAX(ppdev, pjBase, xRight, yBottom);
                            CP_START_QUAD_WAIT(ppdev, pjBase);
                            bClippingSet = TRUE;
                            goto Next_Line;
                        }
                        else
                        {
                            if ((dx ^ dy) > 0)
                                goto Punt_Line;

                            // Ick, this x-major line has tie-breaker cases.

                            xDir = 0;
                            yDir = 1;
                            dy >>= iShift;
                            if (y0 > y1)
                            {
                                dy = -dy;
                                yDir = -1;
                            }

                            y0 -= dy;
                            y1 += dy;

                            dx >>= iShift;
                            if (x0 > x1)
                                dx = -dx;

                            x0 -= dx;
                            x1 += dx;

                        Output_Trapezoid_Line:

                            CP_METAQUAD(ppdev, pjBase, x0, y0);
                            CP_METAQUAD(ppdev, pjBase, x1 + xDir, y1 - yDir);
                            CP_METAQUAD(ppdev, pjBase, x1, y1);
                            CP_METAQUAD(ppdev, pjBase, x0 - xDir, y0 + yDir);

                            CP_WAIT(ppdev, pjBase);
                            CP_RASTER(ppdev, pjBase, ulTrapezoidMix);
                            CP_WMIN(ppdev, pjBase, xLeft, yTop);
                            CP_WMAX(ppdev, pjBase, xRight, yBottom);
                            CP_START_QUAD_WAIT(ppdev, pjBase);
                            bClippingSet = TRUE;
                            goto Next_Line;
                        }
                    }
                }
                else
                {
                    // We have a y-major line.  Adjust the clip box to
                    // account for last-pel exclusion:

                    if (y0 < y1)
                        yBottom--;
                    else
                        yTop++;

                    lOr    = (dx | dy);
                    lBit   = 1;
                    iShift = 1;
                    while (!(lOr & lBit))
                    {
                        lBit <<= 1;
                        iShift++;
                    }

                    // The Weitek's clip registers are inclusive, and
                    // are expected to be well-ordered:

                    xLeft   = max(xLeft,   prclClip->left);
                    yTop    = max(yTop,    prclClip->top);
                    xRight  = min(xRight,  prclClip->right - 1);
                    yBottom = min(yBottom, prclClip->bottom - 1);

                    if ((xLeft <= xRight) && (yTop <= yBottom))
                    {
                        if (dy & lBit)
                        {
                            goto Output_Simple_Line;
                        }
                        else
                        {
                            // Ick, this y-major line has tie-breaker cases.

                            yDir = 0;
                            xDir = 1;
                            dx >>= iShift;
                            if (x0 > x1)
                            {
                                dx = -dx;
                                xDir = -1;
                            }

                            x0 -= dx;
                            x1 += dx;

                            dy >>= iShift;
                            if (y0 > y1)
                                dy = -dy;

                            y0 -= dy;
                            y1 += dy;

                            goto Output_Trapezoid_Line;
                        }
                    }
                }
            }
        }

    Punt_Line:

        if (bClippingSet)
        {
            CP_WAIT(ppdev, pjBase);
            CP_RASTER(ppdev, pjBase, ulLineMix);
            CP_ABS_WMIN(ppdev, pjBase, 0, 0);
            CP_ABS_WMAX(ppdev, pjBase, MAX_COORD, MAX_COORD);
            bClippingSet = FALSE;
        }

        bLines(ppdev, pptfxFirst, pptfxBuf, NULL, 1, pls,
               prclClip, apfn, flStart, ulHwMix);

    Next_Line:

        --cptfx;
        if (cptfx == 0)
            break;

        pptfxFirst = pptfxBuf;
        pptfxBuf++;
    }

    if (bClippingSet)
    {
        CP_WAIT(ppdev, pjBase);
        CP_RASTER(ppdev, pjBase, ulLineMix);    // Might need for next batch
        CP_ABS_WMIN(ppdev, pjBase, 0, 0);
        CP_ABS_WMAX(ppdev, pjBase, MAX_COORD, MAX_COORD);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bCacheCircle(ppdev, ppo, pco, pbo, bStroke, pla)
*
\**************************************************************************/

BOOL bCacheCircle(
PDEV*       ppdev,
PATHOBJ*    ppo,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
BOOL        bStroke,        // TRUE if stroke, FALSE if fill
LINEATTRS*  pla)            // Used for strokes only
{
    RECTFX          rcfx;
    LONG            xCircle;
    LONG            yCircle;
    LONG            xCached;
    LONG            yCached;
    LONG            cx;
    LONG            cy;
    CIRCLEENTRY*    pce;
    LONG            i;
    BYTE*           pjBase;
    RECTL           rclDst;
    POINTL          ptlSrc;
    ULONG           ulHwMix;
    RECTL           rclTmp;
    CLIPENUM        ce;
    LONG            c;
    LONG            bMore;
    LONG            iCircleCache;
    SURFOBJ*        pso;
    CLIPOBJ         co;
    BRUSHOBJ        bo;

    if (!(ppdev->flStat & STAT_CIRCLE_CACHE))
        return(FALSE);

    PATHOBJ_vGetBounds(ppo, &rcfx);

    // Normalize bounds to upper-left corner:

    xCircle = rcfx.xLeft & ~0xfL;
    yCircle = rcfx.yTop  & ~0xfL;

    rcfx.xLeft   -= xCircle;
    rcfx.xRight  -= xCircle;
    rcfx.yTop    -= yCircle;
    rcfx.yBottom -= yCircle;

    // Convert to pixel units:

    xCircle >>= 4;
    yCircle >>= 4;

    cx = (rcfx.xRight >> 4) + 2;
    cy = (rcfx.yBottom >> 4) + 2;

    if ((cx > CIRCLE_DIMENSION) || (cy > CIRCLE_DIMENSION))
    {
        // This circle is too big to cache, so decline it:

        return(FALSE);
    }

    pjBase = ppdev->pjBase;

    pce = &ppdev->ace[0];
    for (i = TOTAL_CIRCLE_COUNT; i != 0; i--)
    {
        if ((pce->bStroke == bStroke)                &&
            (pce->rcfxCircle.xLeft   == rcfx.xLeft)  &&
            (pce->rcfxCircle.yTop    == rcfx.yTop)   &&
            (pce->rcfxCircle.xRight  == rcfx.xRight) &&
            (pce->rcfxCircle.yBottom == rcfx.yBottom))
        {
Draw_It:
            // We got a hit!  Colour-expand from our off-screen
            // cache to the screen:

            rclDst.left   = xCircle;
            rclDst.right  = xCircle + cx;
            rclDst.top    = yCircle;
            rclDst.bottom = yCircle + cy;

            // 'ptlSrc' has to be in relative coordinates:

            ptlSrc.x = pce->xCached - ppdev->xOffset;
            ptlSrc.y = pce->yCached - ppdev->yOffset;

            CP_WAIT(ppdev, pjBase);
            if (P9000(ppdev))
            {
                CP_FOREGROUND(ppdev, pjBase, pbo->iSolidColor);
                ulHwMix = 0xee22;
            }
            else
            {
                CP_COLOR0(ppdev, pjBase, pbo->iSolidColor);
                ulHwMix = 0xe2e2;
            }

            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                ppdev->pfnCopyBlt(ppdev, 1, &rclDst, ulHwMix, &ptlSrc, &rclDst);
            }
            else if (pco->iDComplexity == DC_RECT)
            {
                if (bIntersect(&rclDst, &pco->rclBounds, &rclTmp))
                    ppdev->pfnCopyBlt(ppdev, 1, &rclTmp, ulHwMix, &ptlSrc, &rclDst);
            }
            else
            {
                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                do {
                    bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                    c = cIntersect(&rclDst, ce.arcl, ce.c);

                    if (c != 0)
                        ppdev->pfnCopyBlt(ppdev, c, ce.arcl, ulHwMix, &ptlSrc, &rclDst);

                } while (bMore);
            }

            return(TRUE);
        }
    }

    // Make an entry in our cache:

    iCircleCache = ppdev->iCircleCache;
    if (++iCircleCache >= TOTAL_CIRCLE_COUNT)
        iCircleCache = 0;
    ppdev->iCircleCache = iCircleCache;

    pce = &ppdev->ace[iCircleCache];

    // We must place the circle in off-screen memory with the same dword
    // alignment as the one we've been asked to draw, because we're
    // going to have GDI draw there instead:

    xCached = pce->x + (xCircle & 3);
    yCached = pce->y;

    // Store all the relevant information about the circle:

    pce->xCached = xCached;
    pce->yCached = yCached;
    pce->bStroke = bStroke;

    pce->rcfxCircle.xLeft   = rcfx.xLeft;
    pce->rcfxCircle.yTop    = rcfx.yTop;
    pce->rcfxCircle.xRight  = rcfx.xRight;
    pce->rcfxCircle.yBottom = rcfx.yBottom;

    // Fudge up some parameters for the GDI call:

    pso = ppdev->psoPunt;
    pso->pvScan0 = ppdev->pjScreen
                 + ((yCached - yCircle) * ppdev->lDelta)
                 + ((xCached - xCircle) * ppdev->cjPel);

    ASSERTDD((((ULONG_PTR) pso->pvScan0) & 0x3) == 0,
             "Surface must have dword alignment");

    co.iDComplexity = DC_TRIVIAL;
    bo.iSolidColor  = ppdev->ulWhite;

    // Erase old thing:

    CP_ABS_METARECT(ppdev, pjBase, xCached, yCached);
    CP_ABS_METARECT(ppdev, pjBase, xCached + CIRCLE_DIMENSION,
                                   yCached + CIRCLE_DIMENSION);

    CP_WAIT(ppdev, pjBase);
    CP_RASTER(ppdev, pjBase, 0);    // Same on both P9000 and P9100
    CP_START_QUAD(ppdev, pjBase);

    // Get GDI to draw the circle in our off-screen cache:

    if (bStroke)
    {
        EngStrokePath(pso, ppo, &co, NULL, &bo, NULL, pla, 0x0d0d);
    }
    else
    {
        EngFillPath(pso, ppo, &co, &bo, NULL, 0x0d0d, FP_ALTERNATEMODE);
    }

    goto Draw_It;
}

VOID (*gapfnStrip[])(PDEV*, STRIP*, LINESTATE*) = {
    vStripSolidHorizontal,
    vStripSolidVertical,
    vStripSolidDiagonalHorizontal,
    vStripSolidDiagonalVertical,

    vStripStyledHorizontal,
    vStripStyledVertical,
    vStripStyledVertical,         // Diagonal goes here
    vStripStyledVertical,         // Diagonal goes here
};

// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

/******************************Public*Routine******************************\
* BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix)
*
* Strokes the path.
*
\**************************************************************************/

BOOL DrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE ls;
    PFNSTRIP* apfn;
    PFNLINES  pfnLines;
    FLONG     fl;
    PDEV*     ppdev;
    DSURF*    pdsurf;
    OH*       poh;
    RECTL     arclClip[4];                  // For rectangular clipping
    BYTE*     pjBase;
    RECTL*    prclClip;
    ULONG     ulHwMix;

    ASSERTDD(((mix >> 8) & 0xff) == (mix & 0xff),
             "GDI gave us an improper mix");

// Pass the surface off to GDI if it's a device bitmap that we've
// converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt == DT_DIB)
    {
        return(EngStrokePath(pdsurf->pso, ppo, pco, pxo, pbo, pptlBrush,
                             pla, mix));
    }

// We'll be drawing to the screen or an off-screen DFB; copy the surface's
// offset now so that we won't need to refer to the DSURF again:

    poh   = pdsurf->poh;
    ppdev = (PDEV*) pso->dhpdev;
    ppdev->xOffset = poh->x;
    ppdev->yOffset = poh->y;

    // Because we set GCAPS_BEZIERS, we have to watch out for Beziers:

    if (ppo->fl & PO_BEZIERS)
    {
        // We only try to cache solid-styled COPYPEN ellipses:

        if ((ppo->fl & PO_ELLIPSE)    &&
            (mix == 0x0d0d)           &&
            !(pla->fl & LA_ALTERNATE) &&
            (pla->pstyle == NULL))
        {
            if (bCacheCircle(ppdev, ppo, pco, pbo, TRUE, pla))
                return(TRUE);
        }

        // Get GDI to break the Beziers into lines before calling us
        // again:

        return(FALSE);
    }

    pfnLines = bLines;
    if ((pla->pstyle == NULL) && !(pla->fl & LA_ALTERNATE))
    {
    // We can accelerate solid lines:

        if (pco->iDComplexity == DC_TRIVIAL)
        {
            pfnLines = bIntegerUnclippedLines;
        }
        else if (pco->iDComplexity == DC_RECT)
        {
            RECTFX rcfxBounds;

        // We have to be sure that we don't overflow the hardware registers
        // for current position, line length, or DDA terms.  We check
        // here to make sure that the current position and line length
        // values won't overflow:

            PATHOBJ_vGetBounds(ppo, &rcfxBounds);

            if (rcfxBounds.xLeft   + (ppdev->xOffset * F)
                                                >= (MIN_INTEGER_BOUND * F) &&
                rcfxBounds.xRight  + (ppdev->xOffset * F)
                                                <= (MAX_INTEGER_BOUND * F) &&
                rcfxBounds.yTop    + (ppdev->yOffset * F)
                                                >= (MIN_INTEGER_BOUND * F) &&
                rcfxBounds.yBottom + (ppdev->yOffset * F)
                                                <= (MAX_INTEGER_BOUND * F))
            {
                pfnLines = bIntegerClippedLines;
            }
        }
    }

    pjBase   = ppdev->pjBase;
    prclClip = NULL;
    fl       = 0;

// Look after styling initialization:

    if (pla->fl & LA_ALTERNATE)
    {
        ls.cStyle      = 1;
        ls.spTotal     = 1;
        ls.spTotal2    = 2;
        ls.spRemaining = 1;
        ls.aspRtoL     = &gaspAlternateStyle[0];
        ls.aspLtoR     = &gaspAlternateStyle[0];
        ls.spNext      = HIWORD(pla->elStyleState.l);
        ls.xyDensity   = 1;
        fl            |= FL_STYLED;
        ls.ulStartMask = 0L;
    }
    else if (pla->pstyle != (FLOAT_LONG*) NULL)
    {
        PFLOAT_LONG pstyle;
        STYLEPOS*   pspDown;
        STYLEPOS*   pspUp;

        pstyle = &pla->pstyle[pla->cstyle];

        ls.xyDensity = STYLE_DENSITY;
        ls.spTotal   = 0;
        while (pstyle-- > pla->pstyle)
        {
            ls.spTotal += pstyle->l;
        }
        ls.spTotal *= STYLE_DENSITY;
        ls.spTotal2 = 2 * ls.spTotal;

    // Compute starting style position (this is guaranteed not to overflow):

        ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                    LOWORD(pla->elStyleState.l);

        fl        |= FL_STYLED;
        ls.cStyle  = pla->cstyle;
        ls.aspRtoL = aspRtoL;
        ls.aspLtoR = aspLtoR;

        if (pla->fl & LA_STARTGAP)
            ls.ulStartMask = 0xffffffffL;
        else
            ls.ulStartMask = 0L;

        pstyle  = pla->pstyle;
        pspDown = &ls.aspRtoL[ls.cStyle - 1];
        pspUp   = &ls.aspLtoR[0];

        while (pspDown >= &ls.aspRtoL[0])
        {
            *pspDown = pstyle->l * STYLE_DENSITY;
            *pspUp   = *pspDown;

            pspUp++;
            pspDown--;
            pstyle++;
        }
    }

    if (pco->iDComplexity == DC_RECT)
    {
        fl |= FL_SIMPLE_CLIP;

        arclClip[0]        =  pco->rclBounds;

    // FL_FLIP_D:

        arclClip[1].top    =  pco->rclBounds.left;
        arclClip[1].left   =  pco->rclBounds.top;
        arclClip[1].bottom =  pco->rclBounds.right;
        arclClip[1].right  =  pco->rclBounds.bottom;

    // FL_FLIP_V:

        arclClip[2].top    = -pco->rclBounds.bottom + 1;
        arclClip[2].left   =  pco->rclBounds.left;
        arclClip[2].bottom = -pco->rclBounds.top + 1;
        arclClip[2].right  =  pco->rclBounds.right;

    // FL_FLIP_V | FL_FLIP_D:

        arclClip[3].top    =  pco->rclBounds.left;
        arclClip[3].left   = -pco->rclBounds.bottom + 1;
        arclClip[3].bottom =  pco->rclBounds.right;
        arclClip[3].right  = -pco->rclBounds.top + 1;

        prclClip = arclClip;
    }

    apfn = &gapfnStrip[4 * ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];

// Get the device ready:

    ulHwMix = gaRop3FromMix[mix & 0xF];
    ulHwMix = (ulHwMix << 8) | (ulHwMix);

    CP_WAIT(ppdev, pjBase);
    if (P9000(ppdev))
    {
        CP_RASTER(ppdev, pjBase, P9000_OVERSIZED | ulHwMix);
        CP_BACKGROUND(ppdev, pjBase, pbo->iSolidColor);
    }
    else
    {
        CP_RASTER(ppdev, pjBase, P9100_OVERSIZED | (ulHwMix & 0xff));
        CP_COLOR0(ppdev, pjBase, pbo->iSolidColor);
    }

// Set up to enumerate the path:

    if (pco->iDComplexity != DC_COMPLEX)
    {
        PATHDATA  pd;
        BOOL      bMore;
        ULONG     cptfx;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;

        pd.flags = 0;

        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            cptfx = pd.count;
            if (cptfx == 0)
                break;

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if (pd.flags & PD_RESETSTYLE)
                ls.spNext = 0;

            if (cptfx > 0)
            {
                if (!pfnLines(ppdev,
                              pptfxFirst,
                              pptfxBuf,
                              (RUN*) NULL,
                              cptfx,
                              &ls,
                              prclClip,
                              apfn,
                              fl,
                              ulHwMix))
                {
                    return(FALSE);
                }
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (!pfnLines(ppdev,
                              &ptfxLast,
                              &ptfxStartFigure,
                              (RUN*) NULL,
                              1,
                              &ls,
                              prclClip,
                              apfn,
                              fl,
                              ulHwMix))
                {
                    return(FALSE);
                }
            }
        } while (bMore);

        if (fl & FL_STYLED)
        {
        // Save the style state:

            ULONG ulHigh;
            ULONG ulLow;

        // Masked styles don't normalize the style state.  It's a good
        // thing to do, so let's do it now:

            if ((ULONG) ls.spNext >= (ULONG) ls.spTotal2)
                ls.spNext = (ULONG) ls.spNext % (ULONG) ls.spTotal2;

            ulHigh = ls.spNext / ls.xyDensity;
            ulLow  = ls.spNext % ls.xyDensity;

            pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    }
    else
    {
    // Local state for path enumeration:

        BOOL bMore;
        union {
            BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

    // We use the clip object when non-simple clipping is involved:

        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        do {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if (cl.cl.c != 0)
            {
                if (fl & FL_STYLED)
                {
                    ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                 + LOWORD(cl.cl.lStyleState);
                }
                if (!pfnLines(ppdev,
                              &cl.cl.ptfxA,
                              &cl.cl.ptfxB,
                              &cl.cl.arun[0],
                              cl.cl.c,
                              &ls,
                              (RECTL*) NULL,
                              apfn,
                              fl,
                              ulHwMix))
                {
                    return(FALSE);
                }
            }
        } while (bMore);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\fillpath.c ===
/******************************Module*Header*******************************\
* Module Name: fillpath.c
*
* Contains the DrvFillPath routine.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

// LATER move pointed-to variables into automatics in search loops
// LATER handle complex clipping
// LATER coalesce rectangles

#include "precomp.h"

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// Int32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit LONGs to produce a 64-bit LONGLONG result.
//      I use it because it is much faster than 64x64 multiplies.

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define TAKING_ALLOC_STATS  0

#define NUM_BUFFER_POINTS   96      // Maximum number of points in a path
                                    //   for which we'll attempt to join
                                    //   all the path records so that the
                                    //   path may still be drawn by FastFill

#if TAKING_ALLOC_STATS
    ULONG BufferHitInFillpath = 0;
    ULONG BufferMissInFillpath = 0;
#endif

// Describe a single non-horizontal edge of a path to fill.
typedef struct _EDGE {
    PVOID pNext;
    INT iScansLeft;
    INT X;
    INT Y;
    INT iErrorTerm;
    INT iErrorAdjustUp;
    INT iErrorAdjustDown;
    INT iXWhole;
    INT iXDirection;
    INT iWindingDirection;
} EDGE, *PEDGE;

// Maximum number of rects we'll fill per call to
// the fill code
#define MAX_PATH_RECTS  50
#define RECT_BYTES      (MAX_PATH_RECTS * sizeof(RECTL))
#define EDGE_BYTES      (TMP_BUFFER_SIZE - RECT_BYTES)
#define MAX_EDGES       (EDGE_BYTES/sizeof(EDGE))

VOID AdvanceAETEdges(EDGE *pAETHead);
VOID XSortAETEdges(EDGE *pAETHead);
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY);
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge, POINTFIX *ppfxEdgeStart,
        POINTFIX *ppfxEdgeEnd, RECTL *pClipRect);
BOOL ConstructGET(EDGE *pGETHead, EDGE *pFreeEdges, PATHOBJ *ppo,
        PATHDATA *pd, BOOL bMore, RECTL *pClipRect);
void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection);

/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.  This routine
* detects single convex polygons, and will call to separate faster convex
* polygon code for those cases.  This routine also detects polygons that
* are really rectangles, and handles those separately as well.
*
* Note: Multiple polygons in a path cannot be treated as being disjoint;
*       the fill must consider all the points in the path.  That is, if the
*       path contains multiple polygons, you cannot simply draw one polygon
*       after the other (unless they don't overlap).
*
* Note: This function is optional, but is recommended for good performance.
*       To get GDI to call this function, not only do you have to
*       HOOK_FILLPATH, you have to set GCAPS_ALTERNATEFILL and/or
*       GCAPS_WINDINGFILL.
*
\**************************************************************************/

BOOL DrvFillPath(
SURFOBJ*    pso,
PATHOBJ*    ppo,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
MIX         mix,
FLONG       flOptions)
{
    ULONG rop4;
    BYTE jClipping;     // clipping type
    EDGE *pCurrentEdge;
    EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;     // pointer to AETHead
    EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;     // pointer to GETHead
    EDGE *pFreeEdges;   // pointer to memory free for use to store edges
    ULONG ulNumRects;   // # of rectangles to draw currently in rectangle list
    RECTL *prclRects;   // pointer to start of rectangle draw list
    INT iCurrentY;      // scan line for which we're currently scanning out the
                        //  fill

    ULONG        ulHwMix;           // Hardware mix value
    RBRUSH_COLOR rbc;               // Realized brush or solid color
    ULONG        iSolidColor;       // Copy of pbo->iSolidColor
    FNFILL      *pfnFill;           // Points to appropriate fill routine

    BOOL         bMore;
    PATHDATA     pd;
    RECTL        ClipRect;
    PDEV        *ppdev;
    DSURF       *pdsurf;

    BOOL         bRetVal=FALSE;     // FALSE until proven TRUE
    BOOL         bMemAlloced=FALSE; // FALSE until proven TRUE

    FLONG        flFirstRecord;
    POINTFIX*    pptfxTmp;
    ULONG        cptfxTmp;
    POINTFIX     aptfxBuf[NUM_BUFFER_POINTS];

    if (ppo->fl & PO_BEZIERS)
        return(FALSE);

    // Set up the clipping
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    if (jClipping != DC_TRIVIAL) {
        if (jClipping != DC_RECT) {
            goto ReturnFalse;  // there is complex clipping; let GDI fill the path
        }
        // Clip to the clip rectangle
        ClipRect = pco->rclBounds;
    } else {
        // So the y-clipping code doesn't do any clipping
        // /16 so we don't blow the values out when we scale up to GIQ
        ClipRect.top = (LONG_MIN + 1) / 16; // +1 to avoid compiler problem
        ClipRect.bottom = LONG_MAX / 16;
    }

    // There's nothing to do if there are only one or two points
    if (ppo->cCurves <= 2) {
        goto ReturnTrue;
    }

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt == DT_DIB)
    {
        return(EngFillPath(pdsurf->pso, ppo, pco, pbo, pptlBrush, mix,
                           flOptions));
    }

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:

    ppdev = (PDEV*) pso->dhpdev;
    ppdev->xOffset = pdsurf->poh->x;
    ppdev->yOffset = pdsurf->poh->y;

    pfnFill = ppdev->pfnFillSolid;
    ulHwMix = (gaRop3FromMix[mix >> 8] << 8) | gaRop3FromMix[mix & 0xF];
    iSolidColor = 0;                    // Assume we won't need a pattern

    rop4 = (gaRop3FromMix[mix >> 8] << 8) | gaRop3FromMix[mix & 0xff];

    if ((((rop4 & 0xff00) >> 8) != (rop4 & 0x00ff)) ||
        ((((rop4 >> 4) ^ (rop4)) & 0xf0f) != 0))  // Only do if we need a pattern
    {
        iSolidColor     = pbo->iSolidColor;
        rbc.iSolidColor = iSolidColor;
        if (rbc.iSolidColor == -1)
        {
            rbc.prb = pbo->pvRbrush;
            if (rbc.prb == NULL)
            {
                rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                if (rbc.prb == NULL)
                    return(FALSE);
            }
            pfnFill = ppdev->pfnFillPat;
        }
    }

    // Enumerate path here first time to check for special
    // cases (rectangles and monotone polygons)

    // It is too difficult to determine interaction between
    // multiple paths, if there is more than one, skip this

    bMore = PATHOBJ_bEnum(ppo, &pd);

    if (jClipping == DC_TRIVIAL)
    {
        // Try going through the fast non-complex fill code.  We'll have
        // to realize the brush first if we're going to handle a pattern:

        if (iSolidColor == -1)
        {
            // We handle patterns in 'pfnFastFill' only if we can use the
            // hardware patterns.

            if (!rbc.prb->fl & (RBRUSH_2COLOR | RBRUSH_4COLOR))
                goto SkipFastFill;
        }

        if (bMore)
        {
            // FastFill only knows how to take a single contiguous buffer
            // of points.  Unfortunately, GDI sometimes hands us paths
            // that are split over multiple path data records.  Convex
            // figures such as Ellipses, Pies and RoundRects are almost
            // always given in multiple records.  Since probably 90% of
            // multiple record paths could still be done by FastFill, for
            // those cases we simply copy the points into a contiguous
            // buffer...

            // First make sure that the entire path would fit in the
            // temporary buffer, and make sure the path isn't comprised
            // of more than one subpath:

            if ((ppo->cCurves >= NUM_BUFFER_POINTS) ||
                (pd.flags & PD_ENDSUBPATH))
                goto SkipFastFill;

            pptfxTmp = &aptfxBuf[0];

            RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);

            pptfxTmp     += pd.count;
            cptfxTmp      = pd.count;
            flFirstRecord = pd.flags;       // Remember PD_BEGINSUBPATH flag

            do {
                bMore = PATHOBJ_bEnum(ppo, &pd);

                RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);
                cptfxTmp += pd.count;
                pptfxTmp += pd.count;
            } while (!(pd.flags & PD_ENDSUBPATH));

            // Fake up the path data record:

            pd.pptfx  = &aptfxBuf[0];
            pd.count  = cptfxTmp;
            pd.flags |= flFirstRecord;

            // If there's more than one subpath, we can't call FastFill:

            if (bMore)
                goto SkipFastFill;
        }

        if (bFastFill(ppdev, pd.count, pd.pptfx, ulHwMix, iSolidColor,
                       rbc.prb, pptlBrush))
        {
            return(TRUE);
        }
    }

SkipFastFill:

    // Set up working storage in the temporary buffer

    prclRects = (RECTL*) ppdev->pvTmpBuffer; // storage for list of rectangles to draw

    if (!bMore) {

        RECTL *rectangle;
        INT cPoints = pd.count;

        // The count can't be less than three, because we got all the edges
        // in this subpath, and above we checked that there were at least
        // three edges

        // If the count is four, check to see if the polygon is really a
        // rectangle since we can really speed that up. We'll also check for
        // five with the first and last points the same, because under Win 3.1,
        // it was required to close polygons

        if ((cPoints == 4) ||
           ((cPoints == 5) &&
            (pd.pptfx[0].x == pd.pptfx[4].x) &&
            (pd.pptfx[0].y == pd.pptfx[4].y))) {

            rectangle = prclRects;

      /* we have to start somewhere so assume that most
         applications specify the top left point  first

         we want to check that the first two points are
         either vertically or horizontally aligned.  if
         they are then we check that the last point [3]
         is either horizontally or  vertically  aligned,
         and finally that the 3rd point [2] is  aligned
         with both the first point and the  last  point */

#define FIX_SHIFT 4L
#define FIX_MASK (- (1 << FIX_SHIFT))

         rectangle->top   = pd.pptfx[0].y - 1 & FIX_MASK;
         rectangle->left  = pd.pptfx[0].x - 1 & FIX_MASK;
         rectangle->right = pd.pptfx[1].x - 1 & FIX_MASK;

         if (rectangle->left ^ rectangle->right) {
            if (rectangle->top  ^ (pd.pptfx[1].y - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->left ^ (pd.pptfx[3].x - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->right ^ (pd.pptfx[2].x - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[2].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;
         }
         else {
            if (rectangle->top ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[1].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[2].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->right = pd.pptfx[2].x - 1 & FIX_MASK;
            if (rectangle->right ^ (pd.pptfx[3].x - 1 & FIX_MASK))
                goto not_rectangle;
         }

      /* if the left is greater than the right then
         swap them so the blt code doesn't wig  out */

         if (rectangle->left > rectangle->right) {
            FIX temp;

            temp = rectangle->left;
            rectangle->left = rectangle->right;
            rectangle->right = temp;
         }
         else {

         /* if left == right there's nothing to draw */

            if (rectangle->left == rectangle->right) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->left  = (rectangle->left  >> FIX_SHIFT) + 1;
         rectangle->right = (rectangle->right >> FIX_SHIFT) + 1;

         if (rectangle->top > rectangle->bottom) {
            FIX temp;

            temp = rectangle->top;
            rectangle->top = rectangle->bottom;
            rectangle->bottom = temp;
         }
         else {
            if (rectangle->top == rectangle->bottom) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->top    = (rectangle->top    >> FIX_SHIFT) + 1;
         rectangle->bottom = (rectangle->bottom >> FIX_SHIFT) + 1;

         // Finally, check for clipping
         if (jClipping == DC_RECT) {
            // Clip to the clip rectangle
            if (!bIntersect(rectangle, &ClipRect, rectangle)) {
                // Totally clipped, nothing to do
                goto ReturnTrue;
            }
         }

      /* if we get here then the polygon is a rectangle,
         set count to 1 and  goto  bottom  to  draw  it */

         ulNumRects = 1;
         goto draw_remaining_rectangles;
      }

not_rectangle:

        ;

    }

    // Do we have enough memory for all the edges?
    // LATER does cCurves include closure?
    if (ppo->cCurves > MAX_EDGES) {
#if TAKING_ALLOC_STATS
            BufferMissInFillpath++;
#endif
        //
        // try to allocate enough memory
        //
        pFreeEdges = (EDGE *) EngAllocMem(0, (ppo->cCurves * sizeof(EDGE)), ALLOC_TAG);

        if (pFreeEdges == NULL)
        {
            goto ReturnFalse;  // too many edges; let GDI fill the path
        }
        else
        {
            bMemAlloced = TRUE;
        }
    }
    else {
#if TAKING_ALLOC_STATS
            BufferHitInFillpath++;
#endif
        pFreeEdges = (EDGE*) ((BYTE*) ppdev->pvTmpBuffer + RECT_BYTES);
            // use our handy temporary buffer (it's big enough)
    }

    // Initialize an empty list of rectangles to fill
    ulNumRects = 0;

    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    pGETHead = &GETHead;
    if (!ConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore, &ClipRect)) {
        goto ReturnFalse;  // outside GDI's 2**27 range
    }

    // Create an empty AET with the head node also a tail sentinel
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;  // mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;    // this is greater than any valid X value, so
                               //  searches will always terminate

    // Top scan of polygon is the top of the first edge we come to
    iCurrentY = ((EDGE *)GETHead.pNext)->Y;

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    while (1) {

        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        if (AETHead.pNext != pAETHead) {
            AdvanceAETEdges(pAETHead);
        }

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        if (AETHead.pNext == pAETHead) {
            if (GETHead.pNext == pGETHead) {
                // Done if there are no edges in either the AET or the GET
                break;
            }
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            iCurrentY = ((EDGE *)GETHead.pNext)->Y;
        } else {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            if (((EDGE *)AETHead.pNext)->pNext != pAETHead) {
                XSortAETEdges(pAETHead);
            }
        }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        if (((EDGE *)GETHead.pNext)->Y == iCurrentY) {
            MoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        pCurrentEdge = AETHead.pNext;   // point to the first edge
        do {

            INT iLeftEdge;

            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            iLeftEdge = pCurrentEdge->X;

            // Find the matching right edge according to the current fill rule
            if ((flOptions & FP_WINDINGMODE) != 0) {

                INT iWindingCount;

                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                iWindingCount = pCurrentEdge->iWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while (iWindingCount != 0);
            } else {
                // Odd-even fill; the next edge is the matching right edge
                pCurrentEdge = pCurrentEdge->pNext;
            }

            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            if (iLeftEdge < pCurrentEdge->X) {

                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                if (ulNumRects >= MAX_PATH_RECTS) {
                    // No more room; draw the rectangles in the list and reset
                    // it to empty

                    (*pfnFill)(ppdev, ulNumRects, prclRects, ulHwMix,
                               rbc, pptlBrush);

                    // Reset the list to empty
                    ulNumRects = 0;
                }

                // Add the rectangle representing the current edge pair
                if (jClipping == DC_RECT) {
                    // Clipped
                    // Clip to left
                    prclRects[ulNumRects].left = max(iLeftEdge, ClipRect.left);
                    // Clip to right
                    prclRects[ulNumRects].right =
                            min(pCurrentEdge->X, ClipRect.right);
                    // Draw only if not fully clipped
                    if (prclRects[ulNumRects].left <
                            prclRects[ulNumRects].right) {
                        prclRects[ulNumRects].top = iCurrentY;
                        prclRects[ulNumRects].bottom = iCurrentY+1;
                        ulNumRects++;
                    }
                }
                else
                {
                    // Unclipped
                    prclRects[ulNumRects].top = iCurrentY;
                    prclRects[ulNumRects].bottom = iCurrentY+1;
                    prclRects[ulNumRects].left = iLeftEdge;
                    prclRects[ulNumRects].right = pCurrentEdge->X;
                    ulNumRects++;
                }
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        iCurrentY++;    // next scan
    }

/* draw the remaining rectangles,  if there are any */

draw_remaining_rectangles:

    if (ulNumRects > 0) {
        (*pfnFill)(ppdev, ulNumRects, prclRects, ulHwMix, rbc, pptlBrush);
    }

ReturnTrue:
    bRetVal = TRUE; // done successfully

ReturnFalse:

    // bRetVal is originally false.  If you jumped to ReturnFalse from somewhere,
    // then it will remain false, and be returned.

    if (bMemAlloced)
    {
        //
        // we did allocate memory, so release it
        //
        EngFreeMem (pFreeEdges);
    }

    return(bRetVal);
}

// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.
VOID AdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do {

        // Count down this edge's remaining scans
        if (--pCurrentEdge->iScansLeft == 0) {
            // We've done all scans for this edge; drop this edge from the AET
            pLastEdge->pNext = pCurrentEdge->pNext;
        } else {
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            pCurrentEdge->X += pCurrentEdge->iXWhole;
            // Advance the error term and see if we got one extra pixel this
            // time
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;
            if (pCurrentEdge->iErrorTerm >= 0) {
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
}

// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.
VOID XSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do {

        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X) {

                // Next edge is to the left of the current edge; swap them
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;

    do {

        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X) {
            pCurrentEdge = pCurrentEdge->pNext;
        }

        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;

    } while (pGETNext->Y == iCurrentY);
}





// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.

BOOL ConstructGET(
   EDGE     *pGETHead,
   EDGE     *pFreeEdges,
   PATHOBJ  *ppo,
   PATHDATA *pd,
   BOOL      bMore,
   RECTL    *pClipRect)
{
   POINTFIX pfxPathStart;    // point that started the current subpath
   POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              //  starts the current edge

/* Create an empty GET with the head node also a tail sentinel */

   pGETHead->pNext = pGETHead; // mark that the GET is empty
   pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

/* PATHOBJ_vEnumStart is implicitly  performed  by  engine
   already and first path  is  enumerated  by  the  caller */

next_subpath:

/* Make sure the PATHDATA is not empty (is this necessary) */

   if (pd->count != 0) {

   /* If first point starts a subpath, remember it as such
      and go on to the next point,   so we can get an edge */

      if (pd->flags & PD_BEGINSUBPATH) {

      /* the first point starts the subpath;   remember it */


         pfxPathStart    = *pd->pptfx; /* the subpath starts here          */
         pfxPathPrevious = *pd->pptfx; /* this points starts the next edge */
         pd->pptfx++;                  /* advance to the next point        */
         pd->count--;                  /* count off this point             */
      }


   /* add edges in PATHDATA to GET,  in Y-X  sorted  order */

      while (pd->count--) {
        if ((pFreeEdges =
            AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious, pd->pptfx,
                         pClipRect)) == NULL) {
            goto ReturnFalse;
        }
        pfxPathPrevious = *pd->pptfx; /* current point becomes previous   */
        pd->pptfx++;                  /* advance to the next point        */
      }


   /* If last point ends the subpath, insert the edge that
      connects to first point  (is this built in already?) */

      if (pd->flags & PD_ENDSUBPATH) {
         if ((pFreeEdges = AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                   &pfxPathStart, pClipRect)) == NULL) {
            goto ReturnFalse;
        }
      }
   }

/* the initial loop conditions preclude a do, while or for */

   if (bMore) {
       bMore = PATHOBJ_bEnum(ppo, pd);
       goto next_subpath;
   }

    return(TRUE);   // done successfully

ReturnFalse:
    return(FALSE);  // failed
}

// Adds the edge described by the two passed-in points to the Global Edge
// Table, if the edge spans at least one pixel vertically.
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd, RECTL *pClipRect)
{
    INT iYStart, iYEnd, iXStart, iXEnd, iYHeight, iXWidth;
    INT yJump, yTop;

    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order
    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (iYHeight == 0) {
        return(pFreeEdge);  // zero height; ignore this edge
    } else if (iYHeight >= 0) {
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = 1;
    } else {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = -1;
    }

    if (iYHeight & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now
    iXWidth = iXEnd - iXStart;
    if (iXWidth >= 0) {
        // Left to right, so we change X as soon as we move at all
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    } else {
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if (iXWidth & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    if (iXWidth >= iYHeight) {
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        pFreeEdge->iXWhole = iXWidth / iYHeight;
        // Add sign back into base run length if going right to left
        if (pFreeEdge->iXDirection == -1) {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }
        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    } else {
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }
    pFreeEdge->iErrorAdjustDown = iYHeight;

    // Calculate the number of pixels spanned by this edge, accounting for
    // clipping

    // Top true pixel scan in GIQ coordinates
    // Shifting to divide and multiply by 16 is okay because the clip rect
    // always contains positive numbers
    yTop = max(pClipRect->top << 4, (iYStart + 15) & ~0x0F);
    pFreeEdge->Y = yTop >> 4;    // initial scan line on which to fill edge

    // Calculate # of scans to actually fill, accounting for clipping
    if ((pFreeEdge->iScansLeft = min(pClipRect->bottom, ((iYEnd + 15) >> 4))
            - pFreeEdge->Y) <= 0) {

        return(pFreeEdge);  // no pixels at all are spanned, so we can
                            // ignore this edge
    }

    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects. Ditto if there's top clipping. Also clip to the bottom if
    // needed

    if (iYStart != yTop) {
        // Jump ahead by the Y distance in GIQ coordinates to the first pixel
        // to draw
        yJump = yTop - iYStart;

        // Advance x the minimum amount for the number of scans traversed
        iXStart += pFreeEdge->iXWhole * yJump;

        AdjustErrorTerm(&pFreeEdge->iErrorTerm, pFreeEdge->iErrorAdjustUp,
                        pFreeEdge->iErrorAdjustDown, yJump, &iXStart,
                        pFreeEdge->iXDirection);
    }
    // Turn the calculations into pixel rather than GIQ calculations

    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive
    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

    // LATER adjust only if needed (if prestepped above)?
    if (pFreeEdge->iXDirection == 1) {
        // Left to right
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                (((iXStart + 15) & ~0x0F) - iXStart);
    } else {
        // Right to left
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                ((iXStart - 1) & 0x0F);
    }

    // Scale the error term down 16 times to switch from GIQ to pixels.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    pFreeEdge->iErrorTerm >>= 4;

    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X))) {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}

// Adjust the error term for a skip ahead in y. This is in ASM because there's
// a multiply/divide that may involve a larger than 32-bit value.

void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection)
{
#if defined(_X86_) || defined(i386)
    // Adjust the error term up by the number of y coordinates we'll skip
    //*pErrorTerm += iErrorAdjustUp * yJump;
    _asm    mov ebx,pErrorTerm
    _asm    mov eax,iErrorAdjustUp
    _asm    mul yJump
    _asm    add eax,[ebx]
    _asm    adc edx,-1      // the error term starts out negative

    // See if the error term turned over even once while skipping
    //if (*pErrorTerm >= 0) {
    _asm    js  short NoErrorTurnover

        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        // NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;
        _asm    div iErrorAdjustDown
        _asm    inc eax
        // Note that EDX is the remainder; (EDX - iErrorAdjustDown) is where
        // the error term ends up ultimately

        // Advance x appropriately for the # of times the error term
        // turned over
        // if (iXDirection == 1) {
        //     *pXStart += NumAdjustDowns;
        // } else {
        //     *pXStart -= NumAdjustDowns;
        // }
        _asm    mov ecx,pXStart
        _asm    cmp iXDirection,1
        _asm    jz  short GoingRight
        _asm    neg eax
GoingRight:
        _asm    add [ecx],eax

        // Adjust the error term down to its proper post-skip value
        // *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
        _asm    sub edx,iErrorAdjustDown
        _asm    mov eax,edx     // put into EAX for storing to pErrorTerm next
        // }
NoErrorTurnover:
        _asm    mov [ebx],eax
#else

    LONGLONG llErrorTerm;
    INT NumAdjustDowns;

    llErrorTerm = *pErrorTerm;

    // Adjust the error term up by the number of y coordinates we'll skip
    llErrorTerm += Int32x32To64(iErrorAdjustUp,yJump);

    // See if the error term turned over even once while skipping
    if (llErrorTerm >= 0) {
        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        NumAdjustDowns = (UInt64Div32To32(llErrorTerm,iErrorAdjustDown)) + 1;

        // Advance x appropriately for the # of times the error term
        // turned over
        if (iXDirection == 1) {
            *pXStart += NumAdjustDowns;
        } else {
            *pXStart -= NumAdjustDowns;
        }

        // Adjust the error term down to its proper post-skip value
        llErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
    }

    *pErrorTerm = (INT) llErrorTerm;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\multi.c ===
/******************************Module*Header*******************************\
* Module Name: multi.c
*
* Supports multiple display boards as a single virtual desktop.
*
* This is implemented by presenting to GDI a single large virtual
* display and adding a layer between GDI and the driver's Drv functions.
* For the most part, the rest of the driver outside of multi.c doesn't
* have to change much, subject to the requirements below.
*
* This implementation requires that each board have the same virtual
* resolution and colour depth (e.g., all be running 1024x768x256), and
* that the boards be arranged in a rectangular configuration.
*
* Each board has its own PDEV, and completely manages its surface
* independently, down to glyph and bitmap caching.  The Mul
* routine intercepts the DDI call, and for each board dispatches
* a Drv call with the appropriate PDEV and clip object modifications.
*
* The following support in the main driver is required:
*
* 1) The driver should be able to handle a per-surface offset.  For
*    example, if two 1024x768 displays are pasted side-by-side, the
*    right board will get drawing operations in the range (1024, 768) -
*    (2048, 768).  The driver has a (-1024, 0) surface offset to convert
*    the actual drawing on the right board to the expected (0, 0) -
*    (1024, 768).
*
*    The current driver already uses this notion to support device-format
*    bitmaps drawn in off-screen memory.
*
*    Another option would be to handle the surface offsets in this layer,
*    but then all parameters including clip objects, paths and glyph
*    enumerations would have to be adjusted here as well.
*
* 2) The main driver must be able to share realized pattern information
*    between board instances.  That is, with the current DDI specification
*    GDI entirely handles brush memory allocation via pvAllocRBrush,
*    and the driver doesn't get notified when the brush is destroyed, so
*    the driver has to keep all information about the brush for all the
*    boards in the one brush realization.  This isn't too onerous.
*
* Problems:
*
* 1) DrvSetPointerShape requires that support be consistent between all
*    board instances -- for example, one board instance cannot accept
*    a h/w cursor and the other fail it, because GDI doesn't know it would
*    have to simulate on one area of the screen and not the other.
*
* 2) CompatibleBitmaps would have to be shared between board instances.
*    This becomes a problem when the bitmaps are kept by the driver in off-
*    screen memory.
*
* Status:
*
*    This code is officially untested.  However, I know of no outstanding
*    bugs -- everything seems to just work.
*
*    Note that I haven't addressed any initialization issues; to adapt this
*    code, you will need to solve some of those problems (such as proper
*    miniport support, and a nice method for the user to control the board
*    configurations and geometry).
*
* Disclaimer:
*
*    This code is provided as sample code only.  It is not intended to
*    represent Microsoft's endorsed solution for multiple screen support.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#if MULTI_BOARDS

// We change the active board to the home board after every drawing
// operation.  We do this only because the Metheus BIOS does not reset
// the active board on a soft-reset, and so the initial POST text
// would come up on whatever happened to be the last board drawn to.

#define GO_HOME(pmdev)       vSelectBoard(pmdev, pmdev->pmbHome)
#define GO_BOARD(pmdev, pmb) vSelectBoard(pmdev, pmb)

struct _MULTI_BOARD;

typedef struct _MULTI_BOARD MULTI_BOARD;    /* mb */

struct _MULTI_BOARD
{
    LONG            iHwBoard;       // Hardware board number
    LONG            iBoard;         // Sequentially allocated board number
    RECTL           rcl;            // Board's coordinates
    MULTI_BOARD*    pmbNext;        // For traversing the entire list of boards
    MULTI_BOARD*    pmbLeft;        // For traversing by direction
    MULTI_BOARD*    pmbUp;
    MULTI_BOARD*    pmbRight;
    MULTI_BOARD*    pmbDown;

    PDEV*           ppdev;          // Pointer to the board's PDEV
    SURFOBJ*        pso;            // Surface representing the board
    HSURF           hsurf;          // Handle to surface
};                                          /* mb, pmb */

typedef struct _MDEV
{
    MULTI_BOARD*    pmb;            // Where to start enumerating
    MULTI_BOARD*    pmbHome;        // Board used for full-screen
    MULTI_BOARD*    pmbUpperLeft;   // Board in upper-left corner
    MULTI_BOARD*    pmbUpperRight;
    MULTI_BOARD*    pmbLowerLeft;
    MULTI_BOARD*    pmbLowerRight;
    LONG            cxBoards;       // Number of boards per row
    LONG            cyBoards;       // Number of boards per column
    LONG            cBoards;        // Total number of boards

    MULTI_BOARD*    pmbPointer;     // Board where cursor is currently visible
    MULTI_BOARD*    pmbCurrent;     // Currently selected board (needed for
                                    //   DrvRealizeBrush)
    HDEV            hdev;           // Handle that GDI knows us by
    HSURF           hsurf;          // Handle to our virtual surface
    CLIPOBJ*        pco;            // A temporary CLIPOBJ that we can modify
    ULONG           iBitmapFormat;  // Current colour depth
    FLONG           flHooks;        // Those functions that the main driver
                                    //   is hooking

} MDEV;                                     /* mdev, pmdev */

typedef struct _PVCONSUMER
{
    PVOID       pvConsumer;
} PVCONSUMER;

typedef struct _FONT_CONSUMER
{
    LONG        cConsumers;         // Total number of boards
    PVCONSUMER  apvc[MAX_BOARDS];   // Array of structures cConsumers in length
} FONT_CONSUMER;                            /* fc, pfc */

typedef struct _BITBLTDATA
{
    RECTL       rclBounds;
    MDEV*       pmdev;

    SURFOBJ*    psoDst;
    SURFOBJ*    psoSrc;
    SURFOBJ*    psoMask;
    CLIPOBJ*    pco;
    XLATEOBJ*   pxlo;
    RECTL*      prclDst;
    POINTL*     pptlSrc;
    POINTL*     pptlMask;
    BRUSHOBJ*   pbo;
    POINTL*     pptlBrush;
    ROP4        rop4;
} BITBLTDATA;                               /* bb, pbb */

/******************************Public*Routine******************************\
* bFindBoard
*
* Returns in ppmb a pointer to the board containing the upper-left
* corner of prcl.
*
* Returns TRUE if prcl is entirely containing on one board; FALSE if
* prcl spans multiple boards.
*
\**************************************************************************/

BOOL bFindBoard(MDEV* pmdev, RECTL* prcl, MULTI_BOARD** ppmb)
{
    MULTI_BOARD* pmb;

    pmb = pmdev->pmbUpperLeft;

    // It should never happen that GDI will give us a call whose bounds
    // don't intersect the virtual screen.  But so that we don't crash
    // should it ever happen, we'll return an intersection with the first
    // board -- we can assume GDI at least said the clipping was non-
    // trivial, in which case that board's display routine will realize
    // nothing had to be done:

    *ppmb = pmb;

    // First find the row:

    while (prcl->top >= pmb->rcl.bottom)
    {
        pmb = pmb->pmbDown;
        if (pmb == NULL)
            return(FALSE);      // This is a case where the bounds doesn't
                                //  intercept the virtual screen
    }

    // Now find the column:

    while (prcl->left >= pmb->rcl.right)
    {
        pmb = pmb->pmbRight;
        if (pmb == NULL)
            return(FALSE);      // This is a case where the bounds doesn't
                                //  intercept the virtual screen
    }

    // So we found the first board:

    *ppmb = pmb;

    return(prcl->right  <= pmb->rcl.right &&
           prcl->bottom <= pmb->rcl.bottom);
}

/******************************Public*Routine******************************\
* bNextBoard
*
* Returns in ppmb a pointer to the next board after intersecting prcl, going
* left-to-right then top-to-bottom.
*
* Returns TRUE if all boards intersecting prcl have been enumerated; FALSE
* if there are more boards.
*
\**************************************************************************/

BOOL bNextBoard(RECTL* prcl, MULTI_BOARD** ppmb)
{
    MULTI_BOARD* pmb;

    pmb = *ppmb;

    // We'll do all the boards in a row first, remembering that the
    // bounds rectangle can extend past the end of our virtual screen:

    if ((prcl->right > pmb->rcl.right) && (pmb->pmbRight != NULL))
    {
        *ppmb = pmb->pmbRight;
        return(TRUE);
    }

    // Go to next row if need be, starting at the rcl.left:

    if ((prcl->bottom > pmb->rcl.bottom) && (pmb->pmbDown != NULL))
    {
        pmb = pmb->pmbDown;
        while ((prcl->left < pmb->rcl.left) && (pmb->pmbLeft != NULL))
        {
            pmb = pmb->pmbLeft;
        }
        *ppmb = pmb;
        return(TRUE);
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* vIntersect
*
* Returns in prclOut the intersection of rectangles prcl1 and prcl2.
*
\**************************************************************************/

VOID vIntersect(RECTL* prcl1, RECTL* prcl2, RECTL* prclOut)
{
    prclOut->left   = max(prcl1->left,   prcl2->left);
    prclOut->top    = max(prcl1->top,    prcl2->top);
    prclOut->right  = min(prcl1->right,  prcl2->right);
    prclOut->bottom = min(prcl1->bottom, prcl2->bottom);
}

/******************************Public*Routine******************************\
* bVeryTemporaryInitializationCode
*
\**************************************************************************/

BOOL bVeryTemporaryInitializationCode(MDEV* pmdev)
{
    MULTI_BOARD* pmb1 = NULL;
    MULTI_BOARD* pmb2 = NULL;

    pmb1 = EngAllocMem(FL_ZERO_MEMORY, sizeof(MULTI_BOARD), ALLOC_TAG);
    pmb2 = EngAllocMem(FL_ZERO_MEMORY, sizeof(MULTI_BOARD), ALLOC_TAG);

    if ((pmb1 == NULL) || (pmb2 == NULL))
    {
        EngFreeMem(pmb1);
        EngFreeMem(pmb2);
        return(FALSE);
    }

    // Only this initialization part is hard-coded to have two monitors,
    // side-by-side.

    // Board one:

    pmb1->iHwBoard         = 0;
    pmb1->iBoard           = 0;
    pmb1->pmbNext          = pmb2;
    pmb1->pmbRight         = pmb2;

    pmdev->pmb             = pmb1;
    pmdev->pmbUpperLeft    = pmb1;
    pmdev->pmbLowerLeft    = pmb1;
    pmdev->pmbHome         = pmb1;

    // Board two:

    pmb2->iHwBoard         = 1;
    pmb2->iBoard           = 1;
    pmb2->pmbLeft          = pmb1;

    pmdev->pmbUpperRight   = pmb2;
    pmdev->pmbLowerRight   = pmb2;

    pmdev->cxBoards        = 2;
    pmdev->cyBoards        = 1;
    pmdev->cBoards         = 2;

    // Assume that the currently active board is the 'home' board:

    pmdev->pmbCurrent      = pmdev->pmbHome;

    return(TRUE);
}

/******************************Public*Routine******************************\
* vSelectBoard
*
* Selects board pmb for drawing.  We can have only one Metheus board active
* at any time, so we have to disable the old board before enabling the new.
*
* Obviously, your hardware implementation may not require this entire
* function.  For example, you probably won't have to do this if you can
* have each board's accelerator registers mapped into separate address
* spaces.  NOTE: You'll still have to set pmdev->pmbCurrent, however,
* for DrvRealizeBrush to work!
*
\**************************************************************************/

VOID vSelectBoard(MDEV* pmdev, MULTI_BOARD* pmb)
{
    LONG iOldHwBoard;

    ASSERTDD(pmdev->pmbCurrent != NULL, "Can't have NULL pmbCurrent");

    // LATER: Expand this to handle more than 8 Metheus boards.

    iOldHwBoard = pmdev->pmbCurrent->iHwBoard;
    if (pmb->iHwBoard != iOldHwBoard)
    {
        OUTP(0x220, iOldHwBoard);           // Disable old board
        OUTP(0x220, (8 | pmb->iHwBoard));   // Enable new one
        pmdev->pmbCurrent = pmb;            // Remember new board
    }

}

/******************************Public*Routine******************************\
* bBoardCopy
*
* Given the BitBlt parameters in pbb, bitblt's the part of the rectangle
* on the pmbSrc board that must bitblt'ed to the pmbDst board.  Bails
* out quickly if nothing actually has to be copied.
*
* Will do a screen-to-screen blt if pmbSrc and pmbDst are the same board;
* otherwise it uses the psoTmp bitmap as temporary storage for transferring
* between the two boards.
*
* NOTE: If your hardware allows you to have all the frame buffers mapped
*       into memory simultaneously, you can avoid the 'psoTmp' bitmap
*       allocation and extra copy!
*
\**************************************************************************/

BOOL bBoardCopy(
BITBLTDATA*  pbb,
SURFOBJ*     psoTmp,
MULTI_BOARD* pmbDst,
MULTI_BOARD* pmbSrc)
{
    BOOL     b;
    RECTL    rclDst;
    LONG     dx;
    LONG     dy;
    RECTL    rclTmp;
    POINTL   ptlSrc;

    // If there's really no source board, we're guaranteed not to
    // have to copy anything from it:

    if (pmbSrc == NULL)
        return(TRUE);

    dx = pbb->prclDst->left - pbb->pptlSrc->x;
    dy = pbb->prclDst->top  - pbb->pptlSrc->y;

    // Pretend we're going to copy the entire source board's screen.
    // rclDst would be the destination rectangle:

    rclDst.left   = pmbSrc->rcl.left   + dx;
    rclDst.right  = pmbSrc->rcl.right  + dx;
    rclDst.top    = pmbSrc->rcl.top    + dy;
    rclDst.bottom = pmbSrc->rcl.bottom + dy;

    // We really want to copy only the part that overlaps the
    // destination board's screen:

    vIntersect(&pmbDst->rcl, &rclDst, &rclDst);

    // Plus we really only want to copy anything to what is contained
    // in the original destination rectangle:

    vIntersect(&pbb->rclBounds, &rclDst, &rclDst);

    // rclDst is now the destination rectangle for our call.  We'll
    // need a temporary bitmap for copying, so compute its extents:

    rclTmp.left   = 0;
    rclTmp.top    = 0;
    rclTmp.right  = rclDst.right  - rclDst.left;
    rclTmp.bottom = rclDst.bottom - rclDst.top;

    // If it's empty, we're outta here:

    if ((rclTmp.right <= 0) || (rclTmp.bottom <= 0))
        return(TRUE);

    if (pmbDst == pmbSrc)
    {
        // If the source and destination are the same board, we don't
        // need a temporary bitmap:

        psoTmp = pmbSrc->pso;
        ptlSrc = *pbb->pptlSrc;
    }
    else
    {
        ASSERTDD(psoTmp != NULL, "Need non-null bitmap");
        ASSERTDD(psoTmp->sizlBitmap.cx >= rclTmp.right, "Bitmap too small in x");
        ASSERTDD(psoTmp->sizlBitmap.cy >= rclTmp.bottom, "Bitmap too small in y");

        // Figure out the upper-left source corner corresponding to our
        // upper-left destination corner:

        ptlSrc.x = rclDst.left - dx;
        ptlSrc.y = rclDst.top  - dy;

        // Copy the rectangle from the source to the temporary bitmap:

        GO_BOARD(pbb->pmdev, pmbSrc);
        b = DrvCopyBits(psoTmp, pmbSrc->pso, NULL, NULL, &rclTmp, &ptlSrc);

        // Then get ready to do the copy from the temporary bitmap to
        // the destination:

        ptlSrc.x = pbb->prclDst->left - rclDst.left;
        ptlSrc.y = pbb->prclDst->top  - rclDst.top;
    }

    pbb->pco->rclBounds = rclDst;
    GO_BOARD(pbb->pmdev, pmbDst);
    b &= DrvBitBlt(pmbDst->pso, psoTmp, pbb->psoMask, pbb->pco, pbb->pxlo,
                   pbb->prclDst, &ptlSrc, pbb->pptlMask, pbb->pbo,
                   pbb->pptlBrush, pbb->rop4);

    return(b);
}

/******************************Public*Routine******************************\
* bBitBltBetweenBoards
*
* Handles screen-to-screen blts across multiple boards.
*
\**************************************************************************/

BOOL bBitBltBetweenBoards(
SURFOBJ*     psoDst,
SURFOBJ*     psoSrc,
SURFOBJ*     psoMask,
CLIPOBJ*     pco,
XLATEOBJ*    pxlo,
RECTL*       prclDst,
POINTL*      pptlSrc,
POINTL*      pptlMask,
BRUSHOBJ*    pbo,
POINTL*      pptlBrush,
ROP4         rop4,
RECTL*       prclUnion,     // Rectangular union of source and destination
MULTI_BOARD* pmbUnion)      // Board containing upper-left corner of prclUnion
{
    BOOL         b = TRUE;
    BITBLTDATA   bb;
    RECTL        rclOriginalBounds;
    SIZEL        sizlBoard;
    SIZEL        sizlDst;
    SIZEL        sizl;
    MULTI_BOARD* pmbSrc;
    MULTI_BOARD* pmbDst;
    LONG         dx;
    LONG         dy;
    RECTL        rclStart;

    SURFOBJ*     pso0 = NULL;   // Initialize these first off in case we
    SURFOBJ*     pso1 = NULL;   //   early-out
    SURFOBJ*     pso2 = NULL;
    SURFOBJ*     pso3 = NULL;
    HSURF        hsurf0 = 0;
    HSURF        hsurf1 = 0;

    bb.pmdev     = (MDEV*) psoDst->dhpdev;
    bb.psoDst    = psoDst;
    bb.psoSrc    = psoSrc;
    bb.psoMask   = psoMask;
    bb.pxlo      = pxlo;
    bb.prclDst   = prclDst;
    bb.pptlSrc   = pptlSrc;
    bb.pptlMask  = pptlMask;
    bb.pbo       = pbo;
    bb.pptlBrush = pptlBrush;
    bb.rop4      = rop4;
    bb.pco       = pco;
    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        bb.pco = bb.pmdev->pco;

    vIntersect(&bb.pco->rclBounds, prclDst, &bb.rclBounds);
    rclOriginalBounds = bb.pco->rclBounds;

    sizlDst.cx = bb.rclBounds.right - bb.rclBounds.left;
    sizlDst.cy = bb.rclBounds.bottom - bb.rclBounds.top;

    // This really should never happen, but we'll be paranoid:

    if ((sizlDst.cx <= 0) || (sizlDst.cy <= 0))
        return(TRUE);

    // Compute delta from source to destination:

    dx = prclDst->left - pptlSrc->x;
    dy = prclDst->top  - pptlSrc->y;

    // Figure out the size of a board:

    sizlBoard.cx = bb.pmdev->pmbUpperLeft->rcl.right;
    sizlBoard.cy = bb.pmdev->pmbUpperLeft->rcl.bottom;

    // We use temporary bitmaps as intermediaries for copying from one
    // board to another.  Note that it is much more efficient to allocate
    // on the fly, rather than keeping a dedicated bitmap around that
    // would have to be swapped in and out.

    // When the destination is close to the source, we can accomplish
    // most of the blt using screen-to-screen copies, and will need
    // only two small temporary bitmaps to temporarily hold the bits
    // that must be transferred from one board to another:

    if ((abs(dx) < (sizlBoard.cx >> 1)) && (abs(dy) < (sizlBoard.cy >> 1)))
    {
        // Create a temporary bitmap for the horizontal delta only if
        // the blt actually spans boards in the x-direction:

        if ((dx != 0) && (prclUnion->right > pmbUnion->rcl.right))
        {
            sizl.cx = min(sizlDst.cx, abs(dx));
            sizl.cy = min(sizlDst.cy, sizlBoard.cy - abs(dy));

            hsurf0 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                             0, NULL);
            pso1 = EngLockSurface(hsurf0);
            if (pso1 == NULL)
                return(FALSE);

            // Can use same temporary bitmap for section '3':

            pso3 = pso1;
        }

        // Similarly for the vertical delta:

        if ((dy != 0) && (prclUnion->bottom > pmbUnion->rcl.bottom))
        {
            sizl.cx = min(sizlDst.cx, sizlBoard.cx - abs(dx));
            sizl.cy = min(sizlDst.cy, abs(dy));

            hsurf1 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                             0, NULL);
            pso2 = EngLockSurface(hsurf1);
            if (pso2 == NULL)
            {
                b = FALSE;
                goto OuttaHere;
            }
        }
    }
    else
    {
        // Make the bitmap the size of a board, or the size of the
        // destination rectangle, which ever is smaller:

        sizl.cx = min(sizlDst.cx, sizlBoard.cx);
        sizl.cy = min(sizlDst.cy, sizlBoard.cy);

        hsurf0 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                         0, NULL);
        pso0 = EngLockSurface(hsurf0);
        if (pso0 == NULL)
            return(FALSE);

        pso1 = pso0;
        pso2 = pso0;
        pso3 = pso0;
    }

    if ((dx <= 0) && (dy <= 0))
    {
        // Move the rectangle up and to the left:

        // Find the board containing the upper-left corner of the destination:

        pmbDst = bb.pmdev->pmbUpperLeft;
        while (pmbDst->rcl.right <= bb.rclBounds.left)
            pmbDst = pmbDst->pmbRight;
        while (pmbDst->rcl.bottom <= bb.rclBounds.top)
            pmbDst = pmbDst->pmbDown;

        // Find the upper-left of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.left = pmbDst->rcl.left - dx;
        rclStart.top  = pmbDst->rcl.top  - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.right <= rclStart.left)
            pmbSrc = pmbSrc->pmbRight;
        while (pmbSrc->rcl.bottom <= rclStart.top)
            pmbSrc = pmbSrc->pmbDown;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbRight);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbDown);
            if (pmbSrc->pmbDown != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbDown->pmbRight);

            if (pmbDst->rcl.right < bb.rclBounds.right)
            {
                // Move right in the row of boards:

                pmbDst = pmbDst->pmbRight;
                pmbSrc = pmbSrc->pmbRight;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.bottom >= bb.rclBounds.bottom)
                    break;

                // Nope, have to go down to left side of next lower row:

                while (pmbDst->rcl.left > bb.rclBounds.left)
                {
                    pmbDst = pmbDst->pmbLeft;
                    pmbSrc = pmbSrc->pmbLeft;
                }

                pmbDst = pmbDst->pmbDown;
                pmbSrc = pmbSrc->pmbDown;
            }
        }
    }
    else if ((dx >= 0) && (dy >= 0))
    {
        // Move the rectangle down and to the right:

        // Find the board containing the lower-right corner of the destination:

        pmbDst = bb.pmdev->pmbLowerRight;
        while (pmbDst->rcl.left >= bb.rclBounds.right)
            pmbDst = pmbDst->pmbLeft;
        while (pmbDst->rcl.top >= bb.rclBounds.bottom)
            pmbDst = pmbDst->pmbUp;

        // Find the lower-right of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.right = pmbDst->rcl.right - dx;
        rclStart.bottom = pmbDst->rcl.bottom - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.left >= rclStart.right)
            pmbSrc = pmbSrc->pmbLeft;
        while (pmbSrc->rcl.top >= rclStart.bottom)
            pmbSrc = pmbSrc->pmbUp;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbLeft);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbUp);
            if (pmbSrc->pmbUp != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbUp->pmbLeft);

            if (pmbDst->rcl.left > bb.rclBounds.left)
            {
                // Move left in the row of boards:

                pmbDst = pmbDst->pmbLeft;
                pmbSrc = pmbSrc->pmbLeft;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.top <= bb.rclBounds.top)
                    break;

                // Nope, have to go up to right side of next upper row:

                while (pmbDst->rcl.right < bb.rclBounds.right)
                {
                    pmbDst = pmbDst->pmbRight;
                    pmbSrc = pmbSrc->pmbRight;
                }

                pmbDst = pmbDst->pmbUp;
                pmbSrc = pmbSrc->pmbUp;
            }
        }
    }
    else if ((dx >= 0) && (dy <= 0))
    {
        // Move the rectangle up and to the right:

        // Find the board containing the upper-right corner of the destination:

        pmbDst = bb.pmdev->pmbUpperRight;
        while (pmbDst->rcl.left >= bb.rclBounds.right)
            pmbDst = pmbDst->pmbLeft;
        while (pmbDst->rcl.bottom <= bb.rclBounds.top)
            pmbDst = pmbDst->pmbDown;

        // Find the upper-right of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.right = pmbDst->rcl.right - dx;
        rclStart.top   = pmbDst->rcl.top   - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.left >= rclStart.right)
            pmbSrc = pmbSrc->pmbLeft;
        while (pmbSrc->rcl.bottom <= rclStart.top)
            pmbSrc = pmbSrc->pmbDown;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbLeft);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbDown);
            if (pmbSrc->pmbDown != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbDown->pmbLeft);

            if (pmbDst->rcl.left > bb.rclBounds.left)
            {
                // Move left in the row of boards:

                pmbDst = pmbDst->pmbLeft;
                pmbSrc = pmbSrc->pmbLeft;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.bottom >= bb.rclBounds.bottom)
                    break;

                // Nope, have to go down to right side of next lower row:

                while (pmbDst->rcl.right < bb.rclBounds.right)
                {
                    pmbDst = pmbDst->pmbRight;
                    pmbSrc = pmbSrc->pmbRight;
                }

                pmbDst = pmbDst->pmbDown;
                pmbSrc = pmbSrc->pmbDown;
            }
        }
    }
    else
    {
        // Move the rectangle down and to the left:

        // Find the board containing the lower-left corner of the destination:

        pmbDst = bb.pmdev->pmbLowerLeft;
        while (pmbDst->rcl.right <= bb.rclBounds.left)
            pmbDst = pmbDst->pmbRight;
        while (pmbDst->rcl.top >= bb.rclBounds.bottom)
            pmbDst = pmbDst->pmbUp;

        // Find the lower-left of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.left   = pmbDst->rcl.left   - dx;
        rclStart.bottom = pmbDst->rcl.bottom - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.right <= rclStart.left)
            pmbSrc = pmbSrc->pmbRight;
        while (pmbSrc->rcl.top >= rclStart.bottom)
            pmbSrc = pmbSrc->pmbUp;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbRight);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbUp);
            if (pmbSrc->pmbUp != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbUp->pmbRight);

            if (pmbDst->rcl.right < bb.rclBounds.right)
            {
                // Move right in the row of boards:

                pmbDst = pmbDst->pmbRight;
                pmbSrc = pmbSrc->pmbRight;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.top <= bb.rclBounds.top)
                    break;

                // Nope, have to up down to left side of next upper row:

                while (pmbDst->rcl.left > bb.rclBounds.left)
                {
                    pmbDst = pmbDst->pmbLeft;
                    pmbSrc = pmbSrc->pmbLeft;
                }

                pmbDst = pmbDst->pmbUp;
                pmbSrc = pmbSrc->pmbUp;
            }
        }
    }

    GO_HOME(bb.pmdev);
    bb.pco->rclBounds = rclOriginalBounds;

OuttaHere:

    // In one case, pso0 == pso1 == pso2 == pso3, and we don't want to
    // unlock the same surface twice:

    if (pso1 != pso2)
        EngUnlockSurface(pso1);

    EngUnlockSurface(pso2);
    EngDeleteSurface(hsurf0);
    EngDeleteSurface(hsurf1);

    return(b);
}

/******************************Public*Routine******************************\
* MulGetModes
*
\**************************************************************************/

ULONG MulGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW* pdm)
{
    ULONG ulRet;

    ulRet = DrvGetModes(hDriver, cjSize, pdm);

    return(ulRet);
}

/******************************Public*Routine******************************\
* MulEnablePDEV
*
\**************************************************************************/

DHPDEV MulEnablePDEV(
DEVMODEW* pDevmode,
PWSTR     pwszLogAddress,
ULONG     cPatterns,
HSURF*    ahsurfPatterns,
ULONG     cjGdiInfo,
ULONG*    pGdiInfo,
ULONG     cjDevInfo,
DEVINFO*  pDevInfo,
HDEV      hdev,
PWSTR     pwszDeviceName,
HANDLE    hDriver)
{
    MDEV*        pmdev;                // Multi-board PDEV
    PDEV*        ppdev;                // Per-board PDEV
    MULTI_BOARD* pmb;
    LONG         cx;
    LONG         cy;

    // Note that we depend on the zero initialization:

    pmdev = (MDEV*) EngAllocMem(FL_ZERO_MEMORY, sizeof(MDEV), ALLOC_TAG);
    if (pmdev == NULL)
        goto ReturnFailure0;

    if (!bVeryTemporaryInitializationCode(pmdev))
        goto ReturnFailure1;

    // For every board, we'll create our own PDEV and surface:

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        // Initialize each board and create a surface to go with it:

        ppdev = (PDEV*) DrvEnablePDEV(pDevmode,     pwszLogAddress,
                                      cPatterns,    ahsurfPatterns,
                                      cjGdiInfo,    pGdiInfo,
                                      cjDevInfo,    pDevInfo,
                                      hdev,         pwszDeviceName,
                                      hDriver);
        if (ppdev == NULL)
            goto ReturnFailure1;

        pmb->ppdev = ppdev;
    }

    // Choose a board, any board:

    pmb = pmdev->pmbLowerLeft;

    // Get a copy of what functions we're supposed to hook, sans
    // HOOK_STRETCHBLT because I can't be bothered to write its
    // MulStretchBlt function, and HOOK_SYNCHRONIZE because we have
    // to be a device-managed surface (so DrvSynchronize is unneeded):

    pmdev->flHooks       = pmb->ppdev->flHooks
                         & ~(HOOK_STRETCHBLT | HOOK_SYNCHRONIZE);
    pmdev->iBitmapFormat = pmb->ppdev->iBitmapFormat;

    // As part of our hard-coded initialization hack, we will simply
    // take whatever resolution was requested via the Control Panel
    // and create a two board virtual desktop, where the screens are
    // side-by-side.
    //
    // The DrvEnablePDEV function for any board has already figured
    // out what the requested mode was:

    cx = ((GDIINFO*) pGdiInfo)->ulHorzRes;
    cy = ((GDIINFO*) pGdiInfo)->ulVertRes;

    // Set up bounds for left board:

    pmb->rcl.left       = 0;
    pmb->rcl.top        = 0;
    pmb->rcl.right      = cx;
    pmb->rcl.bottom     = cy;

    // Set up bounds for right board:

    pmb = pmb->pmbRight;

    pmb->rcl.left       = cx;
    pmb->rcl.top        = 0;
    pmb->rcl.right      = 2 * cx;
    pmb->rcl.bottom     = cy;

    // Adjust the stuff we return back to GDI:

    // ((GDIINFO*) pGdiInfo)->ulDesktopHorzRes  *= 2;
    // ((GDIINFO*) pGdiInfo)->ulHorzSize        *= 2;

    // With the Metheus board, since only one board can be mapped in
    // at one time, we cannot allow asynchronous pointers:

    pDevInfo->flGraphicsCaps &= ~(GCAPS_ASYNCMOVE | GCAPS_ASYNCCHANGE);

    return((DHPDEV) pmdev);

ReturnFailure1:
    MulDisablePDEV((DHPDEV) pmdev);

ReturnFailure0:
    DISPDBG((0, "Failed MulEnablePDEV"));

    return(0);
}

/******************************Public*Routine******************************\
* MulCompletePDEV
*
\**************************************************************************/

VOID MulCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    MDEV*         pmdev;
    MULTI_BOARD*  pmb;

    pmdev = (MDEV*) dhpdev;
    pmdev->hdev = hdev;

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);
        DrvCompletePDEV((DHPDEV) pmb->ppdev, hdev);
    }
}

/******************************Public*Routine******************************\
* MulEnableSurface
*
\**************************************************************************/

HSURF MulEnableSurface(DHPDEV dhpdev)
{
    MDEV*         pmdev;
    MULTI_BOARD*  pmb;
    SIZEL         sizlVirtual;
    HSURF         hsurfBoard;               // Gnarly, dude!
    SURFOBJ*      psoBoard;
    DSURF*        pdsurfBoard;
    HSURF         hsurfVirtual;
    CLIPOBJ*      pco;

    pmdev = (MDEV*) dhpdev;
    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);

        hsurfBoard = DrvEnableSurface((DHPDEV) pmb->ppdev);
        if (hsurfBoard == 0)
            goto ReturnFailure;

        pmb->hsurf = hsurfBoard;

        // Every time we draw on a particular board, we'll refer to it
        // using this surface:

        psoBoard = EngLockSurface(hsurfBoard);
        if (psoBoard == NULL)
            goto ReturnFailure;

        pmb->pso = psoBoard;

        // There are a few things in the board's data instances that we
        // have to modify:

        pdsurfBoard = (DSURF*) psoBoard->dhsurf;

        pmb->ppdev->iBoard  =  pmb->iBoard;
        pdsurfBoard->poh->x = -pmb->rcl.left;
        pdsurfBoard->poh->y = -pmb->rcl.top;

        // This is sort of a hack.  Whenever we pass a call on to a board's
        // Drv function using 'pmb->pso', it has to be able to retrieve
        // it's own PDEV pointer from 'dhpdev':

        pmb->pso->dhpdev = (DHPDEV) pmb->ppdev;
    }

    // Now create the surface which the engine will use to refer to our
    // entire multi-board virtual screen:

    sizlVirtual.cx = pmdev->pmbLowerRight->rcl.right;
    sizlVirtual.cy = pmdev->pmbLowerRight->rcl.bottom;

    hsurfVirtual = EngCreateDeviceSurface((DHSURF) pmdev, sizlVirtual,
                                          pmdev->iBitmapFormat);
    if (hsurfVirtual == 0)
        goto ReturnFailure;

    pmdev->hsurf = hsurfVirtual;

    if (!EngAssociateSurface(hsurfVirtual, pmdev->hdev, pmdev->flHooks))
        goto ReturnFailure;

    // Create a temporary clip object that we can use when a drawing
    // operation spans multiple boards:

    pco = EngCreateClip();
    if (pco == NULL)
        goto ReturnFailure;

    pmdev->pco = pco;

    pmdev->pco->iDComplexity      = DC_RECT;
    pmdev->pco->iMode             = TC_RECTANGLES;
    pmdev->pco->rclBounds.left    = 0;
    pmdev->pco->rclBounds.top     = 0;
    pmdev->pco->rclBounds.right   = pmdev->pmbLowerRight->rcl.right;
    pmdev->pco->rclBounds.bottom  = pmdev->pmbLowerRight->rcl.bottom;

    return(hsurfVirtual);

ReturnFailure:
    MulDisableSurface((DHPDEV) pmdev);

    DISPDBG((0, "Failed MulEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* MulStrokePath
*
\**************************************************************************/

BOOL MulStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrush,
LINEATTRS* pla,
MIX        mix)
{
    RECTFX       rcfxBounds;
    RECTL        rclBounds;
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;
    FLOAT_LONG   elStyleState;

    // Get the path bounds and make it lower-right exclusive:

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclBounds.left   = (rcfxBounds.xLeft   >> 4);
    rclBounds.top    = (rcfxBounds.yTop    >> 4);
    rclBounds.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclBounds.bottom = (rcfxBounds.yBottom >> 4) + 2;

    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvStrokePath(pmb->pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix);
    }
    else
    {
        if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        {
            // If the CLIPOBJ doesn't have at least DC_RECT complexity,
            // substitute one that does:

            pco = pmdev->pco;
        }

        rclOriginalBounds = pco->rclBounds;
        elStyleState = pla->elStyleState;

        b = TRUE;
        do {
            // For each board, make sure the style state gets reset and
            // the path enumeration gets restarted:

            pla->elStyleState = elStyleState;
            PATHOBJ_vEnumStart(ppo);

            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvStrokePath(pmb->pso, ppo, pco, pxo, pbo, pptlBrush, pla,
                                   mix);
            }

        } while (bNextBoard(&rclBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulFillPath
*
\**************************************************************************/

BOOL MulFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix,
FLONG     flOptions)
{
    RECTFX       rcfxBounds;
    RECTL        rclBounds;
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;

    // Get the path bounds and make it lower-right exclusive:

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclBounds.left   = (rcfxBounds.xLeft   >> 4);
    rclBounds.top    = (rcfxBounds.yTop    >> 4);
    rclBounds.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclBounds.bottom = (rcfxBounds.yBottom >> 4) + 2;

    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvFillPath(pmb->pso, ppo, pco, pbo, pptlBrush, mix, flOptions);
    }
    else
    {
        if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        {
            // If the CLIPOBJ doesn't have at least DC_RECT complexity,
            // substitute one that does:

            pco = pmdev->pco;
        }

        rclOriginalBounds = pco->rclBounds;

        b = TRUE;
        do {
            // Make sure we restart the path enumeration if need be:

            PATHOBJ_vEnumStart(ppo);
            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvFillPath(pmb->pso, ppo, pco, pbo, pptlBrush, mix,
                                 flOptions);
            }

        } while (bNextBoard(&rclBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulBitBlt
*
\**************************************************************************/

BOOL MulBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL         bFromScreen;
    BOOL         bToScreen;
    MDEV*        pmdev;
    MULTI_BOARD* pmb;
    RECTL        rclOriginalBounds;
    BOOL         b;
    RECTL        rclBounds;
    LONG         xOffset;
    LONG         yOffset;
    RECTL        rclDstBounds;
    RECTL        rclDst;

    bFromScreen = ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE));
    bToScreen   = ((psoDst != NULL) && (psoDst->iType == STYPE_DEVICE));

    // We copy the prclDst rectangle here because sometimes GDI will
    // simply point prclDst to the same rectangle in pco->rclBounds,
    // and we'll be mucking with pco->rclBounds...

    rclDst = *prclDst;

    if (bToScreen && bFromScreen)
    {
        ///////////////////////////////////////////////////////////////
        // Screen-to-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;

        // rclBounds is the union of the source and destination rectangles:

        rclBounds.left   = min(rclDst.left, pptlSrc->x);
        rclBounds.top    = min(rclDst.top,  pptlSrc->y);
        rclBounds.right  = max(rclDst.right,
                               pptlSrc->x + (rclDst.right - rclDst.left));
        rclBounds.bottom = max(rclDst.bottom,
                               pptlSrc->y + (rclDst.bottom - rclDst.top));

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(pmb->pso, pmb->pso, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            return(bBitBltBetweenBoards(psoDst, psoSrc, psoMask, pco, pxlo,
                                        &rclDst, pptlSrc, pptlMask, pbo,
                                        pptlBrush, rop4, &rclBounds, pmb));
        }
    }
    else if (bToScreen)
    {
        ///////////////////////////////////////////////////////////////
        // To-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;
        if (bFindBoard(pmdev, &rclDst, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(pmb->pso, psoSrc, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            b = TRUE;
            do {
                if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
                {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvBitBlt(pmb->pso, psoSrc, psoMask, pco, pxlo, &rclDst,
                                   pptlSrc, pptlMask, pbo, pptlBrush, rop4);
                }

            } while (bNextBoard(&rclDst, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }
    else
    {
        ///////////////////////////////////////////////////////////////
        // From-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoSrc->dhpdev;

        // rclBounds is the source rectangle:

        rclBounds.left   = pptlSrc->x;
        rclBounds.top    = pptlSrc->y;
        rclBounds.right  = pptlSrc->x + (rclDst.right - rclDst.left);
        rclBounds.bottom = pptlSrc->y + (rclDst.bottom - rclDst.top);

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(psoDst, pmb->pso, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            // Offset to transform from source rectangle to destination
            // rectangle:

            xOffset = rclDst.left - pptlSrc->x;
            yOffset = rclDst.top  - pptlSrc->y;

            b = TRUE;
            do {
                // Since the screen is the source, but the clip bounds applies
                // to the destination, we have to convert our board clipping
                // information to destination coordinates:

                rclDstBounds.left   = pmb->rcl.left   + xOffset;
                rclDstBounds.right  = pmb->rcl.right  + xOffset;
                rclDstBounds.top    = pmb->rcl.top    + yOffset;
                rclDstBounds.bottom = pmb->rcl.bottom + yOffset;

                if (bIntersect(&rclOriginalBounds, &rclDstBounds, &pco->rclBounds))
                {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvBitBlt(psoDst, pmb->pso, psoMask, pco, pxlo, &rclDst,
                                   pptlSrc, pptlMask, pbo, pptlBrush, rop4);
                }

            } while (bNextBoard(&rclBounds, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulDisablePDEV
*
* Note: May be called before MulEnablePDEV successfully completed!
*
\**************************************************************************/

VOID MulDisablePDEV(DHPDEV dhpdev)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;

    pmdev = (MDEV*) dhpdev;

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        if (pmb->ppdev != NULL)
        {
            GO_BOARD(pmdev, pmb);
            DrvDisablePDEV((DHPDEV) pmb->ppdev);
        }
    }

    GO_HOME(pmdev);

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        EngFreeMem(pmb);         // Undo 'bVeryTemporaryInitializationCode'
    }                           //   allocation

    EngFreeMem(pmdev);

}

/******************************Public*Routine******************************\
* MulDisableSurface
*
* Note: May be called before MulEnableSurface successfully completed!
*
\**************************************************************************/

VOID MulDisableSurface(DHPDEV dhpdev)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;

    pmdev = (MDEV*) dhpdev;

    if (pmdev->pco != NULL)
        EngDeleteClip(pmdev->pco);

    EngDeleteSurface(pmdev->hsurf);

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);

        EngUnlockSurface(pmb->pso);

        DrvDisableSurface((DHPDEV) pmb->ppdev);
    }

    GO_HOME(pmdev);
}

/******************************Public*Routine******************************\
* MulAssertMode
*
\**************************************************************************/

BOOL MulAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    MDEV*         pmdev;
    MULTI_BOARD*  pmb;

    pmdev = (MDEV*) dhpdev;

    if (!bEnable)
    {
        // When switching to full-screen mode, PatBlt blackness over
        // all the inactive screens (otherwise it looks goofy when
        // the desktop is frozen on the inactive screens and the user
        // can't do anything with it):

        for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
        {
            if (pmb != pmdev->pmbHome)
            {
                GO_BOARD(pmdev, pmb);
                DrvBitBlt(pmb->pso, NULL, NULL, NULL, NULL, &pmb->rcl, NULL,
                          NULL, NULL, NULL, 0);
            }
        }
    }

    // We use the 'home' board for full-screen switching:

    GO_BOARD(pmdev, pmdev->pmbHome);
    return (DrvAssertMode((DHPDEV) pmdev->pmbHome->ppdev, bEnable));
}

/******************************Public*Routine******************************\
* MulMovePointer
*
\**************************************************************************/

VOID MulMovePointer(
SURFOBJ* pso,
LONG     x,
LONG     y,
RECTL*   prcl)
{
    MDEV*        pmdev;
    MULTI_BOARD* pmbPointer;
    RECTL        rclPointer;

    pmdev     = (MDEV*) pso->dhpdev;
    pmbPointer = pmdev->pmbPointer;

    if (pmbPointer != NULL)
    {
        // The most common case is when the pointer is moved to a spot
        // on the same board:

        if ((x >= pmbPointer->rcl.left)  &&
            (x <  pmbPointer->rcl.right) &&
            (y >= pmbPointer->rcl.top)   &&
            (y <  pmbPointer->rcl.bottom))
        {
            GO_BOARD(pmdev, pmbPointer);
            DrvMovePointer(pmbPointer->pso, x, y, prcl);
            GO_HOME(pmdev);

            return;
        }

        // Tell the old board to erase its cursor:

        GO_BOARD(pmdev, pmbPointer);
        DrvMovePointer(pmbPointer->pso, -1, -1, NULL);
    }

    if (x == -1)
    {
        pmdev->pmbPointer = NULL;
        GO_HOME(pmdev);

        return;
    }

    // Find the new board and tell it to draw its new cursor:

    rclPointer.left   = x;
    rclPointer.right  = x;
    rclPointer.top    = y;
    rclPointer.bottom = y;

    bFindBoard(pmdev, &rclPointer, &pmbPointer);

    GO_BOARD(pmdev, pmbPointer);
    DrvMovePointer(pmbPointer->pso, x, y, prcl);

    pmdev->pmbPointer = pmbPointer;

    GO_HOME(pmdev);
}

/******************************Public*Routine******************************\
* MulSetPointerShape
*
\**************************************************************************/

ULONG MulSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;
    ULONG        ulRetPrevious = (ULONG) -1;
    ULONG        ulRet;
    RECTL        rclPointer;
    MULTI_BOARD* pmbPointer;             // Board on which cursor is visible

    pmdev = (MDEV*) pso->dhpdev;

    // Find out which board that the cursor is visible on, if any:

    pmbPointer = NULL;
    if (x != 1)
    {
        rclPointer.left   = x;
        rclPointer.right  = x;
        rclPointer.top    = y;
        rclPointer.bottom = y;

        bFindBoard(pmdev, &rclPointer, &pmbPointer);
    }
    pmdev->pmbPointer = pmbPointer;

    // LATER: Fix the case for when some boards may fail the call, and others
    //        won't.

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        // We notify all boards of the new cursor shape, but only the board
        // on which the cursor is visible is told to draw it:

        GO_BOARD(pmdev, pmb);

        if (pmb == pmbPointer)
        {
            ulRet = DrvSetPointerShape(pmb->pso, psoMask, psoColor, pxlo,
                                       xHot, yHot, x, y, prcl, fl);
        }
        else
        {
            ulRet = DrvSetPointerShape(pmb->pso, psoMask, psoColor, pxlo,
                                       xHot, yHot, -1, y, NULL, fl);
        }

        if ((ulRetPrevious != (ULONG) -1) && (ulRetPrevious != ulRet))
        {
            RIP("MulSetPointerShape not all DrvSetPointerShapes same\n");
        }

        ulRetPrevious = ulRet;
    }

    GO_HOME(pmdev);

    return(ulRetPrevious);
}

/******************************Public*Routine******************************\
* MulDitherColor
*
\**************************************************************************/

ULONG MulDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    PDEV* ppdev;
    ULONG ulRet;

    // Let the first board's driver do the dithering:

    ppdev = ((MDEV*) dhpdev)->pmb->ppdev;
    ulRet = DrvDitherColor((DHPDEV) ppdev, iMode, rgb, pul);

    return(ulRet);
}

/******************************Public*Routine******************************\
* MulSetPalette
*
\**************************************************************************/

BOOL MulSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;
    BOOL         bRet = TRUE;

    // Notify all boards of the palette change:

    pmdev = (MDEV*) dhpdev;
    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);
        bRet &= DrvSetPalette((DHPDEV) pmb->ppdev, ppalo, fl, iStart, cColors);
    }

    GO_HOME(pmdev);

    return(bRet);
}

/******************************Public*Routine******************************\
* MulCopyBits
*
\**************************************************************************/

BOOL MulCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL         bFromScreen;
    BOOL         bToScreen;
    MDEV*        pmdev;
    MULTI_BOARD* pmb;
    RECTL        rclOriginalBounds;
    BOOL         b;
    RECTL        rclBounds;
    RECTL        rclDst;

    bFromScreen = ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE));
    bToScreen   = ((psoDst != NULL) && (psoDst->iType == STYPE_DEVICE));

    // We copy the prclDst rectangle here because sometimes GDI will
    // simply point prclDst to the same rectangle in pco->rclBounds,
    // and we'll be mucking with pco->rclBounds...

    rclDst = *prclDst;

    if (bToScreen && bFromScreen)
    {
        ///////////////////////////////////////////////////////////////
        // Screen-to-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;

        // rclBounds is the union of the source and destination rectangles:

        rclBounds.left   = min(rclDst.left, pptlSrc->x);
        rclBounds.top    = min(rclDst.top,  pptlSrc->y);
        rclBounds.right  = max(rclDst.right,
                               pptlSrc->x + (rclDst.right - rclDst.left));
        rclBounds.bottom = max(rclDst.bottom,
                               pptlSrc->y + (rclDst.bottom - rclDst.top));

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvCopyBits(pmb->pso, pmb->pso, pco, pxlo, &rclDst, pptlSrc);
        }
        else
        {
            return(bBitBltBetweenBoards(psoDst, psoSrc, NULL, pco, pxlo,
                                        &rclDst, pptlSrc, NULL, NULL,
                                        NULL, 0x0000cccc, &rclBounds, pmb));
        }
    }
    else if (bToScreen)
    {
        ///////////////////////////////////////////////////////////////
        // To-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;
        if (bFindBoard(pmdev, &rclDst, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvCopyBits(pmb->pso, psoSrc, pco, pxlo, &rclDst, pptlSrc);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            b = TRUE;
            do {
                if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
                {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvCopyBits(pmb->pso, psoSrc, pco, pxlo, &rclDst,
                                     pptlSrc);
                }

            } while (bNextBoard(&rclDst, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }
    else
    {
        ///////////////////////////////////////////////////////////////
        // From-screen
        ///////////////////////////////////////////////////////////////

        // This rarely happens, so save some code space:

        return(MulBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst,
                              pptlSrc, NULL, NULL, NULL, 0x0000cccc));
    }

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulTextOut
*
\**************************************************************************/

BOOL MulTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    MDEV*          pmdev;
    MULTI_BOARD*   pmb;
    RECTL          rclOriginalBounds;
    BYTE           fjOriginalOptions;
    BOOL           b;
    RECTL*         prclBounds;
    FONT_CONSUMER* pfcArray;

    pmdev = (MDEV*) pso->dhpdev;

    // In keeping with our philosophy for multiple board support, we handle
    // multiple consumers of the same font at this level.  We do this by
    // monitoring pfo->pvConsumer, and the first time a board sets the
    // field, we take control of pfo->pvConsumer.  We use it to allocate
    // a pvConsumer array where we can keep track of every board's
    // individual pvConsumer.

    pfcArray = pfo->pvConsumer;

    prclBounds = (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround;

    bFindBoard(pmdev, prclBounds, &pmb);

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        // If the CLIPOBJ doesn't have at least DC_RECT complexity,
        // substitute one that does:

        pco = pmdev->pco;
    }

    rclOriginalBounds = pco->rclBounds;
    fjOriginalOptions = pco->fjOptions;

    // OR in the OC_BANK_CLIP flag to let GDI know that we may be calling
    // EngTextOut multiple times with the same parameters (EngTextOut
    // is destructive in that it modifies that parameters passed to it,
    // unless this bit is set):

    pco->fjOptions |= OC_BANK_CLIP;

    b = TRUE;
    do {
        if (pfcArray != NULL)
            pfo->pvConsumer = pfcArray->apvc[pmb->iBoard].pvConsumer;

        // Make sure we restart the glyph enumeration if need be:

        STROBJ_vEnumStart(pstro);
        if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
        {
            GO_BOARD(pmdev, pmb);
            b &= DrvTextOut(pmb->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                            pboFore, pboOpaque, pptlOrg, mix);
        }

        if (pfcArray != NULL)
        {
            // Copy the pvConsumer, in case the last DrvTextOut changed
            // it:

            pfcArray->apvc[pmb->iBoard].pvConsumer = pfo->pvConsumer;
        }
        else
        {
            if (pfo->pvConsumer != NULL)
            {
                // The board allocated a new consumer, so create our array
                // to keep track of consumers for every board:

                pfcArray = (FONT_CONSUMER*) EngAllocMem(FL_ZERO_MEMORY,
                             sizeof(FONT_CONSUMER), ALLOC_TAG);
                if (pfcArray == NULL)
                    DrvDestroyFont(pfo);
                else
                {
                    pfcArray->cConsumers = pmdev->cBoards;
                    pfcArray->apvc[pmb->iBoard].pvConsumer = pfo->pvConsumer;

                }
            }
        }
    } while (bNextBoard(prclBounds, &pmb));

    // Restore the original clip bounds:

    pco->rclBounds = rclOriginalBounds;
    pco->fjOptions = fjOriginalOptions;

    // Make sure we restore/set the font's pvConsumer:

    pfo->pvConsumer = pfcArray;

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulDestroyFont
*
\**************************************************************************/

VOID MulDestroyFont(FONTOBJ *pfo)
{
    FONT_CONSUMER* pfcArray;
    LONG           i;
    PVOID          pvConsumer;

    if (pfo->pvConsumer != NULL)
    {
        pfcArray = pfo->pvConsumer;
        for (i = 0; i < pfcArray->cConsumers; i++)
        {
            pvConsumer = pfcArray->apvc[i].pvConsumer;
            if (pvConsumer != NULL)
            {
                pfo->pvConsumer = pvConsumer;
                DrvDestroyFont(pfo);
            }
        }

        EngFreeMem(pfcArray);
        pfo->pvConsumer = NULL;
    }

}

/******************************Public*Routine******************************\
* MulPaint
*
\**************************************************************************/

BOOL MulPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;

    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &pco->rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvPaint(pmb->pso, pco, pbo, pptlBrush, mix);
    }
    else
    {
        rclOriginalBounds = pco->rclBounds;

        b = TRUE;
        do {
            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvPaint(pmb->pso, pco, pbo, pptlBrush, mix);
            }

        } while (bNextBoard(&rclOriginalBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulRealizeBrush
*
\**************************************************************************/

BOOL MulRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    MDEV*        pmdev;
    BOOL         b;

    pmdev = (MDEV*) psoTarget->dhpdev;

    // DrvRealizeBrush is only ever calling from within a Drv function.
    // 'psoTarget' points to our multi-board surface, but we have to point
    // it to the surface of the board for which the DrvBitBlt call was made.

    // NOTE: If SLOWFILL_PATTERNS are enabled, we will have to do a
    //       GO_BOARD here, because our DrvRealizeBrush routine actually
    //       draws for that case.

    b = DrvRealizeBrush(pbo, pmdev->pmbCurrent->pso, psoPattern, psoMask,
                        pxlo, iHatch);

    return(b);
}

#endif // MULTI_BOARDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\precomp.h ===
/******************************Module*Header*******************************\
* Module Name: precomp.h
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>
#include <math.h>

#include "lines.h"
#include "driver.h"
#include "hw.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\misc.c ===
/******************************Module*Header*******************************\
* Module Name: misc.c
*
* Miscellaneous common routines.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vResetClipping
\**************************************************************************/

VOID vResetClipping(
PDEV*   ppdev)
{
    BYTE*   pjBase;

    pjBase = ppdev->pjBase;

    CP_WAIT(ppdev, pjBase);
    CP_ABS_WMIN(ppdev, pjBase, 0, 0);
    CP_ABS_WMAX(ppdev, pjBase, MAX_COORD, MAX_COORD);
}

/******************************Public*Routine******************************\
* VOID vSetClipping
\**************************************************************************/

VOID vSetClipping(
PDEV*   ppdev,
RECTL*  prclClip)           // In relative coordinates
{
    BYTE*   pjBase;

    pjBase = ppdev->pjBase;

    CP_WAIT(ppdev, pjBase);
    CP_WMIN(ppdev, pjBase, prclClip->left, prclClip->top);
    CP_WMAX(ppdev, pjBase, prclClip->right - 1, prclClip->bottom - 1);
}

/******************************Public*Routine******************************\
* VOID vGetBits
*
* Copies the bits to the given surface from the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vGetBits(
PDEV*       ppdev,
SURFOBJ*    psoDst,
RECTL*      prclDst,        // Absolute coordinates!
POINTL*     pptlSrc)        // Absolute coordinates!
{
    LONG    lSrcDelta;
    LONG    lDstDelta;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    cjScan;
    LONG    cyScan;
    LONG    cjStartPhase;
    LONG    cjMiddle;
    LONG    i;

    CP_WAIT(ppdev, ppdev->pjBase);

    lSrcDelta = ppdev->lDelta;
    pjSrc     = ppdev->pjScreen
              + (pptlSrc->y * lSrcDelta)
              + (pptlSrc->x * ppdev->cjPel);

    lDstDelta = psoDst->lDelta;
    pjDst     = (BYTE*) psoDst->pvScan0
              + (prclDst->top * lDstDelta)
              + (prclDst->left * ppdev->cjPel);

    cjScan = (prclDst->right  - prclDst->left) * ppdev->cjPel;
    cyScan = (prclDst->bottom - prclDst->top);

    // We want to do aligned dword reads from the frame buffer:

    cjStartPhase = (LONG)((0 - (LONG_PTR)pjSrc) & 3);
    cjMiddle     = cjScan - cjStartPhase;
    if (cjMiddle < 0)
    {
        cjStartPhase += cjMiddle;
        cjMiddle = 0;
    }

    lSrcDelta -= cjStartPhase;
    lDstDelta -= cjStartPhase;

    do {
        for (i = cjStartPhase; i > 0; i--)
        {
            *pjDst++ = *pjSrc++;
        }

        memcpy(pjDst, pjSrc, cjMiddle);

        pjDst += lDstDelta;
        pjSrc += lSrcDelta;

    } while (--cyScan != 0);
}

/******************************Public*Routine******************************\
* VOID vPutBits
*
* Copies the bits from the given surface to the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vPutBits(
PDEV*       ppdev,
SURFOBJ*    psoSrc,
RECTL*      prclDst,            // Absolute coordinates!
POINTL*     pptlSrc)            // Absolute coordinates!
{
    LONG    lSrcDelta;
    LONG    lDstDelta;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    cjScan;
    LONG    cyScan;
    LONG    cjStartPhase;
    LONG    cjMiddle;
    LONG    i;

    CP_WAIT(ppdev, ppdev->pjBase);

    lSrcDelta = psoSrc->lDelta;
    pjSrc     = (BYTE*) psoSrc->pvScan0
              + (pptlSrc->y * lSrcDelta)
              + (pptlSrc->x * ppdev->cjPel);

    lDstDelta = ppdev->lDelta;
    pjDst     = ppdev->pjScreen
              + (prclDst->top * lDstDelta)
              + (prclDst->left * ppdev->cjPel);

    cjScan = (prclDst->right  - prclDst->left) * ppdev->cjPel;
    cyScan = (prclDst->bottom - prclDst->top);

    // We want to do aligned dword reads from the frame buffer:

    cjStartPhase = (LONG)((0 - (LONG_PTR)pjDst) & 3);
    cjMiddle     = cjScan - cjStartPhase;
    if (cjMiddle < 0)
    {
        cjStartPhase += cjMiddle;
        cjMiddle = 0;
    }

    lSrcDelta -= cjStartPhase;
    lDstDelta -= cjStartPhase;              // Account for start

    do {
        for (i = cjStartPhase; i > 0; i--)
        {
            *pjDst++ = *pjSrc++;
        }

        memcpy(pjDst, pjSrc, cjMiddle);

        pjSrc += lSrcDelta;
        pjDst += lDstDelta;

    } while (--cyScan != 0);
}

/******************************Public*Routine******************************\
* VOID DrvSynchronize
*
* Waits for all accelerator functions to finish so that GDI can draw
* on the frame buffer.
\**************************************************************************/

VOID DrvSynchronize(
DHPDEV  dhpdev,
RECTL*  prcl)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    // !!! Don't think this is true!
    //
    // We have to synchronize for off-screen device bitmaps as well as the
    // screen.  Unfortunately, GDI only gives us a 'dhpdev,' not a SURFOBJ
    // pointer, so we don't know whether it device bitmap is in off-screen,
    // or has been moved to a DIB (because we obviously don't have to
    // synchronize the hardware to draw to a DIB).  So we'll do extra,
    // unneeded synchronization.

    if (ppdev->bEnabled)
    {
        CP_WAIT(ppdev, ppdev->pjBase);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\lines.h ===
/******************************Module*Header*******************************\
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration

// We have to be careful that we don't overflow any registers when using
// the hardware to draw lines (as opposed to going through the strips
// routines, which will never overflow).  We accomplish this by simply
// checking the bounds of the path; if it is so large that any of the
// hardware terms may overflow, we punt the entire path to the strips
// code (should be pretty rare).

#define MAX_INTEGER_BOUND  (1600)
#define MIN_INTEGER_BOUND  (-1024)

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00008000L     // 1... .... .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_STYLED               0x00000400L     // .... .1.. .... ....
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000400L
#define FL_STYLE_SHIFT          10

#define FL_LAST_PEL_INCLUSIVE   0x00002000L     // ..1. .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

////////////////////////////////////////////////////////////////////////////
// NOTE: The following structures must exactly match those declared in
//       lines.inc!

typedef struct _STRIP {
    LONG   cStrips;               // # of strips in array
    LONG   flFlips;               // Indicates if line goes up or down
    POINTL ptlStart;              // first point
    LONG   alStrips[STRIP_MAX];   // Array of strips
} STRIP;

typedef struct _LINESTATE {
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    STYLEPOS*       psp;            // Pointer to current style entry

    STYLEPOS        spRemaining;    // To go in current style
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           ulStyleMask;    // Are we working on a gap in the style?
                                    // 0xff if yes, 0x0 if not
    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;                        /* ls */

// Line prototypes:

typedef VOID (*PFNSTRIP)(PDEV*, STRIP*, LINESTATE*);
typedef BOOL (*PFNLINES)(PDEV*, POINTFIX*, POINTFIX*, RUN*, ULONG, LINESTATE*,
                         RECTL*, PFNSTRIP*, FLONG, ULONG);

// Strip drawers:

VOID vStripSolidHorizontal(PDEV*, STRIP*, LINESTATE*);
VOID vStripSolidVertical(PDEV*, STRIP*, LINESTATE*);
VOID vStripSolidDiagonalHorizontal(PDEV*, STRIP*, LINESTATE*);
VOID vStripSolidDiagonalVertical(PDEV*, STRIP*, LINESTATE*);
VOID vStripStyledHorizontal(PDEV*, STRIP*, LINESTATE*);
VOID vStripStyledVertical(PDEV*, STRIP*, LINESTATE*);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\palette.c ===
/******************************Module*Header*******************************\
* Module Name: palette.c
*
* Palette support.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

PALETTEENTRY gapalBase[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

/******************************Public*Routine******************************\
* BOOL bInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)
{
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    BYTE            jRed;
    BYTE            jGre;
    BYTE            jBlu;
    HPALETTE        hpal;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Allocate our palette:

        ppal = (PALETTEENTRY*)EngAllocMem(FL_ZERO_MEMORY,
                        (sizeof(PALETTEENTRY) * 256), ALLOC_TAG);
        if (ppal == NULL)
            goto ReturnFalse;

        ppdev->pPal = ppal;

        // Generate 256 (8*4*4) RGB combinations to fill the palette

        jRed = 0;
        jGre = 0;
        jBlu = 0;

        ppalTmp = ppal;

        for (ulLoop = 256; ulLoop != 0; ulLoop--)
        {
            ppalTmp->peRed   = jRed;
            ppalTmp->peGreen = jGre;
            ppalTmp->peBlue  = jBlu;
            ppalTmp->peFlags = 0;

            ppalTmp++;

            if (!(jRed += 32))
                if (!(jGre += 32))
                    jBlu += 64;
        }

        // Fill in Windows reserved colours from the WIN 3.0 DDK
        // The Window Manager reserved the first and last 10 colours for
        // painting windows borders and for non-palette managed applications.

        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
            // First 10

            ppal[ulLoop]       = gapalBase[ulLoop];

            // Last 10

            ppal[246 + ulLoop] = gapalBase[ulLoop+10];
        }

        // Create handle for palette.

        hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
    }
    else
    {
        DISPDBG((1, "flRed: %lx flGreen: %lx flBlue: %lx",
                    ppdev->flRed, ppdev->flGreen, ppdev->flBlue));

        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
    }

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if (hpal == 0)
        goto ReturnFalse;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializePalette"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);

    if (ppdev->pPal != (PALETTEENTRY*) NULL)
        EngFreeMem(ppdev->pPal);
}

/******************************Public*Routine******************************\
* BOOL bEnablePalette
*
* Initialize the hardware's 8bpp palette registers.
*
\**************************************************************************/

BOOL bEnablePalette(PDEV* ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       cColors;
    PVIDEO_CLUTDATA pScreenClutData;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy colours in:

        cColors = 256;
        pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

        while(cColors--)
        {
            pScreenClutData[cColors].Red =    ppdev->pPal[cColors].peRed >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Green =  ppdev->pPal[cColors].peGreen >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue =   ppdev->pPal[cColors].peBlue >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }

        // Set palette registers:

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_COLOR_REGISTERS,
                             pScreenClut,
                             MAX_CLUT_SIZE,
                             NULL,
                             0,
                             &ulReturnedDataLength))
        {
            DISPDBG((0, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisablePalette
*
* Undoes anything done in bEnablePalette.
*
\**************************************************************************/

VOID vDisablePalette(
PDEV*   ppdev)
{
    // Nothin' to do
}

/******************************Public*Routine******************************\
* VOID vAssertModePalette
*
* Sets/resets the palette in preparation for full-screen/graphics mode.
*
\**************************************************************************/

VOID vAssertModePalette(
PDEV*   ppdev,
BOOL    bEnable)
{
    // USER immediately calls DrvSetPalette after switching out of
    // full-screen, so we don't have to worry about resetting the
    // palette here.
}

/******************************Public*Routine******************************\
* BOOL DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDEV*           ppdev;

    UNREFERENCED_PARAMETER(fl);

    ppdev = (PDEV*) dhpdev;

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DISPDBG((0, "DrvSetPalette failed PALOBJ_cGetColors\n"));
        return (FALSE);
    }

    // Set the high reserved byte in each palette entry to 0.
    // Do the appropriate palette shifting to fit in the DAC.

    if (ppdev->cPaletteShift)
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Red >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Green >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }
    }
    else
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Unused = 0;
        }
    }

    // Set palette registers

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_COLOR_REGISTERS,
                         pScreenClut,
                         MAX_CLUT_SIZE,
                         NULL,
                         0,
                         &cColors))
    {
        DISPDBG((0, "DrvSetPalette failed EngDeviceIoControl\n"));
        return (FALSE);
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\pointer.c ===
/******************************Module*Header*******************************\
* Module Name: pointer.c
*
* This module contains the hardware Pointer support.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1993-1995 Weitek Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* BOOL bCopyMonoPointer
*
* Copies two monochrome masks into a buffer of the maximum size handled by the
* miniport, with any extra bits set to 0.  The masks are converted to topdown
* form if they aren't already.  Returns TRUE if we can handle this pointer in
* hardware, FALSE if not.
*
\**************************************************************************/

BOOL bCopyMonoPointer(
PDEV*       ppdev,
SURFOBJ*    pso)
{
    ULONG   cy;
    BYTE*   pjSrcAnd;
    BYTE*   pjSrcXor;
    LONG    lDeltaSrc;
    LONG    lDeltaDst;
    LONG    lSrcWidthInBytes;
    ULONG   cxSrc;
    ULONG   cySrc;
    ULONG   cxSrcBytes;
    BYTE*   pjDstAnd;
    BYTE*   pjDstXor;
    PVIDEO_POINTER_ATTRIBUTES pPointerAttributes;

    pPointerAttributes = ppdev->pPointerAttributes;
    cxSrc = pso->sizlBitmap.cx;
    cySrc = pso->sizlBitmap.cy;
    pjDstAnd = pPointerAttributes->Pixels;
    pjDstXor = pPointerAttributes->Pixels;

    // Make sure the new pointer isn't too big to handle
    // (*2 because both masks are in there)

    if ((cxSrc > ppdev->PointerCapabilities.MaxWidth) ||
        (cySrc > (ppdev->PointerCapabilities.MaxHeight * 2)))
    {
        return(FALSE);
    }

    pjDstXor += ((ppdev->PointerCapabilities.MaxWidth + 7) / 8) *
        pPointerAttributes->Height;

    // Set the desk and mask to 0xff

    RtlFillMemory(pjDstAnd, pPointerAttributes->WidthInBytes *
        pPointerAttributes->Height, 0xFF);

    // Zero the dest XOR mask

    RtlZeroMemory(pjDstXor, pPointerAttributes->WidthInBytes *
        pPointerAttributes->Height);

    cxSrcBytes = (cxSrc + 7) / 8;

    if ((lDeltaSrc = pso->lDelta) < 0)
    {
        lSrcWidthInBytes = -lDeltaSrc;
    }
    else
    {
        lSrcWidthInBytes = lDeltaSrc;
    }

    pjSrcAnd = (BYTE*) pso->pvScan0;

    // Height of just AND mask

    cySrc = cySrc / 2;

    // Point to XOR mask

    pjSrcXor = pjSrcAnd + (cySrc * lDeltaSrc);

    // Offset from end of one dest scan to start of next

    lDeltaDst = pPointerAttributes->WidthInBytes;

    for (cy = 0; cy < cySrc; ++cy)
    {
        RtlCopyMemory(pjDstAnd, pjSrcAnd, cxSrcBytes);
        RtlCopyMemory(pjDstXor, pjSrcXor, cxSrcBytes);

        // Point to next source and dest scans

        pjSrcAnd += lDeltaSrc;
        pjSrcXor += lDeltaSrc;
        pjDstAnd += lDeltaDst;
        pjDstXor += lDeltaDst;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bSetHardwarePointerShape
*
* Changes the shape of the Hardware Pointer.
*
* Returns: True if successful, False if Pointer shape can't be hardware.
*
\**************************************************************************/

BOOL bSetHardwarePointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMask,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        x,
LONG        y,
FLONG       fl)
{
    PDEV*                       ppdev;
    DWORD                       returnedDataLength;
    PVIDEO_POINTER_ATTRIBUTES   pPointerAttributes;

    ppdev = (PDEV*) pso->dhpdev;

    pPointerAttributes = ppdev->pPointerAttributes;

    // Don't make any assumptions about the pointer flags.

    pPointerAttributes->Flags = 0;

    // We don't support color pointers.

    if (psoColor != NULL)
    {
        return(FALSE);
    }

    if ((ppdev->PointerCapabilities.Flags & VIDEO_MODE_MONO_POINTER) &&
        bCopyMonoPointer(ppdev, psoMask))
    {
        pPointerAttributes->Flags |= VIDEO_MODE_MONO_POINTER;
    }
    else
    {
        return(FALSE);
    }

    // Initialize Pointer attributes and position

    pPointerAttributes->Column = (SHORT)(x - ppdev->ptlHotSpot.x);
    pPointerAttributes->Row    = (SHORT)(y - ppdev->ptlHotSpot.y);
    pPointerAttributes->Enable = 1;

    if (fl & SPS_ANIMATESTART)
    {
        pPointerAttributes->Flags |= VIDEO_MODE_ANIMATE_START;
    }
    else if (fl & SPS_ANIMATEUPDATE)
    {
        pPointerAttributes->Flags |= VIDEO_MODE_ANIMATE_UPDATE;
    }

    // Set the new Pointer shape.

    CP_WAIT(ppdev, ppdev->pjBase);

    if (EngDeviceIoControl(ppdev->hDriver, IOCTL_VIDEO_SET_POINTER_ATTR,
        pPointerAttributes, ppdev->cjPointerAttributes, NULL, 0,
            &returnedDataLength))
    {

        DISPDBG((0, "Failed IOCTL_VIDEO_SET_POINTER_ATTR call"));
        return(FALSE);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvMovePointer
*
* Moves the hardware pointer to a new position.
*
\**************************************************************************/

VOID DrvMovePointer(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)
{
    PDEV*                   ppdev;
    DWORD                   returnedDataLength;
    VIDEO_POINTER_POSITION  NewPointerPosition;

    ppdev = (PDEV*) pso->dhpdev;

    // We don't use the exclusion rectangle because we only support
    // hardware Pointers. If we were doing our own Pointer simulations
    // we would want to update prcl so that the engine would call us
    // to exclude out pointer before drawing to the pixels in prcl.

    CP_WAIT(ppdev, ppdev->pjBase);

    if (x == -1)
    {
        // A new position of (-1,-1) means hide the pointer.

        if (EngDeviceIoControl(ppdev->hDriver,IOCTL_VIDEO_DISABLE_POINTER,
            NULL, 0, NULL, 0, &returnedDataLength))
        {
            // Not the end of the world, print warning in checked build.

            DISPDBG((0, "Failed IOCTL_VIDEO_DISABLE_POINTER"));
        }
    }
    else
    {
        NewPointerPosition.Column = (SHORT) x - (SHORT) (ppdev->ptlHotSpot.x);
        NewPointerPosition.Row    = (SHORT) y - (SHORT) (ppdev->ptlHotSpot.y);

        // Call NT screen driver to move Pointer.

        if (EngDeviceIoControl(ppdev->hDriver, IOCTL_VIDEO_SET_POINTER_POSITION,
            &NewPointerPosition, sizeof(VIDEO_POINTER_POSITION), NULL,
            0, &returnedDataLength))
        {
            // Not the end of the world, print warning in checked build.

            DISPDBG((0, "Failed IOCTL_VIDEO_SET_POINTER_POSITION"));
        }
    }
}

/******************************Public*Routine******************************\
* ULONG DrvSetPointerShape
*
* Sets the new pointer shape.
*
\**************************************************************************/

ULONG DrvSetPointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMask,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL*      prcl,
FLONG       fl)
{
    PDEV*   ppdev;
    DWORD   returnedDataLength;

    ppdev = (PDEV*) pso->dhpdev;

    // We don't use the exclusion rectangle because we only support
    // hardware Pointers. If we were doing our own Pointer simulations
    // we would want to update prcl so that the engine would call us
    // to exclude out pointer before drawing to the pixels in prcl.

    if (ppdev->pPointerAttributes == (PVIDEO_POINTER_ATTRIBUTES) NULL)
    {
        // Mini-port has no hardware Pointer support.

        return(SPS_DECLINE);
    }

    // See if we are being asked to hide the pointer
    // !!! Wrong

    if (psoMask == (SURFOBJ *) NULL)
    {
        CP_WAIT(ppdev, ppdev->pjBase);

        if (EngDeviceIoControl(ppdev->hDriver, IOCTL_VIDEO_DISABLE_POINTER,
            NULL, 0, NULL, 0, &returnedDataLength))
        {
            // It should never be possible to fail.

            DISPDBG((0, "Failed IOCTL_VIDEO_DISABLE_POINTER"));
        }

        return(TRUE);   // !!! Wrong
    }

    ppdev->ptlHotSpot.x = xHot;
    ppdev->ptlHotSpot.y = yHot;

    if (!bSetHardwarePointerShape(pso,psoMask,psoColor,pxlo,x,y,fl))
    {
        if (ppdev->bHwPointerActive)
        {
            ppdev->bHwPointerActive = FALSE;

            CP_WAIT(ppdev, ppdev->pjBase);

            if (EngDeviceIoControl(ppdev->hDriver,
                IOCTL_VIDEO_DISABLE_POINTER, NULL, 0, NULL, 0,
                &returnedDataLength))
            {
                DISPDBG((0, "Failed IOCTL_VIDEO_DISABLE_POINTER"));
            }
        }

        // Mini-port declines to realize this Pointer

        return(SPS_DECLINE);
    }
    else
    {
        ppdev->bHwPointerActive = TRUE;
    }

    return(SPS_ACCEPT_NOEXCLUDE);
}

/******************************Public*Routine******************************\
* VOID vDisablePointer
*
\**************************************************************************/

VOID vDisablePointer(
PDEV*   ppdev)
{
    EngFreeMem(ppdev->pPointerAttributes);
}

/******************************Public*Routine******************************\
* VOID vAssertModePointer
*
\**************************************************************************/

VOID vAssertModePointer(
PDEV*   ppdev,
BOOL    bEnable)
{
}

/******************************Public*Routine******************************\
* BOOL bEnablePointer
*
* Note: We can return TRUE, as long as pPointerAttributes is set to NULL,
*       and we will make due with a software cursor.
*
\**************************************************************************/

BOOL bEnablePointer(
PDEV*   ppdev)
{
    DWORD                       returnedDataLength;
    DWORD                       MaxWidth;
    DWORD                       MaxHeight;
    VIDEO_POINTER_ATTRIBUTES*   pPointerAttributes;

    ppdev->pPointerAttributes  = NULL;
    ppdev->cjPointerAttributes = 0;

    // Ask the miniport whether it provides pointer support.

    if (EngDeviceIoControl(ppdev->hDriver,
        IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES, &ppdev->ulMode,
        sizeof(PVIDEO_MODE), &ppdev->PointerCapabilities,
        sizeof(ppdev->PointerCapabilities), &returnedDataLength))
    {
        return(TRUE);
    }

    // If neither mono nor color hardware pointer is supported, there's no
    // hardware pointer support and we're done.

    if ((!(ppdev->PointerCapabilities.Flags & VIDEO_MODE_MONO_POINTER)) &&
        (!(ppdev->PointerCapabilities.Flags & VIDEO_MODE_COLOR_POINTER)))
    {
        return(TRUE);
    }

    // Note: The buffer itself is allocated after we set the
    // mode. At that time we know the pixel depth and we can
    // allocate the correct size for the color pointer if supported.

    // It's a hardware pointer; set up pointer attributes.

    MaxHeight = ppdev->PointerCapabilities.MaxHeight;

    // Allocate space for two DIBs (data/mask) for the pointer. If this
    // device supports a color Pointer, we will allocate a larger bitmap.
    // If this is a color bitmap we allocate for the largest possible
    // bitmap because we have no idea of what the pixel depth might be.

    // Width rounded up to nearest byte multiple

    if (!(ppdev->PointerCapabilities.Flags & VIDEO_MODE_COLOR_POINTER))
    {
        MaxWidth = (ppdev->PointerCapabilities.MaxWidth + 7) / 8;
    }
    else
    {
        MaxWidth = ppdev->PointerCapabilities.MaxWidth * sizeof(DWORD);
    }

    ppdev->cjPointerAttributes =
        sizeof(VIDEO_POINTER_ATTRIBUTES) +
        ((sizeof(UCHAR) * MaxWidth * MaxHeight) * 2);

    pPointerAttributes = (PVIDEO_POINTER_ATTRIBUTES)
        EngAllocMem(FL_ZERO_MEMORY,
        ppdev->cjPointerAttributes, ALLOC_TAG);

    if (pPointerAttributes == NULL)
    {
        return(TRUE);
    }

    pPointerAttributes->WidthInBytes = MaxWidth;
    pPointerAttributes->Width        = ppdev->PointerCapabilities.MaxWidth;
    pPointerAttributes->Height       = MaxHeight;
    pPointerAttributes->Column       = 0;
    pPointerAttributes->Row          = 0;
    pPointerAttributes->Enable       = 0;

    ppdev->pPointerAttributes = pPointerAttributes;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\clock.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\stretch.c ===
/******************************Module*Header*******************************\
* Module Name: stretch.c
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define STRETCH_MAX_EXTENT 32767

typedef DWORDLONG ULONGLONG;

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8Narrow
*
* Routine Description:
*
*   Stretch blt 8->8 when the width is 7 or less
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch8Narrow(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    BYTE*   pjDstEnd;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;

    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    BYTE*   pjDst       = pStrBlt->pjDstScan + xDst;
    LONG    yCount      = pStrBlt->YDstCount;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - WidthX;
    ULONG   yInt        = 0;

    yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;

    //
    // Narrow blt
    //

    do {

        ULONG  yTmp = yAccum + yFrac;
        BYTE   jSrc0;
        BYTE*  pjDstEndNarrow = pjDst + WidthX;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        do {
            jSrc0    = *pjSrc;
            xTmp     = xAccum + xFrac;
            pjSrc    = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum   = xTmp;
        } while (pjDst != pjDstEndNarrow);

        pjSrcScan += yInt;

        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }

        yAccum = yTmp;
        pjDst += lDstStride;

    } while (--yCount);

}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch32
*
* Routine Description:
*
*   Stretch blt 32->32
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch32(
STR_BLT* pStrBlt)
{
    BYTE*   pjOldScan;
    ULONG*  pulSrc;
    ULONG*  pulDstEnd;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    LONG    cyDuplicate;
    BYTE*   pjBase;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc * 4;
    ULONG*  pulDst      = (ULONG*)(pStrBlt->pjDstScan) + xDst;
    LONG    yDst        = pStrBlt->YDstStart;
    LONG    yCount      = pStrBlt->YDstCount;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - 4*WidthX;
    ULONG   yInt        = 0;

    pjBase = ppdev->pjBase;

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    do {

        ULONG   ulSrc;
        ULONG   yTmp;

        pulSrc  = (ULONG*) pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        pulDstEnd  = pulDst + WidthX;

        while (pulDst != pulDstEnd)
        {

            ulSrc  = *pulSrc;
            xTmp   = xAccum + xFrac;
            pulSrc = pulSrc + xInt + (xTmp < xAccum);
            *(ULONG*)pulDst = ulSrc;
            pulDst++;
            xAccum = xTmp;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pulDst = (ULONG*) ((BYTE*) pulDst + lDstStride);
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pulDst = (ULONG*) ((BYTE*) pulDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            do {
                CP_Y0(ppdev, pjBase, yDst - 1);
                CP_Y1(ppdev, pjBase, yDst - 1);
                CP_Y2(ppdev, pjBase, yDst);
                CP_Y3(ppdev, pjBase, yDst);
                yDst++;
                CP_START_BLT_WAIT(ppdev, pjBase);
            } while (--cyDuplicate != 0);
        }
    } while (yCount != 0);
}

/******************************Public*Routine******************************\
*
* Routine Description:
*
*   StretchBlt using integer math. Must be from one surface to another
*   surface of the same format.
*
* Arguments:
*
*   ppdev           -   PDEV for device
*   pvDst           -   Pointer to start of dst bitmap
*   lDeltaDst       -   Bytes from start of dst scan line to start of next
*   DstCx           -   Width of Dst Bitmap in pixels
*   DstCy           -   Height of Dst Bitmap in pixels
*   prclDst         -   Pointer to rectangle of Dst extents
*   pvSrc           -   Pointer to start of Src bitmap
*   lDeltaSrc       -   Bytes from start of Src scan line to start of next
*   SrcCx           -   Width of Src Bitmap in pixels
*   SrcCy           -   Height of Src Bitmap in pixels
*   prclSrc         -   Pointer to rectangle of Src extents
*   prclSClip       -   Clip Dest to this rect
*
* Return Value:
*
*   Status
*
\**************************************************************************/

BOOL bStretchDIBDirect(
PDEV*   ppdev,
VOID*   pvDst,
LONG    lDeltaDst,
RECTL*  prclDst,
VOID*   pvSrc,
LONG    lDeltaSrc,
RECTL*  prclSrc,
RECTL*  prclClip)
{
    STR_BLT StrBlt;
    ULONG   XSrcToDstIntFloor;
    ULONG   XSrcToDstFracFloor;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   YSrcToDstIntFloor;
    ULONG   YSrcToDstFracFloor;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    LONG    SrcIntScan;
    LONG    DstDeltaScanEnd;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
    LONG    LeftClipDistance;
    LONG    TopClipDistance;
    BOOL    bStretch;

    union {
        LARGE_INTEGER   large;
        ULONGLONG       li;
    } liInit;

    PFN_DIRSTRETCH      pfnStr;

    //
    // Calculate exclusive start and end points:
    //

    LONG    WidthDst  = prclDst->right  - prclDst->left;
    LONG    HeightDst = prclDst->bottom - prclDst->top;
    LONG    WidthSrc  = prclSrc->right  - prclSrc->left;
    LONG    HeightSrc = prclSrc->bottom - prclSrc->top;

    LONG    XSrcStart = prclSrc->left;
    LONG    XSrcEnd   = prclSrc->right;
    LONG    XDstStart = prclDst->left;
    LONG    XDstEnd   = prclDst->right;
    LONG    YSrcStart = prclSrc->top;
    LONG    YSrcEnd   = prclSrc->bottom;
    LONG    YDstStart = prclDst->top;
    LONG    YDstEnd   = prclDst->bottom;

    //
    // Validate parameters:
    //

    ASSERTDD(pvDst != (VOID*)NULL, "Bad destination bitmap pointer");
    ASSERTDD(pvSrc != (VOID*)NULL, "Bad source bitmap pointer");
    ASSERTDD(prclDst != (RECTL*)NULL, "Bad destination rectangle");
    ASSERTDD(prclSrc != (RECTL*)NULL, "Bad source rectangle");
    ASSERTDD((WidthDst > 0) && (HeightDst > 0) &&
             (WidthSrc > 0) && (HeightSrc > 0),
             "Can't do mirroring or empty rectangles here");
    ASSERTDD((WidthDst  <= STRETCH_MAX_EXTENT) &&
             (HeightDst <= STRETCH_MAX_EXTENT) &&
             (WidthSrc  <= STRETCH_MAX_EXTENT) &&
             (HeightSrc <= STRETCH_MAX_EXTENT), "Stretch exceeds limits");
    ASSERTDD(prclClip != NULL, "Bad clip rectangle");

    //
    // Calculate X Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*WidthSrc)/WidthDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*WidthSrc -1) / WidthDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liWidthSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = WidthSrc - 1;
        liWidthSrc = liInit.li;

        liQuo = liWidthSrc / (ULONGLONG) WidthDst;

        ulXDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulXDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulXDstToSrcFracCeil + 1;

        ulXDstToSrcIntCeil += (ulTemp < ulXDstToSrcFracCeil);
        ulXDstToSrcFracCeil = ulTemp;
    }

    //
    // Calculate Y Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*HeightSrc)/HeightDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*HeightSrc -1) / HeightDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liHeightSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = HeightSrc - 1;
        liHeightSrc = liInit.li;

        liQuo = liHeightSrc / (ULONGLONG) HeightDst;

        ulYDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulYDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulYDstToSrcFracCeil + 1;

        ulYDstToSrcIntCeil += (ulTemp < ulYDstToSrcFracCeil);
        ulYDstToSrcFracCeil = ulTemp;
    }

    //
    // Now clip Dst in X, and/or calc src clipping effect on dst
    //
    // adjust left and right edges if needed, record
    // distance adjusted for fixing the src
    //

    if (XDstStart < prclClip->left)
    {
        XDstStart = prclClip->left;
    }

    if (XDstEnd > prclClip->right)
    {
        XDstEnd = prclClip->right;
    }

    //
    // Check for totally clipped out destination:
    //

    if (XDstEnd <= XDstStart)
    {
        return(TRUE);
    }

    LeftClipDistance = XDstStart - prclDst->left;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulXDstToSrcFracCeil >> 1) | (ulXDstToSrcIntCeil << 31);
        ulTempInt  = (ulXDstToSrcIntCeil >> 1);

        XSrcStart += ulTempInt;
        ulXFracAccumulator = ulTempFrac;

        if (LeftClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulXDstToSrcFracCeil, LeftClipDistance);

            ulTmp = ulXFracAccumulator;
            ulXFracAccumulator += (ULONG) (ullFraction);
            if (ulXFracAccumulator < ulTmp)
                XSrcStart++;

            XSrcStart += (ulXDstToSrcIntCeil * LeftClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Now clip Dst in Y, and/or calc src clipping effect on dst
    //
    // adjust top and bottom edges if needed, record
    // distance adjusted for fixing the src
    //

    if (YDstStart < prclClip->top)
    {
        YDstStart = prclClip->top;
    }

    if (YDstEnd > prclClip->bottom)
    {
        YDstEnd = prclClip->bottom;
    }

    //
    // Check for totally clipped out destination:
    //

    if (YDstEnd <= YDstStart)
    {
        return(TRUE);
    }

    TopClipDistance = YDstStart - prclDst->top;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulYDstToSrcFracCeil >> 1) | (ulYDstToSrcIntCeil << 31);
        ulTempInt  = ulYDstToSrcIntCeil >> 1;

        YSrcStart += (LONG)ulTempInt;
        ulYFracAccumulator = ulTempFrac;

        if (TopClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulYDstToSrcFracCeil, TopClipDistance);

            ulTmp = ulYFracAccumulator;
            ulYFracAccumulator += (ULONG) (ullFraction);
            if (ulYFracAccumulator < ulTmp)
                YSrcStart++;

            YSrcStart += (ulYDstToSrcIntCeil * TopClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Warm up the hardware if doing an expanding stretch in 'y':
    //

    bStretch = (HeightDst > HeightSrc);
    if (bStretch)
    {
        LONG    cjPel = ppdev->cjPel;
        BYTE*   pjBase = ppdev->pjBase;
        LONG    x;

        CP_WAIT(ppdev, pjBase);
        CP_RASTER(ppdev, pjBase, P9000(ppdev) ? P9000_S : P9100_S);

        //
        // Set up the left and right blt edges, since they never change
        // during the StretchBlt
        //

        x = (XDstStart + ppdev->xOffset) * cjPel;
        CP_ABS_X0(ppdev, pjBase, x);
        CP_ABS_X2(ppdev, pjBase, x);

        x = (XDstEnd + ppdev->xOffset) * cjPel - 1;
        CP_ABS_X1(ppdev, pjBase, x);
        CP_ABS_X3(ppdev, pjBase, x);
    }

    //
    // Fill out blt structure, then call format-specific stretch code
    //

    StrBlt.ppdev     = ppdev;
    StrBlt.XDstEnd   = XDstEnd;
    StrBlt.YDstStart = YDstStart;
    StrBlt.YDstCount = YDstEnd - YDstStart;

    if (StrBlt.YDstCount > 0)
    {
        //
        // Caclulate starting scan line address.  Since the inner loop
        // routines are format dependent, they must add XDstStart/XSrcStart
        // to pjDstScan/pjSrcScan to get the actual starting pixel address.
        //

        StrBlt.pjSrcScan           = (BYTE*) pvSrc + (YSrcStart * lDeltaSrc);
        StrBlt.pjDstScan           = (BYTE*) pvDst + (YDstStart * lDeltaDst);

        StrBlt.lDeltaSrc           = lDeltaSrc;
        StrBlt.XSrcStart           = XSrcStart;
        StrBlt.XDstStart           = XDstStart;
        StrBlt.lDeltaDst           = lDeltaDst;
        StrBlt.ulXDstToSrcIntCeil  = ulXDstToSrcIntCeil;
        StrBlt.ulXDstToSrcFracCeil = ulXDstToSrcFracCeil;
        StrBlt.ulYDstToSrcIntCeil  = ulYDstToSrcIntCeil;
        StrBlt.ulYDstToSrcFracCeil = ulYDstToSrcFracCeil;
        StrBlt.ulXFracAccumulator  = ulXFracAccumulator;
        StrBlt.ulYFracAccumulator  = ulYFracAccumulator;

        if (ppdev->iBitmapFormat == BMF_8BPP)
        {
            if ((XDstEnd - XDstStart) < 7)
                pfnStr = vDirectStretch8Narrow;
            else
                pfnStr = vDirectStretch8;
        }
        else if (ppdev->iBitmapFormat == BMF_16BPP)
        {
            pfnStr = vDirectStretch16;
        }
        else
        {
            ASSERTDD(ppdev->iBitmapFormat == BMF_32BPP,
                     "Only handle stretchs at 8, 16 and 32bpp");

            pfnStr = vDirectStretch32;
        }

        (*pfnStr)(&StrBlt);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL DrvStretchBlt
*
\**************************************************************************/

BOOL DrvStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMsk,
ULONG               iMode)
{
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    PDEV*   ppdev;
    OH*     poh;

    // GDI guarantees us that for a StretchBlt the destination surface
    // will always be a device surface, and not a DIB:

    ppdev = (PDEV*) psoDst->dhpdev;

    // It's quicker for GDI to do a StretchBlt when the source surface
    // is not a device-managed surface, because then it can directly
    // read the source bits without having to allocate a temporary
    // buffer and call DrvCopyBits to get a copy that it can use.
    //
    // So if the source is one of our off-screen DFBs, we'll immediately
    // and permanently convert it to a DIB:

    if (psoSrc->iType == STYPE_DEVBITMAP)
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        if (pdsurfSrc->dt == DT_SCREEN)
        {
            if (!pohMoveOffscreenDfbToDib(ppdev, pdsurfSrc->poh))
                return(FALSE);
        }

        ASSERTDD(pdsurfSrc->dt == DT_DIB, "Can only handle DIB DFBs here");

        psoSrc = pdsurfSrc->pso;
    }

    pdsurfDst = (DSURF*) psoDst->dhsurf;
    if (pdsurfDst->dt == DT_DIB)
    {
        // The destination was a device bitmap that we just converted
        // to a DIB:

        psoDst = pdsurfDst->pso;
        goto Punt_It;
    }

    poh             = pdsurfDst->poh;
    psoDst          = ppdev->psoPunt;
    ppdev->xOffset  = poh->x;
    ppdev->yOffset  = poh->y;
    psoDst->pvScan0 = poh->pvScan0;

    // NOTE: The P9000 is allowed down here, too

    {
        RECTL       rclClip;
        RECTL*      prclClip;
        ULONG       cxDst;
        ULONG       cyDst;
        ULONG       cxSrc;
        ULONG       cySrc;
        BOOL        bMore;
        CLIPENUM    ce;
        LONG        c;
        LONG        i;

        if ((psoSrc->iType == STYPE_BITMAP) &&
            (psoMsk == NULL) &&
            ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
            ((psoSrc->iBitmapFormat == ppdev->iBitmapFormat)) &&
            (ppdev->iBitmapFormat != BMF_24BPP))
        {
            cxDst = prclDst->right - prclDst->left;
            cyDst = prclDst->bottom - prclDst->top;
            cxSrc = prclSrc->right - prclSrc->left;
            cySrc = prclSrc->bottom - prclSrc->top;

            // Our 'bStretchDIBDirect' routine requires that the stretch be
            // non-inverting, within a certain size, to have no source
            // clipping, and to have no empty rectangles (the latter is the
            // reason for the '- 1' on the unsigned compare here):

            if (((cxSrc - 1) < STRETCH_MAX_EXTENT)         &&
                ((cySrc - 1) < STRETCH_MAX_EXTENT)         &&
                ((cxDst - 1) < STRETCH_MAX_EXTENT)         &&
                ((cyDst - 1) < STRETCH_MAX_EXTENT)         &&
                (prclSrc->left   >= 0)                     &&
                (prclSrc->top    >= 0)                     &&
                (prclSrc->right  <= psoSrc->sizlBitmap.cx) &&
                (prclSrc->bottom <= psoSrc->sizlBitmap.cy))
            {
                // Our snazzy routine only does COLORONCOLOR.  But for
                // stretching blts, BLACKONWHITE and WHITEONBLACK are also
                // equivalent to COLORONCOLOR:

                if ((iMode == COLORONCOLOR) ||
                    ((iMode < COLORONCOLOR) && (cxSrc <= cxDst) && (cySrc <= cyDst)))
                {
                    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                    {
                        rclClip.left   = LONG_MIN;
                        rclClip.top    = LONG_MIN;
                        rclClip.right  = LONG_MAX;
                        rclClip.bottom = LONG_MAX;
                        prclClip = &rclClip;

                    StretchSingleClipRect:

                        if (bStretchDIBDirect(ppdev,
                                        poh->pvScan0,
                                        ppdev->lDelta,
                                        prclDst,
                                        psoSrc->pvScan0,
                                        psoSrc->lDelta,
                                        prclSrc,
                                        prclClip))
                        {
                            return(TRUE);
                        }
                    }
                    else if (pco->iDComplexity == DC_RECT)
                    {
                        prclClip = &pco->rclBounds;
                        goto StretchSingleClipRect;
                    }
                    else
                    {
                        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                        do {
                            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                            c = cIntersect(prclDst, ce.arcl, ce.c);

                            if (c != 0)
                            {
                                for (i = 0; i < c; i++)
                                {
                                    if (!bStretchDIBDirect(ppdev,
                                                     poh->pvScan0,
                                                     ppdev->lDelta,
                                                     prclDst,
                                                     psoSrc->pvScan0,
                                                     psoSrc->lDelta,
                                                     prclSrc,
                                                     &ce.arcl[i]))
                                    {
                                        goto Punt_It;
                                    }
                                }
                            }

                        } while (bMore);

                        return(TRUE);
                    }
                }
            }
        }
    }

Punt_It:

    return(EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                         prclDst, prclSrc, pptlMsk, iMode));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\strips.c ===
/******************************Module*Header*******************************\
* Module Name: Strips.c
*
* These are the line rendering routines of last resort, and are called
* by 'bLines' when a line is clipped or otherwise cannot be drawn
* directly by the hardware.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vStripSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using radial lines.
*
\**************************************************************************/

VOID vStripSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjBase = ppdev->pjBase;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        CP_METALINE(ppdev, pjBase, x, y);
        x += *pStrips++;
        CP_METALINE(ppdev, pjBase, x - 1, y);
        y += yDir;
        CP_START_QUAD_WAIT(ppdev, pjBase);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vStripSolidVertical
*
* Draws left-to-right y-major near-vertical lines using radial lines.
*
\**************************************************************************/

VOID vStripSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjBase = ppdev->pjBase;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        CP_METALINE(ppdev, pjBase, x, y);
        y += (yDir > 0) ? *pStrips : -*pStrips;
        pStrips++;
        CP_METALINE(ppdev, pjBase, x, y - yDir);
        x++;
        CP_START_QUAD_WAIT(ppdev, pjBase);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vStripSolidDiagonalHorizontal
*
* Draws left-to-right x-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vStripSolidDiagonalHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjBase = ppdev->pjBase;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        CP_METALINE(ppdev, pjBase, x, y);
        x += *pStrips;
        y += (yDir > 0) ? *pStrips : -*pStrips;
        pStrips++;
        CP_METALINE(ppdev, pjBase, x - 1, y - yDir);
        y -= yDir;
        CP_START_QUAD_WAIT(ppdev, pjBase);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vStripSolidDiagonalVertical
*
* Draws left-to-right y-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vStripSolidDiagonalVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjBase = ppdev->pjBase;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        CP_METALINE(ppdev, pjBase, x, y);
        x += *pStrips;
        y += (yDir > 0) ? *pStrips : -*pStrips;
        pStrips++;
        CP_METALINE(ppdev, pjBase, x - 1, y - yDir);
        x--;
        CP_START_QUAD_WAIT(ppdev, pjBase);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vStripStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vStripStyledHorizontal(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjBase;
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    pjBase = ppdev->pjBase;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 90 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going up):

        dy = -1;
    }
    else
    {
        // The minor direction of the line is 270 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going down):

        dy = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x;   // x position of start of first strip
    y       = pstrip->ptlStart.y;   // y position of start of first strip

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        // Short stroke vectors can handle lines that are a maximum of
        // 15 pels long.  When we have to draw a longer consecutive
        // segment than that, we simply break it into 16 pel portions:

        CP_METALINE(ppdev, pjBase, x, y);
        x += cThis;
        CP_METALINE(ppdev, pjBase, x - 1, y);
        CP_START_QUAD_WAIT(ppdev, pjBase);

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vStripStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vStripStyledVertical(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjBase;
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    pjBase = ppdev->pjBase;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 90 (it's a left-to-right y-major line going up):

        dy = -1;
    }
    else
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 270 (it's a left-to-right y-major line going down):

        dy = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x;   // x position of start of first strip
    y       = pstrip->ptlStart.y;   // y position of start of first strip

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        CP_METALINE(ppdev, pjBase, x, y);
        y += (dy > 0) ? cThis : -cThis;
        CP_METALINE(ppdev, pjBase, x, y - dy);
        CP_START_QUAD_WAIT(ppdev, pjBase);

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\dac.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\str.c ===
/******************************Module*Header*******************************\
* Module Name: str.c
*
* Contains some 'C' inner-loop routines for our special-case StretchBlt.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8
*
* Routine Description:
*
*   Stretch blt 8->8
*
* NOTE: This routine doesn't handle cases where the blt stretch starts
*       and ends in the same destination dword!  vDirectStretchNarrow
*       is expected to have been called for that case.
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch8(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    BYTE*   pjDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    BYTE*   pjOldScan;
    BYTE*   pjBase;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    BYTE*   pjDst       = pStrBlt->pjDstScan + xDst;
    LONG    yDst        = pStrBlt->YDstStart;// + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)((ULONG_PTR)pjDst & 0x03);
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)((ULONG_PTR)(pjDst + WidthX) & 0x03);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    ULONG   yInt        = 0;
    LONG    lDstStride  = pStrBlt->lDeltaDst - WidthX;

    pjBase = ppdev->pjBase;

    WidthXAln = WidthX - EndAln - ((- (LONG) StartAln) & 0x03);

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    //
    // loop drawing each scan line
    //
    //
    // at least 7 wide (DST) blt
    //

    do {
        BYTE    jSrc0,jSrc1,jSrc2,jSrc3;
        ULONG   yTmp;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        switch (StartAln) {
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        }

        pjDstEnd  = pjDst + WidthXAln;

        while (pjDst != pjDstEnd)
        {
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc1 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            jSrc2 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc3 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            ulDst = (jSrc3 << 24) | (jSrc2 << 16) | (jSrc1 << 8) | jSrc0;

            *(PULONG)pjDst = ulDst;
            pjDst += 4;
        }

        switch (EndAln) {
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pjDst = (pjDst + lDstStride);
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pjDst = (pjDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            do {
                CP_Y0(ppdev, pjBase, yDst - 1);
                CP_Y1(ppdev, pjBase, yDst - 1);
                CP_Y2(ppdev, pjBase, yDst);
                CP_Y3(ppdev, pjBase, yDst);
                yDst++;
                CP_START_BLT_WAIT(ppdev, pjBase);
            } while (--cyDuplicate != 0);
        }
    } while (yCount != 0);
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch16
*
* Routine Description:
*
*   Stretch blt 16->16
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch16(
STR_BLT* pStrBlt)
{
    BYTE*   pjOldScan;
    USHORT* pusSrc;
    USHORT* pusDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    LONG    cyDuplicate;
    BYTE*   pjBase;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = (pStrBlt->pjSrcScan) + xSrc * 2;
    USHORT* pusDst      = (USHORT*)(pStrBlt->pjDstScan) + xDst;
    LONG    yDst        = pStrBlt->YDstStart;// + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)(((ULONG_PTR)pusDst & 0x02) >> 1);
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)(((ULONG_PTR)(pusDst + WidthX) & 0x02) >> 1);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - 2 * WidthX;
    ULONG   yInt        = 0;

    pjBase = ppdev->pjBase;

    WidthXAln = WidthX - EndAln - StartAln;

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    // Loop stretching each scan line

    do {
        USHORT  usSrc0,usSrc1;
        ULONG   yTmp;

        pusSrc  = (USHORT*) pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        // A single source scan line is being written:

        if (StartAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
            xAccum    = xTmp;
        }

        pusDstEnd  = pusDst + WidthXAln;

        while (pusDst != pusDstEnd)
        {

            usSrc0 = *pusSrc;
            xTmp   = xAccum + xFrac;
            pusSrc = pusSrc + xInt + (xTmp < xAccum);

            usSrc1 = *pusSrc;
            xAccum = xTmp + xFrac;
            pusSrc = pusSrc + xInt + (xAccum < xTmp);

            ulDst = (ULONG)((usSrc1 << 16) | usSrc0);

            *(ULONG*)pusDst = ulDst;
            pusDst+=2;
        }

        if (EndAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pusDst = (USHORT*) ((BYTE*) pusDst + lDstStride);
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pusDst = (USHORT*) ((BYTE*) pusDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            do {
                CP_Y0(ppdev, pjBase, yDst - 1);
                CP_Y1(ppdev, pjBase, yDst - 1);
                CP_Y2(ppdev, pjBase, yDst);
                CP_Y3(ppdev, pjBase, yDst);
                yDst++;
                CP_START_BLT_WAIT(ppdev, pjBase);
            } while (--cyDuplicate != 0);
        }
    } while (yCount != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\thunk.c ===
/******************************Module*Header*******************************\
* Module Name: thunk.c
*
* This module exists solely for testing, to make it is easy to instrument
* all the driver's Drv calls.
*
* Note that most of this stuff will only be compiled in a checked (debug)
* build.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

////////////////////////////////////////////////////////////////////////////

#if DBG

// This entire module is only enabled for Checked builds

#define SYNCH_ENTER()   0   // do nothing
#define SYNCH_LEAVE()   0   // do nothing

////////////////////////////////////////////////////////////////////////////

BOOL gbNull = FALSE;    // Set to TRUE with the debugger to test the speed
                        //   of NT with an inifinitely fast display driver
                        //   (actually, almost infinitely fast since we're
                        //   not hooking all the calls we could be)


DHPDEV DbgEnablePDEV(
DEVMODEW*   pDevmode,
PWSTR       pwszLogAddress,
ULONG       cPatterns,
HSURF*      ahsurfPatterns,
ULONG       cjGdiInfo,
ULONG*      pGdiInfo,
ULONG       cjDevInfo,
DEVINFO*    pDevInfo,
HDEV        hdev,
PWSTR       pwszDeviceName,
HANDLE      hDriver)
{
    DHPDEV bRet;

    SYNCH_ENTER();
    DISPDBG((5, "DrvEnablePDEV"));

    bRet = DrvEnablePDEV(
                pDevmode,
                pwszLogAddress,
                cPatterns,
                ahsurfPatterns,
                cjGdiInfo,
                pGdiInfo,
                cjDevInfo,
                pDevInfo,
                hdev,
                pwszDeviceName,
                hDriver);

    DISPDBG((6, "DrvEnablePDEV done"));
    SYNCH_LEAVE();

    return(bRet);
}

VOID DbgCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvCompletePDEV"));

    DrvCompletePDEV(
                dhpdev,
                hdev);

    DISPDBG((6, "DrvCompletePDEV done"));
    SYNCH_LEAVE();
}

VOID DbgDisablePDEV(DHPDEV dhpdev)
{
    PDEV* ppdev;
    BOOL bNeedSync;
    ppdev = (PDEV*) dhpdev;

    bNeedSync = ppdev->bEnabled;

    //
    // If a PDEV has not been disabled by DrvAssertMode
    // then this call is synchronized as access to the
    // hardware may occur.  If the PDEV has been disabled
    // by DrvAssertMode then access to the hardware is not
    // allowed (all hardware access needs to be done in the
    // DrvAssertMode handling) and synchronization is not done
    // as drawing may be occurring in a different PDEV.
    //

    if (bNeedSync)
    {
        SYNCH_ENTER();
    }

    DISPDBG((5, "DrvDisable"));

    DrvDisablePDEV(dhpdev);

    DISPDBG((6, "DrvDisable done"));

    if (bNeedSync)
    {
        SYNCH_LEAVE();
    }
}

HSURF DbgEnableSurface(DHPDEV dhpdev)
{
    HSURF h;

    SYNCH_ENTER();
    DISPDBG((5, "DrvEnableSurface"));

    h = DrvEnableSurface(dhpdev);

    DISPDBG((6, "DrvEnableSurface done"));
    SYNCH_LEAVE();

    return(h);
}

VOID DbgDisableSurface(DHPDEV dhpdev)
{
    PDEV* ppdev;
    BOOL bNeedSync;
    ppdev = (PDEV*) dhpdev;

    bNeedSync = ppdev->bEnabled;

    //
    // If a PDEV has not been disabled by DrvAssertMode
    // then this call is synchronized as access to the
    // hardware may occur.  If the PDEV has been disabled
    // by DrvAssertMode then access to the hardware is not
    // allowed (all hardware access needs to be done in the
    // DrvAssertMode handling) and synchronization is not done
    // as drawing may be occurring in a different PDEV.
    //

    if (bNeedSync)
    {
        SYNCH_ENTER();
    }

    DISPDBG((5, "DrvDisableSurface"));

    DrvDisableSurface(dhpdev);

    DISPDBG((6, "DrvDisableSurface done"));

    if (bNeedSync)
    {
        SYNCH_LEAVE();
    }
}

BOOL  DbgAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    BOOL b;

    SYNCH_ENTER();
    DISPDBG((5, "DrvAssertMode"));

    b = DrvAssertMode(dhpdev,bEnable);

    DISPDBG((6, "DrvAssertMode done"));
    SYNCH_LEAVE();

    return (b);
}

//
// We do not SYNCH_ENTER since we have not initalized the driver.
// We just want to get the list of modes from the miniport.
//

ULONG DbgGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW* pdm)
{
    ULONG u;

    DISPDBG((5, "DrvGetModes"));

    u = DrvGetModes(
                hDriver,
                cjSize,
                pdm);

    DISPDBG((6, "DrvGetModes done"));

    return(u);
}

VOID DbgMovePointer(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl)
{
    if (gbNull)
        return;

    // Note: Because we set GCAPS_ASYNCMOVE, we don't want to do a
    //       SYNCH_ENTER/LEAVE here.

    DISPDBG((5, "DrvMovePointer"));

    DrvMovePointer(pso,x,y,prcl);

    DISPDBG((6, "DrvMovePointer done"));
}

ULONG DbgSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl)
{
    ULONG u;

    if (gbNull)
        return(SPS_ACCEPT_NOEXCLUDE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvSetPointerShape"));

    u = DrvSetPointerShape(
                pso,
                psoMask,
                psoColor,
                pxlo,
                xHot,
                yHot,
                x,
                y,
                prcl,
                fl);

    DISPDBG((6, "DrvSetPointerShape done"));
    SYNCH_LEAVE();

    return(u);
}

ULONG DbgDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    ULONG u;

    if (gbNull)
        return(DCR_DRIVER);

    //
    // No need to Synchronize Dither color.
    //

    DISPDBG((5, "DrvDitherColor"));

    u = DrvDitherColor(
                dhpdev,
                iMode,
                rgb,
                pul);

    DISPDBG((6, "DrvDitherColor done"));

    return(u);
}

BOOL DbgSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvSetPalette"));

    u = DrvSetPalette(
                dhpdev,
                ppalo,
                fl,
                iStart,
                cColors);

    DISPDBG((6, "DrvSetPalette done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvCopyBits"));

    u = DrvCopyBits(
                psoDst,
                psoSrc,
                pco,
                pxlo,
                prclDst,
                pptlSrc);

    DISPDBG((6, "DrvCopyBits done"));
    SYNCH_LEAVE();

    return(u);
}


BOOL DbgBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvBitBlt"));

    u = DrvBitBlt(
                psoDst,
                psoSrc,
                psoMask,
                pco,
                pxlo,
                prclDst,
                pptlSrc,
                pptlMask,
                pbo,
                pptlBrush,
                rop4);

    DISPDBG((6, "DrvBitBlt done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvTextOut"));

    u = DrvTextOut(
                pso,
                pstro,
                pfo,
                pco,
                prclExtra,
                prclOpaque,
                pboFore,
                pboOpaque,
                pptlOrg,
                mix);

    DISPDBG((6, "DrvTextOut done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* plineattrs,
MIX        mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvStrokePath"));

    u = DrvStrokePath(
                pso,
                ppo,
                pco,
                pxo,
                pbo,
                pptlBrushOrg,
                plineattrs,
                mix);

    DISPDBG((6, "DrvStrokePath done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix,
FLONG     flOptions)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvFillPath"));

    u = DrvFillPath(pso,
                ppo,
                pco,
                pbo,
                pptlBrushOrg,
                mix,
                flOptions);

    DISPDBG((6, "DrvFillPath done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvPaint"));

    u = DrvPaint(
                pso,
                pco,
                pbo,
                pptlBrushOrg,
                mix);

    DISPDBG((6, "DrvPaint done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    BOOL u;

    // Note: The only time DrvRealizeBrush is called by GDI is when we've
    //       called BRUSHOBJ_pvGetRbrush in the middle of a DrvBitBlt
    //       call, and GDI had to call us back.  Since we're still in the
    //       middle of DrvBitBlt, synchronization has already taken care of.
    //       For the same reason, this will never be called when 'gbNull'
    //       is TRUE, so it doesn't even make sense to check gbNull...

    DISPDBG((5, "DrvRealizeBrush"));

    u = DrvRealizeBrush(
                pbo,
                psoTarget,
                psoPattern,
                psoMask,
                pxlo,
                iHatch);

    DISPDBG((6, "DrvRealizeBrush done"));

    return(u);
}

HBITMAP DbgCreateDeviceBitmap(DHPDEV dhpdev, SIZEL sizl, ULONG iFormat)
{
    HBITMAP hbm;

    if (gbNull)                     // I would pretend to have created a
        return(FALSE);              //   bitmap when gbNull is set, by we
                                    //   would need some code to back this
                                    //   up so that the system wouldn't
                                    //   crash...

    SYNCH_ENTER();
    DISPDBG((5, "DrvCreateDeviceBitmap"));

    hbm = DrvCreateDeviceBitmap(dhpdev, sizl, iFormat);

    DISPDBG((6, "DrvCreateDeviceBitmap done"));
    SYNCH_LEAVE();

    return(hbm);
}

VOID DbgDeleteDeviceBitmap(DHSURF dhsurf)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDeleteDeviceBitmap"));

    DrvDeleteDeviceBitmap(dhsurf);

    DISPDBG((6, "DrvDeleteDeviceBitmap done"));
    SYNCH_LEAVE();
}

VOID DbgDestroyFont(FONTOBJ* pfo)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDestroyFont"));

    DrvDestroyFont(pfo);

    DISPDBG((6, "DrvDestroyFont done"));
    SYNCH_LEAVE();
}

BOOL DbgStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMask,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMask,
ULONG               iMode)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvStretchBlt"));

    {
        // Our DrvStretchBlt routine calls back to EngStretchBlt, which
        // calls back to our DrvCopyBits routine -- so we have to be
        // re-entrant for synchronization...

        SYNCH_LEAVE();
    }

    u = DrvStretchBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlHTOrg,
                      prclDst, prclSrc, pptlMask, iMode);

    {
        SYNCH_ENTER();
    }

    DISPDBG((6, "DrvStretchBlt done"));
    SYNCH_LEAVE();

    return(u);
}

VOID DbgSynchronize(
DHPDEV  dhpdev,
RECTL*  prcl)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvSynchronize"));

    DrvSynchronize(dhpdev, prcl);

    DISPDBG((6, "DrvSynchronize done"));
    SYNCH_LEAVE();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\disp\textout.c ===
/******************************Module*Header*******************************\
* Module Name: textout.c
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

//////////////////////////////////////////////////////////////////////////

RECTL grclMax = { 0, 0, 0x10000, 0x10000 };
                                // Maximal clip rectangle for trivial clipping

#define GLYPH_CACHE_CX      32  // Maximal width of glyphs that we'll consider
                                //   caching

#define GLYPH_CACHE_CY      32  // Maximum height of glyphs that we'll consider
                                //   caching

#define GLYPH_ALLOC_SIZE    4000
                                // Do all cached glyph memory allocations
                                //   in 4k chunks

#define HGLYPH_SENTINEL     ((ULONG) -1)
                                // GDI will never give us a glyph with a
                                //   handle value of 0xffffffff, so we can
                                //   use this as a sentinel for the end of
                                //   our linked lists

#define GLYPH_HASH_SIZE     256

#define GLYPH_HASH_FUNC(x)  ((x) & (GLYPH_HASH_SIZE - 1))

typedef struct _CACHEDGLYPH CACHEDGLYPH;
typedef struct _CACHEDGLYPH
{
    CACHEDGLYPH*    pcgNext;    // Points to next glyph that was assigned
                                //   to the same hash table bucket
    HGLYPH          hg;         // Handles in the bucket-list are kept in
                                //   increasing order
    POINTL          ptlOrigin;  // Origin of glyph bits
    LONG            xyWidth;    // Width of the glyph in the high word
    ULONG*          pdPixel1Rem;// Points to accelerator register used for
                                //   writing last partial dword of the glyph
    LONG            cd;         // Number of whole dwords in glyph
    ULONG           ad[1];      // Start of glyph bits
} CACHEDGLYPH;  /* cg, pcg */

typedef struct _GLYPHALLOC GLYPHALLOC;
typedef struct _GLYPHALLOC
{
    GLYPHALLOC*     pgaNext;    // Points to next glyph structure that
                                //   was allocated for this font
    CACHEDGLYPH     acg[1];     // This array is a bit misleading, because
                                //   the CACHEDGLYPH structures are actually
                                //   variable sized
} GLYPHAALLOC;  /* ga, pga */

typedef struct _CACHEDFONT
{
    GLYPHALLOC*     pgaChain;   // Points to start of allocated memory list
    CACHEDGLYPH*    pcgNew;     // Points to where in the current glyph
                                //   allocation structure a new glyph should
                                //   be placed
    LONG            cjAlloc;    // Bytes remaining in current glyph allocation
                                //   structure
    CACHEDGLYPH     cgSentinel; // Sentinel entry of the end of our bucket
                                //   lists, with a handle of HGLYPH_SENTINEL
    CACHEDGLYPH*    apcg[GLYPH_HASH_SIZE];
                                // Hash table for glyphs

} CACHEDFONT;   /* cf, pcf */

/******************************Public*Routine******************************\
* CACHEDFONT* pcfAllocateCachedFont()
*
* Initializes our font data structure.
*
\**************************************************************************/

CACHEDFONT* pcfAllocateCachedFont(
PDEV*   ppdev)
{
    CACHEDFONT*     pcf;
    CACHEDGLYPH**   ppcg;
    LONG            i;

    pcf = EngAllocMem(FL_ZERO_MEMORY, sizeof(CACHEDFONT), ALLOC_TAG);

    if (pcf != NULL)
    {
        // Note that we rely on FL_ZERO_MEMORY to zero 'pgaChain' and
        // 'cjAlloc':

        pcf->cgSentinel.hg = HGLYPH_SENTINEL;

        // Initialize the hash table entries to all point to our sentinel:

        for (ppcg = &pcf->apcg[0], i = GLYPH_HASH_SIZE; i != 0; i--, ppcg++)
        {
            *ppcg = &pcf->cgSentinel;
        }
    }

    return(pcf);
}

/******************************Public*Routine******************************\
* VOID vFreeCachedFont()
*
* Frees all memory associated with the cache we kept for this font.
*
\**************************************************************************/

VOID vFreeCachedFont(
CACHEDFONT* pcf)
{
    GLYPHALLOC* pga;
    GLYPHALLOC* pgaNext;

    pga = pcf->pgaChain;
    while (pga != NULL)
    {
        pgaNext = pga->pgaNext;
        EngFreeMem(pga);
        pga = pgaNext;
    }

    EngFreeMem(pcf);
}

/******************************Public*Routine******************************\
* CACHEDGLYPH* pcgNew()
*
* Caches a new glyph.
*
\**************************************************************************/

CACHEDGLYPH* pcgNew(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp)
{
    GLYPHBITS*      pgb;
    GLYPHALLOC*     pga;
    CACHEDGLYPH*    pcg;
    LONG            cjCachedGlyph;
    HGLYPH          hg;
    LONG            cyGlyph;
    LONG            cxGlyph;
    POINTL          ptlOrigin;
    LONG            cjSrcWidth;
    BYTE            jSrc;
    BYTE*           pjSrc;
    BYTE*           pjDst;
    LONG            cAlign;
    LONG            i;
    LONG            j;
    LONG            cTotal;
    LONG            cRem;
    LONG            cd;
    LONG            iHash;
    CACHEDGLYPH*    pcgFind;

    // First, calculate the amount of storage we'll need for this glyph:

    pgb = pgp->pgdf->pgb;

    cjCachedGlyph = sizeof(CACHEDGLYPH)
            + ((pgb->sizlBitmap.cx * pgb->sizlBitmap.cy + 7) >> 3);

    // Reserve an extra byte at the end for temporary usage by our pack
    // routine:

    cjCachedGlyph++;

    // We need to dword align it too:

    cjCachedGlyph = (cjCachedGlyph + 3) & ~3L;

    if (cjCachedGlyph > pcf->cjAlloc)
    {
        // Have to allocate a new glyph allocation structure:

        pga = EngAllocMem(FL_ZERO_MEMORY, GLYPH_ALLOC_SIZE, ALLOC_TAG);
        if (pga == NULL)
        {
            // It's safe to return at this time because we haven't
            // fatally altered any of our data structures:

            return(NULL);
        }

        // Add this allocation to the front of the allocation linked list,
        // so that we can free it later:

        pga->pgaNext  = pcf->pgaChain;
        pcf->pgaChain = pga;

        // Now we've got a chunk of memory where we can store our cached
        // glyphs:

        pcf->pcgNew  = &pga->acg[0];
        pcf->cjAlloc = GLYPH_ALLOC_SIZE - (sizeof(*pga) - sizeof(pga->acg[0]));

        // It would be bad if we let in any glyphs that would be bigger
        // than our basic allocation size:

        ASSERTDD(cjCachedGlyph <= GLYPH_ALLOC_SIZE, "Woah, this is one big glyph!");
    }

    pcg = pcf->pcgNew;

    // We only need to ensure 'dword' alignment of the next structure:

    pcf->pcgNew   = (CACHEDGLYPH*) ((BYTE*) pcg + cjCachedGlyph);
    pcf->cjAlloc -= cjCachedGlyph;

    ASSERTDD((((ULONG_PTR) pcf->pcgNew) & 3) == 0, "pcgNew not aligned");
    ASSERTDD((BYTE*) pcf->pcgNew <= (BYTE*) pcf->pgaChain + GLYPH_ALLOC_SIZE,
             "Overrunning end of buffer");

    ///////////////////////////////////////////////////////////////
    // Pack the glyph:

    cyGlyph    = pgb->sizlBitmap.cy;
    cxGlyph    = pgb->sizlBitmap.cx;
    ptlOrigin  = pgb->ptlOrigin;

    cjSrcWidth = (cxGlyph + 7) >> 3;
    cRem       = ((cxGlyph - 1) & 7) + 1;   // 0 -> 8
    cAlign     = 0;

    pjSrc  =         pgb->aj;
    pjDst  = (BYTE*) pcg->ad;
    *pjDst = 0;                 // Have to zero very first byte

    i = cyGlyph;
    do {
        j = cjSrcWidth;
        do {
            jSrc = *pjSrc;

            *(pjDst) |= (jSrc >> (cAlign));

            // Note that we may modify a byte past the end of our
            // destination buffer, which is why we reserved an
            // extra byte:

            *(pjDst + 1) = (jSrc << (8 - cAlign));

            pjSrc++;
            pjDst++;

        } while (--j != 0);

        pjDst--;
        cAlign += cRem;
        if (cAlign >= 8)
        {
            cAlign -= 8;
            pjDst++;
        }

    } while (--i != 0);

    ASSERTDD(pjDst <= (BYTE*) pcf->pcgNew, "Overran end of glyph");

    ///////////////////////////////////////////////////////////////
    // Initialize the glyph fields:

    hg = pgp->hg;

    pcg->hg          = hg;
    pcg->ptlOrigin   = ptlOrigin;
    pcg->xyWidth     = cxGlyph << 16;

    cTotal = cxGlyph * cyGlyph;
    cd     = (cTotal >> 5);
    cRem   = (cTotal & 31) - 1;
    if (cRem < 0)
    {
        cd--;
        cRem = 31;

        ASSERTDD(cd >= 0, "Must leave at least one pixel left in glyph");
    }

    pcg->cd = cd;
    pcg->pdPixel1Rem
            = (ULONG*) CP_PIXEL1_REM_REGISTER(ppdev, ppdev->pjBase, cRem);

    ///////////////////////////////////////////////////////////////
    // Insert the glyph, in-order, into the list hanging off our hash
    // bucket:

    iHash   = GLYPH_HASH_FUNC(hg);
    pcgFind = pcf->apcg[iHash];

    if (pcgFind->hg > hg)
    {
        pcf->apcg[iHash] = pcg;
        pcg->pcgNext     = pcgFind;
    }
    else
    {
        // The sentinel will ensure that we never fall off the end of
        // this list:

        while (pcgFind->pcgNext->hg < hg)
            pcgFind = pcgFind->pcgNext;

        // 'pcgFind' now points to the entry to the entry after which
        // we want to insert our new node:

        pcg->pcgNext     = pcgFind->pcgNext;
        pcgFind->pcgNext = pcg;
    }

    return(pcg);
}

/******************************Public*Routine******************************\
* BOOL bCachedProportionalText
*
* Draws proportionally spaced glyphs via glyph caching.
*
\**************************************************************************/

BOOL bCachedProportionalText(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph)
{
    BYTE*           pjBase;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            xy;
    ULONG*          pdPixel1Rem;
    LONG            i;

    pjBase = ppdev->pjBase;

    CP_WOFFSET(ppdev, pjBase, ppdev->xOffset, ppdev->yOffset);

    // Wait for the opaquing rectangle to be finished drawing, so that
    // we don't hold the bus for a long time on our first write to
    // pixel1...

    CP_WAIT(ppdev, pjBase);

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg)
            pcg = pcg->pcgNext;

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
            {
                CP_WOFFSET(ppdev, pjBase, 0, 0);
                return(FALSE);
            }
        }

        // The glyph's origin y-coordinate may often be negative, so we
        // can't compute this as follows:
        //
        //    xy = (pgp->ptl.x << 16) | pgp->ptl.y;
        //    xy += pcg->xyOrigin;

        xy = ((pgp->ptl.x + pcg->ptlOrigin.x) << 16) |
              (pgp->ptl.y + pcg->ptlOrigin.y);

        ASSERTDD((pgp->ptl.y + pcg->ptlOrigin.y) >= 0,
                 "Can't have negative 'y' coordinates here");

        CP_WOFF_PACKED_XY0(ppdev, pjBase, xy);
        CP_WOFF_PACKED_XY1(ppdev, pjBase, xy);
        CP_WOFF_PACKED_XY2(ppdev, pjBase, xy + pcg->xyWidth);

        CP_START_PIXEL1(ppdev, pjBase);

        pdPixel1Rem = pcg->pdPixel1Rem;

        for (i = pcg->cd; i != 0; i--)
        {
            CP_PIXEL1(ppdev, pjBase, pcg->ad[0]);

            // Note that we didn't set 'pdSrc = &pcg->ad[0]' and
            // use that instead because by using and incrementing
            // 'pcg' directly, we avoid an extra 'lea' instruction:

            pcg = (CACHEDGLYPH*) ((ULONG*) pcg + 1);
        }

        CP_PIXEL1_VIA_REGISTER(ppdev, pdPixel1Rem, pcg->ad[0]);

        CP_END_PIXEL1(ppdev, pjBase);
    } while (pgp++, --cGlyph != 0);

    // I'm not sure why we have to reset the window offset when we're
    // done using it, but if we don't we get clipping problems on the
    // P9100.  I suspect that the manual lies when it says that the
    // window offset register has no effect on clipping:

    CP_WOFFSET(ppdev, pjBase, 0, 0);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bCachedFixedText
*
* Draws fixed spaced glyphs via glyph caching.
*
\**************************************************************************/

BOOL bCachedFixedText(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph,
ULONG       ulCharInc)
{
    BYTE*           pjBase;
    LONG            xGlyph;
    LONG            yGlyph;
    LONG            xyGlyph;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    ULONG*          pdPixel1Rem;
    LONG            i;

    pjBase = ppdev->pjBase;

    // Convert to absolute coordinates:

    xGlyph = pgp->ptl.x + ppdev->xOffset;
    yGlyph = pgp->ptl.y + ppdev->yOffset;

    // Wait for the opaquing rectangle to be finished drawing, so that
    // we don't hold the bus for a long time on our first write to
    // pixel1...

    CP_WAIT(ppdev, pjBase);

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg)
            pcg = pcg->pcgNext;

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);
        }

        xyGlyph = PACKXY(xGlyph + pcg->ptlOrigin.x,
                         yGlyph + pcg->ptlOrigin.y);
        xGlyph += ulCharInc;

        CP_ABS_PACKED_XY0(ppdev, pjBase, xyGlyph);
        CP_ABS_PACKED_XY1(ppdev, pjBase, xyGlyph);
        CP_ABS_PACKED_XY2(ppdev, pjBase, xyGlyph + pcg->xyWidth);

        CP_START_PIXEL1(ppdev, pjBase);

        pdPixel1Rem = pcg->pdPixel1Rem;

        for (i = pcg->cd; i != 0; i--)
        {
            CP_PIXEL1(ppdev, pjBase, pcg->ad[0]);

            // Note that we didn't set 'pdSrc = &pcg->ad[0]' and
            // use that instead because by using and incrementing
            // 'pcg' directly, we avoid an extra 'lea' instruction:

            pcg = (CACHEDGLYPH*) ((ULONG*) pcg + 1);
        }

        CP_PIXEL1_VIA_REGISTER(ppdev, pdPixel1Rem, pcg->ad[0]);

        CP_END_PIXEL1(ppdev, pjBase);
    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bCachedClippedText
*
* Draws clipped text via glyph caching.
*
\**************************************************************************/

BOOL bCachedClippedText(
PDEV*       ppdev,
CACHEDFONT* pcf,
STROBJ*     pstro,
CLIPOBJ*    pco)
{
    BYTE*           pjBase;
    BOOL            bRet;
    BOOL            bMoreGlyphs;
    ULONG           cGlyphOriginal;
    ULONG           cGlyph;
    BOOL            bClippingSet;
    GLYPHPOS*       pgpOriginal;
    GLYPHPOS*       pgp;
    GLYPHBITS*      pgb;
    POINTL          ptlOrigin;
    BOOL            bMore;
    CLIPENUM        ce;
    RECTL*          prclClip;
    ULONG           ulCharInc;
    LONG            cxGlyph;
    LONG            cyGlyph;
    ULONG*          pulGlyph;
    LONG            i;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    ULONG*          pdPixel1Rem;
    LONG            xyOrigin;

    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
             "Don't expect trivial clipping in this function");

    bRet      = TRUE;
    pjBase    = ppdev->pjBase;
    ulCharInc = pstro->ulCharInc;

    CP_WOFFSET(ppdev, pjBase, ppdev->xOffset, ppdev->yOffset);

    do {
      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        if (pco->iDComplexity == DC_RECT)
        {
            // We could call 'cEnumStart' and 'bEnum' when the clipping is
            // DC_RECT, but the last time I checked, those two calls took
            // more than 150 instructions to go through GDI.  Since
            // 'rclBounds' already contains the DC_RECT clip rectangle,
            // and since it's such a common case, we'll special case it:

            bMore    = FALSE;
            ce.c     = 1;
            prclClip = &pco->rclBounds;

            goto SingleRectangle;
        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            // We don't always simply set the clipping rectangle here
            // because it may actually end up that no text intersects
            // this clip rectangle, so it would be for naught.  This
            // actually happens a lot when using NT's analog clock set
            // to always-on-top, with a round shape:

            bClippingSet = FALSE;

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;
            pgb    = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              cxGlyph  = pgb->sizlBitmap.cx;
              cyGlyph  = pgb->sizlBitmap.cy;
              pulGlyph = (ULONG*) pgb->aj;

              // Do trivial rejection:

              if ((prclClip->right  > ptlOrigin.x) &&
                  (prclClip->bottom > ptlOrigin.y) &&
                  (prclClip->left   < ptlOrigin.x + cxGlyph) &&
                  (prclClip->top    < ptlOrigin.y + cyGlyph))
              {
                // Lazily set the hardware clipping:

                if (!bClippingSet)
                {
                  bClippingSet = TRUE;

                  CP_WAIT(ppdev, pjBase);
                  CP_WMIN(ppdev, pjBase, prclClip->left, prclClip->top);
                  CP_WMAX(ppdev, pjBase, prclClip->right - 1, prclClip->bottom - 1);
                }

                hg  = pgp->hg;
                pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

                while (pcg->hg < hg)
                  pcg = pcg->pcgNext;

                if (pcg->hg > hg)
                {
                  // This will hopefully not be the common case (that is,
                  // we will have a high cache hit rate), so if I were
                  // writing this in Asm I would have this out-of-line
                  // to avoid the jump around for the common case.
                  // But the Pentium has branch prediction, so what the
                  // heck.

                  pcg = pcgNew(ppdev, pcf, pgp);
                  if (pcg == NULL)
                  {
                    bRet = FALSE;
                    goto AllDone;
                  }
                }

                // Note that 'ptlOrigin.y' may be negative:

                xyOrigin = PACKXY(ptlOrigin.x, ptlOrigin.y);
                CP_WOFF_PACKED_XY0(ppdev, pjBase, xyOrigin);
                CP_WOFF_PACKED_XY1(ppdev, pjBase, xyOrigin);
                CP_WOFF_PACKED_XY2(ppdev, pjBase, xyOrigin + pcg->xyWidth);

                CP_START_PIXEL1(ppdev, pjBase);

                pdPixel1Rem = pcg->pdPixel1Rem;

                for (i = pcg->cd; i != 0; i--)
                {
                    CP_PIXEL1(ppdev, pjBase, pcg->ad[0]);

                    // Note that we didn't set 'pdSrc = &pcg->ad[0]' and
                    // use that instead because by using and incrementing
                    // 'pcg' directly, we avoid an extra 'lea' instruction:

                    pcg = (CACHEDGLYPH*) ((ULONG*) pcg + 1);
                }

                CP_PIXEL1_VIA_REGISTER(ppdev, pdPixel1Rem, pcg->ad[0]);

                CP_END_PIXEL1(ppdev, pjBase);
              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;

              if (ulCharInc == 0)
              {
                pgb         = pgp->pgdf->pgb;
                ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
              }
              else
              {
                ptlOrigin.x += ulCharInc;
              }
            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

AllDone:

    CP_WOFFSET(ppdev, pjBase, 0, 0);
    CP_WAIT(ppdev, pjBase);
    CP_ABS_WMIN(ppdev, pjBase, 0, 0);
    CP_ABS_WMAX(ppdev, pjBase, MAX_COORD, MAX_COORD);

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID vClipSolid
*
* Fills the specified rectangles with the specified colour, honouring
* the requested clipping.  No more than four rectangles should be passed in.
* Intended for drawing the areas of the opaquing rectangle that extend
* beyond the text box.  The rectangles must be in left to right, top to
* bottom order.  Assumes there is at least one rectangle in the list.
*
\**************************************************************************/

VOID vClipSolid(
PDEV*       ppdev,
LONG        crcl,
RECTL*      prcl,
ULONG       iColor,
CLIPOBJ*    pco)
{
    BOOL            bMore;              // Flag for clip enumeration
    CLIPENUM        ce;                 // Clip enumeration object
    ULONG           i;
    ULONG           j;
    RECTL           arclTmp[4];
    ULONG           crclTmp;
    RECTL*          prclTmp;
    RECTL*          prclClipTmp;
    LONG            iLastBottom;
    RECTL*          prclClip;
    RBRUSH_COLOR    rbc;

    ASSERTDD((crcl > 0) && (crcl <= 4), "Expected 1 to 4 rectangles");
    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
                       "Expected a non-null clip object");

    rbc.iSolidColor = iColor;
    if (pco->iDComplexity == DC_RECT)
    {
        crcl = cIntersect(&pco->rclBounds, prcl, crcl);
        if (crcl != 0)
        {
            (ppdev->pfnFillSolid)(ppdev, crcl, prcl, 0xf0f0, rbc, NULL);
        }
    }
    else // iDComplexity == DC_COMPLEX
    {
        // Bottom of last rectangle to fill

        iLastBottom = prcl[crcl - 1].bottom;

        // Initialize the clip rectangle enumeration to right-down so we can
        // take advantage of the rectangle list being right-down:

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

        // Scan through all the clip rectangles, looking for intersects
        // of fill areas with region rectangles:

        do {
            // Get a batch of region rectangles:

            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*)&ce);

            // Clip the rect list to each region rect:

            for (j = ce.c, prclClip = ce.arcl; j-- > 0; prclClip++)
            {
                // Since the rectangles and the region enumeration are both
                // right-down, we can zip through the region until we reach
                // the first fill rect, and are done when we've passed the
                // last fill rect.

                if (prclClip->top >= iLastBottom)
                {
                    // Past last fill rectangle; nothing left to do:

                    return;
                }

                // Do intersection tests only if we've reached the top of
                // the first rectangle to fill:

                if (prclClip->bottom > prcl->top)
                {
                    // We've reached the top Y scan of the first rect, so
                    // it's worth bothering checking for intersection.

                    // Generate a list of the rects clipped to this region
                    // rect:

                    prclTmp     = prcl;
                    prclClipTmp = arclTmp;

                    for (i = crcl, crclTmp = 0; i-- != 0; prclTmp++)
                    {
                        // Intersect fill and clip rectangles

                        if (bIntersect(prclTmp, prclClip, prclClipTmp))
                        {
                            // Add to list if anything's left to draw:

                            crclTmp++;
                            prclClipTmp++;
                        }
                    }

                    // Draw the clipped rects

                    if (crclTmp != 0)
                    {
                        (ppdev->pfnFillSolid)(ppdev, crclTmp, &arclTmp[0],
                                              0xf0f0, rbc, NULL);
                    }
                }
            }
        } while (bMore);
    }
}

/******************************Public*Routine******************************\
* VOID vGeneralText
*
\**************************************************************************/

VOID vGeneralText(
PDEV*     ppdev,
STROBJ*   pstro,
CLIPOBJ*  pco)
{
    BYTE*       pjBase;
    BYTE        iDComplexity;
    BOOL        bMoreGlyphs;
    ULONG       cGlyphOriginal;
    ULONG       cGlyph;
    GLYPHPOS*   pgpOriginal;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL*      prclClip;
    ULONG       ulCharInc;
    LONG        cxGlyph;
    LONG        cyGlyph;
    LONG        xBias;
    LONG        cx;
    LONG        cy;
    ULONG*      pulGlyph;
    LONG        cxXfer;
    LONG        cBits;
    LONG        xLeft;
    LONG        yTop;
    LONG        xRight;
    LONG        yBottom;
    LONG        lDelta;
    LONG        cj;
    LONG        i;
    BYTE*       pjGlyph;

    pjBase       = ppdev->pjBase;
    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    do {
      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        ulCharInc = pstro->ulCharInc;

        if (iDComplexity != DC_COMPLEX)
        {
            // We could call 'cEnumStart' and 'bEnum' when the clipping is
            // DC_RECT, but the last time I checked, those two calls took
            // more than 150 instructions to go through GDI.  Since
            // 'rclBounds' already contains the DC_RECT clip rectangle,
            // and since it's such a common case, we'll special case it:

            bMore = FALSE;
            ce.c  = 1;

            if (iDComplexity == DC_TRIVIAL)
                prclClip = &grclMax;
            else
                prclClip = &pco->rclBounds;

            goto SingleRectangle;
        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;
            pgb    = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              cxGlyph  = pgb->sizlBitmap.cx;
              cyGlyph  = pgb->sizlBitmap.cy;
              pulGlyph = (ULONG*) pgb->aj;

              if ((prclClip->left   <= ptlOrigin.x) &&
                  (prclClip->top    <= ptlOrigin.y) &&
                  (prclClip->right  >= ptlOrigin.x + cxGlyph) &&
                  (prclClip->bottom >= ptlOrigin.y + cyGlyph))
              {
                //-----------------------------------------------------
                // Unclipped glyph

                cxXfer   = (cxGlyph + 7) & ~7;
                cBits    = (cyGlyph * cxXfer);

                CP_X0(ppdev,  pjBase, ptlOrigin.x);
                CP_XY1(ppdev, pjBase, ptlOrigin.x, ptlOrigin.y);
                CP_X2(ppdev,  pjBase, ptlOrigin.x + cxXfer);

                CP_WAIT(ppdev, pjBase);
                CP_WRIGHT(ppdev, pjBase, ptlOrigin.x + cxGlyph - 1);
                CP_START_PIXEL1(ppdev, pjBase);

                while (TRUE)
                {
                  cBits -= 32;
                  if (cBits <= 0)
                    break;

                  CP_PIXEL1(ppdev, pjBase, *pulGlyph);
                  pulGlyph++;
                }

                // The 'count' for CP_PIXEL1_REM must be pre-decremented by
                // 1, which explains why this is '+31':

                cBits += 31;
                CP_PIXEL1_REM(ppdev, pjBase, cBits, *pulGlyph);

                CP_END_PIXEL1(ppdev, pjBase);
              }
              else
              {
                //-----------------------------------------------------
                // Clipped glyph

                // Find the intersection of the glyph rectangle
                // and the clip rectangle:

                xLeft   = max(prclClip->left,   ptlOrigin.x);
                yTop    = max(prclClip->top,    ptlOrigin.y);
                xRight  = min(prclClip->right,  ptlOrigin.x + cxGlyph);
                yBottom = min(prclClip->bottom, ptlOrigin.y + cyGlyph);

                // Check for trivial rejection:

                if (((cx = xRight - xLeft) > 0) &&
                    ((cy = yBottom - yTop) > 0))
                {
                  CP_WAIT(ppdev, pjBase);
                  CP_WRIGHT(ppdev, pjBase, xRight - 1);

                  // Make the left edge byte-aligned in the source:

                  xBias = (xLeft - ptlOrigin.x) & 7;
                  if (xBias != 0)
                  {
                    // 'xBias' is the bit position in the monochrome glyph
                    // bitmap of the first pixel to be lit, relative to
                    // the start of the byte.  That is, if 'xBias' is 2,
                    // then the first unclipped pixel is represented by bit
                    // 2 of the corresponding bitmap byte.
                    //
                    // Normally, the accelerator expects bit 0 to be the
                    // first lit byte.  We use the scissors so that the
                    // first 'xBias' bits of the byte will not be displayed.
                    //
                    // (What we're doing is simply aligning the monochrome
                    // blt using the hardware clipping.)

                    CP_WLEFT(ppdev, pjBase, xLeft);
                    xLeft -= xBias;
                    cx    += xBias;
                  }

                  // Make the right edge byte-aligned too:

                  cx = (cx + 7) & ~7L;

                  CP_X0(ppdev,  pjBase, xLeft);
                  CP_XY1(ppdev, pjBase, xLeft, yTop);
                  CP_X2(ppdev,  pjBase, xLeft + cx);
                  CP_START_PIXEL1(ppdev, pjBase);

                  lDelta  = (cxGlyph + 7) >> 3;
                  pjGlyph = (BYTE*) pulGlyph + (yTop - ptlOrigin.y) * lDelta
                          + ((xLeft - ptlOrigin.x) >> 3);
                  cj      = cx >> 3;
                  lDelta -= cj;             // Make it into a true delta

                  do {
                    i = cj;
                    do {
                      CP_PIXEL1_REM(ppdev, pjBase, 7, *pjGlyph);
                      pjGlyph++;
                    } while (--i != 0);

                    pjGlyph += lDelta;
                  } while (--cy);

                  CP_END_PIXEL1(ppdev, pjBase);

                  if (xBias != 0)
                  {
                    CP_WAIT(ppdev, pjBase);
                    CP_ABS_WMIN(ppdev, pjBase, 0, 0);
                  }
                }
              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;
              pgb = pgp->pgdf->pgb;

              if (ulCharInc == 0)
              {
                ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
              }
              else
              {
                ptlOrigin.x += ulCharInc;
              }
            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

    CP_WAIT(ppdev, pjBase);
    CP_ABS_WMAX(ppdev, pjBase, MAX_COORD, MAX_COORD);
}

/******************************Public*Routine******************************\
* BOOL DrvTextOut
*
\**************************************************************************/

BOOL DrvTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,    // If we had set GCAPS_HORIZSTRIKE, we would have
                        //   to fill these extra rectangles (it is used
                        //   largely for underlines).  It's not a big
                        //   performance win (GDI will call our DrvBitBlt
                        //   to draw the extra rectangles).
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlBrush,
MIX       mix)
{
    PDEV*           ppdev;
    DSURF*          pdsurf;
    OH*             poh;
    BYTE*           pjBase;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    BYTE            iDComplexity;
    CACHEDFONT*     pcf;
    BOOL            bTextPerfectFit;

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt != DT_DIB)
    {
      poh            = pdsurf->poh;
      ppdev          = (PDEV*) pso->dhpdev;
      ppdev->xOffset = poh->x;
      ppdev->yOffset = poh->y;

      // The DDI spec says we'll only ever get foreground and background
      // mixes of R2_COPYPEN:

      ASSERTDD(mix == 0x0d0d, "GDI should only give us a copy mix");

      pjBase = ppdev->pjBase;

      iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

      if (prclOpaque != NULL)
      {
        ////////////////////////////////////////////////////////////
        // Opaque Initialization
        ////////////////////////////////////////////////////////////

        // If we paint the glyphs in 'opaque' mode, we may not actually
        // have to draw the opaquing rectangle up-front -- the process
        // of laying down all the glyphs will automatically cover all
        // of the pixels in the opaquing rectangle.
        //
        // The condition that must be satisfied is that the text must
        // fit 'perfectly' such that the entire background rectangle is
        // covered, and none of the glyphs overlap (if the glyphs
        // overlap, such as for italics, they have to be drawn in
        // transparent mode after the opaquing rectangle is cleared).

        bTextPerfectFit = (pstro->flAccel & (SO_ZERO_BEARINGS |
                SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE |
                SO_CHAR_INC_EQUAL_BM_BASE)) ==
                (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
                SO_MAXEXT_EQUAL_BM_SIDE | SO_CHAR_INC_EQUAL_BM_BASE);

        if (!(bTextPerfectFit)                               ||
            (pstro->rclBkGround.top    > prclOpaque->top)    ||
            (pstro->rclBkGround.left   > prclOpaque->left)   ||
            (pstro->rclBkGround.right  < prclOpaque->right)  ||
            (pstro->rclBkGround.bottom < prclOpaque->bottom))
        {
          if (iDComplexity == DC_TRIVIAL)
          {
            CP_METARECT(ppdev, pjBase, prclOpaque->left, prclOpaque->top);
            CP_METARECT(ppdev, pjBase, prclOpaque->right, prclOpaque->bottom);

            CP_WAIT(ppdev, pjBase);
            if (P9000(ppdev))
            {
                CP_BACKGROUND(ppdev, pjBase, pboOpaque->iSolidColor);
                CP_RASTER(ppdev, pjBase, P9000_B);
            }
            else
            {
                CP_COLOR0(ppdev, pjBase, pboOpaque->iSolidColor);
                CP_RASTER(ppdev, pjBase, P9100_P);
            }
            CP_START_QUAD(ppdev, pjBase);
          }
          else
          {
            vClipSolid(ppdev, 1, prclOpaque, pboOpaque->iSolidColor, pco);
          }
        }

        if (bTextPerfectFit)
        {
          // If we have already drawn the opaquing rectangle (because
          // it was larger than the text rectangle), we could lay down
          // the glyphs in 'transparent' mode.  But I've found the Weitek
          // to be a bit faster drawing in opaque mode, so we'll stick
          // with that:

          CP_WAIT(ppdev, pjBase);
          if (P9000(ppdev))
          {
            CP_BACKGROUND(ppdev, pjBase, pboOpaque->iSolidColor);
            CP_FOREGROUND(ppdev, pjBase, pboFore->iSolidColor);
            CP_RASTER(ppdev, pjBase, P9000_OPAQUE_EXPAND);
          }
          else
          {
            CP_COLOR0(ppdev, pjBase, pboOpaque->iSolidColor);
            CP_COLOR1(ppdev, pjBase, pboFore->iSolidColor);
            CP_RASTER(ppdev, pjBase, P9100_OPAQUE_EXPAND);
          }

          CP_ABS_Y3(ppdev, pjBase, 1);
          goto SkipTransparentInitialization;
        }
      }

      ////////////////////////////////////////////////////////////
      // Transparent Initialization
      ////////////////////////////////////////////////////////////

      // Initialize the hardware for transparent text:

      CP_WAIT(ppdev, pjBase);
      if (P9000(ppdev))
      {
        CP_FOREGROUND(ppdev, pjBase, pboFore->iSolidColor);
        CP_RASTER(ppdev, pjBase, P9000_TRANSPARENT_EXPAND);
      }
      else
      {
        CP_COLOR1(ppdev, pjBase, pboFore->iSolidColor);
        CP_RASTER(ppdev, pjBase, P9100_TRANSPARENT_EXPAND);
      }
      CP_ABS_Y3(ppdev, pjBase, 1);

    SkipTransparentInitialization:

      if ((pfo->cxMax <= GLYPH_CACHE_CX) &&
          ((pstro->rclBkGround.bottom - pstro->rclBkGround.top) <= GLYPH_CACHE_CY))
      {
        pcf = (CACHEDFONT*) pfo->pvConsumer;

        if (pcf == NULL)
        {
            pcf = pcfAllocateCachedFont(ppdev);
            if (pcf == NULL)
                return(FALSE);

            pfo->pvConsumer = pcf;
        }

        // Use our glyph cache:

        if (iDComplexity == DC_TRIVIAL)
        {

          do {
            if (pstro->pgp != NULL)
            {
              // There's only the one batch of glyphs, so save ourselves
              // a call:

              pgp         = pstro->pgp;
              cGlyph      = pstro->cGlyphs;
              bMoreGlyphs = FALSE;
            }
            else
            {
              bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
            }

            if (cGlyph > 0)
            {
              if (pstro->ulCharInc == 0)
              {
                if (!bCachedProportionalText(ppdev, pcf, pgp, cGlyph))
                  return(FALSE);
              }
              else
              {
                if (!bCachedFixedText(ppdev, pcf, pgp, cGlyph, pstro->ulCharInc))
                  return(FALSE);
              }
            }
          } while (bMoreGlyphs);
        }
        else
        {
          if (!bCachedClippedText(ppdev, pcf, pstro, pco))
            return(FALSE);
        }
      }
      else
      {
        DISPDBG((5, "Text too big to cache: %li x %li",
            pfo->cxMax, pstro->rclBkGround.bottom - pstro->rclBkGround.top));

        vGeneralText(ppdev, pstro, pco);
      }
    }
    else
    {
      // We're drawing to a DFB we've converted to a DIB, so just call GDI
      // to handle it:

      return(EngTextOut(pdsurf->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                        pboFore, pboOpaque, pptlBrush, mix));
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDestroyFont
*
* We're being notified that the given font is being deallocated; clean up
* anything we've stashed in the 'pvConsumer' field of the 'pfo'.
*
\**************************************************************************/

VOID DrvDestroyFont(
FONTOBJ*    pfo)
{
    CACHEDFONT* pcf;

    pcf = pfo->pvConsumer;
    if (pcf != NULL)
    {
        vFreeCachedFont(pcf);
        pfo->pvConsumer = NULL;
    }
}

/******************************Public*Routine******************************\
* BOOL bEnableText
*
* Performs the necessary setup for the text drawing subcomponent.
*
\**************************************************************************/

BOOL bEnableText(
PDEV*   ppdev)
{
    // Our text algorithms require no initialization.  If we were to
    // do glyph caching, we would probably want to allocate off-screen
    // memory and do a bunch of other stuff here.

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableText
*
* Performs the necessary clean-up for the text drawing subcomponent.
*
\**************************************************************************/

VOID vDisableText(PDEV* ppdev)
{
    // Here we free any stuff allocated in 'bEnableText'.
}

/******************************Public*Routine******************************\
* VOID vAssertModeText
*
* Disables or re-enables the text drawing subcomponent in preparation for
* full-screen entry/exit.
*
\**************************************************************************/

VOID vAssertModeText(
PDEV*   ppdev,
BOOL    bEnable)
{
    // If we were to do off-screen glyph caching, we would probably want
    // to invalidate our cache here, because it will get destroyed when
    // we switch to full-screen.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\bt485.c ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    Bt485.c

Abstract:

    This module contains code specific to the Bt485 DAC.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

#include "p9.h"
#include "p9gbl.h"
#include "p9000.h"
#include "bt485.h"

#include "p91dac.h"

//
// DAC specific static data.
//

//
// Define the DAC support routines structure for the Bt485 DAC.
//

DAC Bt485 = {
    DAC_ID_BT485,
    NUM_DAC_REGS,
    Bt485SetMode,
    Bt485RestoreMode,
    Bt485SetPalette,
    Bt485ClearPalette,
    Bt485PointerOn,
    Bt485PointerOff,
    Bt485SetPointerPos,
    Bt485SetPointerShape,
    CLK_MAX_FREQ,
    Bt485SetClkDoubler,
    Bt485ClrClkDoubler
};




VOID
Bt485SetPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG *pPal,
    ULONG StartIndex,
    ULONG Count
    )

/*++

Routine Description:

    Sets the Device palette

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    pPal - Pointer to the array of pallete entries.

    StartIndex - Specifies the first pallete entry provided in pPal.

    Count - Number of palette entries in pPal

Return Value:

    None.

--*/

{
    UCHAR   *pBytePal;

    PAL_WR_ADDR((UCHAR) StartIndex);

    pBytePal = (PUCHAR) pPal;

    //
    // Load the palette with RGB values. The input palette has 4 bytes
    // per entry, the last of which is ignored.
    //

    while (Count--)
    {
	    PAL_WR_DATA(*pBytePal++);
        PAL_WR_DATA(*pBytePal++);
	    PAL_WR_DATA(*pBytePal++);
	    pBytePal++;		
    }
}


VOID
Bt485SetPointerPos(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG   ptlX,
    ULONG   ptlY
    )

/*++

Routine Description:

    Move Hardware Pointer.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ptlX, ptlY - Requested X,Y position for the pointer.

Return Value:

    TRUE

--*/

{

    //
    // Strip off the invalid bits and update the cursor position regs.
    //

    WR_CURS_POS_X(((ptlX + CURSOR_WIDTH) & 0xFFF));
    WR_CURS_POS_Y(((ptlY + CURSOR_HEIGHT) & 0xFFF));

    return;
}


VOID
Bt485SetPointerShape(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR  pHWCursorShape
    )

/*++

Routine Description:

    Sets the hardware cursor shape.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    pHWCursorShape - Pointer to the cursor bitmap.

Return Value:

    None.

--*/

{
    ULONG   iCount;

    //
    // The # of bytes of cursor bitmap data to send *= 2 for and/xor mask
    // *= 8 for 8bit/byte
    // *= 2 for 2 loops
    //

	ULONG iLoop  = (CURSOR_WIDTH * CURSOR_HEIGHT * 2) / (8 * 2);

    //
    // AND mask will be loaded to plane 1.
	//

    PAL_WR_ADDR(0x80);

    iCount = iLoop;

    WAIT_FOR_RETRACE();

    while (iCount--)
    {
        WR_CURS_DATA(*pHWCursorShape++);
    }

	//
    // XOR mask will be loaded to plane 0.
	//

    PAL_WR_ADDR(0x00);

    iCount = iLoop;

    WAIT_FOR_RETRACE();

    while (iCount--)
    {
        WR_CURS_DATA(*pHWCursorShape++);
    }

    return;
}


VOID
Bt485PointerOn(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

  Turn on the hardware cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{


    //
    // Turn the cursor on only if it was disabled.
    //

    if (!CURS_IS_ON())
    {
        WAIT_FOR_RETRACE();
        CURS_ON();
    }

    return;
}


VOID
Bt485PointerOff(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

  Turn off the hardware cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{


    //
    // Turn the cursor off only if it was enabled.
    //

    if (CURS_IS_ON())
    {
        WAIT_FOR_RETRACE();
        CURS_OFF();
    }

    return;
}


VOID
Bt485ClearPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Clears the palette to all 0's

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{
    int Count;

    //
    // Calculate the number of palette entries. It is assumed that the
    // caller has already determined that the current mode makes use
    // of the palette,
    //

    Count = 1 << HwDeviceExtension->usBitsPixel;

    //
    // Fill the palette with RGB values of 0.
    //

    while (Count--)
    {
	    PAL_WR_DATA(0);
        PAL_WR_DATA(0);
	    PAL_WR_DATA(0);
    }

    return;
}


BOOLEAN
Bt485SetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Initializes the DAC for the current mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/
{
    UCHAR   ucCurState;

    //
    // Enable 8bit dacs, allow access to Command Register 3.
    //

    WR_DAC(CMD_REG_0, ENB_CMD_REG_3 | MODE_8_BIT);		

    //
    // Set the DAC Pixel port value for the current bit depth.
    //

    switch (HwDeviceExtension->usBitsPixel)
    {
        case 8:
            WR_DAC(CMD_REG_1, PIX_PORT_8);
            break;

        case 16:
            WR_DAC(CMD_REG_1, PIX_PORT_16);
            break;

        case 32:
            WR_DAC(CMD_REG_1, PIX_PORT_32);
            break;

        default:

        //
        // Oops..invalid BPP value. Use 8BPP value for now.
        //

            WR_DAC(CMD_REG_1, PIX_PORT_8);
            break;
    };

    //
    // Select P9000 video clock, disable cursor
    //

    WR_DAC(CMD_REG_2, (PORTSEL_MSKD | PCLK1_SEL) & DIS_CURS);

    //
    // Select 32x32x2 cursor mode, and clock doubler mode if neccessary.
    //

    RD_CMD_REG_3(ucCurState);

    if (HwDeviceExtension->VideoData.dotfreq1 >
        HwDeviceExtension->Dac.ulMaxClkFreq)
    {
        //
        // Enable the DAC clock doubler mode.
        //

        HwDeviceExtension->Dac.DACSetClkDblMode(HwDeviceExtension);
    }
    else
    {
        //
        // Disable the DAC clock doubler mode.
        //

        HwDeviceExtension->Dac.DACClrClkDblMode(HwDeviceExtension);
    }

    //
    // Set the pixel read mask.
    //

    WR_DAC(PIXEL_MSK_REG, 0xff);

    //
    // Set cursor colors 1 and 2.
    //

    WR_DAC(CURS_CLR_ADDR, 1);
    WR_DAC(CURS_CLR_DATA, 0x00);
    WR_DAC(CURS_CLR_DATA, 0x00);
    WR_DAC(CURS_CLR_DATA, 0x00);
    WR_DAC(CURS_CLR_DATA, 0xFF);
    WR_DAC(CURS_CLR_DATA, 0xFF);
    WR_DAC(CURS_CLR_DATA, 0xFF);

    return(TRUE);
}


VOID
Bt485RestoreMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

routine description:

    Restore the DAC to its pristine state.

arguments:

    hwdeviceextension - pointer to the miniport driver's device extension.


return value:

--*/

{
    UCHAR   ucCurState;

    //
    // Enable accesses to CMD_REG_3.
    //

    WR_DAC(CMD_REG_0, ENB_CMD_REG_3);

    //
    // Set pixel port for 8bit pixels.
    //

    WR_DAC(CMD_REG_1, RD_DAC(CMD_REG_1) & ~PIX_PORT_24);

    //
    // Select VGA video clock, disable cursor.
    //

    WR_DAC(CMD_REG_2, (RD_DAC(CMD_REG_2) & DIS_CURS));

    //
    // Select 32x32 cursor, clear clock doubler bit.
    //

    RD_CMD_REG_3(ucCurState);
    WR_CMD_REG_3(ucCurState & (~DAC_CLK_2X & CUR_MODE_32));	

    //
    // Set pixel read mask.
    //

    WR_DAC(PIXEL_MSK_REG, 0xff);

    return;
}


VOID
Bt485SetClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

routine description:

    Enable the DAC's internal clock doubler.

arguments:

    hwdeviceextension - pointer to the miniport driver's device extension.


return value:

--*/

{
    UCHAR   ucCurState;

    RD_CMD_REG_3(ucCurState);
    WR_CMD_REG_3(ucCurState | DAC_CLK_2X);
    return;
}


VOID
Bt485ClrClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

routine description:

    Disable the DAC's internal clock doubler.

arguments:

    hwdeviceextension - pointer to the miniport driver's device extension.


return value:

--*/
{
    UCHAR   ucCurState;

    RD_CMD_REG_3(ucCurState);
    WR_CMD_REG_3(ucCurState & ~DAC_CLK_2X);	
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\p9.h ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    p9.h

Abstract:

    This module contains the definitions for the code that implements the
    Weitek P9 miniport device driver.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

#include "dderror.h"
#include "devioctl.h"

#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

//
// Sync Polarities.
//

#define NEGATIVE 0L
#define POSITIVE 1L

#define CURSOR_WIDTH    32
#define CURSOR_HEIGHT   32

extern  VIDEO_ACCESS_RANGE  VLDefDACRegRange[];

//
// Structure containing the video parameters. Pack the structure on
// 1 byte boundaries. This is done so that the size of the structure
// matches exactly the size of the video parms data value stored in the
// registry.
//

#pragma pack(1)

typedef struct tagVDATA
{
    ULONG dotfreq1;                             // Input pixel dot rate shift value
    ULONG hsyncp;                           // horizontal sync pulse width in dots
    ULONG hbp;                                  // horizontal back porch width
    ULONG XSize;                                // my personal global copy of the current
    ULONG hfp;                                  // horizontal front porch
    ULONG hco;                                  // horizontal cursor offset
    ULONG hp;                                   // horizontal sync polarity
    ULONG vlr;                  // Vertical Refresh Rate in Hz.
    ULONG vsp;                                  // vertical sync pulse height in lines
    ULONG vbp;                                  // vertical back porch width
    ULONG YSize;                        // screen width and height
    ULONG vfp;                                  // vertical front porch
    ULONG vco;                                  // vertical cursor offset
    ULONG vp;                                   // vertical sync polarity

    // Added for P9100 support
    // Potential overides...
    //

    ULONG ulIcdSerPixClk;   // IcdSerPixClk
    ULONG ulIcdCtrlPixClk;  // IcdCtrlPixClk
    ULONG ulIcdSer525Ref;   // IcdSer525Ref
    ULONG ulIcdCtrl525Ref;  // IcdCtrl525Ref
    ULONG ul525RefClkCnt;   // 525RefClkCnt
    ULONG ul525VidClkFreq;  // 525VidClkFreq
    ULONG ulMemCfgClr;      // MemCfgClr
    ULONG ulMemCfgSet;      // MemCfgSet

} VDATA, *PVDATA;

//
// Restore strcuture packing to the default value.
//

#pragma pack()

//
// Structure containing the mode information.
//

#define P9000_ID   0x01
#define P9100_ID   0x02

#define IS_DEV_P9100 (HwDeviceExtension->P9CoprocInfo.CoprocId == P9100_ID)

//
// DriverSpecificAttributeFlags
//

#define CAPS_WEITEK_CHIPTYPE_IS_P9000 0x0001  // represents p9000 chip

typedef struct tagP9INITDATA
{
    ULONG   Count;
    ULONG   ulChips;
    PVDATA  pvData;                         // Ptr to the default video parms
    BOOLEAN valid;
    VIDEO_MODE_INFORMATION modeInformation; // NT Mode Info structure.
} P9INITDATA, *PP9INITDATA;


//
// Mode enumeration.
//

typedef enum _P9_MODES
{
    m640_480_8_60,
    m640_480_16_60,
    m640_480_24_60,
    m640_480_32_60,
    m640_480_8_72,
    m640_480_16_72,
    m640_480_24_72,
    m640_480_32_72,
    m800_600_8_60,
    m800_600_8_72,
    m800_600_16_60,
    m800_600_16_72,
    m800_600_24_60,
    m800_600_24_72,
    m800_600_32_60,
    m800_600_32_72,
    m1K_768_8_60,
    m1K_768_8_70,
    m1K_768_16_60,
    m1K_768_16_70,
    m1K_768_24_60,
    m1K_768_24_70,
    m1K_768_32_60,
    m1K_768_32_70,
    m1280_1K_8_55,
    m1280_1K_8_60,
    m1280_1K_8_74,
    m1280_1K_8_75,
    m1280_1K_16_60,
    m1280_1K_16_74,
    m1280_1K_16_75,
    m1280_1K_24_60,
    m1280_1K_24_74,
    m1280_1K_24_75,
    m1600_1200_8_60,
    m1600_1200_16_60,
    mP9ModeCount
} P9_MODES;


//
// Define P9 coprocessor data structure. This contains info about the
// one member of the P9 family of coprocessors.
//

typedef struct _P9_COPROC {

    //
    //  Coprocessor type ID.
    //

    ULONG   CoprocId;

    //
    // Size of the P9 address space.
    //

    ULONG   AddrSpace;

    //
    // Offset from the base address to the coprocessor registers.
    //

    ULONG   CoprocRegOffset;

    //
    // Length of the coprocessor register block.
    //

    ULONG   CoprocLength;

    //
    // Offset from the base address to the frame buffer.
    //

    ULONG   FrameBufOffset;

    //
    // Routine to perform frame buffer memory sizing.
    //

    VOID    (*SizeMem)(PHW_DEVICE_EXTENSION);
} P9_COPROC, *PP9_COPROC;

//
// DAC IDs:
// NOTE:    These DAC ID's are the same as the bits in the P9100 power up
//          configuration register.  Were just going to "borrow" them so
//          can place the DAC ID in the DAC info structure. (This makes
//          displaying of the DAC info real easy).

#define DAC_ID_BT485                (0x0)   // BT485
#define DAC_ID_IBM525               (0x8)   // IBMRGB525
#define DAC_ID_BT489                (0x1)   // BT489               


//
// Define the DAC support routines structure.
//

typedef struct _DAC {
    ULONG       ulDacId;
    UCHAR       cDacRegs;               // Number of DAC registers

    //
    // Routine to Initialize the DAC.
    //

    BOOLEAN      (*DACInit)(PHW_DEVICE_EXTENSION);

    //
    // Routine to enable hardware pointer.
    //

    VOID        (*DACRestore)(PHW_DEVICE_EXTENSION);

    //
    // Routine to set palette entries.
    //

    VOID        (*DACSetPalette)(PHW_DEVICE_EXTENSION, PULONG, ULONG, ULONG);

    //
    // Routine to clear the palette.
    //

    VOID        (*DACClearPalette)(PHW_DEVICE_EXTENSION);

    //
    // Routine to enable hardware pointer.
    //

    VOID        (*HwPointerOn)(PHW_DEVICE_EXTENSION);

    //
    // Routine to disable hw pointer.
    //

    VOID        (*HwPointerOff)(PHW_DEVICE_EXTENSION);

    //
    // Routine to set hw pointer pos.
    //

    VOID        (*HwPointerSetPos)(PHW_DEVICE_EXTENSION, ULONG, ULONG);

    //
    // Routine to set hw ptr shape.
    //

    VOID        (*HwPointerSetShape)(PHW_DEVICE_EXTENSION, PUCHAR);

    //
    // Maximum frequency supported by this DAC w/o clock doubling (if the
    // DAC supports it, see below).
    //

    ULONG       ulMaxClkFreq;

    //
    // DAC routine to set clock double mode (if supported).
    //

    VOID       (*DACSetClkDblMode)(PHW_DEVICE_EXTENSION);

    //
    // DAC routine to clear clock double mode (if supported).
    //

    VOID       (*DACClrClkDblMode)(PHW_DEVICE_EXTENSION);

    //
    // The following structure members are for the P9100 DAC support
    //

    USHORT      usRamdacID,
                usRamdacWidth;

    BOOLEAN     bRamdacUsePLL,
                bRamdacDivides,
                bRamdac24BPP;

} DAC, *PDAC;

//
// Define Adapter Description structure. This contains the Adapter support
// information.
//

typedef struct _ADAPTER_DESC {

    USHORT  ausAdapterIDString[32];

    //
    // P9000 Register values which vary depending upon the OEM configuration.
    //

    ULONG   ulMemConfVal;       // Memory config reg value.
    ULONG   ulSrctlVal;         // Screen repaint control reg value.

    //
    // Flag which indicates whether autodetection should be attempted.
    //

    BOOLEAN bAutoDetect;

    //
    // Is this a PCI adapter ?
    //

    BOOLEAN bPCIAdapter;
    //
    // OEM board detect/P9 memory map routine.
    //

    BOOLEAN     (*OEMGetBaseAddr)(PHW_DEVICE_EXTENSION);

    //
    // OEM set video mode routine.
    //

    VOID        (*OEMSetMode)(PHW_DEVICE_EXTENSION);

    //
    // Routines to enable/disable P9 video.
    //

    VOID        (*P9EnableVideo)(PHW_DEVICE_EXTENSION);
    BOOLEAN     (*P9DisableVideo)(PHW_DEVICE_EXTENSION);

    //
    // Routine to enable the P9 memory map.
    //

    BOOLEAN     (*P9EnableMem)(PHW_DEVICE_EXTENSION);

    //
    // Misc OEM specific fields.
    //

    LONG        iClkDiv;            // Clock divisor
    BOOLEAN     bWtk5x86;           // Is a Weitek 5x86 VGA present?
    BOOLEAN     bRequiresIORanges;  // Will this adapter try to use
                                    //   non memory mapped registers.

} ADAPTER_DESC, *PADAPTER_DESC;

//
// Structure which defines an OEM P9 based adapter.
//

typedef struct tagP9ADAPTER
{

    //
    // OEM adapter information.
    //

    PADAPTER_DESC    pAdapterDesc;

    //
    // DAC used by this adapter.
    //

    PDAC             pDac;

    //
    // P9 Coprocessor type used by this adapter.
    //

    PP9_COPROC       pCoprocInfo;

} P9ADAPTER, *PP9ADAPTER;


//
// P9100 additions
// Define standard bus types.
//

#define VESA 1
#define PCI  2

//
// maximum Amount of address space used by both types of cards
//

#define RESERVE_PCI_ADDRESS_SPACE   0x01000000   // 16 MEG


typedef struct {
    BOOLEAN     bEnabled,
                bInitialized,
                bVram256,
                bVideoPowerEnabled;

    ULONG       ulPuConfig,
                ulMemConfVal,
                ulSrctlVal,
                ulBlnkDlyAdj,
                ulFrameBufferSize;

    USHORT      usClockID,
                usRevisionID,
                usMemConfNum,
                usNumVramBanks;
} P91STATE;

typedef P91STATE *PP91STATE;

typedef enum
{
    GENERIC, SIEMENS, SIEMENS_P9100_VLB, SIEMENS_P9100_PCi
                   // ^            SNI-Od: add an id to manage viper P9100 VL
                   //    boards on SIEMENS-NIXDORF RM200/RM300/RM400 machines
} MACHINE_TYPE;

#define VideoPortIsCpu(typeCpu)                                             \
        (NO_ERROR == VideoPortGetDeviceData(HwDeviceExtension,VpMachineData,\
                                            &GetCPUIdCallback, typeCpu))
#define if_SIEMENS_Box() \
              if (HwDeviceExtension->MachineType == SIEMENS \
              ||  HwDeviceExtension->MachineType == SIEMENS_P9100_VLB \
              ||  HwDeviceExtension->MachineType == SIEMENS_P9100_PCi)
#define if_SIEMENS_P9100_VLB() \
              if (HwDeviceExtension->MachineType == SIEMENS_P9100_VLB)
#define if_SIEMENS_P9100() \
              if (HwDeviceExtension->MachineType == SIEMENS_P9100_VLB \
              ||  HwDeviceExtension->MachineType == SIEMENS_P9100_PCi)
#define if_Not_SIEMENS_P9100_VLB() \
              if (HwDeviceExtension->MachineType != SIEMENS_P9100_VLB)
#define if_SIEMENS_VLB() \
              if (HwDeviceExtension->MachineType == SIEMENS \
              ||  HwDeviceExtension->MachineType == SIEMENS_P9100_VLB)


//
// Define device extension structure. This is device dependant/private
// information.
//

typedef struct _HW_DEVICE_EXTENSION {
    PVOID Vga;
    PVOID Coproc;
    PVOID FrameAddress;
    PVOID CoprocVirtAddr;

    PHYSICAL_ADDRESS    P9PhysAddr;
    PHYSICAL_ADDRESS    CoprocPhyAddr;      // these two addresses are part
    PHYSICAL_ADDRESS    PhysicalFrameAddr;  // of the P9PhysAddr address space.

    PHYSICAL_ADDRESS    P9001PhysicalAddress;

    ULONG               FrameLength;

    USHORT              MiscRegState;       // Original value for MISCOUT reg

    ULONG               CurrentModeNumber;
    ULONG               usBitsPixel;        // BPP of current mode

    VDATA               VideoData;

    ULONG               ulPointerX;
    ULONG               ulPointerY;
    ULONG               flPtrState;

    // P9100 stuff...

    USHORT              usBusType;

    PVOID               ConfigAddr;

    P91STATE            p91State;

    // End of P9100 sutff...

    P9_COPROC           P9CoprocInfo;
    ADAPTER_DESC        AdapterDesc;        // The adapter support info
    DAC                 Dac;                // ptr to the DAC information
    PULONG              pDACRegs;           // ptr to DAC register block

    ULONG               ulNumAvailModes;    // number of available modes
    ULONG               PciSlotNum;         // Slot number for PCI machine

    MACHINE_TYPE        MachineType;        // If the miniport needs to
                                            // behave differently on a
                                            // given machine, then the
                                            // machine type should be
                                            // detected during HwFindAdapter,
                                            // and we can check this field
                                            // anywhere where we need to
                                            // behave differently.

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

//
// Macros to read and write a register.
//

#define WR_REG(addr, data) \
    VideoPortWritePortUchar(addr, (data))

#define RD_REG(addr) \
    VideoPortReadPortUchar(addr)

//
// Macros to read and write VGA registers.
//

#define VGA_WR_REG(index, data) \
    VideoPortWritePortUchar((PUCHAR) HwDeviceExtension->Vga + index, (UCHAR) (data))

#define VGA_RD_REG(index) \
    VideoPortReadPortUchar((PUCHAR) HwDeviceExtension->Vga + index)

//
// Macros to read and write P9 registers.
//

#define P9_WR_REG(index, data) \
   VideoPortWriteRegisterUlong((PULONG)((PUCHAR) HwDeviceExtension->Coproc + index), (ULONG) (data))

#define P9_RD_REG(index) \
   VideoPortReadRegisterUlong((PULONG) ((PUCHAR) HwDeviceExtension->Coproc + index))

#define P9_WR_BYTE_REG(index, data) \
   VideoPortWriteRegisterUchar(((PUCHAR) HwDeviceExtension->Coproc + index), (UCHAR) (data))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\p9.c ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    p9.c

Abstract:

    This module contains the code that implements the Weitek P9 miniport
    device driver.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

#include "p9.h"
#include "p9gbl.h"
#include "vga.h"
#include "string.h"
#include "p91regs.h"
#include "p9errlog.h"

//
// This global is used as an error flag to error out quickly on the multiple
// calls to P9FindAdapter when a board is not supported.
//

extern VP_STATUS    vpP91AdapterStatus;
extern BOOLEAN      bFoundPCI;

extern ULONG P91_Bt485_DAC_Regs[];

BOOLEAN gMadeAdjustments=FALSE;

extern BOOLEAN
bIntergraphBoard(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

extern VOID SetVgaMode3(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

extern VOID
WriteP9ConfigRegister(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR regnum,
    UCHAR jValue
    );

extern VOID
InitP9100(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


extern VOID
P91_SysConf(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


extern VOID
P91_WriteTiming(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

extern VOID vDumpPCIConfig(PHW_DEVICE_EXTENSION HwDeviceExtension,
                    PUCHAR psz);

extern
VOID
P91RestoreVGAregs(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    VGA_REGS  * SaveVGARegisters);

extern
VOID
P91SaveVGARegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    VGA_REGS * SaveVGARegisters);

//
// Local function Prototypes
//
// Functions that start with 'P9' are entry points for the OS port driver.
//

VP_STATUS
GetCPUIdCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentifierLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    );

VP_STATUS
GetDeviceDataCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentifierLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    );

VOID
DevSetRegistryParams(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );


VP_STATUS
FindAdapter(
    PHW_DEVICE_EXTENSION    HwDeviceExtension,
    PVOID                   HwContext,
    PWSTR                   ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PP9ADAPTER              pCurAdapter
    );

VP_STATUS
P9FindAdapter(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
P9Initialize(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
P9StartIO(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

VOID
DevInitP9(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
DevDisableP9(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    BOOLEAN BugCheck
    );

VP_STATUS
P9QueryNamedValueCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

BOOLEAN
P9ResetVideo(
    IN PVOID HwDeviceExtension,
    IN ULONG Columns,
    IN ULONG Rows
    );

VOID
InitializeModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


//
// New entry points added for NT 5.0.
//

#if (_WIN32_WINNT >= 500)

//
// Routine to set a desired DPMS power management state.
//
VP_STATUS
WP9SetPower50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    );

//
// Routine to retrieve possible DPMS power management states.
//
VP_STATUS
WP9GetPower50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    );

//
// Routine to retrieve the Enhanced Display ID structure via DDC
//
ULONG
WP9GetVideoChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    );
#endif  // _WIN32_WINNT >= 500


#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,GetCPUIdCallback)
#pragma alloc_text(PAGE,GetDeviceDataCallback)
#pragma alloc_text(PAGE,DevSetRegistryParams)
#pragma alloc_text(PAGE,P9FindAdapter)
#pragma alloc_text(PAGE,FindAdapter)
#pragma alloc_text(PAGE,P9Initialize)
#pragma alloc_text(PAGE,P9StartIO)
#if (_WIN32_WINNT >= 500)
#pragma alloc_text(PAGE_COM, WP9SetPower50)
#pragma alloc_text(PAGE_COM, WP9GetPower50)
#pragma alloc_text(PAGE_COM, WP9GetVideoChildDescriptor)
#endif  // _WIN32_WINNT >= 500


/*****************************************************************************
 *
 * IMPORTANT:
 *
 * Some routines, like DevDisable, can not be paged since they are called
 * when the system is bugchecking
 *
 ****************************************************************************/

// #pragma alloc_text(PAGE, DevDisableP9)
#endif


ULONG
DriverEntry (
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    Context1 - First context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

    Context2 - Second context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

--*/

{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG status = ERROR_DEV_NOT_EXIST;

    VideoDebugPrint((2, "DriverEntry ----------\n"));

    //
    // Zero out structure.
    //

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    //
    // Specify sizes of structure and extension.
    //

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitData.HwFindAdapter = P9FindAdapter;
    hwInitData.HwInitialize  = P9Initialize;
    hwInitData.HwInterrupt   = NULL;
    hwInitData.HwStartIO     = P9StartIO;
    hwInitData.HwResetHw     = P9ResetVideo;

#if (_WIN32_WINNT >= 500)

    //
    // Set new entry points added for NT 5.0.
    //

    hwInitData.HwSetPowerState           = WP9SetPower50;
    hwInitData.HwGetPowerState           = WP9GetPower50;
    hwInitData.HwGetVideoChildDescriptor = WP9GetVideoChildDescriptor;

#endif // _WIN32_WINNT >= 500


    //
    // Determine the size we require for the device extension.
    //

    //
    // Compute the size of the device extension by adding in the
    // number of DAC Registers.
    //

    hwInitData.HwDeviceExtensionSize =
        sizeof(HW_DEVICE_EXTENSION) +
        (17) * sizeof(PVOID);

    //
    // This driver accesses one range of memory one range of control
    // register and a last range for cursor control.
    //

    // hwInitData.NumberOfAccessRanges = 0;

    //
    // There is no support for the V86 emulator in this driver so this field
    // is ignored.
    //

    // hwInitData.NumEmulatorAccessEntries = 0;

    //
    // This device supports many bus types.
    //
    // SNI has implemented machines with both VL and PCI versions of the
    // weitek chipset.  Don't bother with the other buses since the
    // detection code may actually crash some MIPS boxes.
    //

    hwInitData.AdapterInterfaceType = PCIBus;

    status = VideoPortInitialize(Context1,
                                 Context2,
                                 &hwInitData,
                                 NULL);

    if (status == NO_ERROR)
    {
        VideoDebugPrint((2, "DriverEntry SUCCESS for PCI\n"));
        bFoundPCI = TRUE;
        return(status);
    }


    //
    //  As of NT5, we won't support weitek PCI with any other weitek on
    //  the same machine.
    //

    if (bFoundPCI)
        return ERROR_DEV_NOT_EXIST;

    hwInitData.AdapterInterfaceType = Isa;

    status = VideoPortInitialize(Context1,
                                 Context2,
                                 &hwInitData,
                                 NULL);

    if ((status == NO_ERROR))
    {
        VideoDebugPrint((2, "DriverEntry SUCCESS for ISA\n"));
        return(status);
    }

    hwInitData.AdapterInterfaceType = Eisa;

    status = VideoPortInitialize(Context1,
                                 Context2,
                                 &hwInitData,
                                 NULL);

    if ((status == NO_ERROR))
    {
        VideoDebugPrint((2, "DriverEntry SUCCESS for EISA\n"));
        return(status);
    }

    hwInitData.AdapterInterfaceType = Internal;

    status = VideoPortInitialize(Context1,
                                 Context2,
                                 &hwInitData,
                                 NULL);

    if ((status == NO_ERROR))
    {
        VideoDebugPrint((2, "DriverEntry SUCCESS at for Internal\n"));
        return(status);
    }

    return(status);

} // end DriverEntry()

VP_STATUS
P9FindAdapter (
    PHW_DEVICE_EXTENSION    HwDeviceExtension,
    PVOID                   HwContext,
    PWSTR                   ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR                  Again
    )

/*++

Routine Description:

Arguments:

Return Value:

    Status from FindAdapter()

--*/

{

    ULONG status;
    UCHAR   i;
    *Again = TRUE;

    VideoDebugPrint((2, "P9FindAdapter entry\n"));

    //
    //  Loop through the table of types of cards. DriverEntry() loops through
    //  the bus types.
    //

    for (i = 0; i < NUM_OEM_ADAPTERS; i++)
    {
        VideoDebugPrint((2, "Loop %d in P9FindAdapter\n", i));

        status =    FindAdapter(HwDeviceExtension,
                                HwContext,
                                ArgumentString,
                                ConfigInfo,
                                &(OEMAdapter[i]));

        if (status == NO_ERROR)
        {
            VideoDebugPrint((2, "P9FindAdapter SUCCESS at loop %d\n", i));

            //
            // Indicate we do not wish to be called over
            //

            *Again = FALSE;

            break;
        }

    }

    //
    //  If we've exhausted the table, request to not be recalled.
    //

    if ( i ==  NUM_OEM_ADAPTERS)
        {
        VideoDebugPrint((1, "P9FindAdapter FAILED\n", i));
        *Again = FALSE;
        }

    return(status);

} // end P9FindAdapter()


VP_STATUS
pVlCardDetect(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*++

Routine Description:

    This routine determines if the driver is the ForceVga.

Arguments:

Return Value:

    return STATUS_SUCCESS if we are in DEADMAN_KEY state
    return failiure otherwise.

--*/

{

#ifdef _X86_

    if (ValueData &&
        ValueLength &&
        (*((PULONG)ValueData) == 1)) {

        VideoDebugPrint((2, "doing VL card detection\n"));

        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;

    }

#else

    //
    // we never have a VL bus on non-x86 systems
    //

    return ERROR_INVALID_PARAMETER;

#endif

}

VP_STATUS
GetCPUIdCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentifierLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    )
{
    VideoDebugPrint((2, "Weitek: Check the SNI CPU ID\n"));

    //
    // We do not want to try to detect the weitekp9 if there isn't one present.
    // (Kind of a paradox?)
    //

    if (Identifier) {

        if (VideoPortCompareMemory(Context,
                                   Identifier,
                                   IdentifierLength) == IdentifierLength)
        {
            return NO_ERROR;
        }
    }

    return ERROR_DEV_NOT_EXIST;

} //end GetCPUIdCallback()

VP_STATUS
GetDeviceDataCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentifierLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    )
{
    PVIDEO_HARDWARE_CONFIGURATION_DATA configData = ConfigurationData;
    PHW_DEVICE_EXTENSION hwDeviceExtension;
    ULONG i;

    hwDeviceExtension = (PHW_DEVICE_EXTENSION)HwDeviceExtension;

    VideoDebugPrint((2, "Weitek: controller information is present\n"));

    //
    // We do not want to try to detect the weitekp9 if there isn't one present.
    // (Kind of a paradox?)
    //

    if (Identifier) {

        if (VideoPortCompareMemory(L"DIAMOND P9000 VLBUS",
                                   Identifier,
                                   sizeof(L"DIAMOND P9000 VLBUS")) ==
                                   sizeof(L"DIAMOND P9000 VLBUS"))
        {
            hwDeviceExtension->MachineType = SIEMENS;
        }
        else if (VideoPortCompareMemory(L"DIAMOND P9100 VLBUS",
                                        Identifier,
                                        sizeof(L"DIAMOND P9100 VLBUS")) ==
                                        sizeof(L"DIAMOND P9100 VLBUS"))

        {
            hwDeviceExtension->MachineType = SIEMENS_P9100_VLB;
        }
        else
        {
            return ERROR_DEV_NOT_EXIST;
        }

        VideoDebugPrint((1, "Siemens Nixdorf RM400 VL with Weitek P9%d00\n",
                         hwDeviceExtension->MachineType == SIEMENS ? 0:1));

        hwDeviceExtension->P9PhysAddr.LowPart = 0x1D000000;

        //
        // adjust DriverAccessRanges for Siemens box
        //
        // This routine may be called several times, but we
        // only want to do this once!
        //

        if (!gMadeAdjustments)
        {
            ULONG adjust;

            if ((hwDeviceExtension->MachineType == SIEMENS_P9100_VLB) &&
                (VideoPortIsCpu(L"RM400-MT") || VideoPortIsCpu(L"RM400-T")
               ||VideoPortIsCpu(L"RM400-T MP")))
            {
                //
                // If we have a P9100 VLB and it's *not* on a RM200
                // then use the new address.
                //
                // Otherwise, use the old address.
                //

                adjust = 0x1E000000;
            }
            else if (hwDeviceExtension->MachineType == SIEMENS
                 ||  VideoPortIsCpu(L"RM200"))
            {
                adjust = 0x14000000;
            }
            else return ERROR_DEV_NOT_EXIST;

            DriverAccessRanges[1].RangeStart.LowPart += adjust;

            for(i=0; i<0x10; i++)
            {
                VLDefDACRegRange[i].RangeStart.LowPart += adjust;
            }

            gMadeAdjustments = TRUE;
        }

    }

    return NO_ERROR;

} //end GetDeviceDataCallback()

VP_STATUS
P9QueryNamedValueCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
)
{
    if (ValueLength == 4)
    {
        *((PULONG) Context) = *((PULONG)ValueData);
        return(NO_ERROR);
    }
    else
    {
        return(ERROR_INVALID_PARAMETER);
    }
}

VOID
WeitekP91NapTime(
    VOID
    )
{
    ULONG   count;

    for (count=0; count<100; count) {

        VideoPortStallExecution(1000);
        ++count;
    }
}


VP_STATUS
FindAdapter(
    PHW_DEVICE_EXTENSION    HwDeviceExtension,
    PVOID                   HwContext,
    PWSTR                   ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PP9ADAPTER              pCurAdapter
    )

/*++

Routine Description:

    This routine is called to determine if the adapter for this driver
    is present in the system.
    If it is present, the function fills out some information describing
    the adapter.

Arguments:

    HwDeviceExtension - Supplies the miniport driver's adapter storage. This
        storage is initialized to zero before this call.

    HwContext - Supplies the context value which was passed to
        VideoPortInitialize(). Must be NULL for PnP drivers.

    ArgumentString - Suuplies a NULL terminated ASCII string. This string
        originates from the user.

    ConfigInfo - Returns the configuration information structure which is
        filled by the miniport driver. This structure is initialized with
        any knwon configuration information (such as SystemIoBusNumber) by
        the port driver. Where possible, drivers should have one set of
        defaults which do not require any supplied configuration information.

    Again - Indicates if the miniport driver wants the port driver to call
        its VIDEO_HW_FIND_ADAPTER function again with a new
        and the same config info. This is used by the miniport drivers which
        can search for several adapters on a bus.


    NO_ERROR - Indicates a host adapter was found and the
        configuration information was successfully determined.

    ERROR_INVALID_PARAMETER - Indicates an adapter was found but there was an
        error obtaining the configuration information. If possible an error
        should be logged.

    ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
        supplied configuration information.

--*/

{
    PULONG     pVirtAddr;
    SHORT      i;
    ULONG      TotalRanges;

    ULONG      CoProcId;
    VP_STATUS  vpCurrStatus = NO_ERROR;
    VGA_REGS   VGAregs;
    BOOLEAN    bRetryP9100 = TRUE;

    VideoDebugPrint((2, "FindAdapter: enter\n"));

    //
    // NOTE:
    // Important workaround for detection:
    //
    // We can not always autodetect Weitek VL designs because many machines
    // will NMI if we try to access the high memory locations at which the
    // card is present.
    //
    // We will only "detect" the Weitek VL cards if the user specifically
    // installed the weitek driver using the video applet.
    //
    // We will only autodetect the PCI and Viper VL designs. The bAutoDetect
    // field in the adapter info structure indicates if a design can be
    // autodetected.
    //

    if ((!pCurAdapter->pAdapterDesc->bAutoDetect) &&
         !bFoundPCI &&
         VideoPortGetRegistryParameters(HwDeviceExtension,
                                        L"DetectVLCards",
                                        FALSE,
                                        pVlCardDetect,
                                        NULL) != NO_ERROR)
    {
        VideoDebugPrint((1, "FindAdapter: failed to autodetect\n"));
        return(ERROR_DEV_NOT_EXIST);
    }

    //
    //  If the bus type in pCurAdapter->pAdapterDesc is PCI, but
    //  the AdapterInterfaceType in ConfigInfo is not PCI, return
    //  ERROR_DEV_NOT_EXIST.
    //

    if ((ConfigInfo->AdapterInterfaceType == PCIBus) &&
        (!pCurAdapter->pAdapterDesc->bPCIAdapter))
        return ERROR_DEV_NOT_EXIST;


    HwDeviceExtension->P9PhysAddr.HighPart = 0;
    HwDeviceExtension->P9PhysAddr.LowPart = 0;

    VideoPortGetRegistryParameters((PVOID) HwDeviceExtension,
                                   L"Membase",
                                   FALSE,
                                   P9QueryNamedValueCallback,
                                   (PVOID) &(HwDeviceExtension->P9PhysAddr.LowPart));


    // SNI is shipping MIPS machine with Internal and PCI versions of the
    // weitek chips.  For other buses, don't try to load
    // For MIPS machine with an Internal Bus, check the ID
    // for PPC, we just go through normal detection
    //

#if defined(_MIPS_)

    if (ConfigInfo->AdapterInterfaceType == Internal)
    {
        //
        // Let get the hardware information from the hardware description
        // part of the registry.
        //
        // Check if there is a video adapter on the internal bus.
        // Exit right away if there is not.
        //

        if (NO_ERROR != VideoPortGetDeviceData(HwDeviceExtension,
                                               VpControllerData,
                                               &GetDeviceDataCallback,
                                               pCurAdapter))
        {

            VideoDebugPrint((1, "Weitek: VideoPort get controller info failed\n"));

            return ERROR_INVALID_PARAMETER;

        }
    }
    else if(ConfigInfo->AdapterInterfaceType != PCIBus)
                return ERROR_INVALID_PARAMETER;
#endif

    //
    // Move the various Hw component structures for this board into the
    // device extension.
    //

    VideoPortMoveMemory(&HwDeviceExtension->P9CoprocInfo,
                        pCurAdapter->pCoprocInfo,
                        sizeof(P9_COPROC));

    VideoPortMoveMemory(&HwDeviceExtension->AdapterDesc,
                        pCurAdapter->pAdapterDesc,
                        sizeof(ADAPTER_DESC));

    VideoPortMoveMemory(&HwDeviceExtension->Dac,
                        pCurAdapter->pDac,
                        sizeof(DAC));

    //
    // Set up the array of register ptrs in the device extension:
    // the OEMGetBaseAddr routine will need them if a board is found.
    // The arrays are kept at the very end of the device extension and
    // are order dependent.
    //

    (PUCHAR) HwDeviceExtension->pDACRegs = (PUCHAR) HwDeviceExtension +
                                    sizeof(HW_DEVICE_EXTENSION);

    //
    // Call the OEMGetBaseAddr routine to determine if the board is
    // installed.
    //
    VideoDebugPrint((2, "AdapterInterfaceType:%d\n", ConfigInfo->AdapterInterfaceType));

    if (!pCurAdapter->pAdapterDesc->OEMGetBaseAddr(HwDeviceExtension))
    {
        VideoDebugPrint((1, "FindAdapter, GetBaseAddr Failed, line %d\n", __LINE__));
        return(ERROR_DEV_NOT_EXIST);
    }

    //
    // We found an adapter, pickup a local for the chip type.
    //

    CoProcId = pCurAdapter->pCoprocInfo->CoprocId;

    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO))
    {
        VideoDebugPrint((1, "FindAdapter Failed, wrong version, line %d\n", __LINE__));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Clear out the Emulator entries and the state size since this driver
    // does not support them.
    //

    ConfigInfo->NumEmulatorAccessEntries = 0;
    ConfigInfo->EmulatorAccessEntries = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    ConfigInfo->HardwareStateSize = 0;

    if ((CoProcId == P9000_ID) && !(pCurAdapter->pAdapterDesc->bPCIAdapter))
    {
        ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0L;
        ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0L;
        ConfigInfo->VdmPhysicalVideoMemoryLength           = 0L;
    }
    else
    {
        ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = MEM_VGA_ADDR;
        ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0L;
        ConfigInfo->VdmPhysicalVideoMemoryLength           = MEM_VGA_SIZE;
        if(HwDeviceExtension->MachineType == SIEMENS_P9100_PCi)
                ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart |= 0x10000000;
    }
    //
    // The OEMGetBaseAddr routine should have initialized the following
    // data structures:
    //
    //  1) The DAC access ranges in DriverAccessRanges.
    //  2) The P9PhysAddr field in the device extension.
    //

    //
    // Initialize the physical address for the registers and frame buffer.
    //

    HwDeviceExtension->CoprocPhyAddr = HwDeviceExtension->P9PhysAddr;
    HwDeviceExtension->CoprocPhyAddr.LowPart +=
            HwDeviceExtension->P9CoprocInfo.CoprocRegOffset;

    HwDeviceExtension->PhysicalFrameAddr = HwDeviceExtension->P9PhysAddr;
    HwDeviceExtension->PhysicalFrameAddr.LowPart +=
            HwDeviceExtension->P9CoprocInfo.FrameBufOffset;

    //
    // Initialize the access range structure with the base address values
    // so the driver can register its memory usage.
    //

    DriverAccessRanges[0].RangeStart =
                HwDeviceExtension->P9PhysAddr;
    DriverAccessRanges[0].RangeLength =
                HwDeviceExtension->P9CoprocInfo.AddrSpace;

    if (CoProcId == P9000_ID)
    {
        //
        // Init the total number of standard access ranges.
        //

        TotalRanges = NUM_DRIVER_ACCESS_RANGES + NUM_DAC_ACCESS_RANGES + 1;

    }
    else
    {
        TotalRanges = NUM_DRIVER_ACCESS_RANGES;
    }

    //
    // Check to see if another miniport driver has allocated any of the
    // coprocessor's memory space.
    //

    if (VideoPortVerifyAccessRanges(HwDeviceExtension,
                                    TotalRanges,
                                    DriverAccessRanges) != NO_ERROR)
    {
        if (HwDeviceExtension->AdapterDesc.bRequiresIORanges)
        {
            //
            // If we need more then just the coproc ranges, and couldn't get
            // then we need to fail.
            //

            VideoDebugPrint((1, "FindAdapter : (ERROR) VideoPortVerifyAccessRanges - Failed 1\n"));
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            //
            // We couldn't claim all of the access ranges.  However, this is a
            // card which really only needs the coproc and frame buffer range.
            //

            if (DriverAccessRanges[0].RangeStart.LowPart &&
                VideoPortVerifyAccessRanges(HwDeviceExtension,
                                            1,
                                            DriverAccessRanges) != NO_ERROR)
            {
                //
                // This access range we can't do without
                //

                VideoDebugPrint((1, "FindAdapter : (ERROR) VideoPortVerifyAccessRanges - Failed 2\n"));
                return ERROR_INVALID_PARAMETER;
            }
        }
    }
    else
    {
        //
        // If we get here, then we must have successfully claimed
        // the VGA access ranges.  Lets map them in.
        //

        HwDeviceExtension->Vga =
            VideoPortGetDeviceBase(HwDeviceExtension,
                                   DriverAccessRanges[1].RangeStart,
                                   DriverAccessRanges[1].RangeLength,
                                   DriverAccessRanges[1].RangeInIoSpace);
    }

    //
    // map coproc, frame buffer, and vga ports
    //

    {
        PHYSICAL_ADDRESS Base;

        Base = DriverAccessRanges[0].RangeStart;
        Base.QuadPart += HwDeviceExtension->P9CoprocInfo.CoprocRegOffset;

        HwDeviceExtension->Coproc =
            VideoPortGetDeviceBase(HwDeviceExtension,
                                   Base,
                                   0x100000,
                                   DriverAccessRanges[0].RangeInIoSpace);

        Base = DriverAccessRanges[0].RangeStart;
        Base.QuadPart += HwDeviceExtension->P9CoprocInfo.FrameBufOffset;

        HwDeviceExtension->FrameAddress =
            VideoPortGetDeviceBase(HwDeviceExtension,
                                   Base,
                                   HwDeviceExtension->P9CoprocInfo.AddrSpace -
                                   HwDeviceExtension->P9CoprocInfo.FrameBufOffset,
                                   DriverAccessRanges[0].RangeInIoSpace);
    }

    if( HwDeviceExtension->Coproc == NULL ||
        HwDeviceExtension->FrameAddress == NULL ||
        (HwDeviceExtension->Vga == NULL &&
         HwDeviceExtension->AdapterDesc.bRequiresIORanges))
    {
        VideoDebugPrint((1, "weitekp9: VideoPortGetDeviceBase failed.\n"));

        return ERROR_INVALID_PARAMETER;
    }

    if (CoProcId == P9000_ID)
    {
        //
        // Map all of the DAC registers into system virtual address space.
        // These registers are mapped seperately from the coprocessor and DAC
        // registers since their virtual addresses must be kept in an array
        // at the end of the device extension.
        //

        for (i = 0; i < NUM_DAC_ACCESS_RANGES; i++)
        {
                if ( (HwDeviceExtension->pDACRegs[i] =
                (ULONG)(ULONG_PTR) VideoPortGetDeviceBase(HwDeviceExtension,
                    DriverAccessRanges[i + NUM_DRIVER_ACCESS_RANGES].RangeStart,
                    DriverAccessRanges[i + NUM_DRIVER_ACCESS_RANGES].RangeLength,
                    DriverAccessRanges[i + NUM_DRIVER_ACCESS_RANGES].RangeInIoSpace)) == 0)
            {
                return ERROR_INVALID_PARAMETER;
            }
        }
    }
    else
    {

        for (i = 0; i < NUM_DAC_ACCESS_RANGES; i++)
        {
            HwDeviceExtension->pDACRegs[i] = P91_Bt485_DAC_Regs[i];
        }
    }

    // NOTE: !!! jn 1294
    //       On the P9100 we will always allocate the a full 12 meg
    //       of address space...

    if (CoProcId == P9000_ID)
    {
        //
        // Enable the video memory so it can be sized.
        //

        if (HwDeviceExtension->AdapterDesc.P9EnableMem)
        {
            if (!HwDeviceExtension->AdapterDesc.P9EnableMem(HwDeviceExtension))
            {
                return(FALSE);
            }
        }

        //
        // Determine the amount of video memory installed.
        //

        HwDeviceExtension->P9CoprocInfo.SizeMem(HwDeviceExtension);
    }

    //
    // Detect the DAC type.
    // !!!
    // On the X86, This requires switching into native mode, so the screen
    // will be dark for the remainder of boot.
    //

    if (CoProcId == P9100_ID)
    {
        ULONG   ulPuConfig;


        /*
        ** SNI-Od: Save all VGA registers before we switch
        **         to native mode
        */
        VideoDebugPrint((2, "Before save\n"));

        P91SaveVGARegs(HwDeviceExtension,&VGAregs);
        VideoDebugPrint((2, "After save\n"));
        WeitekP91NapTime();

        // If we have found a serious error, don't go any further.  We have already
        // logged the error if the status is set in HwDeviceExtension

        if ( vpP91AdapterStatus != NO_ERROR )
        {
            P91RestoreVGAregs(HwDeviceExtension,&VGAregs);
            return (ERROR_DEV_NOT_EXIST);
        }

        // Get into Native mode

        if (HwDeviceExtension->usBusType == VESA)
        {
            WriteP9ConfigRegister(HwDeviceExtension, P91_CONFIG_CONFIGURATION, 3);
            VideoDebugPrint((2, "WroteConfig 1\n"));
        }

        WriteP9ConfigRegister(HwDeviceExtension, P91_CONFIG_MODE, 0);
        VideoDebugPrint((2, "WroteConfig 2\n"));
        WeitekP91NapTime();

        HwDeviceExtension->p91State.ulPuConfig = P9_RD_REG(P91_PU_CONFIG);

        // Look to see if it is an Intergraph board - if so, we want to error out

        if ( bIntergraphBoard(HwDeviceExtension) == TRUE )
        {
            vpCurrStatus = P9_INTERGRAPH_FOUND;
            goto error1;
        }

        // Determine the VRAM type:

        HwDeviceExtension->p91State.bVram256 =
            (HwDeviceExtension->p91State.ulPuConfig & P91_PUC_MEMORY_DEPTH)
            ? FALSE : TRUE;

        // Size the memory

        P91SizeVideoMemory(HwDeviceExtension);
        VideoDebugPrint((2, "Sized mem\n"));
        WeitekP91NapTime();

        // Setup the Hardware Device Extension.
        // So the mode counter will work.

        HwDeviceExtension->FrameLength = HwDeviceExtension->p91State.ulFrameBufferSize;

        // Make sure we are supporting the correct DAC.

        ulPuConfig = HwDeviceExtension->p91State.ulPuConfig;

        if ((ulPuConfig & P91_PUC_RAMDAC_TYPE) == P91_PUC_DAC_IBM525)
        {
            if (HwDeviceExtension->Dac.ulDacId != DAC_ID_IBM525)
            {
                VideoDebugPrint((1, "WEITEKP9! WARNING - Detected an IBM525 DAC, Expected a Bt485 DAC\n"));
                goto error1;
            }
        }
        else if ((ulPuConfig & P91_PUC_RAMDAC_TYPE) == P91_PUC_DAC_BT485)
        {
            if (HwDeviceExtension->Dac.ulDacId != DAC_ID_BT485)
            {
                VideoDebugPrint((1, "WEITEKP9! WARNING - Detected an BT485 DAC, Expected an IBM525 DAC\n"));
                goto error1;
            }
        }
        else if ((ulPuConfig & P91_PUC_RAMDAC_TYPE) == P91_PUC_DAC_BT489)
        {
            if (HwDeviceExtension->Dac.ulDacId != DAC_ID_BT489)
            {
                VideoDebugPrint((1, "WEITEKP9! WARNING - Detected an BT489 DAC, Expected an IBM525 DAC\n"));
                goto error1;
            }
        }
        else
        {
            vpCurrStatus = P9_UNSUPPORTED_DAC;
            VideoDebugPrint((1, "WEITEKP9! ERROR - Found P9100, detected an unsupported DAC\n"));
            goto error1;
        }

        /*
        ** SNI-Od: Restore all VGA registers
        ** after we switch back to VGA mode
        */
        VideoDebugPrint((2, "Before 1st write config"));
        WeitekP91NapTime();

        WriteP9ConfigRegister(HwDeviceExtension,P91_CONFIG_MODE,0x2);
        VideoDebugPrint((2, "After wrote config\n"));

        VideoDebugPrint((2, "Before restore\n"));
        WeitekP91NapTime();

        P91RestoreVGAregs(HwDeviceExtension,&VGAregs);
        VideoDebugPrint((2, "After restore\n"));
        WeitekP91NapTime();

    }

    //
    // Set the Chip, Adapter, DAC, and Memory information in the registry.
    //

    DevSetRegistryParams(HwDeviceExtension);


    //
    // Initialize the monitor parameters.
    //

    HwDeviceExtension->CurrentModeNumber = 0;

    //
    // Initialize the pointer state flags.
    //

    HwDeviceExtension->flPtrState = 0;

    //
    // NOTE:
    // Should we free up all the address map we allocated to ourselves ?
    // Do we use them after initialization ???
    //
    // VideoPortFreeDeviceBase(HwDeviceExtension, HwDeviceExtension->Coproc);
    // VideoPortFreeDeviceBase(HwDeviceExtension, HwDeviceExtension->Vga);

    //
    // Indicate a successful completion status.
    //

    VideoDebugPrint((2, "FindAdapter: succeeded\n"));

    if_Not_SIEMENS_P9100_VLB()
        VideoPortFreeDeviceBase(HwDeviceExtension, HwDeviceExtension->FrameAddress);

    InitializeModes(HwDeviceExtension);

    WeitekP91NapTime();
    VideoDebugPrint((2, "return\n"));

    return(NO_ERROR);

    //
    // We get here if we really detected a problem, not a mismatch of configuration
    //

error1:

    if (CoProcId == P9100_ID)
    {
        P91RestoreVGAregs(HwDeviceExtension,&VGAregs);
        VideoDebugPrint((2, "restored vga\n"));
        WeitekP91NapTime();
    }

    if ( vpCurrStatus != NO_ERROR && vpCurrStatus != vpP91AdapterStatus )
    {
        vpP91AdapterStatus = vpCurrStatus;

        VideoPortLogError(HwDeviceExtension,
                          NULL,
                          vpCurrStatus,
                          __LINE__);
    }

#if defined(i386)
    // Switch back to VGA emulation mode
    //
    // We need to do this so that the VGA miniport can start up.
    //

    WriteP9ConfigRegister(HwDeviceExtension, P91_CONFIG_MODE, 0x2);
#endif

    VideoDebugPrint((1, "returning ERROR_DEV_NOT_EXIST\n"));

    return (ERROR_DEV_NOT_EXIST);

} // end FindAdapter()

VOID
DevSetRegistryParams(PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    PUSHORT pwszChip,
            pwszDAC,
            pwszAdapterString;

    ULONG   cbChip,
            cbDAC,
            cbAdapterString,
            AdapterMemorySize;

    //
    // First set the string for the chip type, and set the
    // memory configuration if available.
    //

    if (hwDeviceExtension->P9CoprocInfo.CoprocId == P9000_ID)
    {
        pwszChip = L"Weitek P9000";
        cbChip   = sizeof (L"Weitek P9000");
    }
    else
    {
        pwszChip = L"Weitek P9100";
        cbChip   = sizeof (L"Weitek P9100");
    }

    //
    // Set the memory size
    //

    AdapterMemorySize = hwDeviceExtension->FrameLength;

    //
    // Now, set the string for the DAC type.
    //

    if (hwDeviceExtension->Dac.ulDacId == DAC_ID_BT485)
    {
        pwszDAC = L"Brooktree Bt485";
        cbDAC   = sizeof (L"Brooktree Bt485");
    }
    else if (hwDeviceExtension->Dac.ulDacId == DAC_ID_BT489)
        {
            pwszDAC = L"Brooktree Bt489";
            cbDAC   = sizeof (L"Brooktree Bt489");
    }
    else
    {
        pwszDAC = L"IBM IBM525";
        cbDAC   = sizeof (L"IBM IBM525");
    }

    //
    // Now just pickup the adapter information from the adapter description.
    //

    //
    // Use the length of the longest string !
    //

    pwszAdapterString = hwDeviceExtension->AdapterDesc.ausAdapterIDString;
    cbAdapterString   = sizeof(L"Generic Weitek P9000 VL Adapter");

    //
    // We now have a complete hardware description of the hardware.
    // Save the information to the registry so it can be used by
    // configuration programs - such as the display applet
    //

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.ChipType",
                                   pwszChip,
                                   cbChip);

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.DacType",
                                   pwszDAC,
                                   cbDAC);

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &AdapterMemorySize,
                                   sizeof(ULONG));

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.AdapterString",
                                   pwszAdapterString,
                                   cbAdapterString);
}




BOOLEAN
P9Initialize(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:


    Always returns TRUE since this routine can never fail.

--*/

{

    VideoDebugPrint((2, "P9Initialize ----------\n"));
    return(TRUE);

} // end P9Initialize()


BOOLEAN
P9StartIO(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    acceptss a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    RequestPacket - Pointer to the video request packet. This structure
        contains all the parameters passed to the VideoIoControl function.

Return Value:


--*/

{
    VP_STATUS status;
    PVIDEO_MODE_INFORMATION modeInformation;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    ULONG       inIoSpace;
    PVIDEO_CLUT clutBuffer;
    PVOID       virtualAddr;
    UCHAR       i;
    ULONG       numValidModes;
    ULONG       ulMemoryUsage;

    // VideoDebugPrint((2, "StartIO ----------\n"));

    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //

    switch (RequestPacket->IoControlCode)
    {


        case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:

            VideoDebugPrint((2, "P9StartIO - IOCTL_QUERY_PUBLIC_ACCESS_RANGES\n"));

            if (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information =
                sizeof(VIDEO_PUBLIC_ACCESS_RANGES)) )
            {

                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

#if 0
            vDumpPCIConfig(HwDeviceExtension,
                           "P9StartIo - IOCTL_QUERY_PUBLIC_ACCESS_RANGES");
#endif

            // map the coproc to a virtual address

            //
            // Note that on the Alpha we have to map this in sparse-space
            // because dense-space requires all reads to be 64 bits, which
            // would give us unintended side effects using the Weitek
            // registers.
            //

            {
                PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
                ULONG CoprocSize = 0x100000;

                portAccess = RequestPacket->OutputBuffer;

                portAccess->InIoSpace = FALSE;
                portAccess->MappedInIoSpace = portAccess->InIoSpace;
                portAccess->VirtualAddress = NULL;

                status = VideoPortMapMemory(HwDeviceExtension,
                                            HwDeviceExtension->CoprocPhyAddr,
                                            &CoprocSize,
                                            &(portAccess->MappedInIoSpace),
                                            &(portAccess->VirtualAddress));

                HwDeviceExtension->CoprocVirtAddr = portAccess->VirtualAddress;
            }

            status = NO_ERROR;

            break;


        case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:

            VideoDebugPrint((2, "P9StartIO - FreePublicAccessRanges\n"));

            {
                PVIDEO_MEMORY mappedMemory;

                if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) {

                    status = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }

                mappedMemory = RequestPacket->InputBuffer;
                status = NO_ERROR;

                if (mappedMemory->RequestedVirtualAddress != NULL)
                {
                    status = VideoPortUnmapMemory(HwDeviceExtension,
                                                  mappedMemory->
                                                      RequestedVirtualAddress,
                                                  0);
                }

            }

            break;


        case IOCTL_VIDEO_MAP_VIDEO_MEMORY:

            VideoDebugPrint((2, "P9StartIO - MapVideoMemory\n"));

            if ( (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MEMORY_INFORMATION))) ||
                (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
            {

                status = ERROR_INSUFFICIENT_BUFFER;
            }

            memoryInformation = RequestPacket->OutputBuffer;

            memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
                    (RequestPacket->InputBuffer))->RequestedVirtualAddress;

            memoryInformation->VideoRamLength = HwDeviceExtension->FrameLength;

        #ifdef ALPHA

            //
            // On the Alpha, we map the frame buffer in dense-space so that
            // we can have GDI draw directly on the surface when we need it
            // to.
            //

            inIoSpace = 4;

        #else

            inIoSpace = 0;

        #endif

            status = VideoPortMapMemory(HwDeviceExtension,
                                        HwDeviceExtension->PhysicalFrameAddr,
                                        &(memoryInformation->VideoRamLength),
                                        &inIoSpace,
                                        &(memoryInformation->VideoRamBase));

            //
            // The frame buffer and virtual memory and equivalent in this
            // case.
            //

            memoryInformation->FrameBufferBase =
                memoryInformation->VideoRamBase;

            memoryInformation->FrameBufferLength =
                memoryInformation->VideoRamLength;

            break;


        case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

            VideoDebugPrint((2, "P9StartIO - UnMapVideoMemory\n"));

            if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
        {
                status = ERROR_INSUFFICIENT_BUFFER;
            }

            status = VideoPortUnmapMemory(HwDeviceExtension,
                                        ((PVIDEO_MEMORY)
                                        (RequestPacket->InputBuffer))->
                                            RequestedVirtualAddress,
                                        0);

            break;


        case IOCTL_VIDEO_QUERY_CURRENT_MODE:

            VideoDebugPrint((2, "P9StartIO - QueryCurrentModes\n"));

            modeInformation = RequestPacket->OutputBuffer;

            if (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MODE_INFORMATION)) )
            {
                status = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {

                *((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer) =
                    P9Modes[HwDeviceExtension->CurrentModeNumber].modeInformation;

                ((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer)->Frequency =
                    HwDeviceExtension->VideoData.vlr;

                if (HwDeviceExtension->P9CoprocInfo.CoprocId == P9000_ID)
                {
                    ((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer)->DriverSpecificAttributeFlags =
                        CAPS_WEITEK_CHIPTYPE_IS_P9000;
                }
                else
                {
                    ((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer)->DriverSpecificAttributeFlags =
                        0;
                }

                status = NO_ERROR;
            }

            break;

        case IOCTL_VIDEO_QUERY_AVAIL_MODES:

            VideoDebugPrint((2, "P9StartIO - QueryAvailableModes\n"));

            numValidModes = HwDeviceExtension->ulNumAvailModes;

            if (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information =
                    numValidModes * sizeof(VIDEO_MODE_INFORMATION)) )
            {
                status = ERROR_INSUFFICIENT_BUFFER;

            }
            else
            {
                ULONG Flags=0;

                if (HwDeviceExtension->P9CoprocInfo.CoprocId == P9000_ID)
                {
                    Flags = CAPS_WEITEK_CHIPTYPE_IS_P9000;
                }

                modeInformation = RequestPacket->OutputBuffer;

                for (i = 0; i < mP9ModeCount; i++)
                {
                    if (P9Modes[i].valid == TRUE)
                    {
                        *modeInformation = P9Modes[i].modeInformation;
                        modeInformation->DriverSpecificAttributeFlags = Flags;
                        modeInformation++;
                    }
                }

                status = NO_ERROR;
            }

            break;


    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((2, "P9StartIO - QueryNumAvailableModes\n"));

        //
        // Find out the size of the data to be put in the the buffer and
        // return that in the status information (whether or not the
        // information is there). If the buffer passed in is not large
        // enough return an appropriate error code.
        //
        // !!! This must be changed to take into account which monitor
        // is present on the machine.
        //

        if (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information =
                                                sizeof(VIDEO_NUM_MODES)) )
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->NumModes =
                    HwDeviceExtension->ulNumAvailModes;

            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->ModeInformationLength =
                sizeof(VIDEO_MODE_INFORMATION);

            status = NO_ERROR;
        }

        break;


    case IOCTL_VIDEO_SET_CURRENT_MODE:

        VideoDebugPrint((2, "P9StartIO - SetCurrentMode\n"));

        //
        // verify data
        // !!! Make sure it is one of the valid modes on the list
        // calculated using the monitor information.
        //

        if (((PVIDEO_MODE)(RequestPacket->InputBuffer))->RequestedMode
            >= mP9ModeCount)
        {
            status = ERROR_INVALID_PARAMETER;
            break;
        }

        HwDeviceExtension->CurrentModeNumber =
            *(ULONG *)(RequestPacket->InputBuffer);

        DevInitP9(HwDeviceExtension);

#if 0
        vDumpPCIConfig(HwDeviceExtension,
                       "P9StartIo - IOCTL_VIDEO_SET_CURRENT_MODE");
#endif

        status = NO_ERROR;

        break;


    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        VideoDebugPrint((2, "P9StartIO - SetColorRegs\n"));

        clutBuffer = RequestPacket->InputBuffer;

        //
        // Check if the size of the data in the input buffer is large enough.
        //

        if ( (RequestPacket->InputBufferLength < sizeof(VIDEO_CLUT) -
                    sizeof(ULONG)) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_CLUT) +
                    (sizeof(ULONG) * (clutBuffer->NumEntries - 1)) ) )
        {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        if (P9Modes[HwDeviceExtension->CurrentModeNumber].
                modeInformation.BitsPerPlane == 8)
        {

            HwDeviceExtension->Dac.DACSetPalette(HwDeviceExtension,
                                                        (PULONG)clutBuffer->LookupTable,
                                                        clutBuffer->FirstEntry,
                                                        clutBuffer->NumEntries);

            status = NO_ERROR;
        }
        break;



    case IOCTL_VIDEO_ENABLE_POINTER:
    {

        ULONG   iCount = (CURSOR_WIDTH * CURSOR_HEIGHT * 2) /  8;
        ULONG   xInitPos, yInitPos;

        VideoDebugPrint((2, "P9StartIO - EnablePointer\n"));

        xInitPos = P9Modes[HwDeviceExtension->CurrentModeNumber].
                        modeInformation.VisScreenWidth / 2;
        yInitPos = P9Modes[HwDeviceExtension->CurrentModeNumber].
                        modeInformation.VisScreenHeight / 2;

        HwDeviceExtension->Dac.HwPointerSetPos(HwDeviceExtension, xInitPos, yInitPos);
        HwDeviceExtension->Dac.HwPointerOn(HwDeviceExtension);

        status = NO_ERROR;
        break;

    case IOCTL_VIDEO_DISABLE_POINTER:

        VideoDebugPrint((2, "P9StartIO - DisablePointer\n"));

        HwDeviceExtension->Dac.HwPointerOff(HwDeviceExtension);

        status = NO_ERROR;

        break;

    }


    case IOCTL_VIDEO_SET_POINTER_POSITION:
    {

        PVIDEO_POINTER_POSITION pointerPosition;

        pointerPosition = RequestPacket->InputBuffer;

        //
        // Check if the size of the data in the input buffer is large enough.
        //

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_POINTER_POSITION))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HwDeviceExtension->ulPointerX = (ULONG)pointerPosition->Row;
            HwDeviceExtension->ulPointerY = (ULONG)pointerPosition->Column;

            HwDeviceExtension->Dac.HwPointerSetPos(HwDeviceExtension,
                                                (ULONG)pointerPosition->Column,
                                                            (ULONG)pointerPosition->Row);

            status = NO_ERROR;
        }

        break;

    }


    case IOCTL_VIDEO_QUERY_POINTER_POSITION:
    {

        PVIDEO_POINTER_POSITION pPointerPosition = RequestPacket->OutputBuffer;

        VideoDebugPrint((2, "P9StartIO - QuerypointerPostion\n"));

        //
        // Make sure the output buffer is big enough.
        //

        if (RequestPacket->OutputBufferLength < sizeof(VIDEO_POINTER_POSITION))
        {
            RequestPacket->StatusBlock->Information = 0;
            return ERROR_INSUFFICIENT_BUFFER;
        }

        //
        // Return the pointer position
        //

        pPointerPosition->Row = (SHORT)HwDeviceExtension->ulPointerX;
        pPointerPosition->Column = (SHORT)HwDeviceExtension->ulPointerY;

        RequestPacket->StatusBlock->Information =
                sizeof(VIDEO_POINTER_POSITION);

        status = NO_ERROR;

        break;

    }

    case IOCTL_VIDEO_SET_POINTER_ATTR:    // Set pointer shape
    {

        PVIDEO_POINTER_ATTRIBUTES pointerAttributes;
        UCHAR *pHWCursorShape;            // Temp Buffer

        VideoDebugPrint((2, "P9StartIO - SetPointerAttributes\n"));

        pointerAttributes = RequestPacket->InputBuffer;

        //
        // Check if the size of the data in the input buffer is large enough.
        //

        if (RequestPacket->InputBufferLength <
                (sizeof(VIDEO_POINTER_ATTRIBUTES) + ((sizeof(UCHAR) *
                (CURSOR_WIDTH/8) * CURSOR_HEIGHT) * 2)))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }

        //
        // If the specified cursor width or height is not valid, then
        // return an invalid parameter error.
        //

        else if ((pointerAttributes->Width > CURSOR_WIDTH) ||
            (pointerAttributes->Height > CURSOR_HEIGHT))
        {
            status = ERROR_INVALID_PARAMETER;
        }

        else if (pointerAttributes->Flags & VIDEO_MODE_MONO_POINTER)
        {
            pHWCursorShape = (PUCHAR) &pointerAttributes->Pixels[0];

            //
            // If this is an animated pointer, don't turn the hw
            // pointer off. This will eliminate cursor blinking.
            // Since GDI currently doesn't pass the ANIMATE_START
            // flag, also check to see if the state of the
            // ANIMATE_UPDATE flag has changed from the last call.
            // If it has, turn the pointer off to eliminate ptr
            // "jumping" when the ptr shape is changed.
            //

            if (!(pointerAttributes->Flags & VIDEO_MODE_ANIMATE_UPDATE) ||
                ((HwDeviceExtension->flPtrState ^
                pointerAttributes->Flags) & VIDEO_MODE_ANIMATE_UPDATE))
            {
                HwDeviceExtension->Dac.HwPointerOff(HwDeviceExtension);
            }

            //
            // Update the cursor state flags in the Device Extension.
            //

            HwDeviceExtension->flPtrState = pointerAttributes->Flags;

            HwDeviceExtension->Dac.HwPointerSetShape(HwDeviceExtension,
                                                        pHWCursorShape);
            HwDeviceExtension->Dac.HwPointerSetPos(HwDeviceExtension,
                                                    (ULONG)pointerAttributes->Column,
                                                    (ULONG)pointerAttributes->Row);


            HwDeviceExtension->Dac.HwPointerOn(HwDeviceExtension);

            status = NO_ERROR;

            break;
        }
        else
        {
            //
            // This cursor is unsupported. Return an error.
            //

            status = ERROR_INVALID_PARAMETER;

    }

    //
    // Couldn't set the new cursor shape. Ensure that any existing HW
    // cursor is disabled.
    //

    HwDeviceExtension->Dac.HwPointerOff(HwDeviceExtension);

    break;

    }

    case IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES:
    {

    PVIDEO_POINTER_CAPABILITIES pointerCaps = RequestPacket->OutputBuffer;

        VideoDebugPrint((2, "P9StartIO - QueryPointerCapabilities\n"));

        if (RequestPacket->OutputBufferLength < sizeof(VIDEO_POINTER_CAPABILITIES))
    {
            RequestPacket->StatusBlock->Information = 0;
            status = ERROR_INSUFFICIENT_BUFFER;
        }

        pointerCaps->Flags = VIDEO_MODE_MONO_POINTER;
        pointerCaps->MaxWidth = CURSOR_WIDTH;
        pointerCaps->MaxHeight = CURSOR_HEIGHT;
        pointerCaps->HWPtrBitmapStart = 0;        // No VRAM storage for pointer
        pointerCaps->HWPtrBitmapEnd = 0;

        //
        // Number of bytes we're returning.
        //

        RequestPacket->StatusBlock->Information = sizeof(VIDEO_POINTER_CAPABILITIES);

        status = NO_ERROR;

        break;

    }

    case IOCTL_VIDEO_RESET_DEVICE:

        VideoDebugPrint((2, "P9StartIO - RESET_DEVICE\n"));

        DevDisableP9(HwDeviceExtension, FALSE);

        status = NO_ERROR;

        break;

    case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:
    {
        PVIDEO_SHARE_MEMORY pShareMemory;
        PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
        PHYSICAL_ADDRESS shareAddress;
        PVOID virtualAddress;
        ULONG sharedViewSize;

        VideoDebugPrint((2, "P9StartIo - ShareVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength < sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

            VideoDebugPrint((1, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        pShareMemory = RequestPacket->InputBuffer;

        if ( (pShareMemory->ViewOffset > HwDeviceExtension->FrameLength) ||
             ((pShareMemory->ViewOffset + pShareMemory->ViewSize) >
                  HwDeviceExtension->FrameLength) ) {

            VideoDebugPrint((1, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INVALID_PARAMETER\n"));
            status = ERROR_INVALID_PARAMETER;
            break;
        }

        RequestPacket->StatusBlock->Information =
                                    sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

        //
        // Beware: the input buffer and the output buffer are the same
        // buffer, and therefore data should not be copied from one to the
        // other
        //

        virtualAddress = pShareMemory->ProcessHandle;
        sharedViewSize = pShareMemory->ViewSize;

        #ifdef ALPHA

            //
            // On the Alpha, we map the frame buffer in dense-space so that
            // we can have GDI draw directly on the surface when we need it
            // to.
            //

            inIoSpace = 4;

        #else

            inIoSpace = 0;

        #endif

        //
        // NOTE: we are ignoring ViewOffset
        //

        shareAddress.QuadPart =
            HwDeviceExtension->PhysicalFrameAddr.QuadPart;

        //
        // The frame buffer is always mapped linearly.
        //

        status = VideoPortMapMemory(HwDeviceExtension,
                                    shareAddress,
                                    &sharedViewSize,
                                    &inIoSpace,
                                    &virtualAddress);

        pShareMemoryInformation = RequestPacket->OutputBuffer;

        pShareMemoryInformation->SharedViewOffset = pShareMemory->ViewOffset;
        pShareMemoryInformation->VirtualAddress = virtualAddress;
        pShareMemoryInformation->SharedViewSize = sharedViewSize;

        break;

    }

    case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:
    {
        PVIDEO_SHARE_MEMORY pShareMemory;

        VideoDebugPrint((2, "P9StartIo - UnshareVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;

        }

        pShareMemory = RequestPacket->InputBuffer;

        status = VideoPortUnmapMemory(HwDeviceExtension,
                                      pShareMemory->RequestedVirtualAddress,
                                      pShareMemory->ProcessHandle);

        break;

    }

    //
    // if we get here, an invalid IoControlCode was specified.
    //

    default:

        VideoDebugPrint((1, "Fell through P9 startIO routine - invalid command\n"));

        status = ERROR_INVALID_FUNCTION;

        break;

    }

    RequestPacket->StatusBlock->Status = status;

    return(TRUE);

} // end P9StartIO()


VOID
DevInitP9(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Sets the video mode described in the device extension.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

--*/


{

    VideoDebugPrint((2, "DevInitP9 ----------\n"));

    //
    // Copy the default parameters for this resolution mode into the
    // device extension.
    //

    VideoPortMoveMemory((PVOID) &(HwDeviceExtension->VideoData),
                        (PVOID) P9Modes[HwDeviceExtension->CurrentModeNumber].pvData,
                        sizeof(VDATA));

    //
    // Store the requested Bits/Pixel value in the video parms structure
    // in the Device Extension.
    //

    HwDeviceExtension->usBitsPixel =
        P9Modes[HwDeviceExtension->CurrentModeNumber].modeInformation.BitsPerPlane *
        P9Modes[HwDeviceExtension->CurrentModeNumber].modeInformation.NumberOfPlanes;

    HwDeviceExtension->AdapterDesc.OEMSetMode(HwDeviceExtension);

    if (HwDeviceExtension->P9CoprocInfo.CoprocId == P9000_ID)
    {
        Init8720(HwDeviceExtension);

        //
        // Initialize the P9000 system configuration register.
        //

        SysConf(HwDeviceExtension);

        //
        // Set the P9000 Crtc timing registers.
        //

        WriteTiming(HwDeviceExtension);
    }
    else
    {
        InitP9100(HwDeviceExtension);
        P91_SysConf(HwDeviceExtension);
        P91_WriteTiming(HwDeviceExtension);
    }


    VideoDebugPrint((2, "DevInitP9  ---done---\n"));
}



BOOLEAN
P9ResetVideo(
    IN PVOID HwDeviceExtension,
    IN ULONG Columns,
    IN ULONG Rows
    )

/*++

routine description:

    disables the P9 and turns on vga pass-thru.

    This function is exported as the HwResetHw entry point so that it may be
    called by the Video Port driver
    at bugcheck time so that VGA video may be enabled.

arguments:

    hwdeviceextension - pointer to the miniport driver's device extension.
    Columns - Number of columns for text mode (not used).
    Rows - Number of rows for text mode (not used).

return value:

    Always returns FALSE so that the Video Port driver will call Int 10 to
    set the desired video mode.

--*/

{
    DevDisableP9(HwDeviceExtension, TRUE);

    //
    // Tell the Video Port driver to do an Int 10 mode set.
    //

    return(FALSE);
}

VOID
DevDisableP9(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    BOOLEAN BugCheck
    )
{
    PHYSICAL_ADDRESS Base;
    BOOLEAN bResetComplete;

    //
    // Clean up the DAC.
    //

    HwDeviceExtension->Dac.DACRestore(HwDeviceExtension);

    //
    // If we are not about to "bugcheck", then clear out
    // video memory.
    //
    // NOTE: On the alpha, the attempt to clear video memory causes
    //       the machine to hang.  So, we just won't clear the memory
    //       on the alpha.
    //

#if !defined(_ALPHA_)

    if (BugCheck == FALSE)
    {
        Base = DriverAccessRanges[0].RangeStart;
        Base.QuadPart += HwDeviceExtension->P9CoprocInfo.FrameBufOffset;

        HwDeviceExtension->FrameAddress =
            VideoPortGetDeviceBase(HwDeviceExtension,
                                   Base,
                                   HwDeviceExtension->P9CoprocInfo.AddrSpace -
                                   HwDeviceExtension->P9CoprocInfo.FrameBufOffset,
                                   DriverAccessRanges[0].RangeInIoSpace);

        if (HwDeviceExtension->FrameAddress != NULL)
        {
            VideoDebugPrint((2, "Weitekp9: Clearing video memory.\n"));

            VideoPortZeroMemory(HwDeviceExtension->FrameAddress,
                                HwDeviceExtension->FrameLength);

            VideoPortFreeDeviceBase(HwDeviceExtension, HwDeviceExtension->FrameAddress);
        }
    }

#endif

    // NOTE: On the P9100 we must take care of the DAC before
    //       we change the mode to emulation.
    //       !!! This must be tested on the P9000

    bResetComplete = HwDeviceExtension->AdapterDesc.P9DisableVideo(HwDeviceExtension);

    //
    // We only want to call int10 if the reset function needs some help and
    // we are not in bugcheck mode, because int10 does not work in bugcheck
    // mode.
    //

    if ((bResetComplete == FALSE) &&
        (BugCheck == FALSE))
    {

#ifndef PPC

        VIDEO_X86_BIOS_ARGUMENTS biosArguments;

        //
        // Now simply do an int10 and switch to mode 3.  The video BIOS
        // will do the work.
        //

        VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        biosArguments.Eax = 0x0003;

        VideoPortInt10(HwDeviceExtension, &biosArguments);

#endif

    }
}

VOID
InitializeModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine walks through the list of modes, and determines which
    modes will work with our hardware.  It sets a flag for each mode
    which will work, and places the number of valid modes in the
    HwDeviceExtension.

Arguments:

    HwDeviceExtension - pointer to the miniport driver's device extension.
    Columns - Number of columns for text mode (not used).
    Rows - Number of rows for text mode (not used).

Return Value:

    none

--*/

{
    int i;
    ULONG numValidModes=0;

    for(i=0; i<mP9ModeCount; i++)
    {
        if ((HwDeviceExtension->FrameLength >=
             P9Modes[i].modeInformation.ScreenStride *
             P9Modes[i].modeInformation.VisScreenHeight) &&
            (HwDeviceExtension->P9CoprocInfo.CoprocId &
             P9Modes[i].ulChips) &&
             ((P9Modes[i].modeInformation.BitsPerPlane != 24) || 
              (HwDeviceExtension->Dac.bRamdac24BPP)) )
        {

            if_SIEMENS_VLB()
            {
                P9Modes[i].modeInformation.AttributeFlags |=
                    VIDEO_MODE_NO_64_BIT_ACCESS;
            }

            P9Modes[i].valid = TRUE;
            numValidModes++;
        }
    }

    //
    // store the number of valid modes in the HwDeviceExtension
    // so we can quickly look it up later when we need it.
    //

    HwDeviceExtension->ulNumAvailModes = numValidModes;
}

//
//  Global Functions.
//

long mul32(
    short op1,
    short op2
    )
{
    return ( ((long) op1) * ((long) op2));
}

int div32(
    long op1,
    short op2
    )
{
    return ( (int) (op1 / (long) op2));
}

#if (_WIN32_WINNT >= 500)

//
// Routine to set a desired DPMS power management state.
//
VP_STATUS
WP9SetPower50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    )
{
    if ((pVideoPowerMgmt->PowerState == VideoPowerOn) ||
        (pVideoPowerMgmt->PowerState == VideoPowerHibernate) ||
        (pVideoPowerMgmt->PowerState == VideoPowerStandBy)
       ) {

        return NO_ERROR;

    } else {

        return ERROR_INVALID_FUNCTION;
    }
}

//
// Routine to retrieve possible DPMS power management states.
//
VP_STATUS
WP9GetPower50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    )
{
    if ((pVideoPowerMgmt->PowerState == VideoPowerOn) ||
        (pVideoPowerMgmt->PowerState == VideoPowerHibernate)) {

        return NO_ERROR;

    } else {

        return ERROR_INVALID_FUNCTION;
    }
}


//
// Routine to retrieve the Enhanced Display ID structure via DDC
//
ULONG
WP9GetVideoChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    )
{
    PHW_DEVICE_EXTENSION pHwDeviceExtension = HwDeviceExtension;
    ULONG                Status;

    ASSERT(pHwDeviceExtension != NULL && pMoreChildren != NULL);

    VideoDebugPrint((2, "weitekp9 GetVideoChildDescriptor: *** Entry point ***\n"));

    //
    // Determine if the graphics adapter in the system supports
    // DDC2 (our miniport only supports DDC2, not DDC1). This has
    // the side effect (assuming both monitor and card support
    // DDC2) of switching the monitor from DDC1 mode (repeated
    // "blind" broadcast of EDID clocked by the vertical sync
    // signal) to DDC2 mode (query/response not using any of the
    // normal video lines - can transfer information rapidly
    // without first disrupting the screen by switching into
    // a pseudo-mode with a high vertical sync frequency).
    //
    // Since we must support hot-plugging of monitors, and our
    // routine to obtain the EDID structure via DDC2 assumes that
    // the monitor is in DDC2 mode, we must make this test each
    // time this entry point is called.
    //

    switch (ChildEnumInfo->ChildIndex) {
    case 0:

        //
        // Case 0 is used to enumerate devices found by the ACPI firmware.
        //
        // Since we do not support ACPI devices yet, we must return failure.
        //

        Status = ERROR_NO_MORE_DEVICES;
        break;

    case 1:

        //
        // We do not support monitor enumeration
        //

        Status = ERROR_NO_MORE_DEVICES;
        break;

    case DISPLAY_ADAPTER_HW_ID:
    {

        PUSHORT     pPnpDeviceDescription = NULL;
        ULONG       stringSize            = sizeof(L"*PNPXXXX");


        //
        // Special ID to handle return legacy PnP IDs for root enumerated
        // devices.
        //

        *pChildType = VideoChip;
        *pHwId      = DISPLAY_ADAPTER_HW_ID;

        //
        //  Figure out which card type and set pPnpDeviceDescription at
        //  associated string.
        //

        //  WTK_9100_ID     0x0002
        if (pHwDeviceExtension->P9CoprocInfo.CoprocId == P9100_ID)
            pPnpDeviceDescription = L"*PNP0002";

        //  WTK_9002_ID     0x9002
        else if (pHwDeviceExtension->P9CoprocInfo.CoprocId == P9000_ID )
            pPnpDeviceDescription = L"*PNP9002";

        else {
                VideoDebugPrint((1, "weitekp9.sys coprocId:%x\n",
                                 pHwDeviceExtension->P9CoprocInfo.CoprocId));
             }
        //
        //  Now just copy the string into memory provided.
        //

        if (pPnpDeviceDescription)
            memcpy(pvChildDescriptor, pPnpDeviceDescription, stringSize);

        Status = ERROR_MORE_DATA;
        break;
        }

    default:

        Status = ERROR_NO_MORE_DEVICES;
        break;
    }

    return Status;
}

#endif  // _WIN32_WINNT >= 500
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\clock.h ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    clock.h

Abstract:

    This module contains clock generator specific functions for the
    Weitek P9 miniport device driver.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

//
// Masks used to program the ICD2061a Frequency Synthesizer.
//

#define IC_REG0     0x0l       // Mask selects ICD Video Clock Reg 1
#define IC_REG1     0x200000l  // Mask selects ICD Video Clock Reg 2
#define IC_REG2     0x400000l  // Mask selects ICD Video Clock Reg 3
#define IC_MREG     0x600000l  // Mask selects ICD Mem Timing Clock
#define IC_CNTL     0xc18000l  // Mask selects ICD Control Register
#define IC_DIV4     0xa40000l

//
// These values are used to program custom frequencies
// and to select a custom frequency.
//
#define ICD2061_EXTSEL9100     (0x03)
#define ICD2061_DATA9100       (0x02)
#define ICD2061_DATASHIFT9100  (0x01)
#define ICD2061_CLOCK9100      (0x01)

//
// Define macros to access the ICD register. These macros take advantage
// of the fact that the synth bits are the same for the Weitek, Viper, and
// Ajax boards. The only difference is that the Ajax board's ICD register
// is mapped to a different base address.
//

#define WR_ICD(value)   VGA_WR_REG(MISCOUT, (value))

#define RD_ICD()        VGA_RD_REG(MISCIN)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\bt485.h ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    Bt485.h

Abstract:

    This module contains the Bt485 specific DAC definitions for the
    Weitek P9 miniport device driver.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

//
// Define the relative offset of each of the Bt485 registers in the
// DACRegisters array found in the Device Extension.
//

typedef enum
{
    RS_0,
    RS_1,
    RS_2,
    RS_3,
    RS_4,
    RS_5,
    RS_6,
    RS_7,
    RS_8,
    RS_9,
    RS_A,
    RS_B,
    RS_C,
    RS_D,
    RS_E,
    RS_F,
    NUM_DAC_REGS
} DAC_REG_INDEX;

//
// The following definitions provide a readable means of referencing the
// Bt485 registers via their virtual addresses found in the
// HwDeviceExtension.
//

#define PAL_WR_ADDR_REG     HwDeviceExtension->pDACRegs[RS_0]
#define PAL_DATA_REG        HwDeviceExtension->pDACRegs[RS_1]
#define PIXEL_MSK_REG       HwDeviceExtension->pDACRegs[RS_2]
#define PAL_RD_ADDR_REG     HwDeviceExtension->pDACRegs[RS_3]
#define CURS_CLR_ADDR       HwDeviceExtension->pDACRegs[RS_4]
#define CURS_CLR_DATA       HwDeviceExtension->pDACRegs[RS_5]
#define CMD_REG_0           HwDeviceExtension->pDACRegs[RS_6]
#define CLR_RD_ADDR_REG     HwDeviceExtension->pDACRegs[RS_7]
#define CMD_REG_1           HwDeviceExtension->pDACRegs[RS_8]
#define CMD_REG_2           HwDeviceExtension->pDACRegs[RS_9]
#define CMD_REG_3           HwDeviceExtension->pDACRegs[RS_A]
#define CURS_DATA_REG       HwDeviceExtension->pDACRegs[RS_B]
#define CURS_X              HwDeviceExtension->pDACRegs[RS_C]
#define CURS_X_HI           HwDeviceExtension->pDACRegs[RS_D]
#define CURS_Y              HwDeviceExtension->pDACRegs[RS_E]
#define CURS_Y_HI           HwDeviceExtension->pDACRegs[RS_F]

//
// Bit definitions for CMD_REG_0.
//

#define ENB_CMD_REG_3  0x80
#define DIS_CMD_REG_3  0x00
#define MODE_8_BIT     0x02

//
// Bit definitions for CMD_REG_1.
//

#define PIX_PORT_24 0x60
#define PIX_PORT_8  0x40
#define PIX_PORT_16 0x30
#define PIX_PORT_32 0x10


//
// Bit definitions for CMD_REG_2.
//

#define SCLK_INV        0x40	  // Bt489 - invert SCLK if in forbidden region
#define SCLK_NORM       ~SCLK_INV
#define PORTSEL_MSKD    0x20
#define PCLK1_SEL       0x10
#define PCLK0_SEL       ~PCLK1_SEL
#define CURS_ACTIVE     0x03
#define ENB_CURS        0x02
#define DIS_CURS        ~CURS_ACTIVE

//
// Bit definitions for CMD_REG_3.
//

#define CUR_MODE_64 0x04
#define CUR_MODE_32 ~CUR_MODE_64
#define DAC_CLK_2X  0x08
#define DAC_CLK_2X_489  0x80      // per os2 driver code - undocumented for Bt489
#define CUR_REG_IND_MSK ~0x03

//
// Bit definitions for CMD_REG_4 on Bt489.
//

#define MUX_485_COMPAT   (0x00<<4)   // 485 compatible value - set at reset
#define CR4_MUX_81       (0x02<<4)	 // 489 8:1 mux mode (8  bpp)
#define CR4_MUX_41       (0x03<<4)	 // 489 4:1 mux mode (16 bpp)
#define CR4_MUX_21       (0x04<<4)	 // 489 2:1 mux mode (32 bpp)
#define CR4_MUX_24BPP    (0x07<<4)	 // 489 24 bpp mux mode (24 bpp)
#define CR4_MUX_BITS     (0x07<<4)

//
// Bit definitions for PAL_WR_ADDR to enable CMD_REG_3.
//

#define CMD_REG_3_ENB 0x01
#define CMD_REG_3_DIS 0x00

//
// Bit definitions for PAL_WR_ADDR to enable CMD_REG_4 on Bt489.
//

#define CMD_REG_4_ENB 0x02
#define CMD_REG_4_DIS 0x00

//
// Max clock frequency supported w/o clock doubling.
//
//

#define CLK_MAX_FREQ        6750
#define CLK489_MAX_FREQ     8500

//
// General purpose macros for accessing the DAC registers.
//


//
// Macros for accessing the palette registers.
//

extern VOID
WriteDAC(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG ulIndex,
    UCHAR ucValue
    );

extern UCHAR
ReadDAC(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG ulIndex
    );

#define RD_DAC(addr) \
   ReadDAC(HwDeviceExtension, (ULONG) addr)

#define WR_DAC(addr, data) \
   WriteDAC(HwDeviceExtension, (ULONG) addr, (UCHAR) (data))

#define PAL_WR_ADDR(data) \
   WriteDAC(HwDeviceExtension, PAL_WR_ADDR_REG, (data))

#define PAL_WR_DATA(data) \
   WriteDAC(HwDeviceExtension, PAL_DATA_REG, (data))

//
// Macros for accessing the command register 3.
//

#define WR_CMD_REG_3(data) \
    WR_DAC(CMD_REG_0, RD_DAC(CMD_REG_0) | ENB_CMD_REG_3); \
    PAL_WR_ADDR(CMD_REG_3_ENB); \
    WR_DAC(CMD_REG_3, (data)); \
    PAL_WR_ADDR(CMD_REG_3_DIS)

#define RD_CMD_REG_3(data) \
    WR_DAC(CMD_REG_0, RD_DAC(CMD_REG_0) | ENB_CMD_REG_3); \
    PAL_WR_ADDR(CMD_REG_3_ENB); \
    data = RD_DAC(CMD_REG_3); \
    PAL_WR_ADDR(CMD_REG_3_DIS)

//
// Macros for accessing the command register 4 on Bt489 DAC.
//

#define WR_CMD_REG_4(data) \
    WR_DAC(CMD_REG_0, RD_DAC(CMD_REG_0) | ENB_CMD_REG_3); \
    PAL_WR_ADDR(CMD_REG_4_ENB); \
    WR_DAC(CMD_REG_3, (data)); \
    PAL_WR_ADDR(CMD_REG_4_DIS)

#define RD_CMD_REG_4(data) \
    WR_DAC(CMD_REG_0, RD_DAC(CMD_REG_0) | ENB_CMD_REG_3); \
    PAL_WR_ADDR(CMD_REG_4_ENB); \
    data = RD_DAC(CMD_REG_3); \
    PAL_WR_ADDR(CMD_REG_4_DIS)

//
// Macros for accessing the hardware cursor registers.
//

#define WR_CURS_POS_X(pos) \
    WR_DAC(CURS_X, (UCHAR) pos); \
    WR_DAC(CURS_X_HI, (UCHAR) (pos >> 8))

#define WR_CURS_POS_Y(pos) \
    WR_DAC(CURS_Y, (UCHAR) pos); \
    WR_DAC(CURS_Y_HI, (UCHAR) (pos >> 8))

#define WR_CURS_DATA(data) \
    WR_DAC(CURS_DATA_REG, (data))


#define CURS_IS_ON() \
    (RD_DAC(CMD_REG_2) & CURS_ACTIVE)

#define CURS_ON() \
    WR_DAC(CMD_REG_2, RD_DAC(CMD_REG_2) | ENB_CURS)

#define CURS_OFF() \
    WR_DAC(CMD_REG_2, RD_DAC(CMD_REG_2) & DIS_CURS)


//
// Function Prototypes for the Bt485 DAC which are defined in BT485.C.
//
//
// Bt485 function prototypes.
//

VOID
Bt485SetPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG *pPal,
    ULONG StartIndex,
    ULONG Count
    );

VOID
Bt485SetPointerPos(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG   ptlX,
    ULONG   ptlY
    );

VOID
Bt485SetPointerShape(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR  pHWCursorShape
    );

VOID
Bt485PointerOn(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
Bt485PointerOff(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
Bt485ClearPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
Bt485SetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
Bt485RestoreMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
Bt485SetClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
Bt485ClrClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


//
// Function Prototypes for the Bt489 DAC which are defined in P91BT489.C.
//
//
// Bt489 function prototypes.
//

VOID
Bt489SetPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG *pPal,
    ULONG StartIndex,
    ULONG Count
    );

VOID
Bt489SetPointerPos(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG   ptlX,
    ULONG   ptlY
    );

VOID
Bt489SetPointerShape(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR  pHWCursorShape
    );

VOID
Bt489PointerOn(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
Bt489PointerOff(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
Bt489ClearPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
Bt489SetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
Bt489RestoreMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
Bt489SetClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
Bt489ClrClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\ibm525.h ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    ibm485.h

Abstract:

    This module contains the IBMRGB525 specific DAC definitions for the
    Weitek P9100 miniport device driver.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/


//
// Define the relative offset of each of the Bt485 registers in the
// DACRegisters array found in the Device Extension.
//

typedef enum
{
    RS_0,
    RS_1,
    RS_2,
    RS_3,
    RS_4,
    RS_5,
    RS_6,
    RS_7,
    RS_8,
    RS_9,
    RS_A,
    RS_B,
    RS_C,
    RS_D,
    RS_E,
    RS_F,
    NUM_DAC_REGS
} DAC_REG_INDEX;

//
// IBMRGB525 Indexed registers.  Those index registers marked // Referenced
// indicate that they are reference.
//
#define RGB525_REVISION_LEVEL           (0x00)
#define RGB525_ID                       (0x01)
#define RGB525_MISC_CLOCK_CTL           (0x02) // Referenced
#define RGB525_SYNC_CTL                 (0x03)
#define RGB525_HSYNC_POS                (0x04)
#define RGB525_POWER_MGNT               (0x05)
#define RGB525_DAC_OPER                 (0x06) // Referenced
#define RGB525_PAL_CTRL                 (0x07)
//
// 08h through 09h are reserved by IBM
//
#define RGB525_PIXEL_FORMAT             (0x0A) // Referenced
#define RGB525_8BPP_CTL                 (0x0B) // Referenced
#define RGB525_16BPP_CTL                (0x0C) // Referenced
#define RGB525_24BPP_CTL                (0x0D) // Referenced
#define RGB525_32BPP_CTL                (0x0E) // Referenced
//
// 0Fh is reserved by IBM
//
#define RGB525_PLL_CTL1                 (0x10) // Referenced
#define RGB525_PLL_CTL2                 (0x11) // Referenced
//
// 12h through 13h are reserved by IBM
//
#define RGB525_FIXED_PLL_REF_DIV        (0x14) // Referenced
//
// 15h through 1fh are reserved by IBM
//
#define RGB525_F0                       (0x20) // Referenced
#define RGB525_F1                       (0x21)
#define RGB525_F2                       (0x22)
#define RGB525_F3                       (0x23)
#define RGB525_F4                       (0x24)
#define RGB525_F5                       (0x25)
#define RGB525_F6                       (0x26)
#define RGB525_F7                       (0x27)
#define RGB525_F8                       (0x28)
#define RGB525_F9                       (0x29)
#define RGB525_F10                      (0x2A)
#define RGB525_F11                      (0x2B)
#define RGB525_F12                      (0x2C)
#define RGB525_F13                      (0x2D)
#define RGB525_F14                      (0x2E)
#define RGB525_F15                      (0x2F)
#define RGB525_CURSOR_CTL               (0x30) // Referenced
#define RGB525_CURSOR_X_LOW             (0x31) // Referenced
#define RGB525_CURSOR_X_HIGH            (0x32) // Referenced
#define RGB525_CURSOR_Y_LOW             (0x33) // Referenced
#define RGB525_CURSOR_Y_HIGH            (0x34) // Referenced
#define RGB525_CURSOR_HOT_X             (0x35) // Referenced
#define RGB525_CURSOR_HOT_Y             (0x36) // Referenced
//
// 37h through 3fh are reserved by IBM
//
#define RGB525_CURSOR_1_RED             (0x40) // Referenced
#define RGB525_CURSOR_1_GREEN           (0x41) // Referenced
#define RGB525_CURSOR_1_BLUE            (0x42) // Referenced
#define RGB525_CURSOR_2_RED             (0x43) // Referenced
#define RGB525_CURSOR_2_GREEN           (0x44) // Referenced
#define RGB525_CURSOR_2_BLUE            (0x45) // Referenced
#define RGB525_CURSOR_3_RED             (0x46)
#define RGB525_CURSOR_3_GREEN           (0x47)
#define RGB525_CURSOR_3_BLUE            (0x48)
//
// 49h through 5fh are reserved by IBM
//
#define RGB525_BORDER_RED               (0x60)
#define RGB525_BORDER_GREEN             (0x61)
#define RGB525_BORDER_BLUE              (0x62)
//
// 63h through 6fh are reserved by IBM
//
#define RGB525_MISC_CTL1                (0x70) // Referenced
#define RGB525_MISC_CTL2                (0x71) // Referenced
#define RGB525_MISC_CTL3                (0x72)
//
// 73h through 81h are reserved by IBM
//
#define RGB525_DAC_SENSE                (0x82)
//
// 83h is reserved by IBM
//
#define RGB525_MISR_RED                 (0x84)
//
// 85h is reserved by IBM
//
#define RGB525_MISR_GREEN               (0x86)
//
// 87h is reserved by IBM
//
#define RGB525_MISR_BLUE                (0x88)
//
// 89h - 8dh are reserved by IBM
//
#define RGB525_PLL_VCO_DIV              (0x8E)
#define RGB525_PLL_REF_DIV_IN           (0x8F)
#define RGB525_VRAM_MASK_LOW            (0x90)
#define RGB525_VRAM_MASK_HIGH           (0x91)
//
// 92h through 0ffh are reserved by IBM
//
#define RGB525_CURSOR_ARRAY             (0x100) // Referenced
//
// Miscellaneous definitions...
//

//
// Max clock frequency supported w/o clock doubling.
//
//

#define CLK_MAX_FREQ_IBM525                    (17000L)

#define ON                              (0xff)
#define OFF                             (0x0)

#define CURS_ACTIVE_IBM525                                       (0x02)
#define ENB_CURS_IBM525                                          (0x02)
#define DIS_CURS_IBM525                                          ~CURS_ACTIVE_IBM525
//
// PLL Control 1 Register Bit Definitions.  (Section 13.2.3.1)
//
#define IBM525_PLL1_REF_SRC_MSK  0x10
#define IBM525_PLL1_REFCLK_INPUT 0x00
#define IBM525_PLL1_EXTOSC_INPUT 0x10
#define IBM525_PLL1_EXT_INT_MSK  0x07
#define IBM525_PLL1_EXT_FS       0x00
#define IBM525_PLL1_INT_FS       0x02

//
// PLL Control 2 Register Bit Definitions.  (Section 13.2.3.2)
//
#define IBM525_PLL2_INT_FS_MSK   0x0F
#define IBM525_PLL2_F0_REG       0x00
#define IBM525_PLL2_F1_REG       0x01
#define IBM525_PLL2_F2_REG       0x02
#define IBM525_PLL2_F3_REG       0x03
#define IBM525_PLL2_F4_REG       0x04
#define IBM525_PLL2_F5_REG       0x05
#define IBM525_PLL2_F6_REG       0x06
#define IBM525_PLL2_F7_REG       0x07
#define IBM525_PLL2_F8_REG       0x08
#define IBM525_PLL2_F9_REG       0x09
#define IBM525_PLL2_F10_REG      0x0A
#define IBM525_PLL2_F11_REG      0x0B
#define IBM525_PLL2_F12_REG      0x0C
#define IBM525_PLL2_F13_REG      0x0D
#define IBM525_PLL2_F14_REG      0x0E
#define IBM525_PLL2_F15_REG      0x0F

//
// PLL Reference Divider Register Bit Definitions.  (Section 13.2.3.3)
//
#define IBM525_PLLD_4MHZ         0x02
#define IBM525_PLLD_6MHZ         0x03
#define IBM525_PLLD_8MHZ         0x04
#define IBM525_PLLD_10MHZ        0x05
#define IBM525_PLLD_12MHZ        0x06
#define IBM525_PLLD_14MHZ        0x07
#define IBM525_PLLD_16MHZ        0x08
#define IBM525_PLLD_18MHZ        0x09
#define IBM525_PLLD_20MHZ        0x0A
#define IBM525_PLLD_22MHZ        0x0B
#define IBM525_PLLD_24MHZ        0x0C
#define IBM525_PLLD_26MHZ        0x0D
#define IBM525_PLLD_28MHZ        0x0E
#define IBM525_PLLD_30MHZ        0x0F
#define IBM525_PLLD_32MHZ        0x10
#define IBM525_PLLD_34MHZ        0x11
#define IBM525_PLLD_36MHZ        0x12
#define IBM525_PLLD_38MHZ        0x13
#define IBM525_PLLD_40MHZ        0x14
#define IBM525_PLLD_42MHZ        0x15
#define IBM525_PLLD_44MHZ        0x16
#define IBM525_PLLD_46MHZ        0x17
#define IBM525_PLLD_48MHZ        0x18
#define IBM525_PLLD_50MHZ        0x19
#define IBM525_PLLD_52MHZ        0x1A
#define IBM525_PLLD_54MHZ        0x1B
#define IBM525_PLLD_56MHZ        0x1C
#define IBM525_PLLD_58MHZ        0x1D
#define IBM525_PLLD_60MHZ        0x1E
#define IBM525_PLLD_62MHZ        0x1F

//
// DAC Operation Register Bit Definitions.  (Section 13.2.1.8)
//
#define IBM525_DO_SOG_MSK        0x08
#define IBM525_DO_SOG_DISABLE    0x00
#define IBM525_DO_SOG_ENABLE     0x08
#define IBM525_DO_BRB_MSK        0x04
#define IBM525_DO_BRB_NORMAL     0x00
#define IBM525_DO_BRB_BLANKED    0x04
#define IBM525_DO_DSR_MSK        0x02
#define IBM525_DO_DSR_SLOW       0x00
#define IBM525_DO_DSR_FAST       0x02
#define IBM525_DO_DPE_MSK        0x01
#define IBM525_DO_DPE_DISABLE    0x00
#define IBM525_DO_DPE_ENABLE     0x01

//
// Bit definitions for the indexed registers.
//
//
// Miscellaneous Control 1 Register Bit Definitions.  (Section 13.2.1.1)
//
#define IBM525_MC1_MISR_CTL_MSK  0x80
#define IBM525_MC1_MISR_CTL_OFF  0x00
#define IBM525_MC1_MISR_CTL_ON   0x80
#define IBM525_MC1_VMSK_CTL_MSK  0x40
#define IBM525_MC1_VMASK_DISABLE 0x00
#define IBM525_MC1_VMASK_ENABLE  0x40
#define IBM525_MC1_PADR_RFMT_MSK 0x20
#define IBM525_MC1_GET_PAL_ADDR  0x00
#define IBM525_MC1_GET_ACC_STATE 0x20
#define IBM525_MC1_SENS_DSAB_MSK 0x10
#define IBM525_MC1_SENSE_ENABLE  0x00
#define IBM525_MC1_SENSE_DISABLE 0x10
#define IBM525_MC1_SENS_SEL_MSK  0x08
#define IBM525_MC1_SENS_SEL_BIT3 0x00
#define IBM525_MC1_SENS_SEL_BIT7 0x08
#define IBM525_MC1_VRAM_SIZE_MSK 0x01
#define IBM525_MC1_VRAM_32_BITS  0x00
#define IBM525_MC1_VRAM_64_BITS  0x01

//
// Miscellaneous Control 2 Register Bit Definitions.  (Section 13.2.1.2)
//
#define IBM525_MC2_PCLK_SEL_MSK  0xC0
#define IBM525_MC2_LCLK_INPUT    0x00
#define IBM525_MC2_INT_PLL_OUT   0x40
#define IBM525_MC2_EXT_OSC_INPUT 0x80
#define IBM525_MC2_INTL_MODE_MSK 0x20
#define IBM525_MC2_NON_INTERLACE 0x00
#define IBM525_MC2_INTERLACE     0x20
#define IBM525_MC2_BLANK_CTL_MSK 0x10
#define IBM525_MC2_NORMAL_BLNKS  0x00
#define IBM525_MC2_DAC_BLNKS     0x10
#define IBM525_MC2_CLR_RES_MSK   0x04
#define IBM525_MC2_CLR_RES_6_BIT 0x00
#define IBM525_MC2_CLR_RES_8_BIT 0x04
#define IBM525_MC2_PORT_SEL_MSK  0x01
#define IBM525_MC2_VGA_PEL_INPUT 0x00
#define IBM525_MC2_SD_PEL_INPUT  0x01

//
// Define the Desired Frequency Ranges.
//
#define IBM525_DF0_LOW           1625
#define IBM525_DF0_HIGH          3200
#define IBM525_DF0_STEP          25
#define IBM525_DF1_LOW           3250
#define IBM525_DF1_HIGH          6400
#define IBM525_DF1_STEP          50
#define IBM525_DF2_LOW           6500
#define IBM525_DF2_HIGH          12800
#define IBM525_DF2_STEP          100
#define IBM525_DF3_LOW           13000
#define IBM525_DF3_HIGH          25000
#define IBM525_DF3_STEP          200

//
// Frequency 0 thru Frequency 15 Register Bit Definitions.  (Section 13.2.3.4)
//
#define IBM525_FREQ_DF_MSK       0xC0
#define IBM525_FREQ_DF_0         0x00
#define IBM525_FREQ_DF_1         0x40
#define IBM525_FREQ_DF_2         0x80
#define IBM525_FREQ_DF_3         0xC0

//
// Miscellaneous Clock Control Register Bit Definitions.  (Section 13.2.1.4)
//
#define IBM525_MCC_DDOT_DSAB_MSK 0x80
#define IBM525_MCC_DDOT_ENABLE   0x00
#define IBM525_MCC_DDOT_DISABLE  0x80
#define IBM525_MCC_SCLK_DSAB_MSK 0x40
#define IBM525_MCC_SCLK_ENABLE   0x00
#define IBM525_MCC_SCLK_DISABLE  0x40
#define IBM525_MCC_B24P_DDOT_MSK 0x20
#define IBM525_MCC_B24P_PLL      0x00
#define IBM525_MCC_B24P_SCLK     0x20
#define IBM525_MCC_DDOT_DIV_MSK  0x0E
#define IBM525_MCC_PLL_DIV_1     0x00
#define IBM525_MCC_PLL_DIV_2     0x02
#define IBM525_MCC_PLL_DIV_4     0x04
#define IBM525_MCC_PLL_DIV_8     0x06
#define IBM525_MCC_PLL_DIV_16    0x08
#define IBM525_MCC_PLL_ENAB_MSK  0x01
#define IBM525_MCC_PLL_DISABLE   0x00
#define IBM525_MCC_PLL_ENABLE    0x01

//
// Pixel Format Register Bit Definitions.  (Section 13.2.2.1)
//
#define IBM525_PF_FORMAT_MSK     0x07
#define IBM525_PF_4_BPP          0x02
#define IBM525_PF_8_BPP          0x03
#define IBM525_PF_15_OR_16_BPP   0x04
#define IBM525_PF_24_BPP         0x05
#define IBM525_PF_32_BPP         0x06

//
// 8 Bpp Control Register Bit Definitions.  (Section 13.2.2.2)
//
#define IBM525_8BC_DCOL_MSK      0x01
#define IBM525_8BC_INDIRECT      0x00
#define IBM525_8BC_DIRECT        0x01

//
// Macros for accessing the IBMRGB525's hardware cursor registers.
//

#define WR_CURS_POS_X_IBM525(pos) \
    WriteIBM525(HwDeviceExtension, RGB525_CURSOR_X_LOW, (UCHAR) pos); \
    WriteIBM525(HwDeviceExtension, RGB525_CURSOR_X_HIGH, (UCHAR) (pos >> 8))

#define WR_CURS_POS_Y_IBM525(pos) \
    WriteIBM525(HwDeviceExtension, RGB525_CURSOR_Y_LOW, (UCHAR) pos); \
    WriteIBM525(HwDeviceExtension, RGB525_CURSOR_Y_HIGH, (UCHAR) (pos >> 8))

#define CURS_IS_ON_IBM525() \
    (ReadIBM525(HwDeviceExtension, RGB525_CURSOR_CTL) & CURS_ACTIVE_IBM525)

#define CURS_ON_IBM525() \
    WriteIBM525(HwDeviceExtension, RGB525_CURSOR_CTL, (UCHAR) (ReadIBM525(HwDeviceExtension, RGB525_CURSOR_CTL) | ENB_CURS_IBM525))

#define CURS_OFF_IBM525() \
    WriteIBM525(HwDeviceExtension, RGB525_CURSOR_CTL, (UCHAR) (ReadIBM525(HwDeviceExtension, RGB525_CURSOR_CTL) & DIS_CURS_IBM525))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\p9000.c ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    p9000.c

Abstract:

    This module contains the code specific to the Weitek P9000.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

#include "p9.h"
#include "p9gbl.h"
#include "p9000.h"

//
// Static data for the P9000 specific support routines.
//

//
// This table is used to compute the qsfselect value for the P9000 Srctl
// register. This value is dependent upon a particular adapter's dot clock
// divisor and its memory configuration. See p. 64 of the P9000 manual for
// details.
//

ULONG   qsfSelect[2][5] =
{
    {4, 4, 5, 5, 6},
    {3, 3, 4, 4, 5},
};


VOID
Init8720(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Initialize the P9000.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/
{

    P9_WR_REG(0x0000CL, 0x00000080L);             //INTERRUPT-EN = disabled
    P9_WR_REG(0x00118L, 0x00000000L);             //PREHRZC = 0
    P9_WR_REG(0x00130L, 0x00000000L);             //PREVRTC = 0

    //
    // Initialize the P9 registers whose values are dependent upon a
    // particular OEM implementation.
    //

    P9_WR_REG(MEMCONF, HwDeviceExtension->AdapterDesc.ulMemConfVal);
    P9_WR_REG(SRCTL,
        HwDeviceExtension->AdapterDesc.ulSrctlVal |
        qsfSelect[(HwDeviceExtension->AdapterDesc.iClkDiv >> 2) - 1]
                 [HwDeviceExtension->AdapterDesc.ulMemConfVal]);

    //
    // Initialize non-implementation specific registers.
    //

    P9_WR_REG(0x00188L, 0x00000186L);             //RFPERIOD =
    P9_WR_REG(0x00190L, 0x000000FAL);             //RLMAX =
    P9_WR_REG(0x80208L, 0x000000FFL);             //allow writing in all 8 planes
    P9_WR_REG(0x8020CL, 0x0000000AL);             //drawmode=buffer 0, write inside window
    P9_WR_REG(0x80190L, 0x00000000L);             //disable any co-ord offset

    return;
}


VOID
WriteTiming(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:


Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.
    pPal - Pointer to the array of pallete entries.
    StartIndex - Specifies the first pallete entry provided in pPal.
    Count - Number of palette entries in pPal

Return Value:

    None.

--*/

{
    int     div;

    div = (HwDeviceExtension->AdapterDesc.iClkDiv)/(HwDeviceExtension->usBitsPixel / 8);

    P9_WR_REG(0x010CL, HwDeviceExtension->VideoData.hsyncp/div - 1 );             // HRZSR
    P9_WR_REG(0x0110L, (HwDeviceExtension->VideoData.hsyncp + HwDeviceExtension->VideoData.hbp) / div - 1 );              //HRZBR
    P9_WR_REG(0x0114L, (HwDeviceExtension->VideoData.hsyncp + HwDeviceExtension->VideoData.hbp + HwDeviceExtension->VideoData.XSize)/div -1 );    //HRZBF
    P9_WR_REG(0x0108L, (HwDeviceExtension->VideoData.hsyncp + HwDeviceExtension->VideoData.hbp + HwDeviceExtension->VideoData.XSize + HwDeviceExtension->VideoData.hfp)/div - 1 );  //HRZT
    P9_WR_REG(0x0124L, HwDeviceExtension->VideoData.vsp);                                 //VRTSR
    P9_WR_REG(0x0128L, HwDeviceExtension->VideoData.vsp + HwDeviceExtension->VideoData.vbp );                     //VRTBR
    P9_WR_REG(0x012CL, HwDeviceExtension->VideoData.vsp + HwDeviceExtension->VideoData.vbp + HwDeviceExtension->VideoData.YSize );                //VRTBF
    P9_WR_REG(0x0120L, HwDeviceExtension->VideoData.vsp + HwDeviceExtension->VideoData.vbp + HwDeviceExtension->VideoData.YSize+HwDeviceExtension->VideoData.vfp );               //VRTT

   return;
}




VOID
SysConf(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:


Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{
    int i,j;                            // loop counters
    long  sysval = 0x3000L;             // swap bytes and words for little endian PC

    int  xtem = HwDeviceExtension->VideoData.XSize * (HwDeviceExtension->usBitsPixel / 8);  //save a copy for clearing bits in
    long  ClipMax;                          // clipping register value for NotBusy to restore

    if (xtem & 0xf80)                       // each field in the sysconreg can only set
    {                                       // a limited range of bits in the size
        j = 7;                              // each field is 3 bits wide
        for (i = 2048; i >= 128;i >>= 1)    // look at all the bits field 3 can effect
        {
            if (i & xtem)                   // if this bit is on,
            {
                sysval |= ((long) j) << 20; // use this field to set it
                xtem &= ~i;                 // and remove the bit from the size
                break;                      // each field can only set one bit
            }
            j -=  1;
        }
    }

    if (xtem & 0x7C0)                       // do the same thing for field 2
    {
        j = 6;                              // each field is 3 bits wide
        for (i = 1024; i >= 64; i >>= 1)    // look at all the bits field 2 can effect
        {
            if (i & xtem)                   // if this bit is on,
            {
                sysval |= ((long)j)<<17;    // use this field to set it
                xtem &= ~i;                 // and remove the bit from the size
                break;                      // each field can only set one bit
            }
            j -= 1;
        }
    }

    if (xtem & 0x3E0)                       // do the same thing for field 1
    {
        j = 5;                              // each field is 3 bits wide
        for (i = 512; i >= 32;i >>= 1)      // look at all the bits field 1 can effect
        {
            if (i & xtem)                   // if this bit is on,
            {
                sysval |= ((long) j) << 14; // use this field to set it
                xtem &= ~i;                 // and remove the bit from the size
                break;                      // each field can only set one bit
            }
            j -= 1;
        }
    }

    if (xtem != 0)                          // if there are bits left, it is an
        return;                             // illegal x size.

    P9_WR_REG(SYSCONFIG, sysval);           // send data to the register
    P9_WR_REG(WMIN, 0);                     // minimum clipping register

    // calc and set max

    ClipMax=((long) HwDeviceExtension->VideoData.XSize - 1) << 16 |
            (div32(HwDeviceExtension->FrameLength, (SHORT) HwDeviceExtension->VideoData.XSize) - 1);   

    // clipping to allow access to all of the extra memory.

    P9_WR_REG(WMAX, ClipMax);
    return;
}


VOID
P9000SizeMem(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Determines the amount of video memory installed, as well as the P9000
    memory configuration, and stores them in the device extension.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/
{
    PULONG pulFrameBufAddr = (PULONG) HwDeviceExtension->FrameAddress;
    ULONG  i;

    //
    // Assume 2 M of VRAM is installed.
    //

    HwDeviceExtension->AdapterDesc.ulMemConfVal = P90_MEM_CFG_3;
    HwDeviceExtension->FrameLength = 0x200000;

    //
    // Initialize the P9000 to memory configuration 3 (2M), so frame buffer
    // memory can be accessed.
    //

    P9_WR_REG(MEMCONF, P90_MEM_CFG_3);

    //
    // Write a series of test values to the frame buffer.
    //

    for (i = 0; i < 32; i++)
    {
        pulFrameBufAddr[i] = i;
    }

    //
    // Read back the test values. If any errors occur, this is not a valid
    // memory configuration.
    //

    for (i = 0; i < 32; i++)
    {
        if (pulFrameBufAddr[i] != i)
        {
            HwDeviceExtension->AdapterDesc.ulMemConfVal = P90_MEM_CFG_1;
            HwDeviceExtension->FrameLength = 0x100000;
            break;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\p9100.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\ibm525.c ===
/*++

Copyright (c) 1994  Weitek Corporation

Module Name:

    ibm525.c

Abstract:

    This module contains code specific for the IBM 525RGB DAC on P9100
    adapters.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

#include "p9.h"
#include "p9000.h"
#include "p9gbl.h"
#include "p91dac.h" // Include before ibm525.h
#include "ibm525.h"
#include "p91regs.h"

//
// DAC specific static data.
//

//
// Function Prototypes for the IBM525 DAC which are defined in IBM525.C.
//
//
// IBM525 function prototypes.
//

VOID
WriteIBM525(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT index,
    UCHAR bvalue
    );

VOID
IBM525SetPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG *pPal,
    ULONG StartIndex,
    ULONG Count
    );

VOID
IBM525SetPointerPos(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG   ptlX,
    ULONG   ptlY
    );

VOID
IBM525SetPointerShape(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR  pHWCursorShape
    );

VOID
IBM525PointerOn(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
IBM525PointerOff(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
IBM525ClearPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
IBM525SetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
IBM525RestoreMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
IBM525SetClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
IBM525ClrClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );



//
// Define the DAC support routines structure for the IBM525 DAC.
//

DAC Ibm525 = {
    DAC_ID_IBM525,
    NUM_DAC_REGS,
    IBM525SetMode,
    IBM525RestoreMode,
    IBM525SetPalette,
    IBM525ClearPalette,
    IBM525PointerOn,
    IBM525PointerOff,
    IBM525SetPointerPos,
    IBM525SetPointerShape,
    CLK_MAX_FREQ_IBM525,
    IBM525SetClkDoubler,
    IBM525ClrClkDoubler,
    DAC_ID_IBM525,
    64,
    FALSE,
    TRUE,
    TRUE
};


VOID
WriteIBM525(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT index,
    UCHAR value
    )
/*++

Routine Description:

    Writes specified data to an indexed register inside the RGB525 Ramdac.

Arguments:

    Index register and data.

Return Value:

    None.

--*/

{
    IBM525_WR_DAC(P9100_IBM525_INDEX_LOW,  (UCHAR)  (index & 0x00FF));
    IBM525_WR_DAC(P9100_IBM525_INDEX_HIGH, (UCHAR) ((index & 0xFF00) >> 8));
    IBM525_WR_DAC(P9100_IBM525_INDEX_DATA, (UCHAR) value);
   (void) P9_RD_REG(P91_MEM_CONFIG); // Needed for timinig...

} // End of WriteIBM525()


UCHAR
ReadIBM525(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT index
    )

/*++

Routine Description:

    Reads data from an indexed register inside the RGB525 Ramdac.

Arguments:

    Index register.

Return Value:

    None.

--*/

{
    UCHAR   j;

    IBM525_WR_DAC(P9100_IBM525_INDEX_LOW,  (UCHAR)  (index & 0x00FF));
    IBM525_WR_DAC(P9100_IBM525_INDEX_HIGH, (UCHAR) ((index & 0xFF00) >> 8));

    IBM525_RD_DAC(P9100_IBM525_INDEX_DATA, j);

    return(j); 

} // End of ReadIBM525()




VOID
IBM525SetPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG *pPal,
    ULONG StartIndex,
    ULONG Count
    )

/*++

Routine Description:

    Sets the Device palette

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    pPal - Pointer to the array of pallete entries.

    StartIndex - Specifies the first pallete entry provided in pPal.

    Count - Number of palette entries in pPal

Return Value:

    None.

--*/

{

    UCHAR *pBytePal;
     int i;

#define STALL_TIME 11

    VideoDebugPrint((3, "IBM525SetPalette: ----------\n"));
    IBM525_WR_DAC(P9100_RAMWRITE, (UCHAR) StartIndex);
    VideoPortStallExecution(STALL_TIME);

    pBytePal = (PUCHAR) pPal;

    //
    // Load the palette with RGB values. The input palette has 4 bytes
    // per entry, the last of which is ignored.
    //

    while (Count--)
    {
        IBM525_WR_DAC(P9100_PALETDATA, *pBytePal++);
        VideoPortStallExecution(STALL_TIME);
        IBM525_WR_DAC(P9100_PALETDATA, *pBytePal++);
        VideoPortStallExecution(STALL_TIME);
        IBM525_WR_DAC(P9100_PALETDATA, *pBytePal++);
        VideoPortStallExecution(STALL_TIME);
        pBytePal++;

    }
}


VOID
IBM525SetPointerPos(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG   ptlX,
    ULONG   ptlY
    )

/*++

Routine Description:

    Move Hardware Pointer.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ptlX, ptlY - Requested X,Y position for the pointer.

Return Value:

    TRUE

--*/

{

    WR_CURS_POS_X_IBM525(ptlX);
    WR_CURS_POS_Y_IBM525(ptlY);

    return;
}


VOID
IBM525SetPointerShape(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR  pHWCursorShape
    )

/*++

Routine Description:

    Sets the hardware cursor shape.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.
    pHWCursorShape - Pointer to the cursor bitmap.

Return Value:

    None.

--*/

{
   int        i, j, iCursorIndex;
   UCHAR    ucPacked;
   USHORT    usExpanded;

   VideoDebugPrint((3, "IBM525SetPointerShape: ----------\n"));
   //
   // Calculate # bytes for Pixel data.  The IBMRGB525 DAC provides support
   // for 32x32 and 64x64 cursors.  Two bits for each pixel.
   //
   //    2 bit per pixel = 4 pixel per byte (8 / 2).
   //    256 bytes for 32x32 cursor, and 1024 bytes for 64x64 cursor.
   // Note that we can store up to four 32x32 cursors.
   //
   // Specify:
   // 32x32 cursor; 2-color & highlighting cursor; delayed cursor update;
   // read actual location; pixel order left to right and partion 00.
   //
    WriteIBM525(HwDeviceExtension, RGB525_CURSOR_CTL,     0x32);

   //
   // Set color 1 to Black, and color 2 to white...
   //
    WriteIBM525(HwDeviceExtension, RGB525_CURSOR_1_RED,   0x00); // Black
    WriteIBM525(HwDeviceExtension, RGB525_CURSOR_1_GREEN, 0x00);
    WriteIBM525(HwDeviceExtension, RGB525_CURSOR_1_BLUE,  0x00);

    WriteIBM525(HwDeviceExtension, RGB525_CURSOR_2_RED,   0xFF); // White
    WriteIBM525(HwDeviceExtension, RGB525_CURSOR_2_GREEN, 0xFF);
    WriteIBM525(HwDeviceExtension, RGB525_CURSOR_2_BLUE,  0xFF);

    //
   // Set cursor hot-spot to upper/left of cursor...
   //
   WriteIBM525(HwDeviceExtension, RGB525_CURSOR_HOT_X,   0x00);
    WriteIBM525(HwDeviceExtension, RGB525_CURSOR_HOT_Y,   0x00);

   //
   // WinNT provides a monochrome or color bitmap for a specific cursor.
   // The mono bitmap has the same width as the cursor, but has twice the
   // vertical extent, which contains two masks.  The first mask is the
   // AND mask, while the second mask is the XOR mask.  Normally, the AND
   // mask will be loaded into Plane1 while the XOR mask will be loaded
   // into Plane0 as is for Ramdacs like the BT485.  However, since the
   // IBMRGB525 Ramdac only allows for a color cursor, we must combine
   // both the AND and XOR mask into one, two bits per pixel bit mask.
   //
    iCursorIndex = RGB525_CURSOR_ARRAY; // Beginning cursor index

    WAIT_FOR_RETRACE();

   for (i = 0; i < ((CURSOR_WIDTH * CURSOR_HEIGHT) / 8); i++)
   {
      usExpanded = 0;

      ucPacked   = *pHWCursorShape;                // Get AND mask byte

      for (j = 0; j < 8; j++)
      {
            if (ucPacked & (0x1 << j))
                usExpanded |= (0x2 << (j*2));
      }

      ucPacked   = *(pHWCursorShape + 128);    // Get XOR mask byte

      for (j = 0; j < 8; j++)
      {
            if (ucPacked & (0x1 << j))
                usExpanded |= (0x1 << (j*2));
      }

      ++pHWCursorShape;

      WriteIBM525(HwDeviceExtension,
                  (USHORT) iCursorIndex++,
                  (UCHAR) ((usExpanded & 0xFF00) >> 8));

      WriteIBM525(HwDeviceExtension,
                  (USHORT) iCursorIndex++,
                  (UCHAR) (usExpanded & 0x00FF));
   }
   return;

} // End of IBM525SetPointerShape()




VOID
IBM525PointerOn(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

  Turn on the hardware cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{
   //
   // Turn the cursor on only if it was disabled.
   //
   VideoDebugPrint((3, "IBM525PointerOn: ----------\n"));
   if (!CURS_IS_ON_IBM525())
   {
       WAIT_FOR_RETRACE();
       CURS_ON_IBM525();
   }

   return;
}


VOID
IBM525PointerOff(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

  Turn off the hardware cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{

    //
    // Turn the cursor off only if it was enabled.
    //
    VideoDebugPrint((3, "IBM525PointerOff: ----------\n"));
    if (CURS_IS_ON_IBM525())
    {
        WAIT_FOR_RETRACE();
        CURS_OFF_IBM525();
    }

    return;
}


VOID
IBM525ClearPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Clears the palette to all 0's

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{
    int i, Count;

    VideoDebugPrint((3, "IBM525ClearPalette: ----------\n"));
    //
    // Calculate the number of palette entries. It is assumed that the
    // caller has already determined that the current mode makes use
    // of the palette,
    //
    Count = 256; // 256 x 8 x 3

    //
    // Fill the palette with RGB values of 0.
    //
    IBM525_WR_DAC(P9100_RAMWRITE, (UCHAR) 0);
    VideoPortStallExecution(5);

    while (Count--)
    {
        IBM525_WR_DAC(P9100_PALETDATA, 0);
        VideoPortStallExecution(5);
        IBM525_WR_DAC(P9100_PALETDATA, 0);
        VideoPortStallExecution(5);
        IBM525_WR_DAC(P9100_PALETDATA, 0);
        VideoPortStallExecution(5);
    }

    return;
}


BOOLEAN
IBM525SetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Initializes the DAC for the current mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/
{
    VideoDebugPrint((2, "IBM525SetMode: - Entry\n"));

    //
    // Set the pixel read mask.
    //

    P9_WR_BYTE_REG(P9100_PIXELMASK, 0xff);

    //
    // Select the fast DAC slew rate for the sharpest pixels
    //

    WriteIBM525(HwDeviceExtension, RGB525_DAC_OPER, 0x02);

    //
    // Enable the 64-bit VRAM pixel port
    //

    WriteIBM525(HwDeviceExtension, RGB525_MISC_CTL1, 0x01);

    //
    // The Dac.bRamdacUsePLL flag determines whether or not
    // we use the RAMDAC's internal PLL.
    //

    VideoDebugPrint((3, "IBM525SetMode: bRamdacUsePLL = %d\n",
                   HwDeviceExtension->Dac.bRamdacUsePLL));
    if (!HwDeviceExtension->Dac.bRamdacUsePLL)
    {
        //
        // Use the external clock instead of the RAMDAC PLL
        // Useful for debugging if you can't get the RAMDAC
        // PLL on your board to lock for whatever reason.
        //
        WriteIBM525(HwDeviceExtension, RGB525_MISC_CTL2, 0x85);
    }
    else
    {
        //
        // Internal PLL output used for pixel clock 8-bit DACs
        // VRAM pixel port inputs.
        //
        WriteIBM525(HwDeviceExtension, RGB525_MISC_CTL2, 0x45);
    }

   VideoDebugPrint((3, "IBM525SetMode: bRamdacDivides = %d\n",
                    HwDeviceExtension->Dac.bRamdacDivides));

   switch(HwDeviceExtension->usBitsPixel)
   {
        case 32:
            //
            // Select 32bpp (bypass palette)
            //
            //
            // If Dac.bRamdacDivides == TRUE then we set up the RAMDAC
            // so that we can use the ddotclk output instead of SCLK if
            // necessary, by setting up the ddotclk divisor.
            // Otherwise we have the RAMDAC send out the pixel clock.
            //
            if (HwDeviceExtension->Dac.bRamdacDivides)
                WriteIBM525(HwDeviceExtension, RGB525_MISC_CLOCK_CTL, 0x23);
            else
                WriteIBM525(HwDeviceExtension, RGB525_MISC_CLOCK_CTL, 0x21);

            WriteIBM525(HwDeviceExtension, RGB525_PIXEL_FORMAT, 0x06);
            WriteIBM525(HwDeviceExtension, RGB525_32BPP_CTL, 0x03);
            break;

        case 24:
            //
            // 24BPP packed
            //
            //
            // This first line doesn't matter too much because SCLK
            // will be sent out both the SCLK and DDOTCLK outputs in
            // 24bpp mode
            //
            WriteIBM525(HwDeviceExtension, RGB525_MISC_CLOCK_CTL, 0x27);
            WriteIBM525(HwDeviceExtension, RGB525_PIXEL_FORMAT, 0x05);
            WriteIBM525(HwDeviceExtension, RGB525_24BPP_CTL, 0x01);
            break;

        case 16:
            //
           // Note: 16-bpp is really 15-bpp (555)
            // Select 15bpp (bypass palette)
            //
            if (HwDeviceExtension->Dac.bRamdacDivides)
                WriteIBM525(HwDeviceExtension, RGB525_MISC_CLOCK_CTL, 0x25);
            else
                WriteIBM525(HwDeviceExtension, RGB525_MISC_CLOCK_CTL, 0x21);
            WriteIBM525(HwDeviceExtension, RGB525_PIXEL_FORMAT, 0x04);
            WriteIBM525(HwDeviceExtension, RGB525_16BPP_CTL, 0xc4);
            break;

        case 15:
            //
           // This is really 16-bpp (565).
            // Select 16bpp (bypass palette)
            //
            if (HwDeviceExtension->Dac.bRamdacDivides)
                WriteIBM525(HwDeviceExtension, RGB525_MISC_CLOCK_CTL, 0x25);
            else
                WriteIBM525(HwDeviceExtension, RGB525_MISC_CLOCK_CTL, 0x21);
            WriteIBM525(HwDeviceExtension, RGB525_PIXEL_FORMAT, 0x04);
            WriteIBM525(HwDeviceExtension, RGB525_16BPP_CTL, 0xc6);
            break;

        case 8:
            //
            // Select 8bpp
            //
            if (HwDeviceExtension->Dac.bRamdacDivides)
                WriteIBM525(HwDeviceExtension, RGB525_MISC_CLOCK_CTL, 0x27);
            else
                WriteIBM525(HwDeviceExtension, RGB525_MISC_CLOCK_CTL, 0x21);
            WriteIBM525(HwDeviceExtension, RGB525_PIXEL_FORMAT, 0x03);
            WriteIBM525(HwDeviceExtension, RGB525_8BPP_CTL, 0x00);
            break;
    };

    VideoDebugPrint((2, "IBM525SetMode: - Exit\n"));

    return(TRUE);
}



VOID
IBM525RestoreMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

routine description:

    Restore the DAC to its pristine state.  For the P9100, the disable
    video function will reset the DAC via a call to INT10 for VGA mode
    3.  Since the Video BIOS cannot switch to protected mode, and therefore
    cannot enter P9100 native mode, it cannot completely initialize the
    IBMRGB525 DAC, so we will do the initialization here.

arguments:

    hwdeviceextension - pointer to the miniport driver's device extension.

return value:

--*/

{
   VideoDebugPrint((3, "IBM525RestoreMode: ----------\n"));

   //
   // Check if there is an override value for the PLL Reference Divider.
   //
    if (HwDeviceExtension->VideoData.ul525RefClkCnt != 0xFFFFFFFF)
    {
       //
       // Program REFCLK to the specified override...
       //
       WriteIBM525(HwDeviceExtension,
                RGB525_FIXED_PLL_REF_DIV,
                (UCHAR) HwDeviceExtension->VideoData.ul525RefClkCnt);

    }
    else
    {
       //
       // Program REFCLK to a fixed 50MHz.
       //
       WriteIBM525(HwDeviceExtension, RGB525_FIXED_PLL_REF_DIV,
                                     IBM525_PLLD_50MHZ);
    }

   //
   // REFCLK Input, External
   //
    WriteIBM525(HwDeviceExtension, RGB525_PLL_CTL1, 0x00);

   //
   // Set F0 to 25.25 Mhz
   //
    WriteIBM525(HwDeviceExtension, RGB525_F0, 0x24);

   //
   // Set F1 to 28.25 Mhz
   //
    WriteIBM525(HwDeviceExtension, RGB525_F1, 0x30);

   //
   // PLL Enable
   //
    WriteIBM525(HwDeviceExtension, RGB525_MISC_CLOCK_CTL, 0x01);

   //
   // Cursor OFF
   //
    WriteIBM525(HwDeviceExtension, RGB525_CURSOR_CTL, 0x00);

    WriteIBM525(HwDeviceExtension, RGB525_VRAM_MASK_LOW, 0x03);
    WriteIBM525(HwDeviceExtension, RGB525_MISC_CTL1,     0x40);
    WriteIBM525(HwDeviceExtension, RGB525_PIXEL_FORMAT,  0x03);
    WriteIBM525(HwDeviceExtension, RGB525_MISC_CTL2,     0x41);
    WriteIBM525(HwDeviceExtension, RGB525_MISC_CTL2,     0x00);
    WriteIBM525(HwDeviceExtension, RGB525_MISC_CTL1,     0x00);
    WriteIBM525(HwDeviceExtension, RGB525_VRAM_MASK_LOW, 0x00);
    return;

}


VOID
IBM525SetClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    return; // Nothing to do... just return.
}


VOID
IBM525ClrClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    return; // Nothing to do... just return.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\p9000.h ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    p9000.h

Abstract:

    This module contains the definitions specific to the Weitek P9000.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

//
// Offsets of the P9000 registers from the base memory address.
//

#define  SYSCONFIG    0x4               // W8720 system configuration register
#define  SRCTL        0x0138L           // Screen repaint timing register
#define  MEMCONF      0x0184L           // Memory configuration regester
#define  WMIN         0x80220           // Clipping window minimum register
#define  WMAX         0x80224           // Clipping window maximum register
#define  FOREGROUND   0x80200           // Foreground color register
#define  METACORD     0x81218           // Meta-coordinate loading register
#define  RASTER       0x80218           // Raster Op register
#define  VRTC         0x011CL           // Vertical scan counter

//
// Defines for P9000 specific drawing operations.
//

#define  REC          0x100             // Or with METACORD when entering rectangles
#define  QUAD         0x80008           // Draw a quadrilateral
#define  FORE         0xFF00            // Foreground color only write mode

//
// Enumerate the various P9000 memory configuration values.
//

typedef enum
{
    P90_MEM_CFG_1,
    P90_MEM_CFG_2,
    P90_MEM_CFG_3,
    P90_MEM_CFG_4,
    P90_MEM_CFG_5
} P90_MEM_CFG;

//
// Define bits in the P9000 Screen Repaint Timing Control Reg (SRCTL)
//

#define VSYNC_INTERNAL  0x0100L
#define HSYNC_INTERNAL  0x0080L
#define COMPOSITE_SYNC  0x0040L
#define VIDEO_NORMAL    0x0020L
#define HBLNK_RELOAD    0x0010L
#define DISP_BUFFER_1   0x0008L
#define QSF_SELECT      0x0007L

//
// Masks for P9000 registers.
//

#define P9_COORD_MASK   0x1fff1fffL

//
// Macro used to wait for P9000 vertical retrace.
//


#if 0
#define WAIT_FOR_RETRACE()                                  \
    ulStrtScan = P9_RD_REG(P91_VRTC);                       \
    while ((ulCurScan = P9_RD_REG(P91_VRTC)) >= ulStrtScan) \
    {                                                       \
        ulStrtScan = ulCurScan;                             \
    }
#endif

#define WAIT_FOR_RETRACE() /* The above loses sync on p9100... */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\p91dac.h ===
/*++

Copyright (c) 1993, 1994  Weitek Corporation

Module Name:

    p91dac.h

Abstract:

    This module contains ramdac definitions specific to the Weitek P9100.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

//
// P9100 relocatable memory mapped BT485 register definitions.
//
// Note: An extra 2 byte offset is added to the register offset in order
//       to align the offset on the byte of the Dword which contains the
//       DAC data.
//
#define P9100_RAMWRITE           0x00000200 + 2
#define P9100_PALETDATA          0x00000204 + 2
#define P9100_PIXELMASK          0x00000208 + 2
#define P9100_RAMREAD            0x0000020C + 2
#define P9100_COLORWRITE         0x00000210 + 2
#define P9100_COLORDATA          0x00000214 + 2
#define P9100_COMREG0            0x00000218 + 2
#define P9100_COLORREAD          0x0000021C + 2
#define P9100_COMREG1            0x00000220 + 2
#define P9100_COMREG2            0x00000224 + 2
#define P9100_COMREG3            0x00000228 + 2
#define P9100_STATREG            0x00000228 + 2
#define P9100_CURSORDATA         0x0000022C + 2
#define P9100_CURSORX0           0x00000230 + 2
#define P9100_CURSORX1           0x00000234 + 2
#define P9100_CURSORY0           0x00000238 + 2
#define P9100_CURSORY1           0x0000023C + 2

//
// P9100 relocatable memory mapped IBM 525 register definitions.
//
// Note: An extra 2 byte offset is added to the register offset in order
//       to align the offset on the byte of the Dword which contains the
//       DAC data.
//
#define P9100_IBM525_PAL_WRITE   0x00000200 + 2
#define P9100_IBM525_PAL_DATA    0x00000204 + 2
#define P9100_IBM525_PEL_MASK    0x00000208 + 2
#define P9100_IBM525_PAL_READ    0x0000020C + 2
#define P9100_IBM525_INDEX_LOW   0x00000210 + 2
#define P9100_IBM525_INDEX_HIGH  0x00000214 + 2
#define P9100_IBM525_INDEX_DATA  0x00000218 + 2
#define P9100_IBM525_INDEX_CTL   0x0000021C + 2

typedef union {
    ULONG   ul;
    USHORT  aw[2];
    UCHAR   aj[4];
} UWB ;

#define IBM525_WR_DAC(index, data)      \
{                                       \
    ULONG   ulIndex;                    \
    UWB     uwb;                        \
                                        \
    uwb.aj[0] = (UCHAR) data;           \
    uwb.aj[1] = uwb.aj[0];              \
    uwb.aw[1] = uwb.aw[0];              \
                                        \
    ulIndex = index & ~0x3;             \
                                        \
    P9_WR_REG(ulIndex, uwb.ul);         \
}

#define IBM525_RD_DAC(index, val)       \
{                                       \
    ULONG   ulIndex;                    \
    UWB     uwb;                        \
                                        \
    ulIndex = index & ~0x3;             \
                                        \
    uwb.ul = P9_RD_REG(ulIndex);        \
                                        \
    uwb.aj[3] = uwb.aj[2];              \
    uwb.aw[0] = uwb.aw[1];              \
                                        \
    val = uwb.aj[0];                    \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\p91regs.h ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    p91regs.h

Abstract:

        This module contains register definitions for the Weitek Power 9100.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

//
// Memclk frequency (in Mhz)...
//
#define DEF_P9100_REV1_MEMCLK   4600
#define DEF_P9100_MEMCLK                4975

//
// System Configuration Register definitions
//
#define SYSCFG_BPP_8            (0x08003000)    //  8 BPP & Byte & Half-word swap
#define SYSCFG_BPP_16   (0x0C003000)    // 16 BPP & Byte & Half-word swap
#define SYSCFG_BPP_24   (0x1C003000)    // 24 BPP & Byte & Half-word swap
#define SYSCFG_BPP_32   (0x14003000)    // 32 BPP & Byte & Half-word swap


//
// Define valid P9100 Revision ID's
//

#define WTK_9100_REV0               0x0000      //
#define WTK_9100_REV1               0x0000      //
#define WTK_9100_REV2               0x0002      //
#define WTK_9100_REV3               0x0003      //

//
// Define Power 9100 I/O Space Configuration Index Registers.
//

#define P91_CONFIG_INDEX            0x9100      // Config space index register.
#define P91_CONFIG_DATA             0x9104      // Config space data register.

//
// Define the Weitek & OEM specific IDs for P9100 board verification...
//

#define P91_VEN_ID           0x100E    // Standard Weitek Design
#define P90_DEV_ID           0x9000    // Standard Weitek P9000 Design
#define P91_DEV_ID           0x9100    // Standard Weitek P9100 Design

//
// Configuration Register Definitions, all are Read-only unless specified.
// Note: offsets are for byte reads/writes.
//

#define P91_CONFIG_VENDOR_LOW           (0)         // RO-Low order byte of Vendor ID
#define P91_CONFIG_VENDOR_HIGH      (1)     // RO-High order byte of Vendor ID
#define P91_CONFIG_DEVICE_LOW       (2)     // RO-Low order byte of Device ID
#define P91_CONFIG_DEVICE_HIGH      (3)     // RO-HIGH order byte of Device ID
#define P91_CONFIG_CONFIGURATION    (4)     // RW-Configuration Register
#define P91_CONFIG_STATUS           (7)     // RO-Status Register
#define P91_CONFIG_REVISION_ID      (8)     // RO-Revision ID
#define P91_CONFIG_VGA_PRESENT      (10)    // RO-Vga Present - set by PUCONFIG
#define P91_CONFIG_DISPLAY          (11)    // RO-PCI Display Controller
#define P91_CONFIG_WBASE            (19)    // RW-Memory Base for Native Mode
#define P91_CONFIG_ROM_ENABLE       (48)    // RW-ROM decoding enabled
#define P91_CONFIG_ROM_BASE_0       (49)    // RW-ROM Base address, Bit 0
#define P91_CONFIG_ROM_BASE_8_1     (50)    // RW-ROM Base address, Bits 8~1
#define P91_CONFIG_ROM_BASE_16_9    (51)    // RW-ROM Base address, Bits 16~9
#define P91_CONFIG_CFBGA            (64)    // RO-Config: BUS, CFBGA & EEDAIN
#define P91_CONFIG_MODE             (65)    // RW-Mode select
#define P91_CONFIG_CKSEL            (66)    // RW-CKSEl & VCEN

//
//
// Clock Synth IDs:
//
#define CLK_ID_ICD2061A             (0x00)  // ICD2061a
#define CLK_ID_FIXED_MEMCLK         (0x20)  // Fixed MEMCLK, RAMDAC gens pixclk

//
// Define Power 9100 coprocesser address prefix bits.
// (Page 18)
//
// Address format:
//
//   3             2   2       1   1   1   1   1   1
//   1             4   3       9   8   7   6   5   4  0
// ------------------------------------------------------
// | a a a a a a a a | 0 0 0 0 0 | H | B | b | 0 | o  o |
// ------------------------------------------------------
//
//  a - Base Address
//  H - Word Swap
//  B - Byte Swap
//  b - Bit Swap
//  o - Coprocessor register offset
//

#define P91_WORD_SWAP            0x00040000  //
#define P91_BYTE_SWAP            0x00020000  //
#define P91_BIT_SWAP             0x00010000  //

//
// Define Power 9100 coprocesser system control register address offsets.
// (Page 23)
//
// Address format:
//
//   3                               1   1
//   1                               5   4             7   6       2    1 0
// --------------------------------------------------------------------------
// | p p p p p p p p p p p p p p p p p | 0 0 0 0 0 0 0 0 | r r r r r  | 0 0 |
// --------------------------------------------------------------------------
//
//  p - Address prefix bits.
//  r - Resiter bits (6-2):
//        00001 - sysconfig
//        00010 - interrupt
//        00011 - interrupt_en
//        00100 - alt_write_bank
//        00101 - alt_read_bank
//

#define P91_SYSCONFIG            0x00000004  // System configuration register.
#define P91_INTERRUPT            0x00000008  // Interrupt register.
#define P91_INTERRUPT_EN         0x0000000C  // Interrupt enable register.
#define P91_ALT_WRITE_BANK       0x00000010  // Alternate write bank register.
#define P91_ALT_READ_BANK        0x00000014  // Alternate read bank register.

//
// Define Power 9100 coprocesser device coordinate register address offsets.
// (Page 27)
//
// Address format:
//
//   3                               1   1
//   1                               5   4           8   7 6   5   4 3   2 1 0
// -----------------------------------------------------------------------------
// | p p p p p p p p p p p p p p p p p | 0 1 1 0 0 0 0 | r r | a | y x | 0 0 0 |
// -----------------------------------------------------------------------------
//
//  p - Address prefix bits.
//  r - Resiter bits (7-6):
//        00 - X[0]/Y[0]
//        01 - X[1]/Y[1]
//        10 - X[2]/Y[2]
//        11 - X[3]/Y[3]
//  a - Screen addressing bit (5):
//         0 - Perform absolute screen addressing.
//         1 - Perform window-relative screen addressing (write only).
// yx - 32/16 bit read/write bits (4-3):
//        00 - Not used.
//        01 - Read or write 32-bit X value.
//        10 - Read or write 32-bit Y value.
//        11 - Read or write 16-bit X value (high 16 bits) Y value (low 16 bits).
//

#define P91_X0_32                0x00003008  // 32-bit X[0] register.
#define P91_X1_32                0x00003048  // 32-bit X[1] register.
#define P91_X2_32                0x00003088  // 32-bit X[2] register.
#define P91_X3_32                0x000030C8  // 32-bit X[3] register.
#define P91_Y0_32                0x00003010  // 32-bit Y[0] register.
#define P91_Y1_32                0x00003050  // 32-bit Y[1] register.
#define P91_Y2_32                0x00003090  // 32-bit Y[2] register.
#define P91_Y3_32                0x000030D0  // 32-bit Y[3] register.
#define P91_X0_Y0_16             0x00003018  // 16-bit X[0]/Y[0] register.
#define P91_X1_Y1_16             0x00003058  // 16-bit X[1]/Y[1] register.
#define P91_X2_Y2_16             0x00003098  // 16-bit X[2]/Y[1] register.
#define P91_X3_Y3_16             0x000030D8  // 16-bit X[3]/Y[1] register.
#define P91_WIN_REL_BIT          0x00000020  // Window relative addressing bit.

//
// Define Power 9100 coprocesser status register address offset.
// (Page 28)
//
// Address format:
//
//   3                               1   1
//   1                               5   4                       2   1 0
// -----------------------------------------------------------------------
// | p p p p p p p p p p p p p p p p p | 0 1 0 0 0 0 0 0 0 0 0 0 0 | 0 0 |
// -----------------------------------------------------------------------
//
//  p - Address prefix bits.
//

#define P91_STATUS               0x00002000  // Status register.

//
// Define Power 9100 coprocesser parameter engine control and
// condition register address offsets.
// (Page 29)
//
// Address format:
//
//   3                               1   1
//   1                               5   4             7   6       2    1 0
// --------------------------------------------------------------------------
// | p p p p p p p p p p p p p p p p p | 0 1 0 0 0 0 1 1 | r r r r r  | 0 0 |
// --------------------------------------------------------------------------
//
//  p - Address prefix bits.
//  r - Resiter bits (6-2):
//        00000 - Not Used.
//        00001 - oor
//        00010 - Not Used.
//        00011 - cindex
//        00100 - w_off_xy
//        00101 - p_w_min
//        00110 - p_w_max
//        00111 - Not Used.
//        01000 - yclip
//        01001 - xclip
//        01010 - xedge_lt
//        01011 - xedge_gt
//        01100 - yedge_lt
//        01101 - yedge_gt
//

#define P91_PE_OOR               0x00002184  // Out of Range Reg. (read only)
#define P91_PE_CINDEX            0x0000218C  // Index Reg.
#define P91_PE_W_OFF_XY          0x00002190  // Window Offset Reg.
#define P91_PE_P_W_MIN           0x00002194  // Pixel Window Min Reg. (read only)
#define P91_PE_P_W_MAX           0x00002198  // Pixel Window Max Reg. (read only)
#define P91_PE_YCLIP             0x000021A0  // Y Clip Register. (read only)
#define P91_PE_XCLIP             0x000021A4  // X Clip Register. (read only)
#define P91_PE_XEDGE_LT          0x000021A8  // (read only)
#define P91_PE_XEDGE_GT          0x000021AC  // (read only)
#define P91_PE_YEDGE_LT          0x000021B0  // (read only)
#define P91_PE_YEDGE_GT          0x000021B4  // (read only)

//
// Define Power 9100 coprocesser drawing engine register address offsets.
// (Page 33)
//
// Address format:
//
//   3                               1   1
//   1                               5   4         9   8           2    1 0
// --------------------------------------------------------------------------
// | p p p p p p p p p p p p p p p p p | 0 1 0 0 0 1 | r r r r r r r  | 0 0 |
// --------------------------------------------------------------------------
//
//  p - Address prefix bits.
//  r - Resiter bits (8-2):
//        0000000 - color[0]
//        0000001 - color[1]
//        0000010 - pmask
//        0000011 - draw_mode
//        0000100 - pat_originx
//        0000101 - pat_originy
//        0000110 - raster
//        0000111 - pixel8
//        0001000 - p_w_min
//        0001001 - p_w_max
//        0001110 - color[2]
//        0001111 - color[3]
//        0100000 - pattern0
//        0100001 - pattern1
//        0100010 - pattern2
//        0100011 - pattern3
//        0101000 - b_w_min
//        0101001 - b_w_max
//

#define P91_DE_COLOR0            0x00002200  // Color register 0.
#define P91_DE_COLOR1            0x00002204  // Color register 1.
#define P91_DE_PMASK             0x00002208  // Plane Mask register.
#define P91_DE_DRAW_MODE         0x0000220C  // Draw Mode Register.
#define P91_DE_PAT_ORIGINX       0x00002210  // Pattern X Origin register.
#define P91_DE_PAT_ORIGINY       0x00002214  // Pattern Y Origin register.
#define P91_DE_RASTER            0x00002218  // Raster Operation register.
#define P91_DE_PIXEL8            0x0000221C  // Pixel 8 register.
#define P91_DE_P_W_MIN           0x00002220  // Pixel Window Clip Minimum.
#define P91_DE_P_W_MAX           0x00002224  // Pixel Window Clip Maximum.
#define P91_DE_COLOR2            0x00002238  // Color register 2.
#define P91_DE_COLOR3            0x0000223C  // Color register 3.
#define P91_DE_PATTERN0          0x00002280  // Pattern 0 register.
#define P91_DE_PATTERN1          0x00002284  // Pattern 1 register.
#define P91_DE_PATTERN2          0x00002288  // Pattern 2 register.
#define P91_DE_PATTERN3          0x0000228C  // Pattern 3 register.
#define P91_DE_B_W_MIN           0x000022A0  // Byte Window Clip Minimum.
#define P91_DE_B_W_MAX           0x000022A4  // Byte Window Clip Maximum.

//
// Define Power 9100 coprocesser video control register address offsets.
// Note:  The offsets for these registers are the same as for the Power 9000
//        except for srtctl2 which is new on the Power 9100.
// (Page 37)
//
// Address format:
//
//   3                               1   1
//   1                               5   4             7   6       2    1 0
// --------------------------------------------------------------------------
// | p p p p p p p p p p p p p p p p p | 0 0 0 0 0 0 1 0 | r r r r r  | 0 0 |
// --------------------------------------------------------------------------
//
//  p - Address prefix bits.
//  r - Resiter bits (6-2):
//        00001 - hrzc
//        00010 - hrzt
//        00011 - hrzsr
//        00100 - hrzbr
//        00101 - hrzbf
//        00110 - prehrzc
//        00111 - vrtc
//        01000 - vrtt
//        01001 - vrtsr
//        01010 - vrtbr
//        01011 - vrtbf
//        01100 - prevrtc
//        01101 - sraddr
//        01110 - srtctl
//        01111 - sraddr_inc
//        10000 - srtctl2
//

#define P91_HRZC                 0x00000104  // Horiz. counter (read only).
#define P91_HRZT                 0x00000108  // Horiz. length (read/write).
#define P91_HRZSR                0x0000010C  // Horiz. sync rising edge (read/write).
#define P91_HRZBR                0x00000110  // Horiz. blank rising edge (read/write).
#define P91_HRZBF                0x00000114  // Horiz. blank falling edge (read/write).
#define P91_PREHRZC              0x00000118  // Horiz. counter preload (read/write).
#define P91_VRTC                 0x0000011C  // Vert. counter (read only).
#define P91_VRTT                 0x00000120  // Vert. length (read/write).
#define P91_VRTSR                0x00000124  // Vert. sync rising edge (read/write).
#define P91_VRTBR                0x00000128  // Vert. blank rising edge (read/write).
#define P91_VRTBF                0x0000012C  // Vert. blank falling edge (read/write).
#define P91_PREVRTC              0x00000130  // Vert. counter preload (read/write).
#define P91_SRADDR               0x00000134  //
#define P91_SRTCTL               0x00000138  // Screen repaint timing control 1.
#define P91_SRADDR_INC           0x0000013C  //
#define P91_SRTCTL2              0x00000140  // Screen repaint timing control 2.
#define P91_SRTCTL2_N                (0x00)        // SRTCTL2 sync polarities...
#define P91_SRTCTL2_P                (0x01)
#define P91_SRTCTL2_H                (0x03)
#define P91_SRTCTL2_L                (0x02)
#define P91_HSYNC_HIGH_TRUE      0x00000000
#define P91_HSYNC_LOW_TRUE       0x00000001
#define P91_VSYNC_HIGH_TRUE      0x00000000
#define P91_VSYNC_LOW_TRUE       0x00000004

//
// Define Power 9100 coprocesser VRAM control register address offsets.
// Note:  The offsets for these registers are the same as for the Power 9000
//        except for pu_config which is new on the Power 9100.
// (Page 41)
//
// Address format:
//
//   3                               1   1
//   1                               5   4             7   6       2    1 0
// --------------------------------------------------------------------------
// | p p p p p p p p p p p p p p p p p | 0 0 0 0 0 0 1 1 | r r r r r  | 0 0 |
// --------------------------------------------------------------------------
//
//  p - Address prefix bits.
//  r - Resiter bits (6-2):
//        00001 - mem_config
//        00010 - rfperiod
//        00011 - rfcount
//        00100 - rlmax
//        00101 - rlcur
//        00110 - pu_config
//

#define P91_MEM_CONFIG           0x00000184  // Memory Configuration Register.
#define P91_RFPERIOD             0x00000188  // Refresh Period Register.
#define P91_RFCOUNT              0x0000018C  // Refresh Count Register.
#define P91_RLMAX                0x00000190  // RAS Low Miaximum Register.
#define P91_RLCUR                0x00000194  // RAS Low Current Register.
#define P91_PU_CONFIG            0x00000198  // Power-Up Configuration Register.
#define P91_EXT_IO_ID            0x00000208  // Get external board id value from here
                                                                                         // to detect Intergraph board
//
// Define Power 9100 coprocesser meta-coordinate pseudo-register address
// offsets.
// (Page 43)
//
// Address format:
//
//   3                               1   1
//   1                               5   4         9   8   6   5   4 3   2 1 0
// -----------------------------------------------------------------------------
// | p p p p p p p p p p p p p p p p p | 0 1 1 0 0 1 | v v v | a | y x | 0 0 0 |
// -----------------------------------------------------------------------------
//
//  p - Address prefix bits.
//  v - Vtype bits (8-6):
//        000 - point
//        001 - line
//        010 - triangle
//        011 - quad
//        100 - rectangle
//  a - Screen addressing bit (5):
//         0 - Perform addressing relative to the window offset.
//         1 - Perform addressing relative to the previos vertex.
// yx - 32/16 bit read/write bits (4-3):
//        00 - Not used.
//        01 - Read or write 32-bit X value.
//        10 - Read or write 32-bit Y value.
//        11 - Read or write 16-bit X value (high 16 bits) Y value (low 16 bits).
//

#define P91_META_X_32            0x00003208  // 32-bit X coordinate value.
#define P91_META_Y_32            0x00003210  // 32-bit Y coordinate value.
#define P91_META_X_Y_16          0x00003218  // 16-bit X/Y coordinate value.
#define P91_META_POINT           0x00000000  // Point draw type bits.
#define P91_META_LINE            0x00000040  // Line draw type bits.
#define P91_META_TRIANGLE        0x00000080  // Triangle draw type bits.
#define P91_META_QUAD            0x000000C0  // Quadrilateral draw type bits.
#define P91_META_RECT            0x00000100  // Rectangle draw type bits.
#define P91_META_WIN_REL         0x00000000  // Window relative addressing bits.
#define P91_META_VERT_REL        0x00000020  // Vertex relative addressing bits.

//
// Define Power 9100 coprocesser quad command register address offset.
// (Page 44)
//
// Address format:
//
//   3                               1   1
//   1                               5   4                       2   1 0
// -----------------------------------------------------------------------
// | p p p p p p p p p p p p p p p p p | 0 1 0 0 0 0 0 0 0 0 0 1 0 | 0 0 |
// -----------------------------------------------------------------------
//
//  p - Address prefix bits.
//

#define P91_QUAD                 0x00002008  // Quad Command Register.

//
// Define Power 9100 coprocesser blit command register address offset.
// (Page 44)
//
// Address format:
//
//   3                               1   1
//   1                               5   4                       2   1 0
// -----------------------------------------------------------------------
// | p p p p p p p p p p p p p p p p p | 0 1 0 0 0 0 0 0 0 0 0 0 1 | 0 0 |
// -----------------------------------------------------------------------
//
//  p - Address prefix bits.
//

#define P91_BLIT                 0x00002004  // Blit Command Register.

//
// Define Power 9100 coprocesser pixel8 command register address offset.
// (Page 45)
//
// Address format:
//
//   3                               1   1
//   1                               5   4                       2   1 0
// -----------------------------------------------------------------------
// | p p p p p p p p p p p p p p p p p | 1 - - - - - - - - - - - - | 0 0 |
// -----------------------------------------------------------------------
//
//  p - Address prefix bits.
//

#define P91_PIXEL8               0x00004000  // Pixel 8 Command Register.

//
// Define Power 9100 coprocesser pixel1 command register address offset.
// (Page 45)
//
// Address format:
//
//   3                               1   1
//   1                               5   4             7   6       2   1 0
// -------------------------------------------------------------------------
// | p p p p p p p p p p p p p p p p p | 0 1 0 0 0 0 0 1 | # # # # # | 0 0 |
// -------------------------------------------------------------------------
//
//  p - Address prefix bits.
//

#define P91_PIXEL1               0x00002080  // Pixel 1 Command Register.
#define P91_PIXEL1_COUNT_MSK     0x0000007C  // Pixel Count Mask
#define P91_PIXEL1_32_PIXELS     0x0000007C  // Maximum Pixel Count

//
// Define Power 9100 coprocesser next pixels command register address offset.
// (Page 46)
//
// Address format:
//
//   3                               1   1
//   1                               5   4                       2   1 0
// -----------------------------------------------------------------------
// | p p p p p p p p p p p p p p p p p | 0 1 0 0 0 0 0 0 0 0 1 0 1 | 0 0 |
// -----------------------------------------------------------------------
//
//  p - Address prefix bits.
//

#define P91_NEXT_PIXELS          0x00002014  // Next Pixels Command Register.

//   3                               1
//   1                               5                             0
// -------------------------------------------------------------------
// | 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 |
// -------------------------------------------------------------------


//
// Define the Power-Up Configuration Register Bits.
// Page (Page 13)
//  2   1  1     1  1
//  3   6  5     2  1   8  7   5   4   3   2 1   0
// -------------------------------------------------
// |  0  | - - - - |  0  | - - - | - | - | - - | - |
// -------------------------------------------------
//    |    | | | |    |    | | |   |   |   | |   |
//    |    -------    |    -----   |   |   ---   |
//    |       |       |      |     |   |    |    ----> Motherboard implementation.
//    |       |       |      |     |   |    ---------> EEProm Type
//    |       |       |      |     |   --------------> VRAM SAM Size.
//    |       |       |      |     ------------------> VRAM Memory Depth.
//    |       |       |      ------------------------> Frequency Synthesizer type.
//    |       |       -------------------------------> Reserved.
//    |       ---------------------------------------> RAMDAC Type.
//    -----------------------------------------------> Reserved.
//
//   3 3   2   2   2   2   2
//   1 0   9   7   6   5   4
// ---------------------------
// | - - | - - - | - | - | 0 |
// ---------------------------
//   | |   | | |   |   |   |
//   ---   -----   |   |   ---------------> Reserved.
//    |      |     |   -------------------> VGA presence.
//    |      |     -----------------------> Initial Mode Select.
//    |      -----------------------------> Configuration Registers Base Address.
//    ------------------------------------> Bus Type.
//

#define P91_PUC_IMPLEMENTATION   0x00000001  //
#define P91_PUC_MOTHER_BOARD     0x00000000  //
#define P91_PUC_ADD_IN_CARD      0x00000001  //
#define P91_PUC_EEPROM_TYPE      0x00000006  //
#define P91_PUC_EEPROM_AT24C01   0x00000000  //
#define P91_PUC_VRAM_SAM_SIZE    0x00000008  //
#define P91_PUC_FULL_SIZE_SHIFT  0x00000000  //
#define P91_PUC_HALF_SIZE_SHIFT  0x00000008  //
#define P91_PUC_MEMORY_DEPTH     0x00000010  //
#define P91_PUC_256K_VRAMS       0x00000000  //
#define P91_PUC_128K_VRAMS       0x00000010  //
#define P91_PUC_FREQ_SYNTH_TYPE  0x000000E0  //
#define P91_PUC_EXT_IO           0x00000100  // External I/O regs are on DAC interface
#define P91_PUC_ICD_2061A        0x00000000  // ICD2061a
#define P91_PUC_FIXED_MEMCLK     0x00000020  // Fixed MEMCLK, RAMDAC gens pixclk
#define P91_PUC_RAMDAC_TYPE      0x0000F000  //
#define P91_PUC_DAC_BT485        0x00000000  //
#define P91_PUC_DAC_BT489        0x00001000  //
#define P91_PUC_DAC_IBM525       0x00008000  //
#define P91_PUC_VGA_PRESENCE     0x02000000  //
#define P91_PUC_VGA_ABSENT       0x00000000  //
#define P91_PUC_VGA_PRESENT      0x02000000  //
#define P91_PUC_INITIAL_MODSEL   0x04000000  //
#define P91_PUC_NATIVE_MODE      0x00000000  //
#define P91_PUC_VGA_MODE         0x04000000  //
#define P91_PUC_CONFIG_REG_BASE  0x38000000  //
#define P91_PUC_BASE_9100_9104   0x00000000  //
#define P91_PUC_BASE_9108_910C   0x08000000  //
#define P91_PUC_BASE_9110_9114   0x10000000  //
#define P91_PUC_BASE_9118_911C   0x18000000  //
#define P91_PUC_BASE_9120_9124   0x20000000  //
#define P91_PUC_BASE_9128_912C   0x28000000  //
#define P91_PUC_BASE_9130_9134   0x30000000  //
#define P91_PUC_BASE_9138_913C   0x38000000  //
#define P91_PUC_BUS_TYPE         0xC0000000  //
#define P91_PUC_BUS_PCI          0x40000000  //
#define P91_PUC_BUS_VESA         0x80000000  //

//
// Define Power up configuration bit field positions for use in shifting
// the various fields to bit 0.
//

#define P91_PUC_EEPROM_SHIFT_CNT 0x01
#define P91_PUC_SYNTH_SHIFT_CNT  0X05
#define P91_PUC_RAMDAC_SHIFT_CNT 0x0C
#define P91_PUC_REG_SHIFT_CNT    0x1B
#define P91_PUC_BUS_SHIFT_CNT    0x1E

//
// Define the System Configuration Register Bits.
// (Page 24)
//   1   1   1   1   1   1   1   1
//   9   7   6   4   3   2   1   0   9  8 0
// -----------------------------------------
// | - - - | - - - | - | - | - | - | - | 0 |
// -----------------------------------------
//   | | |   | | |   |   |   |   |   |   |
//   -----   -----   |   |   |   |   |   -> Reserved. Must be 0.
//     |       |     |   |   |   |   -----> Pixel write buffer selection.
//     |       |     |   |   |   ---------> Pixel read buffer selection.
//     |       |     |   |   -------------> Pixel access bit swap.
//     |       |     |   -----------------> Pixel access byte swap.
//     |       |     ---------------------> Pixel access half-word swap.
//     |       ---------------------------> Shift control 2.
//     -----------------------------------> Shift control 1.
//
//   3   3 2   2   2   2   2   2   2   2
//   1   0 9   8   6   5   4   3   2   0
// ---------------------------------------
// | 0 | - - | - - - | - | - | - | - - - |
// ---------------------------------------
//   |    |    | | |   |   |   |   | | |
//   |    |    -----   |   |   |   -----
//   |    |      |     |   |   |     |
//   |    |      |     |   |   |     -----> Shift control 0.
//   |    |      |     |   |   -----------> Overide internal PLL.
//   |    |      |     |   ---------------> Frame buffer controller drive load.
//   |    |      |     -------------------> Disable internal selftiming on FBC.
//   |    |      -------------------------> Pixel size for drawing engine.
//   |    --------------------------------> Shift control 3.
//   -------------------------------------> Reserved. Must be 0.
//

#define P91_WRITE_BUF_1          0x00000200
#define P91_READ_BUF_1           0x00000400
#define P91_SWAP_BITS            0x00000800
#define P91_SWAP_BYTES           0x00001000
#define P91_SWAP_WORDS           0x00002000
#define P91_SHIFT2_0             0x00000000
#define P91_SHIFT2_32            0x00004000
#define P91_SHIFT2_64            0x00008000
#define P91_SHIFT2_128           0x0000C000
#define P91_SHIFT2_256           0x00010000
#define P91_SHIFT2_512           0x00014000
#define P91_SHIFT2_FIELD_INC     0x00004000
#define P91_SHIFT1_0             0x00000000
#define P91_SHIFT1_64            0x00040000
#define P91_SHIFT1_128           0x00060000
#define P91_SHIFT1_256           0x00080000
#define P91_SHIFT1_512           0x000A0000
#define P91_SHIFT1_1024          0x000C0000
#define P91_SHIFT1_FIELD_INC     0x00020000
#define P91_SHIFT0_0             0x00000000
#define P91_SHIFT0_128           0x00300000
#define P91_SHIFT0_256           0x00400000
#define P91_SHIFT0_512           0x00500000
#define P91_SHIFT0_1024          0x00600000
#define P91_SHIFT0_2048          0x00700000
#define P91_SHIFT0_FIELD_INC     0x00100000
#define P91_EXT_PLL_CLOCK        0x00800000
#define P91_DBL_DRIVE_LOAD       0x01000000
#define P91_SELFTIME_DIS         0x02000000
#define P91_DE_8BPP              0x08000000
#define P91_DE_16BPP             0x0C000000
#define P91_DE_24BPP             0x1C000000
#define P91_DE_32BPP             0x14000000
#define P91_SHIFT3_0             0x00000000
#define P91_SHIFT3_1024          0x20000000
#define P91_SHIFT3_2048          0x40000000
#define P91_SHIFT3_4096          0x60000000
#define P91_SHIFT3_FIELD_INC     0x20000000

//
// Define the Interrupt Register Bits.
// Note:  These are exactly the same as the Power 9000 bit definitions.
// (Page 25)
//  3
//  1   6  5 4   3 2   1 0
// -------------------------
// |  0  | - - | - - | - - |
// -------------------------
//    |    | |   | |   | |
//    |    | |   | |   | -----------------> Draw Engine Idle INT.
//    |    | |   | |   -------------------> Draw Engine Idle INT Write Enable.
//    |    | |   | -----------------------> Pick Done INT.
//    |    | |   -------------------------> Pick Done INT. Write Enable.
//    |    | -----------------------------> VBlank Done INT.
//    |    -------------------------------> VBlank Done INT Write Enable.
//    ------------------------------------> Reserved. Must be 0.
//

#define P91_DE_IDLE              0x00000001
#define P91_DE_IDLE_CLEAR        0x00000002
#define P91_PICK_DONE            0x00000004
#define P91_PICK_DONE_CLEAR      0x00000008
#define P91_VBLANK_DONE          0x00000010
#define P91_VBLANK_DONE_CLEAR    0x00000020

//
// Define the Interrupt Enable Register Bits.
// Note:  These are exactly the same as the Power 9000 bit definitions.
// Page (26)
//  3
//  1   8  7 6   5 4   3 2   1 0
// -------------------------------
// |  0  | - - | - - | - - | - - |
// -------------------------------
//    |    | |   | |   | |   | |
//    |    | |   | |   | |   | -----------> Draw Engine Int. Enable.
//    |    | |   | |   | |   -------------> Draw Engine Write Enable.
//    |    | |   | |   | -----------------> Pick Int. Enable.
//    |    | |   | |   -------------------> Pick Write Enable.
//    |    | |   | -----------------------> VBlank Int. Enable.
//    |    | |   -------------------------> VBlank Write Enable.
//    |    | -----------------------------> Master Int. Enable.
//    |    -------------------------------> Master Enable Write Enable.
//    ------------------------------------> Reserved. Must be 0.
//

#define P91_DE_IDLE_DIS          0x00000002  // Disable Draw Engine idle INT.
#define P91_DE_IDLE_EN           0x00000003  // Enable Draw Engine idle INT.
#define P91_PICKED_DIS           0x00000008  // Disable Pick INT.
#define P91_PICKED_EN            0x0000000C  // Enable Pick INT.
#define P91_VBLANKED_DIS         0x00000020  // Disable VBlank INT.
#define P91_VBLANKED_EN          0x00000030  // Enable VBlank INT.
#define P91_MASTER_DIS           0x00000080  // Disable all interrupts.
#define P91_MASTER_EN            0x000000C0  // Enable INTs according to bits 5-0.

//
// Define the Status Register Bits.
// Note:  These are exactly the same as the Power 9000 bit definitions.
// (Page 28)
//   3   3  2
//   1   0  9   8  7   6   5   4   3   2   1   0
// -----------------------------------------------
// | - | - |  0  | - | - | - | - | - | - | - | - |
// -----------------------------------------------
//  |    |    |    |   |   |   |   |   |   |   |
//  |    |    |    |   |   |   |   |   |   |   ----> Quad intersects clip window.
//  |    |    |    |   |   |   |   |   |   --------> Quad inside clip window.
//  |    |    |    |   |   |   |   |   ------------> Quad outside clip window.
//  |    |    |    |   |   |   |   ----------------> Quad is concave.
//  |    |    |    |   |   |   --------------------> Quad must be done by software.
//  |    |    |    |   |   ------------------------> Blit must be done by software.
//  |    |    |    |   ----------------------------> Pixel must be done by software.
//  |    |    |    --------------------------------> Pick detected.
//  |    |    -------------------------------------> Reserved.
//  |    ------------------------------------------> Drawing engine busy.
//  -----------------------------------------------> Quad/blit re-initiate.
//

#define P91_SR_QUAD_INTERSECT 0x00000001
#define P91_SR_QUAD_VISIBLE   0x00000002
#define P91_SR_QUAD_HIDDEN    0x00000004
#define P91_SR_QUAD_CONCAVE   0x00000008
#define P91_SR_QUAD_SOFTWARE  0x00000010
#define P91_SR_BLIT_SOFTWARE  0x00000020
#define P91_SR_PIXEL_SOFTWARE 0x00000040
#define P91_SR_PICKED         0x00000080
#define P91_SR_ENGINE_BUSY    0x40000000
#define P91_SR_NO_REINITIATE  0x80000000

//
// Define the Draw Mode Register Bits.
// Note:  These are exactly the same as the Power 9000 bit definitions.
// Page (34)
//  3
//  1   4  3 2   1 0
// -------------------
// |  0  | - - | - - |
// -------------------
//    |    | |   | |
//    |    | |   | -----------------------> Pick write enable bit.
//    |    | |   -------------------------> Write enable Pick write enable bit.
//    |    | -----------------------------> Buffer selection bit.
//    |    -------------------------------> Write enable Buffer selection bit.
//    ------------------------------------> Reserved.  Must be 0.
//

#define P91_WR_INSIDE_WINDOW     0x00000002
#define P91_SUPPRESS_ALL_WRITES  0x00000003
#define P91_DE_DRAW_BUFF_0       0x00000008
#define P91_DE_DRAW_BUFF_1       0x0000000C

//
// Define the Raster Register Bits.
// (Page 34)
//  3   1  1   1   1   1   1  1
//  1   8  7   6   5   4   3  2   8  7             0
// ---------------------------------------------------
// |  0  | - | - | - | - | - |  0  | - - - - - - - - |
// ---------------------------------------------------
//    |    |   |   |   |   |    |    | | | | | | | |
//    |    |   |   |   |   |    |    ---------------
//    |    |   |   |   |   |    |           |
//    |    |   |   |   |   |    |           --------> Minterms.
//    |    |   |   |   |   |    --------------------> Reserved.
//    |    |   |   |   |   -------------------------> Solid Color Disable.
//    |    |   |   |   -----------------------------> Pattern Depth.
//    |    |   |   ---------------------------------> Transparent Pixel1 Enable.
//    |    |   -------------------------------------> Quad Draw Mode.
//    |    -----------------------------------------> Transparent Pattern Enable.
//    ----------------------------------------------> Reserved.
//

#define P91_RR_SOLID_ENABLE      0x00000000
#define P91_RR_SOLID_DISABLE     0x00002000
#define P91_RR_2_CLR_PATTERN     0x00000000
#define P91_RR_4_CLR_PATTERN     0x00004000
#define P91_RR_TRANS_PIX1_DISABL 0x00000000
#define P91_RR_TRANS_PIX1_ENABLE 0x00008000
#define P91_RR_QUAD_X11_MODE     0x00000000
#define P91_RR_QUAD_OVERSIZE     0x00010000
#define P91_RR_TRANS_PAT_DISABL  0x00000000
#define P91_RR_TRANS_PAT_ENABLE  0x00020000

//
// Define the Screen Repaint Timing Control (SRTCTL) Register Bits.
// (Page 40)
//  3   1  1   1
//  1   2  1   0 9   8   7   6   5   4   3   2   0
// -------------------------------------------------
// |  0  | - | - - | - | - | 0 | - | - | - | - - - |
// -------------------------------------------------
//    |    |   | |   |   |   |   |   |   |   | | |
//    |    |   ---   |   |   |   |   |   |   -----
//    |    |    |    |   |   |   |   |   |     |
//    |    |    |    |   |   |   |   |   |     -----> QSF Counter Position.
//    |    |    |    |   |   |   |   |   -----------> Buffer For Display.
//    |    |    |    |   |   |   |   ---------------> Screen Repaint Mode.
//    |    |    |    |   |   |   -------------------> Enable Video.
//    |    |    |    |   |   -----------------------> Reserved.
//    |    |    |    |   ---------------------------> Internal Horizontal Sync.
//    |    |    |    -------------------------------> Internal Vertical Sync.
//    |    |    ------------------------------------> SRADDR Increment Value.
//    |    -----------------------------------------> 24-Bit DAC Clock Skip Mode.
//    ----------------------------------------------> Reserved.
//

#define P91_SRTCTL_QSF_MSK       0x00000007
#define P91_SRTCTL_DISP_BUFFER   0x00000004
#define P91_SRTCTL_DISP_BUFF_0   0x00000000
#define P91_SRTCTL_DISP_BUFF_1   0x00000004
#define P91_SRTCTL_HBLNK_RELOAD  0x00000010
#define P91_SRTCTL_HR_NORMAL     0x00000000
#define P91_SRTCTL_HR_RESTRICTED 0x00000010
#define P91_SRTCTL_ENABLE_VIDEO  0x00000020
#define P91_SRTCTL_HSYNC         0x00000080
#define P91_SRTCTL_HSYNC_EXT     0x00000000
#define P91_SRTCTL_HSYNC_INT     0x00000080
#define P91_SRTCTL_VSYNC         0x00000100
#define P91_SRTCTL_VSYNC_EXT     0x00000000
#define P91_SRTCTL_VSYNC_INT     0x00000100
#define P91_SRTCTL_SRC_INCS      0x00000600
#define P91_SRTCTL_SRC_INC_256   0x00000000
#define P91_SRTCTL_SRC_INC_512   0x00000200
#define P91_SRTCTL_SRC_INC_1024  0x00000400
#define P91_SRTCTL_V_24EN        0x00000800
#define P91_SRTCTL_24EN_DISABLE  0x00000000
#define P91_SRTCTL_24EN_ENABLE   0x00000800

//
// Define the Screen Repaint Timing Control 2 (SRTCTL2) Register Bits.
// (Page 40)
//  3
//  1   4  3 2   1 0
// -------------------
// |  0  | - - | - - |
// -------------------
//    |    | |   | |
//    |    ---   ---
//    |     |     |
//    |     |     ------------------------> External VSYNC Polarity Control.
//    |     ------------------------------> External HSYNC Polarity Control.
//    ------------------------------------> Reserved.
//

#define P91_SRTCTL2_EXT_VSYNC    0x00000003

#if 0
#define P91_VSYNC_LOW_TRUE       0x00000000
#define P91_VSYNC_HIGH_TRUE      0x00000001
#endif

#define P91_VSYNC_LOW_FORCED     0x00000002
#define P91_VSYNC_HIGH_FORCED    0x00000003
#define P91_SRTCTL2_EXT_HSYNC    0x0000000C

#if 0
#define P91_HSYNC_LOW_TRUE       0x00000000
#define P91_HSYNC_HIGH_TRUE      0x00000004
#endif

#define P91_HSYNC_LOW_FORCED     0x00000008
#define P91_HSYNC_HIGH_FORCED    0x0000000C

//
// Define the Memory Configuration Register Bits.
// (Page 42)
//   9   8   7   6   5   4   3   2   0
// -------------------------------------
// | - | - | - | - | - | - | - | - - - |
// -------------------------------------
//   |   |   |   |   |   |   |   | | |
//   |   |   |   |   |   |   |   -----
//   |   |   |   |   |   |   |     |
//   |   |   |   |   |   |   |     -------> VRAM Memory Confiuration [2..0].
//   |   |   |   |   |   |   -------------> VRAM Row Miss Timing Adjustment.
//   |   |   |   |   |   -----------------> VRAM Read Timing Adjustment.
//   |   |   |   |   ---------------------> VRAM Write Timing Adjustment.
//   |   |   |   -------------------------> VCP Priority Select.
//   |   |   -----------------------------> RAMDAC Access Adjustment.
//   |   ---------------------------------> DAC Read/Write signalling mode.
//   -------------------------------------> Memory/Video Reset.
//
//   2   2   1   1   1 1   1   1   1   1
//   1   0   9   8   7 6   5   3   2   0
// ---------------------------------------
// | - | - | - | 0 | - - | - - - | - - - |
// ---------------------------------------
//   |   |   |   |   | |   | | |   | | |
//   |   |   |   |   ---   -----   -----
//   |   |   |   |    |      |       |
//   |   |   |   |    |      |       -----> VRAM Shift Clock State Macine.
//   |   |   |   |    |      -------------> Internal CRTC Divided Dot Clock.
//   |   |   |   |    --------------------> Muxsel pin polarity.
//   |   |   |   -------------------------> Reserved.
//   |   |   -----------------------------> Clock Edge Syrchonization.
//   |   ---------------------------------> Video Clock Source Selection.
//   -------------------------------------> Additional Divide for Video Transfer.
//
//   3   3   2   2 2   2   2 2   2 2
//   1   0   9   8 7   6   5 4   3 2
// -----------------------------------
// | - | - | - | - - | 0 | - - | - - |
// -----------------------------------
//   |   |   |   | |   |   | |   | |
//   |   |   |   ---       ---   ---
//   |   |   |    |    |    |     |
//   |   |   |    |    |    |     --------> Shift Clock Timing Pattern Selection.
//   |   |   |    |    |    --------------> Serial Output Timing Pattern Selection.
//   |   |   |    |    -------------------> Reserved.
//   |   |   |    ------------------------> Blank Generation Delay Selection.
//   |   |   -----------------------------> VRAM Memory Configuration [3].
//   |   ---------------------------------> Slow Host Interface Adjustment.
//   -------------------------------------> VRAM REad Timing Adjustment.
//
//
//

#define P91_MC_CNFG_2_0_MSK      0x00000007
#define P91_MC_CNFG_3_MSK        0x20000000
#define P91_MC_CNFG_MSK          0x20000007
#define P91_MC_CNFG_1            0x00000001  // 2 banks, 128K VRAMs, 1 1Mb buffer.
#define P91_MC_CNFG_3            0x00000003  // 4 banks, 128K VRAMs, 1 2Mb buffer.
#define P91_MC_CNFG_4            0x00000004  // 1 bank, 256K VRAMs, 1 1Mb buffer.
#define P91_MC_CNFG_5            0x00000005  // 2 banks, 256K VRAMs, 1 2Mb buffer.
#define P91_MC_CNFG_7            0x00000007  // 4 banks, 256K VRAMs, 1 4Mb buffer.
#define P91_MC_CNFG_11           0x20000003  // 4 banks, 128K VRAMs, 2 1Mb buffers.
#define P91_MC_CNFG_14           0x20000006  // 2 banks, 256K VRAMs, 2 1Mb buffers.
#define P91_MC_CNFG_15           0x20000007  // 4 banks, 256K VRAMs, 2 2Mb buffers.
#define P91_MC_MISS_ADJ_0        0x00000000
#define P91_MC_MISS_ADJ_1        0x00000008
#define P91_MC_READ_ADJ_0        0x00000000
#define P91_MC_READ_ADJ_1        0x00000010
#define P91_MC_WRITE_ADJ_0       0x00000000
#define P91_MC_WRITE_ADJ_1       0x00000020
#define P91_MC_VCP_PRIORITY_LO   0x00000000
#define P91_MC_VCP_PRIORITY_HI   0x00000040
#define P91_MC_DAC_ACCESS_ADJ_0  0x00000000
#define P91_MC_DAC_ACCESS_ADJ_1  0x00000080
#define P91_MC_DAC_MODE_0        0x00000000
#define P91_MC_DAC_MODE_1        0x00000100
#define P91_MC_HOLD_RESET        0x00000200
#define P91_MC_MEM_VID_NORMAL    0x00000000
#define P91_MC_MEM_VID_RESET     0x00000200
#define P91_MC_SHFT_CLK_DIV_1    0x00000000
#define P91_MC_SHFT_CLK_DIV_2    0x00000400
#define P91_MC_SHFT_CLK_DIV_4    0x00000800
#define P91_MC_SHFT_CLK_DIV_8    0x00000C00
#define P91_MC_SHFT_CLK_DIV_16   0x00001000
#define P91_MC_CRTC_CLK_DIV_1    0x00000000
#define P91_MC_CRTC_CLK_DIV_2    0x00002000
#define P91_MC_CRTC_CLK_DIV_4    0x00004000
#define P91_MC_CRTC_CLK_DIV_8    0x00006000
#define P91_MC_CRTC_CLK_DIV_16   0x00008000
#define P91_MC_MUXSEL_NORMAL     0x00000000
#define P91_MC_MUXSEL_INVERT     0x00010000
#define P91_MC_MUXSEL_LOW        0x00020000
#define P91_MC_MUXSEL_HIGH       0x00030000
#define P91_MC_BLANK_EDGE_MSK    0x00080000
#define P91_MC_SYNC_RISE_EDGE    0x00000000
#define P91_MC_SYNC_FALL_EDGE    0x00080000
#define P91_MC_VCLK_SRC_PIXCLK   0x00000000
#define P91_MC_VCLK_SRC_DDOTCLK  0x00100000
#define P91_MC_VAD_DIV_1         0x00000000
#define P91_MC_VAD_DIV_2         0x00200000
#define P91_MC_SHFT_CLK_1_BANK   0x00000000
#define P91_MC_SHFT_CLK_2_BANK   0x00400000
#define P91_MC_SHFT_CLK_4_BANK   0x00800000
#define P91_MC_SERIAL_OUT_1_BANK 0x00000000
#define P91_MC_SERIAL_OUT_2_BANK 0x01000000
#define P91_MC_SERIAL_OUT_4_BANK 0x02000000
#define P91_MC_BLNKDLY_MSK       0x18000000
#define P91_MC_BLNKDLY_0_CLK     0x00000000
#define P91_MC_BLNKDLY_1_CLK     0x08000000
#define P91_MC_BLNKDLY_2_CLK     0x10000000
#define P91_MC_BLNKDLY_3_CLK     0x18000000
#define P91_MC_SLOW_HOST_ADJ_0   0x00000000
#define P91_MC_SLOW_HOST_ADJ_1   0x40000000
#define P91_MC_READ_SMPL_ADJ_0   0x00000000
#define P91_MC_READ_SMPL_ADJ_1   0x80000000

    //
    //  structure for temporary storage for VGA / Graphic switching
    //

typedef  struct _VGA_REGS {
    UCHAR MiscOut;
    UCHAR CR[0x18];
    UCHAR SR[4];
    UCHAR GR[8];
    UCHAR AR[0x14];
    UCHAR LUT[3 * 256];
} VGA_REGS, *PVGA_REGS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\p91bt485.c ===
/*++

Copyright (c) 1993, 1994  Weitek Corporation

Module Name:

    bt485.c

Abstract:

    This module contains code specific to the Bt485 DAC on P9x0x adapters.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

#include "p9.h"
#include "p9gbl.h"
#include "p9000.h"
#include "bt485.h"
#include "p91regs.h"
#include "p91dac.h"


#define PIX_PORT_15 0x30

//
// DAC specific static data.
//

UCHAR
ReadDAC(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG ulIndex
    );

VOID
WriteDAC(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG ulIndex,
    UCHAR ucValue
    );

VOID
P91Bt485SetPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG *pPal,
    ULONG StartIndex,
    ULONG Count
    );

VOID
P91Bt485SetPointerPos(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG   ptlX,
    ULONG   ptlY
    );

VOID
P91Bt485SetPointerShape(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR  pHWCursorShape
    );

VOID
P91Bt485PointerOn(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
P91Bt485PointerOff(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
P91Bt485ClearPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
P91Bt485SetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
P91Bt485RestoreMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
P91Bt485SetClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
P91Bt485ClrClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

//
// Define the DAC support routines structure for the Bt485 DAC.
//

DAC P91Bt485 = {
    DAC_ID_BT485,
    NUM_DAC_REGS,
    P91Bt485SetMode,
    P91Bt485RestoreMode,
    P91Bt485SetPalette,
    P91Bt485ClearPalette,
    P91Bt485PointerOn,
    P91Bt485PointerOff,
    P91Bt485SetPointerPos,
    P91Bt485SetPointerShape,
    CLK_MAX_FREQ,
    P91Bt485SetClkDoubler,
    P91Bt485ClrClkDoubler,
    DAC_ID_BT485,
    32,
    FALSE,
    FALSE,
    FALSE
};

//
//  Power 9100 Bt485 DAC register definitions.  See comments in
//  VLGetBaseAddrP91().
//
ULONG P91_Bt485_DAC_Regs[] =
{
    P9100_RAMWRITE,
    P9100_PALETDATA,
    P9100_PIXELMASK,
    P9100_RAMREAD,
    P9100_COLORWRITE,
    P9100_COLORDATA,
    P9100_COMREG0,
    P9100_COLORREAD,
    P9100_COMREG1,
    P9100_COMREG2,
    P9100_COMREG3,
    P9100_CURSORDATA,
    P9100_CURSORX0,
    P9100_CURSORX1,
    P9100_CURSORY0,
    P9100_CURSORY1
};


VOID
P91Bt485SetPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG *pPal,
    ULONG StartIndex,
    ULONG Count
    )

/*++

Routine Description:

    Sets the Device palette

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    pPal - Pointer to the array of pallete entries.

    StartIndex - Specifies the first pallete entry provided in pPal.

    Count - Number of palette entries in pPal

Return Value:

    None.

--*/

{
    UCHAR  *pBytePal;

    PAL_WR_ADDR((UCHAR) StartIndex);

    pBytePal = (PUCHAR) pPal;

    //
    // Load the palette with RGB values. The input palette has 4 bytes
    // per entry, the last of which is ignored.
    //

    while (Count--)
    {
        PAL_WR_DATA(*pBytePal++);
        PAL_WR_DATA(*pBytePal++);
        PAL_WR_DATA(*pBytePal++);
        pBytePal++;
    }
}


VOID
P91Bt485SetPointerPos(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG   ptlX,
    ULONG   ptlY
    )

/*++

Routine Description:

    Move Hardware Pointer.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ptlX, ptlY - Requested X,Y position for the pointer.

Return Value:

    TRUE

--*/

{

    //
    // Strip off the invalid bits and update the cursor position regs.
    //

    WR_CURS_POS_X(((ptlX + CURSOR_WIDTH) & 0xFFF));
    WR_CURS_POS_Y(((ptlY + CURSOR_HEIGHT) & 0xFFF));

    return;
}


VOID
P91Bt485SetPointerShape(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR  pHWCursorShape
    )

/*++

Routine Description:

    Sets the hardware cursor shape.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    pHWCursorShape - Pointer to the cursor bitmap.

Return Value:

    None.

--*/

{
    ULONG   iCount;

    //
    // The # of bytes of cursor bitmap data to send *= 2 for and/xor mask
    // *= 8 for 8bit/byte
    // *= 2 for 2 loops
    //

    ULONG iLoop  = (CURSOR_WIDTH * CURSOR_HEIGHT * 2) / (8 * 2);

    //
    // AND mask will be loaded to plane 1.
    //

    PAL_WR_ADDR(0x80);

    iCount = iLoop;

    WAIT_FOR_RETRACE();

    while (iCount--)
    {
        WR_CURS_DATA(*pHWCursorShape++);
    }

    //
    // XOR mask will be loaded to plane 0.
    //

    PAL_WR_ADDR(0x00);

    iCount = iLoop;

    WAIT_FOR_RETRACE();

    while (iCount--)
    {
        WR_CURS_DATA(*pHWCursorShape++);
    }

    return;
}


VOID
P91Bt485PointerOn(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

  Turn on the hardware cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{


    //
    // Turn the cursor on only if it was disabled.
    //

    if (!CURS_IS_ON())
    {
        WAIT_FOR_RETRACE();
        CURS_ON();
    }

    return;
}


VOID
P91Bt485PointerOff(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

  Turn off the hardware cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{


    //
    // Turn the cursor off only if it was enabled.
    //

    if (CURS_IS_ON())
    {
        WAIT_FOR_RETRACE();
        CURS_OFF();
    }

    return;
}


VOID
P91Bt485ClearPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Clears the palette to all 0's

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{
    int Count;

    //
    // Calculate the number of palette entries. It is assumed that the
    // caller has already determined that the current mode makes use
    // of the palette,
    //

    Count = 1 << HwDeviceExtension->usBitsPixel;

    //
    // Fill the palette with RGB values of 0.
    //

    while (Count--)
    {
        PAL_WR_DATA(0);
        PAL_WR_DATA(0);
        PAL_WR_DATA(0);
    }

    return;
}


BOOLEAN
P91Bt485SetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Initializes the DAC for the current mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/
{
    UCHAR   ucCurState;

    //
    // Enable 8bit dacs, allow access to Command Register 3.
    //

    //
    // Enable accesses to CMD_REG_3.  For the Power 9100, to access command
    // register 3, you must have CR07 TRUE and you must load a one into
    // the address register.
    //
    if (IS_DEV_P9100)
       P9_WR_REG(P9100_RAMWRITE, 0x01);

    WriteDAC(HwDeviceExtension, CMD_REG_0, ENB_CMD_REG_3 | MODE_8_BIT);

    //
    // Set the DAC Pixel port value for the current bit depth.
    // Note: The BT485 does not support 24bpp mode.
    //

    switch (HwDeviceExtension->usBitsPixel)
    {
        case 8:
            WriteDAC(HwDeviceExtension, CMD_REG_1, PIX_PORT_8);
            break;

        case 16: // This is really 555, not 565...
            WriteDAC(HwDeviceExtension, CMD_REG_1, PIX_PORT_15);
            break;

        case 32:
            WriteDAC(HwDeviceExtension, CMD_REG_1, PIX_PORT_32);
            break;

        default:

        //
        // Oops..invalid BPP value. Use 8BPP value for now.
        //

            WriteDAC(HwDeviceExtension, CMD_REG_1, PIX_PORT_8);
            break;
    };

    //
    // Select P9x00 video clock, disable cursor
    //

    WriteDAC(HwDeviceExtension, CMD_REG_2,
                               (PORTSEL_MSKD | PCLK1_SEL) & DIS_CURS);

    //
    // Select 32x32x2 cursor mode, and clock doubler mode if neccessary.
    //

    RD_CMD_REG_3(ucCurState);

    if (HwDeviceExtension->VideoData.dotfreq1 >
        HwDeviceExtension->Dac.ulMaxClkFreq)
    {
        //
        // Enable the DAC clock doubler mode.
        //

        HwDeviceExtension->Dac.DACSetClkDblMode(HwDeviceExtension);
    }
    else
    {
        //
        // Disable the DAC clock doubler mode.
        //

        HwDeviceExtension->Dac.DACClrClkDblMode(HwDeviceExtension);
    }

    //
    // Set the pixel read mask.
    //

    WriteDAC(HwDeviceExtension, PIXEL_MSK_REG, 0xff);

    //
    // Set cursor colors 1 and 2.
    //

    WriteDAC(HwDeviceExtension, CURS_CLR_ADDR, 1);
    WriteDAC(HwDeviceExtension, CURS_CLR_DATA, 0x00);
    WriteDAC(HwDeviceExtension, CURS_CLR_DATA, 0x00);
    WriteDAC(HwDeviceExtension, CURS_CLR_DATA, 0x00);
    WriteDAC(HwDeviceExtension, CURS_CLR_DATA, 0xFF);
    WriteDAC(HwDeviceExtension, CURS_CLR_DATA, 0xFF);
    WriteDAC(HwDeviceExtension, CURS_CLR_DATA, 0xFF);

    return(TRUE);
}


VOID
P91Bt485RestoreMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

routine description:

    Restore the DAC to its pristine state.

arguments:

    hwdeviceextension - pointer to the miniport driver's device extension.


return value:

--*/

{
    UCHAR   ucCurState;

    VideoDebugPrint((1, "P91Bt485RestoreMode----------\n"));

    //
    // Enable accesses to CMD_REG_3.  For the Power 9100, to access command
    // register 3, you must have CR07 TRUE and you must load a one into
    // the address register.
    //
    if (IS_DEV_P9100)
    {
       P9_WR_REG(P9100_RAMWRITE, 0x01);
       WriteDAC(HwDeviceExtension, CMD_REG_0, ENB_CMD_REG_3);
       WR_CMD_REG_3(0x00);
       WriteDAC(HwDeviceExtension, CMD_REG_0, 0x00);
        WriteDAC(HwDeviceExtension, CMD_REG_1, 0x00);
        WriteDAC(HwDeviceExtension, CMD_REG_2, 0x00);
         return;
    }

    WriteDAC(HwDeviceExtension, CMD_REG_0, ENB_CMD_REG_3);

    //
    // Set pixel port for 8bit pixels.
    //

    WriteDAC(HwDeviceExtension, CMD_REG_1, PIX_PORT_8);

    //
    // Select VGA video clock, disable cursor.
    //

    WriteDAC(HwDeviceExtension, (ULONG) CMD_REG_2,
            (UCHAR)(ReadDAC(HwDeviceExtension, (ULONG) CMD_REG_2) & DIS_CURS));

    //
    // Select 32x32 cursor, clear clock doubler bit.
    //

    RD_CMD_REG_3(ucCurState);
    WR_CMD_REG_3(ucCurState & (~DAC_CLK_2X & CUR_MODE_32));

    //
    // Set pixel read mask.
    //

    WriteDAC(HwDeviceExtension, PIXEL_MSK_REG, 0xff);
     return;
}


VOID
P91Bt485SetClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

routine description:

    Enable the DAC's internal clock doubler.

arguments:

    hwdeviceextension - pointer to the miniport driver's device extension.


return value:

--*/

{
    UCHAR   ucCurState;

    VideoDebugPrint((1, "P91Bt485SetClkDoubler----------\n"));
    RD_CMD_REG_3(ucCurState);
    WR_CMD_REG_3(ucCurState | DAC_CLK_2X);
    return;
}


VOID
P91Bt485ClrClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

routine description:

    Disable the DAC's internal clock doubler.

arguments:

    hwdeviceextension - pointer to the miniport driver's device extension.


return value:

--*/
{
    UCHAR   ucCurState;

    VideoDebugPrint((1, "P91Bt485ClrClkDoubler----------\n"));
    RD_CMD_REG_3(ucCurState);
    WR_CMD_REG_3(ucCurState & ~DAC_CLK_2X);
    return;
}


UCHAR
ReadDAC(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG ulIndex
    )

/*++

routine description:

    Read a value from the specified index from the DAC.

arguments:

    hwdeviceextension - pointer to the miniport driver's device extension,
    ulIndex           - index register.

return value:
    Value.

--*/
{
    if (IS_DEV_P9100)
    {
#if 0
        return((UCHAR) P9_RD_REG(ulIndex));
#else
            return( (UCHAR) (VideoPortReadRegisterUlong(
                (PULONG)((PUCHAR) HwDeviceExtension->Coproc + (ulIndex - 2)) ) >> 16) );
#endif
    }
    else
    {
       return(VideoPortReadPortUchar((PUCHAR)(ULONG_PTR)ulIndex));
    }

} // End of ReadDAC()



VOID
WriteDAC(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG ulIndex,
    UCHAR ucValue
    )

/*++

routine description:

    Write the specified value to the specified index to the DAC.

arguments:

    hwdeviceextension - pointer to the miniport driver's device extension,
    ulIndex           - index register,
    ucValue           - value to write.
return value:
    None.

--*/
{
    if (IS_DEV_P9100)
    {
#if 0
        P9_WR_REG(ulIndex, ucValue);
#endif

        VideoPortWriteRegisterUlong(
            (PULONG)((PUCHAR)HwDeviceExtension->Coproc + (ulIndex - 2)),
            (((ULONG) ucValue) << 16) );
    }
    else
    {
       VideoPortWritePortUchar((PUCHAR)(ULONG_PTR)ulIndex, ucValue);
    }

    return;

} // End of WriteDAC()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\p91supp.c ===
/*++

Copyright (c) 1993, 1994  Weitek Corporation

Module Name:

    p91supp.c

Abstract:

    This module contains functions for calculating memconf and srtcrl values
    for the Weitek P9 miniport device driver.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

#include "p9.h"
#include "p9gbl.h"
#include "p91regs.h"


extern VOID
ProgramClockSynth(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT usFrequency,
    BOOLEAN bSetMemclk,
    BOOLEAN bUseClockDoubler
    );

//
// Local function Prototypes
//

VOID
CalcP9100MemConfig (
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
P91SizeVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
P91TestVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT iNumLongWords
    );

ULONG
Logbase2(
     ULONG ulValue
     );


VOID
CalcP9100MemConfig (
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

   Calculate the value to be stored in the Power 9100 memory configuration
   field as well as the srtctl field.

Argumentss:

    PHW_DEVICE_EXTENSION HwDeviceExtension.

Return Values:

    FALSE - If the operation is not successful.
    TRUE  - If the operation is successful.

--*/

{
   BOOLEAN  fDacDividesClock;
   USHORT   usShiftClockIndex;
   USHORT   usSrtctlSrcIncIndex;
   USHORT   usLoadClock;
   USHORT   usDivisionFactor;
   USHORT   usClkFreqIndex;
   USHORT   usBlankDlyIndex;
   USHORT   usSamIndex;
   USHORT   usDacWidthIndex;
   USHORT   usNumBanksIndex;
   USHORT   usEffectiveBackendBanks;
   USHORT   usDepthOfOneSAM;
   USHORT   usEffectiveSAMDepth;
   USHORT   usEffectiveRowDepth;
    USHORT    usMemClkInUse;

   ULONG    ulMemConfig;
   ULONG    ulSrtCtl;

   //
   // Define the positive (rising edge) blank delay index table for when the
   // Power 9100 is dividing the clock.
   //
   USHORT usPositiveBlnkDly[2][2][3] =
   {
   //
   // Define blank delay for 128K deep VRAM
   //     1Bnk  2Bnk  4Bnk
   //
      {
         {0xFF, 0x00, 0x00},           // 32-Bit RAMDAC
         {0xFF, 0x00, 0x00}            // 64-Bit RAMDAC
      },

      //
      // Define blank delay for 256K deep VRAM
      //     1Bnk  2Bnk  4Bnk
      //
      {
         {0x01, 0x02, 0x00},           // 32-Bit RAMDAC
         {0xFF, 0x01, 0x02}            // 64-Bit RAMDAC
      }
   };

   //
   // Define the negative (falling edge) blank delay index table for when the
   // Power 9100 is dividing the clock.
   //
   USHORT usNegativeBlnkDly[2][2][3] =
   {
   //
   // Define blank delay for 128K deep VRAM
   //     1Bnk  2Bnk  4Bnk
   //
      {
         {0xFF, 0x02, 0x03},           // 32-Bit RAMDAC
         {0xFF, 0x01, 0x02}            // 64-Bit RAMDAC
      },

      //
      // Define blank delay for 256K deep VRAM
      //     1Bnk  2Bnk  4Bnk
      //
      {
         {0x01, 0x02, 0x03},           // 32-Bit RAMDAC
         {0xFF, 0x01, 0x02}            // 64-Bit RAMDAC
      }
   };

   //
   // Define the VRAM configuration mem_config.config lookup table.
   //
   ULONG ulMemConfTable[] =
   {
      0,
      P91_MC_CNFG_1,
      0,
      P91_MC_CNFG_3,
      P91_MC_CNFG_4,
      P91_MC_CNFG_5,
      0,
      P91_MC_CNFG_7,
      0,
      0,
      0,
      P91_MC_CNFG_11,
      0,
      0,
      P91_MC_CNFG_14,
      P91_MC_CNFG_15
   };

   //
   // Define the mem_config.shiftclk_mode and mem_config.soe_mode lookup table.
   //
   ULONG ulShiftClockMode[] =
   {
      P91_MC_SHFT_CLK_1_BANK | P91_MC_SERIAL_OUT_1_BANK,
      P91_MC_SHFT_CLK_2_BANK | P91_MC_SERIAL_OUT_2_BANK,
      P91_MC_SHFT_CLK_4_BANK | P91_MC_SERIAL_OUT_4_BANK
   };

   //
   // Define the mem_config.shiftclk_freq and mem_config.crtc_freq lookup table.
   //
   ULONG ulClockFreq[] =
   {
      P91_MC_SHFT_CLK_DIV_1  | P91_MC_CRTC_CLK_DIV_1,
      P91_MC_SHFT_CLK_DIV_2  | P91_MC_CRTC_CLK_DIV_2,
      P91_MC_SHFT_CLK_DIV_4  | P91_MC_CRTC_CLK_DIV_4,
      P91_MC_SHFT_CLK_DIV_8  | P91_MC_CRTC_CLK_DIV_8,
      P91_MC_SHFT_CLK_DIV_16 | P91_MC_CRTC_CLK_DIV_16
   };

   //
   // Define the mem_config.blank_dly field lookup table.
   //
   ULONG ulBlankDly[] =
   {
      P91_MC_BLNKDLY_0_CLK,
      P91_MC_BLNKDLY_1_CLK,
      P91_MC_BLNKDLY_2_CLK,
      P91_MC_BLNKDLY_3_CLK
   };

   //
   // Define the srtctl.src_incs field lookup table.
   //
   ULONG ulSrtctlSrcInc[] =
   {
      P91_SRTCTL_SRC_INC_256,
      P91_SRTCTL_SRC_INC_512,
      P91_SRTCTL_SRC_INC_1024
   };

   //
   // A1/A2 silicon SPLIT SHIFT TRANSFER BUG FIX
   //
   // First initialize the memory clock that is being used.  This value may
   // need to be changed if it is determined that the conditions are right
   // for the split shift transfer bug to occur.
   //
   // First choose the default value for the clock being used just in case
   // there was not a value passed in.
   //
   usMemClkInUse = (HwDeviceExtension->p91State.usRevisionID ==
                             WTK_9100_REV1) ? DEF_P9100_REV1_MEMCLK :
                                              DEF_P9100_MEMCLK;

   //
   // A1/A2 silicon SPLIT SHIFT TRANSFER BUG FIX
   //
   // Now select either the default memory clock or the value passed in.
   //
   //   usMemClkInUse = (*pusMemClock) ? *pusMemClock : usMemClkInUse;

   //
   // Initialize the constant fields of the Screen Repaint Timing Control
   // register value.
   //
   ulSrtCtl = P91_SRTCTL_DISP_BUFF_0   |              // display_buffer (3)
              P91_SRTCTL_HR_NORMAL     |              // hblnk_relaod   (4)
              P91_SRTCTL_ENABLE_VIDEO  |              // enable_video   (5)
              P91_SRTCTL_HSYNC_INT     |              // internal_hsync (7)
              P91_SRTCTL_VSYNC_INT;                   // internal_vsync (8)

   //
   // Initialize the memory configuration fields to start things off.
   //

   ulMemConfig = ulMemConfTable[HwDeviceExtension->p91State.usMemConfNum];

   //
   // Initialize all of the constant fields.
   //
   ulMemConfig |= P91_MC_MISS_ADJ_1       |           // vram_miss_adj     (3)
                  P91_MC_READ_ADJ_1       |           // vram_read_adj     (4)
                  P91_MC_WRITE_ADJ_1      |           // vram_write_adj    (5)
                  P91_MC_VCP_PRIORITY_HI  |           // priority_select   (6)
                  P91_MC_DAC_ACCESS_ADJ_0 |           // dac_access_adj    (7)
                  P91_MC_DAC_MODE_0       |           // dac_mode          (8)
                  P91_MC_MEM_VID_NORMAL   |           // hold_reset        (9)
                  P91_MC_MUXSEL_NORMAL    |           // reserved          (16-17)
                  P91_MC_SLOW_HOST_ADJ_1  |           // slow_host_hifc    (30)
                  P91_MC_READ_SMPL_ADJ_1;             // vram_read_sample  (31)

   //
   // Calculate the number of effective back-end banks in the current configuration.  This
   // value is used to calculate several fields in the memory configuration register.
   //
   usEffectiveBackendBanks = (32*HwDeviceExtension->p91State.usNumVramBanks)
                      / HwDeviceExtension->Dac.usRamdacWidth;

   //
   // Determine the depth of one shift register as follows:
   //   128k deep VRAM has a row size of 256 => depth of one shift register is 256
   //   256k deep VRAM has a row size of 512 => depth of one shift register is 512
   //
   usDepthOfOneSAM = (HwDeviceExtension->p91State.ulPuConfig &
                                           P91_PUC_128K_VRAMS) ? 256 : 512;

   //
   // Calculate the effective SAM and Row depths.  These values are used to calculate the
   // initial value for the SRTCTL register.
   //
   usEffectiveSAMDepth = usDepthOfOneSAM * usEffectiveBackendBanks;
   usEffectiveRowDepth = usDepthOfOneSAM *
                                HwDeviceExtension->p91State.usNumVramBanks;

   //
   // Calculate the index into the Shift Clock Mode lookup table.  The index is calculated
   // as Logbase2(usEffectiveBakendBanks) should give either a 0, 1 or 2.
   //
   usShiftClockIndex = usEffectiveBackendBanks >> 1;
   VideoDebugPrint((2, "CalcP9100MemConfig: usEffectiveBackendBanks = %d\n",
                    usEffectiveBackendBanks));
   VideoDebugPrint((2, "CalcP9100MemConfig: usShiftClockIndex = %d\n",
                    usShiftClockIndex));
   VideoDebugPrint((2, "CalcP9100MemConfig: usShiftClockMode[] = %lx\n",
                    ulShiftClockMode[usShiftClockIndex]));
   //
   // Now, using the Shift Clock Mode lookup table index, set both the shiftclk_mode (22-23)
   // and soe_mode (24-25) fields.
   //
   ulMemConfig |= ulShiftClockMode[usShiftClockIndex];

   switch (HwDeviceExtension->p91State.ulPuConfig & P91_PUC_VRAM_SAM_SIZE)
   {
      case P91_PUC_FULL_SIZE_SHIFT:
      {
      //
      // Calculate the initial value for the SRTCTL register.
      //
      // First set srtctl.src_incs...
      //
         usSrtctlSrcIncIndex = (USHORT) (Logbase2 ((ULONG) usEffectiveRowDepth) - 9);
         ulSrtCtl |= ulSrtctlSrcInc[usSrtctlSrcIncIndex];

      //
      // And then srtctl.qsfselect
      //
         ulSrtCtl |= Logbase2((ULONG) usEffectiveSAMDepth) - 5;

      //
      // Set the vad_shft field for full size SAMs.
      //
         ulMemConfig |= P91_MC_VAD_DIV_1;

         break;
      }

      case P91_PUC_HALF_SIZE_SHIFT:
      {
      //
      // Calculate the initial value for the SRTCTL register.
      //
      // First set srtctl.src_incs...
      //
         usSrtctlSrcIncIndex = (USHORT) (Logbase2 ((ULONG) usEffectiveRowDepth) - 9);

         if (usSrtctlSrcIncIndex)
         {
         //
         // For half size SAMs, if src_incs is not already equal to 0 then it will get
         // decremented by one...
         //
            --usSrtctlSrcIncIndex;
            ulSrtCtl |= ulSrtctlSrcInc[usSrtctlSrcIncIndex];

         //
         // And vad_shft will be set to 0.
         //
            ulMemConfig |= P91_MC_VAD_DIV_1;
         }
         else
         {
         //
         // If src_incs is already equal to 0, then it will be left as is...
         //
            ulSrtCtl |= ulSrtctlSrcInc[usSrtctlSrcIncIndex];

         //
         // And vad_shft will be set to 1.
         //
            ulMemConfig |= P91_MC_VAD_DIV_2;
         }

      //
      // Now set srtctl.qsfselect for half size SAMs.
      //
         ulSrtCtl |= Logbase2 ((ULONG) usEffectiveSAMDepth) - 6;

         break;
      }
   }

   //
   // Determine if the RAMDAC should divide the clock.
   //

   usLoadClock = (USHORT) ((HwDeviceExtension->VideoData.dotfreq1 /
                            HwDeviceExtension->Dac.usRamdacWidth) *
                            HwDeviceExtension->usBitsPixel);

   // start of non-JEDEC memory bug fix

   if (
        (HwDeviceExtension->p91State.usRevisionID < WTK_9100_REV3)       &&
        (HwDeviceExtension->usBitsPixel <= 16)                           &&
        ( ( (HwDeviceExtension->p91State.usNumVramBanks == 2)       &&
            (HwDeviceExtension->Dac.usRamdacWidth == 64)            &&
            ((HwDeviceExtension->p91State.ulPuConfig &
               P91_PUC_FREQ_SYNTH_TYPE) != P91_PUC_FIXED_MEMCLK)    &&
            (usLoadClock < 1200)
                  )                                                            ||
                  ( usLoadClock < 800 )
                )
#ifdef _MIPS_
         &&  !( HwDeviceExtension->MachineType == SIEMENS_P9100_VLB
             || HwDeviceExtension->MachineType == SIEMENS_P9100_PCi)
         // SNI-Od: 22-1-96:
         // hum!! (HwDeviceExtension->Dac.usRamdacID != DAC_ID_IBM525) ??
#endif
          )
   {
      if (HwDeviceExtension->VideoData.dotfreq1 <= 6750 )
      {
         ulMemConfig |= ((2 - (HwDeviceExtension->usBitsPixel/8) +
                         (HwDeviceExtension->Dac.usRamdacWidth/32)) << 10)   // shiftclk_freq  (10-12)
                             |
                        ((2 - (HwDeviceExtension->usBitsPixel/8) +
                         (HwDeviceExtension->Dac.usRamdacWidth/32)) << 13);  // crtc_freq      (13-15)
      }
      else
      {
         ulMemConfig |= ((1 - (HwDeviceExtension->usBitsPixel/8) +
                         (HwDeviceExtension->Dac.usRamdacWidth/32)) << 10)   // shiftclk_freq  (10-12)
                             |
                        ((1 - (HwDeviceExtension->usBitsPixel/8) +
                         (HwDeviceExtension->Dac.usRamdacWidth/32)) << 13);  // crtc_freq      (13-15)
      }
      fDacDividesClock = FALSE;
   }
   else
   {

   //
   // A1/A2 silicon SPLIT SHIFT TRANSFER BUG FIX
   //
   // This is the main logic for the split shift transfer bug software work
   // around. The current assumption is that the RAMDAC will always be doing
   // the dividing of the clock.
   //
       fDacDividesClock = TRUE;

   //
   // A1/A2 silicon SPLIT SHIFT TRANSFER BUG FIX
   //
   // Special attention is required for A1/A2 silicon for low resolution modes
   // such as 640x480x8, 640x480x15, 640x480x16 and 800x600x8.  Furthormore,
   // the problem only occurs on boards with 2 megabytes of VRAM, a 64-bit
   // RAMDAC and when the following condition is met.
   //
   //    (SCLK * 7) < MEMCLK
   //
   // Note: The value calculated for LCLK can also be used in place of SCLK
   //       in the computations.
   //
       if ((HwDeviceExtension->p91State.usRevisionID < WTK_9100_REV3)                    &&
           (HwDeviceExtension->usBitsPixel != 24)                                           &&
           ((HwDeviceExtension->p91State.ulPuConfig &
                          P91_PUC_MEMORY_DEPTH) == P91_PUC_256K_VRAMS)  &&
           (HwDeviceExtension->p91State.usNumVramBanks == 2)                                            &&
           (HwDeviceExtension->Dac.usRamdacWidth == 64)                     &&
           ((HwDeviceExtension->p91State.ulPuConfig &
                      P91_PUC_FREQ_SYNTH_TYPE) != P91_PUC_FIXED_MEMCLK) &&
           ((usLoadClock * 7) < usMemClkInUse))
       {
   //
   // All the conditions are right for the split shift transfer bug to occur.
   // The software fix for this bug requires that the memory clock is adjusted
   // so that the (SCLK * 7) < MEMCLK equation is no longer satisfied.  This is
   // done easily enough by setting MEMCLK = SCLK * 7.  By doing this, MEMCLK is
   // not reduced any more than neccessary.
   //
          usMemClkInUse = (usLoadClock * 7);
       }
   //
   // Reprogram MEMCLK...
   //
       ProgramClockSynth(HwDeviceExtension, usMemClkInUse, TRUE, FALSE);

   //
   // A1/A2 silicon SPLIT SHIFT TRANSFER BUG FIX
   //
   // Because of the current work around, the RAMDAC always does the dividing of
   // of the clock and the DDOTCLK is always used, so set those bit here.
   //
   // Set the shiftclk_freq (10-12), crtc_freq (13-15) and video_clk_sel (20) fields for
   // when the RAMDAC is dividing the clock.
   //
       ulMemConfig |= P91_MC_SHFT_CLK_DIV_1  |        // shiftclk_freq  (10-12)
                  P91_MC_CRTC_CLK_DIV_1      |        // crtc_freq      (13-15)
                  P91_MC_VCLK_SRC_DDOTCLK;            // video_clk_sel  (20)

   }

   VideoDebugPrint((2, "CalcP9100MemConfig: usLoadClock = %d\n",
                    usLoadClock));
   VideoDebugPrint((2, "CalcP9100MemConfig: fDacDividesClock = %d\n",
                    fDacDividesClock));

#if 0

   if (fDacDividesClock)
   {
      //
      // Set the shiftclk_freq (10-12), crtc_freq (13-15) and video_clk_sel (20) fields for
      // when the RAMDAC is dividing the clock.
      //
      ulMemConfig |= P91_MC_SHFT_CLK_DIV_1   |           // shiftclk_freq  (10-12)
                     P91_MC_CRTC_CLK_DIV_1   |           // crtc_freq      (13-15)
                     P91_MC_VCLK_SRC_DDOTCLK;            // video_clk_sel  (20)
   }
   else
   {
      //
      // Set the shiftclk_freq (10-12), crtc_freq (13-15) and video_clk_sel (20) fields for
      // when the Power 9100 is dividing the clock.
      //
      usDivisionFactor = (USHORT) (HwDeviceExtension->Dac.usRamdacWidth /
                                              HwDeviceExtension->usBitsPixel);
      usClkFreqIndex = (USHORT) Logbase2 ((ULONG) usDivisionFactor);

      VideoDebugPrint((2, "CalcP9100MemConfig: usClkFreqIndex#1 = %d\n",
                      usClkFreqIndex));

      if (HwDeviceExtension->VideoData.dotfreq1 >
          HwDeviceExtension->Dac.ulMaxClkFreq) // was  if (usFreqRatio == 2)
      {
         --usClkFreqIndex;
      VideoDebugPrint((2, "CalcP9100MemConfig: usClkFreqIndex#2 = %d\n",
                      usClkFreqIndex));
      }

      VideoDebugPrint((2, "CalcP9100MemConfig: usClkFreqIndex = %d\n",
                      usClkFreqIndex));
      VideoDebugPrint((2, "CalcP9100MemConfig: ulClockFreq[] = %lx\n",
                      ulClockFreq[usClkFreqIndex]));

      ulMemConfig |= ulClockFreq[usClkFreqIndex];

      //
      // video_clk_sel is always PIXCLK when the 9100 is dividing the clock.
      //
      ulMemConfig |= P91_MC_VCLK_SRC_PIXCLK;
   }

#endif

   //
   // Determine the setting for the blank_edge (19) field
   //
   if ((usLoadClock <= 3300)                             ||
       (HwDeviceExtension->p91State.usRevisionID >= WTK_9100_REV3))
   {
      ulMemConfig |= P91_MC_SYNC_FALL_EDGE;
   }
   else
   {
      ulMemConfig |= P91_MC_SYNC_RISE_EDGE;
   }

   //
   // Do the magic for the blank_dly (27-28) field.
   //

   if (HwDeviceExtension->p91State.usRevisionID >= WTK_9100_REV3)
   {
      //
      // For A3 silicon, this is simply a 1.
      //
      usBlankDlyIndex = 1;

      //
      // Now special case for the number of banks and the DAC width.
      //

      if ((HwDeviceExtension->p91State.usNumVramBanks == 4) &&
          (HwDeviceExtension->Dac.usRamdacWidth == 32))
      {
         ++usBlankDlyIndex;
      }
   }
   else if (fDacDividesClock)
   {
      //
      // When not on A3 and the DAC is dividing the clock, there's a little
      // more to this field.
      //
      if ((ulMemConfig & P91_MC_BLANK_EDGE_MSK) == P91_MC_SYNC_RISE_EDGE)
      {
         usBlankDlyIndex = 1;
      }
      else
      {
         usBlankDlyIndex = 2;
      }

      //
      // Now special case for the number of banks and the DAC width.
      //
      if ((HwDeviceExtension->p91State.usNumVramBanks == 4) &&
          (HwDeviceExtension->Dac.usRamdacWidth == 32))
      {
         ++usBlankDlyIndex;
      }
   }
   else
   {
      //
      // When the Power 9100 is dividing the clock this gets really messy.
      //
      usSamIndex = ((HwDeviceExtension->p91State.ulPuConfig &
                  P91_PUC_VRAM_SAM_SIZE) == P91_PUC_FULL_SIZE_SHIFT) ? 1 : 0;

      usDacWidthIndex = (HwDeviceExtension->Dac.usRamdacWidth / 32) - 1;

      usNumBanksIndex = HwDeviceExtension->p91State.usNumVramBanks >> 1;

      if ((ulMemConfig & P91_MC_BLANK_EDGE_MSK) == P91_MC_SYNC_RISE_EDGE)
      {
         usBlankDlyIndex = usPositiveBlnkDly[usSamIndex]
                                            [usDacWidthIndex]
                                            [usNumBanksIndex];
      }
      else
      {
         usBlankDlyIndex = usNegativeBlnkDly[usSamIndex]
                                            [usDacWidthIndex]
                                            [usNumBanksIndex];
      }

      //
      // Now special case for the number of banks, the DAC width, the SAM size and
      // the pixel depth.
      //
      if ((HwDeviceExtension->usBitsPixel == 32)               &&
          (HwDeviceExtension->p91State.usNumVramBanks == 1) &&
          (usSamIndex == 1)                                    &&
          (HwDeviceExtension->Dac.usRamdacWidth == 32))
      {
         usBlankDlyIndex = 2;
      }

      if ((HwDeviceExtension->usBitsPixel == 32)               &&
          (HwDeviceExtension->p91State.usNumVramBanks == 2) &&
          (usSamIndex == 1)                                    &&
          (HwDeviceExtension->Dac.usRamdacWidth == 32))
      {
         usBlankDlyIndex = 1;
      }
   }

   //
   // Now use the blank delay index to set the blank_dly (27-38) field in the
   // memory configuration regsiter.
   //
   ulMemConfig |= ulBlankDly[usBlankDlyIndex];

   //
   // Now calculate the blank delay adjustment used when calculating the timing
   // values.
   //
   HwDeviceExtension->p91State.ulBlnkDlyAdj = (ULONG) usBlankDlyIndex;

   //
   // As if everything wasn't bad enough!!!  One more special case.
   //
   if ((HwDeviceExtension->p91State.usRevisionID >= WTK_9100_REV3)       &&
       (HwDeviceExtension->p91State.usNumVramBanks == 2)                 &&
       ((HwDeviceExtension->p91State.ulPuConfig & P91_PUC_VRAM_SAM_SIZE)
                                        == P91_PUC_HALF_SIZE_SHIFT)         &&
       (HwDeviceExtension->Dac.usRamdacWidth == 64)                         &&
       (HwDeviceExtension->usBitsPixel == 8)                                &&
       (HwDeviceExtension->VideoData.XSize == 640)                          &&
       (HwDeviceExtension->VideoData.YSize == 480))
   {
      //
      // Fix up for A3 silicon.
      //
      HwDeviceExtension->p91State.ulBlnkDlyAdj++;
   }

   //
   // Set the return values.
   //
   HwDeviceExtension->p91State.ulMemConfVal = ulMemConfig;
   HwDeviceExtension->p91State.ulSrctlVal   = ulSrtCtl;
   HwDeviceExtension->Dac.bRamdacDivides       = fDacDividesClock;

   return;

} // End CalcP9100MemConfig ()



ULONG
Logbase2 (
     ULONG ulValue
     )
/*++

Routine Description:

  This routine calculates the LOG Base 2 of the passed in value.

Argumentss:

  ulValue - Value to calculate LOG Base 2 for.

Return Values:

  ulResult - LOG Base 2 of ulValue.

--*/
{
   ULONG ulResult;

   ulResult = 0;
   while (ulValue != 1)
   {
      ++ulResult;
      ulValue >>= 1;
   }

   return (ulResult);

} // End of Logbase2()


BOOLEAN
P91TestVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT iNumLongWords
    )

/*++

Routine Description:
    Routine to check if our memory configuration is set right.

Argumentss:
    HwDeviceExtension - Pointer to the miniport driver's device extension.
    Specified number of longwords to test.

Return Values:
    TRUE  == if video memory checks out OK.
    FALSE == otherwise.

--*/

{
    unsigned long i;

    ULONG ulOtherBankBits;
    ULONG aulOldBits[32];

    BOOLEAN bRet =  TRUE;

    //
    // The SandleFoot blue screen showed corruption from this test.
    // We tried to not save this data, but we had to.
    // In addition to saving the screen data around the test, we have also
    // saved the state of the Memory Configuration register.

    ulOtherBankBits =
        VideoPortReadRegisterUlong((PULONG) HwDeviceExtension->FrameAddress + 0x8000);

    for (i = 0; i < 32; i++)
    {
        aulOldBits[i] =
            VideoPortReadRegisterUlong((PULONG) HwDeviceExtension->FrameAddress + i);
    }

    //
    // Make sure you cause a row change at the beginning of the memory
    // by first accessing a location that is guaranteed to be in another row.
    //

    VideoPortWriteRegisterUlong((PULONG) HwDeviceExtension->FrameAddress + 0x8000,
                                0x5A5A5A5A);

    //
    // Test iNumLongWords doubleword locations by writing the inverse of the
    // address to each memory location.
    //
    for (i = 0 ; i < iNumLongWords; i++)
    {
        VideoPortWriteRegisterUlong((PULONG) HwDeviceExtension->FrameAddress + i,
                                    ~i);
    }

    //
    // Now read them back and test for failure
    //

    for (i = 0 ; i < iNumLongWords; i++)
    {
        //
        // If any one fails, return error...
        //

        if (VideoPortReadRegisterUlong((PULONG) HwDeviceExtension->FrameAddress + i)
                != ~i)
        {
            bRet = FALSE;
            break;
        }
    }

    //
    // Restore everything.
    //

    VideoPortWriteRegisterUlong((PULONG) HwDeviceExtension->FrameAddress + 0x8000,
                                ulOtherBankBits);

    for (i = 0; i < 32; i++)
    {
        VideoPortWriteRegisterUlong((PULONG) HwDeviceExtension->FrameAddress + i,
                                    aulOldBits[i]);
    }

    //
    // If all of them work, return success
    //

    return(bRet);

} // End of int P91TestVideoMemory()


VOID
P91SizeVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

    Routine Description:

       Routine to determine the amount of memory and what memory configuration
       bits to set.
       This routine assumes that the board is already initialized.
       It also sets (...)

    Argumentss:
        HwDeviceExtension - Pointer to the miniport driver's device extension.

    Return Values:
        None.

    Modifies:
        HwDeviceExtension->p91State.usNumVramBanks    = 1,2 or 4;
        HwDeviceExtension->p91State.ulFrameBufferSize = 0x0100000,
                                                       0x0200000 or 0x0400000;

--*/

{
    ULONG   ulMemConfig;

    VideoDebugPrint((2, "P91SizeVideoMemory - Entry\n"));


    ulMemConfig = P9_RD_REG(P91_MEM_CONFIG);

    if (HwDeviceExtension->p91State.bVram256)
    {
        //
        // Assume 4 banks and test assertion...
        //

        HwDeviceExtension->p91State.usMemConfNum      = 7;
        HwDeviceExtension->p91State.usNumVramBanks    = 4;
        HwDeviceExtension->p91State.ulFrameBufferSize = 0x0400000;

        P9_WR_REG(P91_MEM_CONFIG, 0x00000007);

        if (!P91TestVideoMemory(HwDeviceExtension, 32))
        {
            //
            // Assertion failed, so assume 2 banks and test assertion...
            //

            HwDeviceExtension->p91State.usMemConfNum      = 5;
            HwDeviceExtension->p91State.usNumVramBanks    = 2;
            HwDeviceExtension->p91State.ulFrameBufferSize = 0x0200000L;
            P9_WR_REG(P91_MEM_CONFIG, 0x00000005);

            if (!P91TestVideoMemory(HwDeviceExtension, 32))
            {
                //
                // If second assertion fails, assume 1 bank
                //

                HwDeviceExtension->p91State.usMemConfNum      = 4;
                HwDeviceExtension->p91State.usNumVramBanks    = 1;
                HwDeviceExtension->p91State.ulFrameBufferSize = 0x0100000;
            }
        }
    }
    else
    {
        //
        // Assume 4 banks and test assertion...
        //
        HwDeviceExtension->p91State.usMemConfNum      = 3;
        HwDeviceExtension->p91State.usNumVramBanks    = 4;
        HwDeviceExtension->p91State.ulFrameBufferSize = 0x0200000;
        P9_WR_REG(P91_MEM_CONFIG, 0x00000003);

        if (!P91TestVideoMemory(HwDeviceExtension, 32))
        {
            //
            // Assertion failed, so assume 2 banks
            //

            HwDeviceExtension->p91State.usMemConfNum      = 1;
            HwDeviceExtension->p91State.usNumVramBanks    = 2;
            HwDeviceExtension->p91State.ulFrameBufferSize = 0x0100000L;
        }
    }

    VideoDebugPrint((3, "P91SizeVideoMemory: usNumVramBanks = %d\n",
                        HwDeviceExtension->p91State.usNumVramBanks));

    VideoDebugPrint((3, "P91SizeVideoMemory: usFrameBufferSize = %lx\n",
                        HwDeviceExtension->p91State.ulFrameBufferSize));

    VideoDebugPrint((2, "P91SizeVideoMemory - Exit\n"));

    P9_WR_REG(P91_MEM_CONFIG, ulMemConfig);

} // End of P91SizeVideoMemory()


BOOLEAN
ValidateMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation
    )

/*++

Routine Description:

    Function to determine if the mode is valid based on the current
    adapter.  The factors that determine if the mode is valid are the
    DAC and the size of video ram.

Argumentss:
    HwDeviceExtension - Pointer to the miniport driver's device extension.
    ModeInformation   - Pointer to the resolution information.

Return Values:
    TRUE  == The resolution is valid,
    FALSE == The resolution is invalid.

--*/

{
    //
    // Check to see if 24BPP mode is specified and if this DAC supports it...
    //
    if ( (ModeInformation->BitsPerPlane == 24) &&
        (!HwDeviceExtension->Dac.bRamdac24BPP) )
        return(FALSE); // 24Bpp not supported by this DAC...

    //
    // Check to see if we have enough video ram to support this resolution...
    //
    if ( ((ULONG) (ModeInformation->BitsPerPlane/8)  *
                  ModeInformation->VisScreenWidth   *
                  ModeInformation->VisScreenHeight) >
                  HwDeviceExtension->FrameLength )
   {
      VideoDebugPrint((2, "ValidateMode: VisScreenWidth = %d\n",
                           ModeInformation->VisScreenWidth));
      VideoDebugPrint((2, "ValidateMode: VisScreenHeight = %d\n",
                           ModeInformation->VisScreenHeight));
      VideoDebugPrint((2, "ValidateMode: BitsPerPlane = %d\n",
                           ModeInformation->BitsPerPlane));
      VideoDebugPrint((2, "ValidateMode: Vram needed = %ld\n",
                           ((ULONG) (ModeInformation->BitsPerPlane/8)  *
                           ModeInformation->VisScreenWidth   *
                           ModeInformation->VisScreenHeight) ));
        return(FALSE); // Not enough video memory for this mode...
   }
    else
        return(TRUE);

} // End of ValidateMode()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\p9gbl.c ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    p9gbl.c

Abstract:

    This module contains the global data for the Weitek P9 miniport
    device driver.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

#include "p9.h"
#include "p9gbl.h"
#include "p9000.h"
#include "bt485.h"
#include "vga.h"
#include "p91regs.h"
#include "p91dac.h"
#include "pci.h"

//
// This global is used as an error flag to error out quickly on the multiple
// calls to P9FindAdapter when a board is not supported.
//

VP_STATUS   vpP91AdapterStatus = NO_ERROR;
BOOLEAN     bFoundPCI          = FALSE;


//
// Coprocessor info structure for the Weitek P9100.
//

//
// The P9100's total address space is 16mb (0x0100000).  The maximum
// frame-buffer is 4mb (0x00400000).  So define the coproc length as
// the maximum (16mb) less the size of the frame buffer (4mb).
// Note: we might want to map the optional video power coprocessor
// discretely.
//
// NOTE only ask for 0x00C00000 since that;s was preconfigured PCI devices
// have.
//

P9_COPROC   P9100Info =
{
    P9100_ID,
    0x00C00000,        // Size of memory address space.
    0x00000000,        // Offset to coproc regs.
    0x00800000,        // Size of coproc register block.
    0x00800000,        // Offset to frame buffer.
    P91SizeVideoMemory // Memory sizing function.
};

//
// Coprocessor info structure for the Weitek P9000.
//

P9_COPROC   P9000Info =
{
    P9000_ID,
    0x00400000,   // Size of memory address space.
    0x00100000,   // Offset to coproc regs.
    0x00100000,   // Size of coproc register block.
    0x00200000,   // Offset to frame buffer.
    P9000SizeMem  // Memory sizing function.
};

//
// The default adapter description structure for the Weitek P9 PCI
// boards.
//

ADAPTER_DESC    WtkPciDesc =
{
    {L"Weitek P9000 PCI Adapter"},
    0L,                                 // P9 Memconf value (un-initialized)
    HSYNC_INTERNAL | VSYNC_INTERNAL |
    COMPOSITE_SYNC | VIDEO_NORMAL,      // P9 Srctl value
    TRUE,                               // Should autodetection be attempted?
    TRUE,                               // Is this a PCI adapter ?
    PciGetBaseAddr,                     // Routine to detect/map P9 base addr
    VLSetMode,                          // Routine to set the P9 mode
    VLEnableP9,                         // Routine to enable P9 video
    VLDisableP9,                        // Routine to disable P9 video
    PciP9MemEnable,                     // Routine to enable memory/io
    8,                                  // Clock divisor value
    TRUE,                               // Is a Wtk 5x86 VGA present?
    TRUE
};


//
// The default adapter description structure for the Weitek P9100 PCI
// boards.
//

ADAPTER_DESC    WtkP91PciDesc =
{
    {L"Weitek P9100 PCI Adapter"},
    0L,                                 // P9 Memconf value (un-initialized)
    HSYNC_INTERNAL | VSYNC_INTERNAL |
    COMPOSITE_SYNC | VIDEO_NORMAL,      // P9 Srctl value
    TRUE,                               // Should autodetection be attempted?
    TRUE,                               // Is this a PCI adapter ?
    PciGetBaseAddr,                     // Routine to detect/map P9 base addr
    VLSetModeP91,                       // Routine to set the P9 mode
    VLEnableP91,                        // Routine to enable P9 video
    VLDisableP91,                       // Routine to disable P9 video
    // PciP9MemEnable,                     // Routine to enable memory/io
    NULL,
    4,                                  // Clock divisor value
    TRUE,                               // Is a Wtk 5x86 VGA present?
    FALSE
};

//
// The default adapter description structure for the Diamond Viper VL board.
//

ADAPTER_DESC    ViperVLDesc =
{
    {L"Diamond Viper P9000 VL Adapter"},
    0L,                                 // P9 Memconf value (un-initialized)
    HSYNC_INTERNAL | VSYNC_INTERNAL |
    COMPOSITE_SYNC | VIDEO_NORMAL,      // P9 Srctl value
    TRUE,                               // Should autodetection be attempted?
    FALSE,                              // Is this a PCI adapter ?
    ViperGetBaseAddr,                   // Routine to detect/map P9 base addr
    ViperSetMode,                       // Routine to set the P9 mode
    ViperEnableP9,                      // Routine to enable P9 video
    ViperDisableP9,                     // Routine to disable P9 video
    ViperEnableMem,                     // Routine to enable P9 memory
    4,                                  // Clock divisor value
    TRUE,                               // Is a Wtk 5x86 VGA present?
    TRUE
};


//
// The default adapter description structure for the Weitek P9100 PCI
// boards.
//

ADAPTER_DESC    WtkP91VLDesc =
{
    {L"Weitek P9100 VL Adapter"},
    0L,                                 // P9 Memconf value (un-initialized)
    HSYNC_INTERNAL | VSYNC_INTERNAL |
    COMPOSITE_SYNC | VIDEO_NORMAL,      // P9 Srctl value
    TRUE,                               // Should autodetection be attempted?
    FALSE,                              // Is this a PCI adapter ?
    VLGetBaseAddrP91,                   // Routine to detect/map P9 base addr
    VLSetModeP91,                       // Routine to set the P9 mode
    VLEnableP91,                        // Routine to enable P9 video
    VLDisableP91,                       // Routine to disable P9 video
    // PciP9MemEnable,                     // Routine to enable memory/io
    NULL,
    4,                                  // Clock divisor value
    TRUE,                               // Is a Wtk 5x86 VGA present?
    FALSE
};

//
// The default adapter description structure for the Weitek P9000 VL board.
//

ADAPTER_DESC    WtkVLDesc =
{
    {L"Generic Weitek P9000 VL Adapter"},
    0L,                                 // P9 Memconf value (un-initialized)
    HSYNC_INTERNAL | VSYNC_INTERNAL |
    COMPOSITE_SYNC | VIDEO_NORMAL,      // P9 Srctl value
    FALSE,                              // Should autodetection be attempted?
    FALSE,                              // Is this a PCI adapter ?
    VLGetBaseAddr,                      // Routine to detect/map P9 base addr
    VLSetMode,                          // Routine to set the P9 mode
    VLEnableP9,                         // Routine to enable P9 video
    VLDisableP9,                        // Routine to disable P9 video
    (PVOID) 0,                          // Routine to enable P9 memory
    4,                                  // Clock divisor value
    TRUE,                               // Is a Wtk 5x86 VGA present?
    TRUE
};


//
// List of OEM P9ADAPTER structures.
//

P9ADAPTER   OEMAdapter[NUM_OEM_ADAPTERS] =
{

    //
    // Weitek P9100 PCI adapters, with the IBM525,
    // including Viper PCI Adapter.
    //

    {
        &WtkP91PciDesc,
        &Ibm525,
        &P9100Info
    },

    // Weitek P9100 PCI adapters, with the Bt485
    //

    {
        &WtkP91PciDesc,
        &P91Bt485,
        &P9100Info
    },

    //
    // Weitek P9100 PCI adapters, with the Bt489
    //

    {
        &WtkP91PciDesc,
        &P91Bt489,
        &P9100Info
    },

    //
    // Weitek PCI adapters, including Viper PCI Adapter.
    //

    {
        &WtkPciDesc,
        &Bt485,
        &P9000Info
    },

    //
    // Weitek P9100 VL adapters, with the IBM525,
    //

    {
        &WtkP91VLDesc,
        &Ibm525,
        &P9100Info
    },


    //
    // Weitek P9100 VL adapters, with the Bt485,
    //

    {
        &WtkP91VLDesc,
        &Bt485,
        &P9100Info
    },

    // Viper VL Adapter.
    //

    {
        &ViperVLDesc,
        &Bt485,
        &P9000Info
    },

    //
    // Adapters based on the Weitek VL Design.
    //

    {
        &WtkVLDesc,
        &Bt485,
        &P9000Info
    }
};


//
// DriverAccessRanges are used to verify access to the P9 coprocessor's
// address space and to the VGA and DAC registers.
//

VIDEO_ACCESS_RANGE DriverAccessRanges[NUM_DRIVER_ACCESS_RANGES
                                        + NUM_DAC_ACCESS_RANGES
                                        + NUM_MISC_ACCESS_RANGES] =
{
    //
    // The P9 Coprocessor's access range. Everything is initialized
    // except for the base address and length which are Coprocessor
    // specific.
    //

    {
        0L,             // Low address. To be initialized.
        0L,             // Hi address
        0L,             // length. To be initialized.
        0,              // Is range in i/o space?
        1,              // Range should be visible
        1               // Range should be shareable
    },

    //
    // The VGA Access Range. Every field is initialized.
    //

    {
        0x000003C0,     // Low addr         vga & dac
        0x00000000,     // Hi addr
        0x20,           // length
        1,              // Is range in i/o space?
        1,              // Range should be visible
        1               // Range should be shareable

    },

    //
    // The following access ranges are for the DAC and are uninitialized.
    //

     {
        0L,                             // Low address
        0L,                             // Hi address
        0L,                             // length
        0,                              // Is range in i/o space?
        0,                              // Range should be visible
        0                               // Range should be shareable
     },
     {
        0L,                             // Low address
        0L,                             // Hi address
        0L,                             // length
        0,                              // Is range in i/o space?
        0,                              // Range should be visible
        0                               // Range should be shareable
     },
     {
        0L,                             // Low address
        0L,                             // Hi address
        0L,                             // length
        0,                              // Is range in i/o space?
        0,                              // Range should be visible
        0                               // Range should be shareable
     },
     {
        0L,                             // Low address
        0L,                             // Hi address
        0L,                             // length
        0,                              // Is range in i/o space?
        0,                              // Range should be visible
        0                               // Range should be shareable
     },
     {
        0L,                             // Low address
        0L,                             // Hi address
        0L,                             // length
        0,                              // Is range in i/o space?
        0,                              // Range should be visible
        0                               // Range should be shareable
     },
     {
        0L,                             // Low address
        0L,                             // Hi address
        0L,                             // length
        0,                              // Is range in i/o space?
        0,                              // Range should be visible
        0                               // Range should be shareable
     },
     {
        0L,                             // Low address
        0L,                             // Hi address
        0L,                             // length
        0,                              // Is range in i/o space?
        0,                              // Range should be visible
        0                               // Range should be shareable
     },
     {
        0L,                             // Low address
        0L,                             // Hi address
        0L,                             // length
        0,                              // Is range in i/o space?
        0,                              // Range should be visible
        0                               // Range should be shareable
     },
     {
        0L,                             // Low address
        0L,                             // Hi address
        0L,                             // length
        0,                              // Is range in i/o space?
        0,                              // Range should be visible
        0                               // Range should be shareable
     },
     {
        0L,                             // Low address
        0L,                             // Hi address
        0L,                             // length
        0,                              // Is range in i/o space?
        0,                              // Range should be visible
        0                               // Range should be shareable
     },
     {
        0L,                             // Low address
        0L,                             // Hi address
        0L,                             // length
        0,                              // Is range in i/o space?
        0,                              // Range should be visible
        0                               // Range should be shareable
     },
     {
        0L,                             // Low address
        0L,                             // Hi address
        0L,                             // length
        0,                              // Is range in i/o space?
        0,                              // Range should be visible
        0                               // Range should be shareable
     },
     {
        0L,                             // Low address
        0L,                             // Hi address
        0L,                             // length
        0,                              // Is range in i/o space?
        0,                              // Range should be visible
        0                               // Range should be shareable
     },
     {
        0L,                             // Low address
        0L,                             // Hi address
        0L,                             // length
        0,                              // Is range in i/o space?
        0,                              // Range should be visible
        0                               // Range should be shareable
     },
     {
        0L,                             // Low address
        0L,                             // Hi address
        0L,                             // length
        0,                              // Is range in i/o space?
        0,                              // Range should be visible
        0                               // Range should be shareable
     },
     {
        0L,                             // Low address
        0L,                             // Hi address
        0L,                             // length
        0,                              // Is range in i/o space?
        0,                              // Range should be visible
        0                               // Range should be shareable
     },

    //
    // This is a miscellaneous access range. It is uninitialized and
    // is only used (currently) by the PCI adapter type.
    //

     {
        0L,                             // Low address
        0L,                             // Hi address
        0L,                             // length
        0,                              // Is range in i/o space?
        0,                              // Range should be visible
        0                               // Range should be shareable
     }
};


VDATA v1280_1K_55[] =
{
   10018L,              // Dot Freq 1
   184L,                // Horiz Sync Pulse
   200L,                // Horiz Back Porch
   1280L,               // X size
   44L,                 // Horiz Front Porch
   360L,                // hco
   POSITIVE,            // Horizontal Polarity
   55L,                 // Vertical Refresh Rate in Hz.
   3L,                  // Vertical Sync Pulse
   26L,                 // Vertical Back Porch
   1024L,               // Y size
   3L,                  // Vertical Front Porch
   27L,                 // vco
   POSITIVE,            // Vertical Polarity
   0,                   // IcdSerPixClk
   0xFFFFFFFF,          // IcdCtrlPixClk
   0,                   // IcdSer525Ref
   0xFFFFFFFF,          // IcdCtrl525Ref
   0xFFFFFFFF,          // 525RefClkCnt
   0xFFFFFFFF,          // 525VidClkFreq
   0xFFFFFFFF,          // MemCfgClr
   0                    // MemCfgSet
};

//
// These values came from the 3.1 driver.
// They are more current than the 3.5 values
//


VDATA v640_480_60[] =
{
   2517L,               // Dot Freq 1
   96L,                 // Horiz Sync Pulse
   32L,                 // Horiz Back Porch
   640L,                // X size
   32L,                 // Horiz Front Porch
   0L,                  // hco
   NEGATIVE,            // Horizontal Polarity
   60L,                 // Vertical Refresh Rate in Hz.
   4L,                  // Vertical Sync Pulse
   24L,                 // Vertical Back Porch
   480L,                // Y size
   17L,                 // Vertical Front Porch
   0L,                  // vco
   NEGATIVE,            // Vertical Polarity
   0,                   // IcdSerPixClk
   0xFFFFFFFF,          // IcdCtrlPixClk
   0,                   // IcdSer525Ref
   0xFFFFFFFF,          // IcdCtrl525Ref
   0xFFFFFFFF,          // 525RefClkCnt
   0xFFFFFFFF,          // 525VidClkFreq
   0xFFFFFFFF,          // MemCfgClr
   0                    // MemCfgSet
};

VDATA v640_480_72[] =
{
   3150L,               // Dot Freq 1
   40L,                 // Horiz Sync Pulse
   136L,                // Horiz Back Porch
   640L,                // X size
   32L,                 // Horiz Front Porch
   144L,                // hco
   NEGATIVE,            // Horizontal Polarity
   72L,                 // Vertical Refresh Rate in Hz.
   3L,                  // Vertical Sync Pulse
   28L,                 // Vertical Back Porch
   480L,                // Y size
   9L,                  // Vertical Front Porch
   35L,                 // vco
   NEGATIVE,            // Vertical Polarity
   0,                   // IcdSerPixClk
   0xFFFFFFFF,          // IcdCtrlPixClk
   0,                   // IcdSer525Ref
   0xFFFFFFFF,          // IcdCtrl525Ref
   0xFFFFFFFF,          // 525RefClkCnt
   0xFFFFFFFF,          // 525VidClkFreq
   0xFFFFFFFF,          // MemCfgClr
   0                    // MemCfgSet
};

VDATA v800_600_60[] =
{
   4000L,               // Dot Freq 1
   128L,                // Horiz Sync Pulse
   88L,                 // Horiz Back Porch
   800L,                // X size
   40L,                 // Horiz Front Porch
   192L,                // hco
   POSITIVE,            // Horizontal Polarity
   60L,                 // Vertical Refresh Rate in Hz.
   4L,                  // Vertical Sync Pulse
   23L,                 // Vertical Back Porch
   600L,                // Y size
   1L,                  // Vertical Front Porch
   22L,                 // vco
   POSITIVE,            // Vertical Polarity
   0,                   // IcdSerPixClk
   0xFFFFFFFF,          // IcdCtrlPixClk
   0,                   // IcdSer525Ref
   0xFFFFFFFF,          // IcdCtrl525Ref
   0xFFFFFFFF,          // 525RefClkCnt
   0xFFFFFFFF,          // 525VidClkFreq
   0xFFFFFFFF,          // MemCfgClr
   0                    // MemCfgSet
};

VDATA v800_600_72[] =
{
   5000L,               // Dot Freq 1
   120L,                // Horiz Sync Pulse
   64L,                 // Horiz Back Porch
   800L,                // X size
   56L,                 // Horiz Front Porch
   192L,                // hco
   POSITIVE,            // Horizontal Polarity
   72L,                 // Vertical Refresh Rate in Hz.
   6L,                  // Vertical Sync Pulse
   23L,                 // Vertical Back Porch
   600L,                // Y size
   37L,                 // Vertical Front Porch
   22L,                 // vco
   POSITIVE,            // Vertical Polarity
   0,                   // IcdSerPixClk
   0xFFFFFFFF,          // IcdCtrlPixClk
   0,                   // IcdSer525Ref
   0xFFFFFFFF,          // IcdCtrl525Ref
   0xFFFFFFFF,          // 525RefClkCnt
   0xFFFFFFFF,          // 525VidClkFreq
   0xFFFFFFFF,          // MemCfgClr
   0                    // MemCfgSet
};

VDATA v1K_768_60[] =
{
   6500L,               // Dot Freq 1
   136L,                // Horiz Sync Pulse
   160L,                // Horiz Back Porch
   1024L,               // X size
   24L,                 // Horiz Front Porch
   272L,                // hco
   NEGATIVE,            // Horizontal Polarity
   60L,                 // Vertical Refresh Rate in Hz.
   6L,                  // Vertical Sync Pulse
   29L,                 // Vertical Back Porch
   768L,                // Y size
   3L,                  // Vertical Front Porch
   30L,                 // vco
   NEGATIVE,            // Vertical Polarity
   0,                   // IcdSerPixClk
   0xFFFFFFFF,          // IcdCtrlPixClk
   0,                   // IcdSer525Ref
   0xFFFFFFFF,          // IcdCtrl525Ref
   0xFFFFFFFF,          // 525RefClkCnt
   0xFFFFFFFF,          // 525VidClkFreq
   0xFFFFFFFF,          // MemCfgClr
   0                    // MemCfgSet
};

VDATA v1K_768_70[] =
{
   7500L,               // Dot Freq 1
   136L,                // Horiz Sync Pulse
   144L,                // Horiz Back Porch
   1024L,               // X size
   24L,                 // Horiz Front Porch
   256L,                // hco
   NEGATIVE,            // Horizontal Polarity
   70L,                 // Vertical Refresh Rate in Hz.
   6L,                  // Vertical Sync Pulse
   29L,                 // Vertical Back Porch
   768L,                // Y size
   3L,                  // Vertical Front Porch
   30L,                 // vco
   NEGATIVE,            // Vertical Polarity
   0,                   // IcdSerPixClk
   0xFFFFFFFF,          // IcdCtrlPixClk
   0,                   // IcdSer525Ref
   0xFFFFFFFF,          // IcdCtrl525Ref
   0xFFFFFFFF,          // 525RefClkCnt
   0xFFFFFFFF,          // 525VidClkFreq
   0xFFFFFFFF,          // MemCfgClr
   0                    // MemCfgSet
};

VDATA v1280_1K_60[] =
{
   11500L,              // Dot Freq 1
   224L,                // Horiz Sync Pulse
   256L,                // Horiz Back Porch
   1280L,               // X size
   32L,                 // Horiz Front Porch
   456L,                // hco
   POSITIVE,            // Horizontal Polarity
   60L,                 // Vertical Refresh Rate in Hz.
   3L,                  // Vertical Sync Pulse
   42L,                 // Vertical Back Porch
   1024L,               // Y size
   1L,                  // Vertical Front Porch
   41L,                 // vco
   POSITIVE,            // Vertical Polarity
   0,                   // IcdSerPixClk
   0xFFFFFFFF,          // IcdCtrlPixClk
   0,                   // IcdSer525Ref
   0xFFFFFFFF,          // IcdCtrl525Ref
   0xFFFFFFFF,          // 525RefClkCnt
   0xFFFFFFFF,          // 525VidClkFreq
   0xFFFFFFFF,          // MemCfgClr
   0                    // MemCfgSet
};

VDATA v1280_1K_74[] =
{
   13500L,              // Dot Freq 1
   144L,                // Horiz Sync Pulse
   256L,                // Horiz Back Porch
   1280L,               // X size
   32L,                 // Horiz Front Porch
   0L,                  // hco
   POSITIVE,            // Horizontal Polarity
   74L,                 // Vertical Refresh Rate in Hz.
   3L,                  // Vertical Sync Pulse
   38L,                 // Vertical Back Porch
   1024L,               // Y size
   1L,                  // Vertical Front Porch
   0L,                  // vco
   POSITIVE,            // Vertical Polarity
   0,                   // IcdSerPixClk
   0xFFFFFFFF,          // IcdCtrlPixClk
   0,                   // IcdSer525Ref
   0xFFFFFFFF,          // IcdCtrl525Ref
   0xFFFFFFFF,          // 525RefClkCnt
   0xFFFFFFFF,          // 525VidClkFreq
   0xFFFFFFFF,          // MemCfgClr
   0                    // MemCfgSet
};

VDATA v1280_1K_75[] =
{
   12800L,              // Dot Freq 1
   112L,                // Horiz Sync Pulse
   240L,                // Horiz Back Porch
   1280L,               // X size
   32L,                 // Horiz Front Porch
   0L,                  // hco
   POSITIVE,            // Horizontal Polarity
   75L,                 // Vertical Refresh Rate in Hz.
   15L,                 // Vertical Sync Pulse
   26L,                 // Vertical Back Porch
   1024L,               // Y size
   3L,                  // Vertical Front Porch
   0L,                  // vco
   POSITIVE,            // Vertical Polarity
   0,                   // IcdSerPixClk
   0xFFFFFFFF,          // IcdCtrlPixClk
   0,                   // IcdSer525Ref
   0xFFFFFFFF,          // IcdCtrl525Ref
   0xFFFFFFFF,          // 525RefClkCnt
   0xFFFFFFFF,          // 525VidClkFreq
   0xFFFFFFFF,          // MemCfgClr
   0                    // MemCfgSet
};

VDATA v1600_1200_60[] =
{
   16000L,              // Dot Freq 1
   144L,                // Horiz Sync Pulse
   272L,                // Horiz Back Porch
   1600L,               // X size
   32L,                 // Horiz Front Porch
   0L,                  // hco
   NEGATIVE,            // Horizontal Polarity
   60L,                 // Vertical Refresh Rate in Hz.
   8L,                  // Vertical Sync Pulse
   49L,                 // Vertical Back Porch
   1200L,               // Y size
   4L,                  // Vertical Front Porch
   0L,                  // vco
   NEGATIVE,            // Vertical Polarity
   0,                   // IcdSerPixClk
   0xFFFFFFFF,          // IcdCtrlPixClk
   0,                   // IcdSer525Ref
   0xFFFFFFFF,          // IcdCtrl525Ref
   0xFFFFFFFF,          // 525RefClkCnt
   0xFFFFFFFF,          // 525VidClkFreq
   0xFFFFFFFF,          // MemCfgClr
   0                    // MemCfgSet
};

//
// P9 mode information Tables. This is the data which is returned to
// the Win32 driver so that it can select the proper video mode.
//

P9INITDATA P9Modes[mP9ModeCount] =
{
{
  18,                                   // Number of entries in the structure
  (P9000_ID | P9100_ID),
  v640_480_60,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode informtion structure
      m640_480_8_60,                    // Index used to set this mode
      640,                              // X Resolution, in pixels
      480,                              // Y Resolution, in pixels
      640,                              // physical scanline byte length
      1,                                // Number of video memory planes
      8,                                // Number of bits per plane
      60,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00000000,                       // Mask for Red bits in non-palette modes
      0x00000000,                       // Mask for Green bits in non-palette modes
      0x00000000,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
      VIDEO_MODE_MANAGED_PALETTE,       // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the structure
  (P9000_ID | P9100_ID),
  v640_480_60,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode informtion structure
      m640_480_16_60,                   // Index used to set this mode
      640,                              // X Resolution, in pixels
      480,                              // Y Resolution, in pixels
      640 * 2,                          // physical scanline byte length
      1,                                // Number of video memory planes
      16,                               // Number of bits per plane
      60,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      5,                                // # of Red bits in non-palette modes
      5,                                // # of Green bits in non-palette modes
      5,                                // # of Blue bits in non-palette modes
      0x00007C00,                       // Mask for Red bits in non-palette modes
      0x000003E0,                       // Mask for Green bits in non-palette modes
      0x0000001F,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,   // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the structure
  P9100_ID,
  v640_480_60,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode informtion structure
      m640_480_24_60,                   // Index used to set this mode
      640,                              // X Resolution, in pixels
      480,                              // Y Resolution, in pixels
      640 * 3,                          // physical scanline byte length
      1,                                // Number of video memory planes
      24,                               // Number of bits per plane
      60,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00FF0000,                       // Mask for Red bits in non-palette modes
      0x0000FF00,                       // Mask for Green bits in non-palette modes
      0x000000FF,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,   // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the structure
  (P9000_ID | P9100_ID),
  v640_480_60,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode informtion structure
      m640_480_32_60,                   // Index used to set this mode
      640,                              // X Resolution, in pixels
      480,                              // Y Resolution, in pixels
      640 * 4,                          // physical scanline byte length
      1,                                // Number of video memory planes
      32,                               // Number of bits per plane
      60,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00FF0000,                       // Mask for Red bits in non-palette modes
      0x0000FF00,                       // Mask for Green bits in non-palette modes
      0x000000FF,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the structure
  (P9000_ID | P9100_ID),
  v640_480_72,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode informtion structure
      m640_480_8_72,                    // Index used to set this mode
      640,                              // X Resolution, in pixels
      480,                              // Y Resolution, in pixels
      640,                              // physical scanline byte length
      1,                                // Number of video memory planes
      8,                                // Number of bits per plane
      72,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00000000,                       // Mask for Red bits in non-palette modes
      0x00000000,                       // Mask for Green bits in non-palette modes
      0x00000000,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
      VIDEO_MODE_MANAGED_PALETTE,       // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the structure
  (P9000_ID | P9100_ID),
  v640_480_72,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode informtion structure
      m640_480_16_72,                   // Index used to set this mode
      640,                              // X Resolution, in pixels
      480,                              // Y Resolution, in pixels
      640 * 2,                          // physical scanline byte length
      1,                                // Number of video memory planes
      16,                               // Number of bits per plane
      72,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      5,                                // # of Red bits in non-palette modes
      5,                                // # of Green bits in non-palette modes
      5,                                // # of Blue bits in non-palette modes
      0x00007C00,                       // Mask for Red bits in non-palette modes
      0x000003E0,                       // Mask for Green bits in non-palette modes
      0x0000001F,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,   // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the structure
  P9100_ID,
  v640_480_72,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode informtion structure
      m640_480_24_72,                   // Index used to set this mode
      640,                              // X Resolution, in pixels
      480,                              // Y Resolution, in pixels
      640 * 3,                          // physical scanline byte length
      1,                                // Number of video memory planes
      24,                               // Number of bits per plane
      72,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00FF0000,                       // Mask for Red bits in non-palette modes
      0x0000FF00,                       // Mask for Green bits in non-palette modes
      0x000000FF,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the structure
  (P9000_ID | P9100_ID),
  v640_480_72,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode informtion structure
      m640_480_32_72,                   // Index used to set this mode
      640,                              // X Resolution, in pixels
      480,                              // Y Resolution, in pixels
      640 * 4,                          // physical scanline byte length
      1,                                // Number of video memory planes
      32,                               // Number of bits per plane
      72,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00FF0000,                       // Mask for Red bits in non-palette modes
      0x0000FF00,                       // Mask for Green bits in non-palette modes
      0x000000FF,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the mode set structure
  (P9000_ID | P9100_ID),
  v800_600_60,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m800_600_8_60,                    // Index used to set this mode
      800,                              // X Resolution, in pixels
      600,                              // Y Resolution, in pixels
      800,                              // physical scanline byte length
      1,                                // Number of video memory planes
      8,                                // Number of bits per plane
      60,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00000000,                       // Mask for Red bits in non-palette modes
      0x00000000,                       // Mask for Green bits in non-palette modes
      0x00000000,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
      VIDEO_MODE_MANAGED_PALETTE,       // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the mode set structure
  (P9000_ID | P9100_ID),
  v800_600_72,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m800_600_8_72,                    // Index used to set this mode
      800,                              // X Resolution, in pixels
      600,                              // Y Resolution, in pixels
      800,                              // physical scanline byte length
      1,                                // Number of video memory planes
      8,                                // 