							 LPEXCHEXTMODELESSCALLBACK FAR * ppeemcb) PURE;
	STDMETHOD(ChooseFolder) (THIS_ LPEXCHEXTCHOOSEFOLDER peecf) PURE;
};
typedef IExchExtCallback FAR * LPEXCHEXTCALLBACK;


/*
 *	E x t e n s i o n   I n t e r f a c e s
 */


/*
 *	IExchExt
 *
 *	Purpose:
 *		Central interface implemented by Exchange client extensions.
 */
#undef INTERFACE
#define INTERFACE   IExchExt

DECLARE_INTERFACE_(IExchExt, IUnknown)
{
	BEGIN_INTERFACE

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExchExt methods ***
    STDMETHOD(Install) (THIS_ LPEXCHEXTCALLBACK lpeecb,
    					ULONG mecontext, ULONG ulFlags) PURE;
};
typedef IExchExt FAR * LPEXCHEXT;

// Type of function called by the client to load an extension
typedef LPEXCHEXT (CALLBACK * LPFNEXCHEXTENTRY)(VOID);


/*
 *	IExchExtCommands
 *
 *	Purpose:
 *		Interface implemented by Exchange client extensions that wish to
 *		add additional commands to the client's menus.
 */
#undef INTERFACE
#define INTERFACE   IExchExtCommands

DECLARE_INTERFACE_(IExchExtCommands, IUnknown)
{
	BEGIN_INTERFACE

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExchExtCommands methods ***
	STDMETHOD(InstallCommands) (THIS_ LPEXCHEXTCALLBACK lpeecb, HWND hwnd,
								HMENU hmenu, UINT FAR * lpcmdidBase,
								LPTBENTRY lptbeArray, UINT ctbe,
								ULONG ulFlags) PURE;
	STDMETHOD_(VOID,InitMenu) (THIS_ LPEXCHEXTCALLBACK lpeecb) PURE;
	STDMETHOD(DoCommand) (THIS_ LPEXCHEXTCALLBACK lpeecb, UINT cmdid) PURE;
	STDMETHOD(Help) (THIS_ LPEXCHEXTCALLBACK lpeecb, UINT cmdid) PURE;
	STDMETHOD(QueryHelpText) (THIS_ UINT cmdid, ULONG ulFlags,
							  LPTSTR lpsz, UINT cch) PURE;
	STDMETHOD(QueryButtonInfo) (THIS_ ULONG tbid, UINT itbb, LPTBBUTTON ptbb,
								LPTSTR lpsz, UINT cch, ULONG ulFlags) PURE;
	STDMETHOD(ResetToolbar) (THIS_ ULONG tbid, ULONG ulFlags) PURE;
};
typedef IExchExtCommands FAR * LPEXCHEXTCOMMANDS;


/*
 *	IExchExtUserEvents
 *
 *	Purpose:
 *		Interface implemented by Exchange client extensions that wish to
 *		take special action when the user does certain actions.
 */
#undef INTERFACE
#define INTERFACE   IExchExtUserEvents

DECLARE_INTERFACE_(IExchExtUserEvents, IUnknown)
{
	BEGIN_INTERFACE

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExchExtUserEvents methods ***
	STDMETHOD_(VOID,OnSelectionChange) (THIS_ LPEXCHEXTCALLBACK lpeecb) PURE;
	STDMETHOD_(VOID,OnObjectChange) (THIS_ LPEXCHEXTCALLBACK lpeecb) PURE;
};
typedef IExchExtUserEvents FAR * LPEXCHEXTUSEREVENTS;


/*
 *	IExchExtSessionEvents
 *
 *	Purpose:
 *		Interface implemented by Exchange client extensions that wish to
 *		take special action when certain events happen in the session.
 */
#undef INTERFACE
#define INTERFACE   IExchExtSessionEvents

DECLARE_INTERFACE_(IExchExtSessionEvents, IUnknown)
{
	BEGIN_INTERFACE

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExchExtEvents methods ***
	STDMETHOD(OnDelivery)(THIS_ LPEXCHEXTCALLBACK lpeecb) PURE;
};
typedef IExchExtSessionEvents FAR * LPEXCHEXTSESSIONEVENTS;


/*
 *	IExchExtMessageEvents
 *
 *	Purpose:
 *		Interface implemented by Exchange client extensions that wish to
 *		take special action when certain events happen to messages.
 */
#undef INTERFACE
#define INTERFACE   IExchExtMessageEvents

DECLARE_INTERFACE_(IExchExtMessageEvents, IUnknown)
{
	BEGIN_INTERFACE

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExchExtMessageEvents methods ***
	STDMETHOD(OnRead)(THIS_ LPEXCHEXTCALLBACK lpeecb) PURE;
	STDMETHOD(OnReadComplete)(THIS_ LPEXCHEXTCALLBACK lpeecb,
							  ULONG ulFlags) PURE;
	STDMETHOD(OnWrite)(THIS_ LPEXCHEXTCALLBACK lpeecb) PURE;
	STDMETHOD(OnWriteComplete)(THIS_ LPEXCHEXTCALLBACK lpeecb,
							   ULONG ulFlags) PURE;
	STDMETHOD(OnCheckNames)(THIS_ LPEXCHEXTCALLBACK lpeecb) PURE;
	STDMETHOD(OnCheckNamesComplete)(THIS_ LPEXCHEXTCALLBACK lpeecb,
									ULONG ulFlags) PURE;
	STDMETHOD(OnSubmit)(THIS_ LPEXCHEXTCALLBACK lpeecb) PURE;
	STDMETHOD_(VOID, OnSubmitComplete)(THIS_ LPEXCHEXTCALLBACK lpeecb,
									   ULONG ulFlags) PURE;
};
typedef IExchExtMessageEvents FAR * LPEXCHEXTMESSAGEEVENTS;


/*
 *	IExchExtAttachedFileEvents
 *
 *	Purpose:
 *		Interface implemented by Exchange client extensions that wish to
 *		take special action when certain events happen to attached files.
 */
#undef INTERFACE
#define INTERFACE   IExchExtAttachedFileEvents

DECLARE_INTERFACE_(IExchExtAttachedFileEvents, IUnknown)
{
	BEGIN_INTERFACE

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExchExtAttachedFileEvents methods ***
	STDMETHOD(OnReadPattFromSzFile)(THIS_ LPATTACH lpatt, LPTSTR lpszFile,
									ULONG ulFlags) PURE;
	STDMETHOD(OnWritePattToSzFile)(THIS_ LPATTACH lpatt, LPTSTR lpszFile,
								   ULONG ulFlags) PURE;
	STDMETHOD(QueryDisallowOpenPatt)(THIS_ LPATTACH lpatt) PURE;
	STDMETHOD(OnOpenPatt)(THIS_ LPATTACH lpatt) PURE;
	STDMETHOD(OnOpenSzFile)(THIS_ LPTSTR lpszFile, ULONG ulFlags) PURE;
};
typedef IExchExtAttachedFileEvents FAR * LPEXCHEXTATTACHEDFILEEVENTS;


/*
 *	IExchExtPropertySheets
 *
 *	Purpose:
 *		Interface implemented by Exchange client extensions that wish
 *		to add additional pages to the client's object property sheets.
 */
#undef INTERFACE
#define INTERFACE   IExchExtPropertySheets

DECLARE_INTERFACE_(IExchExtPropertySheets, IUnknown)
{
	BEGIN_INTERFACE

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExchExtPropertySheet methods ***
	STDMETHOD_(ULONG,GetMaxPageCount) (THIS_ ULONG ulFlags) PURE;
	STDMETHOD(GetPages) (THIS_ LPEXCHEXTCALLBACK lpeecb, ULONG ulFlags,
						 LPPROPSHEETPAGE lppsp, ULONG FAR * lpcpsp) PURE;
	STDMETHOD_(VOID,FreePages) (THIS_ LPPROPSHEETPAGE lppsp,
								ULONG ulFlags, ULONG cpsp) PURE;
};
typedef IExchExtPropertySheets FAR * LPEXCHEXTPROPERTYSHEETS;


/*
 *	IExchExtAdvancedCriteria
 *
 *	Purpose:
 *		Interface implemented by Exchange client extensions that wish to
 *		implement an advanced criteria dialog.
 */
#undef INTERFACE
#define INTERFACE   IExchExtAdvancedCriteria

DECLARE_INTERFACE_(IExchExtAdvancedCriteria, IUnknown)
{
	BEGIN_INTERFACE

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExchExtAdvancedCriteria methods ***
	STDMETHOD(InstallAdvancedCriteria) (THIS_ HWND hwnd, LPSRestriction lpres,
										BOOL fNot, LPENTRYLIST lpeidl,
										ULONG ulFlags) PURE;
	STDMETHOD(DoDialog) (THIS) PURE;
	STDMETHOD_(VOID,Clear) (THIS) PURE;
	STDMETHOD_(VOID,SetFolders) (THIS_ LPENTRYLIST lpeidl, ULONG ulFlags) PURE;
	STDMETHOD(QueryRestriction) (THIS_ LPVOID lpvAllocBase,
								 LPSRestriction FAR * lppres,
								 LPSPropTagArray FAR * lppPropTags,
								 LPMAPINAMEID FAR * FAR * lpppPropNames,
								 BOOL * lpfNot, LPTSTR lpszDesc, ULONG cchDesc,
								 ULONG ulFlags) PURE;
	STDMETHOD_(VOID,UninstallAdvancedCriteria) (THIS) PURE;
};
typedef IExchExtAdvancedCriteria FAR * LPEXCHEXTADVANCEDCRITERIA;


/*
 *  IExchExtModeless
 *
 *	Purpose:
 *		Interface implemented by Exchange client extensions that wish
 *		to create modeless UI.
 */
#undef INTERFACE
#define INTERFACE   IExchExtModeless

DECLARE_INTERFACE_(IExchExtModeless, IUnknown)
{
	BEGIN_INTERFACE

	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

	// *** IExchExtModeless methods ***
	STDMETHOD(TranslateAccelerator) (THIS_ LPMSG pmsg) PURE;
	STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
};


/*
 *	G U I D s
 */


#define DEFINE_EXCHEXTGUID(name, b) \
    DEFINE_GUID(name, 0x00020D00 | (b), 0, 0, 0xC0,0,0,0,0,0,0,0x46)

#ifndef NOEXCHEXTGUIDS
DEFINE_EXCHEXTGUID(IID_IExchExtCallback,			0x10);
DEFINE_EXCHEXTGUID(IID_IExchExt,					0x11);
DEFINE_EXCHEXTGUID(IID_IExchExtCommands,			0x12);
DEFINE_EXCHEXTGUID(IID_IExchExtUserEvents,			0x13);
DEFINE_EXCHEXTGUID(IID_IExchExtSessionEvents,		0x14);
DEFINE_EXCHEXTGUID(IID_IExchExtMessageEvents,		0x15);
DEFINE_EXCHEXTGUID(IID_IExchExtAttachedFileEvents,	0x16);
DEFINE_EXCHEXTGUID(IID_IExchExtPropertySheets,		0x17);
DEFINE_EXCHEXTGUID(IID_IExchExtAdvancedCriteria,	0x18);
DEFINE_EXCHEXTGUID(IID_IExchExtModeless,			0x19);
DEFINE_EXCHEXTGUID(IID_IExchExtModelessCallback,	0x1a);
#endif // NOEXCHEXTGUIDS


/*
 *	C M D I D s
 */


// File
#define EECMDID_File								10
#define EECMDID_FileOpen							11
#define EECMDID_FileSend							12
#define EECMDID_FileSave             				13
#define EECMDID_FileSaveAs							14
#define EECMDID_FileMove      						16
#define EECMDID_FileCopy	      					17
#define EECMDID_FilePrint							25
#define EECMDID_FileNewEntry						18
#define EECMDID_FileNewMessage						19
#define EECMDID_FileNewFolder						20
#define EECMDID_FileAddToPAB						29
#define EECMDID_FileDelete							21
#define EECMDID_FileRename							22
#define EECMDID_FileProperties						23
#define EECMDID_FilePropertiesRecipients			24
#define EECMDID_FileClose            				30
#define EECMDID_FileExit							32
#define EECMDID_FileExitAndLogOff					33

// Edit
#define EECMDID_Edit                    			40
#define EECMDID_EditUndo                			41
#define EECMDID_EditCut                 			42
#define EECMDID_EditCopy                			43
#define EECMDID_EditPaste       					44
#define EECMDID_EditPasteSpecial   					45
#define EECMDID_EditSelectAll           			46
#define	EECMDID_EditMarkAsRead						49
#define EECMDID_EditMarkAsUnread					50
#define EECMDID_EditMarkToRetrieve					52
#define EECMDID_EditMarkToRetrieveACopy				53
#define EECMDID_EditMarkToDelete					54
#define EECMDID_EditUnmarkAll						55
#define EECMDID_EditFind                			56
#define EECMDID_EditReplace             			57
#define EECMDID_EditLinks               			59
#define EECMDID_EditObject              			60
#define EECMDID_EditObjectConvert					61
#ifdef DBCS
#define	EECMDID_EditFullShape						62
#define	EECMDID_EditHiraKataAlpha					63
#define	EECMDID_EditHangAlpha						64
#define	EECMDID_EditHanja							65
#define	EECMDID_EditRoman							66
#define	EECMDID_EditCode							67	
#endif

// View
#define EECMDID_View                    			70
#define EECMDID_ViewFolders             			71
#define EECMDID_ViewToolbar             			72
#define EECMDID_ViewFormattingToolbar   			73
#define EECMDID_ViewStatusBar           			74
#define EECMDID_ViewNewWindow						75
#define EECMDID_ViewColumns							79
#define EECMDID_ViewSort							78
#define EECMDID_ViewFilter							80
#define EECMDID_ViewBccBox              			91
#define EECMDID_ViewPrevious           				87
#define EECMDID_ViewNext           					88
#ifdef DBCS											
#define EECMDID_ViewWritingMode						89
#define EECMDID_ViewImeStatus						94
#endif
													
// Insert											
#define EECMDID_Insert                  			100
#define EECMDID_InsertFile							101
#define EECMDID_InsertMessage						102
#define EECMDID_InsertObject            			103
#define EECMDID_InsertInkObject						104
													
// Format											
#define EECMDID_Format                  			110
#define EECMDID_FormatFont              			111
#define EECMDID_FormatParagraph         			112
													
// Tools											
#define EECMDID_Tools								120
#define EECMDID_ToolsDeliverNowUsing				121
#define EECMDID_ToolsDeliverNow						122
#define EECMDID_ToolsSpelling	        			131
#define EECMDID_ToolsAddressBook					123
#define EECMDID_ToolsCheckNames         			133
#define EECMDID_ToolsFind							124
#define EECMDID_ToolsConnect						126
#define EECMDID_ToolsUpdateHeaders					127
#define EECMDID_ToolsTransferMail					128
#define EECMDID_ToolsDisconnect						129
#define EECMDID_ToolsRemoteMail						130
#define EECMDID_ToolsCustomizeToolbar				134
#define EECMDID_ToolsServices						135
#define EECMDID_ToolsOptions						136
#ifdef DBCS											
#define	EECMDID_ToolsWordRegistration				137
#endif												
													
// Compose											
#define EECMDID_Compose								150
#define EECMDID_ComposeNewMessage					151
#define EECMDID_ComposeReplyToSender				154
#define EECMDID_ComposeReplyToAll					155
#define EECMDID_ComposeForward						156
													
// Help
#define EECMDID_Help								160
#define EECMDID_HelpMicrosoftExchangeHelpTopics		161
#define EECMDID_HelpAboutMicrosoftExchange			162

// Header											
#define EECMDID_CtxHeader							203
#define EECMDID_CtxHeaderSortAscending				204
#define EECMDID_CtxHeaderSortDescending				205
													
// In Folder										
#define EECMDID_CtxInFolder							206
#define EECMDID_CtxInFolderChoose					207
													
// Container										
#define EECMDID_CtxContainer						208
#define EECMDID_CtxContainerProperties				209

// Standard Toolbar
#define EECMDID_Toolbar								220
#define EECMDID_ToolbarPrint            			221
#define EECMDID_ToolbarReadReceipt					222
#define EECMDID_ToolbarImportanceHigh				223
#define EECMDID_ToolbarImportanceLow				224
#define EECMDID_ToolbarFolderList					225
#define EECMDID_ToolbarOpenParent					226
#define EECMDID_ToolbarInbox						76
#define EECMDID_ToolbarOutbox						77

// Formatting Toolbar
#define EECMDID_Formatting							230
#define EECMDID_FormattingFont						231
#define EECMDID_FormattingSize						232
#define EECMDID_FormattingColor						233
#define EECMDID_FormattingColorAuto					234
#define EECMDID_FormattingColor1					235
#define EECMDID_FormattingColor2					236
#define EECMDID_FormattingColor3					237
#define EECMDID_FormattingColor4					238
#define EECMDID_FormattingColor5					239
#define EECMDID_FormattingColor6					240
#define EECMDID_FormattingColor7					241
#define EECMDID_FormattingColor8					242
#define EECMDID_FormattingColor9					243
#define EECMDID_FormattingColor10					244
#define EECMDID_FormattingColor11					245
#define EECMDID_FormattingColor12					246
#define EECMDID_FormattingColor13					247
#define EECMDID_FormattingColor14					248
#define EECMDID_FormattingColor15					249
#define EECMDID_FormattingColor16					250
#define EECMDID_FormattingBold						251
#define EECMDID_FormattingItalic					252
#define EECMDID_FormattingUnderline					253
#define EECMDID_FormattingBullets					254
#define EECMDID_FormattingDecreaseIndent			255
#define EECMDID_FormattingIncreaseIndent			256
#define EECMDID_FormattingLeft						257
#define EECMDID_FormattingCenter					258
#define EECMDID_FormattingRight						259

// Note accelerators
#define EECMDID_Accel								270
#define EECMDID_AccelFont							271
#define EECMDID_AccelSize							272
#define EECMDID_AccelSizePlus1						273
#define EECMDID_AccelSizeMinus1						274
#define EECMDID_AccelBold							275
#define EECMDID_AccelItalic							276
#define EECMDID_AccelUnderline						277
#define EECMDID_AccelLeft							278
#define EECMDID_AccelCenter							279
#define EECMDID_AccelRight							280
#define EECMDID_AccelBullets						281
#define EECMDID_AccelNoFormatting					282
#define EECMDID_AccelRepeatFind						283
#define EECMDID_AccelContextHelp					284
#define EECMDID_AccelNextWindow						285
#define EECMDID_AccelPrevWindow						286
#define EECMDID_AccelCtrlTab						287
#define EECMDID_AccelUndo							288
#define EECMDID_AccelCut							289
#define EECMDID_AccelCopy							290
#define EECMDID_AccelPaste							291
#define EECMDID_AccelSubject						292
#define EECMDID_AccelContextHelpOff					293
#define EECMDID_AccelDecreaseIndent					294
#define EECMDID_AccelIncreaseIndent					295
#define EECMDID_AccelColor							296

// Edit.Object
#define EECMDID_ObjectMin							300
#define EECMDID_ObjectMax							399

// Tools.Remote Mail
#define EECMDID_RemoteMailMin						600
#define EECMDID_RemoteMailMax						699

// Tools.Deliver Now Using
#define EECMDID_DeliverNowUsingMin					700
#define EECMDID_DeliverNowUsingMax					799

// Form verbs
#define EECMDID_FormVerbMin							800
#define EECMDID_FormVerbMax							899

// For backward compatibility with earlier header versions
#define EECMDID_ViewInbox				EECMDID_ToolbarInbox
#define EECMDID_ViewOutbox				EECMDID_ToolbarOutbox
#define EECMDID_ViewItemAbove			EECMDID_ViewPrevious
#define EECMDID_ViewItemBelow           EECMDID_ViewNext
#define EECMDID_ToolsFindItem			EECMDID_ToolsFind
#define EECMDID_HelpUsersGuideContents	EECMDID_HelpMicrosoftExchangeHelpTopics
#define EECMDID_HelpAbout				EECMDID_HelpAboutMicrosoftExchange

#endif // EXCHEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\dlcapi.h ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    dlcapi.h

Abstract:

    This module defines 32-bit Windows/NT DLC structures and manifests

Revision History:

--*/

#ifndef _DLCAPI_
#define _DLCAPI_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// DLC Command Codes
//

#define LLC_DIR_INTERRUPT               0x00
#define LLC_DIR_OPEN_ADAPTER            0x03
#define LLC_DIR_CLOSE_ADAPTER           0x04
#define LLC_DIR_SET_MULTICAST_ADDRESS   0x05
#define LLC_DIR_SET_GROUP_ADDRESS       0x06
#define LLC_DIR_SET_FUNCTIONAL_ADDRESS  0x07
#define LLC_DIR_READ_LOG                0x08
#define LLC_TRANSMIT_FRAMES             0x09
#define LLC_TRANSMIT_DIR_FRAME          0x0A
#define LLC_TRANSMIT_I_FRAME            0x0B
#define LLC_TRANSMIT_UI_FRAME           0x0D
#define LLC_TRANSMIT_XID_CMD            0x0E
#define LLC_TRANSMIT_XID_RESP_FINAL     0x0F
#define LLC_TRANSMIT_XID_RESP_NOT_FINAL 0x10
#define LLC_TRANSMIT_TEST_CMD           0x11
#define LLC_DLC_RESET                   0x14
#define LLC_DLC_OPEN_SAP                0x15
#define LLC_DLC_CLOSE_SAP               0x16
#define LLC_DLC_REALLOCATE_STATIONS     0x17
#define LLC_DLC_OPEN_STATION            0x19
#define LLC_DLC_CLOSE_STATION           0x1A
#define LLC_DLC_CONNECT_STATION         0x1B
#define LLC_DLC_MODIFY                  0x1C
#define LLC_DLC_FLOW_CONTROL            0x1D
#define LLC_DLC_STATISTICS              0x1E
#define LLC_DIR_INITIALIZE              0x20
#define LLC_DIR_STATUS                  0x21
#define LLC_DIR_TIMER_SET               0x22
#define LLC_DIR_TIMER_CANCEL            0x23
#define LLC_BUFFER_GET                  0x26
#define LLC_BUFFER_FREE                 0x27
#define LLC_RECEIVE                     0x28
#define LLC_RECEIVE_CANCEL              0x29
#define LLC_RECEIVE_MODIFY              0x2A
#define LLC_DIR_TIMER_CANCEL_GROUP      0x2C
#define LLC_DIR_SET_EXCEPTION_FLAGS     0x2D
#define LLC_BUFFER_CREATE               0x30
#define LLC_READ                        0x31
#define LLC_READ_CANCEL                 0x32
#define LLC_DLC_SET_THRESHOLD           0x33
#define LLC_DIR_CLOSE_DIRECT            0x34
#define LLC_DIR_OPEN_DIRECT             0x35
#define LLC_MAX_DLC_COMMAND             0x37

//
// forward definitions
//

union _LLC_PARMS;
typedef union _LLC_PARMS LLC_PARMS, *PLLC_PARMS;

//
// Parameters. Can be pointer to a parameter table (32-bit flat address),
// a single 32-bit ULONG, 2 16-bit USHORTs or 4 8-bit BYTEs
//

typedef union {

    PLLC_PARMS pParameterTable;     // pointer to the parameter table

    struct {
        USHORT usStationId;         // Station id
        USHORT usParameter;         // optional parameter
    } dlc;

    struct {
        USHORT usParameter0;        // first optional parameter
        USHORT usParameter1;        // second optional parameter
    } dir;

    UCHAR auchBuffer[4];            // group/functional address

    ULONG ulParameter;

} CCB_PARMS;

//
// LLC_CCB - the Command Control Block structure
//

typedef struct _LLC_CCB {
    UCHAR uchAdapterNumber;         // Adapter 0 or 1
    UCHAR uchDlcCommand;            // DLC command
    UCHAR uchDlcStatus;             // DLC command completion code
    UCHAR uchReserved1;             // reserved for DLC DLL
    struct _LLC_CCB* pNext;         // CCB chain
    ULONG ulCompletionFlag;         // used in command completion
    CCB_PARMS u;                    // parameters
    HANDLE hCompletionEvent;        // event for command completion
    UCHAR uchReserved2;             // reserved for DLC DLL
    UCHAR uchReadFlag;              // set when special READ CCB chained
    USHORT usReserved3;             // reserved for DLC DLL
} LLC_CCB, *PLLC_CCB;

//
// transmit/receive buffers
//

union _LLC_BUFFER;
typedef union _LLC_BUFFER LLC_BUFFER, *PLLC_BUFFER;

typedef struct {
    PLLC_BUFFER pNextBuffer;        // next DLC buffer in frame
    USHORT cbFrame;                 // length of the whole received frame
    USHORT cbBuffer;                // length of this segment
    USHORT offUserData;             // offset of data from descriptor header
    USHORT cbUserData;              // length of the data
} LLC_NEXT_BUFFER;

typedef struct {
    PLLC_BUFFER pNextBuffer;        // next buffer of frame
    USHORT cbFrame;                 // length of entire frame
    USHORT cbBuffer;                // length of this buffer
    USHORT offUserData;             // user data in this struct
    USHORT cbUserData;              // length of user data
    USHORT usStationId;             // ssnn station id
    UCHAR uchOptions;               // option byte from RECEIVE param tbl
    UCHAR uchMsgType;               // the message type
    USHORT cBuffersLeft;            // number of basic buffer units left
    UCHAR uchRcvFS;                 // the reveived frame status
    UCHAR uchAdapterNumber;         // adapter number
    PLLC_BUFFER pNextFrame;         // pointer to next frame
    UCHAR cbLanHeader;              // length of the lan header
    UCHAR cbDlcHeader;              // length of the DLC header
    UCHAR auchLanHeader[32];        // lan header of the received frame
    UCHAR auchDlcHeader[4];         // dlc header of the received frame
    USHORT usPadding;               // data begins from offset 64 !!!
} LLC_NOT_CONTIGUOUS_BUFFER;

typedef struct {
    PLLC_BUFFER pNextBuffer;        // next buffer of frame
    USHORT cbFrame;                 // length of entire frame
    USHORT cbBuffer;                // length of this buffer
    USHORT offUserData;             // user data in this struct
    USHORT cbUserData;              // length of user data
    USHORT usStationId;             // ssnn station id
    UCHAR uchOptions;               // option byte from RECEIVE param tbl
    UCHAR uchMsgType;               // the message type
    USHORT cBuffersLeft;            // number of basic buffer units left
    UCHAR uchRcvFS;                 // the reveived frame status
    UCHAR uchAdapterNumber;         // adapter number
    PLLC_BUFFER pNextFrame;         // pointer to next frame
} LLC_CONTIGUOUS_BUFFER;

//
// Received frames are returned in these data structures
//

union _LLC_BUFFER {

    PLLC_BUFFER pNext;

    LLC_NEXT_BUFFER Next;

    struct LlcNextBuffer {
        LLC_NEXT_BUFFER Header;
        UCHAR auchData[];
    } Buffer;

    LLC_NOT_CONTIGUOUS_BUFFER NotContiguous;

    struct {
        LLC_NOT_CONTIGUOUS_BUFFER Header;
        UCHAR auchData[];
    } NotCont;

    LLC_CONTIGUOUS_BUFFER Contiguous;

    struct {
        LLC_CONTIGUOUS_BUFFER Header;
        UCHAR auchData[];
    } Cont;

};

//
// This structure is used by BUFFER.GET, BUFFER.FREE and TRANSMIT
//

struct _LLC_XMIT_BUFFER;
typedef struct _LLC_XMIT_BUFFER LLC_XMIT_BUFFER, *PLLC_XMIT_BUFFER;

struct _LLC_XMIT_BUFFER {
    PLLC_XMIT_BUFFER pNext;         // next buffer (or NULL)
    USHORT usReserved1;             //
    USHORT cbBuffer;                // length of transmitted data
    USHORT usReserved2;             //
    USHORT cbUserData;              // length of optional header
    UCHAR auchData[];               // optional header and transmitted data
};

#define LLC_XMIT_BUFFER_SIZE sizeof(LLC_XMIT_BUFFER)

//
// CCB parameter tables
//

typedef struct {
    HANDLE hBufferPool;             // handle of new buffer pool
    PVOID pBuffer;                  // any buffer in memory
    ULONG cbBufferSize;             // buffer size in bytes
    ULONG cbMinimumSizeThreshold;   // minimum locked size
} LLC_BUFFER_CREATE_PARMS, *PLLC_BUFFER_CREATE_PARMS;

typedef struct {
    USHORT usReserved1;             // Station id is not used
    USHORT cBuffersLeft;            // free 256 buffer segments
    ULONG ulReserved;
    PLLC_XMIT_BUFFER pFirstBuffer;  // buffer chain
} LLC_BUFFER_FREE_PARMS, *PLLC_BUFFER_FREE_PARMS;

typedef struct {
    USHORT usReserved1;             // Station id is not used
    USHORT cBuffersLeft;            // free 256 buffer segments

    //
    // cBuffersToGet: number of buffers to get. If 0, the returned buffer list
    // may consist of segment of different size
    //

    USHORT cBuffersToGet;

    //
    // cbBufferSize: size of the requested buffers. This will be rounded up to
    // the next largest segment size: 256, 512, 1024, 2048 or 4096
    //

    USHORT cbBufferSize;
    PLLC_XMIT_BUFFER pFirstBuffer;
} LLC_BUFFER_GET_PARMS, *PLLC_BUFFER_GET_PARMS;

//
// parameter table for DLC.CONNECT.STATION
//

typedef struct {
    USHORT usStationId;             // SAP or direct station ID, defines the pool
    USHORT usReserved;
    PUCHAR pRoutingInfo;            // offset to the routing info
} LLC_DLC_CONNECT_PARMS, *PLLC_DLC_CONNECT_PARMS;

//
// DLC_FLOW_CONTROL Options:
//

#define LLC_RESET_LOCAL_BUSY_USER   0x80
#define LLC_RESET_LOCAL_BUSY_BUFFER 0xC0
#define LLC_SET_LOCAL_BUSY_USER     0

typedef struct {
    USHORT usRes;
    USHORT usStationId;             // SAP or link station id
    UCHAR uchT1;                    // response timer
    UCHAR uchT2;                    // aknowledgment timer
    UCHAR uchTi;                    // inactivity timer
    UCHAR uchMaxOut;                // max transmits without ack
    UCHAR uchMaxIn;                 // max receives without ack
    UCHAR uchMaxOutIncr;            // dynamic window increment value
    UCHAR uchMaxRetryCnt;           // N2 value (retries)
    UCHAR uchReserved1;
    USHORT usMaxInfoFieldLength;    // Only for link stations, NEW!!!
    UCHAR uchAccessPriority;        // token ring access priority
    UCHAR auchReserved3[4];
    UCHAR cGroupCount;              // number of group SAPs of this SAP
    PUCHAR pGroupList;              // offset to the group list
} LLC_DLC_MODIFY_PARMS, *PLLC_DLC_MODIFY_PARMS;

#define LLC_XID_HANDLING_IN_APPLICATION 0x08
#define LLC_XID_HANDLING_IN_DLC         0
#define LLC_INDIVIDUAL_SAP              0x04
#define LLC_GROUP_SAP                   0x02
#define LLC_MEMBER_OF_GROUP_SAP         0x01

typedef struct {
    USHORT usStationId;             // SAP or link station id
    USHORT usUserStatValue;         // reserved for user
    UCHAR uchT1;                    // response timer
    UCHAR uchT2;                    // aknowledgment timer
    UCHAR uchTi;                    // inactivity timer
    UCHAR uchMaxOut;                // max tramists without ack
    UCHAR uchMaxIn;                 // max receives without ack
    UCHAR uchMaxOutIncr;            // dynamic window increment value
    UCHAR uchMaxRetryCnt;           // N2 value (retries)
    UCHAR uchMaxMembers;            // maximum members for group SAP
    USHORT usMaxI_Field;            // maximum length of the Info field
    UCHAR uchSapValue;              // SAP value to be assigned
    UCHAR uchOptionsPriority;       // SAP options and access priority
    UCHAR uchcStationCount;         // maximum number of link stations in sap
    UCHAR uchReserved2[2];          //
    UCHAR cGroupCount;              // number of group SAPs of this SAP
    PUCHAR pGroupList;              // offset to the group list
    ULONG DlcStatusFlags;           // User notify flag for DLC status changes
    UCHAR uchReserved3[8];          // reserved
    UCHAR cLinkStationsAvail;       // total number of available link stations
} LLC_DLC_OPEN_SAP_PARMS, *PLLC_DLC_OPEN_SAP_PARMS;

typedef struct {
    USHORT usSapStationId;          // SAP station id
    USHORT usLinkStationId;         // Link station id
    UCHAR uchT1;                    // response timer
    UCHAR uchT2;                    // aknowledgment timer
    UCHAR uchTi;                    // inactivity timer
    UCHAR uchMaxOut;                // max tramists without ack
    UCHAR uchMaxIn;                 // max receives without ack
    UCHAR uchMaxOutIncr;            // dynamic window increment value
    UCHAR uchMaxRetryCnt;           // N2 value (retries)
    UCHAR uchRemoteSap;             // remote SAP of the link
    USHORT usMaxI_Field;            // max I field length
    UCHAR uchAccessPriority;        // token ring access priority
    PVOID pRemoteNodeAddress;       // pointer to the destination address
} LLC_DLC_OPEN_STATION_PARMS, *PLLC_DLC_OPEN_STATION_PARMS;

#define LLC_INCREASE_LINK_STATIONS  0
#define LLC_DECREASE_LINK_STATIONS  0x80

typedef struct {
    USHORT usStationId;             // ID of affected SAP
    UCHAR uchOption;                // increase of decrease indicator
    UCHAR uchStationCount;
    UCHAR uchStationsAvailOnAdapter;
    UCHAR uchStationsAvailOnSap;
    UCHAR uchTotalStationsOnAdapter;
    UCHAR uchTotalStationsOnSap;
} LLC_DLC_REALLOCATE_PARMS, *PLLC_DLC_REALLOCATE_PARMS;

typedef struct {
    USHORT usStationId;             // SAP station ID
    USHORT cBufferThreshold;        // SAP buffer pool Threshold number
    PVOID AlertEvent;               // alerting event
} LLC_DLC_SET_THRESHOLD_PARMS, *PLLC_DLC_SET_THRESHOLD_PARMS;

typedef struct {
    PVOID TraceBuffer;              // trace buffer
    ULONG TraceBufferSize;          // trace buffer size
    ULONG TraceFlags;               // various trace flags
} LLC_TRACE_INITIALIZE_PARMS, *PLLC_TRACE_INITIALIZE_PARMS;

#define LLC_DLC_RESET_STATISTICS    0x80
#define LLC_DLC_READ_STATISTICS     0

typedef struct {
    ULONG cTransmittedFrames;
    ULONG cReceivedFrames;
    ULONG cDiscardedFrames;
    ULONG cDataLost;
    USHORT cBuffersAvailable;
} DLC_SAP_LOG, *PDLC_SAP_LOG;

typedef struct {
    USHORT cI_FramesTransmitted;
    USHORT cI_FramesReceived;
    UCHAR cI_FrameReceiveErrors;
    UCHAR cI_FrameTransmissionErrors;
    USHORT cT1_ExpirationCount;     // Note: not OUT data xfer mode
    UCHAR uchLastCmdRespReceived;
    UCHAR uchLastCmdRespTransmitted;
    UCHAR uchPrimaryState;
    UCHAR uchSecondaryState;
    UCHAR uchSendStateVariable;
    UCHAR uchReceiveStateVariable;
    UCHAR uchLastNr;                // last received NR
    UCHAR cbLanHeader;
    UCHAR auchLanHeader[32];
} DLC_LINK_LOG, *PDLC_LINK_LOG;

typedef union {
    DLC_SAP_LOG Sap;
    DLC_LINK_LOG Link;
} LLC_DLC_LOG_BUFFER, *PLLC_DLC_LOG_BUFFER;

typedef struct {
    USHORT usStationId;             // ID of a SAP or a link station
    USHORT cbLogBufSize;            //
    PLLC_DLC_LOG_BUFFER pLogBuf;    // offset to the log buffer
    USHORT usActLogLength;          // length of returned log
    UCHAR uchOptions;               // command options (bit7 resets log params)
} LLC_DLC_STATISTICS_PARMS, *PLLC_DLC_STATISTICS_PARMS;

typedef struct {
    USHORT usBringUps;              // Token Ring adapter bring up error code
    UCHAR Reserved[30];             // everything else specific to DOS or OS/2
} LLC_DIR_INITIALIZE_PARMS, *PLLC_DIR_INITIALIZE_PARMS;

typedef struct {
    USHORT usOpenErrorCode;         // open adapter errors detected
    USHORT usOpenOptions;           // various options
    UCHAR auchNodeAddress[6];       // adapters LAN address
    UCHAR auchGroupAddress[4];      // multicast address added in the open
    UCHAR auchFunctionalAddress[4]; // added token ring functional address
    USHORT usReserved1;
    USHORT usReserved2;
    USHORT usMaxFrameSize;          // maximum frame size defined in NDIS
    USHORT usReserved3[4];
    USHORT usBringUps;              // Bring up errors, TR only
    USHORT InitWarnings;
    USHORT usReserved4[3];
} LLC_ADAPTER_OPEN_PARMS, *PLLC_ADAPTER_OPEN_PARMS;

typedef struct {
    UCHAR uchDlcMaxSaps;
    UCHAR uchDlcMaxStations;
    UCHAR uchDlcMaxGroupSaps;
    UCHAR uchDlcMaxGroupMembers;
    UCHAR uchT1_TickOne;            // Short timer interval (for 1 - 5)
    UCHAR uchT2_TickOne;
    UCHAR uchTi_TickOne;
    UCHAR uchT1_TickTwo;            // Long timer interval (for 6 - 10)
    UCHAR uchT2_TickTwo;
    UCHAR uchTi_TickTwo;
} LLC_DLC_PARMS, *PLLC_DLC_PARMS;

//
// The ethernet mode selects the LAN header format of ethernet. SNA
// applications should use the default parameter, that has been defined in the
// registry. The applications using connectionless DLC services should select
// the ethernet LLC LAN header format they are using (usually 802.3)
//

typedef enum {
    LLC_ETHERNET_TYPE_DEFAULT,      // use the parameter value set in registry
    LLC_ETHERNET_TYPE_AUTO,         // automatic header type selction for links
    LLC_ETHERNET_TYPE_802_3,        // use always 802.3 lan headers
    LLC_ETHERNET_TYPE_DIX           // use always LLC on DIX SNA type.
} LLC_ETHERNET_TYPE, *PLLC_ETHERNET_TYPE;

typedef struct {
    PVOID hBufferPool;
    PVOID pSecurityDescriptor;
    LLC_ETHERNET_TYPE LlcEthernetType;
} LLC_EXTENDED_ADAPTER_PARMS, *PLLC_EXTENDED_ADAPTER_PARMS;

typedef struct {
    PLLC_ADAPTER_OPEN_PARMS pAdapterParms;      // ADAPTER_PARMS
    PLLC_EXTENDED_ADAPTER_PARMS pExtendedParms; // DIRECT_PARMS
    PLLC_DLC_PARMS pDlcParms;                   // DLC_PARMS
    PVOID pReserved1;                           // NCB_PARMS
} LLC_DIR_OPEN_ADAPTER_PARMS, *PLLC_DIR_OPEN_ADAPTER_PARMS;

typedef struct {
    UCHAR auchMulticastAddress[6];  // 48 bit multicast address
} LLC_DIR_MULTICAST_ADDRESS, *PLLC_DIR_MULTICAST_ADDRESS;

#define LLC_DIRECT_OPTIONS_ALL_MACS 0x1880

typedef struct {
    USHORT Reserved[4];
    USHORT usOpenOptions;
    USHORT usEthernetType;
    ULONG ulProtocolTypeMask;
    ULONG ulProtocolTypeMatch;
    USHORT usProtocolTypeOffset;
} LLC_DIR_OPEN_DIRECT_PARMS, *PLLC_DIR_OPEN_DIRECT_PARMS;

typedef struct {
    UCHAR cLineError;
    UCHAR cInternalError;
    UCHAR cBurstError;
    UCHAR cAC_Error;
    UCHAR cAbortDelimiter;
    UCHAR uchReserved1;
    UCHAR cLostFrame;
    UCHAR cReceiveCongestion;
    UCHAR cFrameCopiedError;
    UCHAR cFrequencyError;
    UCHAR cTokenError;
    UCHAR uchReserved2;
    UCHAR uchReserved3;
    UCHAR uchReserved4;
} LLC_ADAPTER_LOG_TR, *PLLC_ADAPTER_LOG_TR;

typedef struct {
    UCHAR cCRC_Error;
    UCHAR uchReserved1;
    UCHAR cAlignmentError;
    UCHAR uchReserved2;
    UCHAR cTransmitError;
    UCHAR uchReserved3;
    UCHAR cCollisionError;
    UCHAR cReceiveCongestion;
    UCHAR uchReserved[6];
} LLC_ADAPTER_LOG_ETH, *PLLC_ADAPTER_LOG_ETH;

typedef union {
    LLC_ADAPTER_LOG_TR Tr;
    LLC_ADAPTER_LOG_ETH Eth;
} LLC_ADAPTER_LOG, *PLLC_ADAPTER_LOG;

typedef struct {
    ULONG cTransmittedFrames;
    ULONG cReceivedFrames;
    ULONG cDiscardedFrames;
    ULONG cDataLost;
    USHORT cBuffersAvailable;
} LLC_DIRECT_LOG, *PLLC_DIRECT_LOG;

typedef union {
    LLC_ADAPTER_LOG Adapter;
    LLC_DIRECT_LOG Dir;

    struct {
        LLC_ADAPTER_LOG Adapter;
        LLC_DIRECT_LOG Dir;
    } both;

} LLC_DIR_READ_LOG_BUFFER, *PLLC_DIR_READ_LOG_BUFFER;

#define LLC_DIR_READ_LOG_ADAPTER    0
#define LLC_DIR_READ_LOG_DIRECT     1
#define LLC_DIR_READ_LOG_BOTH       2

typedef struct {
    USHORT usTypeId;                    // 0=adapter, 1=direct, 2=both logs
    USHORT cbLogBuffer;                 // size of log buffer
    PLLC_DIR_READ_LOG_BUFFER pLogBuffer;// pointer to log buffer
    USHORT cbActualLength;              // returned size of log buffer
} LLC_DIR_READ_LOG_PARMS, *PLLC_DIR_READ_LOG_PARMS;

typedef struct {
    ULONG ulAdapterCheckFlag;
    ULONG ulNetworkStatusFlag;
    ULONG ulPcErrorFlag;
    ULONG ulSystemActionFlag;
} LLC_DIR_SET_EFLAG_PARMS, *PLLC_DIR_SET_EFLAG_PARMS;

#define LLC_ADAPTER_ETHERNET    0x0010
#define LLC_ADAPTER_TOKEN_RING  0x0040

typedef struct {
    UCHAR auchPermanentAddress[6];  // permanent encoded address
    UCHAR auchNodeAddress[6];       // adapter's network address
    UCHAR auchGroupAddress[4];      // adapter's group address
    UCHAR auchFunctAddr[4];         // adapter's functional address
    UCHAR uchMaxSap;                // maximum allowable SAP
    UCHAR uchOpenSaps;              // number of currently open saps
    UCHAR uchMaxStations;           // max number of stations (always 253)
    UCHAR uchOpenStation;           // number of open stations (only up to 253)
    UCHAR uchAvailStations;         // number of available stations (always 253)
    UCHAR uchAdapterConfig;         // adapter configuration flags
    UCHAR auchReserved1[10];        // microcode level
    ULONG ulReserved1;
    ULONG ulReserved2;
    ULONG ulMaxFrameLength;         // maximum frame length (only in Windows/Nt)
    USHORT usLastNetworkStatus;
    USHORT usAdapterType;           // THIS BYTE IS NOT USED IN DOS DLC !!!
} LLC_DIR_STATUS_PARMS, *PLLC_DIR_STATUS_PARMS;


#define LLC_OPTION_READ_STATION 0
#define LLC_OPTION_READ_SAP     1
#define LLC_OPTION_READ_ALL     2

#define LLC_EVENT_SYSTEM_ACTION         0x0040
#define LLC_EVENT_NETWORK_STATUS        0x0020
#define LLC_EVENT_CRITICAL_EXCEPTION    0x0010
#define LLC_EVENT_STATUS_CHANGE         0x0008
#define LLC_EVENT_RECEIVE_DATA          0x0004
#define LLC_EVENT_TRANSMIT_COMPLETION   0x0002
#define LLC_EVENT_COMMAND_COMPLETION    0x0001
#define LLC_READ_ALL_EVENTS             0x007F

//
// LLC_STATUS_CHANGE indications
// The returned status value may be an inclusive-OR of several flags
//

#define LLC_INDICATE_LINK_LOST              0x8000
#define LLC_INDICATE_DM_DISC_RECEIVED       0x4000
#define LLC_INDICATE_FRMR_RECEIVED          0x2000
#define LLC_INDICATE_FRMR_SENT              0x1000
#define LLC_INDICATE_RESET                  0x0800
#define LLC_INDICATE_CONNECT_REQUEST        0x0400
#define LLC_INDICATE_REMOTE_BUSY            0x0200
#define LLC_INDICATE_REMOTE_READY           0x0100
#define LLC_INDICATE_TI_TIMER_EXPIRED       0x0080
#define LLC_INDICATE_DLC_COUNTER_OVERFLOW   0x0040
#define LLC_INDICATE_ACCESS_PRTY_LOWERED    0x0020
#define LLC_INDICATE_LOCAL_STATION_BUSY     0x0001

typedef struct {
    USHORT usStationId;
    UCHAR uchOptionIndicator;
    UCHAR uchEventSet;
    UCHAR uchEvent;
    UCHAR uchCriticalSubset;
    ULONG ulNotificationFlag;

    union {

        struct {
            USHORT usCcbCount;
            PLLC_CCB pCcbCompletionList;
            USHORT usBufferCount;
            PLLC_BUFFER pFirstBuffer;
            USHORT usReceivedFrameCount;
            PLLC_BUFFER pReceivedFrame;
            USHORT usEventErrorCode;
            USHORT usEventErrorData[3];
        } Event;

        struct {
            USHORT usStationId;
            USHORT usDlcStatusCode;
            UCHAR uchFrmrData[5];
            UCHAR uchAccessPritority;
            UCHAR uchRemoteNodeAddress[6];
            UCHAR uchRemoteSap;
            UCHAR uchReserved;
            USHORT usUserStatusValue;
        } Status;

    } Type;

} LLC_READ_PARMS, *PLLC_READ_PARMS;

//
// This data structure gives the best performance in Windows/Nt: The DLC driver
// must copy the CCB and the parameter table. If the driver knows that the
// parameter table is concatenated to the CCB, it can copy both structures at
// once. NOTE: The pointer to the parameter table MUST still be present in the
// CCB
//

typedef struct {
    LLC_CCB Ccb;
    LLC_READ_PARMS Parms;
} LLC_READ_COMMAND, *PLLC_READ_COMMAND;

//
// New receive types for direct stations, these types are ignored if the direct
// station was opened with a specific ethernet type
//

#define LLC_DIR_RCV_ALL_TR_FRAMES       0
#define LLC_DIR_RCV_ALL_MAC_FRAMES      1
#define LLC_DIR_RCV_ALL_8022_FRAMES     2
#define LLC_DIR_RCV_ALL_FRAMES          4
#define LLC_DIR_RCV_ALL_ETHERNET_TYPES  5

#define LLC_CONTIGUOUS_MAC      0x80
#define LLC_CONTIGUOUS_DATA     0x40
#define LLC_NOT_CONTIGUOUS_DATA 0x00

//
// LLC_BREAK (0x20) is not supported by Windows/Nt
//

#define LLC_RCV_READ_INDIVIDUAL_FRAMES  0
#define LLC_RCV_CHAIN_FRAMES_ON_LINK    1
#define LLC_RCV_CHAIN_FRAMES_ON_SAP     2

typedef struct {
    USHORT usStationId;             // SAP, link station or direct id
    USHORT usUserLength;            // length of user data in buffer header
    ULONG ulReceiveFlag;            // the received data handler
    PLLC_BUFFER pFirstBuffer;       // first buffer in the pool
    UCHAR uchOptions;               // defines how the frame is received
    UCHAR auchReserved1[3];
    UCHAR uchRcvReadOption;         // defines if rcv frames are chained
} LLC_RECEIVE_PARMS, *PLLC_RECEIVE_PARMS;

#define LLC_CHAIN_XMIT_COMMANDS_ON_LINK 0
#define LLC_COMPLETE_SINGLE_XMIT_FRAME  1
#define LLC_CHAIN_XMIT_COMMANDS_ON_SAP  2

typedef struct {
    USHORT usStationId;             // SAP, link station or direct id
    UCHAR uchTransmitFs;            // token-ring frame status
    UCHAR uchRemoteSap;             // remote destination SAP
    PLLC_XMIT_BUFFER pXmitQueue1;   // first link list of frame segments
    PLLC_XMIT_BUFFER pXmitQueue2;   // another segment list returuned to pool
    USHORT cbBuffer1;               // length of buffer 1
    USHORT cbBuffer2;               // length of buffer 2
    PVOID pBuffer1;                 // yet another segment
    PVOID pBuffer2;                 // this is the last segment of frame
    UCHAR uchXmitReadOption;        // defines completion event for READ
} LLC_TRANSMIT_PARMS,  *PLLC_TRANSMIT_PARMS;

#define LLC_FIRST_DATA_SEGMENT  0x01
#define LLC_NEXT_DATA_SEGMENT   0x02

typedef struct {
    UCHAR eSegmentType;             // defines if first or next segment of frame
    UCHAR boolFreeBuffer;           // if set, this buffer is released to pool
    USHORT cbBuffer;                // length of this buffer
    PVOID pBuffer;
} LLC_TRANSMIT_DESCRIPTOR, *PLLC_TRANSMIT_DESCRIPTOR;

//
// The frames types returned in the first receive buffer or used with the
// TRANSMIT_FRAMES command.  A direct station may also send only ethernet
// frames. The ethernet types are only for transmit. Types 0x0019 - 0x05DC
// are reserved
//

enum _LLC_FRAME_TYPES {                     // Purpose:
    LLC_DIRECT_TRANSMIT         = 0x0000,   // transmit
    LLC_DIRECT_MAC              = 0x0002,   // receive
    LLC_I_FRAME                 = 0x0004,   // receive & transmit
    LLC_UI_FRAME                = 0x0006,   // receive & transmit
    LLC_XID_COMMAND_POLL        = 0x0008,   // receive & transmit
    LLC_XID_COMMAND_NOT_POLL    = 0x000A,   // receive & transmit
    LLC_XID_RESPONSE_FINAL      = 0x000C,   // receive & transmit
    LLC_XID_RESPONSE_NOT_FINAL  = 0x000E,   // receive & transmit
    LLC_TEST_RESPONSE_FINAL     = 0x0010,   // receive & transmit
    LLC_TEST_RESPONSE_NOT_FINAL = 0x0012,   // receive & transmit
    LLC_DIRECT_8022             = 0x0014,   // receive (direct station)
    LLC_TEST_COMMAND_POLL       = 0x0016,   // transmit
    LLC_DIRECT_ETHERNET_TYPE    = 0x0018,   // receive (direct station)
    LLC_LAST_FRAME_TYPE         = 0x001a,   // reserved
    LLC_FIRST_ETHERNET_TYPE     = 0x05DD    // transmit (>)
};

typedef struct {
    LLC_CCB Ccb;                    // use this as transmit CCB
    USHORT usStationId;
    USHORT usFrameType;             // DLC frame or ethernet type
    UCHAR uchRemoteSap;             // used with UI, TEST, XID frames
    UCHAR uchXmitReadOption;
    UCHAR Reserved2[2];
    ULONG cXmitBufferCount;
    LLC_TRANSMIT_DESCRIPTOR aXmitBuffer[1];
} LLC_TRANSMIT2_COMMAND, *PLLC_TRANSMIT2_COMMAND;

//
// LLC_TRANSMIT2_VAR_PARMS - this macro allocates space for variable length
// descriptor array, eg: LLC_TRANSMIT2_VAR_PARMS(8) TransmitParms;
//

#define LLC_TRANSMIT2_VAR_PARMS(a)\
struct {\
    LLC_CCB Ccb;\
    USHORT usStationId;\
    USHORT usFrameType;\
    UCHAR uchRemoteSap;\
    UCHAR uchXmitReadOption;\
    UCHAR uchReserved2[2];\
    ULONG cXmitBufferCount;\
    LLC_TRANSMIT_DESCRIPTOR XmitBuffer[(a)];\
}

//
// LLC_PARMS - All CCB parameter tables can be referred to using this union
//

union _LLC_PARMS {
    LLC_BUFFER_FREE_PARMS BufferFree;
    LLC_BUFFER_GET_PARMS BufferGet;
    LLC_DLC_CONNECT_PARMS DlcConnectStation;
    LLC_DLC_MODIFY_PARMS DlcModify;
    LLC_DLC_OPEN_SAP_PARMS DlcOpenSap;
    LLC_DLC_OPEN_STATION_PARMS DlcOpenStation;
    LLC_DLC_REALLOCATE_PARMS DlcReallocate;
    LLC_DLC_SET_THRESHOLD_PARMS DlcSetThreshold;
    LLC_DLC_STATISTICS_PARMS DlcStatistics;
    LLC_DIR_INITIALIZE_PARMS DirInitialize;
    LLC_DIR_OPEN_ADAPTER_PARMS DirOpenAdapter;
    LLC_DIR_OPEN_DIRECT_PARMS DirOpenDirect;
    LLC_DIR_READ_LOG_PARMS DirReadLog;
    LLC_DIR_SET_EFLAG_PARMS DirSetEventFlag;
    LLC_DIR_STATUS_PARMS DirStatus;
    LLC_READ_PARMS Read;
    LLC_RECEIVE_PARMS Receive;
    LLC_TRANSMIT_PARMS Transmit;
    LLC_TRANSMIT2_COMMAND Transmit2;
    LLC_TRACE_INITIALIZE_PARMS TraceInitialize;
};

//
// LLC_STATUS - enumerates the return codes which appear in the CCB uchDlcStatus
// field
//

typedef enum _LLC_STATUS {
    LLC_STATUS_SUCCESS                      = 0x00,
    LLC_STATUS_INVALID_COMMAND              = 0x01,
    LLC_STATUS_DUPLICATE_COMMAND            = 0x02,
    LLC_STATUS_ADAPTER_OPEN                 = 0x03,
    LLC_STATUS_ADAPTER_CLOSED               = 0x04,
    LLC_STATUS_PARAMETER_MISSING            = 0x05,
    LLC_STATUS_INVALID_OPTION               = 0x06,
    LLC_STATUS_COMMAND_CANCELLED_FAILURE    = 0x07,
    LLC_STATUS_ACCESS_DENIED                = 0x08,   // not used in Windows/Nt
    LLC_STATUS_ADAPTER_NOT_INITIALIZED      = 0x09,   // not used in Windows/Nt
    LLC_STATUS_CANCELLED_BY_USER            = 0x0A,
    LLC_STATUS_COMMAND_CANCELLED_CLOSED     = 0x0B,   // not used in Windows/Nt
    LLC_STATUS_SUCCESS_NOT_OPEN             = 0x0C,
    LLC_STATUS_TIMER_ERROR                  = 0x11,
    LLC_STATUS_NO_MEMORY                    = 0x12,
    LLC_STATUS_INVALID_LOG_ID               = 0x13,   // not used in Windows/Nt
    LLC_STATUS_LOST_LOG_DATA                = 0x15,
    LLC_STATUS_BUFFER_SIZE_EXCEEDED         = 0x16,
    LLC_STATUS_INVALID_BUFFER_LENGTH        = 0x18,
    LLC_STATUS_INADEQUATE_BUFFERS           = 0x19,
    LLC_STATUS_USER_LENGTH_TOO_LARGE        = 0x1A,
    LLC_STATUS_INVALID_PARAMETER_TABLE      = 0x1B,
    LLC_STATUS_INVALID_POINTER_IN_CCB       = 0x1C,
    LLC_STATUS_INVALID_ADAPTER              = 0x1D,
    LLC_STATUS_LOST_DATA_NO_BUFFERS         = 0x20,
    LLC_STATUS_LOST_DATA_INADEQUATE_SPACE   = 0x21,
    LLC_STATUS_TRANSMIT_ERROR_FS            = 0x22,
    LLC_STATUS_TRANSMIT_ERROR               = 0x23,
    LLC_STATUS_UNAUTHORIZED_MAC             = 0x24,   // not used in Windows/Nt
    LLC_STATUS_MAX_COMMANDS_EXCEEDED        = 0x25,   // not used in Windows/Nt
    LLC_STATUS_LINK_NOT_TRANSMITTING        = 0x27,
    LLC_STATUS_INVALID_FRAME_LENGTH         = 0x28,
    LLC_STATUS_INADEQUATE_RECEIVE           = 0x30,   // not used in Windows/Nt
    LLC_STATUS_INVALID_NODE_ADDRESS         = 0x32,
    LLC_STATUS_INVALID_RCV_BUFFER_LENGTH    = 0x33,
    LLC_STATUS_INVALID_XMIT_BUFFER_LENGTH   = 0x34,
    LLC_STATUS_INVALID_STATION_ID           = 0x40,
    LLC_STATUS_LINK_PROTOCOL_ERROR          = 0x41,
    LLC_STATUS_PARMETERS_EXCEEDED_MAX       = 0x42,
    LLC_STATUS_INVALID_SAP_VALUE            = 0x43,
    LLC_STATUS_INVALID_ROUTING_INFO         = 0x44,
    LLC_STATUS_RESOURCES_NOT_AVAILABLE      = 0x46,   // not used in Windows/Nt
    LLC_STATUS_LINK_STATIONS_OPEN           = 0x47,
    LLC_STATUS_INCOMPATIBLE_COMMANDS        = 0x4A,
    LLC_STATUS_OUTSTANDING_COMMANDS         = 0x4C,   // not used in Windows/Nt
    LLC_STATUS_CONNECT_FAILED               = 0x4D,
    LLC_STATUS_INVALID_REMOTE_ADDRESS       = 0x4F,
    LLC_STATUS_CCB_POINTER_FIELD            = 0x50,
    LLC_STATUS_INVALID_APPLICATION_ID       = 0x52,   // not used in Windows/Nt
    LLC_STATUS_NO_SYSTEM_PROCESS            = 0x56,   // not used in Windows/Nt
    LLC_STATUS_INADEQUATE_LINKS             = 0x57,
    LLC_STATUS_INVALID_PARAMETER_1          = 0x58,
    LLC_STATUS_DIRECT_STATIONS_NOT_ASSIGNED = 0x5C,
    LLC_STATUS_DEVICE_DRIVER_NOT_INSTALLED  = 0x5d,
    LLC_STATUS_ADAPTER_NOT_INSTALLED        = 0x5e,
    LLC_STATUS_CHAINED_DIFFERENT_ADAPTERS   = 0x5f,
    LLC_STATUS_INIT_COMMAND_STARTED         = 0x60,
    LLC_STATUS_TOO_MANY_USERS               = 0x61,   // not used in Windows/Nt
    LLC_STATUS_CANCELLED_BY_SYSTEM_ACTION   = 0x62,
    LLC_STATUS_DIR_STATIONS_NOT_AVAILABLE   = 0x63,   // not used in Windows/Nt
    LLC_STATUS_NO_GDT_SELECTORS             = 0x65,
    LLC_STATUS_MEMORY_LOCK_FAILED           = 0x69,

    //
    // New NT DLC specific error codes begin from 0x80
    // These error codes are for new Windows/Nt DLC apps.
    //

    LLC_STATUS_INVALID_BUFFER_ADDRESS       = 0x80,
    LLC_STATUS_BUFFER_ALREADY_RELEASED      = 0x81,
    LLC_STATUS_BIND_ERROR                   = 0xA0,   // not used in Windows/Nt
    LLC_STATUS_INVALID_VERSION              = 0xA1,
    LLC_STATUS_NT_ERROR_STATUS              = 0xA2,
    LLC_STATUS_PENDING                      = 0xFF
} LLC_STATUS;

#define LLC_STATUS_MAX_ERROR 0xFF

//
// ACSLAN_STATUS - status codes which are returned from AcsLan
//

typedef enum {
    ACSLAN_STATUS_COMMAND_ACCEPTED = 0,
    ACSLAN_STATUS_INVALID_CCB_POINTER = 1,
    ACSLAN_STATUS_CCB_IN_ERROR = 2,
    ACSLAN_STATUS_CHAINED_CCB_IN_ERROR = 3,
    ACSLAN_STATUS_SYSTEM_ERROR = 4,
    ACSLAN_STATUS_SYSTEM_STATUS = 5,
    ACSLAN_STATUS_INVALID_COMMAND = 6
} ACSLAN_STATUS;

//
// prototypes
//

ACSLAN_STATUS
APIENTRY
AcsLan(
    IN OUT PLLC_CCB pCcb,
    OUT PLLC_CCB* ppBadCcb
    );

LLC_STATUS
APIENTRY
GetAdapterNameFromNumber(
    IN UINT AdapterNumber,
    OUT LPTSTR pNdisName
    );

LLC_STATUS
APIENTRY
GetAdapterNumberFromName(
    IN LPTSTR pNdisName,
    OUT UINT *AdapterNumber
    );

#ifdef __cplusplus
}
#endif

#endif // _DLCAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\evntrace.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    EvnTrace.h

Abstract:

    Public headers for event tracing control applications,
    consumers and providers

--*/

#ifndef _EVNTRACE_
#define _EVNTRACE_

#if defined(_WINNT_) || defined(WINNT)
#ifndef WMIAPI
#ifndef MIDL_PASS
#ifdef _WMI_SOURCE_
#define WMIAPI __stdcall
#else
#define WMIAPI DECLSPEC_IMPORT __stdcall
#endif // _WMI_SOURCE
#endif // MIDL_PASS

#endif // WMIAPI

#include <guiddef.h>

//
// EventTraceGuid is used to identify a event tracing session
//
DEFINE_GUID ( /* 68fdd900-4a3e-11d1-84f4-0000f80464e3 */
    EventTraceGuid,
    0x68fdd900,
    0x4a3e,
    0x11d1,
    0x84, 0xf4, 0x00, 0x00, 0xf8, 0x04, 0x64, 0xe3
  );

//
// SystemTraceControlGuid. Used to specify event tracing for kernel
//
DEFINE_GUID ( /* 9e814aad-3204-11d2-9a82-006008a86939 */
    SystemTraceControlGuid,
    0x9e814aad,
    0x3204,
    0x11d2,
    0x9a, 0x82, 0x00, 0x60, 0x08, 0xa8, 0x69, 0x39
  );

//
//EventTraceConfigGuid. Used to report hardware configuration records
//

DEFINE_GUID ( /* 01853a65-418f-4f36-aefc-dc0f1d2fd235 */
    EventTraceConfigGuid,
    0x01853a65,
    0x418f,
    0x4f36,
    0xae, 0xfc, 0xdc, 0x0f, 0x1d, 0x2f, 0xd2, 0x35
  );


#define MAX_MOF_FIELDS                      16  // Limit of USE_MOF_PTR fields
typedef ULONG64 TRACEHANDLE, *PTRACEHANDLE;

typedef struct _TRACE_ENABLE_CONTEXT {
    USHORT  LoggerId;           // Actual Id of the logger
    UCHAR   Level;              // Enable level passed by control caller
    UCHAR   InternalFlag;       // Reserved
    ULONG   EnableFlags;        // Enable flags passed by control caller
} TRACE_ENABLE_CONTEXT, *PTRACE_ENABLE_CONTEXT;

//
// predefined generic event types (0x00 to 0x09 reserved).
//

#define EVENT_TRACE_TYPE_INFO               0x00  // Info or point event
#define EVENT_TRACE_TYPE_START              0x01  // Start event
#define EVENT_TRACE_TYPE_END                0x02  // End event
#define EVENT_TRACE_TYPE_DC_START           0x03  // Collection start marker
#define EVENT_TRACE_TYPE_DC_END             0x04  // Collection end marker
#define EVENT_TRACE_TYPE_EXTENSION          0x05  // Extension/continuation
#define EVENT_TRACE_TYPE_REPLY              0x06  // Reply event
#define EVENT_TRACE_TYPE_DEQUEUE            0x07  // De-queue event
#define EVENT_TRACE_TYPE_CHECKPOINT         0x08  // Generic checkpoint event
#define EVENT_TRACE_TYPE_RESERVED9          0x09

//
// Event types for Process & Threads
//

#define EVENT_TRACE_TYPE_LOAD                  0x0A      // Load image

//
// Event types for IO subsystem
//

#define EVENT_TRACE_TYPE_IO_READ               0x0A
#define EVENT_TRACE_TYPE_IO_WRITE              0x0B

//
// Event types for Memory subsystem
//

#define EVENT_TRACE_TYPE_MM_TF                 0x0A      // Transition fault
#define EVENT_TRACE_TYPE_MM_DZF                0x0B      // Demand Zero fault
#define EVENT_TRACE_TYPE_MM_COW                0x0C      // Copy on Write
#define EVENT_TRACE_TYPE_MM_GPF                0x0D      // Guard Page fault
#define EVENT_TRACE_TYPE_MM_HPF                0x0E      // Hard page fault

//
// Event types for Network subsystem, all protocols
//

#define EVENT_TRACE_TYPE_SEND                  0x0A     // Send
#define EVENT_TRACE_TYPE_RECEIVE               0x0B     // Receive
#define EVENT_TRACE_TYPE_CONNECT               0x0C     // Connect
#define EVENT_TRACE_TYPE_DISCONNECT            0x0D     // Disconnect
#define EVENT_TRACE_TYPE_RETRANSMIT            0x0E     // ReTransmit
#define EVENT_TRACE_TYPE_ACCEPT                0x0F     // Accept


//
// Event Types for the Header (to handle internal event headers)
//

#define EVENT_TRACE_TYPE_GUIDMAP                0x0A
#define EVENT_TRACE_TYPE_CONFIG                 0x0B
#define EVENT_TRACE_TYPE_SIDINFO                0x0C
#define EVENT_TRACE_TYPE_SECURITY               0x0D

//
// Event types for Registry subsystem
//

#define EVENT_TRACE_TYPE_REGCREATE              0x0A     // NtCreateKey
#define EVENT_TRACE_TYPE_REGOPEN                0x0B     // NtOpenKey
#define EVENT_TRACE_TYPE_REGDELETE              0x0C     // NtDeleteKey
#define EVENT_TRACE_TYPE_REGQUERY               0x0D     // NtQueryKey
#define EVENT_TRACE_TYPE_REGSETVALUE            0x0E     // NtSetValueKey
#define EVENT_TRACE_TYPE_REGDELETEVALUE         0x0F     // NtDeleteValueKey
#define EVENT_TRACE_TYPE_REGQUERYVALUE          0x10     // NtQueryValueKey
#define EVENT_TRACE_TYPE_REGENUMERATEKEY        0x11     // NtEnumerateKey
#define EVENT_TRACE_TYPE_REGENUMERATEVALUEKEY   0x12     // NtEnumerateValueKey
#define EVENT_TRACE_TYPE_REGQUERYMULTIPLEVALUE  0x13     // NtQueryMultipleValueKey
#define EVENT_TRACE_TYPE_REGSETINFORMATION      0x14     // NtSetInformationKey
#define EVENT_TRACE_TYPE_REGFLUSH               0x15     // NtFlushKey
#define EVENT_TRACE_TYPE_REGKCBDMP              0x16     // KcbDump/create

//
// Event types for hardware configuration records
//
#define EVENT_TRACE_TYPE_CONFIG_CPU             0x0A     // CPU Configuration
#define EVENT_TRACE_TYPE_CONFIG_PHYSICALDISK    0x0B     // Physical Disk Configuration
#define EVENT_TRACE_TYPE_CONFIG_LOGICALDISK     0x0C     // Logical Disk Configuration
#define EVENT_TRACE_TYPE_CONFIG_NIC             0x0D     // NIC Configuration
#define EVENT_TRACE_TYPE_CONFIG_VIDEO           0x0E     // Video Adapter Configuration

//
// Enable flags for SystemControlGuid only
//
#define EVENT_TRACE_FLAG_PROCESS            0x00000001  // process start & end
#define EVENT_TRACE_FLAG_THREAD             0x00000002  // thread start & end
#define EVENT_TRACE_FLAG_IMAGE_LOAD         0x00000004  // image load

#define EVENT_TRACE_FLAG_DISK_IO            0x00000100  // physical disk IO
#define EVENT_TRACE_FLAG_DISK_FILE_IO       0x00000200  // requires disk IO

#define EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS 0x00001000  // all page faults
#define EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS 0x00002000  // hard faults only

#define EVENT_TRACE_FLAG_NETWORK_TCPIP      0x00010000  // tcpip send & receive

#define EVENT_TRACE_FLAG_REGISTRY           0x00020000  // registry calls
#define EVENT_TRACE_FLAG_DBGPRINT           0x00040000  // DbgPrint(ex) Calls
//
// Pre-defined Enable flags for everybody else
//
#define EVENT_TRACE_FLAG_EXTENSION          0x80000000  // indicates more flags
#define EVENT_TRACE_FLAG_FORWARD_WMI        0x40000000  // Can forward to WMI
#define EVENT_TRACE_FLAG_ENABLE_RESERVE     0x20000000  // Reserved

//
// Logger Mode flags
//

#define EVENT_TRACE_FILE_MODE_NONE          0x00000000  // logfile is off
#define EVENT_TRACE_FILE_MODE_SEQUENTIAL    0x00000001  // log sequentially
#define EVENT_TRACE_FILE_MODE_CIRCULAR      0x00000002  // log in circular manner
#define EVENT_TRACE_FILE_MODE_APPEND        0x00000004  // append sequential log
#define EVENT_TRACE_FILE_MODE_NEWFILE       0x00000008  // auto-switch log file

#define EVENT_TRACE_REAL_TIME_MODE          0x00000100  // real time mode on
#define EVENT_TRACE_DELAY_OPEN_FILE_MODE    0x00000200  // delay opening file
#define EVENT_TRACE_BUFFERING_MODE          0x00000400  // buffering mode only
#define EVENT_TRACE_PRIVATE_LOGGER_MODE     0x00000800  // Process Private Logger
#define EVENT_TRACE_ADD_HEADER_MODE         0x00001000  // Add a logfile header
#define EVENT_TRACE_USE_GLOBAL_SEQUENCE     0x00004000  // Use global sequence no.
#define EVENT_TRACE_USE_LOCAL_SEQUENCE      0x00008000  // Use local sequence no.

//
// internal control codes used.
//
#define EVENT_TRACE_CONTROL_QUERY           0
#define EVENT_TRACE_CONTROL_STOP            1
#define EVENT_TRACE_CONTROL_UPDATE          2
#define EVENT_TRACE_CONTROL_FLUSH           3       // Flushes all the buffers

//
// Flags used by WMI Trace Message
// Note that the order or value of these flags should NOT be changed as they are processed
// in this order.
//
#define TRACE_MESSAGE_SEQUENCE		1           // Message should include a sequence number
#define TRACE_MESSAGE_GUID			2           // Message includes a GUID
#define TRACE_MESSAGE_COMPONENTID   4           // Message has no GUID, Component ID instead
#define	TRACE_MESSAGE_TIMESTAMP		8           // Message includes a timestamp
#define TRACE_MESSAGE_PERFORMANCE_TIMESTAMP 16  // Timestamp is the Performance Counter not the system clock
#define	TRACE_MESSAGE_SYSTEMINFO	32          // Message includes system information TID,PID
#define TRACE_MESSAGE_FLAG_MASK     0xFFFF      // Only the lower 16 bits of flags are placed in the message
                                                // those above 16 bits are reserved for local processing



#pragma warning (disable:4201)
//
// Trace header for all (except kernel) events. This is used to overlay
// to bottom part of WNODE_HEADER to conserve space.
//

typedef struct _EVENT_TRACE_HEADER {    // overlays WNODE_HEADER
    USHORT          Size;                   // Size of entire record
    UCHAR           HeaderType;             // Header type - internal use only
    UCHAR           MarkerFlags;            // Marker - internal use only
    union {
        ULONG       Version;
        struct {
            UCHAR   Type;                   // event type
            UCHAR   Level;                  // trace instrumentation level
            USHORT  Version;                // version of trace record
        } Class;
    };
    ULONG           ThreadId;               // Thread Id
    ULONG           ProcessId;              // Process Id
    LARGE_INTEGER   TimeStamp;              // time when event happens
    union {
        GUID        Guid;                   // Guid that identifies event
        ULONGLONG   GuidPtr;                // use with WNODE_FLAG_USE_GUID_PTR
    };
    union {
        struct {
            ULONG   ClientContext;          // Reserved
            ULONG   Flags;                  // Flags for header
        };
        struct {
            ULONG   KernelTime;             // Kernel Mode CPU ticks
            ULONG   UserTime;               // User mode CPU ticks
        };
        ULONG64     ProcessorTime;          // Processor Clock
    };
} EVENT_TRACE_HEADER, *PEVENT_TRACE_HEADER;

//
// This header is used to trace and track transaction co-relations
//
typedef struct _EVENT_INSTANCE_HEADER {
    USHORT          Size;
    UCHAR           HeaderType;
    UCHAR           MarkerFlags;
    union {
        ULONG       Version;
        struct {
            UCHAR   Type;
            UCHAR   Level;
            USHORT  Version;
        } Class;
    };
    ULONG           ThreadId;
    ULONG           ProcessId;
    LARGE_INTEGER   TimeStamp;
    ULONGLONG       RegHandle;
    ULONG           InstanceId;
    ULONG           ParentInstanceId;
    union {
        struct {
            ULONG   ClientContext;          // Reserved
            ULONG   Flags;                  // Flags for header
        };
        struct {
            ULONG   KernelTime;             // Kernel Mode CPU ticks
            ULONG   UserTime;               // User mode CPU ticks
        };
        ULONG64     ProcessorTime;          // Processor Clock
    };
    ULONGLONG       ParentRegHandle;
} EVENT_INSTANCE_HEADER, *PEVENT_INSTANCE_HEADER;

//
// Following are structures and macros for use with USE_MOF_PTR
//

#define DEFINE_TRACE_MOF_FIELD(MOF, ptr, length, type) \
    (MOF)->DataPtr  = (ULONG64) ptr; \
    (MOF)->Length   = (ULONG) length; \
    (MOF)->DataType = (ULONG) type;

typedef struct _MOF_FIELD {
    ULONG64     DataPtr;    // Pointer to the field. Up to 64-bits only
    ULONG       Length;     // Length of the MOF field
    ULONG       DataType;   // Type of data
} MOF_FIELD, *PMOF_FIELD;

#if !defined(_NTDDK_) || defined(_WMIKM_)
//
// This is the header for every logfile. The memory for LoggerName
// and LogFileName must be contiguous adjacent to this structure
// Allows both user-mode and kernel-mode to understand the header
//
typedef struct _TRACE_LOGFILE_HEADER {
    ULONG           BufferSize;         // Logger buffer size in Kbytes
    union {
        ULONG       Version;            // Logger version
        struct {
            UCHAR   MajorVersion;
            UCHAR   MinorVersion;
            UCHAR   SubVersion;
            UCHAR   SubMinorVersion;
        } VersionDetail;
    };
    ULONG           ProviderVersion;    // defaults to NT version
    ULONG           NumberOfProcessors; // Number of Processors
    LARGE_INTEGER   EndTime;            // Time when logger stops
    ULONG           TimerResolution;    // assumes timer is constant!!!
    ULONG           MaximumFileSize;    // Maximum in Mbytes
    ULONG           LogFileMode;        // specify logfile mode
    ULONG           BuffersWritten;     // used to file start of Circular File
    union {
        GUID LogInstanceGuid;           // For RealTime Buffer Delivery
        struct {
            ULONG   StartBuffers;       // Count of buffers written at start.
            ULONG   PointerSize;        // Size of pointer type in bits
            ULONG   EventsLost;         // Events losts during log session
            ULONG   Reserved32;         // Reserved 32bits
        };
    };
#if defined(_WMIKM_)
    PWCHAR          LoggerName;
    PWCHAR          LogFileName;
    RTL_TIME_ZONE_INFORMATION TimeZone;
#else
    LPWSTR          LoggerName;
    LPWSTR          LogFileName;
    TIME_ZONE_INFORMATION TimeZone;
#endif
    LARGE_INTEGER   BootTime;
    LARGE_INTEGER   PerfFreq;           // Reserved
    LARGE_INTEGER   StartTime;          // Reserved
    ULONG           ReservedFlags;      // Reserved
    ULONG           BuffersLost;
} TRACE_LOGFILE_HEADER, *PTRACE_LOGFILE_HEADER;

#endif // !_NTDDK_ || _WMIKM_


//
// Instance Information to track parent child relationship of Instances.
//
typedef struct EVENT_INSTANCE_INFO {
    HANDLE      RegHandle;
    ULONG       InstanceId;
} EVENT_INSTANCE_INFO, *PEVENT_INSTANCE_INFO;

#if !defined(_WMIKM_) && !defined(_NTDDK_)
//
// Structures that have UNICODE and ANSI versions are defined here
//

//
// Logger configuration and running statistics. This structure is used
// by user-mode callers, such as PDH library
//

typedef struct _EVENT_TRACE_PROPERTIES {
    WNODE_HEADER Wnode;
//
// data provided by caller
    ULONG BufferSize;                   // buffer size for logging (kbytes)
    ULONG MinimumBuffers;               // minimum to preallocate
    ULONG MaximumBuffers;               // maximum buffers allowed
    ULONG MaximumFileSize;              // maximum logfile size (in MBytes)
    ULONG LogFileMode;                  // sequential, circular
    ULONG FlushTimer;                   // buffer flush timer, in seconds
    ULONG EnableFlags;                  // trace enable flags
    LONG  AgeLimit;                     // age decay time, in minutes

// data returned to caller
    ULONG NumberOfBuffers;              // no of buffers in use
    ULONG FreeBuffers;                  // no of buffers free
    ULONG EventsLost;                   // event records lost
    ULONG BuffersWritten;               // no of buffers written to file
    ULONG LogBuffersLost;               // no of logfile write failures
    ULONG RealTimeBuffersLost;          // no of rt delivery failures
    HANDLE LoggerThreadId;              // thread id of Logger
    ULONG LogFileNameOffset;            // Offset to LogFileName
    ULONG LoggerNameOffset;             // Offset to LoggerName
} EVENT_TRACE_PROPERTIES, *PEVENT_TRACE_PROPERTIES;

// NOTE:
// If AgeLimit is 0, default is used
// If AgeLimit is < 0, buffer aging is turned off

typedef struct _TRACE_GUID_PROPERTIES {
    GUID    Guid;
    ULONG   GuidType;
    ULONG   LoggerId;
    ULONG   EnableLevel;
    ULONG   EnableFlags;
    BOOLEAN     IsEnable;
} TRACE_GUID_PROPERTIES, *PTRACE_GUID_PROPERTIES;


//
// Data Provider structures
//
// Used by RegisterTraceGuids()

typedef struct  _TRACE_GUID_REGISTRATION {
    LPCGUID Guid;           // Guid of data block being registered or updated.
    HANDLE RegHandle;      // Guid Registration Handle is returned.
} TRACE_GUID_REGISTRATION, *PTRACE_GUID_REGISTRATION;

//
// Data consumer structures
//

// An EVENT_TRACE consists of a fixed header (EVENT_TRACE_HEADER) and
// optionally a variable portion pointed to by MofData. The datablock
// layout of the variable portion is unknown to the Logger and must
// be obtained from WBEM CIMOM database.
//
typedef struct _EVENT_TRACE {
    EVENT_TRACE_HEADER      Header;             // Event trace header
    ULONG                   InstanceId;         // Instance Id of this event
    ULONG                   ParentInstanceId;   // Parent Instance Id.
    GUID                    ParentGuid;         // Parent Guid;
    PVOID                   MofData;            // Pointer to Variable Data
    ULONG                   MofLength;          // Variable Datablock Length
    ULONG                   ClientContext;      // Reserved
} EVENT_TRACE, *PEVENT_TRACE;


typedef struct _EVENT_TRACE_LOGFILEW
                EVENT_TRACE_LOGFILEW, *PEVENT_TRACE_LOGFILEW;

typedef struct _EVENT_TRACE_LOGFILEA
                EVENT_TRACE_LOGFILEA, *PEVENT_TRACE_LOGFILEA;

typedef ULONG (WINAPI * PEVENT_TRACE_BUFFER_CALLBACKW)
                (PEVENT_TRACE_LOGFILEW Logfile);

typedef ULONG (WINAPI * PEVENT_TRACE_BUFFER_CALLBACKA)
                (PEVENT_TRACE_LOGFILEA Logfile);

typedef VOID (WINAPI *PEVENT_CALLBACK)( PEVENT_TRACE pEvent );

//
// Prototype for service request callback. Data providers register with WMI
// by passing a service request callback function that is called for all
// wmi requests.

typedef ULONG (
#ifndef MIDL_PASS
WINAPI
#endif
*WMIDPREQUEST)(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *BufferSize,
    IN OUT PVOID Buffer
    );


struct _EVENT_TRACE_LOGFILEW {
    LPWSTR                  LogFileName;    // Logfile Name
    LPWSTR                  LoggerName;     // LoggerName
    LONGLONG                CurrentTime;    // timestamp of last event
    ULONG                   BuffersRead;    // buffers read to date
    ULONG                   LogFileMode;    // Mode of the logfile

    EVENT_TRACE             CurrentEvent;   // Current Event from this stream.
    TRACE_LOGFILE_HEADER    LogfileHeader;  // logfile header structure
    PEVENT_TRACE_BUFFER_CALLBACKW           // callback before each buffer
                            BufferCallback; // is read
    //
    // following variables are filled for BufferCallback.
    //
    ULONG                   BufferSize;
    ULONG                   Filled;
    ULONG                   EventsLost;
    //
    // following needs to be propaged to each buffer
    //

    PEVENT_CALLBACK         EventCallback;  // callback for every event
    ULONG                   IsKernelTrace;  // TRUE for kernel logfile

    PVOID                   Context;        // reserved for internal use
};

struct _EVENT_TRACE_LOGFILEA {
    LPSTR                   LogFileName;    // Logfile Name
    LPSTR                   LoggerName;     // LoggerName
    LONGLONG                CurrentTime;    // timestamp of last event
    ULONG                   BuffersRead;    // buffers read to date
    ULONG                   LogFileMode;    // LogFile Mode.

    EVENT_TRACE             CurrentEvent;   // Current Event from this stream
    TRACE_LOGFILE_HEADER    LogfileHeader;  // logfile header structure
    PEVENT_TRACE_BUFFER_CALLBACKA           // callback before each buffer
                            BufferCallback; // is read

    //
    // following variables are filled for BufferCallback.
    //
    ULONG                   BufferSize;
    ULONG                   Filled;
    ULONG                   EventsLost;
    //
    // following needs to be propaged to each buffer
    //

    PEVENT_CALLBACK         EventCallback;  // callback for every event
    ULONG                   IsKernelTrace;  // TRUE for kernel logfile

    PVOID                   Context;        // reserved for internal use
};

//
// Define generic structures
//

#if defined(_UNICODE) || defined(UNICODE)
#define PEVENT_TRACE_BUFFER_CALLBACK    PEVENT_TRACE_BUFFER_CALLBACKW
#define EVENT_TRACE_LOGFILE             EVENT_TRACE_LOGFILEW
#define PEVENT_TRACE_LOGFILE            PEVENT_TRACE_LOGFILEW

#else

#define PEVENT_TRACE_BUFFER_CALLBACK    PEVENT_TRACE_BUFFER_CALLBACKA
#define EVENT_TRACE_LOGFILE             EVENT_TRACE_LOGFILEA
#define PEVENT_TRACE_LOGFILE            PEVENT_TRACE_LOGFILEA

#endif

#pragma warning (default:4201)

#ifdef __cplusplus
extern "C" {
#endif


//
// Logger control APIs
//

//
// Use the routine below to start an event trace session
//

// ULONG
// StartTrace(
//      OUT PTRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );


EXTERN_C
ULONG
WMIAPI
StartTraceW(
    OUT PTRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
StartTraceA(
    OUT PTRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

//
// Use the routine below to stop an event trace session
//

//
// ULONG
// StopTrace(
//      IN TRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

EXTERN_C
ULONG
WMIAPI
StopTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
StopTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );


//
// Use the routine below to query the properties of an event trace session
//

// ULONG
// QueryTrace(
//      IN TRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

EXTERN_C
ULONG
WMIAPI
QueryTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
QueryTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

//
// Use the routine below to update certain properties of an event trace session
//

// ULONG
// UpdateTrace(
//      IN (PTRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

EXTERN_C
ULONG
WMIAPI
UpdateTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
UpdateTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

//
// Use the routine below to request that all active buffers an event trace
// session be "flushed", or written out.
//

// ULONG
// FlushTrace(
//      IN TRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

EXTERN_C
ULONG
WMIAPI
FlushTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
FlushTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

//
// Generic trace control routine
//
EXTERN_C
ULONG
WMIAPI
ControlTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG ControlCode
    );

EXTERN_C
ULONG
WMIAPI
ControlTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG ControlCode
    );

//
// ULONG
// QueryAllTraces(
//  OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
//  IN ULONG PropertyArrayCount,
//  OUT PULONG LoggerCount
//  );
//

EXTERN_C
ULONG
WMIAPI
QueryAllTracesW(
    OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
    IN ULONG PropertyArrayCount,
    OUT PULONG LoggerCount
    );

EXTERN_C
ULONG
WMIAPI
QueryAllTracesA(
    OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
    IN ULONG PropertyArrayCount,
    OUT PULONG LoggerCount
    );


//
// Data Provider APIs
//

EXTERN_C
ULONG
WMIAPI
CreateTraceInstanceId(
    IN HANDLE RegHandle,
    IN OUT PEVENT_INSTANCE_INFO pInstInfo
    );

EXTERN_C
ULONG
WMIAPI
EnableTrace(
    IN ULONG Enable,
    IN ULONG EnableFlag,
    IN ULONG EnableLevel,
    IN LPCGUID ControlGuid,
    IN TRACEHANDLE TraceHandle
    );

//
// Use the routine below to generate and record an event trace
//


EXTERN_C
ULONG
WMIAPI
TraceEvent(
    IN TRACEHANDLE  TraceHandle,
    IN PEVENT_TRACE_HEADER EventTrace
    );

EXTERN_C
ULONG
WMIAPI
TraceEventInstance(
    IN TRACEHANDLE TraceHandle,
    IN PEVENT_INSTANCE_HEADER EventTrace,
    IN PEVENT_INSTANCE_INFO pInstInfo,
    IN PEVENT_INSTANCE_INFO pParentInstInfo
    );

//
// Use the routine below to register a guid for tracing
//

//
// ULONG
// RegisterTraceGuids(
//  IN WMIDPREQUEST  RequestAddress,
//  IN PVOID         RequestContext,
//  IN LPCGUID       ControlGuid,
//  IN ULONG         GuidCount,
//  IN PTRACE_GUID_REGISTRATION TraceGuidReg,
//  IN LPCTSTR       MofImagePath,
//  IN LPCTSTR       MofResourceName,
//  OUT PTRACEHANDLE RegistrationHandle
//  );
//

EXTERN_C
ULONG
WMIAPI
RegisterTraceGuidsW(
    IN WMIDPREQUEST  RequestAddress,
    IN PVOID         RequestContext,
    IN LPCGUID       ControlGuid,
    IN ULONG         GuidCount,
    IN PTRACE_GUID_REGISTRATION TraceGuidReg,
    IN LPCWSTR       MofImagePath,
    IN LPCWSTR       MofResourceName,
    OUT PTRACEHANDLE RegistrationHandle
    );

EXTERN_C
ULONG
WMIAPI
RegisterTraceGuidsA(
    IN WMIDPREQUEST  RequestAddress,
    IN PVOID         RequestContext,
    IN LPCGUID       ControlGuid,
    IN ULONG         GuidCount,
    IN PTRACE_GUID_REGISTRATION TraceGuidReg,
    IN LPCSTR        MofImagePath,
    IN LPCSTR        MofResourceName,
    OUT PTRACEHANDLE RegistrationHandle
    );

EXTERN_C
ULONG
WMIAPI
EnumerateTraceGuids(
    IN OUT PTRACE_GUID_PROPERTIES *GuidPropertiesArray,
    IN ULONG PropertyArrayCount,
    OUT PULONG GuidCount
    );

EXTERN_C
ULONG
WMIAPI
UnregisterTraceGuids(
    IN TRACEHANDLE RegistrationHandle
    );

EXTERN_C
TRACEHANDLE
WMIAPI
GetTraceLoggerHandle(
    IN PVOID Buffer
    );

EXTERN_C
UCHAR
WMIAPI
GetTraceEnableLevel(
    IN TRACEHANDLE TraceHandle
    );

EXTERN_C
ULONG
WMIAPI
GetTraceEnableFlags(
    IN TRACEHANDLE TraceHandle
    );

//
// Data Consumer APIs and structures start here
//

//
// TRACEHANDLE
// OpenTrace(
//  IN OUT PEVENT_TRACE_LOGFILE Logfile
//  );
//

EXTERN_C
TRACEHANDLE
WMIAPI
OpenTraceA(
    IN OUT PEVENT_TRACE_LOGFILEA Logfile
    );

EXTERN_C
TRACEHANDLE
WMIAPI
OpenTraceW(
    IN OUT PEVENT_TRACE_LOGFILEW Logfile
    );

EXTERN_C
ULONG
WMIAPI
ProcessTrace(
    IN PTRACEHANDLE HandleArray,
    IN ULONG HandleCount,
    IN LPFILETIME StartTime,
    IN LPFILETIME EndTime
    );

EXTERN_C
ULONG
WMIAPI
CloseTrace(
    IN TRACEHANDLE TraceHandle
    );

EXTERN_C
ULONG
WMIAPI
SetTraceCallback(
    IN LPCGUID pGuid,
    IN PEVENT_CALLBACK EventCallback
    );

EXTERN_C
ULONG
WMIAPI
RemoveTraceCallback (
    IN LPCGUID pGuid
    );

// The routines for tracing Messages follow
//
EXTERN_C
ULONG 
__cdecl
TraceMessage(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    ...
);

EXTERN_C
ULONG 
TraceMessageVa(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    IN va_list      MessageArgList
);

#ifdef __cplusplus
}       // extern "C"
#endif

//
//
// Define the encoding independent routines
//

#if defined(UNICODE) || defined(_UNICODE)
#define RegisterTraceGuids      RegisterTraceGuidsW
#define StartTrace              StartTraceW
#define ControlTrace            ControlTraceW
#define StopTrace               StopTraceW
#define QueryTrace              QueryTraceW
#define UpdateTrace             UpdateTraceW
#define FlushTrace              FlushTraceW
#define QueryAllTraces          QueryAllTracesW
#define OpenTrace               OpenTraceW
#else
#define RegisterTraceGuids      RegisterTraceGuidsA
#define StartTrace              StartTraceA
#define ControlTrace            ControlTraceA
#define StopTrace               StopTraceA
#define QueryTrace              QueryTraceA
#define UpdateTrace             UpdateTraceA
#define FlushTrace              FlushTraceA
#define QueryAllTraces          QueryAllTracesA
#define OpenTrace               OpenTraceA
#endif  // UNICODE

#endif /* _WMIKM_  && _NTDDK_ */

#endif // WINNT
#endif /* _EVNTRACE_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ftsiface.h ===
// FTSIFACE.h -- DLL interface for FTSrch.dll
// Copyright (c) 1996-1999 Microsoft Corporation

#ifndef __FTSIFACE_H__
#define __FTSIFACE_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */



typedef HANDLE HINDEX;
typedef HANDLE HSEARCHER;
typedef HANDLE HCOMPRESSOR;
typedef HANDLE HHILITER;
typedef INT    ERRORCODE;
typedef struct { int base; int limit; } HILITE;

#define NO_TITLE              UINT(-1)  // ERRORCODE values
#define NOT_INDEXER           UINT(-2)
#define NOT_SEARCHER          UINT(-3)
#define NOT_COMPRESSOR        UINT(-4)
#define CANNOT_SAVE           UINT(-5)
#define OUT_OF_MEMORY         UINT(-6)
#define CANNOT_OPEN           UINT(-7)
#define CANNOT_LOAD           UINT(-8)
#define INVALID_INDEX         UINT(-9)
#define ALREADY_WEIGHED       UINT(-10)
#define NO_TEXT_SCANNED       UINT(-11)
#define ALIGNMENT_ERROR       UINT(-12)
#define INVALID_PHRASE_TABLE  UINT(-13)
#define INVALID_LCID          UINT(-14)
#define NO_INDICES_LOADED     UINT(-15)
#define INDEX_LOADED_ALREADY  UINT(-16)
#define GROUP_LOADED_ALREADY  UINT(-17)
#define DIALOG_ALREADY_ACTIVE UINT(-18)
#define EMPTY_PHRASE_TABLE    UINT(-19)
#define OUT_OF_DISK           UINT(-20)
#define DISK_READ_ERROR       UINT(-21)
#define DISK_WRITE_ERROR      UINT(-22)
#define SEARCH_ABORTED        UINT(-23)
#define UNKNOWN_EXCEPTION     UINT(-24)
#define SYSTEM_ERROR          UINT(-25)
#define NOT_HILITER			  UINT(-26)
#define INVALID_CHARSET       UINT(-27)
#define INVALID_SOURCE_NAME   UINT(-28)
#define INVALID_TIMESTAMP     UINT(-29)

#define ERR_NO_DISK_SPACE        0xE0000001  // Values reported by GetLastError
#define ERR_DISK_CREATE_ERROR    0xE0000002  //   when an explicit error result
#define ERR_DISK_OPEN_ERROR      0xE0000003  //   isn't available.
#define ERR_DISK_READ_ERROR      0xE0000004
#define ERR_DISK_WRITE_ERROR     0xE0000005
#define ERR_SYSTEM_ERROR         0xE0000006
#define ERR_ABORT_SEARCH         0xE0000007
#define ERR_INVALID_TIMESTAMP    0xE0000008
#define ERR_INVALID_SOURCE_NAME  0xE0000009
#define ERR_FILE_MAP_FAILED      0xE000000A
#define ERR_INVALID_FILE_TYPE    0xE000000B
#define ERR_DAMAGED_FILE         0xE000000C
#define ERR_FUTURE_VERSION       0xE000000D

// -------------- Index Construction Interface ---------------------------

#define TOPIC_SEARCH    0x00000001   // Options for NewIndex
#define PHRASE_SEARCH   0x00000002
#define PHRASE_FEEDBACK 0x00000004
#define VECTOR_SEARCH   0x00000008
#define WINHELP_INDEX   0x00000010
#define USE_VA_ADDR     0x00000020
#define USE_QWORD_JUMP  0x00000040

#define USE_DEFAULT     UINT(-1) // Surrogate for default charset or default lcid

HINDEX APIENTRY NewIndex(const PBYTE pbSourceName,
              UINT uiTime1, UINT uiTime2,
              UINT iCharsetDefault, UINT lcidDefault, UINT fdwOptions
             );

ERRORCODE APIENTRY ScanTopicTitle(HINDEX hinx, PBYTE pbTitle, UINT cbTitle,
                         UINT iTopic, HANDLE hTopic, UINT iCharset, UINT lcid
                        );
ERRORCODE APIENTRY ScanTopicText (HINDEX hinx, PBYTE pbText, UINT cbText, UINT iCharset, UINT lcid);
ERRORCODE APIENTRY SaveIndex     (HINDEX hinx, PSZ pszFileName);
ERRORCODE APIENTRY DeleteIndex   (HINDEX hinx);

typedef void  (__stdcall *ANIMATOR)(void);

ERRORCODE APIENTRY RegisterAnimator(ANIMATOR pAnimator, HWND hwndAnimator);

// ----------------- Querying the Validity of an Index File --------------

BOOL      APIENTRY IsValidIndex(PSZ pszFileName, UINT dwOptions);

void      APIENTRY SetDirectoryLocator(HWND hwndLocator);

// ----------------- Searcher Interface ----------------------------------

HSEARCHER APIENTRY NewSearcher();

INT       APIENTRY OpenIndex(HSEARCHER hsrch, PSZ pszIndexFileName,        // returns iIndex for index file
                               PBYTE pbSourceName, PUINT pcbSourceNameLimit, // or      -ErrorCode
                               PUINT pTime1, PUINT pTime2
                              );

ERRORCODE APIENTRY DiscardIndex  (HSEARCHER hsrch, INT iIndex);
ERRORCODE APIENTRY QueryOptions  (HSEARCHER hsrch, INT iIndex, PUINT pfdwOptions);
ERRORCODE APIENTRY SaveGroup     (HSEARCHER hsrch, PSZ pszFileName);
ERRORCODE APIENTRY LoadGroup     (HSEARCHER hsrch, PSZ pszFileName);
HWND      APIENTRY OpenDialog    (HSEARCHER hsrch, HWND hwndParent);
ERRORCODE APIENTRY DeleteSearcher(HSEARCHER hsrch);

// Messages for talking to WinHelp

#define MSG_FTS_JUMP_HASH	(WM_USER + 32)  // wParam = index, lParam = HashValue
#define MSG_FTS_JUMP_VA 	(WM_USER + 33)  // wParam = index, lParam = VirtualAddress
#define MSG_FTS_GET_TITLE	(WM_USER + 34)	// wParam = index, lParam = &pszTitle
#define MSG_FTS_JUMP_QWORD  (WM_USER + 35)  // wParam = index, lParam = address of QWordAddress structure
#define MSG_REINDEX_REQUEST (WM_USER + 36)  // wParam = unused,lParam = unused
#define MSG_FTS_WHERE_IS_IT (WM_USER + 37)	// wParam = fStartEnumeration, lParam = &pszFile
#define MSG_GET_DEFFONT 	(WM_USER + 45)	// return default font handle

typedef struct _QWordAddress
        {
            UINT   iSerial;
            HANDLE hTopic;

        } QWordAddress, *PQWordAddress;

// ------------------- Phrase Compression Interface ----------------------

HCOMPRESSOR APIENTRY NewCompressor(UINT iCharsetDefault);

ERRORCODE   APIENTRY ScanText(HCOMPRESSOR hcmp, PBYTE pbText, UINT cbText, UINT iCharset);

ERRORCODE   APIENTRY GetPhraseTable(HCOMPRESSOR hcmp, PUINT pcPhrases, PBYTE *ppbImages, PUINT pcbImages,
                           PBYTE *ppacbImageCompressed, PUINT pcbCompressed
                          );

ERRORCODE   APIENTRY SetPhraseTable(HCOMPRESSOR hcmp, PBYTE pbImages, UINT cbImages,
                           PBYTE pacbImageCompressed, UINT cbCompressed
                          );

INT APIENTRY CompressText  (HCOMPRESSOR hcmp, PBYTE pbText,       UINT cbText,       PBYTE *ppbCompressed, UINT iCharset);
INT APIENTRY DecompressText(HCOMPRESSOR hcmp, PBYTE pbCompressed, UINT cbCompressed, PBYTE  pbText                      );

ERRORCODE   APIENTRY DeleteCompressor(HCOMPRESSOR hcmp);

//----------------------- Hiliting Interface ------------------------------

HHILITER APIENTRY NewHiliter(HSEARCHER hSearch);
ERRORCODE APIENTRY DeleteHiliter(HHILITER hhil);
ERRORCODE APIENTRY ScanDisplayText(HHILITER hhil, PBYTE pbText, int cbText,
                                   UINT iCharset, LCID lcid);

ERRORCODE APIENTRY ClearDisplayText(HHILITER hhil);
int APIENTRY CountHilites(HHILITER hhil, int base, int limit);
int APIENTRY QueryHilites(HHILITER hhil, int base, int limit,
                          int cHilites, HILITE* paHilites);

#ifdef __cplusplus
}
#endif /* __cplusplus */



#endif // __FTSIFACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\fttypes.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    fttypes.h

Abstract:

    This header file defines types and structures for the FT API
    and the IOCTLs used to implement the FT API.

Author:

    Norbert Kusters 13-July-1996

Notes:

Revision History:

--*/

#if !defined( _FT_TYPES_DEFINITION_ )

#define _FT_TYPES_DEFINITION_ 1

#if _MSC_VER > 1000
#pragma once
#endif

//
// This enumerated type defines all of the different types of logical
// disks that can be constructed with this API.
//

typedef enum _FT_LOGICAL_DISK_TYPE {
    FtPartition,
    FtVolumeSet,
    FtStripeSet,
    FtMirrorSet,
    FtStripeSetWithParity,
    FtRedistribution
} FT_LOGICAL_DISK_TYPE, *PFT_LOGICAL_DISK_TYPE;

//
// This enumerated type defines all of the possible states that members
// of an FT set can have.
//

typedef enum _FT_MEMBER_STATE {
    FtMemberHealthy,
    FtMemberRegenerating,
    FtMemberOrphaned
} FT_MEMBER_STATE, *PFT_MEMBER_STATE;

//
// The logical disk id type is used to uniquely identify a logical disk.  It
// needs to be unique in the universe.
//

typedef LONGLONG FT_LOGICAL_DISK_ID, *PFT_LOGICAL_DISK_ID;

//
// This is the structure needed for the configuration information of
// a logical disk type of 'FtPartition'.
//

typedef struct _FT_PARTITION_CONFIGURATION_INFORMATION {
    ULONG       Signature;
    ULONG       DiskNumber;
    LONGLONG    ByteOffset;
} FT_PARTITION_CONFIGURATION_INFORMATION, *PFT_PARTITION_CONFIGURATION_INFORMATION;

//
// This is the structure needed for the configuration information of
// a logical disk type of 'FtStripeSet'.
//

typedef struct _FT_STRIPE_SET_CONFIGURATION_INFORMATION {
    ULONG   StripeSize;
} FT_STRIPE_SET_CONFIGURATION_INFORMATION, *PFT_STRIPE_SET_CONFIGURATION_INFORMATION;

//
// This is the structure needed for the configuration information of
// a logical disk type of 'FtMirrorSet'.
//

typedef struct _FT_MIRROR_SET_CONFIGURATION_INFORMATION {
    LONGLONG    MemberSize;
} FT_MIRROR_SET_CONFIGURATION_INFORMATION, *PFT_MIRROR_SET_CONFIGURATION_INFORMATION;

//
// This is the structure needed for the configuration information of
// a logical disk type of 'FtStripeSetWithParity'.
//

typedef struct _FT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION {
    LONGLONG    MemberSize;
    ULONG       StripeSize;
} FT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION, *PFT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION;

//
// This is the structure needed for the configuration information of
// a logical disk type of 'FtRedistribution'.
//

typedef struct _FT_REDISTRIBUTION_CONFIGURATION_INFORMATION {
    ULONG   StripeSize;
    USHORT  FirstMemberWidth;
    USHORT  SecondMemberWidth;
} FT_REDISTRIBUTION_CONFIGURATION_INFORMATION, *PFT_REDISTRIBUTION_CONFIGURATION_INFORMATION;

//
// This is the structure needed for the state of a logical disk type of
// 'FtStripeSetWithParity' or 'FtMirrorSet'.
//

typedef struct _FT_MIRROR_AND_SWP_STATE_INFORMATION {
    BOOLEAN         IsDirty;
    BOOLEAN         IsInitializing;
    USHORT          UnhealthyMemberNumber;
    FT_MEMBER_STATE UnhealthyMemberState;
} FT_MIRROR_AND_SWP_STATE_INFORMATION, *PFT_MIRROR_AND_SWP_STATE_INFORMATION;

//
// This is the structure needed for the state of a logical disk type of
// 'FtRedistribution'.
//

typedef struct _FT_REDISTRIBUTION_STATE_INFORMATION {
    LONGLONG    BytesRedistributed;
} FT_REDISTRIBUTION_STATE_INFORMATION, *PFT_REDISTRIBUTION_STATE_INFORMATION;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\getuser.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992-1999           **/
/**********************************************************************/

/*
    GetUser.h

    This file contains the definitions for the User Browser "C" API

    FILE HISTORY:
        AndyHe  11-Oct-1992     Created

*/

#ifndef _GETUSER_H_
#define _GETUSER_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <ntseapi.h>

typedef HANDLE    HUSERBROW;        // handle type returned by OpenUserBrowser

//
//   Parameter structure passed to OpenUserBrowser
//
typedef struct tagUSLT {    // uslt
    ULONG             ulStructSize;
    BOOL              fUserCancelled;   // Set if user cancelled
    BOOL              fExpandNames;     // TRUE if full names should be returned
    HWND              hwndOwner;        // Window handle to use for dialog
    WCHAR           * pszTitle;         // Dialog title (or NULL)
    WCHAR           * pszInitialDomain; // NULL for local machine or prefix
                                        // with "\\" for server
    DWORD             Flags;            // Defined below
    ULONG             ulHelpContext;    // Help context for the main dialog
    WCHAR           * pszHelpFileName;  // Help file name
}  USERBROWSER, *LPUSERBROWSER, * PUSERBROWSER;

//
// Bit values for Flags field
//

//
//  Indicates the user accounts should be shown as if the user pressed
//  the "Show Users" button.  The button will be hidden if this flag is
//  set.  The USRBROWS_SHOW_USERS flag must also be set.

#define USRBROWS_EXPAND_USERS       (0x00000008)

//
//  Passing this will prevent the computer name from showing up in the
//  combo box.
//

#define USRBROWS_DONT_SHOW_COMPUTER (0x00000100)

//
//  Allow the user to only select a single item from the listbox (not all
//  SHOW_* combinations are supported with this option).
//

#define USRBROWS_SINGLE_SELECT	    (0x00001000)

//
//  These manifests determine which well known Sids are included in the list.
//
#define USRBROWS_INCL_REMOTE_USERS  (0x00000010)
#define USRBROWS_INCL_INTERACTIVE   (0x00000020)
#define USRBROWS_INCL_EVERYONE      (0x00000040)
#define USRBROWS_INCL_CREATOR       (0x00000080)
#define USRBROWS_INCL_SYSTEM        (0x00010000)
#define USRBROWS_INCL_RESTRICTED    (0x00020000)
#define USRBROWS_INCL_ALL           (USRBROWS_INCL_REMOTE_USERS |\
                                     USRBROWS_INCL_INTERACTIVE  |\
                                     USRBROWS_INCL_EVERYONE     |\
                                     USRBROWS_INCL_CREATOR      |\
                                     USRBROWS_INCL_SYSTEM	|\
                                     USRBROWS_INCL_RESTRICTED)

//
//  These manifests determine which type of accounts to display
//
//  Note: currently, if you display groups, you must display users
//		     if you display aliases (local groups), you must display
//			   groups and users
//
#define USRBROWS_SHOW_ALIASES	    (0x00000001)
#define USRBROWS_SHOW_GROUPS	    (0x00000002)
#define USRBROWS_SHOW_USERS	    (0x00000004)
#define USRBROWS_SHOW_ALL	    (USRBROWS_SHOW_ALIASES |\
				     USRBROWS_SHOW_GROUPS  |\
				     USRBROWS_SHOW_USERS)


//
// The caller should provide the name of a help file containing four
// help contexts.  The first help context is for the main User Browser
// dialog, the next three are for the Local Group Membership, Global Group
// Membership, and Find Account subdialogs, respectively.
//
#define USRBROWS_HELP_OFFSET_LOCALGROUP  1
#define USRBROWS_HELP_OFFSET_GLOBALGROUP 2
#define USRBROWS_HELP_OFFSET_FINDUSER    3

//
//  User Details structure returned by user browser enumeration
//
typedef struct tagUSDT {    // usdt
    enum _SID_NAME_USE    UserType;
    PSID                  psidUser;
    PSID                  psidDomain;
    WCHAR               * pszFullName;
    WCHAR               * pszAccountName;
    WCHAR               * pszDisplayName;
    WCHAR               * pszDomainName;
    WCHAR               * pszComment;
    ULONG                 ulFlags;          // User account flags
} USERDETAILS, * LPUSERDETAILS, * PUSERDETAILS;

#ifdef __cplusplus
extern "C" {
#endif

// Function definitions for the GetUser API...

HUSERBROW WINAPI OpenUserBrowser( LPUSERBROWSER lpUserParms );

BOOL WINAPI EnumUserBrowserSelection( HUSERBROW hHandle,
                                      LPUSERDETAILS lpUser,
                                      DWORD *plBufferSize );

BOOL WINAPI CloseUserBrowser( HUSERBROW hHandle );

#ifdef __cplusplus
}   // extern "C"
#endif

#endif //_GETUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\gluon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:   gluon.h
//
//  Contents:   Gluon data structure definitions
//
//  History:    16-Mar-94       MikeSe  Created
//
//  Description:
//
//  This file contains all the structure definitions related to
//  gluons. It is constructed in such a way that it can be #included
//  in an IDL file and that the resultant MIDL-generated H file will
//  not interfere when both are included, regardless of order.
//
//----------------------------------------------------------------------------

#ifndef __GLUON_H__
#define __GLUON_H__

#if _MSC_VER > 1000
#pragma once
#endif

// Handy macro for decoration with MIDL attributes
#if defined(MIDL_PASS)
# define MIDL_DECL(x) x
# define MIDL_QUOTE(x) cpp_quote(x)
#else
# define MIDL_DECL(x)
# define MIDL_QUOTE(x)
#endif

MIDL_QUOTE("#ifndef __GLUON_H__")
MIDL_QUOTE("#define __GLUON_H__")

// TDI transport address structure. We do not define this if tdi.h has
//  already been included.

MIDL_QUOTE("#if !defined(_TDI_USER_)")
#if !defined(_TDI_USER_)

typedef struct _TA_ADDRESS {
    USHORT AddressLength;       // length in bytes of Address[] in this
    USHORT AddressType;         // type of this address
# if defined(MIDL_PASS)
    [size_is(AddressLength)] UCHAR Address[];
# else
    UCHAR Address[1];       // actually AddressLength bytes long
# endif
} TA_ADDRESS;

#endif
MIDL_QUOTE("#endif")

// Note that you must include tdi.h (first) if you need the AddressType
//  constant definitions.

// DS_TRANSPORT, with RPC and File protocol modifiers

typedef struct _DS_TRANSPORT
{
    USHORT usFileProtocol;
    USHORT iPrincipal;
    USHORT grfModifiers;
    TA_ADDRESS taddr;
} DS_TRANSPORT, *PDS_TRANSPORT;

// The real size of a DS_TRANSPORT where AddressLength == 0.  Need to
// subtract off 2 UCHARs to take into account padding.
#define DS_TRANSPORT_SIZE (sizeof(DS_TRANSPORT) - 2*sizeof(UCHAR))
MIDL_QUOTE("#define DS_TRANSPORT_SIZE (sizeof(DS_TRANSPORT) - 2*sizeof(UCHAR))")

// File protocol identifiers

#if defined(MIDL_PASS)

const USHORT FSP_NONE = 0;      // file access not supported
const USHORT FSP_SMB = 1;   // SMB (ie: LanMan redirector)
const USHORT FSP_NCP = 2;   // Netware Core Protocol (Netware requestor)
const USHORT FSP_NFS = 3;   // Sun NFS protocol
const USHORT FSP_VINES = 4; // Banyan Vines
const USHORT FSP_AFS = 5;   // Andrews File System
const USHORT FSP_DCE = 6;   // DCE Andrews File System

#else

#define FSP_NONE    0
#define FSP_SMB     1
#define FSP_NCP     2
#define FSP_NFS     3
#define FSP_VINES   4
#define FSP_AFS     5
#define FSP_DCE     6

#endif

// RPC modifiers

#if defined(MIDL_PASS)

const USHORT DST_RPC_CN = 0x0001;   // supports a connection-oriented (ncacn_...)
                        //   RPC protocol for this transport.
const USHORT DST_RPC_DG = 0x0002;   // supports a connectionless (ncadg_...)
                        //   RPC protocol for this transport.
const USHORT DST_RPC_NB_XNS = 0x0004;   // ncacn_nb_xns protocol is supported
const USHORT DST_RPC_NB_NB = 0x0008;    // ncacn_nb_nb protocol is supported
const USHORT DST_RPC_NB_IPX = 0x0010;   // ncacn_nb_ipx protocol is supported
const USHORT DST_RPC_NB_TCP = 0x0020;   // ncacn_nb_tcp protocol is supported

#else

#define DST_RPC_CN  0x0001
#define DST_RPC_DG  0x0002
#define DST_RPC_NB_XNS  0x0004
#define DST_RPC_NB_NB   0x0008
#define DST_RPC_NB_IPX  0x0010
#define DST_RPC_NB_TCP  0x0020

#endif

// DS_MACHINE

typedef MIDL_DECL([string]) WCHAR * PNAME;

typedef struct _DS_MACHINE
{
    GUID guidSite;
    GUID guidMachine;
    ULONG grfFlags;
    MIDL_DECL([string]) LPWSTR pwszShareName;
    ULONG cPrincipals;
    MIDL_DECL([size_is(cPrincipals)]) PNAME *prgpwszPrincipals;
    ULONG cTransports;
# if defined(MIDL_PASS)
    [size_is(cTransports)] PDS_TRANSPORT rpTrans[];
# else
    PDS_TRANSPORT rpTrans[1];
# endif
} DS_MACHINE, *PDS_MACHINE;

// The real size of a DS_MACHINE in which cTransports == 0
#define DS_MACHINE_SIZE (sizeof(DS_MACHINE) - sizeof(PDS_TRANSPORT))
MIDL_QUOTE("#define DS_MACHINE_SIZE (sizeof(DS_MACHINE) - sizeof(PDS_TRANSPORT))")

// DS_GLUON

typedef struct _DS_GLUON
{
    GUID guidThis;
    MIDL_DECL([string]) LPWSTR pwszName;
    ULONG grfFlags;
    ULONG cMachines;
# if defined(MIDL_PASS)
    [size_is(cMachines)] PDS_MACHINE rpMachines[];
# else
    PDS_MACHINE rpMachines[1];
# endif
} DS_GLUON, *PDS_GLUON;

// The real size of a DS_GLUON in which cMachines == 0
#define DS_GLUON_SIZE (sizeof(DS_GLUON) - sizeof(PDS_MACHINE))
MIDL_QUOTE("#define DS_GLUON_SIZE (sizeof(DS_GLUON) - sizeof(PDS_MACHINE))")

MIDL_QUOTE("#endif")

#endif  // of ifndef __GLUON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\h323tsp.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    H323TSP.H

Abstract:

    Microsoft H.323 TAPI Service Provider Extensions.

Environment:

    User Mode - Win32

--*/

#ifndef _H323TSP_H_
#define _H323TSP_H_

#if _MSC_VER > 1000
#pragma once
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Extension version                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define H323TSP_CURRENT_VERSION     1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Structure definitions                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#pragma pack(push,1)

#define H245_MESSAGE_REQUEST        0
#define H245_MESSAGE_RESPONSE       1
#define H245_MESSAGE_COMMAND        2
#define H245_MESSAGE_INDICATION     3

typedef struct _H323_USERUSERINFO {

    DWORD   dwTotalSize;
    DWORD   dwH245MessageType;
    DWORD   dwUserUserInfoSize;
    DWORD   dwUserUserInfoOffset;
    BYTE    bCountryCode;
    BYTE    bExtension;
    WORD    wManufacturerCode;

} H323_USERUSERINFO, * PH323_USERUSERINFO;

#pragma pack(pop)

#endif // _H323TSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ia64inst.h ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
//     without Intel's express permission
//
/**
***  Copyright  (C) 1996-99 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    ia64inst.h

Abstract:

    IA64 instruction and floating constant definitions.

Author:

    hc

Revision History:

--*/

#ifndef _IA64INST_
#define _IA64INST_
#if _MSC_VER > 1000
#pragma once
#endif

//
//     IA64 INSTRUCTION FORMAT STRUCTURES
//

typedef union _IA64_INSTRUCTION {
    ULONG Long[4];
    UCHAR Byte[16];

} IA64_INSTRUCTION, *PIA64_INSTRUCTION;

#define BUNDLE_SIZE sizeof(IA64_INSTRUCTION)

//
// Define certain specific instructions
//

#define SYSTEM_CALL_INSTR  0x01100000000L  // break <number>
#define FAST_SYSCALL_INSTR 0x01180000000L  // break <number>
#define RETURN_INSTR       0x00000A00000L  // rfi
#define BREAK_INSTR        0x00000000000L  // break <number>
#define NO_OP_INSTR        0x00000100000L  // ori r.0, r.0, 0
#define INVALID_INSTR      0x00000000000L  // all 0's => invalid
#define BR_RET_INSTR       0x00001040100L  // br.ret

#define BR_RET_MASK        0x1e1f80001c0L  // br.ret mask

#define INST_TEMPL_MASK   (0x0000000001fL)           // bit(4:0)
#define INST_SLOT0_MASK   (0x1ffffffffffL << 5)      // bit(5:45)
#define INST_SLOT1_MASK   (0x1ffffffffffL << 14)     // bit(46:86)
#define INST_SLOT2_MASK   (0x1ffffffffffL << 23)     // bit(87:127)

#define ISR_EI 41                                    // copy from kxia64.h
#define PSR_RI 41                                    // copy from kxia64.h
#define PSR_DD 39                                    // copy from kxia64.h
#define PSR_DB 24                                    // copy from kxia64.h
#define ISR_EI_MASK  ((ULONGLONG)0x3 << ISR_EI)      // ISR.ei (42:41)
#define IPSR_RI_MASK ((ULONGLONG)0x3 << PSR_RI)      // PSR.ri (42:41)


#endif // _IA64INST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\i2osmi.h ===
/*++

Copyright (c) 1997-1999  Hewlett-Packard Company & Microsoft Corporation

Module Name:

    i2osmi.h

Abstract:

    This module defines the NT types, constants, and functions that are
    exposed from the i2oexec driver.

Revision History:

--*/

#if !defined(I2OSMI_HDR)
#define I2OSMI_HDR

#if _MSC_VER > 1000
#pragma once
#endif

#include <devioctl.h>

#include "I2OUtil.h"
#include "I2OExec.h"

#pragma pack (push, 1)

//
// Parameter structure for Get/Set Parameters call.
//

typedef struct _I2O_PARAM_BLOCK {
    ULONG           IOP;
    USHORT          TargetTID;
    UCHAR           ParamData[1];
} I2O_PARAM_BLOCK, *PI2O_PARAM_BLOCK;

//
// I2O IOP Descriptor
//

typedef struct  _I2O_IOP_DESCRIPTOR {
    U32          IOPNumber;
    BOOLEAN      (*SendHandler) (PVOID HandlerContext, PVOID     MessageFrame);
    PVOID        reserved;
    PVOID        reserved1;
    PVOID        HandlerContext;
    ULONG        (*GetMFA)(PVOID HandlerContext, PVOID MFA, PVOID Buffer, ULONG Size);
    ULONG        MaxMessageFrameSize;
    ULONG        ExpectedLCTSize;
    PVOID        AdapterObject;
    ULONG        MaxInboundMFrames;
    ULONG        InitialInboundMFrames;
} I2O_IOP_DESCRIPTOR, *PI2O_IOP_DESCRIPTOR;

//
// I2O IOP and LCT Configuration data
//

typedef struct _I2O_DEVICE_DESCRIPTOR {
    I2O_IOP_DESCRIPTOR      IOP;
    ULONG                   ChangeIndicator;
    I2O_LCT_ENTRY           LCT;
} I2O_DEVICE_DESCRIPTOR, *PI2O_DEVICE_DESCRIPTOR;

//
//      I2O Query Configuration Record structure
//

#define I2O_CLASS_MATCH_ANY_BITS  (((1<<I2O_CLASS_ID_SZ)-1) & I2O_CLASS_MATCH_ANYCLASS)

typedef struct _I2O_CONFIG_QUERY {
    ULONG          IOPNumber;
    I2O_CLASS_ID   ClassID;
    ULONG          SubClassID;
    ULONG          Index;
} I2O_CONFIG_QUERY, *PI2O_CONFIG_QUERY;

//
// Useful define in get/set operations
//

typedef struct _I2O_PARAM_SCALAR_OPERATION {
    I2O_PARAM_OPERATIONS_LIST_HEADER      OpList;
    I2O_PARAM_OPERATION_SPECIFIC_TEMPLATE OpBlock;
} I2O_PARAM_SCALAR_OPERATION, *PI2O_PARAM_SCALAR_OPERATION;
//
// Defines for the interface to the I2OExec driver.
//

#define I2O_GET_CONFIG_INFO        0xBA0
#define I2O_PRIVATE_MESSAGE_CODE   0xBB0
#define I2O_EXEC_REQUEST           0xBC0
#define I2O_PARAMS_GET_REQUEST     0xBD0
#define I2O_PARAMS_SET_REQUEST     0xBE0
#define I2O_GET_LCT                0xBF0
#define I2O_GET_IOPCOUNT           0xC00
#define I2O_GET_CONFIGDIALOG       0xC10

#define IOCTL_GET_CONFIG_INFO \
    CTL_CODE (FILE_DEVICE_UNKNOWN, I2O_GET_CONFIG_INFO, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PRIVATE_MESSAGE \
    CTL_CODE (FILE_DEVICE_UNKNOWN, I2O_PRIVATE_MESSAGE_CODE, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_EXEC_REQUEST \
    CTL_CODE (FILE_DEVICE_UNKNOWN, I2O_EXEC_REQUEST, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PARAMS_GET_REQUEST \
    CTL_CODE (FILE_DEVICE_UNKNOWN, I2O_PARAMS_GET_REQUEST, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PARAMS_SET_REQUEST \
    CTL_CODE (FILE_DEVICE_UNKNOWN, I2O_PARAMS_SET_REQUEST, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_GET_LCT \
    CTL_CODE (FILE_DEVICE_UNKNOWN, I2O_GET_LCT, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PRIVATE_MSG \
    CTL_CODE (FILE_DEVICE_UNKNOWN, I2O_PRIVATE_MESSAGE, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_GET_IOP_COUNT \
    CTL_CODE (FILE_DEVICE_UNKNOWN, I2O_GET_IOPCOUNT, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_GET_CONFIG_DIALOG \
    CTL_CODE (FILE_DEVICE_UNKNOWN, I2O_GET_CONFIGDIALOG, METHOD_BUFFERED, FILE_ANY_ACCESS)

#pragma pack (pop)

#endif          // I2OCONFIG_HDR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\fltdefs.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

   fltdefs.h

Abstract:

    Definitions for the WIN32 filter APIs

Author:

    Arnold Miller (arnoldm) 24-Sept-1997

Revision History:

--*/

#ifndef _FLTDEFS_H
#define _FLTDEFS_H

#if _MSC_VER > 1000
#pragma once
#endif

typedef PVOID  FILTER_HANDLE, *PFILTER_HANDLE;
typedef PVOID  INTERFACE_HANDLE, *PINTERFACE_HANDLE;

#define PFEXPORT _declspec(dllexport)

#ifdef __cplusplus
#define EXTERNCDECL EXTERN_C
#else
#define EXTERNCDECL
#endif

#define PFAPIENTRY EXTERNCDECL DWORD PFEXPORT WINAPI

typedef enum _GlobalFilter
{
    GF_FRAGMENTS = 2,        // check consistency of fragments
    GF_STRONGHOST = 8,       // check destination address of input frames
    GF_FRAGCACHE = 9         // check fragments from cache
} GLOBAL_FILTER, *PGLOBAL_FILTER;

typedef enum _PfForwardAction
{
    PF_ACTION_FORWARD = 0,
    PF_ACTION_DROP
} PFFORWARD_ACTION, *PPFFORWARD_ACTION;

typedef enum _PfAddresType
{
    PF_IPV4,
    PF_IPV6
} PFADDRESSTYPE, *PPFADDRESSTYPE;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The constants that should be used to set up the FILTER_INFO_STRUCTURE    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define FILTER_PROTO(ProtoId)   MAKELONG(MAKEWORD((ProtoId),0x00),0x00000)

#define FILTER_PROTO_ANY        FILTER_PROTO(0x00)
#define FILTER_PROTO_ICMP       FILTER_PROTO(0x01)
#define FILTER_PROTO_TCP        FILTER_PROTO(0x06)
#define FILTER_PROTO_UDP        FILTER_PROTO(0x11)

#define FILTER_TCPUDP_PORT_ANY  (WORD)0x0000

#define FILTER_ICMP_TYPE_ANY    (BYTE)0xff
#define FILTER_ICMP_CODE_ANY    (BYTE)0xff

typedef struct _PF_FILTER_DESCRIPTOR
{
    DWORD           dwFilterFlags;    // see below
    DWORD           dwRule;           // copied into the log when appropriate
    PFADDRESSTYPE   pfatType;
    PBYTE           SrcAddr;
    PBYTE           SrcMask;
    PBYTE           DstAddr;
    PBYTE           DstMask;
    DWORD           dwProtocol;
    DWORD           fLateBound;
    WORD            wSrcPort;
    WORD            wDstPort;
    WORD            wSrcPortHighRange;
    WORD            wDstPortHighRange;
}PF_FILTER_DESCRIPTOR, *PPF_FILTER_DESCRIPTOR;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Structure for PfGetInterfaceStatistics                                   //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef struct _PF_FILTER_STATS
{
    DWORD       dwNumPacketsFiltered;
    PF_FILTER_DESCRIPTOR info;
}PF_FILTER_STATS, *PPF_FILTER_STATS;

typedef struct _PF_INTERFACE_STATS
{
    PVOID               pvDriverContext;
    DWORD               dwFlags;          // none as yet (28-Sept-1997)
    DWORD               dwInDrops;
    DWORD               dwOutDrops;
    PFFORWARD_ACTION    eaInAction;
    PFFORWARD_ACTION    eaOutAction;
    DWORD               dwNumInFilters;
    DWORD               dwNumOutFilters;
    DWORD               dwFrag;
    DWORD               dwSpoof;
    DWORD               dwReserved1;
    DWORD               dwReserved2;
    LARGE_INTEGER       liSYN;
    LARGE_INTEGER       liTotalLogged;
    DWORD               dwLostLogEntries;
    PF_FILTER_STATS     FilterInfo[1];
} PF_INTERFACE_STATS, *PPF_INTERFACE_STATS;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The number of bytes starting at SrcAddr. If you add something to the     //
// structure make sure this remains valid                                   //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define FILTERSIZE                                      \
    (sizeof(PF_FILTER_DESCRIPTOR) -                     \
     (DWORD)(&((PPF_FILTER_DESCRIPTOR)0)->SrcAddr))


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Flags for PF_FILTER_DESCRIPTOR                                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//
// Disallows incoming SYN
//

#define FD_FLAGS_NOSYN      0x1

//
// All legal flags
//

#define FD_FLAGS_ALLFLAGS   FD_FLAGS_NOSYN


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Late bound defs. Go in fLateBound in a PF_FILTER_DESCRIPTOR and          //
// describe which other fields of the filter are affected  by a             //
// PfRebindFilters call. In general such filters are on  WAN interfaces     //
// where one or the other address may change as the connection is           //
// reconnected.                                                             //
// The assumption is that such interfaces HAVE ONLY ONE ADDRESS.            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define LB_SRC_ADDR_USE_SRCADDR_FLAG     0x00000001
#define LB_SRC_ADDR_USE_DSTADDR_FLAG     0x00000002
#define LB_DST_ADDR_USE_SRCADDR_FLAG     0x00000004
#define LB_DST_ADDR_USE_DSTADDR_FLAG     0x00000008
#define LB_SRC_MASK_LATE_FLAG            0x00000010
#define LB_DST_MASK_LATE_FLAG            0x00000020

typedef struct _PF_LATEBIND_INFO
{
    PBYTE   SrcAddr;
    PBYTE   DstAddr;
    PBYTE   Mask;
}PF_LATEBIND_INFO, *PPF_LATEBIND_INFO;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The format of a logged frame and defs for it.                            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef enum _PfFrameType
{
    PFFT_FILTER = 1,                  // a filter violation
    PFFT_FRAG   = 2,                  // bad fragment
    PFFT_SPOOF   = 3                  // strong host failure
} PFFRAMETYPE, *PPFFRAMETYPE;

typedef struct _pfLogFrame
{
    LARGE_INTEGER  Timestamp;
    PFFRAMETYPE    pfeTypeOfFrame;
    DWORD          dwTotalSizeUsed;      // used to find the next frame
    DWORD          dwFilterRule;         // from the filter
    WORD           wSizeOfAdditionalData;
    WORD           wSizeOfIpHeader;
    DWORD          dwInterfaceName;      // the name of the interface
    DWORD          dwIPIndex;
    BYTE           bPacketData[1];       // the frame. wsizeOfIpHeader
                                         // and wsizeOfAdditionalData
                                         // describe this
} PFLOGFRAME, *PPFLOGFRAME;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Error codes. These extend the WIN32 errors by having errors specific to  //
// these APIs. Besides these errors, the APIs may return any of the WIN32   //
// errors.                                                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define ERROR_BASE  23000

#define PFERROR_NO_PF_INTERFACE    (ERROR_BASE + 0)   // never returned.
#define PFERROR_NO_FILTERS_GIVEN   (ERROR_BASE + 1)
#define PFERROR_BUFFER_TOO_SMALL   (ERROR_BASE + 2)
#define ERROR_IPV6_NOT_IMPLEMENTED (ERROR_BASE + 3)


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The API prototypes                                                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

PFAPIENTRY
PfCreateInterface(
    DWORD            dwName,
    PFFORWARD_ACTION inAction,
    PFFORWARD_ACTION outAction,
    BOOL             bUseLog,
    BOOL             bMustBeUnique,
    INTERFACE_HANDLE *ppInterface
    );

PFAPIENTRY
PfDeleteInterface(
    INTERFACE_HANDLE pInterface
    );

PFAPIENTRY
PfAddFiltersToInterface(
    INTERFACE_HANDLE      ih,
    DWORD                 cInFilters,
    PPF_FILTER_DESCRIPTOR pfiltIn,
    DWORD                 cOutFilters,
    PPF_FILTER_DESCRIPTOR pfiltOut,
    PFILTER_HANDLE        pfHandle
    );

PFAPIENTRY
PfRemoveFiltersFromInterface(
    INTERFACE_HANDLE      ih,
    DWORD                 cInFilters,
    PPF_FILTER_DESCRIPTOR pfiltIn,
    DWORD                 cOutFilters,
    PPF_FILTER_DESCRIPTOR pfiltOut
    );

PFAPIENTRY
PfRemoveFilterHandles(
    INTERFACE_HANDLE   pInterface,
    DWORD              cFilters,
    PFILTER_HANDLE     pvHandles
    );


PFAPIENTRY
PfUnBindInterface(
    INTERFACE_HANDLE   pInterface
    );

PFAPIENTRY
PfBindInterfaceToIndex(
    INTERFACE_HANDLE    pInterface,
    DWORD               dwIndex,
    PFADDRESSTYPE       pfatLinkType,
    PBYTE               LinkIPAddress
    );

PFAPIENTRY
PfBindInterfaceToIPAddress(
    INTERFACE_HANDLE    pInterface,
    PFADDRESSTYPE       pfatType,
    PBYTE               IPAddress
    );

PFAPIENTRY
PfRebindFilters(
    INTERFACE_HANDLE    pInterface,
    PPF_LATEBIND_INFO   pLateBindInfo
    );

PFAPIENTRY
PfAddGlobalFilterToInterface(
    INTERFACE_HANDLE   pInterface,
    GLOBAL_FILTER      gfFilter
    );

PFAPIENTRY
PfRemoveGlobalFilterFromInterface(
    INTERFACE_HANDLE   pInterface,
    GLOBAL_FILTER      gfFilter
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Log APIs. Note that there is at most one log and it must be created      //
// before any interface needing it is created. There is no way to set a     //
// log onto an existing interface. The log can be applied to any or all of  //
// the interfaces.                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

PFAPIENTRY
PfMakeLog(
    HANDLE  hEvent
    );

//
// Provide a buffer, and notification parameters, and get back
// the old buffer and status.
//

PFAPIENTRY
PfSetLogBuffer(
    PBYTE   pbBuffer,
    DWORD   dwSize,
    DWORD   dwThreshold,
    DWORD   dwEntries,
    PDWORD  pdwLoggedEntries,
    PDWORD  pdwLostEntries,
    PDWORD  pdwSizeUsed
    );

//
// Doing this will disable the log on any of the interfaces. But if
// an interface was created with the log, the actual log will not be
// completely deleted until that interface is deleted. This is a small
// point, but it might explain a mystery or two.
//

PFAPIENTRY
PfDeleteLog(
    VOID
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Get statistics. Note pdwBufferSize in an IN/OUT parameter. If            //
// ERROR_INSUFFICIENT_BUFFER is returned, the common statistics are         //
// available and the correct byte count is in *pdwBufferSize. If only the   //
// interface statistics are needed, provide a buffer of size                //
// PF_INTERFACE_STATS only.                                                 //
// If the filter descriptions are also needed, then supply a large buffer,  //
// or use the returned count from the first call to allocate a buffer of    //
// sufficient size. Note that for a shared interface, this second call may  //
// fail with ERROR_INSUFFICIENT_BUFFER. This can happen if the other        //
// sharers add filters in the interim. This should not happen for a UNIQUE  //
// interface.                                                               //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


PFAPIENTRY
PfGetInterfaceStatistics(
    INTERFACE_HANDLE    pInterface,
    PPF_INTERFACE_STATS ppfStats,
    PDWORD              pdwBufferSize,
    BOOL                fResetCounters
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Test a packet.                                                           //
// This call will evaluate the packet against the given interfaces          //
// and return the filtering action.                                         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

PFAPIENTRY
PfTestPacket(
    INTERFACE_HANDLE   pInInterface  OPTIONAL,
    INTERFACE_HANDLE   pOutInterface OPTIONAL,
    DWORD              cBytes,
    PBYTE              pbPacket,
    PPFFORWARD_ACTION  ppAction
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\imessage.h ===
/*
 *	I M E S S A G E . H
 *
 *	External definitions for MAPI's IMessage-on-IStorage facility
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _IMESSAGE_H_
#define _IMESSAGE_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C"
{
#endif

typedef struct _MSGSESS		FAR * LPMSGSESS;

/*	Typedef of optional callback routine to be called on last release of
 *	top-level messages opened with OpenIMsgOnIStg
 */
typedef void (STDAPICALLTYPE MSGCALLRELEASE)(
	ULONG 		ulCallerData,
	LPMESSAGE	lpMessage );

/* DLL Entry Points (found in mapiu.dll) */

/* OpenIMsgSession
 * CloseIMsgSession
 *
 * These entry points allow the caller to "wrap" the creation of messages
 * inside a session, so that when the session is closed, all messages
 * created within that session are closed as well. Use of IMSG sessions
 * is optional. If OpenIMsgOnIStg is called with a NULL for the lpmsgsess
 * parameter, the message is created independent of any session, and has
 * no way to be shutdown. If the caller forgets to release the message, or
 * to release open tables within the message, the memory will be leaked until
 * the external application terminates.
 */

STDAPI_(SCODE) OpenIMsgSession(
	LPMALLOC		lpMalloc,			/* -> Co malloc object			*/
	ULONG			ulFlags,			/* reserved. Must be zero.		*/
	LPMSGSESS FAR	*lppMsgSess );		/* <- message session object	*/

STDAPI_(void) CloseIMsgSession(
	LPMSGSESS		lpMsgSess );		/* -> message session object	*/

/*	OpenIMsgOnIStg - Main entry point
 *
 *	NOTE 1:  The IStg must be opened with STGM_TRANSACTED if STGM_READWRITE
 *	is specified.  Since messages don't support a write only mode, IMessage
 *	doesn't allow a storage object opened in write only mode. If the storage
 *	is opened STGM_READ, then STGM_TRANSACTED is NOT required.
 *
 *	NOTE 2:  The lpMapiSup parameter is optional.  If supplied then IMessage
 *	will support the MAPI_DIALOG and ATTACH_DIALOG flags (by calling
 *	support method: DoMCDialog) on CopyTo and DeleteAttach methods.
 *	If lpMapiSup is not supplied (i.e. passed 0) then dialog flags will be
 *	ignored.  If supplied then ModifyRecipients will attempt to convert
 *	short term entryids to long term entryids (by calling support method
 *	OpenAddressBook and calls on the returned object).  If not supplied
 *	then short term entryid's will be stored without conversion.
 *
 *	NOTE 3:  The lpfMsgCallRelease parameter is optional.  If supplied then
 *	IMessage will call the routine when the last release on (the toplevel only)
 *	message is called.  It is intended to allow the callee to free the IStorage
 *	that contains the message.  IMessage will not use the IStorage object after
 *	making this call.
 *
 *	NOTE 4:  Behavior of multiple opens of sub-objects (Attachments, Streams,
 *	Storages, Messages, etc.) within a message is deliberately undefined in
 *	MAPI.  This implementation allows them, but will do it by AddRef'ing the
 *	existing open and returning it to the caller of OpenAttachment or
 *	OpenProperty.  This means that whatever access mode the first open on a
 *	specific Attachment or Property had is what all others will get regardless
 *	of what the subsequent opens asked for.
 *
 *	NOTE 5:  There is currently one flag defined for use with the ulFlags
 *	parameter. The IMSG_NO_ISTG_COMMIT flag controls whether the commit
 *	method of IStorage is called when the client calls SaveChanges on the
 *	IMessage object. Some clients of IMessage may wish to commit the IStorage
 *	themselves after writing additional data to the storage (beyond what
 *	IMessage itself writes). To aid in this, the IMessage implementation
 *	guarantees to name all sub-storages starting with "__". Therefore,
 *	if the client keeps its names out of that namespace, there will be no
 *	accidental collisions.
 *
 *	WARNING:	
 *
 *	This implementation of IMessage will support OpenProperty w/MAPI_CREATE
 *	where the source interface is IID_IStorage if the property id is
 *	'PR_ATTACH_DATA'.  Once this has been done, the caller has an IStorage
 *	interface on this property.  This is ok and should allow for
 *	easier implementation of OLE 2.0 Server functionality.  However, if you
 *	pass in the new IStorage ptr (to the attachment data) through the
 *	OpenIMsgOnIStg entry point and then proceed to release things in the
 *	wrong order we will make no attempt to behave in a predictable fashion.
 *	Keep in mind that the correct method for placing a message into an
 *	attachment is to call OpenProperty where the source interface is
 *	IID_IMessage.  The IStorage interface is supported to allow an easy way
 *	to stick a WWord doc. into an attachment w/o converting to/from IStream.
 *
 */
STDAPI_(SCODE) OpenIMsgOnIStg(
	LPMSGSESS		lpMsgSess,			/* -> message session obj (optional) */
	LPALLOCATEBUFFER lpAllocateBuffer,	/* -> AllocateBuffer memory routine  */
	LPALLOCATEMORE 	lpAllocateMore, 	/* -> AllocateMore memory routine    */
	LPFREEBUFFER	lpFreeBuffer, 		/* -> FreeBuffer memory routine      */
	LPMALLOC		lpMalloc,			/* -> Co malloc object				 */
	LPVOID			lpMapiSup,			/* -> MAPI Support Obj (optional)    */
	LPSTORAGE 		lpStg, 				/* -> open IStorage containing msg   */
	MSGCALLRELEASE FAR *lpfMsgCallRelease,	/* -> release callback rtn (opt) */
	ULONG			ulCallerData,		/* caller data returned in callback  */
	ULONG			ulFlags,			/* -> flags (controls istg commit)   */
	LPMESSAGE		FAR *lppMsg );		/* <- open message object			 */

#define IMSG_NO_ISTG_COMMIT		((ULONG) 0x00000001)


/* NOTE: Property Attributes are specific to this IMessage on IStorage 		*/
/* implementation and are not a part of standard MAPI 1.0 property methods 	*/

/* Property Attributes */

#define PROPATTR_MANDATORY		((ULONG) 0x00000001)
#define PROPATTR_READABLE		((ULONG) 0x00000002)
#define PROPATTR_WRITEABLE		((ULONG) 0x00000004)

#define PROPATTR_NOT_PRESENT	((ULONG) 0x00000008)

/* Attribute Array */

typedef struct _SPropAttrArray
{
	ULONG	cValues;							
	ULONG	aPropAttr[MAPI_DIM];
} SPropAttrArray, FAR * LPSPropAttrArray;

#define CbNewSPropAttrArray(_cattr) \
	(offsetof(SPropAttrArray,aPropAttr) + (_cattr)*sizeof(ULONG))
#define CbSPropAttrArray(_lparray) \
	(offsetof(SPropAttrArray,aPropAttr) + \
	(UINT)((_lparray)->cValues)*sizeof(ULONG))

#define SizedSPropAttrArray(_cattr, _name) \
struct _SPropAttrArray_ ## _name \
{ \
	ULONG	cValues; \
	ULONG	aPropAttr[_cattr]; \
} _name



/*	GetAttribIMsgOnIStg - To get attributes on properties
 *
 *	This call is provided because there is no method of IMAPIPropSet to allow
 *	getting attributes.
 */
STDAPI GetAttribIMsgOnIStg(
	LPVOID					lpObject,
	LPSPropTagArray			lpPropTagArray,
	LPSPropAttrArray FAR 	*lppPropAttrArray );

/*	SetAttribIMsgOnIStg - To set attributes on properties
 *
 *	This call is provided because there is no method of IMAPIPropSet to allow
 *	setting of attributes.
 */
STDAPI SetAttribIMsgOnIStg(
	LPVOID					lpObject,
	LPSPropTagArray			lpPropTags,
	LPSPropAttrArray		lpPropAttrs,
	LPSPropProblemArray FAR	*lppPropProblems );

/*	MapStorageSCode - To map an IStorage hResult to a MAPI sCode value
 *
 *	This call is provided for the internal use of PDK components that base
 *	their message implementations on IMessage.  Since these components must
 *	open the storage themselves, there is a common need to map OLE 2.0
 *	Storage error returns to MAPI sCodes.
 *
 *	WARNING:	There is no guarantee that this entry point will exist in
 *	shipped versions of mapiu.dll.
 */
STDAPI_(SCODE) MapStorageSCode( SCODE StgSCode );


#ifdef __cplusplus
}
#endif

#endif	/* _IMESSAGE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ipxrip.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    ipxrip.h

Abstract:

    This module contains the definitions of the:

    interface management APIs structures
    rip MIB management APIs structures

Author:

    Stefan Solomon  06/30/1995

Revision History:


--*/

#ifndef _IPXRIP_
#define _IPXRIP_

#if _MSC_VER > 1000
#pragma once
#endif

#include <ipxconst.h>

typedef struct _RIP_GLOBAL_INFO {
    DWORD       EventLogMask;
} RIP_GLOBAL_INFO, *PRIP_GLOBAL_INFO;

//********************************************************************
//								     *
//		    RIP Configuration Information		     *
//								     *
//********************************************************************


//*** RIP Interface Only Information ***

typedef struct _RIP_IF_INFO {

    ULONG	    AdminState;  // The desired state of the interface
    ULONG	    UpdateMode;	// RIP update mechanism used on this interface
    ULONG	    PacketType;  // The RIP packet type used on this interface
    ULONG	    Supply; // Send RIP updates on this interface
    ULONG	    Listen; // Listen to RIP updates on this interface
    ULONG	    PeriodicUpdateInterval; // in seconds - default 60
    ULONG	    AgeIntervalMultiplier; // default - 3

    } RIP_IF_INFO, *PRIP_IF_INFO;

// UpdateMode Values:
//
// This parameter controls the RIP	database update on this interface.
//
// If this is a LAN interface, use IPX_PERIODIC_UPDATE as default.
// If this is a WAN router interface with static routes, use IPX_NO_UPDATE as default.
// If you want to trigger an update on this interface and to keep the data
// as static data, use IPX_AUTO_STATIC value.
// IPX_AUTO_STATIC update can be set only on a WAN interface
//
// PacketType Default Values:
//
// If UpdateMode is set to IPX_NO_UPDATE, this field is meaningless.
// If this is a LAN interface, use IPX_STANDARD_PACKET_TYPE as default.
// If you want reliable delivery of the update data in a triggered update,
// use IPX_RELIABLE_DELIVERY_PACKET_TYPE (this can be set only in combination with
// IPX_AUTO_STATIC_UPDATE in the UpdateMode).

// RIP Route Filter Info
//
// These filters apply to routes accepted or advertised by RIP on each interface.

typedef struct _RIP_ROUTE_FILTER_INFO {

    UCHAR	    Network[4];
    UCHAR	    Mask[4];

    } RIP_ROUTE_FILTER_INFO, *PRIP_ROUTE_FILTER_INFO;

//*** RIP Filters Only Information ***
//
//  This header is followed by RIP_ROUTE_FILTER_STRUCTURES in order:
//  First Supply filters
//  Next Listen filters

typedef struct _RIP_IF_FILTERS {

    ULONG		    SupplyFilterAction;
    ULONG		    SupplyFilterCount;
    ULONG		    ListenFilterAction;
    ULONG		    ListenFilterCount;
    RIP_ROUTE_FILTER_INFO   RouteFilter[1];

    } RIP_IF_FILTERS, *PRIP_IF_FILTERS;

// FilterAction -

#define IPX_ROUTE_FILTER_PERMIT	    1
#define IPX_ROUTE_FILTER_DENY	    2

//
//*** RIP Interface Configuration Information ***
//
// This structure is passed in AddInterface and SetInterface Entry Points
//

typedef struct _RIP_IF_CONFIG {

    RIP_IF_INFO     RipIfInfo;
    RIP_IF_FILTERS  RipIfFilters;

    } RIP_IF_CONFIG, *PRIP_IF_CONFIG;

// ***********************************************************
// ***							   ***
// ***		RIP MIB Table Identifiers		   ***
// ***							   ***
// ***********************************************************


#define RIP_BASE_ENTRY			    0
#define RIP_INTERFACE_TABLE		    1

//************************************************************
//							     *
//		RIP MIB Basic Structures		     *
//							     *
//************************************************************

//
// RIP MIB Base Entry
//

typedef struct _RIPMIB_BASE {

    ULONG	    RIPOperState;

    } RIPMIB_BASE, *PRIPMIB_BASE;


//
// RIP MIB Interface Table Entry
//

typedef struct _RIP_IF_STATS {

    ULONG		    RipIfOperState;   // up, down or sleeping
    ULONG		    RipIfInputPackets;
    ULONG		    RipIfOutputPackets;

    } RIP_IF_STATS, *PRIP_IF_STATS;



typedef struct _RIP_INTERFACE {

    ULONG	    InterfaceIndex;
    RIP_IF_INFO	    RipIfInfo;
    RIP_IF_STATS    RipIfStats;

    } RIP_INTERFACE, *PRIP_INTERFACE;

//***************************************************************
//								*
//	     INPUT DATA For: Get, GetFirst, GetNext		*
//								*
//***************************************************************

typedef struct _RIP_MIB_GET_INPUT_DATA {

    ULONG		TableId;
    ULONG		InterfaceIndex;

    } RIP_MIB_GET_INPUT_DATA, *PRIP_MIB_GET_INPUT_DATA;

//***************************************************************
//								*
//	     INPUT DATA For: Create, Delete, Set		*
//								*
//***************************************************************

typedef struct _RIP_MIB_SET_INPUT_DATA {

    ULONG		 TableId;
    RIP_INTERFACE	 RipInterface;

    } RIP_MIB_SET_INPUT_DATA, *PRIP_MIB_SET_INPUT_DATA;

//
// ***			RIP Base Entry					***
//

// MIB Functions: Get

// INPUT DATA: RIP_MIB_GET_INPUT_DATA and Index is not used

// OUTPUT DATA: RIP_INTERFACE

//
// ***			RIP Interface Table				    ***
//

// MIB Functions: Get, GetFirst, GetNext, Set

// INPUT DATA: RIP_MIB_GET_INPUT_DATA for Get, GetFirst and GetNext
//	       RIP_MIB_SET_INPUT_DATA for Set

//
// OUTPUT DATA: RIP_INTERFACE
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ftapi.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    ftapi.h

Abstract:

    This header file defines the FT API to be used as the interface to
    user mode programs for creating and administering FT sets.

Author:

    Norbert Kusters 13-July-1996

Notes:

Revision History:

--*/

#ifndef __FTAPI_H__
#define __FRAPI_H__

#if _MSC_VER > 1000
#pragma once
#endif

#include <fttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef int BOOL;
typedef BOOL *PBOOL;

//
// This API creates a logical disk id for a given partition.
//

BOOL
FtCreatePartitionLogicalDisk(
    IN  HANDLE              PartitionHandle,
    OUT PFT_LOGICAL_DISK_ID NewLogicalDiskId
    );

//
// The create logical disk API is used to construct a new logical disk.
//

BOOL
FtCreateLogicalDisk(
    IN  FT_LOGICAL_DISK_TYPE    LogicalDiskType,
    IN  USHORT                  NumberOfMembers,
    IN  PFT_LOGICAL_DISK_ID     RootLogicalDiskIds,
    IN  USHORT                  ConfigurationInformationSize,
    IN  PVOID                   ConfigurationInformation,
    OUT PFT_LOGICAL_DISK_ID     NewLogicalDiskId
    );

//
// The initialize logical disk API triggers the initialization of a new
// logical disk.  This API is separate from the create logical disk API
// so that complex logical disks may be constructed and put together before
// starting initialization.
//

BOOL
FtInitializeLogicalDisk(
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId,
    IN  BOOL                RegenerateOrphans
    );

//
// This API breaks up a logical disk into its sub-components.
//

BOOL
FtBreakLogicalDisk(
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId
    );

//
// This API returns an array with all of the logical disk ids for all
// of the root logical disks in the system.  When 'ArraySize' is passed in
// as 0, the array is not returned but the number of root logical disk ids
// is returned in 'NumberOfRootLogicalDiskIds'.
//

BOOL
FtEnumerateLogicalDisks(
    IN  ULONG               ArraySize,
    OUT PFT_LOGICAL_DISK_ID RootLogicalDiskIds,         /* OPTIONAL */
    OUT PULONG              NumberOfRootLogicalDiskIds
    );

//
// This API returns information about a given logical disk.
//

BOOL
FtQueryLogicalDiskInformation(
    IN  FT_LOGICAL_DISK_ID      LogicalDiskId,
    OUT PFT_LOGICAL_DISK_TYPE   LogicalDiskType,                /* OPTIONAL */
    OUT PLONGLONG               VolumeSize,                     /* OPTIONAL */
    IN  USHORT                  MembersArraySize,
    OUT PFT_LOGICAL_DISK_ID     Members,                        /* OPTIONAL */
    OUT PUSHORT                 NumberOfMembers,                /* OPTIONAL */
    IN  USHORT                  ConfigurationInformationSize,
    OUT PVOID                   ConfigurationInformation,       /* OPTIONAL */
    IN  USHORT                  StateInformationSize,
    OUT PVOID                   StateInformation                /* OPTIONAL */
    );

//
// This API orphans a member of a logical disk.
//

BOOL
FtOrphanLogicalDiskMember(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  USHORT              MemberNumberToOrphan
    );

//
// This API replaces a member of a logical disk.
//

BOOL
FtReplaceLogicalDiskMember(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  USHORT              MemberNumberToReplace,
    IN  FT_LOGICAL_DISK_ID  NewMemberLogicalDiskId,
    OUT PFT_LOGICAL_DISK_ID NewLogicalDiskId            /* OPTIONAL */
    );

//
// This API returns the logical disk id for a given logical disk handle.
//

BOOL
FtQueryLogicalDiskId(
    IN  HANDLE              RootLogicalDiskHandle,
    OUT PFT_LOGICAL_DISK_ID RootLogicalDiskId
    );

//
// This API opens a partition, given a signature and offset.
//

HANDLE
FtOpenPartition(
    IN  ULONG       Signature,
    IN  LONGLONG    Offset
    );

//
// This API returns when there is a change to the overall FT state.
//

BOOL
FtChangeNotify(
    );

//
// This API stops all sync operations on the given logical disk.
//

BOOL
FtStopSyncOperations(
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId
    );

//
// This API queries the sticky drive letter for the given root logical disk.
//

BOOL
FtQueryStickyDriveLetter(
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId,
    OUT PUCHAR              DriveLetter
    );

//
// This API sets the sticky drive letter for the given root logical disk.
//

BOOL
FtSetStickyDriveLetter(
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId,
    IN  UCHAR               DriveLetter
    );

//
// This API returns whether or not enough members of the given logical
// disk are online so that IO is possible on all parts of the volume.
//

BOOL
FtCheckIo(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    OUT PBOOL               IsIoOk
    );

//
// This API returns whether or not the FTDISK driver is loaded.
//

BOOL
FtCheckDriver(
    OUT PBOOL   IsDriverLoaded
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\frsapip.h ===
/*++ BUILD Version: 0001    Increment if a change has global effects

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    frsapip.h

Abstract:

    Header file for the application programmer's interfaces to the
    Microsoft File Replication Service (NtFrs).


    These APIs provide support for backup and restore.

Environment:

    User Mode - Win32

Notes:

--*/
#ifndef _FRSAPIP_H_
#define _FRSAPIP_H_

#ifdef __cplusplus
extern "C" {
#endif



//
// Replica set types.
//
#define NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE    L"Enterprise"
#define NTFRSAPI_REPLICA_SET_TYPE_DOMAIN        L"Domain"
#define NTFRSAPI_REPLICA_SET_TYPE_DFS           L"DFS"
#define NTFRSAPI_REPLICA_SET_TYPE_OTHER         L"Other"


//
// BACKUP/RESTORE API
//

#define NTFRSAPI_BUR_FLAGS_NONE                         (0x00000000)
#define NTFRSAPI_BUR_FLAGS_AUTHORITATIVE                (0x00000001)
#define NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE            (0x00000002)
#define NTFRSAPI_BUR_FLAGS_PRIMARY                      (0x00000004)
#define NTFRSAPI_BUR_FLAGS_SYSTEM                       (0x00000008)
#define NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY             (0x00000010)
#define NTFRSAPI_BUR_FLAGS_NORMAL                       (0x00000020)
#define NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES  (0x00000040)
#define NTFRSAPI_BUR_FLAGS_RESTORE                      (0x00000080)
#define NTFRSAPI_BUR_FLAGS_BACKUP                       (0x00000100)
#define NTFRSAPI_BUR_FLAGS_RESTART                      (0x00000200)

#define NTFRSAPI_BUR_FLAGS_TYPES_OF_RESTORE \
                    (NTFRSAPI_BUR_FLAGS_AUTHORITATIVE       | \
                     NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE   | \
                     NTFRSAPI_BUR_FLAGS_PRIMARY)

#define NTFRSAPI_BUR_FLAGS_MODES_OF_RESTORE \
                    (NTFRSAPI_BUR_FLAGS_SYSTEM           | \
                     NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY | \
                     NTFRSAPI_BUR_FLAGS_NORMAL)

#define NTFRSAPI_BUR_FLAGS_SUPPORTED_RESTORE \
                    (NTFRSAPI_BUR_FLAGS_AUTHORITATIVE        | \
                     NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE    | \
                     NTFRSAPI_BUR_FLAGS_PRIMARY              | \
                     NTFRSAPI_BUR_FLAGS_SYSTEM               | \
                     NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY     | \
                     NTFRSAPI_BUR_FLAGS_NORMAL               | \
                     NTFRSAPI_BUR_FLAGS_RESTORE              | \
                     NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES)

#define NTFRSAPI_BUR_FLAGS_SUPPORTED_BACKUP \
                    (NTFRSAPI_BUR_FLAGS_NORMAL | \
                     NTFRSAPI_BUR_FLAGS_BACKUP)



DWORD
WINAPI
NtFrsApiInitializeBackupRestore(
    IN  DWORD   ErrorCallBack(IN PWCHAR, IN ULONG), OPTIONAL
    IN  DWORD   BurFlags,
    OUT PVOID   *BurContext
    );
/*++
Routine Description:
    Called once in the lifetime of a backup/restore process. Must be
    matched with a subsequent call to NtFrsApiDestroyBackupRestore().

    Prepare the system for the backup or restore specified by BurFlags.
    Currently, the following combinations are supported:
    ASR - Automated System Recovery
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_SYSTEM |
        NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES |
        NTFRSAPI_BUR_FLAGS_PRIMARY or NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE

    DSR - Distributed Services Restore (all sets)
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY |
        NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES |
        NTFRSAPI_BUR_FLAGS_PRIMARY or NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE

    DSR - Distributed Services Restore (just the sysvol)
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY
        (may be followed by subsequent calls to NtFrsApiRestoringDirectory())

    Normal Restore - System is up and running; just restoring files
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_NORMAL |
        NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES |
        NTFRSAPI_BUR_FLAGS_AUTHORITATIVE

    Normal Backup
        NTFRSAPI_BUR_FLAGS_BACKUP |
        NTFRSAPI_BUR_FLAGS_NORMAL

Arguments:
    ErrorCallBack   - Ignored if NULL.
                      Address of function provided by the caller. If
                      not NULL, this function calls back with a formatted
                      error message and the error code that caused the
                      error.
    BurFlags        - See above for the supported combinations
    BurContext      - Opaque context for this process

Return Value:

    Win32 Status

--*/




DWORD
WINAPI
NtFrsApiDestroyBackupRestore(
    IN     PVOID    *BurContext,
    IN     DWORD    BurFlags,
    OUT    HKEY     *HKey,
    IN OUT DWORD    *KeyPathSizeInBytes,
    OUT    PWCHAR   KeyPath
    );
/*++
Routine Description:
    Called once in the lifetime of a backup/restore process. Must be
    matched with a previous call to NtFrsApiInitializeBackupRestore().

    If NtFrsApiInitializeBackupRestore() was called with:
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_SYSTEM or NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY
    then BurFlags may be set to one of:
        NTFRSAPI_BUR_FLAGS_NONE - Do not restart the service. The key
            specified by (HKey, KeyPath) must be moved into the final
            registry.
        NTFRSAPI_BUR_FLAGS_RESTART - Restart the service. HKey,
            KeyPathSizeInBytes, and KeyPath must be NULL.

    If NtFrsApiInitializeBackupRestore() was not called the above flags,
    then BurFlags must be NTFRSAPI_BUR_FLAGS_NONE and HKey, KeyPathSizeInBytes,
    and KeyPath must be NULL.

Arguments:
    BurContext          - Returned by previous call to
                          NtFrsApiInitializeBackupRestore().

    BurFlags            - Backup/Restore Flags. See Routine Description.

    HKey                - Address of a HKEY for that will be set to
                          HKEY_LOCAL_MACHINE, ...
                          NULL if BurContext is not for a System or
                          Active Directory restore or Restart is set.

    KeyPathSizeInBytes  - Address of of a DWORD specifying the size of
                          KeyPath. Set to the actual number of bytes
                          needed by KeyPath. ERROR_INSUFFICIENT_BUFFER
                          is returned if the size of KeyPath is too small.
                          NULL if BurContext is not for a System or
                          Active Directory restore or Restart is set.

    KeyPath             - Buffer to receive the path of the registry key.
                          NULL if BurContext is not for a System or
                          Active Directory restore or Restart is set.

Return Value:

    Win32 Status

--*/




DWORD
WINAPI
NtFrsApiGetBackupRestoreSets(
    IN PVOID BurContext
    );
/*++
Routine Description:
    Cannot be called if BurContext is for a System restore.

    Retrieves information about the current replicated directories
    (AKA replica sets).

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()

Return Value:

    Win32 Status

--*/




DWORD
WINAPI
NtFrsApiEnumBackupRestoreSets(
    IN  PVOID   BurContext,
    IN  DWORD   BurSetIndex,
    OUT PVOID   *BurSet
    );
/*++
Routine Description:
    Returns ERROR_NO_MORE_ITEMS if BurSetIndex exceeds the number of
    sets returned by NtFrsApiGetBackupRestoreSets().

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()
    BurSetIndex - Index of set. Starts at 0.
    BurSet      - Opaque struct representing a replicating directory.

Return Value:

    Win32 Status
--*/




DWORD
WINAPI
NtFrsApiIsBackupRestoreSetASysvol(
    IN  PVOID    BurContext,
    IN  PVOID    BurSet,
    OUT BOOL     *IsSysvol
    );
/*++
Routine Description:
    Does the specified BurSet represent a replicating SYSVOL share?

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()
    BurSet      - Opaque struct representing a replicating directory.
                  Returned by NtFrsApiEnumBackupRestoreSets(). Not
                  valid across calls to NtFrsApiGetBackupRestoreSets().
    IsSysvol    - TRUE : set is a system volume (AKA SYSVOL).
                  FALSE: set is a not a system volume (AKA SYSVOL).

Return Value:

    Win32 Status
--*/




DWORD
WINAPI
NtFrsApiGetBackupRestoreSetDirectory(
    IN     PVOID    BurContext,
    IN     PVOID    BurSet,
    IN OUT DWORD    *DirectoryPathSizeInBytes,
    OUT    PWCHAR   DirectoryPath
    );
/*++
Routine Description:
    Return the path of the replicating directory represented by BurSet.

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()
    BurSet      - Opaque struct representing a replicating directory.
                  Returned by NtFrsApiEnumBackupRestoreSets(). Not
                  valid across calls to NtFrsApiGetBackupRestoreSets().
    DirectoryPathSizeInBytes    - Address of DWORD giving size of
                                  DirectoryPath. Cannot be NULL.
                                  Set to the number of bytes needed
                                  to return DirectoryPath.
                                  ERROR_INSUFFICIENT_BUFFER is returned if
                                  DirectoryPath is too small.
    DirectoryPath               - Buffer that is *DirectoryPathSizeInBytes
                                  bytes in length. Contains path of replicating
                                  directory.
Return Value:

    Win32 Status
--*/




DWORD
WINAPI
NtFrsApiGetBackupRestoreSetPaths(
    IN     PVOID    BurContext,
    IN     PVOID    BurSet,
    IN OUT DWORD    *PathsSizeInBytes,
    OUT    PWCHAR   Paths,
    IN OUT DWORD    *FiltersSizeInBytes,
    OUT    PWCHAR   Filters
    );
/*++
Routine Description:
    Return a multistring that contains the paths to other files
    and directories needed for proper operation of the replicated
    directory represented by BurSet. Return another multistring
    that details the backup filters to be applied to the paths
    returned by this function and the path returned by
    NtFrsApiGetBackupRestoreSetDirectory().

    The paths may overlap the replicated directory.

    The paths may contain nested entries.

    Filters is a multistring in the same format as the values for
    the registry key FilesNotToBackup.

    The replicated directory can be found with
    NtFrsApiGetBackupRestoreSetDirectory(). The replicated directory
    may overlap one or more entries in Paths.

    ERROR_PATH_NOT_FOUND is returned if the paths could not be
    determined.

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()
    BurSet      - Opaque struct representing a replicating directory.
                  Returned by NtFrsApiEnumBackupRestoreSets(). Not
                  valid across calls to NtFrsApiGetBackupRestoreSets().

    PathsSizeInBytes  - Address of DWORD giving size of Paths.
                        Cannot be NULL. Set to the number of bytes
                        needed to return Paths.
                        ERROR_INSUFFICIENT_BUFFER is returned if
                        Paths is too small.

    Paths             - Buffer that is *PathsSizeInBytes
                        bytes in length. Contains the paths of the
                        other files and directories needed for proper
                        operation of the replicated directory.

    FiltersSizeInBytes  - Address of DWORD giving size of Filters.
                          Cannot be NULL. Set to the number of bytes
                          needed to return Filters.
                          ERROR_INSUFFICIENT_BUFFER is returned if
                          Filters is too small.

    Filters             - Buffer that is *FiltersSizeInBytes bytes in
                          length. Contains the backup filters to be
                          applied to Paths, the contents of directories
                          in Paths, and the replicated directory.
Return Value:

    Win32 Status
--*/




DWORD
WINAPI
NtFrsApiRestoringDirectory(
    IN  PVOID   BurContext,
    IN  PVOID   BurSet,
    IN  DWORD   BurFlags
    );
/*++
Routine Description:
    The backup/restore application is about to restore the directory
    specified by BurSet (See NtFrsApiEnumBackupRestoreSets()). Matched
    with a later call to NtFrsApiFinishedRestoringDirectory().

    This call is supported only if NtFrsApiInitializeBackupRestore()
    were called with the flags:
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY

    BurFlags can be NTFRSAPI_BUR_FLAGS_PRIMARY or
    NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE and overrides any value
    specified in the call to NtFrsApiInitializeBackupRestore().

Arguments:
    BurContext      - Opaque context from NtFrsApiInitializeBackupRestore()
    BurSet          - Opaque set from NtFrsApiEnumBackupRestoreSets();
    BurFlags        - See above for the supported combinations

Return Value:

    Win32 Status

--*/




DWORD
WINAPI
NtFrsApiFinishedRestoringDirectory(
    IN  PVOID   BurContext,
    IN  PVOID   BurSet,
    IN  DWORD   BurFlags
    );
/*++
Routine Description:
    Finished restoring directory for BurSet. Matched by a previous call
    to NtFrsApiRestoringDirectory().

    This call is supported only if NtFrsApiInitializeBackupRestore()
    were called with the flags:
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY

    BurFlags must be NTFRSAPI_BUR_FLAGS_NONE.

Arguments:
    BurContext      - Opaque context from NtFrsApiInitializeBackupRestore()
    BurSet          - Opaque set from NtFrsApiEnumBackupRestoreSets();
    BurFlags        - See above for the supported combinations

Return Value:

    Win32 Status

--*/


#define NTFRSAPI_MAX_INTERVAL           ((((ULONG)0x7FFFFFFF) / 1000) / 60)
#define NTFRSAPI_MIN_INTERVAL           (1)
#define NTFRSAPI_DEFAULT_LONG_INTERVAL  (1 * 60)    // 1 hour
#define NTFRSAPI_DEFAULT_SHORT_INTERVAL (5)         // 5 minutes



DWORD
WINAPI
NtFrsApi_Set_DsPollingIntervalW(
    IN PWCHAR   ComputerName,       OPTIONAL
    IN ULONG    UseShortInterval,
    IN ULONG    LongInterval,
    IN ULONG    ShortInterval
    );
/*++
Routine Description:

    The NtFrs service polls the DS occasionally for configuration changes.
    This API alters the polling interval and, if the service is not
    in the middle of a polling cycle, forces the service to begin a
    polling cycle.

    The service uses the long interval by default. The short interval
    is used after the ds configuration has been successfully
    retrieved and the service is now verifying that the configuration
    is not in flux. This API can be used to force the service to use
    the short interval until a stable configuration has been retrieved.
    After which, the service reverts back to the long interval.

    The default values for ShortInterval and LongInterval can be
    changed by setting the parameters to a non-zero value. If zero,
    the current values remain unchanged and a polling cycle is initiated.

Arguments:

    ComputerName     - Poke the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.

    UseShortInterval - If non-zero, the service switches to the short
                       interval until a stable configuration is retrieved
                       from the DS or another call to this API is made.
                       Otherwise, the service uses the long interval.

    LongInterval     - Minutes between polls of the DS. The value must fall
                       between NTFRSAPI_MIN_INTERVAL and NTFRSAPI_MAX_INTERVAL,
                       inclusive. If 0, the interval is unchanged.

    ShortInterval    - Minutes between polls of the DS. The value must fall
                       between NTFRSAPI_MIN_INTERVAL and NTFRSAPI_MAX_INTERVAL,
                       inclusive. If 0, the interval is unchanged.

Return Value:

    Win32 Status
--*/




DWORD
WINAPI
NtFrsApi_Get_DsPollingIntervalW(
    IN  PWCHAR  ComputerName,       OPTIONAL
    OUT ULONG   *Interval,
    OUT ULONG   *LongInterval,
    OUT ULONG   *ShortInterval
    );
/*++
Routine Description:

    The NtFrs service polls the DS occasionally for configuration changes.
    This API returns the values the service uses for polling intervals.

    The service uses the long interval by default. The short interval
    is used after the ds configuration has been successfully
    retrieved and the service is now verifying that the configuration
    is not in flux. The short interval is also used if the
    NtFrsApi_Set_DsPollingIntervalW() is used to force usage of the short
    interval until a stable configuration has been retrieved. After which,
    the service reverts back to the long interval.

    The value returned in Interval is the polling interval currently in
    use.

Arguments:

    ComputerName     - Poke the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.

    Interval         - The current polling interval in minutes.

    LongInterval     - The long interval in minutes.

    ShortInterval    - The short interval in minutes.

Return Value:

    Win32 Status
--*/





#ifdef __cplusplus
}
#endif

#endif  _FRSAPIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ipxsap.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    ipxsap.h

Abstract:

    This module contains the definitions of the:

    interface management APIs structures
    sap global management APIs structures
    sap MIB management APIs structures

Author:

    Stefan Solomon  06/30/1995

Revision History:


--*/

#ifndef _IPXSAP_
#define _IPXSAP_

#if _MSC_VER > 1000
#pragma once
#endif

#include <ipxconst.h>

typedef struct _SAP_GLOBAL_INFO {
    DWORD       EventLogMask;
} SAP_GLOBAL_INFO, *PSAP_GLOBAL_INFO;

//********************************************************************
//								     *
//		    SAP Configuration Information		     *
//								     *
//********************************************************************

//*** SAP Interface Configuration Information ***

typedef struct _SAP_IF_INFO {

    ULONG	    AdminState;  // The desired state of the interface
    ULONG	    UpdateMode;	// SAP update mechanism used on this interface
    ULONG	    PacketType;  // The SAP packet type used on this interface
    ULONG	    Supply; // Send SAP updates on this interface
    ULONG	    Listen; // Listen to SAP updates on this interface
    ULONG	    GetNearestServerReply; // Reply to GetNearestServer
    ULONG	    PeriodicUpdateInterval; // in seconds - default 60
    ULONG	    AgeIntervalMultiplier; // default 3

    } SAP_IF_INFO, *PSAP_IF_INFO;

// UpdateMode Values:
//
// This parameter controls the SAP	database update on this interface.
//
// If this is a LAN interface, use IPX_PERIODIC_UPDATE as default.
// If this is a WAN router interface with static routes, use IPX_NO_UPDATE as default.
// If you want to trigger an update on this interface and to keep the data
// as static data, use IPX_AUTO_STATIC value.
// IPX_AUTO_STATIC update can be set only on a WAN interface
//
// PacketType Default Values:
//
// If UpdateMode is set to IPX_NO_UPDATE, this field is meaningless.
// If this is a LAN interface, use IPX_STANDARD_PACKET_TYPE as default.
// If you want reliable delivery of the update data in a triggered update,
// use IPX_RELIABLE_DELIVERY_PACKET_TYPE (this can be set only in combination with
// IPX_AUTO_STATIC_UPDATE in the UpdateMode).


// IPX Service Filter Info
//

typedef struct _SAP_SERVICE_FILTER_INFO {
    union {
        USHORT	    ServiceType;
        ULONG       ServiceType_align;  // Ensures aligment
        };
    UCHAR	    ServiceName[48];
    } SAP_SERVICE_FILTER_INFO, *PSAP_SERVICE_FILTER_INFO;

// ServiceType - a wildcard (0xFFFF) means any type.

// ServiceName - (1-47)chars service name. A null byte as the first byte
// signifies ANY server of this type

//*** SAP Filters Only Information ***

typedef struct _SAP_IF_FILTERS {

    ULONG		    SupplyFilterAction;
    ULONG		    SupplyFilterCount;
    ULONG		    ListenFilterAction;
    ULONG		    ListenFilterCount;
    SAP_SERVICE_FILTER_INFO ServiceFilter[1];

    } SAP_IF_FILTERS, *PSAP_IF_FILTERS;

// FilterAction -

#define IPX_SERVICE_FILTER_PERMIT	    1
#define IPX_SERVICE_FILTER_DENY 	    2

//
//*** SAP Interface Configuration Information ***
//
// This structure is passed in AddInterface and SetInterface Entry Points
//

typedef struct _SAP_IF_CONFIG {

    SAP_IF_INFO	    SapIfInfo;
    SAP_IF_FILTERS  SapIfFilters;

    } SAP_IF_CONFIG, *PSAP_IF_CONFIG;


// ***********************************************************
// ***							   ***
// ***		SAP MIB Table Identifiers		   ***
// ***							   ***
// ***********************************************************


#define SAP_BASE_ENTRY			    0
#define SAP_INTERFACE_TABLE		    1

//************************************************************
//							     *
//		SAP MIB Basic Structures		     *
//							     *
//************************************************************

//
// SAP MIB Base Entry
//

typedef struct _SAP_MIB_BASE {

    ULONG	    SapOperState;

    } SAP_MIB_BASE, *PSAP_MIB_BASE;


//
// SAP MIB Interface Table Entry
//

typedef struct _SAP_IF_STATS {

    ULONG		    SapIfOperState;   // up, down or sleeping
    ULONG		    SapIfInputPackets;
    ULONG		    SapIfOutputPackets;

    } SAP_IF_STATS, *PSAP_IF_STATS;


typedef struct _SAP_INTERFACE {

    ULONG	    InterfaceIndex;
    SAP_IF_INFO	    SapIfInfo;
    SAP_IF_STATS    SapIfStats;

    } SAP_INTERFACE, *PSAP_INTERFACE;

//***************************************************************
//								*
//	     INPUT DATA For: Get, GetFirst, GetNext		*
//								*
//***************************************************************

typedef struct _SAP_MIB_GET_INPUT_DATA {

    ULONG		TableId;
    ULONG		InterfaceIndex;

    } SAP_MIB_GET_INPUT_DATA, *PSAP_MIB_GET_INPUT_DATA;

//***************************************************************
//								*
//	     INPUT DATA For: Create, Delete, Set		*
//								*
//***************************************************************

typedef struct _SAP_MIB_SET_INPUT_DATA {

    ULONG				TableId;
	SAP_INTERFACE		SapInterface;
    } SAP_MIB_SET_INPUT_DATA, *PSAP_MIB_SET_INPUT_DATA;

//
// ***			SAP Base Entry					***
//

// MIB Functions: Get

// INPUT DATA: SAP_MIB_GET_INPUT_DATA and Index is not used

// OUTPUT DATA: SAP_INTERFACE

//
// ***			SAP Interface Table				    ***
//

// MIB Functions: Get, GetFirst, GetNext, Set

// INPUT DATA: SAP_MIB_GET_INPUT_DATA for Get, GetFirst and GetNext
//	       SAP_MIB_SET_INPUT_DATA for Set

//
// OUTPUT DATA: SAP_INTERFACE
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\irtranp.h ===
//--------------------------------------------------------------------
// Copyright (c)1998-1999 Microsoft Corporation, All Rights Reserved.
//
// irtranp.h
//
// Shared constants and Types for IrTran-P Camera Protocol.
//
// Author:
//
//   Edward Reus (edwardr)     08-17-98   Initial coding.
//
//--------------------------------------------------------------------


#ifndef _IRTRANP_H_
#define _IRTRANP_H_

#if _MSC_VER > 1000
#pragma once
#endif

//--------------------------------------------------------------------
// Extra Internal Protocol Specific Error Codes:
//--------------------------------------------------------------------

#define  FACILITY_IRTRANP                  32

//       Out of memory:
#define  ERROR_IRTRANP_OUT_OF_MEMORY        \
         MAKE_HRESULT(SEVERITY_ERROR,FACILITY_IRTRANP,1)

//       Ran out of disk space:
#define  ERROR_IRTRANP_DISK_FULL            \
         MAKE_HRESULT(SEVERITY_ERROR,FACILITY_IRTRANP,2)

//       SCEP protocol error:
#define  ERROR_SCEP_INVALID_PROTOCOL        \
         MAKE_HRESULT(SEVERITY_ERROR,FACILITY_IRTRANP,3)

//       Disconnect from the camera:
#define  ERROR_SCEP_UNSPECIFIED_DISCONNECT  \
         MAKE_HRESULT(SEVERITY_ERROR,FACILITY_IRTRANP,4)

//       User cancel:
#define  ERROR_SCEP_USER_DISCONNECT         \
         MAKE_HRESULT(SEVERITY_ERROR,FACILITY_IRTRANP,5)

//       Lower level Irda disconnect:
#define  ERROR_SCEP_PROVIDER_DISCONNECT     \
         MAKE_HRESULT(SEVERITY_ERROR,FACILITY_IRTRANP,6)

//       Error when creating picture file:
#define  ERROR_SCEP_CANT_CREATE_FILE        \
         MAKE_HRESULT(SEVERITY_ERROR,FACILITY_IRTRANP,7)

//       Protocol error: PDU too large:
#define  ERROR_SCEP_PDU_TOO_LARGE           \
         MAKE_HRESULT(SEVERITY_ERROR,FACILITY_IRTRANP,8)

//       Received abort PDU:
#define  ERROR_SCEP_ABORT                   \
         MAKE_HRESULT(SEVERITY_ERROR,FACILITY_IRTRANP,9)

//       Invalid protocol (bFTP):
#define  ERROR_BFTP_INVALID_PROTOCOL        \
         MAKE_HRESULT(SEVERITY_ERROR,FACILITY_IRTRANP,10)

//       Unexpected end of transmission of the picture:
#define  ERROR_BFTP_NO_MORE_FRAGMENTS       \
         MAKE_HRESULT(SEVERITY_ERROR,FACILITY_IRTRANP,11)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\gpedit.h ===
//-----------------------------------------------------------------------------
//
// GPEDIT.H - Definitions and prototypes for Group Policy
//
// Copyright 1997-2000, Microsoft Corporation
//
//-----------------------------------------------------------------------------

//
// Terminology
//
// Group Policy Editor  -  The tool to view a Group Policy Object.
//
// Group Policy Object  -  A collection of administrator defined policies.
//                         Each Group Policy Object (GPO) has both file system
//                         and Active Directory storage available to it.
//
// IGPEInformation      -  The interface MMC Snapin Extensions use to
//                         talk to the Group Policy Editor.
//
// IGroupPolicyObject   -  The interface used to create/edit a GPO directly
//                         without going through the Group Policy Editor
//


//
// Group Policy Editor MMC SnapIn GUID
//
// {8FC0B734-A0E1-11d1-A7D3-0000F87571E3}

DEFINE_GUID(CLSID_GPESnapIn, 0x8fc0b734, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// Group Policy Editor node ids
//

//
// Computer Configuration\Windows Settings
// {8FC0B737-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_Machine, 0x8fc0b737, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// Computer Configuration\Software Settings
// {8FC0B73A-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_MachineSWSettings, 0x8fc0b73a, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// User Configuration\Windows Settings
// {8FC0B738-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_User, 0x8fc0b738, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// User Configuration\Software Settings
// {8FC0B73C-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_UserSWSettings, 0x8fc0b73c, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// IGPEInformation interface id
//
// {8FC0B735-A0E1-11d1-A7D3-0000F87571E3}

DEFINE_GUID(IID_IGPEInformation, 0x8fc0b735, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// Group Policy Object class id
//
// {EA502722-A23D-11d1-A7D3-0000F87571E3}

DEFINE_GUID(CLSID_GroupPolicyObject, 0xea502722, 0xa23d, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// Group Policy Object interface id
//
// {EA502723-A23D-11d1-A7D3-0000F87571E3}

DEFINE_GUID(IID_IGroupPolicyObject, 0xea502723, 0xa23d, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// GUID that identifies the registry extension
//

#define REGISTRY_EXTENSION_GUID  { 0x35378EAC, 0x683F, 0x11D2, 0xA8, 0x9A, 0x00, 0xC0, 0x4F, 0xBB, 0xCF, 0xA2 }



//========================================================================================
//
// Resultant Set of Policy node ids
//
//========================================================================================

//
// Resultant Set of Policy MMC SnapIn GUID
//
// {6DC3804B-7212-458D-ADB0-9A07E2AE1FA2}

DEFINE_GUID(CLSID_RSOPSnapIn, 0x6dc3804b, 0x7212, 0x458d, 0xad, 0xb0, 0x9a, 0x07, 0xe2, 0xae, 0x1f, 0xa2);


//
// Computer Configuration\Windows Settings
// {BD4C1A2E-0B7A-4A62-A6B0-C0577539C97E}
//

DEFINE_GUID(NODEID_RSOPMachine, 0xbd4c1a2e, 0x0b7a, 0x4a62, 0xa6, 0xb0, 0xc0, 0x57, 0x75, 0x39, 0xc9, 0x7e);


//
// Computer Configuration\Software Settings
// {6A76273E-EB8E-45DB-94C5-25663A5f2C1A}
//

DEFINE_GUID(NODEID_RSOPMachineSWSettings, 0x6a76273e, 0xeb8e, 0x45db, 0x94, 0xc5, 0x25, 0x66, 0x3a, 0x5f, 0x2c, 0x1a);


//
// User Configuration\Windows Settings
// {AB87364F-0CEC-4CD8-9BF8-898F34628FB8}
//

DEFINE_GUID(NODEID_RSOPUser, 0xab87364f, 0x0cec, 0x4cd8, 0x9b, 0xf8, 0x89, 0x8f, 0x34, 0x62, 0x8f, 0xb8);


//
// User Configuration\Software Settings
// {E52C5CE3-FD27-4402-84DE-D9A5F2858910}
//

DEFINE_GUID(NODEID_RSOPUserSWSettings, 0xe52c5ce3, 0xfd27, 0x4402, 0x84, 0xde, 0xd9, 0xa5, 0xf2, 0x85, 0x89, 0x10);


//
// IRSOPInformation interface id
//
// {9A5A81B5-D9C7-49EF-9D11-DDF50968C48D}

DEFINE_GUID(IID_IRSOPInformation, 0x9a5a81b5, 0xd9c7, 0x49ef, 0x9d, 0x11, 0xdd, 0xf5, 0x09, 0x68, 0xc4, 0x8d);


#ifndef _GPEDIT_H_
#define _GPEDIT_H_


//
// Define API decoration for direct importing of DLL references.
//

#if !defined(_GPEDIT_)
#define GPEDITAPI DECLSPEC_IMPORT
#else
#define GPEDITAPI
#endif


#ifdef __cplusplus
extern "C" {
#endif


#include <objbase.h>


//
// Group Policy Object Section flags
//

#define GPO_SECTION_ROOT                 0  // Root
#define GPO_SECTION_USER                 1  // User
#define GPO_SECTION_MACHINE              2  // Machine


//
// Group Policy Object types
//

typedef enum _GROUP_POLICY_OBJECT_TYPE {
    GPOTypeLocal = 0,                       // GPO on the local machine
    GPOTypeRemote,                          // GPO on a remote machine
    GPOTypeDS                               // GPO in the Active Directory
} GROUP_POLICY_OBJECT_TYPE, *PGROUP_POLICY_OBJECT_TYPE;


//
// Group Policy Hint types
//

typedef enum _GROUP_POLICY_HINT_TYPE {
    GPHintUnknown = 0,                      // No link information available
    GPHintMachine,                          // GPO linked to a machine (local or remote)
    GPHintSite,                             // GPO linked to a site
    GPHintDomain,                           // GPO linked to a domain
    GPHintOrganizationalUnit,               // GPO linked to a organizational unit
} GROUP_POLICY_HINT_TYPE, *PGROUP_POLICY_HINT_TYPE;


#undef INTERFACE
#define INTERFACE   IGPEInformation
DECLARE_INTERFACE_(IGPEInformation, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IGPEInformation methods ***

    //
    // Returns the unique Group Policy Object name (a GUID)
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetName) (THIS_ LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns the friendly display name for this Group Policy Object
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetDisplayName) (THIS_ LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns a registry key handle for the requested section.  The returned
    // key is the root of the registry, not the Policies subkey.  To set / read
    // a value in the Policies subkey, you will need to call RegOpenKeyEx to
    // open Software\Policies subkey first.
    //
    // The handle has been opened with ALL ACCESS rights.  Call RegCloseKey
    // on the handle when finished.
    //
    // dwSection is either GPO_SECTION_USER or GPO_SECTION_MACHINE
    // hKey contains the registry key on return
    //

    STDMETHOD(GetRegistryKey) (THIS_ DWORD dwSection, HKEY *hKey) PURE;


    //
    // Returns the Active Directory path to the root of the request section.
    // The path is in ADSI name format.
    //
    // dwSection is one of the GPO_SECTION_* flags
    // pszPath contains the path on return
    // cchMaxPath is the max number of characters that can be stored in pszPath
    //

    STDMETHOD(GetDSPath) (THIS_ DWORD dwSection, LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns the UNC path to the root of the requested section.
    //
    // dwSection is one of the GPO_SECTION_* flags
    // pszPath contains the path on return
    // cchMaxPath is the number of characters that can be stored in pszPath.
    //

    STDMETHOD(GetFileSysPath) (THIS_ DWORD dwSection, LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns the user preferences (options)
    //
    // Currently, there are no options defined.  This is reserved for future use.
    //
    // dwOptions receives a bitmask value
    //

    STDMETHOD(GetOptions) (THIS_ DWORD *dwOptions) PURE;


    //
    // Returns the type of GPO being edited.
    //
    // The three types are:  a GPO in the Active Directory, the GPO on the local machine,
    // and the GPO on a remote machine.
    //
    // Machine GPOs only have file system storage (no Active Directory storage available).
    // If GetDSPath is called for a machine GPO, the function will succeed
    // and the returned buffer will be the empty string ""
    //
    // Active Directory GPOs have both file system and Active Directory storage available to them.
    //
    // gpoType receives one of the type flags listed above.
    //

    STDMETHOD(GetType) (THIS_ GROUP_POLICY_OBJECT_TYPE *gpoType) PURE;


    //
    // Returns the type of Active Directory object (or machine) that could be linked to
    // this GPO
    //
    // This is a hint api only.  The GPE does not know which Active Directory objects are
    // linked to a particular GPO, but it can offer a hint based upon how the
    // user started the GPE.
    //
    // Use this method with great caution.  Some extensions might want to
    // customize their user interface based upon the scoping for this GPO,
    // but it is easy to offer the wrong namespace.  Best advice is to
    // always offer your full user interface, but if you choose to use this
    // method, always offer your full user interface if you recieve the
    // unknown hint back.
    //
    // gpHint receives one of the hint flags listed above.
    //

    STDMETHOD(GetHint) (THIS_ GROUP_POLICY_HINT_TYPE *gpHint) PURE;


    //
    // Informs the Group Policy Editor that policy settings have changed.
    // Extensions MUST call this methold every time a change is made
    // to a Group Policy Object.
    //
    // bMachine specifies if machine or user policy has changed.
    // bAdd specifies whether this is an add or delete.
    // pGuidExtension is the guid or unique name of extension that
    //    will process this GPO.
    // pGuidSnapin is the guid or unique name of snapin that is making
    //    this call
    //

    STDMETHOD(PolicyChanged) (THIS_ BOOL bMachine, BOOL bAdd, GUID *pGuidExtension, GUID *pGuidSnapin ) PURE;
};
typedef IGPEInformation *LPGPEINFORMATION;


//
// Group Policy Object open / creation flags
//

#define GPO_OPEN_LOAD_REGISTRY      0x00000001  // Load the registry files
#define GPO_OPEN_READ_ONLY          0x00000002  // Open the GPO as read only



//
// Group Policy Object option flags
//

#define GPO_OPTION_DISABLE_USER     0x00000001  // The user portion of this GPO is disabled
#define GPO_OPTION_DISABLE_MACHINE  0x00000002  // The machine portion of this GPO is disabled


#undef INTERFACE
#define INTERFACE   IGroupPolicyObject
DECLARE_INTERFACE_(IGroupPolicyObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IGroupPolicyObject methods ***

    //
    // Creates a new GPO in the Active Directory with the given friendly name
    // and opens it via OpenDSGPO().  If pszDomainName contains a domain
    // controller name, the GPO will be created on that DC.  If it does not
    // specify a domain controller name, the method will select a DC on
    // the callers behalf.
    //
    // pszDomainName contains the ADSI path of the domain root
    // pszDisplayName contains the friendly display name
    // dwFlags is a bitmask of GPO open / creation flags listed above
    //

    STDMETHOD(New) (THIS_ LPOLESTR pszDomainName, LPOLESTR pszDisplayName,
                    DWORD dwFlags) PURE;


    //
    // Opens the specified Group Policy Object in the Active Directory
    // based upon the passed in flags.  If pszPath contains a domain
    // controller name, the GPO will be opened on that DC.  If it does
    // not contain a domain controller name, the method will select a
    // DC on the callers behalf.  If the registry is not loaded,
    // GetRegistryKey() will return E_FAIL.
    //
    // pszPath contains the ADSI path to the GPO to open
    // dwFlags is a bitmask of GPO open / creation flags listed above
    //

    STDMETHOD(OpenDSGPO) (THIS_ LPOLESTR pszPath, DWORD dwFlags) PURE;


    //
    // Opens the default Group Policy Object on this machine with the
    // dwFlags options listed above.  If the registry is not loaded,
    // GetRegistryKey() will return E_FAIL.
    //
    // dwFlags is a bitmask of GPO open / creation flags listed above
    //

    STDMETHOD(OpenLocalMachineGPO) (THIS_ DWORD dwFlags) PURE;


    //
    // Opens the default Group Policy Object on a remote machine with the
    // dwFlags options listed above.  If the registry is not loaded,
    // GetRegistryKey() will return E_FAIL.
    //
    // pszComputerName contains the machine name in \\machine format
    // dwFlags is a bitmask of GPO open / creation flags listed above
    //

    STDMETHOD(OpenRemoteMachineGPO) (THIS_ LPOLESTR pszComputerName, DWORD dwFlags) PURE;


    //
    // Flushes the registry settings to disk and updates the revision
    // number of the GPO.
    //
    // bMachine specifies if machine or user should be saved.
    // bAdd specifies whether this is an add or delete.
    // pGuidExtension is the guid or unique name of extension that
    //    will process this GPO.
    // pGuid is a guid
    //

    STDMETHOD(Save) (THIS_ BOOL bMachine, BOOL bAdd, GUID *pGuidExtension, GUID *pGuid ) PURE;


    //
    // Deletes this Group Policy Object.
    //
    // After calling this method, no other methods are valid to call
    // since the data will have been deleted.
    //

    STDMETHOD(Delete) (THIS) PURE;


    //
    // Returns the unique Group Policy Object name
    //
    // For Active Directory policy objects, this is a GUID
    // For the local policy object, it is the string "Local"
    // For remote policy objects, it is the computername
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetName) (THIS_ LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns the friendly display name for this Group Policy Object
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetDisplayName) (THIS_ LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Sets the friendly display name for this Group Policy Object
    //
    // pszName is the new display name
    //

    STDMETHOD(SetDisplayName) (THIS_ LPOLESTR pszName) PURE;


    //
    // Returns the path to the Group Policy Object
    //
    //
    // If the GPO is an Active Directory object, the path is in ADSI name format.
    // If the GPO is a machine object, it is a file system path
    //
    // pszPath contains the path on return
    // cchMaxPath is the max number of characters that can be stored in pszPath
    //

    STDMETHOD(GetPath) (THIS_ LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns the Active Directory path to the root of the request section.
    // The path is in DN name format.
    //
    // dwSection is one of the GPO_SECTION_* flags
    // pszPath contains the path on return
    // cchMaxPath is the max number of characters that can be stored in pszPath
    //

    STDMETHOD(GetDSPath) (THIS_ DWORD dwSection, LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns the UNC path to the root of the requested section.
    //
    // dwSection is one of the GPO_SECTION_* flags
    // pszPath contains the path on return
    // cchMaxPath is the number of characters that can be stored in pszPath.
    //

    STDMETHOD(GetFileSysPath) (THIS_ DWORD dwSection, LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns a registry key handle for the requested section.  The returned
    // key is the root of the registry, not the Policies subkey.  To set / read
    // a value in the Policies subkey, you will need to call RegOpenKeyEx to
    // open Software\Policies subkey first.
    //
    // The handle has been opened with ALL ACCESS rights.  Call RegCloseKey
    // on the handle when finished.
    //
    // If the GPO was loaded / created without the registry being loaded
    // this method will return E_FAIL.
    //
    // dwSection is either GPO_SECTION_USER or GPO_SECTION_MACHINE
    // hKey contains the registry key on return
    //

    STDMETHOD(GetRegistryKey) (THIS_ DWORD dwSection, HKEY *hKey) PURE;


    //
    // Returns any options for this Group Policy Object
    //
    // dwOptions receives the GPO_OPTION_* flags
    //

    STDMETHOD(GetOptions) (THIS_ DWORD *dwOptions) PURE;


    //
    // Sets any options for this Group Policy Object
    //
    // This method sets any options for this GPO.  To change
    // an option, that flag must be set in the mask field.
    // If the flag is in the mask field, then the dwOptions
    // field is read for the current state.
    //
    // For example:  to disable the GPO, make this call
    //
    //    SetOptions (GPO_OPTION_DISABLED, GPO_OPTION_DISABLED);
    //
    // dwOptions specifies one or more GPO_OPTION_* flags
    // dwMask specificies which of the dwOptions to change
    //

    STDMETHOD(SetOptions) (THIS_ DWORD dwOptions, DWORD dwMask) PURE;


    //
    // Returns the type of GPO being edited.
    //
    // The three types are:  a GPO in the Active Directory, the GPO on the local machine,
    // and the GPO on a remote machine.
    //
    // Machine GPOs only have file system storage (no Active Directory storage available).
    // If GetDSPath is called for a machine GPO, the function will succeed
    // and the returned buffer will be the empty string ""
    //
    // Active Directory GPOs have both file system and Active Directory storage available to them.
    //
    // gpoType receives one of the type flags
    //

    STDMETHOD(GetType) (THIS_ GROUP_POLICY_OBJECT_TYPE *gpoType) PURE;


    //
    // Returns the machine name of the remote GPO
    //
    // This method returns the name passed to OpenRemoteMachineGPO.
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetMachineName) (THIS_ LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns an array of property sheet pages and the number of pages
    // in the array
    //
    // Note, this method will allocate memory for the array with
    // LocalAlloc.  When finished, the caller should free the array
    // with LocalFree
    //
    // hPages address of the pointer for the array of property sheet pages
    // uPageCount receives the number of pages in the array
    //

    STDMETHOD(GetPropertySheetPages) (THIS_ HPROPSHEETPAGE **hPages, UINT *uPageCount) PURE;
};
typedef IGroupPolicyObject *LPGROUPPOLICYOBJECT;


//
// RSOP flags
//

#define RSOP_INFO_FLAG_DIAGNOSTIC_MODE  0x00000001      // Running in diagnostic mode vs planning mode

#undef INTERFACE
#define INTERFACE   IRSOPInformation
DECLARE_INTERFACE_(IRSOPInformation, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IRSOPInformation methods ***

    //
    // Returns the namespace for the RSOP data
    //
    // dwSection is either GPO_SECTION_USER or GPO_SECTION_MACHINE
    // pszName contains the namespace on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetNamespace) (THIS_ DWORD dwSection, LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns information about the RSOP session
    //
    // pdwFlags points to a DWORD which contains the flags on return
    //

    STDMETHOD(GetFlags) (THIS_ DWORD * pdwFlags) PURE;


    //
    // Returns the event log text for a specific entry
    //
    // lpEventSource - event log source name
    // lpEventLogName - event log name
    // lpEventTime - event log time in WMI datetime format
    // dwEventID - event ID
    // lpText - Receives a pointer to a buffer containing the text.
    //          The caller should free this buffer with CoTaskMemFree.
    //

    STDMETHOD(GetEventLogEntryText) (THIS_ LPOLESTR pszEventSource, LPOLESTR pszEventLogName,
                                           LPOLESTR pszEventTime, DWORD dwEventID,  LPOLESTR *ppszText) PURE;

};
typedef IRSOPInformation *LPRSOPINFORMATION;


//=============================================================================
//
// CreateGPOLink
//
// Creates a link to a GPO for the specified Site, Domain, or Organizational Unit
//
// lpGPO         - ADSI path to the GPO
// lpContainer   - ADSI path to the Site, Domain, or Organizational Unit
// fHighPriority - Create the link as the highest or lowest priority
//
// Returns:  S_OK if successful
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
CreateGPOLink(
    LPOLESTR lpGPO,
    LPOLESTR lpContainer,
    BOOL fHighPriority);


//=============================================================================
//
// DeleteGPOLink
//
// Deletes a link to a GPO for the specified Site, Domain, or Organizational Unit
//
// lpGPO         - ADSI path to the GPO
// lpContainer   - ADSI path to the Site, Domain, or Organizational Unit
//
// Returns:  S_OK if successful
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
DeleteGPOLink(
    LPOLESTR lpGPO,
    LPOLESTR lpContainer);


//=============================================================================
//
// DeleteAllGPOLinks
//
// Deletes all GPO links for the specified Site, Domain, or Organizational Unit
//
// lpContainer   - ADSI path to the Site, Domain, or Organizational Unit
//
// Returns:  S_OK if successful
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
DeleteAllGPOLinks(
    LPOLESTR lpContainer);


//=============================================================================
//
// BrowseForGPO
//
// Displays the GPO browser dialog
//
// lpBrowseInfo   - Address of a GPOBROWSEINFO structure
//
// Returns:  S_OK if successful
//
//=============================================================================

//
// Flags passed in the dwFlags field of the GPOBROWSEINFO structure
//

#define GPO_BROWSE_DISABLENEW           0x00000001   // Disables the New GPO functionality on all pages except "All"
#define GPO_BROWSE_NOCOMPUTERS          0x00000002   // Removes the Computers tab
#define GPO_BROWSE_NODSGPOS             0x00000004   // Removes the Domain/OU and Sites tabs
#define GPO_BROWSE_OPENBUTTON           0x00000008   // Change the Ok button to say Open
#define GPO_BROWSE_INITTOALL            0x00000010   // Initialize the dialog focused on the All pane

typedef struct tag_GPOBROWSEINFO
{
    DWORD       dwSize;                   // [in] Initialized to the size of this structure
    DWORD       dwFlags;                  // [in] Flags defined above
    HWND        hwndOwner;                // [in] Parent window handle (can be NULL)
    LPOLESTR    lpTitle;                  // [in] Title bar text.  If NULL, "Browse for a Group Policy Object" will be the default text
    LPOLESTR    lpInitialOU;              // [in] Initial Domain/Organizational Unit to open focus on
    LPOLESTR    lpDSPath;                 // [in/out] Pointer to the buffer that receives the Active Directory GPO path
    DWORD       dwDSPathSize;             // [in] Size in characters of buffer given in lpDSPath
    LPOLESTR    lpName;                   // [in/out] Pointer to a buffer that receives either the computer name or
                                          //      the friendly name of the GPO (can be NULL)
    DWORD       dwNameSize;               // [in] Size in characters of buffer given in lpName
    GROUP_POLICY_OBJECT_TYPE    gpoType;  // [out] Specifies the type of GPO
    GROUP_POLICY_HINT_TYPE      gpoHint;  // [out] Specifies a hint of the GPO association
} GPOBROWSEINFO, *LPGPOBROWSEINFO;


GPEDITAPI
HRESULT
WINAPI
BrowseForGPO(
    LPGPOBROWSEINFO lpBrowseInfo);


//=============================================================================
//
// ImportRSoPData
//
// Imports a data file generated by ExportRSoPData
//
// lpNameSpace   - Namespace to place the data in
// lpFileName    - Filename containing the data
//
// Returns:  S_OK if successful
//
// Notes:    The namespace specified in lpNameSpace must exist prior to calling
//           this function.
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
ImportRSoPData(
    LPOLESTR lpNameSpace,
    LPOLESTR lpFileName);


//=============================================================================
//
// ExportRSoPData
//
// Exports a WBEM namespace containing RSoP information to a data file.
// This data file can be imported to a WBEM namespace using ImportRSoPData.
//
// lpNameSpace   - Namespace to read the data from
// lpFileName    - Filename to receive the data
//
// Returns:  S_OK if successful
//
// Notes:    This function should be called twice.  Once for the user data
//           and once for the computer data.
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
ExportRSoPData(
    LPOLESTR lpNameSpace,
    LPOLESTR lpFileName);

#ifdef __cplusplus
}
#endif


#endif  /* _GPEDIT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\iaapi.h ===
/*
 * Copyright (C) 1995-1999 Open Systems Solutions, Inc.  All rights reserved.
 *
 * FILE: @(#)iaapi.h	5.3.1.1  97/03/18
 */

/* THIS FILE IS PROPRIETARY MATERIAL OF OPEN SYSTEMS SOLUTIONS, INC. AND
 * MAY BE USED ONLY BY DIRECT LICENSEES OF OPEN SYSTEMS SOLUTIONS, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED. */

/*****************************************************************************/
/*                                                                           */
/*           Declare the types used in the Interpretive ASN.1 API            */
/*                                                                           */
/*****************************************************************************/
#ifndef IAAPI_H
#define IAAPI_H

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef ASN1CODE_H
#include "asn1code.h"
#endif

#ifndef ASN1HDR_H
#include "asn1hdr.h"
#endif

typedef void *TypeHndl;		/* handle used in referencing types */

#define INDEFLENGTH   -1       /* This value is returned by encodingLength()
                                * for INDEFINITE length encoded values. */

/* ASN.1 builtin types sorted alphabetically and assigned an enumerator */

typedef enum ASN1Type {
	asn1UnknownType = 0,
	asn1ANY = 1,                            asn1NumericString = 17,
	asn1BIT_STRING = 2,                     asn1OBJECT_IDENTIFIER = 18,
	asn1BMPString = 3,                      asn1OCTET_STRING = 19,
	asn1BOOLEAN = 4,                        asn1ObjectDescriptor = 20,
	asn1CHARACTER_STRING = 5,               asn1OpenType = 21,
	asn1CHOICE = 6,                         asn1PrintableString = 22,
	asn1EMBEDDED_PDV = 7,                   asn1REAL = 23,
	asn1ENUMERATED = 8,                     asn1SEQUENCE = 24,
	asn1EXTERNAL = 9,                       asn1SEQUENCE_OF = 25,
	asn1GeneralString = 10,                 asn1SET = 26,
	asn1GeneralizedTime = 11,               asn1SET_OF = 27,
	asn1GraphicString = 12,                 asn1TeletexString = 28,
	asn1IA5String = 13,                     asn1UTCTime = 29,
	asn1INSTANCE_OF = 14,                   asn1UniversalString = 30,
	asn1INTEGER = 15,                       asn1VideotexString = 31,
	asn1NULL = 16,                          asn1VisibleString = 32
} ASN1Type;


/* Types compatible codes */
typedef enum TypesCompatibilityCodes {
    compatible = 0,                  /* Types are compatible */
    differentTypes = 1,              /* Types are not identical */
    defaultsDifferent = 2,           /* Default values are not the same */
    onlyOneHasDefault = 3,           /* Only one type has a default value */
    oneHasPointerOtherDoesnt = 4,    /* Only one type has a POINTER directive */
    numberOfComponentsDifferent = 5, /* Different number of components */
    oneIsOptionalOtherIsnt = 6,      /* Only one type is OPTIONAL */
    oneIsExtensibleOtherIsnt = 7,    /* Only one type is extensible */
    differentNamedItems = 8,         /* Different component identifiers */
    differentKinds = 9,              /* Different type representations */
    componentsHaveDifferentKinds = 10,/* Different component representations */
    differentSubIdNumber = 11,       /* Different number of sub-identifiers in
                                      * an OBJECT IDENTIFIER with the OBJECTID
                                      * directive */
    differentSubIdTypes = 12,        /* Different types of sub-identifiers in
                                      * an OBJECT IDENTIFIER with the OBJECTID
                                      * directive */
    differentSize = 13,              /* Different size of INTEGER or REAL values */
    type1IsPointerOfTypeRef2 = 14,   /* Two types reference the other
                                      * type but the first one has the
                                      * POINTER directive */
    type2IsPointerOfTypeRef1 = 15,   /* Two types reference the other type
                                      * but the second one has the POINTER
                                      * directive */
    differentSizeOfLengthField = 16  /* Different sizes of the length field in
                                      * type representations */
} TypesCompatibilityCodes;


/* ASN.1 tag classes */
typedef enum ASN1TagClass {
	UNIVERSAL, APPLICATION, CONTEXT_SPECIFIC, PRIVATE, NULLENCODING
} ASN1TagClass;


typedef int IAAPI_ERRTYPE;     /* Datatype for IAAPI error codes */

/* IAAPI ERROR CODES */
#define IAAPI_NOERROR      0   /* No error occurred */
#define IAAPI_OUTMEMORY    1   /* No more memory can be allocated */
#define IAAPI_BADBIT       2   /* Bad bit string or hex string */
#define IAAPI_BADBOOLEAN   3   /* Not TRUE or FALSE value */
#define IAAPI_BADNULL      4   /* Not "NULL" value */
#define IAAPI_TOOBIG       5   /* Value exceeds size constraint */
#define IAAPI_BADREAL      6   /* Not a valid REAL value */
#define IAAPI_BADTIME      7   /* Not a valid UTCTime or GeneralizedTime */
#define IAAPI_BADOBJID     8   /* Not a valid OBJECT IDENTIFIER value */
#define IAAPI_BADANY       9   /* Bad ANY value */
#define IAAPI_BADNAME     10   /* Bad INTEGER or ENUMERATED name */
#define IAAPI_BADNMD      11   /* Bad BIT STRING NAMED NUMBER value */
#define IAAPI_NOTSUP      12   /* Type not supported */
#define IAAPI_BADNUM      13   /* Bad INTEGER or ENUMERATED number */
#define IAAPI_BADINDX     14   /* Bad component index into a structured type */
#define IAAPI_BADDEC      15   /* Bad decoded value, possibly NULL */
#define IAAPI_ENCFAL      16   /* Failure to encode value */
#define IAAPI_NLENC       17   /* Null encoding or length is 0 */
#define IAAPI_DECFAL      18   /* Decoding failed */
#define IAAPI_BADTGINDX   19   /* Bad tag number index into encoded value */
#define IAAPI_BADTYPE     20   /* Incorrect type handle for the function */
#define IAAPI_CPYFAIL     21   /* Copying a decoded value failed */
#define IAAPI_NOTCOMPATIBLE   22 /* Types are not compatible */
#define IAAPI_BADDISPLAYVALUE 23 /* Failure to parse a PDU display value */
#define IAAPI_BADIDENTIFIER   24 /* Bad identifier in a parsing display value */
#define IAAPI_DUPLCOMPVALUE   25 /* Duplicate value for one component in a parsing value*/
#define IAAPI_ENCOPENTYPEORANYFAILED 26 /* Encoding failed for ANY or open type value*/
#define IAAPI_FREETPFAL   27   /* Failure to free decoded value */
#define IAAPI_BADENC      28   /* Error exists in the encoded data */
#define IAAPI_BADHINT     29   /* Bad HUGE INTEGER value */
#define IAAPI_BADENCOID   30   /* Bad ENCODED OBJECT IDENTIFIER value */
#define IAAPI_BADOBJ      31   /* Object can not be marked */
#define IAAPI_UNKNOWNOBJ  32   /* Invalid object handle */
#define IAAPI_MEM_ERROR   33   /* Memory violation error occurred */
#define IAAPI_ACCESS_SERIALIZATION 34 /* Access serialization error occurred */

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(push, ossPacking, 4)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack(1)
#elif defined(__BORLANDC__) && defined(__MSDOS__)
#pragma option -a1
#elif defined(__BORLANDC__) && defined(__WIN32__)
#pragma option -a4
#elif defined(__IBMC__)
#pragma pack(4)
#elif defined(__WATCOMC__) && defined(__NT__)
#pragma pack(push, 4)
#elif defined(__WATCOMC__) && (defined(__WINDOWS__) || defined(__DOS__))
#pragma pack(push, 1)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=mac68k
#endif


/* Structure for holding values of type INTEGER */
typedef struct IntValue {
    enum {signedNumber, unsignedNumber} sign;
    union {
	LONG_LONG       signedInt;
	ULONG_LONG      unsignedInt;
    } value;
} IntValue;


/* Structure for IAAPI initialization values */
typedef struct IAAPI_initializers {
           char         charInitializer;
           short        shortInitializer;
           int          intInitializer;
           long         longInitializer;
           LONG_LONG    llongInitializer;
           void       * pointerInitializer;
           char       * floatInitializer;
           char       * doubleInitializer;
} IAAPI_initializers;

/*
 * Type definition for a value reference structure.
 */
typedef struct ValRef {
   char *name;            /* value reference name */
   void *address;         /* pointer to decoded value */
   unsigned short etype;  /* index into etype array */
} ValRef;


/* Union containing the different types for an object value */
typedef union IaapiObjValType {
           char       * fileName;
           int          socketIdentifier;
} IaapiObjValType;

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(pop, ossPacking)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack()
#elif defined(__BORLANDC__) && (defined(__WIN32__) || defined(__MSDOS__))
#pragma option -a.
#elif defined(__IBMC__)
#pragma pack()
#elif defined(__WATCOMC__)
#pragma pack(pop)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=reset
#endif

#ifdef __cplusplus
extern "C" {
#endif

/***************************************************/
/* Functions defined by the Interpretive ASN.1 API */
/***************************************************/

extern int DLL_ENTRY ossDefaultIAAPI_ERR(OssGlobal *world, int return_code);
extern void *DLL_ENTRY ossGetIaapiErrorHandlingFunction(OssGlobal *world);
extern void  DLL_ENTRY ossSetIaapiErrorHandlingFunction(OssGlobal *world,
				int (DLL_ENTRY_FPTR *_System func)
				(OssGlobal *, int error_code));
extern void  DLL_ENTRY ossSetInitializationValues(OssGlobal *world,
					IAAPI_initializers *initStruct);
extern void  DLL_ENTRY ossTermIAAPI(OssGlobal *world);

extern unsigned short DLL_ENTRY ossCtlTblVersionNumber(OssGlobal *world);
extern ossBoolean  DLL_ENTRY ossCtlTblUsableOnlyByPER(OssGlobal *world);
extern ossBoolean  DLL_ENTRY ossCtlTblUsableOnlyByBER(OssGlobal *world);
extern ossBoolean  DLL_ENTRY ossDebugWasSpecified(OssGlobal *world);
extern ossBoolean  DLL_ENTRY ossConstrainWasSpecified(OssGlobal *world);
extern int         DLL_ENTRY ossNumberOfPDUs(OssGlobal *world);

extern TypeHndl    DLL_ENTRY ossTypeHandleOfPDU(OssGlobal *world, int pduNum);
extern TypeHndl    DLL_ENTRY ossPduTypeHandleByName(OssGlobal *world, const char *name);
extern int         DLL_ENTRY ossPduNumberByType(OssGlobal *world, TypeHndl type);

extern ossBoolean  DLL_ENTRY ossTypeIsConstrained(OssGlobal *world, TypeHndl type);
extern ASN1Type    DLL_ENTRY ossAsn1TypeId(OssGlobal *world, TypeHndl type);
extern const char *DLL_ENTRY ossBuiltinTypeName(OssGlobal *world, ASN1Type typeId);
extern const char *DLL_ENTRY ossTypeReferenceName(OssGlobal *world, TypeHndl type);
extern TypesCompatibilityCodes DLL_ENTRY ossTypesCompatible(OssGlobal *world,
					TypeHndl type1, TypeHndl type2);

extern int         DLL_ENTRY ossNumberOfNamedItems(OssGlobal *world, TypeHndl type);
extern TypeHndl    DLL_ENTRY ossTypeHandleOfComponent(OssGlobal *world,
					TypeHndl parent, unsigned int ix);
extern ossBoolean  DLL_ENTRY ossComponentIsOptional(OssGlobal *world,
					TypeHndl type, unsigned int ix);
extern ossBoolean  DLL_ENTRY ossComponentHasDefaultValue(OssGlobal *world,
					TypeHndl parentType, unsigned int ix);
extern void       *DLL_ENTRY ossComponentDefaultValue(OssGlobal *world,
					TypeHndl parentType, unsigned int ix);
extern ossBoolean  DLL_ENTRY ossComponentValueIsPresent(OssGlobal *world,
					TypeHndl parentType, unsigned int ix,
					void *parentValue);
extern ossBoolean  DLL_ENTRY ossComponentIsInitializationValue(OssGlobal *world,
					TypeHndl chldType, void *compAddress);
extern unsigned int DLL_ENTRY ossItemIndexByName(OssGlobal *world,
					TypeHndl type, const char *name);
extern const char *DLL_ENTRY ossAsn1ItemName(OssGlobal *world, TypeHndl type,
						unsigned int ix);
extern long        DLL_ENTRY ossItemIntValue(OssGlobal *world, TypeHndl type,
						unsigned int ix);

extern ossBoolean  DLL_ENTRY ossExtensionMarkerIsPresent(OssGlobal *world,
						TypeHndl type);
extern int         DLL_ENTRY ossNumberOfRootItems(OssGlobal *world, TypeHndl type);
extern ossBoolean  DLL_ENTRY ossCompAppearsAfterExtensionMarker(OssGlobal *world,
						TypeHndl type, unsigned int ix);
extern int         DLL_ENTRY ossNumberOfTags(OssGlobal *world, TypeHndl type);
extern int         DLL_ENTRY ossAsn1TagNumber(OssGlobal *world, TypeHndl type,
						unsigned int ix);
extern ASN1TagClass DLL_ENTRY ossAsn1TagClass(OssGlobal *world, TypeHndl type,
						unsigned int ix);

extern ossBoolean  DLL_ENTRY ossUpperBoundIsPresent(OssGlobal *world, TypeHndl type);
extern ossBoolean  DLL_ENTRY ossLowerBoundIsPresent(OssGlobal *world, TypeHndl type);
extern unsigned long DLL_ENTRY ossLowerBoundOfSizeConstraint(OssGlobal *world,
							TypeHndl type);
extern unsigned long DLL_ENTRY ossUpperBoundOfSizeConstraint(OssGlobal *world,
							TypeHndl type);

extern IntValue    DLL_ENTRY ossMinValueOfInteger(OssGlobal *world, TypeHndl type);
extern IntValue    DLL_ENTRY ossMaxValueOfInteger(OssGlobal *world, TypeHndl type);

extern unsigned long DLL_ENTRY ossPermittedAlphabetLength(OssGlobal *world,
							TypeHndl type);
extern const long *DLL_ENTRY ossPermittedAlphabetConstraint(OssGlobal *world,
							TypeHndl type);

extern unsigned short DLL_ENTRY ossGetNumberOfValueReferences(OssGlobal *world);
extern const char *DLL_ENTRY ossGetNameOfValueReference(OssGlobal *world,
						unsigned short int compIndex);
extern const void *DLL_ENTRY ossGetDecodedValueOfValueReference(OssGlobal *world,
						unsigned short int compIndex);
extern TypeHndl    DLL_ENTRY ossGetTypeHandleOfValueReference(OssGlobal *world,
						unsigned short int compIndex);

extern IAAPI_ERRTYPE DLL_ENTRY ossPutDecodedValueOfPDU(OssGlobal *world,
				int pduNum, char *remainingBuf, void **pduVal);
extern IAAPI_ERRTYPE DLL_ENTRY ossPutSimpleTypeValue(OssGlobal *world,
				TypeHndl type, char *userTypedvalue,
				void **decodedValue);
extern IAAPI_ERRTYPE DLL_ENTRY ossPutStructTypeValue(OssGlobal *world,
				TypeHndl parent, void *compValue,
				unsigned int compIndex, void **structToUpdate);
extern IAAPI_ERRTYPE DLL_ENTRY ossDeleteComponent(OssGlobal *world,
				TypeHndl parentType, unsigned int compIndex,
				void **parentValue);
extern IAAPI_ERRTYPE DLL_ENTRY ossPutOpenTypeDecodedValue(OssGlobal *world,
				TypeHndl type, int pduNum, void *decodedValue,
				OpenType **openValue);
extern IAAPI_ERRTYPE DLL_ENTRY ossPutEncodedValue(OssGlobal *world,
				TypeHndl type, OssBuf encodedValue,
				void **decodedValue);

extern char *DLL_ENTRY ossGetValueOfSimpleType(OssGlobal *world, TypeHndl type,
				void *decodedValue);
extern void *DLL_ENTRY ossUpdateValueOfSimpleType(OssGlobal *world,TypeHndl type,
				char *userTypedValue, void *oldValue);
extern IAAPI_ERRTYPE DLL_ENTRY ossGetDecodedValueOfComponent(OssGlobal *world,
				TypeHndl parentType, void *parentDecodedValue,
				unsigned int compIndex, void **componentValue);
extern IAAPI_ERRTYPE DLL_ENTRY ossGetOpenTypeValue(OssGlobal *world,
				TypeHndl type, void *openValue, int *pduNum,
				void **decodedValue, OssBuf *encodedValue);

extern IAAPI_ERRTYPE DLL_ENTRY ossIaapiMarkObject(OssGlobal *world, TypeHndl type,
				OssObjType objectType, void *object);
extern OssObjType    DLL_ENTRY ossGetObjectType(OssGlobal *world,
				TypeHndl type, void *object);
extern ossBoolean    DLL_ENTRY ossTypeIsExternalObject(OssGlobal *world,
				TypeHndl type);
extern IAAPI_ERRTYPE DLL_ENTRY ossSetTypeAsExternalObject(OssGlobal *world,
				TypeHndl type, ossBoolean marked);
extern void *DLL_ENTRY ossPutObjectValue(OssGlobal *world, TypeHndl type,
				void *objectValue, OssObjType objectType);
extern IAAPI_ERRTYPE DLL_ENTRY ossGetObjectValue(OssGlobal *world,
				TypeHndl type, void *object,
				OssObjType objType, IaapiObjValType *objVal);

extern ossBoolean    DLL_ENTRY ossValueIsValid(OssGlobal *world,
					TypeHndl type, void *value);
extern unsigned long DLL_ENTRY ossGetValueLength(OssGlobal *world,
					TypeHndl type, void *value);
extern IAAPI_ERRTYPE DLL_ENTRY ossCopyTypeValue(OssGlobal *world, TypeHndl type,
					void *valueIn, void **valueOut);
extern IAAPI_ERRTYPE DLL_ENTRY ossValueEncode(OssGlobal *world, TypeHndl type,
					void *value, OssBuf *encodedValue);

extern IAAPI_ERRTYPE DLL_ENTRY ossFreeDecodedValue(OssGlobal *world,
					TypeHndl type, void *valPtr);
extern void DLL_ENTRY ossFreeDisplayString(OssGlobal *world, char *dsplString);
extern void DLL_ENTRY ossFreeIaapiObjectValue(OssGlobal *world,
				OssObjType objType, IaapiObjValType *objVal);


extern ossBoolean     DLL_ENTRY ossEncodingIsConstructed(OssGlobal *world,
				unsigned char *curEnc, long bufLength);
extern unsigned char *DLL_ENTRY ossGetNextBEREncoding(OssGlobal *world,
				unsigned char *curEnc, long *remBufLen);
extern unsigned char *DLL_ENTRY ossGetNestedBEREncoding(OssGlobal *world,
				unsigned char *curEnc, long *remBufLen);
extern long           DLL_ENTRY ossNumberOfEncodingTags(OssGlobal *world,
				unsigned char *curEnc, long bufLength);
extern ASN1TagClass   DLL_ENTRY ossEncodingASN1Class(OssGlobal *world,
				unsigned char *curEnc, long bufLength, int ix);
extern long           DLL_ENTRY ossEncodingASN1Tag(OssGlobal *world,
				unsigned char *curEnc, long bufLength, int ix);
extern char          *DLL_ENTRY ossEncodingASN1Type(OssGlobal *world,
				unsigned char *curEnc, long bufLength);
extern long           DLL_ENTRY ossEncodingLength(OssGlobal *world,
				unsigned char *curEnc, long bufLength);
extern char          *DLL_ENTRY ossEncodingContents(OssGlobal *world,
				unsigned char *curEnc, long bufLength);

extern char  *DLL_ENTRY ossConvertEncodingIntoDisplayHexFmt(OssGlobal *world,
				unsigned char *encodedBufin, long bufLength);
extern char  *DLL_ENTRY ossConvertEncodingIntoDisplayBinFmt(OssGlobal *world,
				unsigned char *encodedBufin, long bufLength);
extern OssBuf DLL_ENTRY ossConvertHexFmtToEncoding(OssGlobal *world,
				char *hexBufin, long bufLength);
extern OssBuf DLL_ENTRY ossConvertBinFmtToEncoding(OssGlobal *world,
				char *binBufin, long bufLength);

/***************************************************************************
 * Functions for printing ASN.1 types and values                           *
 ***************************************************************************/
extern void DLL_ENTRY ossPrintPDUs(OssGlobal *world);
extern void DLL_ENTRY ossPrintASN1DescriptionOfPDU(OssGlobal *world,
					int pduNum, ossBoolean refTypes);
extern void DLL_ENTRY ossPrintASN1DescriptionOfType(OssGlobal *world,
				TypeHndl type, ossBoolean refTypes);

extern void DLL_ENTRY ossPrintDecodedValuesOfPDUs(OssGlobal *world);
extern void DLL_ENTRY ossPrintDecodedValueOfPDU(OssGlobal *world, int pduNum,
				 	void *decodedValue);
extern void DLL_ENTRY ossPrintDecodedValueOfPDUByName(OssGlobal *world,
				TypeHndl type, char *name, void *decodedValue);
extern void DLL_ENTRY ossPrintDecodedValueOfType(OssGlobal *world,
				TypeHndl type, void *decodedValue);

extern void DLL_ENTRY ossPrintBEREncoding(OssGlobal *world, OssBuf *encValue);
extern unsigned int DLL_ENTRY ossEncodingHeaderLength(OssGlobal *world,
				unsigned char *curEnc, long remBufLength);
extern void DLL_ENTRY ossPrintBEREncodedValueInTLV(OssGlobal *world,
				OssBuf *encodedValue);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif     /* #ifndef IAAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\fasttest.inc ===
'FastTest.inc - definitions/declarations for Fast Test routines
'
'  Copyright (c) 1991-1992, Microsoft Corporation. All rights reserved.
'
'Purpose:
' This file declares the functions, constants and variables
' used by the Fast Test routines.
'
'NOTES:
' A common code sequence is used throughout to catch unexpected errors
' using the ON ERROR command.  The sequence is explained in this note
' but not each time that it is used.
'
'    gErrorType = ET_NEXT       ' Global variable to indicate how to handle
'                               ' an unexpected error:
'                               '   ET_NEXT : save that error happened
'                               '             and continue on next statement
'                               '   ET_NOTHING : let driver catch unexpected
'                               '             errors with message
'                               '   ET_LOG  : error happened in log routine
'
'    ' some code that could cause runtime errors
'    fh1% = FREEFILE            ' out of handles?
'    OPEN stFileSpec1$ FOR INPUT AS #fh1%  ' file doesn't exist?
'    fh2% = FREEFILE            ' out of handles?
'    OPEN stFileSpec2$ FOR INPUT AS #fh2%  ' file doesn't exist?
'
'    IF gfError THEN            ' since ET_NEXT was used above, we would
'                               ' execute this block if an error had
'                               ' occurred.
'        XLogFailure "Could not open files for XFileCmp"   ' log a failure
'                               ' specific to this section of code
'        ' if XSetTerminate is called to have scripts continue in event
'        ' of errors, then the script will continue executing here
'        gErrorType = ET_NOTHING  ' reset so other unexpected errors are
'                               ' caught
'        gfError = FALSE        ' reset because we logged this already
'        EXIT SUB               ' can't continue with this function,
'                               ' something went wrong
'    END IF



'$DEFINE TESTCTRL
'$DEFINE TESTEVNT
'$INCLUDE 'MSTEST.inc'
'$INCLUDE 'WNAPIDEC.INC'

' XLog constants to determine where to log information to
CONST LOG_DISK   = 2      'log to disk
CONST LOG_SCREEN = 4      'log to screen (viewport in testdrvr)
CONST LOG_COM1   = 8      'log to COM1 port
CONST LOG_COM2   = 16     'log to COM2 port
CONST LOG_MSGBOX = 32     'log the string in a msgbox (Pause in testdrvr)

' Mouse button constants that map to QueMouse function names, X functions
' can use either ones
CONST LBUTTON% = VK_LBUTTON
CONST MBUTTON% = VK_MBUTTON
CONST RBUTTON% = VK_RBUTTON

'Global to be used to describe Log Options by ORing above Const's
GLOBAL gfLogOptions%
'Global to be used to save above flag when logging is temporarily turned off.
GLOBAL gfTmpLogOptions%

gfLogOptions = LOG_SCREEN 'default to showing in viewport
gfTmpLogOptions = LOG_SCREEN 'default to showing in viewport

GLOBAL gsCurrentDir$
gsCurrentDir$ = curdir$      ' get current directory that started execution

' Global variable to hold log file name
GLOBAL gsLogFileName$
gsLogFileName$ = gsCurrentDir$ + "\FASTTEST.LOG"

' Global variable to hold string to use as the keystrokes necessary
'   to close the app in the case of errors
GLOBAL gsCleanup$
gsCleanup$ = "{esc 5}%( )c"  ' five escapes, alt-space C (for close)

' Global variable to hold class name of app
GLOBAL gsAppClassname$
gsAppClassname$ = ""

' Global variable to hold state of whether to terminate on XLogFailure
GLOBAL gfTerminate%
gfTerminate% = TRUE    ' default to terminate at first failure

' Global variable that indicates if failure occured
GLOBAL gfFailure%
gfFailure% = FALSE

'Global variable that indicates an ON ERROR occurred
GLOBAL gfError%
gfError% = FALSE

'Global variable that is the string value for the dialog window class
GLOBAL gsDialogClass$
gsDialogClass$ = "#32770"



' Error Type constants (don't use 0)
CONST ET_NOTHING = 1      ' no handling, log unexpected runtime error
CONST ET_NEXT    = 2      ' flag error, continue next statement
CONST ET_LOG     = 3      ' error happened in log routines, inform user elsewise

'Global variable that shows what type of error to handle
GLOBAL gErrorType%
gErrorType% = ET_NOTHING


'Prototypes from FTestLog.mst
DECLARE SUB XSetLogFilename(sFilename$)
DECLARE SUB XSetTerminate(fTerminate%)
DECLARE SUB XLog (stLog$)
DECLARE SUB XLogBanner(lpszInput$)
DECLARE SUB XLogWarning(lpszInput$)
DECLARE SUB XLogFailure(stFailure$)
DECLARE SUB XFailureCheck
DECLARE SUB XSetLogOptions (wLogOptions%)
DECLARE SUB XLogOff ()
DECLARE SUB XLogOn ()
DECLARE SUB XDialogBoxExists(s$)
DECLARE SUB XDialogBoxNotExists(s$)
DECLARE SUB XWaitDialogBox(s$, WaitTime%)
DECLARE SUB XButtonExists(stButton$)
DECLARE SUB XButtonNotExists(stButton$)
DECLARE SUB XButtonEnabled(stButton$)
DECLARE SUB XButtonNotEnabled(stButton$)
DECLARE SUB XClickButton(stButtonName$)
DECLARE SUB XListBoxExists(stListBox$)
DECLARE SUB XListBoxNotExists(stListBox$)
DECLARE SUB XFocusListBox(stListBox$)
DECLARE SUB XListBoxItemExists (stListBox$, stListBoxItem$)
DECLARE SUB XListBoxItemNotExists (stListBox$, stListBoxItem$)
DECLARE SUB XClickListBoxItem (stListBox$, stListBoxItem$)
DECLARE SUB XDblClickListBoxItem (stListBox$, stListBoxItem$)
DECLARE SUB XComboBoxExists(stComboBox$)
DECLARE SUB XComboBoxNotExists(stComboBox$)
DECLARE SUB XFocusComboBox(stComboBox$)
DECLARE SUB XComboBoxItemExists (stComboBox$, stComboBoxItem$)
DECLARE SUB XComboBoxItemNotExists (stComboBox$, stComboBoxItem$)
DECLARE SUB XClickComboBoxItem (stComboBox$, stComboBoxItem$)
DECLARE SUB XDblClickComboBoxItem (stComboBox$, stComboBoxItem$)
DECLARE SUB XCheckBoxExists(stCheckBox$)
DECLARE SUB XCheckBoxNotExists(stCheckBox$)
DECLARE SUB XCheckBoxChecked(stCheckBox$)
DECLARE SUB XCheckBoxNotChecked(stCheckBox$)
DECLARE SUB XCheckBoxEnabled(stCheckBox$)
DECLARE SUB XCheckBoxNotEnabled(stCheckBox$)
DECLARE SUB XClickCheckBox(stCheckBox$)
DECLARE SUB XEditTextExists(stEditText$)
DECLARE SUB XEditTextNotExists(stEditTextNot$)
DECLARE SUB XSetEditText (stEditCaption$, stEditText$)
DECLARE SUB XOptionButtonExists(stOptionButton$)
DECLARE SUB XOptionButtonNotExists(stOptionButton$)
DECLARE SUB XOptionButtonEnabled(stOptionButton$)
DECLARE SUB XOptionButtonNotEnabled(stOptionButton$)
DECLARE SUB XOptionButtonChecked(stOptionButton$)
DECLARE SUB XOptionButtonNotChecked(stOptionButton$)
DECLARE SUB XClickOptionButton(stOptionButton$)
DECLARE FUNCTION BDialogBoxExists%(s$)
DECLARE FUNCTION BButtonExists%(stButtonName$)
DECLARE FUNCTION BButtonEnabled%(stButtonName$)
DECLARE FUNCTION BListBoxExists%(stListBox$)
DECLARE FUNCTION IGetListBoxItemCount%(stListBox$)
DECLARE FUNCTION BListBoxItemExists%(stListBox$, stListBoxItem$)
DECLARE FUNCTION SGetListBoxItemText$(stListBox$)
DECLARE FUNCTION BComboBoxExists%(stComboBox$)
DECLARE FUNCTION IGetComboBoxItemCount%(stComboBox$)
DECLARE FUNCTION BComboBoxItemExists%(stComboBox$, stComboBoxItem$)
DECLARE FUNCTION SGetComboBoxItemText$(stComboBox$)
DECLARE FUNCTION BCheckBoxExists%(stCheckBox$)
DECLARE FUNCTION BCheckBoxChecked%(stCheckBox$)
DECLARE FUNCTION BCheckBoxEnabled%(stCheckBox$)
DECLARE FUNCTION BEditTextExists%(stEditText$)
DECLARE FUNCTION SGetEditText$(stEditCaption$)
DECLARE FUNCTION BOptionButtonExists%(stOptionButton$)
DECLARE FUNCTION BOptionButtonEnabled%(stOptionButton$)
DECLARE FUNCTION BOptionButtonChecked%(stOptionButton$)

'Prototypes from FTestKey.mst
DECLARE SUB XKey (s$)
DECLARE SUB XAlt (s$)
DECLARE SUB XCtrl (s$)
DECLARE SUB XShift (s$)
DECLARE SUB XCtrlAlt (s$)
DECLARE SUB XAltShift (s$)
DECLARE SUB XCtrlShift (s$)
DECLARE SUB XCtrlAltShift (s$)
DECLARE SUB XText(s$)
DECLARE SUB XEnter(s$)
DECLARE SUB XSelectMenuItem(stMenu$,stMenuItem$,stHMenuItem$)
DECLARE SUB XMenuItemExists(stMenu$,stMenuItem$, stHMenuItem$)
DECLARE SUB XMenuItemNotExists(stMenu$,stMenuItem$, stHMenuItem$)
DECLARE SUB XMenuItemGrayed(stMenu$,stMenuItem$, stHMenuItem$)
DECLARE SUB XMenuItemNotGrayed(stMenu$,stMenuItem$, stHMenuItem$)
DECLARE SUB XMenuItemChecked(stMenu$,stMenuItem$, stHMenuItem$)
DECLARE SUB XMenuItemNotChecked(stMenu$,stMenuItem$, stHMenuItem$)
DECLARE SUB XMenuItemEnabled(stMenu$,stMenuItem$, stHMenuItem$)
DECLARE SUB XMenuItemNotEnabled(stMenu$,stMenuItem$, stHMenuItem$)
DECLARE SUB XCaptionExists(stCaption$)
DECLARE SUB XCaptionNotExists(stCaption$)
DECLARE SUB XZoomWindow
DECLARE SUB XMaxWindow
DECLARE SUB XWindowMaximized
DECLARE SUB XWindowNotMaximized
DECLARE SUB XMinWindow
DECLARE SUB XWindowMinimized
DECLARE SUB XWindowNotMinimized
DECLARE SUB XRestoreWindow
DECLARE SUB XSizeActiveWindow (iXPixels%, iYPixels%, fAbsOrRel%)
DECLARE SUB XMoveActiveWindow (iXPixels%, iYPixels%, fAbsOrRel%)
DECLARE FUNCTION SKeyString$(s$)
DECLARE FUNCTION SHideKeys$(s$)
DECLARE FUNCTION BMenuItemExists%(stMenu$,stMenuItem$,stHMenuItem$)
DECLARE FUNCTION IGetMenuCount%(stMenu$, stMenuItem$)
DECLARE FUNCTION SGetMenuItemText$(stMenu$,stMenuItem$, iIndex%)
DECLARE FUNCTION BMenuItemGrayed%(stMenu$, stMenuItem$, stHMenuItem$)
DECLARE FUNCTION BMenuItemChecked%(stMenu$, stMenuItem$, stHMenuItem$)
DECLARE FUNCTION BMenuItemEnabled%(stMenu$,stMenuItem$, stHMenuItem$)
DECLARE FUNCTION SGetCaption$()
DECLARE FUNCTION BWindowMaximized%
DECLARE FUNCTION BWindowMinimized%

'Prototypes from FTestUtl.mst
DECLARE SUB XFileExists(stFileSpec$)
DECLARE SUB XFileNotExists(stFileSpec$)
DECLARE SUB XFileCmp(stFileSpec1$,stFileSpec2$)
DECLARE SUB XFileNotCmp(stFileSpec1$,stFileSpec2$)
DECLARE SUB XDeleteFile(stFileSpec$)
DECLARE SUB XDeleteFileIfExists(stFileSpec$)
DECLARE SUB XCreateFile(stFileSpec$,s$)
DECLARE SUB XAppendFile(stFileSpec$,s$)
DECLARE SUB XWaitMessageFile(s$,Message$, WaitTime%)
DECLARE SUB XCWDCmp(s$)
DECLARE SUB XCWDNotCmp(s$)
DECLARE SUB XDriveCmp(s$)
DECLARE SUB XDriveNotCmp(s$)
DECLARE SUB XChangeCWD(s$)
DECLARE SUB XCreateDir(s$)
DECLARE SUB XChangeDrive(s$)
DECLARE SUB XStartApp(stAppName$, stClassname$)
DECLARE SUB XSetCleanup (sCleanup$)
DECLARE SUB XDoCleanup
DECLARE SUB XMoveMouse (x%, y%)
DECLARE SUB XClickMouse(button%, x%, y%)
DECLARE SUB XDblClickMouse(button%, x%, y%)
DECLARE SUB XDragMouse (button%, Begx%, Begy%, Endx%, Endy%)
DECLARE SUB XClipBoardCmp (s$)
DECLARE SUB XClipBoardNotCmp (s$)
DECLARE FUNCTION BFileExists%(stFileSpec$)
DECLARE FUNCTION BFileCmp%(stFileSpec1$,stFileSpec2$)
DECLARE FUNCTION BCWDCmp%(s$)
DECLARE FUNCTION BDriveCmp%(s$)
DECLARE FUNCTION HStartApp%(stAppName$)
DECLARE FUNCTION BClipBoardCmp (s$)




'$INCLUDE 'FTestLog.mst'
'$INCLUDE 'FTestKey.mst'
'$INCLUDE 'FTestUtl.mst'


' These routines have to be after the above includes so that
' the functions used are declared

ON END XDoCleanup

' Set a UAE trap and log failure if one occurs

TRAP UAETrap FROM "TESTDRVR.EXE"
    XSetTerminate TRUE
    XLogFailure "Application UAEed"
END TRAP

' in the FastTest code, gErrorType will be set to one of the following
' CASE items to be handled and set back to ET_NOTHING when the particular
' place where an error could occur is past.
ON ERROR GOTO XErrorHandler

GOTO UsersCode  ' branch around code used by On Error

XErrorHandler:  ' execute here on error conditions

    SELECT CASE gErrorType
        CASE 0
            XSetTerminate TRUE
            XLogFailure "Internal FastTest Error"    ' catch undeclared ET vars
        CASE ET_NOTHING
            XSetTerminate TRUE
            XLogFailure "Unexpected RunTime error;" + ERF + ":" + STR$(ERR) + " " + ERROR$(ERR)
        CASE ET_NEXT
            ' Code that uses this will check the global error variable
            ' and log an appropriate error if one occurred
            gfError = TRUE
            RESUME NEXT
        CASE ET_LOG ' something happened during logging, let user know
            Print "****** A Log error occurred ******"
            Pause "****** A Log error occurred ******"


            END

    END SELECT
    XSetTerminate TRUE
    XLogFailure "Internal FastTest error"


UsersCode:
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\issperr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:      issperr.h
//
//  Contents:  Constant definitions for OLE HRESULT values.
//
//  History:   dd-mmm-yy Author    Comment
//
//--------------------------------------------------------------------------

#pragma message("WARNING: issperr.h is an obsolete header file")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\isvbop.h ===
/*++ BUILD Version: 0001

Copyright (c) 1990-1999 Microsoft Corporation

Module Name:

    ISVBOP.H

Abstract:

    This is the header file supporting third party bops.
    isvbop.inc is the inc file for this h file.

Note:
    Following include file uses 'DB' to define assembly macros. Some
    assemblers use 'emit' instead. If you are using such a compiler,
    you will have to change db's to emit's.

--*/


#if _MSC_VER > 1000
#pragma once
#endif

#define BOP_3RDPARTY 0x58
#define BOP_UNSIMULATE 0xFE

/* XLATOFF */

/** RegisterModule - This Bop call is made from the 16 bit module
 *		     to register a third party DLL with the bop
 *		     manager. This call returns a handle to the
 *		     16bit caller which is to be used later to
 *		     dispatch a call to the DLL.
 *
 *  INPUT:
 *	Client DS:SI - asciiz string of DLL name.
 *      Client ES:DI - asciiz string of Init Routine in the DLL. (Optional)
 *	Client DS:BX - asciiz string to Dispatch routine in the DLL.
 *
 *  OUTPUT:
 *	SUCCESS:
 *	    Client Carry Clear
 *	    Client AX = Handle (non Zero)
 *	FAILURE:
 *	    Client Carry Set
 *	    Client AX = Error Code
 *		    AX = 1 - DLL not found
 *		    AX = 2 - Dispacth routine not found.
 *		    AX = 3 - Init Routine Not Found
 *		    AX = 4 - Insufficient Memory
 *
 *  NOTES:
 *	RegisterModule results in loading the DLL (specified in DS:SI).
 *      Its Init routine (specified in ES:DI) is called. Its Dispatch
 *	routine (specified in DS:BX) is stored away and all the calls
 *      made from DispatchCall are dispacthed to this routine.
 *      If ES and DI both are null than the caller did'nt supply the init
 *      routine.
 */

#define RegisterModule() _asm _emit 0xC4 _asm _emit 0xC4 _asm _emit BOP_3RDPARTY _asm _emit 0x0

/** UnRegisterModule - This Bop call is made from the 16 bit module
 *		       to unregister a third party DLL with the bop
 *		       manager.
 *
 *  INPUT:
 *	Client AX - Handle returned by RegisterModule Call.
 *
 *  OUTPUT:
 *	None (VDM Is terminated with a debug message if Handle is invalid)
 *
 *  NOTES:
 *	Use it if initialization of 16bit app fails after registering the
 *	Bop.
 */

#define UnRegisterModule() _asm _emit 0xC4 _asm _emit 0xC4 _asm _emit BOP_3RDPARTY _asm _emit 0x1

/** DispacthCall - This Bop call is made from the 16 bit module
 *		   to pass a request to its DLL.
 *
 *  INPUT:
 *	Client AX - Handle returned by RegisterModule Call.
 *
 *  OUTPUT:
 *	None (DLL should set the proper output registers etc.)
 *	(VDM Is terminated with a debug message if Handle is invalid)
 *
 *  NOTES:
 *	Use it to pass a request to 32bit DLL. The request index and the
 *	parameters are passed in different registers. These register settings
 *	are private to the 16bit module and its associated VDD. Bop manager
 *	does'nt know anything about these registers.
 */
#define DispatchCall()	 _asm _emit 0xC4 _asm _emit 0xC4 _asm _emit BOP_3RDPARTY _asm _emit 0x2

/*** VDDUnSimulate16
 *
 *   This service causes the simulation of intel instructions to stop and
 *   control to return to VDD.
 *
 *   INPUT
 *      None
 *
 *   OUTPUT
 *      None
 *
 *   NOTES
 *      This service is a macro intended for 16bit stub-drivers. At the
 *      end of worker routine stub-driver should use it.
 */

#define VDDUnSimulate16() _asm _emit 0xC4 _asm _emit 0xC4 _asm _emit BOP_UNSIMULATE

/* XLATON */


/* ASM
RegisterModule macro
    db	0C4h, 0C4h, BOP_3RDPARTY, 0
        endm

UnRegisterModule macro
    db	0C4h, 0C4h, BOP_3RDPARTY, 1
	endm

DispatchCall macro
    db	0C4h, 0C4h, BOP_3RDPARTY, 2
	endm

VDDUnSimulate16 macro
    db	0C4h, 0C4h, BOP_UNSIMULATE
	endm

 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ifguid.h ===
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    sdk\inc\ifguid.h

Abstract:

    Guids for well known (network) interfaces

Revision History:


--*/

#pragma once

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Software loopback for IP                                                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DEFINE_GUID(GUID_IpLoopbackInterface, 0xca6c0780, 0x7526, 0x11d2, 0xba, 0xf4, 0x00, 0x60, 0x08, 0x15, 0xa4, 0xbd);

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// RAS Server (Dial In) Interface for IP                                    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DEFINE_GUID(GUID_IpRasServerInterface, 0x6e06f030, 0x7526, 0x11d2, 0xba, 0xf4, 0x00, 0x60, 0x08, 0x15, 0xa4, 0xbd);

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// IPX internal interface                                                   //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DEFINE_GUID(GUID_IpxInternalInterface, 0xa571ba70, 0x7527, 0x11d2, 0xba, 0xf4, 0x00, 0x60, 0x08, 0x15, 0xa4, 0xbd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ipxconst.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    ipxconst.h

Abstract:

    This module contains the common constants and macros used
    by the IPX Routing Protocols

Author:

    Stefan Solomon  07/10/1995

Revision History:


--*/

#ifndef _IPXCONST_
#define _IPXCONST_

#if _MSC_VER > 1000
#pragma once
#endif

//
// Administrative States Definitions
//
// Note: these states correspond to the MIB admin states of ENABLED and DISABLED

#define ADMIN_STATE_DISABLED		    1
#define ADMIN_STATE_ENABLED		    2

// additional admin states used for netbios delivery.
//
// Note: these states correspond to the MIB states of:
//
// ENABLED_ONLY_FOR_NETBIOS_STATIC_ROUTING and
// ENABLED_ONLY_FOR_OPER_STATE_UP

#define ADMIN_STATE_ENABLED_ONLY_FOR_NETBIOS_STATIC_ROUTING	3
#define ADMIN_STATE_ENABLED_ONLY_FOR_OPER_STATE_UP		4

//
// Interface Operational States Definitions
//
// Note 1: applies to the IPX, RIP and SAP operational states
// Note 2: these states correspond to the MIB operational states of
//	   UP, DOWN and SLEEPING
//

#define OPER_STATE_DOWN			   1 // not operational
#define OPER_STATE_UP			   2 // operational & can pass packets
#define OPER_STATE_SLEEPING		   3 // operational but has to connect to pass packets

//
// Additional operational states in starting/stopping the router
//

#define OPER_STATE_STARTING		    4
#define OPER_STATE_STOPPING		    5

//
// Definitions and default values for the RIP and SAP Interface Info
//

// UpdateMode definitions
//

#define IPX_STANDARD_UPDATE		1 // Periodic update, every UpdateInterval
#define IPX_NO_UPDATE			2 // No update, used for static routes config
#define IPX_AUTO_STATIC_UPDATE		3 // AutoStatic triggered update

// PacketType definitions
//

#define IPX_STANDARD_PACKET_TYPE		1
#define IPX_RELIABLE_DELIVERY_PACKET_TYPE	2

// Pace definitions

#define IPX_PACE_DEFVAL 	18 // This corresponds to a 55 ms interpacketgap

// UpdateInterval definitions

#define IPX_UPDATE_INTERVAL_DEFVAL  60

//*********************************************************
//							  *
//		 IPX Route Entry Definitions		  *
//							  *
//*********************************************************

//
// IPX route entry defs for RTM mapping
//

#define   R_Interface		       RR_InterfaceID
#define   R_Protocol		       RR_RoutingProtocol

#define   R_Network		       RR_Network.N_NetNumber
#define   R_TickCount		       RR_FamilySpecificData.FSD_TickCount
#define   R_HopCount		       RR_FamilySpecificData.FSD_HopCount
#define   R_NextHopMacAddress	       RR_NextHopAddress.NHA_Mac

#define   R_Flags		       RR_FamilySpecificData.FSD_Flags

//
// Some particular interface indices values
//

#define MAX_INTERFACE_INDEX		0xFFFFFFFE
#define GLOBAL_INTERFACE_INDEX		0xFFFFFFFF

//
// Flags definitions
//

#define GLOBAL_WAN_ROUTE		0x00000001
#define DO_NOT_ADVERTISE_ROUTE		0x00000002

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\linkinfo.h ===
/*
 * Copyright (c) 1990-1999  Microsoft Corporation
 * linkinfo.h - LinkInfo ADT module description.
 */


#ifndef __LINKINFO_H__
#define __LINKINFO_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {                     /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Constants
 ************/

/* Define API decoration for direct export or import of DLL functions. */

#ifdef _LINKINFO_
#define LINKINFOAPI
#else
#define LINKINFOAPI        DECLSPEC_IMPORT
#endif


/* Types
 ********/

/* LinkInfo structure */

typedef struct _linkinfo
{
   /* size of LinkInfo structure, including ucbSize field */

   UINT ucbSize;
}
LINKINFO;
typedef LINKINFO *PLINKINFO;
typedef const LINKINFO CLINKINFO;
typedef const LINKINFO *PCLINKINFO;

/* input flags to ResolveLinkInfo() */

typedef enum _resolvelinkinfoinflags
{
   /* Set up connection to referent. */

   RLI_IFL_CONNECT      = 0x0001,

   /*
    * Set up temporary connection to referent.  May only be set if
    * RLI_IFL_CONNECT is also set.
    */

   RLI_IFL_TEMPORARY    = 0x0002,

   /* Allow interaction with user. */

   RLI_IFL_ALLOW_UI     = 0x0004,

   /* Resolve to redirected local device path. */

   RLI_IFL_REDIRECT     = 0x0008,

   /* Update source LinkInfo structure if necessary. */

   RLI_IFL_UPDATE       = 0x0010,

   /* Search matching local devices for missing volume. */

   RLI_IFL_LOCAL_SEARCH = 0x0020,

   /* flag combinations */

   ALL_RLI_IFLAGS       = (RLI_IFL_CONNECT |
                           RLI_IFL_TEMPORARY |
                           RLI_IFL_ALLOW_UI |
                           RLI_IFL_REDIRECT |
                           RLI_IFL_UPDATE |
                           RLI_IFL_LOCAL_SEARCH)
}
RESOLVELINKINFOINFLAGS;

/* output flags from ResolveLinkInfo() */

typedef enum _resolvelinkinfooutflags
{
   /*
    * Only set if RLI_IFL_UPDATE was set in dwInFlags.  The source LinkInfo
    * structure needs updating, and *ppliUpdated points to an updated LinkInfo
    * structure.
    */

   RLI_OFL_UPDATED      = 0x0001,

   /*
    * Only set if RLI_IFL_CONNECT was set in dwInFlags.  A connection to a net
    * resource was established to resolve the LinkInfo.  DisconnectLinkInfo()
    * should be called to shut down the connection when the caller is finished
    * with the remote referent.  DisconnectLinkInfo() need not be called if
    * RLI_IFL_TEMPORARY was also set in dwInFlags.
    */

   RLI_OFL_DISCONNECT   = 0x0002,

   /* flag combinations */

   ALL_RLI_OFLAGS       = (RLI_OFL_UPDATED |
                           RLI_OFL_DISCONNECT)
}
RESOLVELINKINFOOUTFLAGS;

/* LinkInfo data types used by GetLinkInfo() */

typedef enum _linkinfodatatype
{
   /* PCDWORD - pointer to volume's serial number */

   LIDT_VOLUME_SERIAL_NUMBER,

   /* PCUINT - pointer to volume's host drive type */

   LIDT_DRIVE_TYPE,

   /* PCSTR - pointer to volume's label */

   LIDT_VOLUME_LABEL,

   /* PCSTR - pointer to local base path */

   LIDT_LOCAL_BASE_PATH,

   /* PCSTR - pointer to parent network resource's name */

   LIDT_NET_RESOURCE,

   /* PCSTR - pointer to last device redirected to parent network resource */

   LIDT_REDIRECTED_DEVICE,

   /* PCSTR - pointer to common path suffix */

   LIDT_COMMON_PATH_SUFFIX,

   /* PCDWORD - pointer to network type */

   LIDT_NET_TYPE,

   /* PCWSTR - pointer to possible unicode volume label */

   LIDT_VOLUME_LABELW,

   /* PCSTR - pointer to possible unicode parent network resource's name */

   LIDT_NET_RESOURCEW,

   /* PCSTR - pointer to possible unicode last device redirected to parent network resource */

   LIDT_REDIRECTED_DEVICEW,

   /* PCWSTR - pointer to possible unicode local base path */

   LIDT_LOCAL_BASE_PATHW,

   /* PCWSTR - pointer to possible unicode common path suffix */

   LIDT_COMMON_PATH_SUFFIXW
}
LINKINFODATATYPE;

/* output flags from GetCanonicalPathInfo() */

typedef enum _getcanonicalpathinfooutflags
{
   /* The path is on a remote volume. */

   GCPI_OFL_REMOTE      = 0x0001,

   /* flag combinations */

   ALL_GCPI_OFLAGS      = GCPI_OFL_REMOTE
}
GETCANONICALPATHINFOOUTFLAGS;


/* Prototypes
 *************/

/* LinkInfo APIs */

LINKINFOAPI BOOL WINAPI CreateLinkInfoA(LPCSTR, PLINKINFO *);
LINKINFOAPI BOOL WINAPI CreateLinkInfoW(LPCWSTR, PLINKINFO *);

#ifdef UNICODE
#define CreateLinkInfo  CreateLinkInfoW
#else
#define CreateLinkInfo  CreateLinkInfoA
#endif

LINKINFOAPI void WINAPI DestroyLinkInfo(PLINKINFO);
LINKINFOAPI int WINAPI CompareLinkInfoReferents(PCLINKINFO, PCLINKINFO);
LINKINFOAPI int WINAPI CompareLinkInfoVolumes(PCLINKINFO, PCLINKINFO);

LINKINFOAPI BOOL WINAPI ResolveLinkInfoA(PCLINKINFO, LPSTR, DWORD, HWND, PDWORD, PLINKINFO *);
LINKINFOAPI BOOL WINAPI ResolveLinkInfoW(PCLINKINFO, LPWSTR, DWORD, HWND, PDWORD, PLINKINFO *);

#ifdef UNICODE
#define ResolveLinkInfo ResolveLinkInfoW
#else
#define ResolveLinkInfo ResolveLinkInfoA
#endif

LINKINFOAPI BOOL WINAPI DisconnectLinkInfo(PCLINKINFO);
LINKINFOAPI BOOL WINAPI GetLinkInfoData(PCLINKINFO, LINKINFODATATYPE, const VOID **);
LINKINFOAPI BOOL WINAPI IsValidLinkInfo(PCLINKINFO);

/* canonical path APIs */

LINKINFOAPI BOOL WINAPI GetCanonicalPathInfoA(LPCSTR, LPSTR, LPDWORD, LPSTR, LPSTR *);
LINKINFOAPI BOOL WINAPI GetCanonicalPathInfoW(LPCWSTR, LPWSTR, LPDWORD, LPWSTR, LPWSTR *);

#ifdef UNICODE
#define GetCanonicalPathInfo    GetCanonicalPathInfoW
#else
#define GetCanonicalPathInfo    GetCanonicalPathInfoA
#endif


#ifdef __cplusplus
}                                /* End of extern "C" {. */
#endif   /* __cplusplus */


#endif   /* ! __LINKINFO_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\isvbop.inc ===
; This is the inc file for isvbop.h.
; Please refer to isvbop.h for comments and notes on these interfaces
;
BOP_3RDPARTY	EQU	58H
BOP_UNSIMULATE	EQU	0FEH

RegisterModule macro
    db  0C4h, 0C4h, BOP_3RDPARTY, 0
        endm

UnRegisterModule macro
    db  0C4h, 0C4h, BOP_3RDPARTY, 1
        endm

DispatchCall macro
    db  0C4h, 0C4h, BOP_3RDPARTY, 2
        endm
 
VDDUnSimulate16 macro
    db	0C4h, 0C4h, BOP_UNSIMULATE
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\lrpcmon.h ===
// Copyright (c) 1990-1999  Microsoft Corporation
#ifndef _LRPCMON_H
#define _LRPCMON_H

#if _MSC_VER > 1000
#pragma once
#endif

// Creates a window and registers it with LRPC.  Also saves the address, size
// of the given static buffer; address of Notification routine.
//
// For every LRPC message processed LRPC posts an identical message to this
// window.  The message is processed: it content is formatted into the buffer.
// It then calls the notification routine.
//
STDAPI_(BOOL) StartMonitor(HINSTANCE hInst, FARPROC pNotify,
                                            LPOLESTR pBuf, DWORD dwBufSize);

STDAPI_(void) StopMonitor(void);

#define MINBUFSIZE 32 /* Minimum buffer size passed to StartMonitor */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ipxrtdef.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    ipxrtdef.h

Abstract:

    This module contains the definitions of the:

    interface management APIs structures
    ipx global router management APIs structures
    ipx router MIB management APIs structures

Author:

    Stefan Solomon  03/03/1995

Revision History:


--*/

#ifndef _IPXRTDEF_
#define _IPXRTDEF_

#if _MSC_VER > 1000
#pragma once
#endif

#include <ipxconst.h>
#include <ipxsap.h>
#include <ipxrip.h>
#include <stm.h>
#include <ipxtfflt.h>

//****************************************************************
//***							       ***
//***			Global Definitions		       ***
//***							       ***
//****************************************************************

//
//  Version of this router
//

#define IPX_ROUTER_VERSION_1		    RTR_INFO_BLOCK_VERSION

//
//  IPX Protocols
//

#define IPX_PROTOCOL_LOCAL		    1
#define IPX_PROTOCOL_STATIC		    2

//
// Interface Type Definitions for MIB reporting - these are mapped from the
// DDM interface type
//

#define IF_TYPE_OTHER				1
#define IF_TYPE_LAN				2
#define IF_TYPE_WAN_ROUTER			3
#define IF_TYPE_WAN_WORKSTATION			4  // remote workstation dialing in
#define IF_TYPE_INTERNAL			5  // the internal (virtual) interface
#define IF_TYPE_PERSONAL_WAN_ROUTER		6
#define IF_TYPE_ROUTER_WORKSTATION_DIALOUT	7  // local workstation dialing out
#define IF_TYPE_STANDALONE_WORKSTATION_DIALOUT	8

//
// Definitions for Table of Contents Entries Info Types
//

#define IPX_INTERFACE_INFO_TYPE			1
#define IPX_STATIC_ROUTE_INFO_TYPE		2
#define IPX_STATIC_SERVICE_INFO_TYPE		3
#define IPX_SERVICE_FILTER_INFO_TYPE		4
#define IPX_ROUTE_FILTER_INFO_TYPE		5
#define IPX_IN_TRAFFIC_FILTER_INFO_TYPE		6
#define IPX_ADAPTER_INFO_TYPE			7
#define IPXWAN_INTERFACE_INFO_TYPE		8
#define IPX_GLOBAL_INFO_TYPE			9
#define IPX_STATIC_NETBIOS_NAME_INFO_TYPE	10
#define IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE	11
#define IPX_OUT_TRAFFIC_FILTER_INFO_TYPE		12
#define IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE	13

//****************************************************************
//***							       ***
//***	Specific Info Structures In The Information Block      ***
//***							       ***
//****************************************************************

//*** IPX Router Manager Global Info ***

#define     IPX_SMALL_ROUTING_TABLE_HASH_SIZE	    31
#define     IPX_MEDIUM_ROUTING_TABLE_HASH_SIZE	    257
#define     IPX_LARGE_ROUTING_TABLE_HASH_SIZE	    2047

typedef struct _IPX_GLOBAL_INFO {

    ULONG	    RoutingTableHashSize;
    ULONG       EventLogMask;
    } IPX_GLOBAL_INFO, *PIPX_GLOBAL_INFO;


//*** IPX Interface Info ***

typedef struct _IPX_IF_INFO {

    ULONG	    AdminState;        // The desired state of the interface
    ULONG	    NetbiosAccept;     // Accept Netbios broadcast packets
    ULONG	    NetbiosDeliver;    // Deliver Netbios broadcast packets

    } IPX_IF_INFO, *PIPX_IF_INFO;


// Interface Device Type Definitions

#define IPX_DEDICATED_LINK	    1	// includes LAN, leased lines, frame-relay
#define IPX_DIALED_LINK 	    2	// dial on demand links

// Default values:
//
// AdminState: enabled - disabling it disables also RIP, SAP and anything else
// NetbiosAccept: enabled
// NetbiosDeliver: enabled on LAN interface, disabled on WAN interface
// IpxWanNegotiation: disabled.

// The interface name corresponds to the local adapter name in the case the
// interface is the local LAN. If the adapter is multiplexed with different
// packet types, there is a unique net number assigned to each pseudo-adapter.
// In this case the NetNumber is used to differentiate which pseudo-adapter gets
// this interface info.

//*** IPXWAN Interface Info ***

typedef struct _IPXWAN_IF_INFO {

    ULONG	    AdminState;  // Enable/Disable IPXWAN negotiation

    } IPXWAN_IF_INFO, *PIPXWAN_IF_INFO;

//*** Static Route Entry ***

typedef struct _IPX_STATIC_ROUTE_INFO {

    union {

    ULONG	DwordAlign;
    UCHAR	Network[4];  };
    USHORT	TickCount;
    USHORT	HopCount;
    UCHAR	NextHopMacAddress[6];

    } IPX_STATIC_ROUTE_INFO, *PIPX_STATIC_ROUTE_INFO;


//*** Static Service Entry ***

typedef IPX_SERVER_ENTRY IPX_STATIC_SERVICE_INFO, *PIPX_STATIC_SERVICE_INFO;


//*** Static Netbios Name Entry ***

typedef struct	_IPX_STATIC_NETBIOS_NAME_INFO {

    union {

    ULONG	DwordAlign;
    UCHAR	Name[16];     };

    } IPX_STATIC_NETBIOS_NAME_INFO, *PIPX_STATIC_NETBIOS_NAME_INFO;


//
// *** IPX LAN ADAPTER INFO ***
//

#define MAX_ADAPTER_NAME_LEN		    48

typedef struct _IPX_ADAPTER_INFO {

    ULONG	PacketType;
    WCHAR	AdapterName[MAX_ADAPTER_NAME_LEN];

    } IPX_ADAPTER_INFO, *PIPX_ADAPTER_INFO;

#define AUTO_DETECT_PACKET_TYPE 	    0xFFFFFFFF



// ***********************************************************
// ***							   ***
// ***		IPX MIB Table Identifiers		   ***
// ***							   ***
// ***********************************************************


#define IPX_BASE_ENTRY			    0
#define IPX_INTERFACE_TABLE		    1
#define IPX_DEST_TABLE			    2	 // IPX Best Routes Table
#define IPX_STATIC_ROUTE_TABLE		    3	 // IPX Static Routes Table
#define IPX_SERV_TABLE			    4	 // IPX Services Table
#define IPX_STATIC_SERV_TABLE		    5	 // IPX Static Services Table

#define MAX_IPX_MIB_TABLES		    6


//
// Some Global MIB Constants
//

// max size of the interface readable name

#define IPX_INTERFACE_ANSI_NAME_LEN	    48

// ***************************************************************************
//
// ***	     IPX MIB APIs Input/Output Structures For Each Table	   ***
//
//****************************************************************************

// Global definition of the MIB Identifier (locates the table and the row index)

typedef struct	_IF_TABLE_INDEX {

    ULONG	InterfaceIndex;

    } IF_TABLE_INDEX, *PIF_TABLE_INDEX;

typedef struct _ROUTING_TABLE_INDEX {

    UCHAR	Network[4];

    } ROUTING_TABLE_INDEX, *PROUTING_TABLE_INDEX;

typedef struct _STATIC_ROUTES_TABLE_INDEX {

    ULONG	InterfaceIndex;
    UCHAR	Network[4];

    } STATIC_ROUTES_TABLE_INDEX, *PSTATIC_ROUTES_TABLE_INDEX;

typedef struct _SERVICES_TABLE_INDEX {

    USHORT	ServiceType;
    UCHAR	ServiceName[48];

    } SERVICES_TABLE_INDEX, *PSERVICES_TABLE_INDEX;

typedef struct _STATIC_SERVICES_TABLE_INDEX {

    ULONG	InterfaceIndex;
    USHORT	ServiceType;
    UCHAR	ServiceName[48];

    } STATIC_SERVICES_TABLE_INDEX, *PSTATIC_SERVICES_TABLE_INDEX;

typedef union _IPX_MIB_INDEX {

    IF_TABLE_INDEX		InterfaceTableIndex;
    ROUTING_TABLE_INDEX		RoutingTableIndex;
    STATIC_ROUTES_TABLE_INDEX	StaticRoutesTableIndex;
    SERVICES_TABLE_INDEX	ServicesTableIndex;
    STATIC_SERVICES_TABLE_INDEX StaticServicesTableIndex;

    } IPX_MIB_INDEX, *PIPX_MIB_INDEX;

//**********************************************************************
//								       *
//	     INPUT DATA For: Get, GetFirst, GetNext		       *
//								       *
//**********************************************************************

typedef struct _IPX_MIB_GET_INPUT_DATA {

    ULONG		TableId;
    IPX_MIB_INDEX	MibIndex;

    } IPX_MIB_GET_INPUT_DATA, *PIPX_MIB_GET_INPUT_DATA;

typedef struct _IPXMIB_BASE {

    ULONG	    OperState;
    UCHAR	    PrimaryNetNumber[4];
    UCHAR	    Node[6];
    UCHAR	    SysName[IPX_INTERFACE_ANSI_NAME_LEN];
    ULONG	    MaxPathSplits;
    ULONG	    IfCount;
    ULONG	    DestCount;
    ULONG	    ServCount;

    } IPXMIB_BASE, *PIPXMIB_BASE;

// structure used to gather interface statistics

typedef struct _IPX_IF_STATS {

	ULONG		IfOperState;
	ULONG		MaxPacketSize;
	ULONG		InHdrErrors;
	ULONG		InFiltered;
	ULONG		InNoRoutes;
	ULONG		InDiscards;
	ULONG		InDelivers;
	ULONG		OutFiltered;
	ULONG		OutDiscards;
	ULONG		OutDelivers;
	ULONG		NetbiosReceived;
	ULONG		NetbiosSent;

	} IPX_IF_STATS, *PIPX_IF_STATS;

// structure describing the MIB Row for the IPX_INTERFACE_TABLE in the
// IPX_INTERFACE_GROUP

typedef struct _IPX_INTERFACE {

    ULONG	    InterfaceIndex;
    ULONG	    AdminState;
    ULONG	    AdapterIndex;
    UCHAR	    InterfaceName[IPX_INTERFACE_ANSI_NAME_LEN];
    ULONG	    InterfaceType;
    ULONG	    MediaType;
    UCHAR	    NetNumber[4];
    UCHAR	    MacAddress[6];
    ULONG	    Delay;
    ULONG	    Throughput;
    ULONG	    NetbiosAccept;
    ULONG	    NetbiosDeliver;
    ULONG	    EnableIpxWanNegotiation;
    IPX_IF_STATS    IfStats;

    } IPX_INTERFACE, *PIPX_INTERFACE;


typedef struct _IPX_ROUTE {

    ULONG	InterfaceIndex; // see ipxconst.h for specific indices definitions
    ULONG	Protocol;
    UCHAR	Network[4];
    USHORT	TickCount;
    USHORT	HopCount;
    UCHAR	NextHopMacAddress[6];
    ULONG	Flags;

    }  IPX_ROUTE, *PIPX_ROUTE;

//
// INPUT DATA For: Create, Delete, Set
//

typedef	union _IPX_MIB_ROW {

	IPX_INTERFACE	 Interface;
	IPX_ROUTE	 Route;
	IPX_SERVICE	 Service;

	} IPX_MIB_ROW, *PIPX_MIB_ROW;


typedef struct _IPX_MIB_SET_INPUT_DATA {

    ULONG		 TableId;
    IPX_MIB_ROW 	 MibRow;

    } IPX_MIB_SET_INPUT_DATA, *PIPX_MIB_SET_INPUT_DATA;

//
// ***			IPX Base Entry					***
//

// MIB Functions: Get

// INPUT DATA: IPX_MIB_GET_INPUT_DATA and Index is not used

// OUTPUT DATA:

//
// ***			IPX Interface Table				    ***
//

// MIB Functions: Get, GetFirst, GetNext, Set

// INPUT DATA: IPX_MIB_GET_INPUT_DATA and Index is IF_TABLE_INDEX for Get, GetFirst and GetNext
//	       IPX_MIB_SET_INPUT_DATA and MibRow is IPX_INTERFACE for Set

//
// OUTPUT DATA: described by the IPX_INTERFACE structure below
//

//
// ***			IPX Routes Table				   ***
//

// MIB Functions:  Get, GetFirst, GetNext

// INPUT DATA: IPX_MIB_INPUT_DATA with Index ROUTES_TABLE_INDEX

// OUTPUT DATA: IPX_ROUTE
//


//
// ***			IPX Static Routes Table				   ***
//

// MIB Functions:  Create, Delete, Get, GetFirst, GetNext, Set

// INPUT DATA: IPX_MIB_GET_INPUT_DATA with Index STATIC_ROUTES_TABLE_INDEX for Get, GetFirst, GetNext
//	       IPX_MIB_SET_INPUT_DATA and MibRow is IPX_ROUTE for Create, Delete, Set

// OUTPUT DATA: IPX_ROUTE
//

//
// ***			 IPX Services Table				   ***
//

// MIB Functions: Get, GetFirst, GetNext

// INPUT DATA: IPX_MIB_INPUT_DATA with Index SERVICES_TABLE_INDEX

// OUTPUT DATA: The output data is the structure IPX_SERVICE

//
// ***			 IPX Static Services Table			   ***
//

// MIB Functions: Create, Delete, Get, GetFirst, GetNext

// INPUT DATA: IPX_MIB_GET_INPUT_DATA with Index STATIC_SERVICES_TABLE_INDEX for Get, GetFirst, GetNext
//	       IPX_MIB_SET_INPUT_DATA and MibRow is IPX_SERVICE for Create, Delete and Set.

// OUTPUT DATA: IPX_SERVICE

#endif	 // _IPXRTDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\madcapcl.h ===
// Copyright (c) 1990-1999  Microsoft Corporation
#ifndef _MADCAPCL_H_
#define _MADCAPCL_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <time.h>

#if _MSC_VER > 1000
#pragma once
#endif

#define MCAST_CLIENT_ID_LEN 17

enum {
    MCAST_API_VERSION_0 = 0,
    MCAST_API_VERSION_1
};

#define MCAST_API_CURRENT_VERSION MCAST_API_VERSION_1

typedef unsigned short IP_ADDR_FAMILY;

typedef union _IPNG_ADDRESS {
    DWORD   IpAddrV4;
    BYTE    IpAddrV6[16];
} IPNG_ADDRESS, *PIPNG_ADDRESS;


/*++
Description:

    This union is used to pass both IPv4 and IPv6 style address.

Members:

    IpAddrV4 - IPv4 style address

    IpAddrV6 - IPv6 style address

--*/

typedef struct _MCAST_CLIENT_UID {
    LPBYTE ClientUID;
    DWORD ClientUIDLength;
} MCAST_CLIENT_UID, *LPMCAST_CLIENT_UID;

/*++
Description:

    This describes the unique clientID for each request.

Members:

    ClientUID - Buffer containing the clientID

    ClientUIDLength - The size of the above buffer in bytes.

--*/


typedef struct _MCAST_SCOPE_CTX {
    IPNG_ADDRESS      ScopeID;
    IPNG_ADDRESS      Interface;
    IPNG_ADDRESS      ServerID;
} MCAST_SCOPE_CTX, *PMCAST_SCOPE_CTX;

/*++
Description:

    This defines the handle of the scope from which the address
    is to be allocated/renewed/released.

Members:

    ScopeID - Scope ID is essentially first ip of the scope

    Interface - Interface on which this scope was found

    ServerID - IPAddress of the MADCAP server

--*/


typedef struct _MCAST_SCOPE_ENTRY {
    MCAST_SCOPE_CTX ScopeCtx;
    IPNG_ADDRESS      LastAddr;
    DWORD       TTL;
    UNICODE_STRING  ScopeDesc;
} MCAST_SCOPE_ENTRY, *PMCAST_SCOPE_ENTRY;

/*++
Description:

    This structure contains all the info pertaining to a given multicast
    scope.

Members:

    ScopeCtx - the handle for this scope

    LastAddr - last addr of the scope

    TTL - TTL value of this scope.

    ScopeDesc - user friendly description of scope

--*/



typedef struct _MCAST_LEASE_REQUEST {
    LONG        LeaseStartTime;
    LONG        MaxLeaseStartTime;
    DWORD       LeaseDuration;
    DWORD       MinLeaseDuration;
    IPNG_ADDRESS  ServerAddress;
    WORD        MinAddrCount;
    WORD        AddrCount;
    PBYTE       pAddrBuf;
} MCAST_LEASE_REQUEST, *PMCAST_LEASE_REQUEST;

/*++
Description:

    This structure is used to describe the request parameters for
    requesting/renewing/releasing multicast addresses

Members:

    LeaseStartTime - desired start time of the lease, pass 0 if desired start time
                     is current time. The desired time is specified in the number of seconds elapsed
                     since midnight (00:00:00), January 1, 1970, coordinated universal time.

    MaxLeaseStartTime - the maximum start time that the client is willing to accept.
                        Where time is the number of seconds elapsed since midnight (00:00:00),
                        January 1, 1970, coordinated universal time.

    LeaseDuration - desired lease time for the request, pass 0 if default
                    lease time is requested.

    MinLeaseDuration - the minimum lease time that the client is willing
                       to accept

    ServerAddress - server's ip address where this lease whas renewed/requested.
                    pass 0 if unknown (e.g in McastRequestAddress)

    MinAddrCount - minimum number of addresses that the client is willing
                   to accept

    AddrCount - the desired number of addresses requested/allocated/renewed.
                This also specifies the size of the array specified by Addr.

    pAddrBuf - buffer containing specific addresses being requested/renewed/released.
                For IPv4 it is a pointer to 4 byte addresses and for IPv6 it
                points to 16 byte chunks. Pass NULL if no specific addresses
                are requested.

Remarks:

    In MCAST_API_VERSION_1 version, the MaxLeaseStartTime, MinLeaseDuration and
    MinAddrCount are ignored by the API implementation. However, the clients should
    set appropriate desired values for these members so as when the OS update brings
    new implementation of the APIs then the clients can take advantage of it.

--*/


typedef struct _MCAST_LEASE_RESPONSE {
    LONG        LeaseStartTime;
    LONG        LeaseEndTime;
    IPNG_ADDRESS  ServerAddress;
    WORD        AddrCount;
    PBYTE       pAddrBuf;
} MCAST_LEASE_RESPONSE, *PMCAST_LEASE_RESPONSE;

/*++

Description:

    This structure is used to pass the response of the operation of
    requesting/renewing/releasing multicast addresses.

Members:

    LeaseStartTime - start time of the lease in number of seconds elapsed since
                     midnight (00:00:00), January 1, 1970, coordinated universal time.

    LeaseEndTime - time when lease ends, where time is the number of seconds elapsed
                   since midnight (00:00:00), January 1, 1970, coordinated universal time.

    ServerAddress - server's ip address where this lease is renewed/requested.

    AddrCount - number of addresses requested/allocated/renewed.
                This also specifies the size of the array specified by Addr.

    Addr - buffer containing addresses being requested/renewed/released. For IPv4
            it is a pointer to 4 byte addresses and for IPv6 it points to 16 byte chunks

--*/

DWORD
APIENTRY
McastApiStartup(
    IN  OUT  PDWORD   Version
    );

VOID
APIENTRY
McastApiCleanup(
    VOID
    );

DWORD
APIENTRY
McastGenUID(
    IN OUT LPMCAST_CLIENT_UID    pRequestID
    );

DWORD
APIENTRY
McastEnumerateScopes(
    IN     IP_ADDR_FAMILY       AddrFamily,
    IN     BOOL                 ReQuery,
    IN OUT PMCAST_SCOPE_ENTRY   pScopeList,
    IN OUT PDWORD               pScopeLen,
    OUT    PDWORD               pScopeCount
    );

DWORD
APIENTRY
McastRequestAddress(
    IN     IP_ADDR_FAMILY           AddrFamily,
    IN     LPMCAST_CLIENT_UID       pRequestID,
    IN     PMCAST_SCOPE_CTX         pScopeCtx,
    IN     PMCAST_LEASE_REQUEST     pAddrRequest,
    IN OUT PMCAST_LEASE_RESPONSE    pAddrResponse
    );

DWORD
APIENTRY
McastRenewAddress(
    IN     IP_ADDR_FAMILY           AddrFamily,
    IN     LPMCAST_CLIENT_UID       pRequestID,
    IN     PMCAST_LEASE_REQUEST     pRenewRequest,
    IN OUT PMCAST_LEASE_RESPONSE    pRenewResponse
    );

DWORD
APIENTRY
McastReleaseAddress(
    IN     IP_ADDR_FAMILY          AddrFamily,
    IN     LPMCAST_CLIENT_UID      pRequestID,
    IN     PMCAST_LEASE_REQUEST    pReleaseRequest
    );

#ifdef __cplusplus
}
#endif 
#endif _MADCAPCL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ipxtfflt.h ===
/*
Copyright (c) 1995-1999 Microsoft Corporation
    File  ipxfltdf.h

    Defines structures used with the ipx filter driver.
*/

#ifndef __ipxfltdf_h
#define __ipxfltdf_h

#if _MSC_VER > 1000
#pragma once
#endif

//*** IPX Traffic Filters ***
typedef struct _IPX_TRAFFIC_FILTER_GLOBAL_INFO {
	ULONG	FilterAction;	// Action if there is a match with
					// any filter on the interface
} IPX_TRAFFIC_FILTER_GLOBAL_INFO, *PIPX_TRAFFIC_FILTER_GLOBAL_INFO;

// FilterAction

#define IPX_TRAFFIC_FILTER_ACTION_PERMIT	1
#define IPX_TRAFFIC_FILTER_ACTION_DENY	    2

// general traffic filter info structure

typedef struct _IPX_TRAFFIC_FILTER_INFO {

    ULONG	FilterDefinition;
    UCHAR	DestinationNetwork[4];
    UCHAR	DestinationNetworkMask[4];
    UCHAR	DestinationNode[6];
    UCHAR	DestinationSocket[2];
    UCHAR	SourceNetwork[4];
    UCHAR	SourceNetworkMask[4];
    UCHAR	SourceNode[6];
    UCHAR	SourceSocket[2];
	UCHAR	PacketType;
    } IPX_TRAFFIC_FILTER_INFO, *PIPX_TRAFFIC_FILTER_INFO;

// FilterDefinition - Flags to specify relevant IPX address fields to filter on
#define IPX_TRAFFIC_FILTER_ON_SRCNET	0x00000001
#define IPX_TRAFFIC_FILTER_ON_SRCNODE	0x00000002
#define IPX_TRAFFIC_FILTER_ON_SRCSOCKET	0x00000004

#define IPX_TRAFFIC_FILTER_ON_DSTNET	0x00000010
#define IPX_TRAFFIC_FILTER_ON_DSTNODE	0x00000020
#define IPX_TRAFFIC_FILTER_ON_DSTSOCKET	0x00000040

#define IPX_TRAFFIC_FILTER_ON_PKTTYPE	0x00000100
#define IPX_TRAFFIC_FILTER_LOG_MATCHES	0x80000000

typedef struct _FLT_IF_SET_PARAMS {
	ULONG			InterfaceIndex;	// Index of the interface
	ULONG			FilterAction;	// Filter action
	ULONG			FilterSize;	// sizeof (IPX_TRAFFIC_FILTER_INFO)
} FLT_IF_SET_PARAMS, *PFLT_IF_SET_PARAMS;

typedef struct _FLT_IF_GET_PARAMS {
	ULONG			FilterAction;	// Filter action
	ULONG			FilterSize;	// sizeof (IPX_TRAFFIC_FILTER_INFO)
	ULONG			TotalSize;	// Total size of filter description
						// array
} FLT_IF_GET_PARAMS, *PFLT_IF_GET_PARAMS;

typedef struct _FLT_PACKET_LOG {
	ULONG			SrcIfIdx;	// Index of source if (-1 - unknown)
	ULONG			DstIfIdx;	// Index of dest if (-1 - unknown)
	USHORT			DataSize;	// Total size of the data (at least 30)
	USHORT			SeqNum;		// Sequence number to account for
						// packets lost to lack of buffer space
	UCHAR			Header[30];	// IPX packet header followed by the
						// data if any
} FLT_PACKET_LOG, *PFLT_PACKET_LOG;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mapi.h ===
/*
 *	M A P I . H
 *
 *  Messaging Applications Programming Interface.
 *
 *  Copyright 1993-1999 Microsoft Corporation. All Rights Reserved.
 *
 *  Purpose:
 *
 *    This file defines the structures and constants used by that
 *    subset of the Messaging Applications Programming Interface
 *    which is supported under Windows by Microsoft Mail for PC
 *    Networks version 3.x.
 */


#ifndef MAPI_H
#define MAPI_H

#if _MSC_VER > 1000
#pragma once
#endif

/*
 *  Types.
 */


#ifdef __cplusplus
extern "C" {
#endif


#ifndef EXPORT
#ifdef WIN16
#define EXPORT __export
#else
/* Additional special definitions here */
#define EXPORT
#endif
#endif

typedef unsigned long FAR * LPULONG;
typedef unsigned long       FLAGS;

#ifndef __LHANDLE
#define __LHANDLE
typedef ULONG_PTR       LHANDLE, FAR * LPLHANDLE;
#endif

typedef unsigned char FAR * LPBYTE;

#define    lhSessionNull    ((LHANDLE)0)

typedef struct
{
    ULONG ulReserved;            /* Reserved for future use (must be 0)     */
    ULONG flFlags;               /* Flags                                   */
    ULONG nPosition;             /* character in text to be replaced by attachment */
    LPSTR lpszPathName;          /* Full path name of attachment file       */
    LPSTR lpszFileName;          /* Original file name (optional)           */
    LPVOID lpFileType;           /* Attachment file type (can be lpMapiFileTagExt) */
} MapiFileDesc, FAR * lpMapiFileDesc;

#define MAPI_OLE                0x00000001
#define MAPI_OLE_STATIC         0x00000002


typedef struct
{
    ULONG ulReserved;           /* Reserved, must be zero.                  */
    ULONG cbTag;                /* Size (in bytes) of                       */
    LPBYTE lpTag;               /* X.400 OID for this attachment type       */
    ULONG cbEncoding;           /* Size (in bytes) of                       */
    LPBYTE lpEncoding;          /* X.400 OID for this attachment's encoding */
} MapiFileTagExt, FAR *lpMapiFileTagExt;


typedef struct
{
    ULONG ulReserved;           /* Reserved for future use                  */
    ULONG ulRecipClass;         /* Recipient class                          */
                                /* MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG    */
    LPSTR lpszName;             /* Recipient name                           */
    LPSTR lpszAddress;          /* Recipient address (optional)             */
    ULONG ulEIDSize;            /* Count in bytes of size of pEntryID       */
    LPVOID lpEntryID;           /* System-specific recipient reference      */
} MapiRecipDesc, FAR * lpMapiRecipDesc;

#ifndef MAPI_ORIG				/* also defined in mapix.h */
#define MAPI_ORIG   0           /* Recipient is message originator          */
#define MAPI_TO     1           /* Recipient is a primary recipient         */
#define MAPI_CC     2           /* Recipient is a copy recipient            */
#define MAPI_BCC    3           /* Recipient is blind copy recipient        */
#endif

typedef struct
{
    ULONG ulReserved;             /* Reserved for future use (M.B. 0)       */
    LPSTR lpszSubject;            /* Message Subject                        */
    LPSTR lpszNoteText;           /* Message Text                           */
    LPSTR lpszMessageType;        /* Message Class                          */
    LPSTR lpszDateReceived;       /* in YYYY/MM/DD HH:MM format             */
    LPSTR lpszConversationID;     /* conversation thread ID                 */
    FLAGS flFlags;                /* unread,return receipt                  */
    lpMapiRecipDesc lpOriginator; /* Originator descriptor                  */
    ULONG nRecipCount;            /* Number of recipients                   */
    lpMapiRecipDesc lpRecips;     /* Recipient descriptors                  */
    ULONG nFileCount;             /* # of file attachments                  */
    lpMapiFileDesc lpFiles;       /* Attachment descriptors                 */
} MapiMessage, FAR * lpMapiMessage;

#define MAPI_UNREAD             0x00000001
#define MAPI_RECEIPT_REQUESTED  0x00000002
#define MAPI_SENT               0x00000004


/*
 *  Entry points.
 */

/*
 *  flFlags values for Simple MAPI entry points. All documented flags are
 *  shown for each call. Duplicates are commented out but remain present
 *  for every call.
 */

/* MAPILogon() flags.       */

#define MAPI_LOGON_UI           0x00000001  /* Display logon UI             */
#ifndef MAPI_PASSWORD_UI
#define MAPI_PASSWORD_UI		0x00020000	/* prompt for password only     */
#endif
#define MAPI_NEW_SESSION        0x00000002  /* Don't use shared session     */
#define MAPI_FORCE_DOWNLOAD     0x00001000  /* Get new mail before return   */
#define MAPI_EXTENDED           0x00000020  /* Extended MAPI Logon          */

/* MAPISendMail() flags.    */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */

#ifndef MAPI_DIALOG				/* also defined in property.h */
#define MAPI_DIALOG             0x00000008  /* Display a send note UI       */
#endif
/*# define MAPI_USE_DEFAULT		0x00000040	   Use default profile in logon */

/* MAPIFindNext() flags.    */

#define MAPI_UNREAD_ONLY        0x00000020  /* Only unread messages         */
#define MAPI_GUARANTEE_FIFO     0x00000100  /* use date order               */
#define MAPI_LONG_MSGID			0x00004000	/* allow 512 char returned ID	*/

/* MAPIReadMail() flags.    */

#define MAPI_PEEK               0x00000080  /* Do not mark as read.         */
#define MAPI_SUPPRESS_ATTACH    0x00000800  /* header + body, no files      */
#define MAPI_ENVELOPE_ONLY      0x00000040  /* Only header information      */
#define MAPI_BODY_AS_FILE       0x00000200

/* MAPISaveMail() flags.    */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
/* #define MAPI_LONG_MSGID		0x00004000	/* allow 512 char returned ID	*/

/* MAPIAddress() flags.     */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */

/* MAPIDetails() flags.     */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
#define MAPI_AB_NOMODIFY        0x00000400  /* Don't allow mods of AB entries */

/* MAPIResolveName() flags. */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
/* #define MAPI_DIALOG          0x00000008     Prompt for choices if ambiguous */
/* #define MAPI_AB_NOMODIFY     0x00000400     Don't allow mods of AB entries */

typedef ULONG (FAR PASCAL MAPILOGON)(
	ULONG_PTR ulUIParam,
	LPSTR lpszProfileName,
	LPSTR lpszPassword,
	FLAGS flFlags,
	ULONG ulReserved,
	LPLHANDLE lplhSession
);
typedef MAPILOGON FAR *LPMAPILOGON;
MAPILOGON MAPILogon;

typedef ULONG (FAR PASCAL MAPILOGOFF)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	FLAGS flFlags,
	ULONG ulReserved
);
typedef MAPILOGOFF FAR *LPMAPILOGOFF;
MAPILOGOFF MAPILogoff;


typedef ULONG (FAR PASCAL MAPISENDMAIL)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	lpMapiMessage lpMessage,
	FLAGS flFlags,
	ULONG ulReserved
);
typedef MAPISENDMAIL FAR *LPMAPISENDMAIL;
MAPISENDMAIL MAPISendMail;


typedef ULONG (FAR PASCAL MAPISENDDOCUMENTS)(
	ULONG_PTR ulUIParam,
	LPSTR lpszDelimChar,
	LPSTR lpszFilePaths,
	LPSTR lpszFileNames,
	ULONG ulReserved
);
typedef MAPISENDDOCUMENTS FAR *LPMAPISENDDOCUMENTS;
MAPISENDDOCUMENTS MAPISendDocuments;


typedef ULONG (FAR PASCAL MAPIFINDNEXT)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	LPSTR lpszMessageType,
	LPSTR lpszSeedMessageID,
	FLAGS flFlags,
	ULONG ulReserved,
	LPSTR lpszMessageID
);
typedef MAPIFINDNEXT FAR *LPMAPIFINDNEXT;
MAPIFINDNEXT MAPIFindNext;

typedef ULONG (FAR PASCAL MAPIREADMAIL)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	LPSTR lpszMessageID,
	FLAGS flFlags,
	ULONG ulReserved,
	lpMapiMessage FAR *lppMessage
);
typedef MAPIREADMAIL FAR *LPMAPIREADMAIL;
MAPIREADMAIL MAPIReadMail;

typedef ULONG (FAR PASCAL MAPISAVEMAIL)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	lpMapiMessage lpMessage,
	FLAGS flFlags,
	ULONG ulReserved,
	LPSTR lpszMessageID
);
typedef MAPISAVEMAIL FAR *LPMAPISAVEMAIL;
MAPISAVEMAIL MAPISaveMail;

typedef ULONG (FAR PASCAL MAPIDELETEMAIL)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	LPSTR lpszMessageID,
	FLAGS flFlags,
	ULONG ulReserved
);
typedef MAPIDELETEMAIL FAR *LPMAPIDELETEMAIL;
MAPIDELETEMAIL MAPIDeleteMail;

typedef ULONG (EXPORT FAR PASCAL *LPMAPIFREEBUFFER)(LPVOID pv);

ULONG FAR PASCAL MAPIFreeBuffer(LPVOID pv);

typedef ULONG (FAR PASCAL MAPIADDRESS)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	LPSTR lpszCaption,
	ULONG nEditFields,
	LPSTR lpszLabels,
	ULONG nRecips,
	lpMapiRecipDesc lpRecips,
	FLAGS flFlags,
	ULONG ulReserved,
	LPULONG lpnNewRecips,
	lpMapiRecipDesc FAR *lppNewRecips
);
typedef MAPIADDRESS FAR *LPMAPIADDRESS;
MAPIADDRESS MAPIAddress;

typedef ULONG (FAR PASCAL MAPIDETAILS)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	lpMapiRecipDesc lpRecip,
	FLAGS flFlags,
	ULONG ulReserved
);
typedef MAPIDETAILS FAR *LPMAPIDETAILS;
MAPIDETAILS MAPIDetails;

typedef ULONG (FAR PASCAL MAPIRESOLVENAME)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	LPSTR lpszName,
	FLAGS flFlags,
	ULONG ulReserved,
	lpMapiRecipDesc FAR *lppRecip
);
typedef MAPIRESOLVENAME FAR *LPMAPIRESOLVENAME;
MAPIRESOLVENAME MAPIResolveName;

#ifndef SUCCESS_SUCCESS
#define SUCCESS_SUCCESS                 0
#endif
#define MAPI_USER_ABORT                 1
#define MAPI_E_USER_ABORT               MAPI_USER_ABORT
#define MAPI_E_FAILURE                  2
#define MAPI_E_LOGON_FAILURE            3
#define MAPI_E_LOGIN_FAILURE            MAPI_E_LOGON_FAILURE
#define MAPI_E_DISK_FULL                4
#define MAPI_E_INSUFFICIENT_MEMORY      5
#define MAPI_E_ACCESS_DENIED            6
#define MAPI_E_TOO_MANY_SESSIONS        8
#define MAPI_E_TOO_MANY_FILES           9
#define MAPI_E_TOO_MANY_RECIPIENTS      10
#define MAPI_E_ATTACHMENT_NOT_FOUND     11
#define MAPI_E_ATTACHMENT_OPEN_FAILURE  12
#define MAPI_E_ATTACHMENT_WRITE_FAILURE 13
#define MAPI_E_UNKNOWN_RECIPIENT        14
#define MAPI_E_BAD_RECIPTYPE            15
#define MAPI_E_NO_MESSAGES              16
#define MAPI_E_INVALID_MESSAGE          17
#define MAPI_E_TEXT_TOO_LARGE           18
#define MAPI_E_INVALID_SESSION          19
#define MAPI_E_TYPE_NOT_SUPPORTED       20
#define MAPI_E_AMBIGUOUS_RECIPIENT      21
#define MAPI_E_AMBIG_RECIP              MAPI_E_AMBIGUOUS_RECIPIENT
#define MAPI_E_MESSAGE_IN_USE           22
#define MAPI_E_NETWORK_FAILURE          23
#define MAPI_E_INVALID_EDITFIELDS       24
#define MAPI_E_INVALID_RECIPS           25
#define MAPI_E_NOT_SUPPORTED            26



#ifdef MAPIX_H
/*  Maps from a simple mapi session to a MAPI 1.0 extended mapi session */

STDMETHODIMP_(SCODE)
ScMAPIXFromSMAPI(LHANDLE lhSimpleSession,
				ULONG ulFlags,
				LPCIID lpInterface,
				LPMAPISESSION FAR * lppMAPISession);
#endif /* MAPIX_H */


#ifdef	__cplusplus
}		/*	extern "C" */
#endif

#endif /* MAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\macwin32.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       macwin32.h
//
//  Contents:   Macintosh Win32 function overrides for porting Win32 applications.
//
//
//----------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef _MAC

// These functions in the Win32 SDK already exist on the native Macintosh OS.
// To clarify that the user is calling the Win32 ported version rather than the
// native MacOS version, the Win32 versions are prefixed Afx.

//*****************  mmsystem.h
#ifdef _INC_MMSYSTEM

#ifdef CloseDriver
#undef CloseDriver
#endif
#define CloseDriver					AfxCloseDriver

#ifdef OpenDriver
#undef OpenDriver
#endif
#define OpenDriver					AfxOpenDriver

#endif //_INC_MMSYSTEM

//*****************  winbase.h
#ifdef _WINBASE_

#ifdef FlushInstructionCache
#undef FlushInstructionCache
#endif
#define FlushInstructionCache		AfxFlushInstructionCache

#ifdef GetCurrentProcess
#undef GetCurrentProcess
#endif
#define GetCurrentProcess			AfxGetCurrentProcess

#ifdef GetCurrentThread
#undef GetCurrentThread
#endif
#define GetCurrentThread			AfxGetCurrentThread

#ifdef LoadResource
#undef LoadResource
#endif
#define LoadResource				AfxLoadResource

#ifdef GetFileSize
#undef GetFileSize
#endif
#define GetFileSize					AfxGetFileSize

#endif //_WINBASE_

// **************   wingdi.h
#ifdef _WINGDI_

#ifdef AnimatePalette
#undef AnimatePalette
#endif
#define AnimatePalette				AfxAnimatePalette

#ifdef EqualRgn
#undef EqualRgn
#endif
#define EqualRgn					AfxEqualRgn

#ifdef FillRgn
#undef FillRgn
#endif
#define FillRgn						AfxFillRgn

#ifdef FrameRgn
#undef FrameRgn
#endif
#define FrameRgn					AfxFrameRgn

#ifdef GetPixel
#undef GetPixel
#endif
#define GetPixel					AfxGetPixel

#ifdef InvertRgn
#undef InvertRgn
#endif
#define InvertRgn					AfxInvertRgn

#ifdef LineTo
#undef LineTo
#endif
#define LineTo						AfxLineTo

#ifdef OffsetRgn
#undef OffsetRgn
#endif
#define OffsetRgn					AfxOffsetRgn

#ifdef PaintRgn
#undef PaintRgn
#endif
#define PaintRgn					AfxPaintRgn

#ifdef ResizePalette
#undef ResizePalette
#endif
#define ResizePalette				AfxResizePalette

#ifdef SetRectRgn
#undef SetRectRgn
#endif
#define SetRectRgn					AfxSetRectRgn

#ifdef GetPath
#undef GetPath
#endif
#define GetPath						AfxGetPath

#ifdef Polygon
#undef Polygon
#endif
#define Polygon						AfxPolygon

#endif // _WINGDI_

//********************* winnls.h
#ifdef  _WINNLS_

#ifdef CompareStringA
#undef CompareStringA
#endif
#define CompareStringA				AfxCompareStringA

#ifdef CompareStringW
#undef CompareStringW
#endif
#define CompareStringW				AfxCompareStringW

#ifdef GetLocaleInfoA
#undef GetLocaleInfoA
#endif
#define GetLocaleInfoA				AfxGetLocaleInfoA

#ifdef GetLocaleInfoW
#undef GetLocaleInfoW
#endif
#define GetLocaleInfoW				AfxGetLocaleInfoW

#endif //_WINNLS_

//******************** winreg.h
#ifdef _WINREG_

#ifdef RegCloseKey
#undef RegCloseKey
#endif
#define RegCloseKey					AfxRegCloseKey

#ifdef RegCreateKeyA
#undef RegCreateKeyA
#endif
#define RegCreateKeyA				AfxRegCreateKeyA

#ifdef RegCreateKeyW
#undef RegCreateKeyW
#endif
#define RegCreateKeyW				AfxRegCreateKeyW

#ifdef RegDeleteKeyA
#undef RegDeleteKeyA
#endif
#define	RegDeleteKeyA				AfxRegDeleteKeyA

#ifdef RegDeleteKeyW
#undef RegDeleteKeyW
#endif
#define RegDeleteKeyW				AfxRegDeleteKeyW

#ifdef RegDeleteValueA
#undef RegDeleteValueA
#endif
#define RegDeleteValueA				AfxRegDeleteValueA	

#ifdef RegDeleteValueW
#undef RegDeleteValueW
#endif
#define RegDeleteValueW				AfxRegDeleteValueW

#ifdef RegEnumKeyA
#undef RegEnumKeyA
#endif
#define RegEnumKeyA					AfxRegEnumKeyA

#ifdef RegEnumKeyW
#undef RegEnumKeyW
#endif
#define RegEnumKeyW					AfxRegEnumKeyW

#ifdef RegEnumValueA
#undef RegEnumValueA
#endif
#define RegEnumValueA				AfxRegEnumValueA

#ifdef RegEnumValueW
#undef RegEnumValueW
#endif
#define RegEnumValueW				AfxRegEnumValueW

#ifdef RegOpenKeyA
#undef RegOpenKeyA
#endif
#define RegOpenKeyA					AfxRegOpenKeyA

#ifdef RegOpenKeyW
#undef RegOpenKeyW
#endif
#define RegOpenKeyW					AfxRegOpenKeyW

#ifdef RegQueryValueA
#undef RegQueryValueA
#endif
#define RegQueryValueA				AfxRegQueryValueA

#ifdef RegQueryValueW
#undef RegQueryValueW
#endif
#define RegQueryValueW				AfxRegQueryValueW

#ifdef RegQueryValueExA
#undef RegQueryValueExA
#endif
#define RegQueryValueExA			AfxRegQueryValueExA

#ifdef RegQueryValueExW
#undef RegQueryValueExW
#endif
#define RegQueryValueExW			AfxRegQueryValueExW

#ifdef RegSetValueA
#undef RegSetValueA
#endif
#define RegSetValueA				AfxRegSetValueA

#ifdef RegSetValueW
#undef RegSetValueW
#endif
#define RegSetValueW				AfxRegSetValueW

#ifdef RegSetValueExA
#undef RegSetValueExA
#endif
#define RegSetValueExA				AfxRegSetValueExA

#ifdef RegSetValueExW
#undef RegSetValueExW
#endif
#define RegSetValueExW				AfxRegSetValueExW

#endif //_WINREG_

//****************  winuser.h
#ifdef _WINUSER_

#ifdef SendMessage
#undef SendMessage
#endif

#ifdef SendMessageA
#undef SendMessageA
#endif
#define SendMessageA				AfxSendMessageA

#ifdef SendMessageW
#undef SendMessageW
#endif
#define SendMessageW				AfxSendMessageW

#ifdef GetDoubleClickTime
#undef GetDoubleClickTime
#endif
#define GetDoubleClickTime			AfxGetDoubleClickTime

#ifdef GetClassInfo
#undef GetClassInfo
#endif

#ifdef GetClassInfoA
#undef GetClassInfoA
#endif
#define GetClassInfoA				AfxGetClassInfoA

#ifdef GetClassInfoW
#undef GetClassInfoW
#endif
#define GetClassInfoW				AfxGetClassInfoW

#ifdef ShowWindow
#undef ShowWindow
#endif
#define ShowWindow					AfxShowWindow

#ifdef CloseWindow
#undef CloseWindow
#endif
#define CloseWindow					AfxCloseWindow

#ifdef MoveWindow
#undef MoveWindow
#endif
#define MoveWindow					AfxMoveWindow

#ifdef IsWindowVisible
#undef IsWindowVisible
#endif
#define IsWindowVisible				AfxIsWindowVisible

#ifdef GetMenu
#undef GetMenu
#endif
#define GetMenu						AfxGetMenu

#ifdef DrawMenuBar
#undef DrawMenuBar
#endif
#define DrawMenuBar					AfxDrawMenuBar

#ifdef InsertMenu
#undef InsertMenu
#endif

#ifdef InsertMenuA
#undef InsertMenuA
#endif
#define InsertMenuA					AfxInsertMenuA

#ifdef InsertMenuW
#undef InsertMenuW
#endif
#define InsertMenuW					AfxInsertMenuW

#ifdef AppendMenu
#undef AppendMenu
#endif

#ifdef AppendMenuA
#undef AppendMenuA
#endif
#define AppendMenuA					AfxAppendMenuA

#ifdef AppendMenuW
#undef AppendMenuW
#endif
#define AppendMenuW					AfxAppendMenuW

#ifdef DeleteMenu
#undef DeleteMenu
#endif
#define DeleteMenu					AfxDeleteMenu


#ifdef InsertMenuItem
#undef InsertMenuItem
#endif

#ifdef InsertMenuItemA
#undef InsertMenuItemA
#endif
#define InsertMenuItemA				AfxInsertMenuItemA

#ifdef InsertMenuItemW
#undef InsertMenuItemW
#endif
#define InsertMenuItemW				AfxInsertMenuItemW

#ifdef DrawText
#undef DrawText
#endif

#ifdef DrawTextA
#undef DrawTextA
#endif
#define DrawTextA					AfxDrawTextA			

#ifdef DrawTextW
#undef DrawTextW
#endif
#define DrawTextW					AfxDrawTextW

#ifdef ShowCursor
#undef ShowCursor
#endif
#define ShowCursor					AfxShowCursor

#ifdef SetCursor
#undef SetCursor
#endif
#define SetCursor					AfxSetCursor

#ifdef GetCursor
#undef GetCursor
#endif
#define GetCursor					AfxGetCursor

#ifdef FillRect
#undef FillRect
#endif
#define FillRect					AfxFillRect

#ifdef FrameRect
#undef FrameRect
#endif
#define FrameRect					AfxFrameRect

#ifdef InvertRect
#undef InvertRect
#endif
#define InvertRect					AfxInvertRect

#ifdef SetRect
#undef SetRect
#endif
#define SetRect						AfxSetRect

#ifdef UnionRect
#undef UnionRect
#endif
#define UnionRect					AfxUnionRect

#ifdef OffsetRect
#undef OffsetRect
#endif
#define OffsetRect					AfxOffsetRect

#ifdef EqualRect
#undef EqualRect
#endif
#define EqualRect					AfxEqualRect

#ifdef PtInRect
#undef PtInRect
#endif
#define PtInRect					AfxPtInRect

#ifdef GetParent
#undef GetParent
#endif
#define GetParent					AfxGetParent	

#ifdef FindWindow
#undef FindWindow					
#endif

#ifdef FindWindowA
#undef FindWindowA
#endif
#define FindWindowA					AfxFindWindowA

#ifdef FindWindowW
#undef FindWindowW
#endif
#define FindWindowW					AfxFindWindowW

#define AfxGetNextWindow(hWnd, wCmd) GetWindow(hWnd, wCmd)

#endif //_WINUSER_

#endif //_MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\issper16.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:      issperr.h
//
//  Contents:  Constant definitions for OLE HRESULT values.
//
//  History:   dd-mmm-yy Author    Comment
//             20-Sep-93 richardw  genesis
//
//  Notes:
//     This is a generated file. Do not modify directly.
//     The MC tool generates this file from dsyserr.mc
//
//--------------------------------------------------------------------------
#ifndef _ISSPERR_H_
#define _ISSPERR_H_
#if _MSC_VER > 1000
#pragma once
#endif

// Define the status type.

#ifdef FACILITY_SECURITY
#undef FACILITY_SECURITY
#endif

#ifdef STATUS_SEVERITY_SUCCESS
#undef STATUS_SEVERITY_SUCCESS
#endif
//#ifdef STATUS_SEVERITY_ERROR
//#undef STATUS_SEVERITY_ERROR
//#endif

// Define the severities
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SECURITY                0x9
#define FACILITY_NULL                    0


//
// Define the severity codes
//
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_COERROR          0x2


//
// MessageId: SEC_E_INSUFFICIENT_MEMORY
//
// MessageText:
//
//  Not enough memory is available to complete this request
//
#define SEC_E_INSUFFICIENT_MEMORY        ((SECURITY_STATUS)0x1300)

//
// MessageId: SEC_E_INVALID_HANDLE
//
// MessageText:
//
//  The handle specified is invalid
//
#define SEC_E_INVALID_HANDLE             ((SECURITY_STATUS)0x1301)

//
// MessageId: SEC_E_UNSUPPORTED_FUNCTION
//
// MessageText:
//
//  The function requested is not supported
//
#define SEC_E_UNSUPPORTED_FUNCTION       ((SECURITY_STATUS)0x1302)


//
// MessageId: SEC_E_TARGET_UNKNOWN
//
// MessageText:
//
//  The specified target is unknown or unreachable
//
#define SEC_E_TARGET_UNKNOWN             ((SECURITY_STATUS)0x1303)

//
// MessageId: SEC_E_INTERNAL_ERROR
//
// MessageText:
//
//  The Local Security Authority cannot be contacted
//
#define SEC_E_INTERNAL_ERROR             ((SECURITY_STATUS)0x1304)

//
// MessageId: SEC_E_SECPKG_NOT_FOUND
//
// MessageText:
//
//  The requested security package does not exist
//
#define SEC_E_SECPKG_NOT_FOUND           ((SECURITY_STATUS)0x1305)


//
// MessageId: SEC_E_NOT_OWNER
//
// MessageText:
//
//  The caller is not the owner of the desired credentials
//
#define SEC_E_NOT_OWNER                  ((SECURITY_STATUS)0x1306)

//
// MessageId: SEC_E_CANNOT_INSTALL
//
// MessageText:
//
//  The security package failed to initialize, and cannot be installed
//
#define SEC_E_CANNOT_INSTALL             ((SECURITY_STATUS)0x1307)

//
// MessageId: SEC_E_INVALID_TOKEN
//
// MessageText:
//
//  The token supplied to the function is invalid
//
#define SEC_E_INVALID_TOKEN              ((SECURITY_STATUS)0x1308)

//
// MessageId: SEC_E_CANNOT_PACK
//
// MessageText:
//
//  The security package is not able to marshall the logon buffer,
//  so the logon attempt has failed
//
#define SEC_E_CANNOT_PACK                ((SECURITY_STATUS)0x1309)

//
// MessageId: SEC_E_QOP_NOT_SUPPORTED
//
// MessageText:
//
//  The per-message Quality of Protection is not supported by the
//  security package
//
#define SEC_E_QOP_NOT_SUPPORTED          ((SECURITY_STATUS)0x130A)

//
// MessageId: SEC_E_NO_IMPERSONATION
//
// MessageText:
//
//  The security context does not allow impersonation of the client
//
#define SEC_E_NO_IMPERSONATION           ((SECURITY_STATUS)0x130B)

//
// MessageId: SEC_E_LOGON_DENIED
//
// MessageText:
//
//  The logon attempt failed
//
#define SEC_E_LOGON_DENIED               ((SECURITY_STATUS)0x130C)

//
// MessageId: SEC_E_UNKNOWN_CREDENTIALS
//
// MessageText:
//
//  The credentials supplied to the package were not
//  recognized
//
#define SEC_E_UNKNOWN_CREDENTIALS        ((SECURITY_STATUS)0x130D)

//
// MessageId: SEC_E_NO_CREDENTIALS
//
// MessageText:
//
//  No credentials are available in the security package
//
#define SEC_E_NO_CREDENTIALS             ((SECURITY_STATUS)0x130E)

//
// MessageId: SEC_E_MESSAGE_ALTERED
//
// MessageText:
//
//  The message supplied for verification has been altered
//
#define SEC_E_MESSAGE_ALTERED            ((SECURITY_STATUS)0x130F)

//
// MessageId: SEC_E_OUT_OF_SEQUENCE
//
// MessageText:
//
//  The message supplied for verification is out of sequence
//
#define SEC_E_OUT_OF_SEQUENCE            ((SECURITY_STATUS)0x1310)

//
// MessageId: SEC_E_NO_AUTHENTICATING_AUTHORITY
//
// MessageText:
//
//  No authority could be contacted for authentication.
//
#define SEC_E_NO_AUTHENTICATING_AUTHORITY ((SECURITY_STATUS)0x1311)

// MessageId: SEC_E_CONTEXT_EXPIRED
//
// MessageText:
//
//  The context has expired and can no longer be used.
//
#define SEC_E_CONTEXT_EXPIRED            ((SECURITY_STATUS)0x1312)

//
// MessageId: SEC_E_INCOMPLETE_MESSAGE
//
// MessageText:
//
//  The supplied message is incomplete.  The signature was not verified.
//
#define SEC_E_INCOMPLETE_MESSAGE         ((SECURITY_STATUS)0x1313)

//
// MessageId: SEC_I_CONTINUE_NEEDED
//
// MessageText:
//
//  The function completed successfully, but must be called
//  again to complete the context
//
#define SEC_I_CONTINUE_NEEDED            ((SECURITY_STATUS)0x1012)

//
// MessageId: SEC_I_COMPLETE_NEEDED
//
// MessageText:
//
//  The function completed successfully, but CompleteToken
//  must be called
//
#define SEC_I_COMPLETE_NEEDED            ((SECURITY_STATUS)0x1013)

//
// MessageId: SEC_I_COMPLETE_AND_CONTINUE
//
// MessageText:
//
//  The function completed successfully, but both CompleteToken
//  and this function must be called to complete the context
//
#define SEC_I_COMPLETE_AND_CONTINUE      ((SECURITY_STATUS)0x1014)

//
// MessageId: SEC_I_LOCAL_LOGON
//
// MessageText:
//
//  The logon was completed, but no network authority was
//  available.  The logon was made using locally known information
//
#define SEC_I_LOCAL_LOGON                ((SECURITY_STATUS)0x1015)

//
// MessageId: SEC_E_OK
//
// MessageText:
//
//  Call completed successfully
//
#define SEC_E_OK                         ((SECURITY_STATUS)0x0000)

//
// Older error names for backwards compatibility
//


#define SEC_E_NOT_SUPPORTED              SEC_E_UNSUPPORTED_FUNCTION
#define SEC_E_NO_SPM                     SEC_E_INTERNAL_ERROR
#define SEC_E_BAD_PKGID                  SEC_E_SECPKG_NOT_FOUND


#endif // _ISSPERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mapicode.h ===
/*
 *	M A P I C O D E . H
 *
 *	Status Codes returned by MAPI routines
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPICODE_H
#define MAPICODE_H

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

/* Define S_OK and ITF_* */

#ifdef _WIN32
#include <winerror.h>
#endif

/*
 *	MAPI Status codes follow the style of OLE 2.0 sCodes as defined in the
 *	OLE 2.0 Programmer's Reference and header file scode.h (Windows 3.x)
 *	or winerror.h (Windows NT and Windows 95).
 *
 */

/*  On Windows 3.x, status codes have 32-bit values as follows:
 *
 *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+---------------------+-------+-------------------------------+
 *  |S|       Context       | Facil |               Code            |
 *  +-+---------------------+-------+-------------------------------+
 *
 *  where
 *
 *      S - is the severity code
 *
 *          0 - SEVERITY_SUCCESS
 *          1 - SEVERITY_ERROR
 *
 *      Context - context info
 *
 *      Facility - is the facility code
 *
 *			0x0 - FACILITY_NULL		generally useful errors ([SE]_*)
 *			0x1 - FACILITY_RPC		remote procedure call errors (RPC_E_*)
 *			0x2 - FACILITY_DISPATCH late binding dispatch errors
 *			0x3 - FACILITY_STORAGE  storage errors (STG_E_*)
 *			0x4 - FACILITY_ITF		interface-specific errors
 *
 *      Code - is the facility's status code
 *
 *
 */

/*
 *	On Windows NT 3.5 and Windows 95, scodes are 32-bit values
 *	laid out as follows:
 *	
 *	  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *	  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *	 +-+-+-+-+-+---------------------+-------------------------------+
 *	 |S|R|C|N|r|    Facility         |               Code            |
 *	 +-+-+-+-+-+---------------------+-------------------------------+
 *	
 *	 where
 *	
 *	    S - Severity - indicates success/fail
 *	
 *	        0 - Success
 *	        1 - Fail (COERROR)
 *	
 *	    R - reserved portion of the facility code, corresponds to NT's
 *	        second severity bit.
 *	
 *	    C - reserved portion of the facility code, corresponds to NT's
 *	        C field.
 *	
 *	    N - reserved portion of the facility code. Used to indicate a
 *	        mapped NT status value.
 *	
 *	    r - reserved portion of the facility code. Reserved for internal
 *	        use. Used to indicate HRESULT values that are not status
 *	        values, but are instead message ids for display strings.
 *	
 *	    Facility - is the facility code
 *			FACILITY_NULL                    0x0
 *			FACILITY_RPC                     0x1
 *			FACILITY_DISPATCH                0x2
 *			FACILITY_STORAGE                 0x3
 *			FACILITY_ITF                     0x4
 *			FACILITY_WIN32                   0x7
 *			FACILITY_WINDOWS                 0x8
 *	
 *	    Code - is the facility's status code
 *	
 */




/*
 * 	We can't use OLE 2.0 macros to build sCodes because the definition has
 *	changed and we wish to conform to the new definition.
 */
#define MAKE_MAPI_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

/* The following two macros are used to build OLE 2.0 style sCodes */

#define MAKE_MAPI_E( err )	(MAKE_MAPI_SCODE( 1, FACILITY_ITF, err ))
#define MAKE_MAPI_S( warn )	(MAKE_MAPI_SCODE( 0, FACILITY_ITF, warn ))

#ifdef	SUCCESS_SUCCESS
#undef	SUCCESS_SUCCESS
#endif
#define SUCCESS_SUCCESS		0L

/* General errors (used by more than one MAPI object) */

#define MAPI_E_CALL_FAILED								E_FAIL
#define MAPI_E_NOT_ENOUGH_MEMORY						E_OUTOFMEMORY
#define MAPI_E_INVALID_PARAMETER						E_INVALIDARG
#define MAPI_E_INTERFACE_NOT_SUPPORTED					E_NOINTERFACE
#define MAPI_E_NO_ACCESS								E_ACCESSDENIED

#define MAPI_E_NO_SUPPORT								MAKE_MAPI_E( 0x102 )
#define	MAPI_E_BAD_CHARWIDTH							MAKE_MAPI_E( 0x103 )
#define MAPI_E_STRING_TOO_LONG							MAKE_MAPI_E( 0x105 )
#define MAPI_E_UNKNOWN_FLAGS							MAKE_MAPI_E( 0x106 )
#define MAPI_E_INVALID_ENTRYID							MAKE_MAPI_E( 0x107 )
#define MAPI_E_INVALID_OBJECT							MAKE_MAPI_E( 0x108 )
#define MAPI_E_OBJECT_CHANGED							MAKE_MAPI_E( 0x109 )
#define MAPI_E_OBJECT_DELETED							MAKE_MAPI_E( 0x10A )
#define MAPI_E_BUSY			  							MAKE_MAPI_E( 0x10B )
#define MAPI_E_NOT_ENOUGH_DISK							MAKE_MAPI_E( 0x10D )
#define MAPI_E_NOT_ENOUGH_RESOURCES						MAKE_MAPI_E( 0x10E )
#define MAPI_E_NOT_FOUND 								MAKE_MAPI_E( 0x10F )
#define MAPI_E_VERSION				 					MAKE_MAPI_E( 0x110 )
#define MAPI_E_LOGON_FAILED								MAKE_MAPI_E( 0x111 )
#define MAPI_E_SESSION_LIMIT							MAKE_MAPI_E( 0x112 )
#define MAPI_E_USER_CANCEL								MAKE_MAPI_E( 0x113 )
#define MAPI_E_UNABLE_TO_ABORT							MAKE_MAPI_E( 0x114 )
#define MAPI_E_NETWORK_ERROR							MAKE_MAPI_E( 0x115 )
#define MAPI_E_DISK_ERROR								MAKE_MAPI_E( 0x116 )
#define MAPI_E_TOO_COMPLEX			 					MAKE_MAPI_E( 0x117 )
#define MAPI_E_BAD_COLUMN								MAKE_MAPI_E( 0x118 )
#define MAPI_E_EXTENDED_ERROR							MAKE_MAPI_E( 0x119 )
#define MAPI_E_COMPUTED									MAKE_MAPI_E( 0x11A )
#define MAPI_E_CORRUPT_DATA								MAKE_MAPI_E( 0x11B )
#define MAPI_E_UNCONFIGURED								MAKE_MAPI_E( 0x11C )
#define MAPI_E_FAILONEPROVIDER							MAKE_MAPI_E( 0x11D )
#define MAPI_E_UNKNOWN_CPID								MAKE_MAPI_E( 0x11E )
#define MAPI_E_UNKNOWN_LCID								MAKE_MAPI_E( 0x11F )

/* Flavors of E_ACCESSDENIED, used at logon */

#define MAPI_E_PASSWORD_CHANGE_REQUIRED					MAKE_MAPI_E( 0x120 )
#define MAPI_E_PASSWORD_EXPIRED							MAKE_MAPI_E( 0x121 )
#define MAPI_E_INVALID_WORKSTATION_ACCOUNT				MAKE_MAPI_E( 0x122 )
#define MAPI_E_INVALID_ACCESS_TIME						MAKE_MAPI_E( 0x123 )
#define MAPI_E_ACCOUNT_DISABLED							MAKE_MAPI_E( 0x124 )

/* MAPI base function and status object specific errors and warnings */

#define MAPI_E_END_OF_SESSION							MAKE_MAPI_E( 0x200 )
#define MAPI_E_UNKNOWN_ENTRYID							MAKE_MAPI_E( 0x201 )
#define MAPI_E_MISSING_REQUIRED_COLUMN					MAKE_MAPI_E( 0x202 )
#define MAPI_W_NO_SERVICE								MAKE_MAPI_S( 0x203 )

/* Property specific errors and warnings */

#define MAPI_E_BAD_VALUE			 					MAKE_MAPI_E( 0x301 )
#define MAPI_E_INVALID_TYPE								MAKE_MAPI_E( 0x302 )
#define MAPI_E_TYPE_NO_SUPPORT							MAKE_MAPI_E( 0x303 )
#define MAPI_E_UNEXPECTED_TYPE							MAKE_MAPI_E( 0x304 )
#define MAPI_E_TOO_BIG									MAKE_MAPI_E( 0x305 )
#define MAPI_E_DECLINE_COPY								MAKE_MAPI_E( 0x306 )
#define MAPI_E_UNEXPECTED_ID							MAKE_MAPI_E( 0x307 )

#define MAPI_W_ERRORS_RETURNED		 					MAKE_MAPI_S( 0x380 )

/* Table specific errors and warnings */

#define MAPI_E_UNABLE_TO_COMPLETE	 					MAKE_MAPI_E( 0x400 )
#define MAPI_E_TIMEOUT				 					MAKE_MAPI_E( 0x401 )
#define MAPI_E_TABLE_EMPTY			 					MAKE_MAPI_E( 0x402 )
#define MAPI_E_TABLE_TOO_BIG		 					MAKE_MAPI_E( 0x403 )

#define MAPI_E_INVALID_BOOKMARK		 					MAKE_MAPI_E( 0x405 )

#define MAPI_W_POSITION_CHANGED		  					MAKE_MAPI_S( 0x481 )
#define MAPI_W_APPROX_COUNT			  					MAKE_MAPI_S( 0x482 )

/* Transport specific errors and warnings */

#define MAPI_E_WAIT					  					MAKE_MAPI_E( 0x500 )
#define MAPI_E_CANCEL				  					MAKE_MAPI_E( 0x501 )
#define MAPI_E_NOT_ME				  					MAKE_MAPI_E( 0x502 )

#define MAPI_W_CANCEL_MESSAGE		  					MAKE_MAPI_S( 0x580 )

/* Message Store, Folder, and Message specific errors and warnings */

#define MAPI_E_CORRUPT_STORE		  					MAKE_MAPI_E( 0x600 )
#define MAPI_E_NOT_IN_QUEUE			  					MAKE_MAPI_E( 0x601 )
#define MAPI_E_NO_SUPPRESS			  					MAKE_MAPI_E( 0x602 )
#define MAPI_E_COLLISION			  					MAKE_MAPI_E( 0x604 )
#define MAPI_E_NOT_INITIALIZED							MAKE_MAPI_E( 0x605 )
#define MAPI_E_NON_STANDARD								MAKE_MAPI_E( 0x606 )
#define MAPI_E_NO_RECIPIENTS							MAKE_MAPI_E( 0x607 )
#define MAPI_E_SUBMITTED								MAKE_MAPI_E( 0x608 )
#define MAPI_E_HAS_FOLDERS								MAKE_MAPI_E( 0x609 )
#define MAPI_E_HAS_MESSAGES								MAKE_MAPI_E( 0x60A )
#define MAPI_E_FOLDER_CYCLE								MAKE_MAPI_E( 0x60B )

#define MAPI_W_PARTIAL_COMPLETION						MAKE_MAPI_S( 0x680 )

/* Address Book specific errors and warnings */

#define MAPI_E_AMBIGUOUS_RECIP							MAKE_MAPI_E( 0x700 )

/* The range 0x0800 to 0x08FF is reserved */

/* Obsolete typing shortcut that will go away eventually. */
#ifndef MakeResult
#define MakeResult(_s)	ResultFromScode(_s)
#endif

/* We expect these to eventually be defined by OLE, but for now,
 * here they are.  When OLE defines them they can be much more
 * efficient than these, but these are "proper" and don't make
 * use of any hidden tricks.
 */
#ifndef	HR_SUCCEEDED
#define	HR_SUCCEEDED(_hr) SUCCEEDED((SCODE)(_hr))
#define	HR_FAILED(_hr) FAILED((SCODE)(_hr))
#endif

#endif	/* MAPICODE_H */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mapidbg.h ===
/*
 *	M A P I D B G . H
 *
 *	Debugging support for MAPI service providers.
 *	Support functions are implemented in MAPIDBG.C.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef __MAPIDBG_H_
#define __MAPIDBG_H_

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

/*
 * Debugging Macros -------------------------------------------------------
 *
 *		IFDBG(x)		Results in the expression x if DEBUG is defined, or
 *						to nothing if DEBUG is not defined
 *	
 *		IFNDBG(x)		Results in the expression x if DEBUG is not defined,
 *						or to nothing if DEBUG is defined
 *	
 *		Unreferenced(a) Causes a to be referenced so that the compiler
 *						doesn't issue warnings about unused local variables
 *						which exist but are reserved for future use (eg
 *						ulFlags in many cases)
 */

#if defined(DEBUG)
#define IFDBG(x)			x
#define IFNDBG(x)
#else
#define IFDBG(x)
#define IFNDBG(x)			x
#endif

#ifdef __cplusplus
#define EXTERN_C_BEGIN		extern "C" {
#define EXTERN_C_END		}
#else
#define EXTERN_C_BEGIN
#define EXTERN_C_END
#endif

#define dimensionof(a) 		(sizeof(a)/sizeof(*(a)))

#define Unreferenced(a)		((void)(a))

typedef long SCODE;
typedef unsigned long ULONG;
typedef unsigned long DWORD;

/*
 *	 Assert Macros ---------------------------------------------------------
 *	
 *		Assert(a)		Displays a message indicating the file and line number
 *						of this Assert() if a == 0.  OK'ing an assert traps
 *						into the debugger.
 *	
 *		AssertSz(a,sz)	Works like an Assert(), but displays the string sz
 *						along with the file and line number.
 *	
 *		Side asserts	A side assert works like an Assert(), but evaluates
 *						'a' even when asserts are not enabled.
 *	
 *		NF asserts		A NF (Non-Fatal) assert works like an Assert(), but
 *						continues instead of trapping into the debugger when
 *						OK'ed.
 */

#if defined(DEBUG) || defined(ASSERTS_ENABLED)
#define IFTRAP(x)			x
#else
#define IFTRAP(x)			0
#endif

#define Trap()											IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Trap"))
#define TrapSz(psz)										IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz))
#define TrapSz1(psz,a1)									IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1))
#define TrapSz2(psz,a1,a2)								IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2))
#define TrapSz3(psz,a1,a2,a3)							IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3))
#define TrapSz4(psz,a1,a2,a3,a4)						IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4))
#define TrapSz5(psz,a1,a2,a3,a4,a5)						IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5))
#define TrapSz6(psz,a1,a2,a3,a4,a5,a6)					IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6))
#define TrapSz7(psz,a1,a2,a3,a4,a5,a6,a7)				IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7))
#define TrapSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)			IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8))
#define TrapSz9(psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)			IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9))

#define Assert(t)										IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define AssertSz(t,psz)									IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz),0))
#define AssertSz1(t,psz,a1)								IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1),0))
#define AssertSz2(t,psz,a1,a2)							IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2),0))
#define AssertSz3(t,psz,a1,a2,a3)						IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3),0))
#define AssertSz4(t,psz,a1,a2,a3,a4)					IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4),0))
#define AssertSz5(t,psz,a1,a2,a3,a4,a5)					IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5),0))
#define AssertSz6(t,psz,a1,a2,a3,a4,a5,a6)				IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define AssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)			IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define AssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)		IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))
#define AssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)		IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9),0))

#define SideAssert(t)									((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define SideAssertSz(t,psz)								((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz)),0)
#define SideAssertSz1(t,psz,a1)							((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1)),0)
#define SideAssertSz2(t,psz,a1,a2)						((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2)),0)
#define SideAssertSz3(t,psz,a1,a2,a3)					((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3)),0)
#define SideAssertSz4(t,psz,a1,a2,a3,a4)				((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4)),0)
#define SideAssertSz5(t,psz,a1,a2,a3,a4,a5)				((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define SideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)			((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define SideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)		((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define SideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)	((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)
#define SideAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)	((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)),0)

#define NFAssert(t)										IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define NFAssertSz(t,psz)								IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz),0))
#define NFAssertSz1(t,psz,a1)							IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1),0))
#define NFAssertSz2(t,psz,a1,a2)						IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2),0))
#define NFAssertSz3(t,psz,a1,a2,a3)						IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3),0))
#define NFAssertSz4(t,psz,a1,a2,a3,a4)					IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4),0))
#define NFAssertSz5(t,psz,a1,a2,a3,a4,a5)				IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5),0))
#define NFAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)			IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define NFAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)			IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define NFAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)		IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))
#define NFAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)	IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9),0))

#define NFSideAssert(t)									((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define NFSideAssertSz(t,psz)							((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz)),0)
#define NFSideAssertSz1(t,psz,a1)						((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1)),0)
#define NFSideAssertSz2(t,psz,a1,a2)					((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2)),0)
#define NFSideAssertSz3(t,psz,a1,a2,a3)					((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3)),0)
#define NFSideAssertSz4(t,psz,a1,a2,a3,a4)				((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4)),0)
#define NFSideAssertSz5(t,psz,a1,a2,a3,a4,a5)			((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define NFSideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)		((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define NFSideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)		((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define NFSideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)	((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)
#define NFSideAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)	((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)),0)

/*
 *	 Trace Macros ------------------------------------------------------------
 *	
 *		DebugTrace			Use for arbitrary formatted output. It
 *							takes exactly the same arguments as the
 *							Windows wsprintf() function.
 *		DebugTraceResult	Shorthand for error tracing with an
 *							HRESULT. Arguments are the name of the
 *							function (not quoted) and the HRESULT.
 *		DebugTraceSc		Shorthand for error tracing with an
 *							SCODE. Arguments are the name of the
 *							function (not quoted) and the SCODE.
 *		DebugTraceArg		Shorthand for invalid parameter
 *							tracing. Arguments are the name of the
 *							function (not quoted) and a quoted
 *							string describing the bad parameter.
 */

#if defined(DEBUG) || defined(TRACES_ENABLED)
#define IFTRACE(x)			x
#define DebugTrace			DebugTraceFn
#else
#define IFTRACE(x)			0
#define DebugTrace			1?0:DebugTraceFn
#endif

#define DebugTraceResult(f,hr)							IFTRACE(((hr) ? DebugTraceFn(#f " returns 0x%08lX %s\n", GetScode(hr), SzDecodeScode(GetScode(hr))) : 0))
#define DebugTraceSc(f,sc)								IFTRACE(((sc) ? DebugTraceFn(#f " returns 0x%08lX %s\n", sc, SzDecodeScode(sc)) : 0))
#define DebugTraceArg(f,s)								IFTRACE(DebugTraceFn(#f ": bad parameter: " s "\n"))
#define	DebugTraceLine()								IFTRACE(DebugTraceFn("File %s, Line %i	\n",__FILE__,__LINE__))
#define DebugTraceProblems(sz, rgprob)					IFTRACE(DebugTraceProblemsFn(sz, rgprob))

#define TraceSz(psz)									IFTRACE(DebugTraceFn("~" psz))
#define TraceSz1(psz,a1)								IFTRACE(DebugTraceFn("~" psz,a1))
#define TraceSz2(psz,a1,a2)								IFTRACE(DebugTraceFn("~" psz,a1,a2))
#define TraceSz3(psz,a1,a2,a3)							IFTRACE(DebugTraceFn("~" psz,a1,a2,a3))
#define TraceSz4(psz,a1,a2,a3,a4)						IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4))
#define TraceSz5(psz,a1,a2,a3,a4,a5)					IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5))
#define TraceSz6(psz,a1,a2,a3,a4,a5,a6)					IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6))
#define TraceSz7(psz,a1,a2,a3,a4,a5,a6,a7)				IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7))
#define TraceSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)			IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7,a8))
#define TraceSz9(psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)		IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7,a8,a9))

/* Debugging Functions ---------------------------------------------------- */

EXTERN_C_BEGIN

#ifdef WIN16
#define EXPORTDBG	__export
#else
#define EXPORTDBG
#endif

int EXPORTDBG __cdecl		DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...);
int EXPORTDBG __cdecl		DebugTraceFn(char *pszFormat, ...);
void EXPORTDBG __cdecl		DebugTraceProblemsFn(char *sz, void *rgprob);
char * EXPORTDBG __cdecl	SzDecodeScodeFn(SCODE sc);
char * EXPORTDBG __cdecl	SzDecodeUlPropTypeFn(unsigned long ulPropType);
char * EXPORTDBG __cdecl	SzDecodeUlPropTagFn(unsigned long ulPropTag);
unsigned long EXPORTDBG __cdecl UlPropTagFromSzFn(char *psz);
SCODE EXPORTDBG __cdecl		ScodeFromSzFn(char *psz);
void * EXPORTDBG __cdecl	DBGMEM_EncapsulateFn(void * pmalloc, char *pszSubsys, int fCheckOften);
void EXPORTDBG __cdecl		DBGMEM_ShutdownFn(void * pmalloc);
void EXPORTDBG __cdecl		DBGMEM_CheckMemFn(void * pmalloc, int fReportOrphans);
#if defined(_WIN32) && defined(_X86_)
void EXPORTDBG __cdecl		DBGMEM_LeakHook(FARPROC pfn);
void EXPORTDBG __cdecl		GetCallStack(DWORD *, int, int);
#endif
void EXPORTDBG __cdecl		DBGMEM_NoLeakDetectFn(void * pmalloc, void *pv);
void EXPORTDBG __cdecl		DBGMEM_SetFailureAtFn(void * pmalloc, ULONG ulFailureAt);
SCODE EXPORTDBG __cdecl		ScCheckScFn(SCODE, SCODE *, char *, char *, int);
void * EXPORTDBG __cdecl	VMAlloc(ULONG);
void * EXPORTDBG __cdecl	VMAllocEx(ULONG, ULONG);
void * EXPORTDBG __cdecl	VMRealloc(void *, ULONG);
void * EXPORTDBG __cdecl	VMReallocEx(void *, ULONG, ULONG);
ULONG EXPORTDBG __cdecl		VMGetSize(void *);
ULONG EXPORTDBG __cdecl		VMGetSizeEx(void *, ULONG);
void EXPORTDBG __cdecl		VMFree(void *);
void EXPORTDBG __cdecl		VMFreeEx(void *, ULONG);

EXTERN_C_END

/*
 *	Debugging Macros -------------------------------------------------------
 *	
 *		SzDecodeScode			Returns the string name of an SCODE
 *		SzDecodeUlPropTag		Returns the string name of a property
 *								tag
 *		UlPropTagFromSz			Given a property tag's name, returns
 *								its value
 *		ScodeFromSz				Given an SCODE's name, returns its
 *								value
 *	
 *		DBGMEM_Encapsulate		Given an IMalloc interface, adds heap-
 *								checking functionality and returns a
 *								wrapped interface
 *		DBGMEM_Shutdown			Undoes DBGMEM_Encapsulate, and prints
 *								out information on any allocations made
 *								since the interface was encapsulated
 *								that have not yet been released.
 *		DBGMEM_CheckMem			Checks all memory allocated on the heap,
 *								and optionally reports leaked blocks.
 *		DBGMEM_NoLeakDetect		Prevents a block from appearing on the leak
 *								report.  Pass NULL for pv to inhibit leak
 *								reports at all from this heap.
 */

#ifdef DEBUG

#define SzDecodeScode(_sc)				SzDecodeScodeFn(_sc)
#define SzDecodeUlPropType(_ulPropType)	SzDecodeUlPropTypeFn(_ulPropType)
#define SzDecodeUlPropTag(_ulPropTag)	SzDecodeUlPropTagFn(_ulPropTag)
#define UlPropTagFromSz(_sz)			UlPropTagFromSzFn(_sz)
#define ScodeFromSz(_sz)				ScodeFromSzFn(_sz)
#define DBGMEM_Encapsulate(pm, psz, f)	DBGMEM_EncapsulateFn(pm, psz, f)
#define DBGMEM_Shutdown(pm)				DBGMEM_ShutdownFn(pm)
#define DBGMEM_CheckMem(pm, f)			DBGMEM_CheckMemFn(pm, f)
#define DBGMEM_NoLeakDetect(pm,	pv)		DBGMEM_NoLeakDetectFn(pm, pv)
#define DBGMEM_SetFailureAt(pm, ul)		DBGMEM_SetFailureAtFn(pm, ul)

#else

#define SzDecodeScode(_sc)				(0)
#define SzDecodeUlPropType(_ulPropType)	(0)
#define SzDecodeUlPropTag(_ulPropTag)	(0)
#define UlPropTagFromSz(_sz)			(0)
#define ScodeFromSz(_sz)				(0)

#if defined(__cplusplus) && !defined(CINTERFACE)
#define DBGMEM_Encapsulate(pmalloc, pszSubsys, fCheckOften) \
	((pmalloc)->AddRef(), (pmalloc))
#define DBGMEM_Shutdown(pmalloc) \
	((pmalloc)->Release())
#else
#define DBGMEM_Encapsulate(pmalloc, pszSubsys, fCheckOften) \
	((pmalloc)->lpVtbl->AddRef(pmalloc), (pmalloc))
#define DBGMEM_Shutdown(pmalloc) \
	((pmalloc)->lpVtbl->Release(pmalloc))
#endif
#define DBGMEM_CheckMem(pm, f)
#define DBGMEM_NoLeakDetect(pm, pv)
#define DBGMEM_SetFailureAt(pm, ul)

#endif

/*
 *	SCODE maps -------------------------------------------------------------
 *	
 *		ScCheckSc		Given an SCODE and method name, verifies
 *						that the SCODE can legally be returned from
 *						thet method. Prints out a debug string if
 *						it cannot.
 *		HrCheckHr		As ScCheckSc, for functions that return
 *						HRESULT.
 */

#if defined(DEBUG) && !defined(DOS)
#define ScCheckSc(sc,fn)				ScCheckScFn(sc,fn##_Scodes,#fn,__FILE__, __LINE__)
#define HrCheckHr(hr,fn)				HrCheckSc(GetScode(hr),fn)
#else
#define ScCheckSc(sc,fn)				(sc)
#define HrCheckHr(hr,fn)				(hr)
#endif

#define HrCheckSc(sc,fn)				ResultFromScode(ScCheckSc(sc,fn))

#if defined(DEBUG) && !defined(DOS)
extern SCODE Common_Scodes[];
extern SCODE MAPILogon_Scodes[];
extern SCODE MAPIAllocateBuffer_Scodes[];
extern SCODE MAPIAllocateMore_Scodes[];
extern SCODE MAPIFreeBuffer_Scodes[];

extern SCODE IUnknown_QueryInterface_Scodes[];
extern SCODE IUnknown_AddRef_Scodes[];
extern SCODE IUnknown_Release_Scodes[];
extern SCODE IUnknown_GetLastError_Scodes[];

extern SCODE IMAPIProp_CopyTo_Scodes[];
extern SCODE IMAPIProp_CopyProps_Scodes[];
extern SCODE IMAPIProp_DeleteProps_Scodes[];
extern SCODE IMAPIProp_GetIDsFromNames_Scodes[];
extern SCODE IMAPIProp_GetLastError_Scodes[];
extern SCODE IMAPIProp_GetNamesFromIDs_Scodes[];
extern SCODE IMAPIProp_GetPropList_Scodes[];
extern SCODE IMAPIProp_GetProps_Scodes[];
extern SCODE IMAPIProp_OpenProperty_Scodes[];
extern SCODE IMAPIProp_SetProps_Scodes[];
extern SCODE IMAPIProp_SaveChanges_Scodes[];

extern SCODE IStream_Read_Scodes[];
extern SCODE IStream_Write_Scodes[];
extern SCODE IStream_Seek_Scodes[];
extern SCODE IStream_SetSize_Scodes[];
extern SCODE IStream_Tell_Scodes[];
extern SCODE IStream_LockRegion_Scodes[];
extern SCODE IStream_UnlockRegion_Scodes[];
extern SCODE IStream_Clone_Scodes[];
extern SCODE IStream_CopyTo_Scodes[];
extern SCODE IStream_Revert_Scodes[];
extern SCODE IStream_Stat_Scodes[];
extern SCODE IStream_Commit_Scodes[];

extern SCODE IMAPITable_GetLastError_Scodes[];
extern SCODE IMAPITable_Advise_Scodes[];
extern SCODE IMAPITable_Unadvise_Scodes[];
extern SCODE IMAPITable_GetStatus_Scodes[];
extern SCODE IMAPITable_SetColumns_Scodes[];
extern SCODE IMAPITable_QueryColumns_Scodes[];
extern SCODE IMAPITable_GetRowCount_Scodes[];
extern SCODE IMAPITable_SeekRow_Scodes[];
extern SCODE IMAPITable_SeekRowApprox_Scodes[];
extern SCODE IMAPITable_QueryPosition_Scodes[];
extern SCODE IMAPITable_FindRow_Scodes[];
extern SCODE IMAPITable_Restrict_Scodes[];
extern SCODE IMAPITable_CreateBookmark_Scodes[];
extern SCODE IMAPITable_FreeBookmark_Scodes[];
extern SCODE IMAPITable_SortTable_Scodes[];
extern SCODE IMAPITable_QuerySortOrder_Scodes[];
extern SCODE IMAPITable_QueryRows_Scodes[];
extern SCODE IMAPITable_Abort_Scodes[];
extern SCODE IMAPITable_ExpandRow_Scodes[];
extern SCODE IMAPITable_CollapseRow_Scodes[];
extern SCODE IMAPITable_WaitForCompletion_Scodes[];
extern SCODE IMAPITable_GetCollapseState_Scodes[];
extern SCODE IMAPITable_SetCollapseState_Scodes[];

extern SCODE IMAPISession_LogOff_Scodes[];
extern SCODE IMAPISession_Release_Scodes[];
extern SCODE IMAPISession_GetLastError_Scodes[];
extern SCODE IMAPISession_GetMsgStoresTable_Scodes[];
extern SCODE IMAPISession_GetStatusTable_Scodes[];
extern SCODE IMAPISession_OpenMsgStore_Scodes[];
extern SCODE IMAPISession_OpenAddressBook_Scodes[];
extern SCODE IMAPISession_OpenEntry_Scodes[];
extern SCODE IMAPISession_OpenProfileSection_Scodes[];
extern SCODE IMAPISession_Advise_Scodes[];
extern SCODE IMAPISession_Unadvise_Scodes[];
extern SCODE IMAPISession_CompareEntryIDs_Scodes[];
extern SCODE IMAPISession_MessageOptions_Scodes[];
extern SCODE IMAPISession_QueryDefaultMessageOpt_Scodes[];
extern SCODE IMAPISession_EnumAdrTypes_Scodes[];
extern SCODE IMAPISession_QueryIdentity_Scodes[];
extern SCODE IMAPISession_OpenProfileSection_Scodes[];
extern SCODE IMAPISession_GetStatusTable_Scodes[];

extern SCODE IMsgStore_Advise_Scodes[] ;
extern SCODE IMsgStore_Unadvise_Scodes[] ;
extern SCODE IMsgStore_CompareEntryIDs_Scodes[] ;
extern SCODE IMsgStore_OpenEntry_Scodes[] ;
extern SCODE IMsgStore_SetReceiveFolder_Scodes[];
extern SCODE IMsgStore_GetReceiveFolder_Scodes[];
extern SCODE IMsgStore_GetReceiveFolderTable_Scodes[];
extern SCODE IMsgStore_StoreLogoff_Scodes[];
extern SCODE IMsgStore_AbortSubmit_Scodes[];
extern SCODE IMsgStore_GetOutgoingQueue_Scodes[] ;
extern SCODE IMsgStore_SetLockState_Scodes[] ;
extern SCODE IMsgStore_FinishedMsg_Scodes[] ;
extern SCODE IMsgStore_NotifyNewMail_Scodes[];

extern SCODE IMAPIFolder_GetContentsTable_Scodes[];
extern SCODE IMAPIFolder_GetHierarchyTable_Scodes[];
extern SCODE IMAPIFolder_SaveContentsSort_Scodes[];
extern SCODE IMAPIFolder_OpenEntry_Scodes[];
extern SCODE IMAPIFolder_CreateMessage_Scodes[];
extern SCODE IMAPIFolder_CopyMessages_Scodes[];
extern SCODE IMAPIFolder_DeleteMessages_Scodes[];
extern SCODE IMAPIFolder_CreateFolder_Scodes[];
extern SCODE IMAPIFolder_CopyFolder_Scodes[];
extern SCODE IMAPIFolder_DeleteFolder_Scodes[];
extern SCODE IMAPIFolder_SetSearchCriteria_Scodes[];
extern SCODE IMAPIFolder_GetSearchCriteria_Scodes[];
extern SCODE IMAPIFolder_SetReadFlags_Scodes[];
extern SCODE IMAPIFolder_GetMessageStatus_Scodes[];
extern SCODE IMAPIFolder_SetMessageStatus_Scodes[];
extern SCODE IMAPIFolder_EmptyFolder_Scodes[];

extern SCODE IMessage_SaveChanges_Scodes[];
extern SCODE IMessage_GetAttachmentTable_Scodes[];
extern SCODE IMessage_OpenAttach_Scodes[];
extern SCODE IMessage_CreateAttach_Scodes[];
extern SCODE IMessage_DeleteAttach_Scodes[];
extern SCODE IMessage_GetRecipientTable_Scodes[];
extern SCODE IMessage_ModifyRecipients_Scodes[];
extern SCODE IMessage_SubmitMessage_Scodes[];
extern SCODE IMessage_SetReadFlag_Scodes[];

extern SCODE IAttach_SaveChanges_Scodes[];

extern SCODE IAddrBook_OpenEntry_Scodes[];
extern SCODE IAddrBook_CompareEntryIDs_Scodes[];
extern SCODE IAddrBook_CreateOneOff_Scodes[];
extern SCODE IAddrBook_ResolveName_Scodes[];
extern SCODE IAddrBook_Address_Scodes[];
extern SCODE IAddrBook_Details_Scodes[];
extern SCODE IAddrBook_RecipOptions_Scodes[];
extern SCODE IAddrBook_QueryDefaultRecipOpt_Scodes[];
extern SCODE IAddrBook_Address_Scodes[];
extern SCODE IAddrBook_ButtonPress_Scodes[];

extern SCODE IABContainer_GetContentsTable_Scodes[];
extern SCODE IABContainer_GetHierarchyTable_Scodes[];

extern SCODE INotifObj_ChangeEvMask_Scodes[];

extern SCODE IMAPIStatus_ChangePassword_Scodes[];
extern SCODE IMAPIStatus_FlushQueues_Scodes[];
extern SCODE IMAPIStatus_SettingsDialog_Scodes[];
extern SCODE IMAPIStatus_ValidateState_Scodes[];

extern SCODE IMSProvider_Logon_Scodes[];
extern SCODE IMSProvider_Deinit_Scodes[];
extern SCODE IMSProvider_Init_Scodes[];
extern SCODE IMSProvider_SpoolerLogon_Scodes[];
extern SCODE IMSProvider_Shutdown_Scodes[];

extern SCODE SMAPI_MAPILogon_Scodes[];
extern SCODE SMAPI_MAPILogoff_Scodes[];
extern SCODE SMAPI_MAPIFreeBuffer_Scodes[];
extern SCODE SMAPI_MAPISendMail_Scodes[];
extern SCODE SMAPI_MAPISendDocuments_Scodes[];
extern SCODE SMAPI_MAPIFindNext_Scodes[];
extern SCODE SMAPI_MAPIReadMail_Scodes[];
extern SCODE SMAPI_MAPISaveMail_Scodes[];
extern SCODE SMAPI_MAPIDeleteMail_Scodes[];
extern SCODE SMAPI_MAPIAddress_Scodes[];
extern SCODE SMAPI_MAPIResolveName_Scodes[];
extern SCODE SMAPI_MAPIDetails_Scodes[];

extern SCODE IMSLogon_OpenEntry_Scodes[];
extern SCODE IMSLogon_OpenStatusEntry_Scodes[];
extern SCODE IMSLogon_CompareEntryIDs_Scodes[];
extern SCODE IMSLogon_Advise_Scodes[];
extern SCODE IMSLogon_Unadvise_Scodes[];
extern SCODE IMSLogon_Logoff_Scodes[];
#endif

/* ------------------------------------------------------------------------ */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mapiform.h ===
/*
 *	M A P I F O R M . H
 *
 *	Declarations of interfaces for clients and providers of MAPI
 *  forms and form registries.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPIFORM_H
#define MAPIFORM_H

#if _MSC_VER > 1000
#pragma once
#endif

/* Include common MAPI header files if they haven't been already. */

#ifndef MAPIDEFS_H
#include <mapidefs.h>
#include <mapicode.h>
#include <mapiguid.h>
#include <mapitags.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#ifndef _MAC
typedef const RECT FAR *LPCRECT;
#endif

/* HFRMREG is an enumeration which represents a registry container.
 * Microsoft reserves the values from 0 to 0x3FFF for its own use.
 */

typedef ULONG HFRMREG;

#define HFRMREG_DEFAULT  0
#define HFRMREG_LOCAL    1
#define HFRMREG_PERSONAL 2
#define HFRMREG_FOLDER   3

DECLARE_MAPI_INTERFACE_PTR(IPersistMessage, LPPERSISTMESSAGE);
DECLARE_MAPI_INTERFACE_PTR(IMAPIMessageSite, LPMAPIMESSAGESITE);
DECLARE_MAPI_INTERFACE_PTR(IMAPISession, LPMAPISESSION);
DECLARE_MAPI_INTERFACE_PTR(IMAPIViewContext, LPMAPIVIEWCONTEXT);
DECLARE_MAPI_INTERFACE_PTR(IMAPIViewAdviseSink, LPMAPIVIEWADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormAdviseSink, LPMAPIFORMADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormInfo, LPMAPIFORMINFO);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormMgr, LPMAPIFORMMGR);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormContainer, LPMAPIFORMCONTAINER);
DECLARE_MAPI_INTERFACE_PTR(IMAPIForm, LPMAPIFORM);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormFactory, LPMAPIFORMFACTORY);

typedef const char FAR *FAR * LPPCSTR;
typedef LPMAPIFORMINFO FAR *LPPMAPIFORMINFO;

STDAPI MAPIOpenFormMgr(LPMAPISESSION pSession, LPMAPIFORMMGR FAR * ppmgr);
STDAPI MAPIOpenLocalFormContainer(LPMAPIFORMCONTAINER FAR * ppfcnt);


/*-- GetLastError ----------------------------------------------------------*/
/* This defines the GetLastError method held in common by most mapiform
 * interfaces.  It is defined separately so that an implementor may include
 * more than one mapiform interface in a class.
 */

#define MAPI_GETLASTERROR_METHOD(IPURE)                                 \
    MAPIMETHOD(GetLastError) (THIS_                                     \
        /*in*/  HRESULT hResult,                                        \
	/*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIERROR FAR * lppMAPIError) IPURE;                  \


/*-- IPersistMessage -------------------------------------------------------*/
/* This interface is implemented by forms and is used to save,
 * initialize and load forms to and from messages.
 */

#define MAPI_IPERSISTMESSAGE_METHODS(IPURE)                             \
    MAPIMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) IPURE;             \
    MAPIMETHOD(IsDirty)(THIS) IPURE;                                    \
    MAPIMETHOD(InitNew)(THIS_                                           \
        /*in*/ LPMAPIMESSAGESITE pMessageSite,                          \
        /*in*/ LPMESSAGE pMessage) IPURE;                               \
    MAPIMETHOD(Load)(THIS_                                              \
        /*in*/ LPMAPIMESSAGESITE pMessageSite,                          \
        /*in*/ LPMESSAGE pMessage,                                      \
		/*in*/ ULONG ulMessageStatus,                                   \
		/*in*/ ULONG ulMessageFlags) IPURE;                             \
    MAPIMETHOD(Save)(THIS_                                              \
        /*in*/ LPMESSAGE pMessage,                                      \
        /*in*/ ULONG fSameAsLoad) IPURE;                                \
    MAPIMETHOD(SaveCompleted)(THIS_                                     \
        /*in*/ LPMESSAGE pMessage) IPURE;                               \
    MAPIMETHOD(HandsOffMessage)(THIS) IPURE;                            \

#undef INTERFACE
#define INTERFACE IPersistMessage
DECLARE_MAPI_INTERFACE_(IPersistMessage, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IPERSISTMESSAGE_METHODS(PURE)
};


/*-- IMAPIMessageSite ------------------------------------------------------*/

#define MAPI_IMAPIMESSAGESITE_METHODS(IPURE)                            \
    MAPIMETHOD(GetSession) (THIS_                                       \
        /*out*/ LPMAPISESSION FAR * ppSession) IPURE;                   \
    MAPIMETHOD(GetStore) (THIS_                                         \
        /*out*/ LPMDB FAR * ppStore) IPURE;                             \
    MAPIMETHOD(GetFolder) (THIS_                                        \
        /*out*/ LPMAPIFOLDER FAR * ppFolder) IPURE;                     \
    MAPIMETHOD(GetMessage) (THIS_                                       \
        /*out*/ LPMESSAGE FAR * ppmsg) IPURE;                           \
    MAPIMETHOD(GetFormManager) (THIS_                                   \
        /*out*/ LPMAPIFORMMGR FAR * ppFormMgr) IPURE;                   \
    MAPIMETHOD(NewMessage) (THIS_                                       \
        /*in*/  ULONG fComposeInFolder,                                 \
        /*in*/  LPMAPIFOLDER pFolderFocus,                              \
        /*in*/  LPPERSISTMESSAGE pPersistMessage,                       \
        /*out*/ LPMESSAGE FAR * ppMessage,                              \
        /*out*/ LPMAPIMESSAGESITE FAR * ppMessageSite,                  \
        /*out*/ LPMAPIVIEWCONTEXT FAR * ppViewContext) IPURE;           \
    MAPIMETHOD(CopyMessage) (THIS_                                      \
        /*in*/  LPMAPIFOLDER pFolderDestination) IPURE;                 \
    MAPIMETHOD(MoveMessage) (THIS_                                      \
        /*in*/  LPMAPIFOLDER pFolderDestination,                        \
        /*in*/  LPMAPIVIEWCONTEXT pViewContext,                         \
        /*in*/  LPCRECT prcPosRect) IPURE;                              \
    MAPIMETHOD(DeleteMessage) (THIS_                                    \
        /*in*/  LPMAPIVIEWCONTEXT pViewContext,                         \
        /*in*/  LPCRECT prcPosRect) IPURE;                              \
    MAPIMETHOD(SaveMessage) (THIS) IPURE;                               \
    MAPIMETHOD(SubmitMessage) (THIS_                                    \
		/*in*/ ULONG ulFlags) IPURE;                                    \
    MAPIMETHOD(GetSiteStatus) (THIS_                                    \
		/*out*/ LPULONG lpulStatus) IPURE;                              \

#undef INTERFACE
#define INTERFACE IMAPIMessageSite
DECLARE_MAPI_INTERFACE_(IMAPIMessageSite, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIMESSAGESITE_METHODS(PURE)
};


/*-- IMAPIForm -------------------------------------------------------------*/
/* This interface is implemented by forms for the benefit of viewers.
 * One method (ShutdownForm) is provided such that simple forms implementing
 * only IMAPIForm and IPersistMessage have reasonable embedding behavior.
 */

#define MAPI_IMAPIFORM_METHODS(IPURE)                                   \
    MAPIMETHOD(SetViewContext) (THIS_                                   \
        /*in*/  LPMAPIVIEWCONTEXT pViewContext) IPURE;                  \
    MAPIMETHOD(GetViewContext) (THIS_                                   \
        /*out*/ LPMAPIVIEWCONTEXT FAR * ppViewContext) IPURE;           \
    MAPIMETHOD(ShutdownForm)(THIS_                                             \
        /*in*/  ULONG ulSaveOptions) IPURE;                             \
    MAPIMETHOD(DoVerb) (THIS_                                           \
        /*in*/  LONG iVerb,                                             \
        /*in*/  LPMAPIVIEWCONTEXT lpViewContext, /* can be null */      \
        /*in*/  ULONG hwndParent,                                       \
        /*in*/  LPCRECT lprcPosRect) IPURE;                             \
    MAPIMETHOD(Advise)(THIS_                                            \
        /*in*/  LPMAPIVIEWADVISESINK pAdvise,                           \
        /*out*/ ULONG FAR * pdwStatus) IPURE;                           \
    MAPIMETHOD(Unadvise) (THIS_                                         \
        /*in*/  ULONG ulConnection) IPURE;                              \

#undef INTERFACE
#define INTERFACE IMAPIForm
DECLARE_MAPI_INTERFACE_(IMAPIForm, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIFORM_METHODS(PURE)
};

typedef enum tagSAVEOPTS
{
	SAVEOPTS_SAVEIFDIRTY = 0,
	SAVEOPTS_NOSAVE = 1,
	SAVEOPTS_PROMPTSAVE = 2
} SAVEOPTS;


/*-- IMAPIViewContext ------------------------------------------------------*/
/* Implemented by viewers to support next/previous in forms.
 */

/* Structure passed in GetPrintSetup  */

typedef struct {
	ULONG ulFlags;  /* MAPI_UNICODE */
	HGLOBAL hDevMode;
	HGLOBAL hDevNames;
	ULONG ulFirstPageNumber;
	ULONG fPrintAttachments;
} FORMPRINTSETUP, FAR * LPFORMPRINTSETUP;

/* Values for pulFormat in GetSaveStream */

#define SAVE_FORMAT_TEXT                1
#define SAVE_FORMAT_RICHTEXT            2

/* Values from 0 to 0x3fff are reserved for future definition by Microsoft */

#define MAPI_IMAPIVIEWCONTEXT_METHODS(IPURE)                            \
    MAPIMETHOD(SetAdviseSink)(THIS_                                     \
        /*in*/  LPMAPIFORMADVISESINK pmvns) IPURE;                      \
    MAPIMETHOD(ActivateNext)(THIS_                                      \
        /*in*/  ULONG ulDir,                                            \
        /*in*/  LPCRECT prcPosRect) IPURE;                              \
    MAPIMETHOD(GetPrintSetup)(THIS_                                     \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPFORMPRINTSETUP FAR * lppFormPrintSetup) IPURE;        \
    MAPIMETHOD(GetSaveStream)(THIS_                                     \
        /*out*/ ULONG FAR * pulFlags,                                   \
        /*out*/ ULONG FAR * pulFormat,                                  \
        /*out*/ LPSTREAM FAR * ppstm) IPURE;                            \
    MAPIMETHOD(GetViewStatus) (THIS_                                    \
		/*out*/ LPULONG lpulStatus) IPURE;                              \

#undef INTERFACE
#define INTERFACE IMAPIViewContext
DECLARE_MAPI_INTERFACE_(IMAPIViewContext, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIVIEWCONTEXT_METHODS(PURE)
};

#define VCSTATUS_NEXT                           0x00000001
#define VCSTATUS_PREV                           0x00000002
#define VCSTATUS_MODAL                          0x00000004
#define VCSTATUS_INTERACTIVE                    0x00000008
#define VCSTATUS_READONLY                       0x00000010
#define VCSTATUS_DELETE                         0x00010000
#define VCSTATUS_COPY                           0x00020000
#define VCSTATUS_MOVE                           0x00040000
#define VCSTATUS_SUBMIT                         0x00080000
#define VCSTATUS_DELETE_IS_MOVE                 0x00100000
#define VCSTATUS_SAVE                           0x00200000
#define VCSTATUS_NEW_MESSAGE                    0x00400000

#define VCDIR_NEXT                              VCSTATUS_NEXT
#define VCDIR_PREV                              VCSTATUS_PREV
#define VCDIR_DELETE                            VCSTATUS_DELETE
#define VCDIR_MOVE                              VCSTATUS_MOVE


/*-- IMAPIFormAdviseSink ---------------------------------------------------*/
/* Part of form server, held by view; receives notifications from the view.
 *
 * This part of the form server, but is not an interface on the form
 * object.  This means that clients should not expect to QueryInterface
 * from an IMAPIForm* or IOleObject* to this interface, or vice versa.
 */

#define MAPI_IMAPIFORMADVISESINK_METHODS(IPURE)                         \
    STDMETHOD(OnChange)(THIS_ ULONG ulDir) IPURE;                       \
    STDMETHOD(OnActivateNext)(THIS_                                     \
        /*in*/  LPCSTR lpszMessageClass,                                \
        /*in*/  ULONG ulMessageStatus,                                  \
        /*in*/  ULONG ulMessageFlags,                                   \
        /*out*/ LPPERSISTMESSAGE FAR * ppPersistMessage) IPURE;         \

#undef INTERFACE
#define INTERFACE IMAPIFormAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIFormAdviseSink, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIFORMADVISESINK_METHODS(PURE)
};


/*-- IMAPIViewAdviseSink ---------------------------------------------------*/
/* Part of view context, held by form; receives notifications from the form.
 */

#define MAPI_IMAPIVIEWADVISESINK_METHODS(IPURE)                         \
    MAPIMETHOD(OnShutdown)(THIS) IPURE;                                    \
    MAPIMETHOD(OnNewMessage)(THIS) IPURE;                               \
    MAPIMETHOD(OnPrint)(THIS_                                           \
        /*in*/ ULONG dwPageNumber,                                      \
        /*in*/ HRESULT hrStatus) IPURE;                                 \
    MAPIMETHOD(OnSubmitted) (THIS) IPURE;                               \
    MAPIMETHOD(OnSaved) (THIS) IPURE;                                   \

#undef INTERFACE
#define INTERFACE IMAPIViewAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIViewAdviseSink, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIVIEWADVISESINK_METHODS(PURE)
};


/*-- IMAPIFormInfo ---------------------------------------------------------*/
/* Is implemented by registries.  Describes the form.
 */

/* Single enum value */

typedef struct
{								/* fpev */
	LPTSTR pszDisplayName;		/* carries the display string */
	ULONG nVal;					/* the value for the above enumeration */
} SMAPIFormPropEnumVal, FAR * LPMAPIFORMPROPENUMVAL;

/* MAPI Form property descriptor */

/*
 * Values for the tag in the SMAPIFormProp structure
 *
 * Microsoft reserves the range from 0 to 0x3FFF for future use in its other
 * forms registry implementations.
 */

typedef ULONG FORMPROPSPECIALTYPE;

#define FPST_VANILLA                    0
#define FPST_ENUM_PROP                  1

typedef struct
{
	ULONG ulFlags;				/* Contains MAPI_UNICODE if strings are UNICODE */
	ULONG nPropType;			/* type of the property, hiword is 0 */
	MAPINAMEID nmid;			/* id of the property */
	LPTSTR pszDisplayName;
	FORMPROPSPECIALTYPE nSpecialType;	/* tag for the following union */
	union
	{
		struct
		{
			MAPINAMEID nmidIdx;
			ULONG cfpevAvailable;	/* # of enums */
			LPMAPIFORMPROPENUMVAL pfpevAvailable;
		} s1;					/* Property String/Number association Enumeration */
	} u;
} SMAPIFormProp, FAR * LPMAPIFORMPROP;

/* Array of form properties */

typedef struct
{
	ULONG cProps;
	ULONG ulPad;				/* Pad to 8-byte alignment for insurance */
	SMAPIFormProp aFormProp[MAPI_DIM];
} SMAPIFormPropArray, FAR * LPMAPIFORMPROPARRAY;

#define CbMAPIFormPropArray(_c) \
         (offsetof(SMAPIFormPropArray, aFormProp) + \
         (_c)*sizeof(SMAPIFormProp))

/* Structure defining the layout of an mapi verb description */

typedef struct
{
	LONG lVerb;
	LPTSTR szVerbname;
	DWORD fuFlags;
	DWORD grfAttribs;
	ULONG ulFlags;				/* Either 0 or MAPI_UNICODE */
} SMAPIVerb, FAR * LPMAPIVERB;

/* Structure used for returning arrays of mapi verbs */

typedef struct
{
	ULONG cMAPIVerb;			/* Number of verbs in the structure */
	SMAPIVerb aMAPIVerb[MAPI_DIM];
} SMAPIVerbArray, FAR * LPMAPIVERBARRAY;

#define CbMAPIVerbArray(_c) \
         (offsetof(SMAPIVerbArray, aMAPIVerb) + \
         (_c)*sizeof(SMAPIVerb))

#define MAPI_IMAPIFORMINFO_METHODS(IPURE)                               \
    MAPIMETHOD(CalcFormPropSet)(THIS_                                   \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMPROPARRAY FAR * ppFormPropArray) IPURE;       \
    MAPIMETHOD(CalcVerbSet)(THIS_                                       \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIVERBARRAY FAR * ppMAPIVerbArray) IPURE;           \
    MAPIMETHOD(MakeIconFromBinary)(THIS_                                \
        /*in*/ ULONG nPropID,                                           \
        /*out*/ HICON FAR* phicon) IPURE;                               \
    MAPIMETHOD(SaveForm)(THIS_                                          \
        /*in*/ LPCTSTR szFileName) IPURE;                               \
    MAPIMETHOD(OpenFormContainer)(THIS_                                 \
        /*out*/ LPMAPIFORMCONTAINER FAR * ppformcontainer) IPURE;       \

#undef INTERFACE
#define INTERFACE IMAPIFormInfo
DECLARE_MAPI_INTERFACE_(IMAPIFormInfo, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE) 	/* note: subsumes getlasterror */
	MAPI_IMAPIFORMINFO_METHODS(PURE)
};


/* Enumeration of permissible values for PR_FORM_MESSAGE_BEHAVIOR */

#define	MAPI_MESSAGE_BEHAVIOR_IPM 0
#define	MAPI_MESSAGE_BEHAVIOR_FOLDER 1


/*-- IMAPIFormMgr ----------------------------------------------------------*/
/* The client-visible interface for form resolution and dispatch.
 */

/* Structure containing an array of message class strings */

typedef struct
{
	ULONG cValues;
	LPCSTR aMessageClass[MAPI_DIM];
} SMessageClassArray, FAR * LPSMESSAGECLASSARRAY;

#define CbMessageClassArray(_c) \
        (offsetof(SMessageClassArray, aMessageClass) + (_c)*sizeof(LPCSTR))

/* Structure containing an array of IMAPIFormInfo interfaces */

typedef struct
{
	ULONG cForms;
	LPMAPIFORMINFO aFormInfo[MAPI_DIM];
} SMAPIFormInfoArray, FAR * LPSMAPIFORMINFOARRAY;

#define CbMAPIFormInfoArray(_c) \
         (offsetof(SMAPIFormInfoArray, aFormInfo) + \
         (_c)*sizeof(LPMAPIFORMINFO))

/* Flags for IMAPIFormMgr::SelectFormContainer */

#define MAPIFORM_SELECT_ALL_REGISTRIES           0
#define MAPIFORM_SELECT_FOLDER_REGISTRY_ONLY     1
#define MAPIFORM_SELECT_NON_FOLDER_REGISTRY_ONLY 2

/* Flags for IMAPIFormMgr::CalcFormPropSet */

#define FORMPROPSET_UNION                 0
#define FORMPROPSET_INTERSECTION          1

/* Flags for IMAPIFormMgr::ResolveMessageClass and
   IMAPIFormMgr::ResolveMultipleMessageClasses */

#define MAPIFORM_EXACTMATCH             0x0020

#define MAPI_IMAPIFORMMGR_METHODS(IPURE)                                \
    MAPIMETHOD(LoadForm)(THIS_                                          \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPCSTR lpszMessageClass,                                \
        /*in*/  ULONG ulMessageStatus,                                  \
        /*in*/  ULONG ulMessageFlags,                                   \
        /*in*/  LPMAPIFOLDER pFolderFocus,                              \
        /*in*/  LPMAPIMESSAGESITE pMessageSite,                         \
        /*in*/  LPMESSAGE pmsg,                                         \
        /*in*/  LPMAPIVIEWCONTEXT pViewContext,                         \
        /*in*/  REFIID riid,                                            \
        /*out*/ LPVOID FAR *ppvObj) IPURE;                              \
    MAPIMETHOD(ResolveMessageClass)(THIS_                               \
        /*in*/  LPCSTR szMsgClass,                                      \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPMAPIFOLDER pFolderFocus, /* can be null */            \
        /*out*/ LPMAPIFORMINFO FAR* ppResult) IPURE;                    \
    MAPIMETHOD(ResolveMultipleMessageClasses)(THIS_                     \
        /*in*/  LPSMESSAGECLASSARRAY pMsgClasses,                       \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPMAPIFOLDER pFolderFocus, /* can be null */            \
        /*out*/ LPSMAPIFORMINFOARRAY FAR * pfrminfoarray) IPURE;        \
    MAPIMETHOD(CalcFormPropSet)(THIS_                                   \
        /*in*/  LPSMAPIFORMINFOARRAY pfrminfoarray,                     \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMPROPARRAY FAR* ppResults) IPURE;              \
    MAPIMETHOD(CreateForm)(THIS_                                        \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPMAPIFORMINFO pfrminfoToActivate,                      \
        /*in*/  REFIID refiidToAsk,                                     \
        /*out*/ LPVOID FAR* ppvObj) IPURE;                              \
    MAPIMETHOD(SelectForm)(THIS_                                        \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPCTSTR pszTitle,                                       \
        /*in*/  LPMAPIFOLDER pfld,                                      \
        /*out*/ LPMAPIFORMINFO FAR * ppfrminfoReturned) IPURE;          \
    MAPIMETHOD(SelectMultipleForms)(THIS_                               \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPCTSTR pszTitle,                                       \
        /*in*/  LPMAPIFOLDER pfld,                                      \
        /*in*/  LPSMAPIFORMINFOARRAY pfrminfoarray,                     \
        /*out*/ LPSMAPIFORMINFOARRAY FAR * ppfrminfoarray) IPURE;       \
    MAPIMETHOD(SelectFormContainer)(THIS_                               \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMCONTAINER FAR * lppfcnt) IPURE;               \
    MAPIMETHOD(OpenFormContainer)(THIS_                                 \
        /*in*/  HFRMREG hfrmreg,                                        \
        /*in*/  LPUNKNOWN lpunk,                                        \
        /*out*/ LPMAPIFORMCONTAINER FAR * lppfcnt) IPURE;               \
    MAPIMETHOD(PrepareForm)(THIS_                                       \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPMAPIFORMINFO pfrminfo) IPURE;                         \
    MAPIMETHOD(IsInConflict)(THIS_                                      \
        /*in*/  ULONG ulMessageFlags,                                   \
        /*in*/  ULONG ulMessageStatus,                                  \
        /*in*/  LPCSTR szMessageClass,                                  \
        /*in*/  LPMAPIFOLDER pFolderFocus) IPURE;                       \

#undef         INTERFACE
#define         INTERFACE    IMAPIFormMgr
DECLARE_MAPI_INTERFACE_(IMAPIFormMgr, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIFORMMGR_METHODS(PURE)
};

/* Platform numbers (used in .CFG files for forms) */

#define MAPIFORM_CPU_X86                1
#define MAPIFORM_CPU_MIP                2
#define MAPIFORM_CPU_AXP                3
#define MAPIFORM_CPU_PPC                4
#define MAPIFORM_CPU_M68                5

#define MAPIFORM_OS_WIN_31              1
#define MAPIFORM_OS_WINNT_35            2
#define MAPIFORM_OS_WIN_95              3
#define MAPIFORM_OS_MAC_7x              4
#define MAPIFORM_OS_WINNT_40            5

#define MAPIFORM_PLATFORM(CPU, OS) ((ULONG) ((((ULONG) CPU) << 16) | OS))


/*-- IMAPIFormContainer -------------------------------------------------*/

/*  Flags for IMAPIFormMgr::CalcFormPropSet */

/* #define FORMPROPSET_UNION            0   */
/* #define FORMPROPSET_INTERSECTION     1   */

/*  Flags for IMAPIFormMgr::InstallForm     */

#define MAPIFORM_INSTALL_DIALOG                 MAPI_DIALOG
#define MAPIFORM_INSTALL_OVERWRITEONCONFLICT    0x0010

/*  Flags for IMAPIFormContainer::ResolveMessageClass and
    IMAPIFormContainer::ResolveMultipleMessageClasses */
/* #define MAPIFORM_EXACTIMATCH    0x0020   */

#define MAPI_IMAPIFORMCONTAINER_METHODS(IPURE)                       \
    MAPIMETHOD(InstallForm)(THIS_                                   \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPCTSTR szCfgPathName) IPURE;                           \
    MAPIMETHOD(RemoveForm)(THIS_                                        \
        /*in*/  LPCSTR szMessageClass) IPURE;                           \
    MAPIMETHOD(ResolveMessageClass) (THIS_                              \
        /*in*/  LPCSTR szMessageClass,                                  \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMINFO FAR * pforminfo) IPURE;                  \
    MAPIMETHOD(ResolveMultipleMessageClasses) (THIS_                    \
        /*in*/  LPSMESSAGECLASSARRAY pMsgClassArray,                    \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPSMAPIFORMINFOARRAY FAR * ppfrminfoarray) IPURE;       \
    MAPIMETHOD(CalcFormPropSet)(THIS_                                   \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMPROPARRAY FAR * ppResults) IPURE;             \
    MAPIMETHOD(GetDisplay)(THIS_                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPTSTR FAR * pszDisplayName) IPURE;                     \

#undef INTERFACE
#define INTERFACE IMAPIFormContainer
DECLARE_MAPI_INTERFACE_(IMAPIFormContainer, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIFORMCONTAINER_METHODS(PURE)
};

/*-- IMAPIFormFactory ------------------------------------------------------*/

#define MAPI_IMAPIFORMFACTORY_METHODS(IPURE)                            \
    MAPIMETHOD(CreateClassFactory) (THIS_                               \
        /*in*/  REFCLSID clsidForm,                                     \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPCLASSFACTORY FAR * lppClassFactory) IPURE;            \
    MAPIMETHOD(LockServer) (THIS_                                       \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  ULONG fLockServer) IPURE;                               \

#undef INTERFACE
#define INTERFACE IMAPIFormFactory
DECLARE_MAPI_INTERFACE_(IMAPIFormFactory, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIFORMFACTORY_METHODS(PURE)
};

#endif							/* MAPIFORM_H */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mapiwz.h ===
/*
 *	M A P I W Z . H
 *
 *	Definitions for the Profile Wizard.	 Includes all prototypes
 *	and constants required by the provider-wizard code consumers.
 *
 *	Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MAPIWZ_H
#define _MAPIWZ_H

#if _MSC_VER > 1000
#pragma once
#endif

#define	WIZ_QUERYNUMPAGES	(WM_USER +10)
#define WIZ_NEXT			(WM_USER +11)
#define WIZ_PREV			(WM_USER +12)
/*
 *	NOTE: Provider-Wizards should not use ids ranging between
 *	(WM_USER + 1) and (WM_USER +20) as these have been reserved for
 *	future releases.
 */

/*	Flags for LaunchWizard API */

#define MAPI_PW_FIRST_PROFILE			0x00000001
#define MAPI_PW_LAUNCHED_BY_CONFIG		0x00000002
#define MAPI_PW_ADD_SERVICE_ONLY		0x00000004
#define MAPI_PW_PROVIDER_UI_ONLY		0x00000008
#define MAPI_PW_HIDE_SERVICES_LIST		0x00000010

/*
 *  Provider should set this property to TRUE if it does not
 *  want the Profile Wizard to display the PST setup page.
 */
#define PR_WIZARD_NO_PST_PAGE			PROP_TAG(PT_BOOLEAN, 0x6700)
#define PR_WIZARD_NO_PAB_PAGE			PROP_TAG(PT_BOOLEAN, 0x6701)

typedef HRESULT (STDAPICALLTYPE LAUNCHWIZARDENTRY)
(
	HWND			hParentWnd,
	ULONG			ulFlags,
	LPCTSTR FAR *	lppszServiceNameToAdd,
	ULONG			cbBufferMax,
	LPTSTR			lpszNewProfileName
);
typedef LAUNCHWIZARDENTRY FAR * LPLAUNCHWIZARDENTRY;

typedef BOOL (STDAPICALLTYPE SERVICEWIZARDDLGPROC)
(
	HWND			hDlg,
	UINT			wMsgID,
	WPARAM			wParam,
	LPARAM			lParam
);
typedef SERVICEWIZARDDLGPROC FAR * LPSERVICEWIZARDDLGPROC;

typedef ULONG (STDAPICALLTYPE WIZARDENTRY)
(
	HINSTANCE       hProviderDLLInstance,
	LPTSTR FAR *    lppcsResourceName,
	DLGPROC FAR *   lppDlgProc,
	LPMAPIPROP      lpMapiProp,
    LPVOID          lpMapiSupportObject
);
typedef WIZARDENTRY FAR * LPWIZARDENTRY;

#define LAUNCHWIZARDENTRYNAME			"LAUNCHWIZARD"

#endif	/* _MAPIWZ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mapiguid.h ===
/*
 *	M A P I G U I D . H
 *
 *	Master definitions of all GUID's for MAPI.
 *
 *	When included without INITGUID defined, this header file
 *	defines symbols that reference IIDs elsewhere.
 *
 *	When included with INITGUID defined and a "USES_IID_I..."
 *	statement for each IID used by the subsystem, it generates the
 *	bytes for those actual IIDs into the associated object file.
 *
 *	This range of 256 GUIDs reserved by OLE for MAPI use October 5, 1992.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

/*
 *	List of GUIDS allocated by MAPI
 *	
 *	0x00020300	IID_IMAPISession
 *	0x00020301	IID_IMAPITable
 *	0x00020302	IID_IMAPIAdviseSink
 *	0x00020303	IID_IMAPIProp
 *	0x00020304	IID_IProfSect
 *	0x00020305	IID_IMAPIStatus
 *	0x00020306	IID_IMsgStore
 *	0x00020307	IID_IMessage
 *	0x00020308	IID_IAttachment
 *	0x00020309	IID_IAddrBook
 *	0x0002030A	IID_IMailUser
 *	0x0002030B	IID_IMAPIContainer
 *	0x0002030C	IID_IMAPIFolder
 *	0x0002030D	IID_IABContainer
 *	0x0002030E	IID_IDistList
 *	0x0002030F	IID_IMAPISup
 *	0x00020310	IID_IMSProvider
 *	0x00020311	IID_IABProvider
 *	0x00020312	IID_IXPProvider
 *	0x00020313	IID_IMSLogon
 *	0x00020314	IID_IABLogon
 *	0x00020315	IID_IXPLogon
 *	0x00020316	IID_IMAPITableData
 *	0x00020317	IID_IMAPISpoolerInit
 *	0x00020318	IID_IMAPISpoolerSession
 *	0x00020319	IID_ITNEF
 *	0x0002031A	IID_IMAPIPropData
 *	0x0002031B	IID_IMAPIControl
 *	0x0002031C	IID_IProfAdmin
 *	0x0002031D	IID_IMsgServiceAdmin
 *	0x0002031E	IID_IMAPISpoolerService
 *	0x0002031F	IID_IMAPIProgress
 *	0x00020320	IID_ISpoolerHook
 *	0x00020321	IID_IMAPIViewContext
 *	0x00020322	IID_IMAPIFormMgr
 *	0x00020323	IID_IEnumMAPIFormProp
 *	0x00020324	IID_IMAPIFormInfo
 *	0x00020325	IID_IProviderAdmin
 *	0x00020327	IID_IMAPIForm
 *	0x00020328	PS_MAPI
 *	0x00020329	PS_PUBLIC_STRINGS
 *	0x0002032A	IID_IPersistMessage
 *	0x0002032B	IID_IMAPIViewAdviseSink
 *	0x0002032C	IID_IStreamDocfile
 *	0x0002032D	IID_IMAPIFormProp
 *	0x0002032E	IID_IMAPIFormContainer
 *	0x0002032F	IID_IMAPIFormAdviseSink
 *	0x00020330	IID_IStreamTnef
 *	0x00020350	IID_IMAPIFormFactory
 *	0x00020370	IID_IMAPIMessageSite
 *	0x00020380	PS_ROUTING_EMAIL_ADDRESSES
 *	0x00020381	PS_ROUTING_ADDRTYPE
 *	0x00020382	PS_ROUTING_DISPLAY_NAME
 *	0x00020383	PS_ROUTING_ENTRYID
 *	0x00020384	PS_ROUTING_SEARCH_KEY
 *	0x00020385	MUID_PROFILE_INSTANCE
 *	
 *	The remaining GUIDs from 0x00020300 to 0x000203FF are reserved by
 *	MAPI for future use.  The current maximum used by MAPI is 0x00020385
 *
 */

#ifndef MAPIGUID_H
#ifdef  INITGUID
#define MAPIGUID_H
#if _MSC_VER > 1000
#pragma once
#endif
#endif

/* Derive from IUnknown */
#if !defined(INITGUID) || defined(USES_IID_IMAPISession)
DEFINE_OLEGUID(IID_IMAPISession,	0x00020300, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPITable)
DEFINE_OLEGUID(IID_IMAPITable,		0x00020301, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIAdviseSink)
DEFINE_OLEGUID(IID_IMAPIAdviseSink,	0x00020302, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIControl)
DEFINE_OLEGUID(IID_IMAPIControl,	0x0002031B, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProfAdmin)
DEFINE_OLEGUID(IID_IProfAdmin,		0x0002031C, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMsgServiceAdmin)
DEFINE_OLEGUID(IID_IMsgServiceAdmin,0x0002031D, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProviderAdmin)
DEFINE_OLEGUID(IID_IProviderAdmin,	0x00020325, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIProgress)
DEFINE_OLEGUID(IID_IMAPIProgress,	0x0002031F, 0, 0);
#endif

/* MAPIProp or derive from MAPIProp */
#if !defined(INITGUID) || defined(USES_IID_IMAPIProp)
DEFINE_OLEGUID(IID_IMAPIProp,		0x00020303, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProfSect)
DEFINE_OLEGUID(IID_IProfSect,		0x00020304, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIStatus)
DEFINE_OLEGUID(IID_IMAPIStatus,			0x00020305, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMsgStore)
DEFINE_OLEGUID(IID_IMsgStore,		0x00020306, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMessage)
DEFINE_OLEGUID(IID_IMessage,		0x00020307, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IAttachment)
DEFINE_OLEGUID(IID_IAttachment,		0x00020308, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IAddrBook)
DEFINE_OLEGUID(IID_IAddrBook,		0x00020309, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMailUser)
DEFINE_OLEGUID(IID_IMailUser,		0x0002030A, 0, 0);
#endif

/* MAPIContainer or derive from MAPIContainer */
#if !defined(INITGUID) || defined(USES_IID_IMAPIContainer)
DEFINE_OLEGUID(IID_IMAPIContainer,	0x0002030B, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFolder)
DEFINE_OLEGUID(IID_IMAPIFolder,		0x0002030C, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABContainer)
DEFINE_OLEGUID(IID_IABContainer,	0x0002030D, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IDistList)
DEFINE_OLEGUID(IID_IDistList,		0x0002030E, 0, 0);
#endif

/* MAPI Support Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPISup)
DEFINE_OLEGUID(IID_IMAPISup,		0x0002030F, 0, 0);
#endif

/* Provider INIT objects */
#if !defined(INITGUID) || defined(USES_IID_IMSProvider)
DEFINE_OLEGUID(IID_IMSProvider,		0x00020310, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABProvider)
DEFINE_OLEGUID(IID_IABProvider,		0x00020311, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IXPProvider)
DEFINE_OLEGUID(IID_IXPProvider,		0x00020312, 0, 0);
#endif

/* Provider LOGON Objects */
#if !defined(INITGUID) || defined(USES_IID_IMSLogon)
DEFINE_OLEGUID(IID_IMSLogon,		0x00020313, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABLogon)
DEFINE_OLEGUID(IID_IABLogon,		0x00020314, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IXPLogon)
DEFINE_OLEGUID(IID_IXPLogon,		0x00020315, 0, 0);
#endif

/* IMAPITable-in-memory Table Data Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPITableData)
DEFINE_OLEGUID(IID_IMAPITableData,	0x00020316, 0, 0);
#endif

/* MAPI Spooler Init Object (internal) */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerInit)
DEFINE_OLEGUID(IID_IMAPISpoolerInit,	0x00020317, 0, 0);
#endif

/* MAPI Spooler Session Object (internal) */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerSession)
DEFINE_OLEGUID(IID_IMAPISpoolerSession,	0x00020318, 0, 0);
#endif

/* MAPI TNEF Object Interface */
#if !defined(INITGUID) || defined(USES_IID_ITNEF)
DEFINE_OLEGUID(IID_ITNEF,			0x00020319, 0, 0);
#endif

/* IMAPIProp-in-memory Property Data Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPIPropData)
DEFINE_OLEGUID(IID_IMAPIPropData,	0x0002031A, 0, 0);
#endif

/* MAPI Spooler Hook Object */
#if !defined(INITGUID) || defined(USES_IID_ISpoolerHook)
DEFINE_OLEGUID(IID_ISpoolerHook,	0x00020320, 0, 0);
#endif

/* MAPI Spooler Service Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerService)
DEFINE_OLEGUID(IID_IMAPISpoolerService,	0x0002031E, 0, 0);
#endif

/* MAPI forms, form manager, etc. */
#if !defined(INITGUID) || defined(USES_IID_IMAPIViewContext)
DEFINE_OLEGUID(IID_IMAPIViewContext,	0x00020321, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormMgr)
DEFINE_OLEGUID(IID_IMAPIFormMgr,	0x00020322, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IEnumMAPIFormProp)
DEFINE_OLEGUID(IID_IEnumMAPIFormProp,	0x00020323, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormInfo)
DEFINE_OLEGUID(IID_IMAPIFormInfo,	0x00020324, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIForm)
DEFINE_OLEGUID(IID_IMAPIForm,	0x00020327, 0, 0);
#endif


/* Well known guids for name<->id mappings */

/*  The name of MAPI's property set  */
#if !defined(INITGUID) || defined(USES_PS_MAPI)
DEFINE_OLEGUID(PS_MAPI,	0x00020328, 0, 0);
#endif

/*  The name of the set of public strings  */
#if !defined(INITGUID) || defined(USES_PS_PUBLIC_STRINGS)
DEFINE_OLEGUID(PS_PUBLIC_STRINGS,	0x00020329, 0, 0);
#endif




/* MAPI forms, form manager, (cont) */
#if !defined(INITGUID) || defined(USES_IID_IPersistMessage)
DEFINE_OLEGUID(IID_IPersistMessage,	0x0002032A, 0, 0);
#endif

/* IMAPIViewAdviseSink */
#if !defined(INITGUID) || defined(USES_IID_IMAPIViewAdviseSink)
DEFINE_OLEGUID(IID_IMAPIViewAdviseSink,	0x0002032B, 0, 0);
#endif

/* Message Store OpenProperty */
#if !defined(INITGUID) || defined(USES_IID_IStreamDocfile)
DEFINE_OLEGUID(IID_IStreamDocfile, 0x0002032C, 0, 0);
#endif

/* IMAPIFormProp */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormProp)
DEFINE_OLEGUID(IID_IMAPIFormProp,	0x0002032D, 0, 0);
#endif

/* IMAPIFormContainer */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormContainer)
DEFINE_OLEGUID(IID_IMAPIFormContainer, 0x0002032E, 0, 0);
#endif

/* IMAPIFormAdviseSink */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormAdviseSink)
DEFINE_OLEGUID(IID_IMAPIFormAdviseSink, 0x0002032F, 0, 0);
#endif

/* TNEF OpenProperty */
#if !defined(INITGUID) || defined(USES_IID_IStreamTnef)
DEFINE_OLEGUID(IID_IStreamTnef, 0x00020330, 0, 0);
#endif

/* IMAPIFormFactory */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormFactory)
DEFINE_OLEGUID(IID_IMAPIFormFactory, 0x00020350, 0, 0);
#endif

/* IMAPIMessageSite */
#if !defined(INITGUID) || defined(USES_IID_IMAPIMessageSite)
DEFINE_OLEGUID(IID_IMAPIMessageSite, 0x00020370, 0, 0);
#endif



/* Well known guids routing property sets.
   Usefull when writing applications that route documents
   (i.e. Workflow) across gateways.  Gateways that speak MAPI
   should convert the properties found in the follow property
   sets appropriately. */

/*  PS_ROUTING_EMAIL_ADDRESSES:  Addresses that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_EMAIL_ADDRESSES)
DEFINE_OLEGUID(PS_ROUTING_EMAIL_ADDRESSES,	0x00020380, 0, 0);
#endif

/*  PS_ROUTING_ADDRTYPE:  Address types that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_ADDRTYPE)
DEFINE_OLEGUID(PS_ROUTING_ADDRTYPE,	0x00020381, 0, 0);
#endif

/*  PS_ROUTING_DISPLAY_NAME:  Display Name that corresponds to the other props */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_DISPLAY_NAME)
DEFINE_OLEGUID(PS_ROUTING_DISPLAY_NAME,	0x00020382, 0, 0);
#endif

/*  PS_ROUTING_ENTRYID:  (optional) EntryIDs that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_ENTRYID)
DEFINE_OLEGUID(PS_ROUTING_ENTRYID,	0x00020383, 0, 0);
#endif

/*  PS_ROUTING_SEARCH_KEY:  (optional) search keys that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_SEARCH_KEY)
DEFINE_OLEGUID(PS_ROUTING_SEARCH_KEY,	0x00020384, 0, 0);
#endif

/*	MUID_PROFILE_INSTANCE
	Well known section in a profile which contains a property (PR_SEARCH_KEY) which is unique
	for any given profile.  Applications and providers can depend on this value as being
	different for each unique profile. */
#if !defined(INITGUID) || defined(USES_MUID_PROFILE_INSTANCE)
DEFINE_OLEGUID(MUID_PROFILE_INSTANCE, 0x00020385, 0, 0);
#endif

#endif	/* MAPIGUID_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mciavi.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *
**	Copyright (C) Microsoft Corporation 1991-1996. All rights reserved.
**
**	Title: mciavi.h - Multimedia Systems Media Control Interface
**	AVI driver external header file
**
**	Version:	1.00	
**
**	Date:		16-JUL-1992
**
**	Depends on MMSYSTEM.H and WINDOWS.h
*/

/************************************************************************/


/*
** These three flags apply to the 'play' command:
**	play <alias> window		Play in normal window
**	play <alias> fullscreen		Play in 320x240 full-screen mode
**	play <alias> fullscreen by 2	Play fullscreen, zoomed by 2
*/
#define MCI_MCIAVI_PLAY_WINDOW		0x01000000L
#define	MCI_MCIAVI_PLAY_FULLSCREEN	0x02000000L
#define MCI_MCIAVI_PLAY_FULLBY2		0x04000000L
/*
** Debugging constants for AVI diagnostics
*/
/*
** Returns number of frames not drawn during last play.  If this number
** is more than a small fraction of the number of frames that should have
** been displayed, things aren't looking good.
*/
#define MCI_AVI_STATUS_FRAMES_SKIPPED		0x8001L
/*
** Returns a number representing how well the last AVI play worked.
** A result of 1000 indicates that the AVI sequence took the amount
** of time to play that it should have; a result of 2000, for instance,
** would indicate that a 5-second AVI sequence took 10 seconds to play,
** implying that the audio and video were badly broken up.
*/
#define MCI_AVI_STATUS_LAST_PLAY_SPEED		0x8002L
/*
** Returns the number of times that the audio definitely broke up.
** (We count one for every time we're about to write some audio data
** to the driver, and we notice that it's already played all of the
** data we have.
*/
#define MCI_AVI_STATUS_AUDIO_BREAKS		0x8003L


#define MCI_AVI_SETVIDEO_DRAW_PROCEDURE		0x8000L

#define MCI_AVI_SETVIDEO_PALETTE_COLOR		0x8100L


/*
** This constant specifies that the "halftone" palette should be
** used, rather than the default palette.
*/
#define MCI_AVI_SETVIDEO_PALETTE_HALFTONE       0x0000FFFFL

/*
**	Custom error return values
*/
#define MCIERR_AVI_OLDAVIFORMAT		(MCIERR_CUSTOM_DRIVER_BASE + 100)
#define MCIERR_AVI_NOTINTERLEAVED	(MCIERR_CUSTOM_DRIVER_BASE + 101)
#define MCIERR_AVI_NODISPDIB		(MCIERR_CUSTOM_DRIVER_BASE + 102)
#define MCIERR_AVI_CANTPLAYFULLSCREEN	(MCIERR_CUSTOM_DRIVER_BASE + 103)
#define MCIERR_AVI_TOOBIGFORVGA		(MCIERR_CUSTOM_DRIVER_BASE + 104)
#define MCIERR_AVI_NOCOMPRESSOR         (MCIERR_CUSTOM_DRIVER_BASE + 105)
#define MCIERR_AVI_DISPLAYERROR         (MCIERR_CUSTOM_DRIVER_BASE + 106)
#define MCIERR_AVI_AUDIOERROR		(MCIERR_CUSTOM_DRIVER_BASE + 107)
#define MCIERR_AVI_BADPALETTE		(MCIERR_CUSTOM_DRIVER_BASE + 108)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\loadperf.h ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    loadperf.h

Abstract:

    Header file for the Performance Monitor counter string installation
    and removal functions.

Revision History

    16-Nov-95   Created (a-robw)

--*/

#ifndef _LOADPERF_H_
#define _LOADPERF_H_

#if _MSC_VER > 1000
#pragma once
#endif

// function prototypes for perf counter name string load & unload functions
// provided in LOADPERF.DLL

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __LOADPERF__
#define LOADPERF_FUNCTION   DWORD __stdcall
#else
#define LOADPERF_FUNCTION   __declspec(dllimport) DWORD __stdcall
#endif

// flags for dwFlags Argument

#define LOADPERF_FLAGS_DELETE_MOF_ON_EXIT   ((ULONG_PTR)1)
#define LOADPERF_FLAGS_LOAD_REGISTRY_ONLY   ((ULONG_PTR)2)
#define LOADPERF_FLAGS_CREATE_MOF_ONLY      ((ULONG_PTR)4)
#define LOADPERF_FLAGS_DISPLAY_USER_MSGS    ((ULONG_PTR)8)

// note: LOADPERF_FLAGS_LOAD_REGISTRY_ONLY is not a valid flag for
// LoadMofFromInstalledServiceA/W as the service must already be installed

LOADPERF_FUNCTION
LoadMofFromInstalledServiceA (
    IN  LPCSTR  szServiceName,  // service to create mof for
    IN  LPCSTR  szMofFilename,  // name of file to create
    IN  ULONG_PTR   dwFlags
);

LOADPERF_FUNCTION
LoadMofFromInstalledServiceW (
    IN  LPCWSTR szServiceName,  // service to create mof for
    IN  LPCWSTR szMofFilename,  // name of file to create
    IN  ULONG_PTR   dwFlags
);

LOADPERF_FUNCTION
InstallPerfDllW (
    IN  LPCWSTR szComputerName,
    IN  LPCWSTR lpIniFile,
    IN  ULONG_PTR   dwFlags         
);

LOADPERF_FUNCTION
InstallPerfDllA (
    IN  LPCSTR  szComputerName,
    IN  LPCSTR  lpIniFile,
    IN  ULONG_PTR   dwFlags         
);

LOADPERF_FUNCTION
UnInstallPerfDllA (
    IN  LPCSTR  szComputerName,
    IN  LPCSTR  lpServiceName,
    IN  ULONG_PTR   dwFlags         
);

LOADPERF_FUNCTION
UnInstallPerfDllA (
    IN  LPCSTR  szComputerName,
    IN  LPCSTR  lpServiceName,
    IN  ULONG_PTR   dwFlags         
);

LOADPERF_FUNCTION
LoadPerfCounterTextStringsA (
    IN  LPSTR   lpCommandLine,
    IN  BOOL    bQuietModeArg
);

LOADPERF_FUNCTION
LoadPerfCounterTextStringsW (
    IN  LPWSTR  lpCommandLine,
    IN  BOOL    bQuietModeArg
);

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsW (
    IN  LPWSTR  lpCommandLine,
    IN  BOOL    bQuietModeArg
);

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsA (
    IN  LPSTR   lpCommandLine,
    IN  BOOL    bQuietModeArg
);

LOADPERF_FUNCTION
UpdatePerfNameFilesA (
    IN  LPCSTR      szNewCtrFilePath,
    IN  LPCSTR      szNewHlpFilePath,
    IN  LPSTR       szLanguageID,
    IN  ULONG_PTR   dwFlags
);

LOADPERF_FUNCTION
UpdatePerfNameFilesW (
    IN  LPCWSTR     szNewCtrFilePath,
    IN  LPCWSTR     szNewHlpFilePath,
    IN  LPWSTR      szLanguageID,
    IN  ULONG_PTR   dwFlags
);

LOADPERF_FUNCTION
SetServiceAsTrustedA (
    LPCSTR szReserved,
    LPCSTR szServiceName
);

LOADPERF_FUNCTION
SetServiceAsTrustedW (
    LPCWSTR szReserved,
    LPCWSTR szServiceName
);


#ifdef UNICODE
#define InstallPerfDll                  InstallPerfDllW
#define UnInstallPerfDll                UnInstallPerfDllW
#define LoadPerfCounterTextStrings      LoadPerfCounterTextStringsW
#define UnloadPerfCounterTextStrings    UnloadPerfCounterTextStringsW
#define LoadMofFromInstalledService     LoadMofFromInstalledServiceW
#define UpdatePerfNameFiles             UpdatePerfNameFilesW 
#define SetServiceAsTrusted             SetServiceAsTrustedW
#else
#define InstallPerfDll                  InstallPerfDllA
#define UnInstallPerfDll                UnInstallPerfDllA
#define LoadPerfCounterTextStrings      LoadPerfCounterTextStringsA
#define UnloadPerfCounterTextStrings    UnloadPerfCounterTextStringsA
#define LoadMofFromInstalledService     LoadMofFromInstalledServiceA
#define UpdatePerfNameFiles             UpdatePerfNameFilesA
#define SetServiceAsTrusted             SetServiceAsTrustedA
#endif


#ifdef __cplusplus
}
#endif


#endif // _LOADPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mapitags.h ===
/*
 *	M A P I T A G S . H
 *
 *	Property tag definitions for standard properties of MAPI
 *	objects.
 *
 *	The following ranges should be used for all property IDs. Note that
 *	property IDs for objects other than messages and recipients should
 *	all fall in the range 0x3000 to 0x3FFF:
 *
 *	From	To		Kind of property
 *	--------------------------------
 *	0001	0BFF	MAPI_defined envelope property
 *	0C00	0DFF	MAPI_defined per-recipient property
 *	0E00	0FFF	MAPI_defined non-transmittable property
 *	1000	2FFF	MAPI_defined message content property
 *
 *	3000	3FFF	MAPI_defined property (usually not message or recipient)
 *
 *	4000	57FF	Transport-defined envelope property
 *	5800	5FFF	Transport-defined per-recipient property
 *	6000	65FF	User-defined non-transmittable property
 *	6600	67FF	Provider-defined internal non-transmittable property
 *	6800	7BFF	Message class-defined content property
 *	7C00	7FFF	Message class-defined non-transmittable
 *					property
 *
 *	8000	FFFE	User-defined Name-to-id mapped property
 *
 *	The 3000-3FFF range is further subdivided as follows:
 *
 *	From	To		Kind of property
 *	--------------------------------
 *	3000	33FF	Common property such as display name, entry ID
 *	3400	35FF	Message store object
 *	3600	36FF	Folder or AB container
 *	3700	38FF	Attachment
 *	3900	39FF	Address book object
 *	3A00	3BFF	Mail user
 *	3C00	3CFF	Distribution list
 *	3D00	3DFF	Profile section
 *	3E00	3FFF	Status object
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef	MAPITAGS_H
#define	MAPITAGS_H

#if _MSC_VER > 1000
#pragma once
#endif

/* Determine if a property is transmittable. */

#define FIsTransmittable(ulPropTag) \
	((PROP_ID (ulPropTag) <  (ULONG)0x0E00) || \
	(PROP_ID (ulPropTag)  >= (ULONG)0x8000) || \
	((PROP_ID (ulPropTag) >= (ULONG)0x1000) && (PROP_ID (ulPropTag) < (ULONG)0x6000)) || \
	((PROP_ID (ulPropTag) >= (ULONG)0x6800) && (PROP_ID (ulPropTag) < (ULONG)0x7C00)))

/*
 *	Message envelope properties
 */

#define PR_ACKNOWLEDGEMENT_MODE						PROP_TAG( PT_LONG,		0x0001)
#define PR_ALTERNATE_RECIPIENT_ALLOWED				PROP_TAG( PT_BOOLEAN,	0x0002)
#define PR_AUTHORIZING_USERS						PROP_TAG( PT_BINARY,	0x0003)
#define PR_AUTO_FORWARD_COMMENT						PROP_TAG( PT_TSTRING,	0x0004)
#define PR_AUTO_FORWARD_COMMENT_W					PROP_TAG( PT_UNICODE,	0x0004)
#define PR_AUTO_FORWARD_COMMENT_A					PROP_TAG( PT_STRING8,	0x0004)
#define PR_AUTO_FORWARDED							PROP_TAG( PT_BOOLEAN,	0x0005)
#define PR_CONTENT_CONFIDENTIALITY_ALGORITHM_ID		PROP_TAG( PT_BINARY,	0x0006)
#define PR_CONTENT_CORRELATOR						PROP_TAG( PT_BINARY,	0x0007)
#define PR_CONTENT_IDENTIFIER						PROP_TAG( PT_TSTRING,	0x0008)
#define PR_CONTENT_IDENTIFIER_W						PROP_TAG( PT_UNICODE,	0x0008)
#define PR_CONTENT_IDENTIFIER_A						PROP_TAG( PT_STRING8,	0x0008)
#define PR_CONTENT_LENGTH							PROP_TAG( PT_LONG,		0x0009)
#define PR_CONTENT_RETURN_REQUESTED					PROP_TAG( PT_BOOLEAN,	0x000A)



#define PR_CONVERSATION_KEY							PROP_TAG( PT_BINARY,	0x000B)

#define PR_CONVERSION_EITS							PROP_TAG( PT_BINARY,	0x000C)
#define PR_CONVERSION_WITH_LOSS_PROHIBITED			PROP_TAG( PT_BOOLEAN,	0x000D)
#define PR_CONVERTED_EITS							PROP_TAG( PT_BINARY,	0x000E)
#define PR_DEFERRED_DELIVERY_TIME					PROP_TAG( PT_SYSTIME,	0x000F)
#define PR_DELIVER_TIME								PROP_TAG( PT_SYSTIME,	0x0010)
#define PR_DISCARD_REASON							PROP_TAG( PT_LONG,		0x0011)
#define PR_DISCLOSURE_OF_RECIPIENTS					PROP_TAG( PT_BOOLEAN,	0x0012)
#define PR_DL_EXPANSION_HISTORY						PROP_TAG( PT_BINARY,	0x0013)
#define PR_DL_EXPANSION_PROHIBITED					PROP_TAG( PT_BOOLEAN,	0x0014)
#define PR_EXPIRY_TIME								PROP_TAG( PT_SYSTIME,	0x0015)
#define PR_IMPLICIT_CONVERSION_PROHIBITED			PROP_TAG( PT_BOOLEAN,	0x0016)
#define PR_IMPORTANCE								PROP_TAG( PT_LONG,		0x0017)
#define PR_IPM_ID									PROP_TAG( PT_BINARY,	0x0018)
#define PR_LATEST_DELIVERY_TIME						PROP_TAG( PT_SYSTIME,	0x0019)
#define PR_MESSAGE_CLASS							PROP_TAG( PT_TSTRING,	0x001A)
#define PR_MESSAGE_CLASS_W							PROP_TAG( PT_UNICODE,	0x001A)
#define PR_MESSAGE_CLASS_A							PROP_TAG( PT_STRING8,	0x001A)
#define PR_MESSAGE_DELIVERY_ID						PROP_TAG( PT_BINARY,	0x001B)





#define PR_MESSAGE_SECURITY_LABEL					PROP_TAG( PT_BINARY,	0x001E)
#define PR_OBSOLETED_IPMS							PROP_TAG( PT_BINARY,	0x001F)
#define PR_ORIGINALLY_INTENDED_RECIPIENT_NAME		PROP_TAG( PT_BINARY,	0x0020)
#define PR_ORIGINAL_EITS							PROP_TAG( PT_BINARY,	0x0021)
#define PR_ORIGINATOR_CERTIFICATE					PROP_TAG( PT_BINARY,	0x0022)
#define PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED		PROP_TAG( PT_BOOLEAN,	0x0023)
#define PR_ORIGINATOR_RETURN_ADDRESS				PROP_TAG( PT_BINARY,	0x0024)



#define PR_PARENT_KEY								PROP_TAG( PT_BINARY,	0x0025)
#define PR_PRIORITY									PROP_TAG( PT_LONG,		0x0026)



#define PR_ORIGIN_CHECK								PROP_TAG( PT_BINARY,	0x0027)
#define PR_PROOF_OF_SUBMISSION_REQUESTED			PROP_TAG( PT_BOOLEAN,	0x0028)
#define PR_READ_RECEIPT_REQUESTED					PROP_TAG( PT_BOOLEAN,	0x0029)
#define PR_RECEIPT_TIME								PROP_TAG( PT_SYSTIME,	0x002A)
#define PR_RECIPIENT_REASSIGNMENT_PROHIBITED		PROP_TAG( PT_BOOLEAN,	0x002B)
#define PR_REDIRECTION_HISTORY						PROP_TAG( PT_BINARY,	0x002C)
#define PR_RELATED_IPMS								PROP_TAG( PT_BINARY,	0x002D)
#define PR_ORIGINAL_SENSITIVITY						PROP_TAG( PT_LONG,		0x002E)
#define	PR_LANGUAGES								PROP_TAG( PT_TSTRING,	0x002F)
#define	PR_LANGUAGES_W								PROP_TAG( PT_UNICODE,	0x002F)
#define	PR_LANGUAGES_A								PROP_TAG( PT_STRING8,	0x002F)
#define PR_REPLY_TIME								PROP_TAG( PT_SYSTIME,	0x0030)
#define PR_REPORT_TAG								PROP_TAG( PT_BINARY,	0x0031)
#define PR_REPORT_TIME								PROP_TAG( PT_SYSTIME,	0x0032)
#define PR_RETURNED_IPM								PROP_TAG( PT_BOOLEAN,	0x0033)
#define PR_SECURITY									PROP_TAG( PT_LONG,		0x0034)
#define	PR_INCOMPLETE_COPY							PROP_TAG( PT_BOOLEAN,	0x0035)
#define PR_SENSITIVITY								PROP_TAG( PT_LONG,		0x0036)
#define PR_SUBJECT									PROP_TAG( PT_TSTRING,	0x0037)
#define PR_SUBJECT_W								PROP_TAG( PT_UNICODE,	0x0037)
#define PR_SUBJECT_A								PROP_TAG( PT_STRING8,	0x0037)
#define PR_SUBJECT_IPM								PROP_TAG( PT_BINARY,	0x0038)
#define PR_CLIENT_SUBMIT_TIME						PROP_TAG( PT_SYSTIME,	0x0039)
#define PR_REPORT_NAME								PROP_TAG( PT_TSTRING,	0x003A)
#define PR_REPORT_NAME_W							PROP_TAG( PT_UNICODE,	0x003A)
#define PR_REPORT_NAME_A							PROP_TAG( PT_STRING8,	0x003A)
#define	PR_SENT_REPRESENTING_SEARCH_KEY				PROP_TAG( PT_BINARY,	0x003B)
#define PR_X400_CONTENT_TYPE						PROP_TAG( PT_BINARY,	0x003C)
#define PR_SUBJECT_PREFIX							PROP_TAG( PT_TSTRING,	0x003D)
#define PR_SUBJECT_PREFIX_W	 						PROP_TAG( PT_UNICODE,	0x003D)
#define PR_SUBJECT_PREFIX_A	 						PROP_TAG( PT_STRING8,	0x003D)
#define PR_NON_RECEIPT_REASON						PROP_TAG( PT_LONG,		0x003E)
#define PR_RECEIVED_BY_ENTRYID						PROP_TAG( PT_BINARY,	0x003F)
#define PR_RECEIVED_BY_NAME							PROP_TAG( PT_TSTRING,	0x0040)
#define PR_RECEIVED_BY_NAME_W						PROP_TAG( PT_UNICODE,	0x0040)
#define PR_RECEIVED_BY_NAME_A						PROP_TAG( PT_STRING8,	0x0040)
#define	PR_SENT_REPRESENTING_ENTRYID				PROP_TAG( PT_BINARY,	0x0041)
#define PR_SENT_REPRESENTING_NAME					PROP_TAG( PT_TSTRING,	0x0042)
#define PR_SENT_REPRESENTING_NAME_W					PROP_TAG( PT_UNICODE,	0x0042)
#define PR_SENT_REPRESENTING_NAME_A					PROP_TAG( PT_STRING8,	0x0042)
#define PR_RCVD_REPRESENTING_ENTRYID				PROP_TAG( PT_BINARY,	0x0043)
#define PR_RCVD_REPRESENTING_NAME					PROP_TAG( PT_TSTRING,	0x0044)
#define PR_RCVD_REPRESENTING_NAME_W					PROP_TAG( PT_UNICODE,	0x0044)
#define PR_RCVD_REPRESENTING_NAME_A					PROP_TAG( PT_STRING8,	0x0044)
#define PR_REPORT_ENTRYID							PROP_TAG( PT_BINARY,	0x0045)
#define PR_READ_RECEIPT_ENTRYID						PROP_TAG( PT_BINARY,	0x0046)
#define PR_MESSAGE_SUBMISSION_ID					PROP_TAG( PT_BINARY,	0x0047)
#define PR_PROVIDER_SUBMIT_TIME						PROP_TAG( PT_SYSTIME,	0x0048)
#define	PR_ORIGINAL_SUBJECT							PROP_TAG( PT_TSTRING,	0x0049)
#define	PR_ORIGINAL_SUBJECT_W						PROP_TAG( PT_UNICODE,	0x0049)
#define	PR_ORIGINAL_SUBJECT_A						PROP_TAG( PT_STRING8,	0x0049)
#define PR_DISC_VAL									PROP_TAG( PT_BOOLEAN,	0x004A)
#define PR_ORIG_MESSAGE_CLASS						PROP_TAG( PT_TSTRING,	0x004B)
#define PR_ORIG_MESSAGE_CLASS_W						PROP_TAG( PT_UNICODE,	0x004B)
#define PR_ORIG_MESSAGE_CLASS_A						PROP_TAG( PT_STRING8,	0x004B)
#define PR_ORIGINAL_AUTHOR_ENTRYID					PROP_TAG( PT_BINARY,	0x004C)
#define PR_ORIGINAL_AUTHOR_NAME						PROP_TAG( PT_TSTRING,	0x004D)
#define PR_ORIGINAL_AUTHOR_NAME_W					PROP_TAG( PT_UNICODE,	0x004D)
#define PR_ORIGINAL_AUTHOR_NAME_A					PROP_TAG( PT_STRING8,	0x004D)
#define PR_ORIGINAL_SUBMIT_TIME						PROP_TAG( PT_SYSTIME,	0x004E)
#define PR_REPLY_RECIPIENT_ENTRIES					PROP_TAG( PT_BINARY,	0x004F)
#define PR_REPLY_RECIPIENT_NAMES					PROP_TAG( PT_TSTRING,	0x0050)
#define PR_REPLY_RECIPIENT_NAMES_W					PROP_TAG( PT_UNICODE,	0x0050)
#define PR_REPLY_RECIPIENT_NAMES_A					PROP_TAG( PT_STRING8,	0x0050)

#define PR_RECEIVED_BY_SEARCH_KEY					PROP_TAG( PT_BINARY,	0x0051)
#define PR_RCVD_REPRESENTING_SEARCH_KEY				PROP_TAG( PT_BINARY,	0x0052)
#define PR_READ_RECEIPT_SEARCH_KEY					PROP_TAG( PT_BINARY,	0x0053)
#define PR_REPORT_SEARCH_KEY						PROP_TAG( PT_BINARY,	0x0054)
#define	PR_ORIGINAL_DELIVERY_TIME					PROP_TAG( PT_SYSTIME,	0x0055)
#define PR_ORIGINAL_AUTHOR_SEARCH_KEY				PROP_TAG( PT_BINARY,	0x0056)

#define	PR_MESSAGE_TO_ME							PROP_TAG( PT_BOOLEAN,	0x0057)
#define	PR_MESSAGE_CC_ME							PROP_TAG( PT_BOOLEAN,	0x0058)
#define	PR_MESSAGE_RECIP_ME							PROP_TAG( PT_BOOLEAN,	0x0059)

#define PR_ORIGINAL_SENDER_NAME						PROP_TAG( PT_TSTRING,	0x005A)
#define PR_ORIGINAL_SENDER_NAME_W					PROP_TAG( PT_UNICODE,	0x005A)
#define PR_ORIGINAL_SENDER_NAME_A					PROP_TAG( PT_STRING8,	0x005A)
#define	PR_ORIGINAL_SENDER_ENTRYID					PROP_TAG( PT_BINARY,	0x005B)
#define	PR_ORIGINAL_SENDER_SEARCH_KEY				PROP_TAG( PT_BINARY,	0x005C)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME			PROP_TAG( PT_TSTRING,	0x005D)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME_W		PROP_TAG( PT_UNICODE,	0x005D)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME_A		PROP_TAG( PT_STRING8,	0x005D)
#define	PR_ORIGINAL_SENT_REPRESENTING_ENTRYID		PROP_TAG( PT_BINARY,	0x005E)
#define	PR_ORIGINAL_SENT_REPRESENTING_SEARCH_KEY	PROP_TAG( PT_BINARY,	0x005F)

#define PR_START_DATE								PROP_TAG( PT_SYSTIME,	0x0060)
#define PR_END_DATE									PROP_TAG( PT_SYSTIME,	0x0061)
#define PR_OWNER_APPT_ID							PROP_TAG( PT_LONG,		0x0062)
#define PR_RESPONSE_REQUESTED						PROP_TAG( PT_BOOLEAN,	0x0063)

#define PR_SENT_REPRESENTING_ADDRTYPE				PROP_TAG( PT_TSTRING,	0x0064)
#define PR_SENT_REPRESENTING_ADDRTYPE_W				PROP_TAG( PT_UNICODE,	0x0064)
#define PR_SENT_REPRESENTING_ADDRTYPE_A				PROP_TAG( PT_STRING8,	0x0064)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS			PROP_TAG( PT_TSTRING,	0x0065)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS_W		PROP_TAG( PT_UNICODE,	0x0065)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS_A		PROP_TAG( PT_STRING8,	0x0065)

#define PR_ORIGINAL_SENDER_ADDRTYPE					PROP_TAG( PT_TSTRING,	0x0066)
#define PR_ORIGINAL_SENDER_ADDRTYPE_W				PROP_TAG( PT_UNICODE,	0x0066)
#define PR_ORIGINAL_SENDER_ADDRTYPE_A				PROP_TAG( PT_STRING8,	0x0066)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS			PROP_TAG( PT_TSTRING,	0x0067)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS_W			PROP_TAG( PT_UNICODE,	0x0067)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS_A			PROP_TAG( PT_STRING8,	0x0067)

#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE		PROP_TAG( PT_TSTRING,	0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_W	PROP_TAG( PT_UNICODE,	0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_A	PROP_TAG( PT_STRING8,	0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS	PROP_TAG( PT_TSTRING,	0x0069)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_W	PROP_TAG( PT_UNICODE,	0x0069)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_A	PROP_TAG( PT_STRING8,	0x0069)

#define	PR_CONVERSATION_TOPIC						PROP_TAG( PT_TSTRING,	0x0070)
#define	PR_CONVERSATION_TOPIC_W						PROP_TAG( PT_UNICODE,	0x0070)
#define	PR_CONVERSATION_TOPIC_A						PROP_TAG( PT_STRING8,	0x0070)
#define	PR_CONVERSATION_INDEX						PROP_TAG( PT_BINARY,	0x0071)

#define PR_ORIGINAL_DISPLAY_BCC						PROP_TAG( PT_TSTRING,	0x0072)
#define PR_ORIGINAL_DISPLAY_BCC_W					PROP_TAG( PT_UNICODE,	0x0072)
#define PR_ORIGINAL_DISPLAY_BCC_A					PROP_TAG( PT_STRING8,	0x0072)
#define PR_ORIGINAL_DISPLAY_CC						PROP_TAG( PT_TSTRING,	0x0073)
#define PR_ORIGINAL_DISPLAY_CC_W					PROP_TAG( PT_UNICODE,	0x0073)
#define PR_ORIGINAL_DISPLAY_CC_A					PROP_TAG( PT_STRING8,	0x0073)
#define PR_ORIGINAL_DISPLAY_TO						PROP_TAG( PT_TSTRING,	0x0074)
#define PR_ORIGINAL_DISPLAY_TO_W					PROP_TAG( PT_UNICODE,	0x0074)
#define PR_ORIGINAL_DISPLAY_TO_A					PROP_TAG( PT_STRING8,	0x0074)

#define PR_RECEIVED_BY_ADDRTYPE						PROP_TAG( PT_TSTRING,	0x0075)
#define PR_RECEIVED_BY_ADDRTYPE_W					PROP_TAG( PT_UNICODE,	0x0075)
#define PR_RECEIVED_BY_ADDRTYPE_A					PROP_TAG( PT_STRING8,	0x0075)
#define	PR_RECEIVED_BY_EMAIL_ADDRESS				PROP_TAG( PT_TSTRING,	0x0076)
#define	PR_RECEIVED_BY_EMAIL_ADDRESS_W				PROP_TAG( PT_UNICODE,	0x0076)
#define	PR_RECEIVED_BY_EMAIL_ADDRESS_A				PROP_TAG( PT_STRING8,	0x0076)

#define PR_RCVD_REPRESENTING_ADDRTYPE				PROP_TAG( PT_TSTRING,	0x0077)
#define PR_RCVD_REPRESENTING_ADDRTYPE_W				PROP_TAG( PT_UNICODE,	0x0077)
#define PR_RCVD_REPRESENTING_ADDRTYPE_A				PROP_TAG( PT_STRING8,	0x0077)
#define PR_RCVD_REPRESENTING_EMAIL_ADDRESS			PROP_TAG( PT_TSTRING,	0x0078)
#define PR_RCVD_REPRESENTING_EMAIL_ADDRESS_W		PROP_TAG( PT_UNICODE,	0x0078)
#define PR_RCVD_REPRESENTING_EMAIL_ADDRESS_A		PROP_TAG( PT_STRING8,	0x0078)

#define PR_ORIGINAL_AUTHOR_ADDRTYPE					PROP_TAG( PT_TSTRING,	0x0079)
#define PR_ORIGINAL_AUTHOR_ADDRTYPE_W				PROP_TAG( PT_UNICODE,	0x0079)
#define PR_ORIGINAL_AUTHOR_ADDRTYPE_A				PROP_TAG( PT_STRING8,	0x0079)
#define PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS			PROP_TAG( PT_TSTRING,	0x007A)
#define PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS_W			PROP_TAG( PT_UNICODE,	0x007A)
#define PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS_A			PROP_TAG( PT_STRING8,	0x007A)

#define PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE		PROP_TAG( PT_TSTRING,	0x007B)
#define PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE_W		PROP_TAG( PT_UNICODE,	0x007B)
#define PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE_A		PROP_TAG( PT_STRING8,	0x007B)
#define PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS	PROP_TAG( PT_TSTRING,	0x007C)
#define PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS_W	PROP_TAG( PT_UNICODE,	0x007C)
#define PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS_A	PROP_TAG( PT_STRING8,	0x007C)

#define PR_TRANSPORT_MESSAGE_HEADERS				PROP_TAG(PT_TSTRING,	0x007D)
#define PR_TRANSPORT_MESSAGE_HEADERS_W				PROP_TAG(PT_UNICODE,	0x007D)
#define PR_TRANSPORT_MESSAGE_HEADERS_A				PROP_TAG(PT_STRING8,	0x007D)

#define PR_DELEGATION								PROP_TAG(PT_BINARY,		0x007E)

#define PR_TNEF_CORRELATION_KEY						PROP_TAG(PT_BINARY,		0x007F)



/*
 *	Message content properties
 */

#define PR_BODY										PROP_TAG( PT_TSTRING,	0x1000)
#define PR_BODY_W									PROP_TAG( PT_UNICODE,	0x1000)
#define PR_BODY_A									PROP_TAG( PT_STRING8,	0x1000)
#define PR_REPORT_TEXT								PROP_TAG( PT_TSTRING,	0x1001)
#define PR_REPORT_TEXT_W							PROP_TAG( PT_UNICODE,	0x1001)
#define PR_REPORT_TEXT_A							PROP_TAG( PT_STRING8,	0x1001)
#define PR_ORIGINATOR_AND_DL_EXPANSION_HISTORY		PROP_TAG( PT_BINARY,	0x1002)
#define PR_REPORTING_DL_NAME						PROP_TAG( PT_BINARY,	0x1003)
#define PR_REPORTING_MTA_CERTIFICATE				PROP_TAG( PT_BINARY,	0x1004)

/*  Removed PR_REPORT_ORIGIN_AUTHENTICATION_CHECK with DCR 3865, use PR_ORIGIN_CHECK */

#define PR_RTF_SYNC_BODY_CRC						PROP_TAG( PT_LONG,		0x1006)
#define PR_RTF_SYNC_BODY_COUNT						PROP_TAG( PT_LONG,		0x1007)
#define PR_RTF_SYNC_BODY_TAG						PROP_TAG( PT_TSTRING,	0x1008)
#define PR_RTF_SYNC_BODY_TAG_W						PROP_TAG( PT_UNICODE,	0x1008)
#define PR_RTF_SYNC_BODY_TAG_A						PROP_TAG( PT_STRING8,	0x1008)
#define PR_RTF_COMPRESSED							PROP_TAG( PT_BINARY,	0x1009)
#define PR_RTF_SYNC_PREFIX_COUNT					PROP_TAG( PT_LONG,		0x1010)
#define PR_RTF_SYNC_TRAILING_COUNT					PROP_TAG( PT_LONG,		0x1011)
#define PR_ORIGINALLY_INTENDED_RECIP_ENTRYID		PROP_TAG( PT_BINARY,	0x1012)

/*
 *  Reserved 0x1100-0x1200
 */


/*
 *	Message recipient properties
 */

#define PR_CONTENT_INTEGRITY_CHECK					PROP_TAG( PT_BINARY,	0x0C00)
#define PR_EXPLICIT_CONVERSION						PROP_TAG( PT_LONG,		0x0C01)
#define PR_IPM_RETURN_REQUESTED						PROP_TAG( PT_BOOLEAN,	0x0C02)
#define PR_MESSAGE_TOKEN							PROP_TAG( PT_BINARY,	0x0C03)
#define PR_NDR_REASON_CODE							PROP_TAG( PT_LONG,		0x0C04)
#define PR_NDR_DIAG_CODE							PROP_TAG( PT_LONG,		0x0C05)
#define PR_NON_RECEIPT_NOTIFICATION_REQUESTED		PROP_TAG( PT_BOOLEAN,	0x0C06)
#define PR_DELIVERY_POINT							PROP_TAG( PT_LONG,		0x0C07)

#define PR_ORIGINATOR_NON_DELIVERY_REPORT_REQUESTED	PROP_TAG( PT_BOOLEAN,	0x0C08)
#define PR_ORIGINATOR_REQUESTED_ALTERNATE_RECIPIENT	PROP_TAG( PT_BINARY,	0x0C09)
#define PR_PHYSICAL_DELIVERY_BUREAU_FAX_DELIVERY	PROP_TAG( PT_BOOLEAN,	0x0C0A)
#define PR_PHYSICAL_DELIVERY_MODE					PROP_TAG( PT_LONG,		0x0C0B)
#define PR_PHYSICAL_DELIVERY_REPORT_REQUEST			PROP_TAG( PT_LONG,		0x0C0C)
#define PR_PHYSICAL_FORWARDING_ADDRESS				PROP_TAG( PT_BINARY,	0x0C0D)
#define PR_PHYSICAL_FORWARDING_ADDRESS_REQUESTED	PROP_TAG( PT_BOOLEAN,	0x0C0E)
#define PR_PHYSICAL_FORWARDING_PROHIBITED			PROP_TAG( PT_BOOLEAN,	0x0C0F)
#define PR_PHYSICAL_RENDITION_ATTRIBUTES			PROP_TAG( PT_BINARY,	0x0C10)
#define PR_PROOF_OF_DELIVERY						PROP_TAG( PT_BINARY,	0x0C11)
#define PR_PROOF_OF_DELIVERY_REQUESTED				PROP_TAG( PT_BOOLEAN,	0x0C12)
#define PR_RECIPIENT_CERTIFICATE					PROP_TAG( PT_BINARY,	0x0C13)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE				PROP_TAG( PT_TSTRING,	0x0C14)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE_W			PROP_TAG( PT_UNICODE,	0x0C14)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE_A			PROP_TAG( PT_STRING8,	0x0C14)
#define PR_RECIPIENT_TYPE							PROP_TAG( PT_LONG,		0x0C15)
#define PR_REGISTERED_MAIL_TYPE						PROP_TAG( PT_LONG,		0x0C16)
#define PR_REPLY_REQUESTED							PROP_TAG( PT_BOOLEAN,	0x0C17)
#define PR_REQUESTED_DELIVERY_METHOD				PROP_TAG( PT_LONG,		0x0C18)
#define PR_SENDER_ENTRYID							PROP_TAG( PT_BINARY,	0x0C19)
#define PR_SENDER_NAME								PROP_TAG( PT_TSTRING,	0x0C1A)
#define PR_SENDER_NAME_W							PROP_TAG( PT_UNICODE,	0x0C1A)
#define PR_SENDER_NAME_A							PROP_TAG( PT_STRING8,	0x0C1A)
#define PR_SUPPLEMENTARY_INFO						PROP_TAG( PT_TSTRING,	0x0C1B)
#define PR_SUPPLEMENTARY_INFO_W						PROP_TAG( PT_UNICODE,	0x0C1B)
#define PR_SUPPLEMENTARY_INFO_A						PROP_TAG( PT_STRING8,	0x0C1B)
#define PR_TYPE_OF_MTS_USER							PROP_TAG( PT_LONG,		0x0C1C)
#define PR_SENDER_SEARCH_KEY						PROP_TAG( PT_BINARY,	0x0C1D)
#define PR_SENDER_ADDRTYPE							PROP_TAG( PT_TSTRING,	0x0C1E)
#define PR_SENDER_ADDRTYPE_W						PROP_TAG( PT_UNICODE,	0x0C1E)
#define PR_SENDER_ADDRTYPE_A						PROP_TAG( PT_STRING8,	0x0C1E)
#define PR_SENDER_EMAIL_ADDRESS						PROP_TAG( PT_TSTRING,	0x0C1F)
#define PR_SENDER_EMAIL_ADDRESS_W					PROP_TAG( PT_UNICODE,	0x0C1F)
#define PR_SENDER_EMAIL_ADDRESS_A					PROP_TAG( PT_STRING8,	0x0C1F)

/*
 *	Message non-transmittable properties
 */

/*
 * The two tags, PR_MESSAGE_RECIPIENTS and PR_MESSAGE_ATTACHMENTS,
 * are to be used in the exclude list passed to
 * IMessage::CopyTo when the caller wants either the recipients or attachments
 * of the message to not get copied.  It is also used in the ProblemArray
 * return from IMessage::CopyTo when an error is encountered copying them
 */

#define PR_CURRENT_VERSION							PROP_TAG( PT_I8,		0x0E00)
#define PR_DELETE_AFTER_SUBMIT						PROP_TAG( PT_BOOLEAN,	0x0E01)
#define PR_DISPLAY_BCC								PROP_TAG( PT_TSTRING,	0x0E02)
#define PR_DISPLAY_BCC_W							PROP_TAG( PT_UNICODE,	0x0E02)
#define PR_DISPLAY_BCC_A							PROP_TAG( PT_STRING8,	0x0E02)
#define PR_DISPLAY_CC								PROP_TAG( PT_TSTRING,	0x0E03)
#define PR_DISPLAY_CC_W								PROP_TAG( PT_UNICODE,	0x0E03)
#define PR_DISPLAY_CC_A								PROP_TAG( PT_STRING8,	0x0E03)
#define PR_DISPLAY_TO								PROP_TAG( PT_TSTRING,	0x0E04)
#define PR_DISPLAY_TO_W								PROP_TAG( PT_UNICODE,	0x0E04)
#define PR_DISPLAY_TO_A								PROP_TAG( PT_STRING8,	0x0E04)
#define PR_PARENT_DISPLAY							PROP_TAG( PT_TSTRING,	0x0E05)
#define PR_PARENT_DISPLAY_W							PROP_TAG( PT_UNICODE,	0x0E05)
#define PR_PARENT_DISPLAY_A							PROP_TAG( PT_STRING8,	0x0E05)
#define PR_MESSAGE_DELIVERY_TIME					PROP_TAG( PT_SYSTIME,	0x0E06)
#define PR_MESSAGE_FLAGS							PROP_TAG( PT_LONG,		0x0E07)
#define PR_MESSAGE_SIZE								PROP_TAG( PT_LONG,		0x0E08)
#define PR_PARENT_ENTRYID							PROP_TAG( PT_BINARY,	0x0E09)
#define PR_SENTMAIL_ENTRYID							PROP_TAG( PT_BINARY,	0x0E0A)
#define PR_CORRELATE								PROP_TAG( PT_BOOLEAN,	0x0E0C)
#define PR_CORRELATE_MTSID							PROP_TAG( PT_BINARY,	0x0E0D)
#define PR_DISCRETE_VALUES							PROP_TAG( PT_BOOLEAN,	0x0E0E)
#define PR_RESPONSIBILITY							PROP_TAG( PT_BOOLEAN,	0x0E0F)
#define	PR_SPOOLER_STATUS							PROP_TAG( PT_LONG,		0x0E10)
#define	PR_TRANSPORT_STATUS							PROP_TAG( PT_LONG,		0x0E11)
#define PR_MESSAGE_RECIPIENTS						PROP_TAG( PT_OBJECT,	0x0E12)
#define PR_MESSAGE_ATTACHMENTS						PROP_TAG( PT_OBJECT,	0x0E13)
#define PR_SUBMIT_FLAGS								PROP_TAG( PT_LONG,		0x0E14)
#define PR_RECIPIENT_STATUS							PROP_TAG( PT_LONG,		0x0E15)
#define	PR_TRANSPORT_KEY							PROP_TAG( PT_LONG,		0x0E16)
#define PR_MSG_STATUS								PROP_TAG( PT_LONG,		0x0E17)
#define	PR_MESSAGE_DOWNLOAD_TIME					PROP_TAG( PT_LONG,		0x0E18)
#define PR_CREATION_VERSION							PROP_TAG( PT_I8,		0x0E19)
#define PR_MODIFY_VERSION							PROP_TAG( PT_I8,		0x0E1A)
#define PR_HASATTACH								PROP_TAG( PT_BOOLEAN,	0x0E1B)
#define PR_BODY_CRC									PROP_TAG( PT_LONG,      0x0E1C)
#define PR_NORMALIZED_SUBJECT						PROP_TAG( PT_TSTRING,	0x0E1D)
#define PR_NORMALIZED_SUBJECT_W						PROP_TAG( PT_UNICODE,	0x0E1D)
#define PR_NORMALIZED_SUBJECT_A						PROP_TAG( PT_STRING8,	0x0E1D)
#define PR_RTF_IN_SYNC								PROP_TAG( PT_BOOLEAN,	0x0E1F)
#define PR_ATTACH_SIZE								PROP_TAG( PT_LONG,		0x0E20)
#define PR_ATTACH_NUM								PROP_TAG( PT_LONG,		0x0E21)
#define PR_PREPROCESS								PROP_TAG( PT_BOOLEAN,	0x0E22)

/* PR_ORIGINAL_DISPLAY_TO, _CC, and _BCC moved to transmittible range 03/09/95 */

#define PR_ORIGINATING_MTA_CERTIFICATE				PROP_TAG( PT_BINARY,	0x0E25)
#define PR_PROOF_OF_SUBMISSION						PROP_TAG( PT_BINARY,	0x0E26)


/*
 * The range of non-message and non-recipient property IDs (0x3000 - 0x3FFF) is
 * further broken down into ranges to make assigning new property IDs easier.
 *
 *	From	To		Kind of property
 *	--------------------------------
 *	3000	32FF	MAPI_defined common property
 *	3200	33FF	MAPI_defined form property
 *	3400	35FF	MAPI_defined message store property
 *	3600	36FF	MAPI_defined Folder or AB Container property
 *	3700	38FF	MAPI_defined attachment property
 *	3900	39FF	MAPI_defined address book property
 *	3A00	3BFF	MAPI_defined mailuser property
 *	3C00	3CFF	MAPI_defined DistList property
 *	3D00	3DFF	MAPI_defined Profile Section property
 *	3E00	3EFF	MAPI_defined Status property
 *	3F00	3FFF	MAPI_defined display table property
 */

/*
 *	Properties common to numerous MAPI objects.
 *
 *	Those properties that can appear on messages are in the
 *	non-transmittable range for messages. They start at the high
 *	end of that range and work down.
 *
 *	Properties that never appear on messages are defined in the common
 *	property range (see above).
 */

/*
 * properties that are common to multiple objects (including message objects)
 * -- these ids are in the non-transmittable range
 */

#define PR_ENTRYID									PROP_TAG( PT_BINARY,	0x0FFF)
#define PR_OBJECT_TYPE								PROP_TAG( PT_LONG,		0x0FFE)
#define PR_ICON										PROP_TAG( PT_BINARY,	0x0FFD)
#define PR_MINI_ICON								PROP_TAG( PT_BINARY,	0x0FFC)
#define PR_STORE_ENTRYID							PROP_TAG( PT_BINARY,	0x0FFB)
#define PR_STORE_RECORD_KEY							PROP_TAG( PT_BINARY,	0x0FFA)
#define PR_RECORD_KEY								PROP_TAG( PT_BINARY,	0x0FF9)
#define PR_MAPPING_SIGNATURE						PROP_TAG( PT_BINARY,	0x0FF8)
#define PR_ACCESS_LEVEL								PROP_TAG( PT_LONG,		0x0FF7)
#define PR_INSTANCE_KEY								PROP_TAG( PT_BINARY,	0x0FF6)
#define PR_ROW_TYPE									PROP_TAG( PT_LONG,		0x0FF5)
#define PR_ACCESS									PROP_TAG( PT_LONG,		0x0FF4)

/*
 * properties that are common to multiple objects (usually not including message objects)
 * -- these ids are in the transmittable range
 */

#define PR_ROWID									PROP_TAG( PT_LONG,		0x3000)
#define PR_DISPLAY_NAME								PROP_TAG( PT_TSTRING,	0x3001)
#define PR_DISPLAY_NAME_W							PROP_TAG( PT_UNICODE,	0x3001)
#define PR_DISPLAY_NAME_A							PROP_TAG( PT_STRING8,	0x3001)
#define PR_ADDRTYPE									PROP_TAG( PT_TSTRING,	0x3002)
#define PR_ADDRTYPE_W								PROP_TAG( PT_UNICODE,	0x3002)
#define PR_ADDRTYPE_A								PROP_TAG( PT_STRING8,	0x3002)
#define PR_EMAIL_ADDRESS							PROP_TAG( PT_TSTRING,	0x3003)
#define PR_EMAIL_ADDRESS_W							PROP_TAG( PT_UNICODE,	0x3003)
#define PR_EMAIL_ADDRESS_A							PROP_TAG( PT_STRING8,	0x3003)
#define PR_COMMENT									PROP_TAG( PT_TSTRING,	0x3004)
#define PR_COMMENT_W								PROP_TAG( PT_UNICODE,	0x3004)
#define PR_COMMENT_A								PROP_TAG( PT_STRING8,	0x3004)
#define PR_DEPTH									PROP_TAG( PT_LONG,		0x3005)
#define PR_PROVIDER_DISPLAY							PROP_TAG( PT_TSTRING,	0x3006)
#define PR_PROVIDER_DISPLAY_W						PROP_TAG( PT_UNICODE,	0x3006)
#define PR_PROVIDER_DISPLAY_A						PROP_TAG( PT_STRING8,	0x3006)
#define PR_CREATION_TIME							PROP_TAG( PT_SYSTIME,	0x3007)
#define PR_LAST_MODIFICATION_TIME					PROP_TAG( PT_SYSTIME,	0x3008)
#define PR_RESOURCE_FLAGS							PROP_TAG( PT_LONG,		0x3009)
#define PR_PROVIDER_DLL_NAME						PROP_TAG( PT_TSTRING,	0x300A)
#define PR_PROVIDER_DLL_NAME_W						PROP_TAG( PT_UNICODE,	0x300A)
#define PR_PROVIDER_DLL_NAME_A						PROP_TAG( PT_STRING8,	0x300A)
#define PR_SEARCH_KEY								PROP_TAG( PT_BINARY,	0x300B)
#define PR_PROVIDER_UID								PROP_TAG( PT_BINARY,	0x300C)
#define PR_PROVIDER_ORDINAL							PROP_TAG( PT_LONG,		0x300D)

/*
 *  MAPI Form properties
 */
#define PR_FORM_VERSION								PROP_TAG(PT_TSTRING,	0x3301)
#define PR_FORM_VERSION_W							PROP_TAG(PT_UNICODE,	0x3301)
#define PR_FORM_VERSION_A							PROP_TAG(PT_STRING8,	0x3301)
#define PR_FORM_CLSID								PROP_TAG(PT_CLSID,		0x3302)
#define PR_FORM_CONTACT_NAME						PROP_TAG(PT_TSTRING,	0x3303)
#define PR_FORM_CONTACT_NAME_W						PROP_TAG(PT_UNICODE,	0x3303)
#define PR_FORM_CONTACT_NAME_A						PROP_TAG(PT_STRING8,	0x3303)
#define PR_FORM_CATEGORY							PROP_TAG(PT_TSTRING,	0x3304)
#define PR_FORM_CATEGORY_W							PROP_TAG(PT_UNICODE,	0x3304)
#define PR_FORM_CATEGORY_A							PROP_TAG(PT_STRING8,	0x3304)
#define PR_FORM_CATEGORY_SUB						PROP_TAG(PT_TSTRING,	0x3305)
#define PR_FORM_CATEGORY_SUB_W						PROP_TAG(PT_UNICODE,	0x3305)
#define PR_FORM_CATEGORY_SUB_A						PROP_TAG(PT_STRING8,	0x3305)
#define PR_FORM_HOST_MAP							PROP_TAG(PT_MV_LONG,	0x3306)
#define PR_FORM_HIDDEN								PROP_TAG(PT_BOOLEAN,	0x3307)
#define PR_FORM_DESIGNER_NAME						PROP_TAG(PT_TSTRING,	0x3308)
#define PR_FORM_DESIGNER_NAME_W						PROP_TAG(PT_UNICODE,	0x3308)
#define PR_FORM_DESIGNER_NAME_A						PROP_TAG(PT_STRING8,	0x3308)
#define PR_FORM_DESIGNER_GUID						PROP_TAG(PT_CLSID,		0x3309)
#define PR_FORM_MESSAGE_BEHAVIOR					PROP_TAG(PT_LONG,		0x330A)

/*
 *	Message store properties
 */

#define PR_DEFAULT_STORE							PROP_TAG( PT_BOOLEAN,	0x3400)
#define PR_STORE_SUPPORT_MASK						PROP_TAG( PT_LONG,		0x340D)
#define PR_STORE_STATE								PROP_TAG( PT_LONG,		0x340E)

#define PR_IPM_SUBTREE_SEARCH_KEY					PROP_TAG( PT_BINARY,	0x3410)
#define PR_IPM_OUTBOX_SEARCH_KEY					PROP_TAG( PT_BINARY,	0x3411)
#define PR_IPM_WASTEBASKET_SEARCH_KEY				PROP_TAG( PT_BINARY,	0x3412)
#define PR_IPM_SENTMAIL_SEARCH_KEY					PROP_TAG( PT_BINARY,	0x3413)
#define PR_MDB_PROVIDER								PROP_TAG( PT_BINARY,	0x3414)
#define PR_RECEIVE_FOLDER_SETTINGS					PROP_TAG( PT_OBJECT,	0x3415)

#define PR_VALID_FOLDER_MASK						PROP_TAG( PT_LONG,		0x35DF)
#define PR_IPM_SUBTREE_ENTRYID						PROP_TAG( PT_BINARY,	0x35E0)

#define PR_IPM_OUTBOX_ENTRYID						PROP_TAG( PT_BINARY,	0x35E2)
#define PR_IPM_WASTEBASKET_ENTRYID					PROP_TAG( PT_BINARY,	0x35E3)
#define PR_IPM_SENTMAIL_ENTRYID						PROP_TAG( PT_BINARY,	0x35E4)
#define PR_VIEWS_ENTRYID							PROP_TAG( PT_BINARY,	0x35E5)
#define PR_COMMON_VIEWS_ENTRYID						PROP_TAG( PT_BINARY,	0x35E6)
#define PR_FINDER_ENTRYID							PROP_TAG( PT_BINARY,	0x35E7)

/* Proptags 0x35E8-0x35FF reserved for folders "guaranteed" by PR_VALID_FOLDER_MASK */


/*
 *	Folder and AB Container properties
 */

#define PR_CONTAINER_FLAGS							PROP_TAG( PT_LONG,		0x3600)
#define PR_FOLDER_TYPE								PROP_TAG( PT_LONG,		0x3601)
#define PR_CONTENT_COUNT							PROP_TAG( PT_LONG,		0x3602)
#define PR_CONTENT_UNREAD							PROP_TAG( PT_LONG,		0x3603)
#define PR_CREATE_TEMPLATES							PROP_TAG( PT_OBJECT,	0x3604)
#define PR_DETAILS_TABLE							PROP_TAG( PT_OBJECT,	0x3605)
#define PR_SEARCH									PROP_TAG( PT_OBJECT,	0x3607)
#define PR_SELECTABLE								PROP_TAG( PT_BOOLEAN,	0x3609)
#define PR_SUBFOLDERS								PROP_TAG( PT_BOOLEAN,	0x360A)
#define PR_STATUS									PROP_TAG( PT_LONG,		0x360B)
#define PR_ANR										PROP_TAG( PT_TSTRING,	0x360C)
#define PR_ANR_W									PROP_TAG( PT_UNICODE,	0x360C)
#define PR_ANR_A									PROP_TAG( PT_STRING8,	0x360C)
#define PR_CONTENTS_SORT_ORDER						PROP_TAG( PT_MV_LONG,	0x360D)
#define PR_CONTAINER_HIERARCHY						PROP_TAG( PT_OBJECT,	0x360E)
#define PR_CONTAINER_CONTENTS						PROP_TAG( PT_OBJECT,	0x360F)
#define PR_FOLDER_ASSOCIATED_CONTENTS				PROP_TAG( PT_OBJECT,	0x3610)
#define PR_DEF_CREATE_DL							PROP_TAG( PT_BINARY,	0x3611)
#define PR_DEF_CREATE_MAILUSER						PROP_TAG( PT_BINARY,	0x3612)
#define	PR_CONTAINER_CLASS							PROP_TAG( PT_TSTRING,	0x3613)
#define	PR_CONTAINER_CLASS_W						PROP_TAG( PT_UNICODE,	0x3613)
#define	PR_CONTAINER_CLASS_A						PROP_TAG( PT_STRING8,	0x3613)
#define	PR_CONTAINER_MODIFY_VERSION					PROP_TAG( PT_I8,		0x3614)
#define PR_AB_PROVIDER_ID							PROP_TAG( PT_BINARY,	0x3615)
#define PR_DEFAULT_VIEW_ENTRYID						PROP_TAG( PT_BINARY,	0x3616)
#define	PR_ASSOC_CONTENT_COUNT						PROP_TAG( PT_LONG,		0x3617)

/* Reserved 0x36C0-0x36FF */

/*
 *	Attachment properties
 */

#define PR_ATTACHMENT_X400_PARAMETERS				PROP_TAG( PT_BINARY,	0x3700)
#define PR_ATTACH_DATA_OBJ							PROP_TAG( PT_OBJECT,	0x3701)
#define PR_ATTACH_DATA_BIN							PROP_TAG( PT_BINARY,	0x3701)
#define PR_ATTACH_ENCODING							PROP_TAG( PT_BINARY,	0x3702)
#define PR_ATTACH_EXTENSION							PROP_TAG( PT_TSTRING,	0x3703)
#define PR_ATTACH_EXTENSION_W						PROP_TAG( PT_UNICODE,	0x3703)
#define PR_ATTACH_EXTENSION_A						PROP_TAG( PT_STRING8,	0x3703)
#define PR_ATTACH_FILENAME							PROP_TAG( PT_TSTRING,	0x3704)
#define PR_ATTACH_FILENAME_W						PROP_TAG( PT_UNICODE,	0x3704)
#define PR_ATTACH_FILENAME_A						PROP_TAG( PT_STRING8,	0x3704)
#define PR_ATTACH_METHOD							PROP_TAG( PT_LONG,		0x3705)
#define PR_ATTACH_LONG_FILENAME	 					PROP_TAG( PT_TSTRING,	0x3707)
#define PR_ATTACH_LONG_FILENAME_W					PROP_TAG( PT_UNICODE,	0x3707)
#define PR_ATTACH_LONG_FILENAME_A					PROP_TAG( PT_STRING8,	0x3707)
#define PR_ATTACH_PATHNAME							PROP_TAG( PT_TSTRING,	0x3708)
#define PR_ATTACH_PATHNAME_W						PROP_TAG( PT_UNICODE,	0x3708)
#define PR_ATTACH_PATHNAME_A						PROP_TAG( PT_STRING8,	0x3708)
#define PR_ATTACH_RENDERING							PROP_TAG( PT_BINARY,    0x3709)
#define PR_ATTACH_TAG								PROP_TAG( PT_BINARY,	0x370A)
#define PR_RENDERING_POSITION						PROP_TAG( PT_LONG,		0x370B)
#define PR_ATTACH_TRANSPORT_NAME					PROP_TAG( PT_TSTRING,	0x370C)
#define PR_ATTACH_TRANSPORT_NAME_W					PROP_TAG( PT_UNICODE,	0x370C)
#define PR_ATTACH_TRANSPORT_NAME_A					PROP_TAG( PT_STRING8,	0x370C)
#define PR_ATTACH_LONG_PATHNAME	 					PROP_TAG( PT_TSTRING,	0x370D)
#define PR_ATTACH_LONG_PATHNAME_W					PROP_TAG( PT_UNICODE,	0x370D)
#define PR_ATTACH_LONG_PATHNAME_A					PROP_TAG( PT_STRING8,	0x370D)
#define PR_ATTACH_MIME_TAG							PROP_TAG( PT_TSTRING,	0x370E)
#define PR_ATTACH_MIME_TAG_W						PROP_TAG( PT_UNICODE,	0x370E)
#define PR_ATTACH_MIME_TAG_A						PROP_TAG( PT_STRING8,	0x370E)
#define	PR_ATTACH_ADDITIONAL_INFO					PROP_TAG( PT_BINARY,	0x370F)

/*
 *  AB Object properties
 */

#define PR_DISPLAY_TYPE								PROP_TAG( PT_LONG,		0x3900)
#define PR_TEMPLATEID								PROP_TAG( PT_BINARY,	0x3902)
#define PR_PRIMARY_CAPABILITY						PROP_TAG( PT_BINARY,	0x3904)


/*
 *	Mail user properties
 */
#define PR_7BIT_DISPLAY_NAME						PROP_TAG( PT_STRING8,	0x39FF)
#define PR_ACCOUNT									PROP_TAG( PT_TSTRING,	0x3A00)
#define PR_ACCOUNT_W								PROP_TAG( PT_UNICODE,	0x3A00)
#define PR_ACCOUNT_A								PROP_TAG( PT_STRING8,	0x3A00)
#define PR_ALTERNATE_RECIPIENT						PROP_TAG( PT_BINARY,	0x3A01)
#define PR_CALLBACK_TELEPHONE_NUMBER				PROP_TAG( PT_TSTRING,	0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A02)
#define PR_CONVERSION_PROHIBITED					PROP_TAG( PT_BOOLEAN,	0x3A03)
#define PR_DISCLOSE_RECIPIENTS						PROP_TAG( PT_BOOLEAN,	0x3A04)
#define PR_GENERATION								PROP_TAG( PT_TSTRING,	0x3A05)
#define PR_GENERATION_W								PROP_TAG( PT_UNICODE,	0x3A05)
#define PR_GENERATION_A								PROP_TAG( PT_STRING8,	0x3A05)
#define PR_GIVEN_NAME								PROP_TAG( PT_TSTRING,	0x3A06)
#define PR_GIVEN_NAME_W								PROP_TAG( PT_UNICODE,	0x3A06)
#define PR_GIVEN_NAME_A								PROP_TAG( PT_STRING8,	0x3A06)
#define PR_GOVERNMENT_ID_NUMBER						PROP_TAG( PT_TSTRING,	0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A07)
#define PR_BUSINESS_TELEPHONE_NUMBER				PROP_TAG( PT_TSTRING,	0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A08)
#define PR_OFFICE_TELEPHONE_NUMBER					PR_BUSINESS_TELEPHONE_NUMBER
#define PR_OFFICE_TELEPHONE_NUMBER_W				PR_BUSINESS_TELEPHONE_NUMBER_W
#define PR_OFFICE_TELEPHONE_NUMBER_A				PR_BUSINESS_TELEPHONE_NUMBER_A
#define PR_HOME_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A09)
#define PR_INITIALS									PROP_TAG( PT_TSTRING,	0x3A0A)
#define PR_INITIALS_W								PROP_TAG( PT_UNICODE,	0x3A0A)
#define PR_INITIALS_A								PROP_TAG( PT_STRING8,	0x3A0A)
#define PR_KEYWORD									PROP_TAG( PT_TSTRING,	0x3A0B)
#define PR_KEYWORD_W								PROP_TAG( PT_UNICODE,	0x3A0B)
#define PR_KEYWORD_A								PROP_TAG( PT_STRING8,	0x3A0B)
#define PR_LANGUAGE									PROP_TAG( PT_TSTRING,	0x3A0C)
#define PR_LANGUAGE_W								PROP_TAG( PT_UNICODE,	0x3A0C)
#define PR_LANGUAGE_A								PROP_TAG( PT_STRING8,	0x3A0C)
#define PR_LOCATION									PROP_TAG( PT_TSTRING,	0x3A0D)
#define PR_LOCATION_W								PROP_TAG( PT_UNICODE,	0x3A0D)
#define PR_LOCATION_A								PROP_TAG( PT_STRING8,	0x3A0D)
#define PR_MAIL_PERMISSION							PROP_TAG( PT_BOOLEAN,	0x3A0E)
#define PR_MHS_COMMON_NAME							PROP_TAG( PT_TSTRING,	0x3A0F)
#define PR_MHS_COMMON_NAME_W						PROP_TAG( PT_UNICODE,	0x3A0F)
#define PR_MHS_COMMON_NAME_A						PROP_TAG( PT_STRING8,	0x3A0F)
#define PR_ORGANIZATIONAL_ID_NUMBER					PROP_TAG( PT_TSTRING,	0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A10)
#define PR_SURNAME									PROP_TAG( PT_TSTRING,	0x3A11)
#define PR_SURNAME_W								PROP_TAG( PT_UNICODE,	0x3A11)
#define PR_SURNAME_A								PROP_TAG( PT_STRING8,	0x3A11)
#define PR_ORIGINAL_ENTRYID							PROP_TAG( PT_BINARY,	0x3A12)
#define PR_ORIGINAL_DISPLAY_NAME					PROP_TAG( PT_TSTRING,	0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_W					PROP_TAG( PT_UNICODE,	0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_A					PROP_TAG( PT_STRING8,	0x3A13)
#define PR_ORIGINAL_SEARCH_KEY						PROP_TAG( PT_BINARY,	0x3A14)
#define PR_POSTAL_ADDRESS							PROP_TAG( PT_TSTRING,	0x3A15)
#define PR_POSTAL_ADDRESS_W							PROP_TAG( PT_UNICODE,	0x3A15)
#define PR_POSTAL_ADDRESS_A							PROP_TAG( PT_STRING8,	0x3A15)
#define PR_COMPANY_NAME								PROP_TAG( PT_TSTRING,	0x3A16)
#define PR_COMPANY_NAME_W							PROP_TAG( PT_UNICODE,	0x3A16)
#define PR_COMPANY_NAME_A							PROP_TAG( PT_STRING8,	0x3A16)
#define PR_TITLE									PROP_TAG( PT_TSTRING,	0x3A17)
#define PR_TITLE_W									PROP_TAG( PT_UNICODE,	0x3A17)
#define PR_TITLE_A									PROP_TAG( PT_STRING8,	0x3A17)
#define PR_DEPARTMENT_NAME							PROP_TAG( PT_TSTRING,	0x3A18)
#define PR_DEPARTMENT_NAME_W						PROP_TAG( PT_UNICODE,	0x3A18)
#define PR_DEPARTMENT_NAME_A						PROP_TAG( PT_STRING8,	0x3A18)
#define PR_OFFICE_LOCATION							PROP_TAG( PT_TSTRING,	0x3A19)
#define PR_OFFICE_LOCATION_W						PROP_TAG( PT_UNICODE,	0x3A19)
#define PR_OFFICE_LOCATION_A						PROP_TAG( PT_STRING8,	0x3A19)
#define PR_PRIMARY_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A1A)
#define PR_BUSINESS2_TELEPHONE_NUMBER				PROP_TAG( PT_TSTRING,	0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A1B)
#define PR_OFFICE2_TELEPHONE_NUMBER					PR_BUSINESS2_TELEPHONE_NUMBER
#define PR_OFFICE2_TELEPHONE_NUMBER_W				PR_BUSINESS2_TELEPHONE_NUMBER_W
#define PR_OFFICE2_TELEPHONE_NUMBER_A				PR_BUSINESS2_TELEPHONE_NUMBER_A
#define PR_MOBILE_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A1C)
#define PR_CELLULAR_TELEPHONE_NUMBER				PR_MOBILE_TELEPHONE_NUMBER
#define PR_CELLULAR_TELEPHONE_NUMBER_W				PR_MOBILE_TELEPHONE_NUMBER_W
#define PR_CELLULAR_TELEPHONE_NUMBER_A				PR_MOBILE_TELEPHONE_NUMBER_A
#define PR_RADIO_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A1D)
#define PR_CAR_TELEPHONE_NUMBER						PROP_TAG( PT_TSTRING,	0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A1E)
#define PR_OTHER_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A1F)
#define PR_TRANSMITABLE_DISPLAY_NAME				PROP_TAG( PT_TSTRING,	0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_W				PROP_TAG( PT_UNICODE,	0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_A				PROP_TAG( PT_STRING8,	0x3A20)
#define PR_PAGER_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A21)
#define PR_BEEPER_TELEPHONE_NUMBER					PR_PAGER_TELEPHONE_NUMBER
#define PR_BEEPER_TELEPHONE_NUMBER_W				PR_PAGER_TELEPHONE_NUMBER_W
#define PR_BEEPER_TELEPHONE_NUMBER_A				PR_PAGER_TELEPHONE_NUMBER_A
#define PR_USER_CERTIFICATE							PROP_TAG( PT_BINARY,	0x3A22)
#define PR_PRIMARY_FAX_NUMBER						PROP_TAG( PT_TSTRING,	0x3A23)
#define PR_PRIMARY_FAX_NUMBER_W						PROP_TAG( PT_UNICODE,	0x3A23)
#define PR_PRIMARY_FAX_NUMBER_A						PROP_TAG( PT_STRING8,	0x3A23)
#define PR_BUSINESS_FAX_NUMBER						PROP_TAG( PT_TSTRING,	0x3A24)
#define PR_BUSINESS_FAX_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A24)
#define PR_BUSINESS_FAX_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A24)
#define PR_HOME_FAX_NUMBER							PROP_TAG( PT_TSTRING,	0x3A25)
#define PR_HOME_FAX_NUMBER_W						PROP_TAG( PT_UNICODE,	0x3A25)
#define PR_HOME_FAX_NUMBER_A						PROP_TAG( PT_STRING8,	0x3A25)
#define PR_COUNTRY									PROP_TAG( PT_TSTRING,	0x3A26)
#define PR_COUNTRY_W								PROP_TAG( PT_UNICODE,	0x3A26)
#define PR_COUNTRY_A								PROP_TAG( PT_STRING8,	0x3A26)
#define PR_BUSINESS_ADDRESS_COUNTRY					PR_COUNTRY
#define PR_BUSINESS_ADDRESS_COUNTRY_W				PR_COUNTRY_W
#define PR_BUSINESS_ADDRESS_COUNTRY_A				PR_COUNTRY_A

#define PR_LOCALITY									PROP_TAG( PT_TSTRING,	0x3A27)
#define PR_LOCALITY_W								PROP_TAG( PT_UNICODE,	0x3A27)
#define PR_LOCALITY_A								PROP_TAG( PT_STRING8,	0x3A27)
#define PR_BUSINESS_ADDRESS_CITY					PR_LOCALITY
#define PR_BUSINESS_ADDRESS_CITY_W					PR_LOCALITY_W
#define PR_BUSINESS_ADDRESS_CITY_A					PR_LOCALITY_A

#define PR_STATE_OR_PROVINCE						PROP_TAG( PT_TSTRING,	0x3A28)
#define PR_STATE_OR_PROVINCE_W						PROP_TAG( PT_UNICODE,	0x3A28)
#define PR_STATE_OR_PROVINCE_A						PROP_TAG( PT_STRING8,	0x3A28)
#define PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE		PR_STATE_OR_PROVINCE
#define PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_W		PR_STATE_OR_PROVINCE_W
#define PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_A		PR_STATE_OR_PROVINCE_A

#define PR_STREET_ADDRESS							PROP_TAG( PT_TSTRING,	0x3A29)
#define PR_STREET_ADDRESS_W							PROP_TAG( PT_UNICODE,	0x3A29)
#define PR_STREET_ADDRESS_A							PROP_TAG( PT_STRING8,	0x3A29)
#define PR_BUSINESS_ADDRESS_STREET					PR_STREET_ADDRESS
#define PR_BUSINESS_ADDRESS_STREET_W				PR_STREET_ADDRESS_W
#define PR_BUSINESS_ADDRESS_STREET_A				PR_STREET_ADDRESS_A

#define PR_POSTAL_CODE								PROP_TAG( PT_TSTRING,	0x3A2A)
#define PR_POSTAL_CODE_W							PROP_TAG( PT_UNICODE,	0x3A2A)
#define PR_POSTAL_CODE_A							PROP_TAG( PT_STRING8,	0x3A2A)
#define PR_BUSINESS_ADDRESS_POSTAL_CODE				PR_POSTAL_CODE
#define PR_BUSINESS_ADDRESS_POSTAL_CODE_W			PR_POSTAL_CODE_W
#define PR_BUSINESS_ADDRESS_POSTAL_CODE_A			PR_POSTAL_CODE_A


#define PR_POST_OFFICE_BOX							PROP_TAG( PT_TSTRING,	0x3A2B)
#define PR_POST_OFFICE_BOX_W						PROP_TAG( PT_UNICODE,	0x3A2B)
#define PR_POST_OFFICE_BOX_A						PROP_TAG( PT_STRING8,	0x3A2B)
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX			PR_POST_OFFICE_BOX
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_W		PR_POST_OFFICE_BOX_W
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_A		PR_POST_OFFICE_BOX_A


#define PR_TELEX_NUMBER								PROP_TAG( PT_TSTRING,	0x3A2C)
#define PR_TELEX_NUMBER_W							PROP_TAG( PT_UNICODE,	0x3A2C)
#define PR_TELEX_NUMBER_A							PROP_TAG( PT_STRING8,	0x3A2C)
#define PR_ISDN_NUMBER								PROP_TAG( PT_TSTRING,	0x3A2D)
#define PR_ISDN_NUMBER_W							PROP_TAG( PT_UNICODE,	0x3A2D)
#define PR_ISDN_NUMBER_A							PROP_TAG( PT_STRING8,	0x3A2D)
#define PR_ASSISTANT_TELEPHONE_NUMBER				PROP_TAG( PT_TSTRING,	0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A2E)
#define PR_HOME2_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A2F)
#define PR_ASSISTANT								PROP_TAG( PT_TSTRING,	0x3A30)
#define PR_ASSISTANT_W								PROP_TAG( PT_UNICODE,	0x3A30)
#define PR_ASSISTANT_A								PROP_TAG( PT_STRING8,	0x3A30)
#define PR_SEND_RICH_INFO							PROP_TAG( PT_BOOLEAN,	0x3A40)

#define PR_WEDDING_ANNIVERSARY						PROP_TAG( PT_SYSTIME, 0x3A41)
#define PR_BIRTHDAY									PROP_TAG( PT_SYSTIME, 0x3A42)


#define PR_HOBBIES									PROP_TAG( PT_TSTRING, 0x3A43)
#define PR_HOBBIES_W								PROP_TAG( PT_UNICODE, 0x3A43)
#define PR_HOBBIES_A								PROP_TAG( PT_STRING8, 0x3A43)

#define PR_MIDDLE_NAME								PROP_TAG( PT_TSTRING, 0x3A44)
#define PR_MIDDLE_NAME_W							PROP_TAG( PT_UNICODE, 0x3A44)
#define PR_MIDDLE_NAME_A							PROP_TAG( PT_STRING8, 0x3A44)

#define PR_DISPLAY_NAME_PREFIX						PROP_TAG( PT_TSTRING, 0x3A45)
#define PR_DISPLAY_NAME_PREFIX_W					PROP_TAG( PT_UNICODE, 0x3A45)
#define PR_DISPLAY_NAME_PREFIX_A					PROP_TAG( PT_STRING8, 0x3A45)

#define PR_PROFESSION								PROP_TAG( PT_TSTRING, 0x3A46)
#define PR_PROFESSION_W								PROP_TAG( PT_UNICODE, 0x3A46)
#define PR_PROFESSION_A								PROP_TAG( PT_STRING8, 0x3A46)

#define PR_PREFERRED_BY_NAME						PROP_TAG( PT_TSTRING, 0x3A47)
#define PR_PREFERRED_BY_NAME_W						PROP_TAG( PT_UNICODE, 0x3A47)
#define PR_PREFERRED_BY_NAME_A						PROP_TAG( PT_STRING8, 0x3A47)

#define PR_SPOUSE_NAME								PROP_TAG( PT_TSTRING, 0x3A48)
#define PR_SPOUSE_NAME_W							PROP_TAG( PT_UNICODE, 0x3A48)
#define PR_SPOUSE_NAME_A							PROP_TAG( PT_STRING8, 0x3A48)

#define PR_COMPUTER_NETWORK_NAME					PROP_TAG( PT_TSTRING, 0x3A49)
#define PR_COMPUTER_NETWORK_NAME_W					PROP_TAG( PT_UNICODE, 0x3A49)
#define PR_COMPUTER_NETWORK_NAME_A					PROP_TAG( PT_STRING8, 0x3A49)

#define PR_CUSTOMER_ID								PROP_TAG( PT_TSTRING, 0x3A4A)
#define PR_CUSTOMER_ID_W							PROP_TAG( PT_UNICODE, 0x3A4A)
#define PR_CUSTOMER_ID_A							PROP_TAG( PT_STRING8, 0x3A4A)

#define PR_TTYTDD_PHONE_NUMBER						PROP_TAG( PT_TSTRING, 0x3A4B)
#define PR_TTYTDD_PHONE_NUMBER_W					PROP_TAG( PT_UNICODE, 0x3A4B)
#define PR_TTYTDD_PHONE_NUMBER_A					PROP_TAG( PT_STRING8, 0x3A4B)

#define PR_FTP_SITE									PROP_TAG( PT_TSTRING, 0x3A4C)
#define PR_FTP_SITE_W								PROP_TAG( PT_UNICODE, 0x3A4C)
#define PR_FTP_SITE_A								PROP_TAG( PT_STRING8, 0x3A4C)

#define PR_GENDER									PROP_TAG( PT_SHORT, 0x3A4D)

#define PR_MANAGER_NAME								PROP_TAG( PT_TSTRING, 0x3A4E)
#define PR_MANAGER_NAME_W							PROP_TAG( PT_UNICODE, 0x3A4E)
#define PR_MANAGER_NAME_A							PROP_TAG( PT_STRING8, 0x3A4E)

#define PR_NICKNAME									PROP_TAG( PT_TSTRING, 0x3A4F)
#define PR_NICKNAME_W								PROP_TAG( PT_UNICODE, 0x3A4F)
#define PR_NICKNAME_A								PROP_TAG( PT_STRING8, 0x3A4F)

#define PR_PERSONAL_HOME_PAGE						PROP_TAG( PT_TSTRING, 0x3A50)
#define PR_PERSONAL_HOME_PAGE_W						PROP_TAG( PT_UNICODE, 0x3A50)
#define PR_PERSONAL_HOME_PAGE_A						PROP_TAG( PT_STRING8, 0x3A50)


#define PR_BUSINESS_HOME_PAGE						PROP_TAG( PT_TSTRING, 0x3A51)
#define PR_BUSINESS_HOME_PAGE_W						PROP_TAG( PT_UNICODE, 0x3A51)
#define PR_BUSINESS_HOME_PAGE_A						PROP_TAG( PT_STRING8, 0x3A51)

#define PR_CONTACT_VERSION							PROP_TAG( PT_CLSID, 0x3A52)
#define PR_CONTACT_ENTRYIDS							PROP_TAG( PT_MV_BINARY, 0x3A53)

#define PR_CONTACT_ADDRTYPES						PROP_TAG( PT_MV_TSTRING, 0x3A54)
#define PR_CONTACT_ADDRTYPES_W						PROP_TAG( PT_MV_UNICODE, 0x3A54)
#define PR_CONTACT_ADDRTYPES_A						PROP_TAG( PT_MV_STRING8, 0x3A54)

#define PR_CONTACT_DEFAULT_ADDRESS_INDEX			PROP_TAG( PT_LONG, 0x3A55)

#define PR_CONTACT_EMAIL_ADDRESSES					PROP_TAG( PT_MV_TSTRING, 0x3A56)
#define PR_CONTACT_EMAIL_ADDRESSES_W				PROP_TAG( PT_MV_UNICODE, 0x3A56)
#define PR_CONTACT_EMAIL_ADDRESSES_A				PROP_TAG( PT_MV_STRING8, 0x3A56)


#define PR_COMPANY_MAIN_PHONE_NUMBER				PROP_TAG( PT_TSTRING, 0x3A57)
#define PR_COMPANY_MAIN_PHONE_NUMBER_W				PROP_TAG( PT_UNICODE, 0x3A57)
#define PR_COMPANY_MAIN_PHONE_NUMBER_A				PROP_TAG( PT_STRING8, 0x3A57)

#define PR_CHILDRENS_NAMES							PROP_TAG( PT_MV_TSTRING, 0x3A58)
#define PR_CHILDRENS_NAMES_W						PROP_TAG( PT_MV_UNICODE, 0x3A58)
#define PR_CHILDRENS_NAMES_A						PROP_TAG( PT_MV_STRING8, 0x3A58)



#define PR_HOME_ADDRESS_CITY						PROP_TAG( PT_TSTRING, 0x3A59)
#define PR_HOME_ADDRESS_CITY_W						PROP_TAG( PT_UNICODE, 0x3A59)
#define PR_HOME_ADDRESS_CITY_A						PROP_TAG( PT_STRING8, 0x3A59)

#define PR_HOME_ADDRESS_COUNTRY						PROP_TAG( PT_TSTRING, 0x3A5A)
#define PR_HOME_ADDRESS_COUNTRY_W					PROP_TAG( PT_UNICODE, 0x3A5A)
#define PR_HOME_ADDRESS_COUNTRY_A					PROP_TAG( PT_STRING8, 0x3A5A)

#define PR_HOME_ADDRESS_POSTAL_CODE					PROP_TAG( PT_TSTRING, 0x3A5B)
#define PR_HOME_ADDRESS_POSTAL_CODE_W				PROP_TAG( PT_UNICODE, 0x3A5B)
#define PR_HOME_ADDRESS_POSTAL_CODE_A				PROP_TAG( PT_STRING8, 0x3A5B)

#define PR_HOME_ADDRESS_STATE_OR_PROVINCE			PROP_TAG( PT_TSTRING, 0x3A5C)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE_W			PROP_TAG( PT_UNICODE, 0x3A5C)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE_A			PROP_TAG( PT_STRING8, 0x3A5C)

#define PR_HOME_ADDRESS_STREET						PROP_TAG( PT_TSTRING, 0x3A5D)
#define PR_HOME_ADDRESS_STREET_W					PROP_TAG( PT_UNICODE, 0x3A5D)
#define PR_HOME_ADDRESS_STREET_A					PROP_TAG( PT_STRING8, 0x3A5D)

#define PR_HOME_ADDRESS_POST_OFFICE_BOX				PROP_TAG( PT_TSTRING, 0x3A5E)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX_W			PROP_TAG( PT_UNICODE, 0x3A5E)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX_A			PROP_TAG( PT_STRING8, 0x3A5E)

#define PR_OTHER_ADDRESS_CITY						PROP_TAG( PT_TSTRING, 0x3A5F)
#define PR_OTHER_ADDRESS_CITY_W						PROP_TAG( PT_UNICODE, 0x3A5F)
#define PR_OTHER_ADDRESS_CITY_A						PROP_TAG( PT_STRING8, 0x3A5F)

#define PR_OTHER_ADDRESS_COUNTRY					PROP_TAG( PT_TSTRING, 0x3A60)
#define PR_OTHER_ADDRESS_COUNTRY_W					PROP_TAG( PT_UNICODE, 0x3A60)
#define PR_OTHER_ADDRESS_COUNTRY_A					PROP_TAG( PT_STRING8, 0x3A60)

#define PR_OTHER_ADDRESS_POSTAL_CODE				PROP_TAG( PT_TSTRING, 0x3A61)
#define PR_OTHER_ADDRESS_POSTAL_CODE_W				PROP_TAG( PT_UNICODE, 0x3A61)
#define PR_OTHER_ADDRESS_POSTAL_CODE_A				PROP_TAG( PT_STRING8, 0x3A61)

#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE			PROP_TAG( PT_TSTRING, 0x3A62)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE_W		PROP_TAG( PT_UNICODE, 0x3A62)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE_A		PROP_TAG( PT_STRING8, 0x3A62)

#define PR_OTHER_ADDRESS_STREET						PROP_TAG( PT_TSTRING, 0x3A63)
#define PR_OTHER_ADDRESS_STREET_W					PROP_TAG( PT_UNICODE, 0x3A63)
#define PR_OTHER_ADDRESS_STREET_A					PROP_TAG( PT_STRING8, 0x3A63)

#define PR_OTHER_ADDRESS_POST_OFFICE_BOX			PROP_TAG( PT_TSTRING, 0x3A64)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX_W			PROP_TAG( PT_UNICODE, 0x3A64)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX_A			PROP_TAG( PT_STRING8, 0x3A64)


/*
 *	Profile section properties
 */

#define PR_STORE_PROVIDERS							PROP_TAG( PT_BINARY,	0x3D00)
#define PR_AB_PROVIDERS								PROP_TAG( PT_BINARY,	0x3D01)
#define PR_TRANSPORT_PROVIDERS						PROP_TAG( PT_BINARY,	0x3D02)

#define PR_DEFAULT_PROFILE							PROP_TAG( PT_BOOLEAN,	0x3D04)
#define PR_AB_SEARCH_PATH							PROP_TAG( PT_MV_BINARY,	0x3D05)
#define PR_AB_DEFAULT_DIR							PROP_TAG( PT_BINARY,	0x3D06)
#define PR_AB_DEFAULT_PAB							PROP_TAG( PT_BINARY,	0x3D07)

#define PR_FILTERING_HOOKS                          PROP_TAG( PT_BINARY,    0x3D08)
#define PR_SERVICE_NAME								PROP_TAG( PT_TSTRING,	0x3D09)
#define PR_SERVICE_NAME_W							PROP_TAG( PT_UNICODE,	0x3D09)
#define PR_SERVICE_NAME_A							PROP_TAG( PT_STRING8,	0x3D09)
#define PR_SERVICE_DLL_NAME							PROP_TAG( PT_TSTRING,	0x3D0A)
#define PR_SERVICE_DLL_NAME_W						PROP_TAG( PT_UNICODE,	0x3D0A)
#define PR_SERVICE_DLL_NAME_A						PROP_TAG( PT_STRING8,	0x3D0A)
#define PR_SERVICE_ENTRY_NAME						PROP_TAG( PT_STRING8,	0x3D0B)
#define PR_SERVICE_UID								PROP_TAG( PT_BINARY,	0x3D0C)
#define PR_SERVICE_EXTRA_UIDS						PROP_TAG( PT_BINARY,	0x3D0D)
#define PR_SERVICES									PROP_TAG( PT_BINARY,	0x3D0E)
#define PR_SERVICE_SUPPORT_FILES   					PROP_TAG( PT_MV_TSTRING, 0x3D0F)
#define PR_SERVICE_SUPPORT_FILES_W					PROP_TAG( PT_MV_UNICODE, 0x3D0F)
#define PR_SERVICE_SUPPORT_FILES_A					PROP_TAG( PT_MV_STRING8, 0x3D0F)
#define PR_SERVICE_DELETE_FILES   					PROP_TAG( PT_MV_TSTRING, 0x3D10)
#define PR_SERVICE_DELETE_FILES_W					PROP_TAG( PT_MV_UNICODE, 0x3D10)
#define PR_SERVICE_DELETE_FILES_A					PROP_TAG( PT_MV_STRING8, 0x3D10)
#define PR_AB_SEARCH_PATH_UPDATE   					PROP_TAG( PT_BINARY, 	 0x3D11)
#define PR_PROFILE_NAME								PROP_TAG( PT_TSTRING,	0x3D12)
#define PR_PROFILE_NAME_A							PROP_TAG( PT_STRING8,	0x3D12)
#define PR_PROFILE_NAME_W							PROP_TAG( PT_UNICODE,	0x3D12)

/*
 *	Status object properties
 */

#define PR_IDENTITY_DISPLAY							PROP_TAG( PT_TSTRING,	0x3E00)
#define PR_IDENTITY_DISPLAY_W						PROP_TAG( PT_UNICODE,	0x3E00)
#define PR_IDENTITY_DISPLAY_A						PROP_TAG( PT_STRING8,	0x3E00)
#define PR_IDENTITY_ENTRYID							PROP_TAG( PT_BINARY,	0x3E01)
#define PR_RESOURCE_METHODS							PROP_TAG( PT_LONG,		0x3E02)
#define PR_RESOURCE_TYPE							PROP_TAG( PT_LONG,		0x3E03)
#define PR_STATUS_CODE								PROP_TAG( PT_LONG,		0x3E04)
#define PR_IDENTITY_SEARCH_KEY						PROP_TAG( PT_BINARY,	0x3E05)
#define PR_OWN_STORE_ENTRYID						PROP_TAG( PT_BINARY,	0x3E06)
#define PR_RESOURCE_PATH							PROP_TAG( PT_TSTRING,   0x3E07)
#define PR_RESOURCE_PATH_W							PROP_TAG( PT_UNICODE,   0x3E07)
#define PR_RESOURCE_PATH_A							PROP_TAG( PT_STRING8,   0x3E07)
#define PR_STATUS_STRING							PROP_TAG( PT_TSTRING,	0x3E08)
#define PR_STATUS_STRING_W							PROP_TAG( PT_UNICODE,	0x3E08)
#define PR_STATUS_STRING_A							PROP_TAG( PT_STRING8,	0x3E08)
#define PR_X400_DEFERRED_DELIVERY_CANCEL			PROP_TAG( PT_BOOLEAN,	0x3E09)
#define PR_HEADER_FOLDER_ENTRYID					PROP_TAG( PT_BINARY,	0x3E0A)
#define PR_REMOTE_PROGRESS							PROP_TAG( PT_LONG,		0x3E0B)
#define PR_REMOTE_PROGRESS_TEXT						PROP_TAG( PT_TSTRING,	0x3E0C)
#define PR_REMOTE_PROGRESS_TEXT_W					PROP_TAG( PT_UNICODE,	0x3E0C)
#define PR_REMOTE_PROGRESS_TEXT_A					PROP_TAG( PT_STRING8,	0x3E0C)
#define PR_REMOTE_VALIDATE_OK						PROP_TAG( PT_BOOLEAN,	0x3E0D)

/*
 * Display table properties
 */

#define PR_CONTROL_FLAGS							PROP_TAG( PT_LONG,		0x3F00)
#define PR_CONTROL_STRUCTURE						PROP_TAG( PT_BINARY,	0x3F01)
#define PR_CONTROL_TYPE								PROP_TAG( PT_LONG,		0x3F02)
#define PR_DELTAX									PROP_TAG( PT_LONG,		0x3F03)
#define PR_DELTAY									PROP_TAG( PT_LONG,		0x3F04)
#define PR_XPOS										PROP_TAG( PT_LONG,		0x3F05)
#define PR_YPOS										PROP_TAG( PT_LONG,		0x3F06)
#define PR_CONTROL_ID								PROP_TAG( PT_BINARY,	0x3F07)
#define PR_INITIAL_DETAILS_PANE						PROP_TAG( PT_LONG,		0x3F08)

/*
 * Secure property id range
 */

#define PROP_ID_SECURE_MIN 							0x67F0
#define PROP_ID_SECURE_MAX 							0x67FF


#endif	/* MAPITAGS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mgmtapi.h ===
/*++

Copyright (c) 1992-1999 Microsoft Corporation

Module Name:

    mgmtapi.h

Abstract:

    Definitions for SNMP Management API Development.

--*/

#ifndef _INC_MGMTAPI
#define _INC_MGMTAPI

#if _MSC_VER > 1000
#pragma once
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Additional header files                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <winsock.h>

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// MGMT API error code definitions                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_MGMTAPI_TIMEOUT                40
#define SNMP_MGMTAPI_SELECT_FDERRORS        41
#define SNMP_MGMTAPI_TRAP_ERRORS            42
#define SNMP_MGMTAPI_TRAP_DUPINIT           43
#define SNMP_MGMTAPI_NOTRAPS                44
#define SNMP_MGMTAPI_AGAIN                  45
#define SNMP_MGMTAPI_INVALID_CTL            46
#define SNMP_MGMTAPI_INVALID_SESSION        47
#define SNMP_MGMTAPI_INVALID_BUFFER         48

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// MGMT API control codes
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#define MGMCTL_SETAGENTPORT             0x01

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// MGMT API type definitions                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef PVOID LPSNMP_MGR_SESSION;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// MGMT API prototypes                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LPSNMP_MGR_SESSION
SNMP_FUNC_TYPE
SnmpMgrOpen(
    IN LPSTR lpAgentAddress,                // Name/address of target agent
    IN LPSTR lpAgentCommunity,              // Community for target agent
    IN INT   nTimeOut,                      // Comm time-out in milliseconds
    IN INT   nRetries                       // Comm time-out/retry count
    );

BOOL
SNMP_FUNC_TYPE
SnmpMgrCtl(
    LPSNMP_MGR_SESSION session,             // pointer to the MGMTAPI session
    DWORD              dwCtlCode,           // control code for the command requested
    LPVOID             lpvInBuffer,         // buffer with the input parameters for the operation
    DWORD              cbInBuffer,          // size of lpvInBuffer in bytes
    LPVOID             lpvOUTBuffer,        // buffer for all the output parameters of the command
    DWORD              cbOUTBuffer,         // size of lpvOUTBuffer
    LPDWORD            lpcbBytesReturned    // space used from lpvOutBuffer
    );

BOOL
SNMP_FUNC_TYPE
SnmpMgrClose(
    IN LPSNMP_MGR_SESSION session           // SNMP session pointer
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpMgrRequest(
    IN     LPSNMP_MGR_SESSION session,           // SNMP session pointer
    IN     BYTE               requestType,       // Get, GetNext, or Set
    IN OUT RFC1157VarBindList *variableBindings, // Varible bindings
       OUT AsnInteger         *errorStatus,      // Result error status
       OUT AsnInteger         *errorIndex        // Result error index
    );

BOOL
SNMP_FUNC_TYPE
SnmpMgrStrToOid(
    IN  LPSTR               string,         // OID string to be converted
    OUT AsnObjectIdentifier *oid            // OID internal representation
    );

BOOL
SNMP_FUNC_TYPE
SnmpMgrOidToStr(
    IN  AsnObjectIdentifier *oid,           // OID to be converted
    OUT LPSTR               *string         // OID string representation
    );

BOOL
SNMP_FUNC_TYPE
SnmpMgrTrapListen(
    OUT HANDLE *phTrapAvailable             // Event indicating trap available
    );

BOOL
SNMP_FUNC_TYPE
SnmpMgrGetTrap(
    OUT AsnObjectIdentifier *enterprise,         // Generating enterprise
    OUT AsnNetworkAddress   *IPAddress,          // Generating IP address
    OUT AsnInteger          *genericTrap,        // Generic trap type
    OUT AsnInteger          *specificTrap,       // Enterprise specific type
    OUT AsnTimeticks        *timeStamp,          // Time stamp
    OUT RFC1157VarBindList  *variableBindings    // Variable bindings
    );

BOOL
SNMP_FUNC_TYPE
SnmpMgrGetTrapEx(
    OUT AsnObjectIdentifier *enterprise,       // Generating enterprise
    OUT AsnNetworkAddress   *agentAddress,     // Generating agent addr
    OUT AsnNetworkAddress   *sourceAddress,    // Generating network addr
    OUT AsnInteger          *genericTrap,      // Generic trap type
    OUT AsnInteger          *specificTrap,     // Enterprise specific type
    OUT AsnOctetString      *community,        // Generating community
    OUT AsnTimeticks        *timeStamp,        // Time stamp
    OUT RFC1157VarBindList  *variableBindings  // Variable bindings
    );

#ifdef __cplusplus
}
#endif

#endif // _INC_MGMTAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mapiwin.h ===
/*
 *	M A P I W I N . H
 *
 *	Definitions used by the MAPI Development Team to aid in
 *	developing single-source service providers that run on
 *	both WIN32 and WIN16 platforms.
 *	There are three sections.
 *
 *	The first section defines how to call something that
 *	is available by different methods in WIN16 vs. WIN32.
 *	As such, they are totally new mechanisms.
 *
 *	The second section establishes things that are available
 *	AS-IS in one environment but we have to define for the
 *	other environment.
 *
 *	The third section simply defines a few conventions
 *	(simplifications) for common operations.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

/*
 *	Routines are included in the first section to manage per-instance
 *	global variables for DLLs. They assume that all of the DLL's
 *	per-instance global variables live in a single block of memory.
 *	Functions are provided to install and retrieve the correct block of
 *	memory for the current instance.
 *
 *	There are only two functions:
 *
 *		PvGetInstanceGlobals	Call this to get the address of the
 *								per-instance globals structure.
 *		ScSetinstanceGlobals	Call this to install the
 *								per-instance globals structure. It
 *								may fail if the number of instances
 *								exceeds a certain limit.
 *
 *	The caller is free to choose the name, size, and allocation
 *	method of the per-instance global variables structure.
 *
 *	The WIN32 implementation uses a pointer in the DLL's data
 *	segment. This assumes that the DLL gets a separate instance
 *	of the default data segment per calling process.
 *
 *	The WIN16 implementation uses a fixed array of pointers and a
 *	matching fixed array of keys unique to the calling process.
 */

/*
 *	The second section consists largely of Win32 file I/O functions
 *	that are not supported under Win16. These functions are
 *	implemented in mapiwin.c, using DOS calls. Most have limitations
 *	relative to their Win32 counterparts, which are spelled out in
 *	the comments to the source code.
 */

#ifndef __MAPIWIN_H__
#define __MAPIWIN_H__

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

#include "mapinls.h"

#ifdef __cplusplus
extern "C" {
#endif


/********************************/
/*	Our conventions for things	*/
/*	we choose to do differently	*/
/*	on WIN16 vs. WIN32.			*/
/********************************/

#ifdef	WIN16

#define	MULDIV(x,y,z)				MulDiv32(x,y,z)
#define IsBadReadPtr(lp,cb)			FBadReadPtr(lp,cb)

#define cInstMax					50
LPVOID FAR PASCAL	PvGetInstanceGlobals(void);
LONG FAR PASCAL		ScSetInstanceGlobals(LPVOID pv);
LONG FAR PASCAL		ScSetVerifyInstanceGlobals(LPVOID pv, DWORD dwPid);
LPVOID FAR PASCAL	PvGetVerifyInstanceGlobals(DWORD dwPid);
LPVOID FAR PASCAL	PvSlowGetInstanceGlobals(DWORD dwPid);
BOOL __export FAR PASCAL FCleanupInstanceGlobals(WORD, DWORD);

#elif defined(_MAC)	/* !WIN16 */

#define	MULDIV(x,y,z)				MulDiv(x,y,z)

LPVOID FAR PASCAL	PvGetInstanceGlobals(WORD wDataSet);
LONG FAR PASCAL		ScSetInstanceGlobals(LPVOID pv, WORD wDataSet);
LONG FAR PASCAL		ScSetVerifyInstanceGlobals(LPVOID pv, DWORD dwPid,
						WORD wDataSet);
LPVOID FAR PASCAL	PvGetVerifyInstanceGlobals(DWORD dwPid, DWORD wDataSet);
LPVOID FAR PASCAL	PvSlowGetInstanceGlobals(DWORD dwPid, DWORD wDataSet);
BOOL FAR PASCAL		FCleanupInstanceGlobals(WORD, DWORD);

#else	/* !WIN16 */

#define	MULDIV(x,y,z)				MulDiv(x,y,z)

extern LPVOID pinstX;
#define PvGetInstanceGlobals()					pinstX
#define ScSetInstanceGlobals(_pv)				(pinstX = _pv, 0)
#define PvGetVerifyInstanceGlobals(_pid)		pinstX
#define ScSetVerifyInstanceGlobals(_pv,_pid)	(pinstX = _pv, 0)
#define PvSlowGetInstanceGlobals(_pid)			pinstX

#endif	/* WIN16 */

#if defined(_WIN32) && !defined(_MAC)
#define szMAPIDLLSuffix		"32"
#elif defined(WIN16) || defined(DOS)
#define szMAPIDLLSuffix		""
#elif  defined(_MAC)
#define szMAPIDLLSuffix		"M"
#else
#error "Don't know the suffix for DLLs on this platform"
#endif

/********************************/
/*  Things missing from one		*/
/*	system-provided environment	*/
/*	or the other.				*/
/********************************/

#if !defined(_WIN32)
#define	ZeroMemory(pb,cb)			memset((pb),0,(cb))
#define FillMemory(pb,cb,b)			memset((pb),(b),(cb))
#define CopyMemory(pbDst,pbSrc,cb)	do								\
									{								\
										size_t _cb = (size_t)(cb);	\
										if (_cb)					\
											memcpy(pbDst,pbSrc,_cb);\
									} while (FALSE)
#define MoveMemory(pbDst,pbSrc,cb)	memmove((pbDst),(pbSrc),(cb))

#define UNALIGNED

#endif

#if defined(WIN16) || defined(_MAC)

#ifndef _MAC
#include <error.h>				/*	for GetLastError() */
#endif

typedef	int					INT;
typedef	unsigned long		ULONG;
typedef	short				SHORT;
typedef	unsigned short		USHORT;
typedef double 				LONGLONG;
typedef double 				DWORDLONG;
typedef unsigned char		UCHAR;
typedef unsigned char FAR*	PUCHAR;
typedef int					BOOL;


#ifndef _MAC
typedef char				BOOLEAN;

#ifndef _FILETIME_
#define _FILETIME_
typedef struct tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif		/* _FILETIME */

typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, FAR *LPSYSTEMTIME;

typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    CHAR StandardName[ 32 ];		/* was WCHAR */
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    CHAR DaylightName[ 32 ];		/* was WCHAR */
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, FAR *LPTIME_ZONE_INFORMATION;


#if defined(DOS) || defined(WIN16)
/* Simulate effect of afx header */
#define __T(x)		x
#define _T(x)		__T(x)
#define TEXT		_T
#endif

#define APIENTRY		WINAPI

#define	SetForegroundWindow			SetActiveWindow

#define wsprintfA					wsprintf
#define GetWindowsDirectoryA		GetWindowsDirectory
#define GetSystemDirectoryA			GetSystemDirectory
#define GetPrivateProfileStringA 	GetPrivateProfileString
#define GetPrivateProfileIntA		GetPrivateProfileInt
#define GetProfileStringA			GetProfileString
#define GetModuleFileNameA			GetModuleFileName
#define CharUpperBuffA				CharUpperBuff
#define LoadLibraryA				LoadLibrary
#define lstrcatA					lstrcat
#define RegisterWindowMessageA		RegisterWindowMessage
#define MAKEINTRESOURCEA			MAKEINTRESOURCE

#define WNDCLASSA					WNDCLASS									

#endif	/* !_MAC */

/* Synchronization */
#define InterlockedIncrement(plong)	(++(*(plong)))
#define InterlockedDecrement(plong) (--(*(plong)))

#ifndef CreateMutex
#define CreateMutexA	CreateMutex
#define CreateMutexW	CreateMutex
#define CreateMutex(pv, bool, sz)	(INVALID_HANDLE_VALUE)
#endif

#define WaitForSingleObject(hObj, dw)	((void)0)
#define ReleaseMutex(hObj)				((BOOL)1)
#define CloseMutexHandle(hObj)			TRUE

#define	CRITICAL_SECTION			ULONG
#define	InitializeCriticalSection(_pcs)	((void)0)
#define	DeleteCriticalSection(_pcs)		((void)0)
#define	EnterCriticalSection(_pcs)		((void)0)
#define	LeaveCriticalSection(_pcs)		((void)0)

#define MAX_PATH					260

#ifndef	_MAC
/*
 *	File Access Modes
 *
 *	The possible combination of file access modes as passed into
 *	the CreateFile() api map to OpenFile() as follows:
 *
 *	 GENERIC_READ						OPEN_ACCESS_READONLY
 *	 GENERIC_WRITE						OPEN_ACCESS_WRITEONLY
 *	 GENERIC_READ | GENERIC_WRITE		OPEN_ACCESS_READWRITE
 *
 *	 0									OPEN_SHARE_DENYREADWRITE
 *	 FILE_SHARE_READ					OPEN_SHARE_DENYWRITE
 *	 FILE_SHARE_WRITE					OPEN_SHARE_DENYREAD
 *	 FILE_SHARE_READ | FILE_SHARE_WRITE	OPEN_SHARE_DENYNONE
 *
 *	Due to the mappings we cannot pass them through directly,
 *	so we will have to use a conversion within APIs that test
 *	these bits.  It would be best to use the Win32 #defines
 *	for these flags and convert as needed in the APIs.
 */
#define GENERIC_READ				(0x80000000) /* from WINNT.H */
#define GENERIC_WRITE				(0x40000000) /* from WINNT.H */
#define FILE_SHARE_READ				(0x00000001) /* from WINNT.H */
#define FILE_SHARE_WRITE			(0x00000002) /* from WINNT.H */
#endif	/* _MAC */

#define FILE_FLAG_SEQUENTIAL_SCAN	0x08000000

#define CREATE_NEW          1
#define CREATE_ALWAYS       2
#define OPEN_EXISTING       3
#define OPEN_ALWAYS         4
#define TRUNCATE_EXISTING   5

#ifndef _MAC
#define INVALID_HANDLE_VALUE		((HANDLE)(-1))
#define DELETE						0x00010000L

#define FILE_BEGIN					0
#define FILE_CURRENT				1
#define FILE_END					2
#endif

#define FILE_ATTRIBUTE_READONLY         0x00000001
#define FILE_ATTRIBUTE_HIDDEN           0x00000002
#define FILE_ATTRIBUTE_SYSTEM           0x00000004
#define FILE_ATTRIBUTE_DIRECTORY        0x00000010
#define FILE_ATTRIBUTE_ARCHIVE          0x00000020
#define FILE_ATTRIBUTE_NORMAL           0x00000080
#define	FILE_ATTRIBUTE_TEMPORARY		0x00000100

#define FILE_FLAG_WRITE_THROUGH     0x80000000
#define FILE_FLAG_RANDOM_ACCESS     0x10000000

#ifndef _MAC
typedef struct _WIN32_FIND_DATA {
    DWORD		dwFileAttributes;
    FILETIME	ftCreationTime;
    FILETIME	ftLastAccessTime;
    FILETIME	ftLastWriteTime;
    DWORD		nFileSizeHigh;
    DWORD		nFileSizeLow;
    DWORD		dwReserved0;
    DWORD		dwReserved1;
    CHAR		cFileName[ MAX_PATH ];
    CHAR		cAlternateFileName[ 16 ];
} WIN32_FIND_DATA, *PWIN32_FIND_DATA, *LPWIN32_FIND_DATA;

#define TIME_ZONE_ID_INVALID		0xFFFFFFFF
#endif
#define TIME_ZONE_ID_UNKNOWN		0
#define TIME_ZONE_ID_STANDARD		1
#define TIME_ZONE_ID_DAYLIGHT		2



DWORD WINAPI	GetLastError(void);
DWORD WINAPI	GetFileAttributes(LPCSTR lpFileName);
DWORD WINAPI	GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
BOOL WINAPI		GetFileTime(HANDLE hFile, FILETIME FAR *lpftCreation,
				FILETIME FAR *lpftLastAccess, FILETIME FAR *lpftLastWrite);
BOOL WINAPI		SetFileTime(HANDLE hFile, const FILETIME FAR *lpftCreation,
				const FILETIME FAR *lpftLastAccess,
				const FILETIME FAR *lpftLastWrite);
#ifndef _MAC
/*  IsTask can crash - here's a safer one.  */
BOOL WINAPI		FIsTask(HTASK hTask);

HANDLE WINAPI	CreateFile(LPCSTR lpFileName, DWORD dwDesiredAccess,
				DWORD dwShareMode, LPVOID lpSecurityAttributes,
				DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes,
				HANDLE hTemplateFile);
BOOL WINAPI		ReadFile(HANDLE hFile, LPVOID lpBuffer,
				DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead,
				LPVOID lpOverlapped);
BOOL WINAPI		WriteFile(HANDLE hFile, LPCVOID lpBuffer,
				DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten,
				LPVOID lpOverlapped);
#endif
DWORD WINAPI	SetFilePointer(HANDLE hFile, LONG lDistanceToMove,
				LONG FAR *lpDistanceToMoveHigh, DWORD dwMoveMethod);
BOOL WINAPI		SetEndOfFile(HANDLE hFile);
BOOL WINAPI		CloseHandle(HANDLE hObject);
DWORD WINAPI	GetTempPath(DWORD nBufferLength, LPSTR lpBuffer);
UINT WINAPI		GetTempFileName32 (LPCSTR lpPathName, LPCSTR lpPrefixString,
				UINT uUnique, LPSTR lpTempFileName);
BOOL WINAPI		DeleteFile(LPCSTR lpFileName);
#ifndef _MAC
BOOL WINAPI		CreateDirectory(LPCSTR lpPathName, LPVOID lpSecurityAttributes);
#endif
BOOL WINAPI		RemoveDirectory(LPCSTR lpPathName);
BOOL WINAPI		CopyFile(LPCSTR szSrc, LPCSTR szDst, BOOL fFailIfExists);
BOOL WINAPI		MoveFile(LPCSTR lpExistingFileName, LPCSTR lpNewFileName);
HANDLE WINAPI	FindFirstFile(LPCSTR lpFileName, LPWIN32_FIND_DATA lpFindFileData);
BOOL WINAPI		FindNextFile(HANDLE hFindFile, LPWIN32_FIND_DATA lpFindFileData);
BOOL WINAPI		FindClose(HANDLE hFindFile);
DWORD WINAPI	GetFullPathName(LPCSTR lpFileName, DWORD nBufferLength,
			    LPSTR lpBuffer, LPSTR *lpFilePart);
void WINAPI		Sleep(DWORD dwMilliseconds);
LONG WINAPI		CompareFileTime(const FILETIME FAR *, const FILETIME FAR *);
BOOL WINAPI		LocalFileTimeToFileTime(const FILETIME FAR *, FILETIME FAR *);
BOOL WINAPI		FileTimeToLocalFileTime(const FILETIME FAR *, FILETIME FAR *);
BOOL WINAPI		FileTimeToSystemTime(const FILETIME FAR *, SYSTEMTIME FAR *);
BOOL WINAPI		SystemTimeToFileTime(const SYSTEMTIME FAR *, FILETIME FAR *);
void WINAPI		GetSystemTime(SYSTEMTIME FAR *);
void WINAPI		GetLocalTime(SYSTEMTIME FAR *);
BOOL WINAPI		FileTimeToDosDateTime(const FILETIME FAR * lpFileTime,
			    WORD FAR *lpFatDate, WORD FAR *lpFatTime);
BOOL WINAPI		DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime,
			    FILETIME FAR * lpFileTime);
DWORD WINAPI	GetTimeZoneInformation(
				LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
BOOL WINAPI		SetTimeZoneInformation(
				const TIME_ZONE_INFORMATION FAR *lpTimeZoneInformation);

DWORD WINAPI	GetCurrentProcessId(void);
long WINAPI		MulDiv32(long, long, long);
#ifndef _MAC
BOOL WINAPI		FBadReadPtr(const void FAR* lp, UINT cb);
#endif

#else	/* !WIN16 */

/* Remaps GetTempFileName32() to the real 32bit version */

#define GetTempFileName32(_szPath,_szPfx,_n,_lpbuf)	GetTempFileName(_szPath,_szPfx,_n,_lpbuf)

#define CloseMutexHandle	CloseHandle

#endif	/* !WIN16 */


#ifdef _MAC
#define	CRITICAL_SECTION			ULONG
#define	InitializeCriticalSection(_pcs)	((void)0)
#define	DeleteCriticalSection(_pcs)		((void)0)
#define	EnterCriticalSection(_pcs)		((void)0)
#define	LeaveCriticalSection(_pcs)		((void)0)
#endif

/********************************/
/*	Our private conventions		*/
/*	(common to WIN16/WIN32)		*/
/********************************/

#define	Cbtszsize(_a)	((lstrlen(_a)+1)*sizeof(TCHAR))
#define	CbtszsizeA(_a)	((lstrlenA(_a) + 1))
#define	CbtszsizeW(_a)	((lstrlenW(_a) + 1) * sizeof(WCHAR))
#define HexCchOf(_s)	(sizeof(_s)*2+1)
#define HexSizeOf(_s)	(HexCchOf(_s)*sizeof(TCHAR))

BOOL WINAPI IsBadBoundedStringPtr(const void FAR* lpsz, UINT cchMax);

#ifdef __cplusplus
}
#endif

#endif /* __MAPIWIN_H__ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mapispi.h ===
/*
 *	M A P I S P I . H
 *
 *  Defines the calls and structures exchanged between MAPI or the spooler
 *  and the MAPI service providers
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPISPI_H
#define MAPISPI_H
#if _MSC_VER > 1000
#pragma once
#endif

/* Include common MAPI header files if they haven't been already. */
#ifndef MAPIDEFS_H
#include <mapidefs.h>
#endif
#ifndef MAPICODE_H
#include <mapicode.h>
#endif
#ifndef MAPIGUID_H
#include <mapiguid.h>
#endif
#ifndef MAPITAGS_H
#include <mapitags.h>
#endif

#if defined (WIN16) || defined (DOS) || defined (DOS16)
#include <storage.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*	The MAPI SPI has a version number.  MAPIX.DLL knows and supports
 *	one or more versions of the SPI.  Each provider supports one or
 *	more versions of the SPI.  Checks are performed in both MAPIX.DLL
 *	and in the provider to ensure that they agree to use exactly one
 *	version of the MAPI SPI.
 *
 *	The SPI version number is composed of a major (8-bit) version,
 *	minor (8-bit) version, and micro (16-bit) version.  The first
 *	retail ship of MAPI 1.0 is expected to be version 1.0.0.
 *	The major version number changes rarely.
 *	The minor version number changes opon each retail ship of
 *	MAPI if the SPI has been modified.
 *	The micro version number changes internally at Microsoft
 *	during development of MAPI.
 *
 *	The version of the SPI documented by this set of header files
 *	is ALWAYS known as "CURRENT_SPI_VERSION".  If you write a
 *	service provider, and get a new set of header files, and update
 *	your code to the new interface, you'll be at the "current" version.
 */
#define	CURRENT_SPI_VERSION	0x00010010L

/*	Here are some well-known SPI version numbers:
 *	(These will eventually be useful for provider-writers who
 *	might choose to make provider DLLs that support more than
 *	one version of the MAPI SPI.
 */
#define	PDK1_SPI_VERSION	0x00010000L	/* 0.1.0  MAPI PDK1 Spring 1993 */

#define	PDK2_SPI_VERSION	0x00010008L /* 0.1.8  MAPI PDK2 Spring 1994 */

#define PDK3_SPI_VERSION	0x00010010L /* 0.1.16 MAPI PDK3 Fall 1994   */

/*
 * Forward declaration of interface pointers specific to the service
 * provider interface.
 */
DECLARE_MAPI_INTERFACE_PTR(IMAPISupport, LPMAPISUP);

/* IMAPISupport Interface -------------------------------------------------- */

/* Notification key structure for the MAPI notification engine */

typedef struct
{
	ULONG		cb;				/* How big the key is */
	BYTE		ab[MAPI_DIM];	/* Key contents */
} NOTIFKEY, FAR * LPNOTIFKEY;

#define CbNewNOTIFKEY(_cb)		(offsetof(NOTIFKEY,ab) + (_cb))
#define CbNOTIFKEY(_lpkey)		(offsetof(NOTIFKEY,ab) + (_lpkey)->cb)
#define SizedNOTIFKEY(_cb, _name) \
	struct _NOTIFKEY_ ## _name \
{ \
	ULONG		cb; \
	BYTE		ab[_cb]; \
} _name


/* For Subscribe() */

#define NOTIFY_SYNC				((ULONG) 0x40000000)

/* For Notify() */

#define NOTIFY_CANCELED			((ULONG) 0x80000000)


/* From the Notification Callback function (well, this is really a ulResult) */

#define CALLBACK_DISCONTINUE	((ULONG) 0x80000000)

/* For Transport's SpoolerNotify() */

#define NOTIFY_NEWMAIL			((ULONG) 0x00000001)
#define NOTIFY_READYTOSEND		((ULONG) 0x00000002)
#define NOTIFY_SENTDEFERRED		((ULONG) 0x00000004)
#define NOTIFY_CRITSEC			((ULONG) 0x00001000)
#define NOTIFY_NONCRIT			((ULONG) 0x00002000)
#define NOTIFY_CONFIG_CHANGE	((ULONG) 0x00004000)
#define NOTIFY_CRITICAL_ERROR	((ULONG) 0x10000000)

/* For Message Store's SpoolerNotify() */

#define NOTIFY_NEWMAIL_RECEIVED	((ULONG) 0x20000000)

/* For ModifyStatusRow() */

#define	STATUSROW_UPDATE		((ULONG) 0x10000000)

/* For IStorageFromStream() */

#define STGSTRM_RESET			((ULONG) 0x00000000)
#define STGSTRM_CURRENT			((ULONG) 0x10000000)
#define STGSTRM_MODIFY			((ULONG) 0x00000002)
#define STGSTRM_CREATE			((ULONG) 0x00001000)

/* For GetOneOffTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/* For CreateOneOff() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */
/****** MAPI_SEND_NO_RICH_INFO	((ULONG) 0x00010000) */

/* For ReadReceipt() */
#define MAPI_NON_READ			((ULONG) 0x00000001)

/* For DoConfigPropSheet() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/* Preprocessor calls: */

/* PreprocessMessage, first ordinal in RegisterPreprocessor(). */

typedef HRESULT (STDMETHODCALLTYPE PREPROCESSMESSAGE)(
					LPVOID lpvSession,
					LPMESSAGE lpMessage,
					LPADRBOOK lpAdrBook,
					LPMAPIFOLDER lpFolder,
					LPALLOCATEBUFFER AllocateBuffer,
					LPALLOCATEMORE AllocateMore,
					LPFREEBUFFER FreeBuffer,
					ULONG FAR *lpcOutbound,
					LPMESSAGE FAR * FAR *lpppMessage,
					LPADRLIST FAR *lppRecipList);

/* RemovePreprocessInfo, second ordinal in RegisterPreprocessor(). */

typedef HRESULT (STDMETHODCALLTYPE REMOVEPREPROCESSINFO)(LPMESSAGE lpMessage);

/* Function pointer for GetReleaseInfo */

#define MAPI_IMAPISUPPORT_METHODS1(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetMemAllocRoutines)										\
		(THIS_	LPALLOCATEBUFFER FAR *		lpAllocateBuffer,			\
				LPALLOCATEMORE FAR *		lpAllocateMore,				\
				LPFREEBUFFER FAR *			lpFreeBuffer) IPURE;		\
	MAPIMETHOD(Subscribe)												\
		(THIS_	LPNOTIFKEY					lpKey,						\
				ULONG						ulEventMask,				\
				ULONG						ulFlags,					\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unsubscribe)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(Notify)													\
		(THIS_	LPNOTIFKEY					lpKey,						\
				ULONG						cNotification,				\
				LPNOTIFICATION				lpNotifications,			\
				ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(ModifyStatusRow)											\
		(THIS_	ULONG						cValues,					\
				LPSPropValue				lpColumnVals,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(OpenProfileSection)										\
		(THIS_	LPMAPIUID					lpUid,						\
				ULONG						ulFlags,					\
				LPPROFSECT FAR *			lppProfileObj) IPURE;		\
	MAPIMETHOD(RegisterPreprocessor)									\
		(THIS_	LPMAPIUID					lpMuid,						\
				LPTSTR						lpszAdrType,				\
				LPTSTR						lpszDLLName,				\
				LPSTR	/* String8! */		lpszPreprocess,				\
				LPSTR	/* String8! */		lpszRemovePreprocessInfo,	\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(NewUID)													\
		(THIS_	LPMAPIUID					lpMuid) IPURE;				\
	MAPIMETHOD(MakeInvalid)												\
		(THIS_	ULONG						ulFlags,					\
				LPVOID						lpObject,					\
				ULONG						ulRefCount,					\
				ULONG						cMethods) IPURE;			\

#define MAPI_IMAPISUPPORT_METHODS2(IPURE)								\
	MAPIMETHOD(SpoolerYield)											\
		(THIS_	ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SpoolerNotify)											\
		(THIS_	ULONG						ulFlags,					\
				LPVOID						lpvData) IPURE;				\
	MAPIMETHOD(CreateOneOff)											\
		(THIS_	LPTSTR						lpszName,					\
				LPTSTR						lpszAdrType,				\
				LPTSTR						lpszAddress,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(SetProviderUID)											\
		(THIS_	LPMAPIUID					lpProviderID,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntry1,					\
				LPENTRYID					lpEntry1,					\
				ULONG						cbEntry2,					\
				LPENTRYID					lpEntry2,					\
				ULONG						ulCompareFlags,				\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(OpenTemplateID)											\
		(THIS_	ULONG						cbTemplateID,				\
				LPENTRYID					lpTemplateID,				\
				ULONG						ulTemplateFlags,			\
				LPMAPIPROP					lpMAPIPropData,				\
				LPCIID						lpInterface,				\
				LPMAPIPROP FAR *			lppMAPIPropNew,				\
				LPMAPIPROP					lpMAPIPropSibling) IPURE;	\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulOpenFlags,				\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(GetOneOffTable)											\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(Address)													\
		(THIS_	ULONG FAR *					lpulUIParam,				\
				LPADRPARM					lpAdrParms,					\
				LPADRLIST FAR *				lppAdrList) IPURE;			\
	MAPIMETHOD(Details)													\
		(THIS_	ULONG FAR *					lpulUIParam,				\
				LPFNDISMISS					lpfnDismiss,				\
				LPVOID						lpvDismissContext,			\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPFNBUTTON					lpfButtonCallback,			\
				LPVOID						lpvButtonContext,			\
				LPTSTR						lpszButtonText,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(NewEntry)												\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				ULONG						cbEIDContainer,				\
				LPENTRYID					lpEIDContainer,				\
				ULONG						cbEIDNewEntryTpl,			\
				LPENTRYID					lpEIDNewEntryTpl,			\
				ULONG FAR *					lpcbEIDNewEntry,			\
				LPENTRYID FAR *				lppEIDNewEntry) IPURE;		\
	MAPIMETHOD(DoConfigPropsheet)										\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				LPTSTR						lpszTitle,					\
				LPMAPITABLE					lpDisplayTable,				\
				LPMAPIPROP					lpCOnfigData,				\
				ULONG						ulTopPage) IPURE;			\
	MAPIMETHOD(CopyMessages)											\
		(THIS_	LPCIID						lpSrcInterface,				\
				LPVOID						lpSrcFolder,				\
				LPENTRYLIST					lpMsgList,					\
				LPCIID						lpDestInterface,			\
				LPVOID 						lpDestFolder,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(CopyFolder)												\
		(THIS_	LPCIID						lpSrcInterface,				\
				LPVOID						lpSrcFolder,				\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpDestInterface,			\
				LPVOID 						lpDestFolder,				\
				LPTSTR 						lszNewFolderName,			\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\

#define MAPI_IMAPISUPPORT_METHODS3(IPURE)								\
	MAPIMETHOD(DoCopyTo)												\
		(THIS_	LPCIID						lpSrcInterface,				\
				LPVOID						lpSrcObj,					\
				ULONG						ciidExclude,				\
				LPCIID						rgiidExclude,				\
				LPSPropTagArray				lpExcludeProps,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				LPCIID						lpDestInterface,			\
				LPVOID						lpDestObj,					\
				ULONG						ulFlags,					\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(DoCopyProps)												\
		(THIS_	LPCIID						lpSrcInterface,				\
				LPVOID						lpSrcObj,					\
				LPSPropTagArray				lpIncludeProps,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				LPCIID						lpDestInterface,			\
				LPVOID						lpDestObj,					\
				ULONG						ulFlags,					\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(DoProgressDialog)										\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				LPMAPIPROGRESS FAR *		lppProgress) IPURE;			\
	MAPIMETHOD(ReadReceipt)												\
		(THIS_	ULONG						ulFlags,					\
				LPMESSAGE					lpReadMessage,				\
				LPMESSAGE FAR *				lppEmptyMessage) IPURE;		\
	MAPIMETHOD(PrepareSubmit)											\
		(THIS_	LPMESSAGE					lpMessage,					\
				ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(ExpandRecips)											\
		(THIS_	LPMESSAGE					lpMessage,					\
				ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(UpdatePAB)												\
		(THIS_	ULONG						ulFlags,					\
				LPMESSAGE					lpMessage) IPURE;			\
	MAPIMETHOD(DoSentMail)												\
		(THIS_	ULONG						ulFlags,					\
				LPMESSAGE					lpMessage) IPURE;			\
	MAPIMETHOD(OpenAddressBook)											\
		(THIS_	LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPADRBOOK FAR *				lppAdrBook) IPURE;			\
	MAPIMETHOD(Preprocess)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(CompleteMsg)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(StoreLogoffTransports)									\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(StatusRecips)											\
		(THIS_	LPMESSAGE					lpMessage,					\
				LPADRLIST					lpRecipList) IPURE;			\
	MAPIMETHOD(WrapStoreEntryID)										\
		(THIS_	ULONG						cbOrigEntry,				\
				LPENTRYID					lpOrigEntry,				\
				ULONG FAR *					lpcbWrappedEntry,			\
				LPENTRYID FAR *				lppWrappedEntry) IPURE;		\
	MAPIMETHOD(ModifyProfile)											\
		(THIS_	ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(IStorageFromStream)										\
		(THIS_	LPUNKNOWN					lpUnkIn,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPSTORAGE FAR *				lppStorageOut) IPURE;		\
	MAPIMETHOD(GetSvcConfigSupportObj)									\
		(THIS_	ULONG						ulFlags,					\
				LPMAPISUP FAR *				lppSvcSupport) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMAPISupport
DECLARE_MAPI_INTERFACE_(IMAPISupport, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPISUPPORT_METHODS1(PURE)
	MAPI_IMAPISUPPORT_METHODS2(PURE)
	MAPI_IMAPISUPPORT_METHODS3(PURE)
};


/********************************************************************/
/*																	*/
/*							ADDRESS BOOK SPI						*/
/*																	*/
/********************************************************************/

/* Address Book Provider ------------------------------------------------- */

/* OpenTemplateID() */
#define FILL_ENTRY				((ULONG) 0x00000001)

/* For Logon() */

/*#define AB_NO_DIALOG			((ULONG) 0x00000001) in mapidefs.h */
/*#define MAPI_UNICODE			((ULONG) 0x80000000) in mapidefs.h */



DECLARE_MAPI_INTERFACE_PTR(IABProvider, LPABPROVIDER);
DECLARE_MAPI_INTERFACE_PTR(IABLogon,    LPABLOGON);

#define MAPI_IABPROVIDER_METHODS(IPURE)                                 \
	MAPIMETHOD(Shutdown)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
    MAPIMETHOD(Logon)                                                   \
        (THIS_  LPMAPISUP                   lpMAPISup,                  \
                ULONG                       ulUIParam,                  \
                LPTSTR                      lpszProfileName,            \
                ULONG                       ulFlags,                    \
				ULONG FAR *					lpulpcbSecurity,			\
				LPBYTE FAR *				lppbSecurity,				\
                LPMAPIERROR FAR *			lppMAPIError,				\
                LPABLOGON FAR *             lppABLogon) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IABProvider
DECLARE_MAPI_INTERFACE_(IABProvider, IUnknown)
{
	BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IABPROVIDER_METHODS(PURE)
};

/* For GetOneOffTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

#define MAPI_IABLOGON_METHODS(IPURE)                                    \
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(Logoff)													\
		(THIS_	ULONG						ulFlags) IPURE;				\
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(Advise)				                                    \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
    MAPIMETHOD(OpenStatusEntry)                                         \
        (THIS_  LPCIID                       lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPMAPISTATUS FAR *          lppEntry) IPURE;            \
    MAPIMETHOD(OpenTemplateID)                                          \
        (THIS_  ULONG                       cbTemplateID,               \
                LPENTRYID                   lpTemplateID,               \
                ULONG                       ulTemplateFlags,            \
                LPMAPIPROP                  lpMAPIPropData,             \
                LPCIID                       lpInterface,                \
                LPMAPIPROP FAR *            lppMAPIPropNew,             \
                LPMAPIPROP                  lpMAPIPropSibling) IPURE;   \
    MAPIMETHOD(GetOneOffTable)                                          \
        (THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *           lppTable) IPURE;            \
	MAPIMETHOD(PrepareRecips)											\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray				lpPropTagArray,				\
				LPADRLIST					lpRecipList) IPURE;			\

#undef       INTERFACE
#define      INTERFACE  IABLogon
DECLARE_MAPI_INTERFACE_(IABLogon, IUnknown)
{
	BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IABLOGON_METHODS(PURE)
};

typedef HRESULT (STDMAPIINITCALLTYPE ABPROVIDERINIT)(
	HINSTANCE			hInstance,
	LPMALLOC			lpMalloc,
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPALLOCATEMORE 		lpAllocateMore,
	LPFREEBUFFER 		lpFreeBuffer,
    ULONG				ulFlags,
    ULONG				ulMAPIVer,
    ULONG FAR *			lpulProviderVer,
    LPABPROVIDER FAR *	lppABProvider
);

ABPROVIDERINIT ABProviderInit;



/********************************************************************/
/*																	*/
/*							TRANSPORT SPI							*/
/*																	*/
/********************************************************************/

/* For DeinitTransport */

#define	DEINIT_NORMAL				((ULONG) 0x00000001)
#define	DEINIT_HURRY				((ULONG) 0x80000000)

/* For TransportLogon */

/* Flags that the Spooler may pass to the transport: */

#define LOGON_NO_DIALOG				((ULONG) 0x00000001)
#define	LOGON_NO_CONNECT			((ULONG) 0x00000004)
#define	LOGON_NO_INBOUND			((ULONG) 0x00000008)
#define	LOGON_NO_OUTBOUND			((ULONG) 0x00000010)
/*#define MAPI_UNICODE				((ULONG) 0x80000000) in mapidefs.h */

/* Flags that the transport may pass to the Spooler: */

#define	LOGON_SP_IDLE				((ULONG) 0x00010000)
#define	LOGON_SP_POLL				((ULONG) 0x00020000)
#define	LOGON_SP_RESOLVE			((ULONG) 0x00040000)


DECLARE_MAPI_INTERFACE_PTR(IXPProvider, LPXPPROVIDER);
DECLARE_MAPI_INTERFACE_PTR(IXPLogon, LPXPLOGON);

#define MAPI_IXPPROVIDER_METHODS(IPURE)									\
	MAPIMETHOD(Shutdown)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(TransportLogon)											\
		(THIS_	LPMAPISUP					lpMAPISup,					\
				ULONG						ulUIParam,					\
				LPTSTR						lpszProfileName,			\
				ULONG FAR *					lpulFlags,					\
                LPMAPIERROR FAR *			lppMAPIError,				\
				LPXPLOGON FAR *				lppXPLogon) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IXPProvider
DECLARE_MAPI_INTERFACE_(IXPProvider, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IXPPROVIDER_METHODS(PURE)
};

/* OptionData returned from call to RegisterOptions */

#define OPTION_TYPE_RECIPIENT		((ULONG) 0x00000001)
#define OPTION_TYPE_MESSAGE			((ULONG) 0x00000002)

typedef struct _OPTIONDATA
{
	ULONG			ulFlags;		/* MAPI_RECIPIENT, MAPI_MESSAGE */
	LPGUID			lpRecipGUID;	/* Same as returned by AddressTypes() */
	LPTSTR			lpszAdrType;	/* Same as returned by AddressTypes() */
	LPTSTR			lpszDLLName;	/* Options DLL */
	ULONG			ulOrdinal;		/* Ordinal in that DLL */
	ULONG			cbOptionsData;	/* Count of bytes in lpbOptionsData */
	LPBYTE			lpbOptionsData;	/* Providers per [recip|message] option data */
	ULONG			cOptionsProps;	/* Count of Options default prop values */
	LPSPropValue	lpOptionsProps;	/* Default Options property values */
} OPTIONDATA, FAR *LPOPTIONDATA;

typedef SCODE (STDMAPIINITCALLTYPE OPTIONCALLBACK)(
			HINSTANCE			hInst,
			LPMALLOC			lpMalloc,
			ULONG				ulFlags,
			ULONG				cbOptionData,
			LPBYTE				lpbOptionData,
			LPMAPISUP			lpMAPISup,
			LPMAPIPROP			lpDataSource,
			LPMAPIPROP FAR *	lppWrappedSource,
            LPMAPIERROR FAR *	lppMAPIError);

/* For XP_AddressTypes */

/*#define MAPI_UNICODE				((ULONG) 0x80000000) in mapidefs.h */

/* For XP_RegisterRecipOptions */

/*#define MAPI_UNICODE				((ULONG) 0x80000000) in mapidefs.h */

/* For XP_RegisterMessageOptions */

/*#define MAPI_UNICODE				((ULONG) 0x80000000) in mapidefs.h */

/* For TransportNotify */

#define NOTIFY_ABORT_DEFERRED		((ULONG) 0x40000000)
#define NOTIFY_CANCEL_MESSAGE		((ULONG) 0x80000000)
#define NOTIFY_BEGIN_INBOUND		((ULONG) 0x00000001)
#define NOTIFY_END_INBOUND			((ULONG) 0x00010000)
#define NOTIFY_BEGIN_OUTBOUND		((ULONG) 0x00000002)
#define NOTIFY_END_OUTBOUND			((ULONG) 0x00020000)
#define NOTIFY_BEGIN_INBOUND_FLUSH	((ULONG) 0x00000004)
#define NOTIFY_END_INBOUND_FLUSH	((ULONG) 0x00040000)
#define NOTIFY_BEGIN_OUTBOUND_FLUSH	((ULONG) 0x00000008)
#define NOTIFY_END_OUTBOUND_FLUSH	((ULONG) 0x00080000)

/* For TransportLogoff */

#define	LOGOFF_NORMAL				((ULONG) 0x00000001)
#define LOGOFF_HURRY				((ULONG) 0x80000000)

/* For SubmitMessage */

#define BEGIN_DEFERRED				((ULONG) 0x00000001)

/* For EndMessage */

/* Flags that the Spooler may pass to the Transport: */

/* Flags that the transport may pass to the Spooler: */

#define END_RESEND_NOW				((ULONG) 0x00010000)
#define END_RESEND_LATER			((ULONG) 0x00020000)
#define END_DONT_RESEND				((ULONG) 0x00040000)

#define MAPI_IXPLOGON_METHODS(IPURE)									\
	MAPIMETHOD(AddressTypes)											\
		(THIS_	ULONG FAR *					lpulFlags,					\
				ULONG FAR *					lpcAdrType,					\
				LPTSTR FAR * FAR *			lpppAdrTypeArray,			\
				ULONG FAR *					lpcMAPIUID,					\
				LPMAPIUID FAR * FAR *		lpppUIDArray) IPURE;		\
	MAPIMETHOD(RegisterOptions)											\
		(THIS_	ULONG FAR *					lpulFlags,					\
				ULONG FAR *					lpcOptions,					\
				LPOPTIONDATA FAR *			lppOptions) IPURE;			\
	MAPIMETHOD(TransportNotify)											\
		(THIS_	ULONG FAR *					lpulFlags,					\
				LPVOID FAR *				lppvData) IPURE;			\
	MAPIMETHOD(Idle)													\
		(THIS_	ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(TransportLogoff)											\
		(THIS_	ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SubmitMessage)											\
		(THIS_	ULONG						ulFlags,					\
				LPMESSAGE					lpMessage,					\
				ULONG FAR *					lpulMsgRef,					\
				ULONG FAR *					lpulReturnParm) IPURE;		\
	MAPIMETHOD(EndMessage)												\
		(THIS_	ULONG						ulMsgRef,					\
				ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(Poll)													\
		(THIS_	ULONG FAR *					lpulIncoming) IPURE;		\
	MAPIMETHOD(StartMessage)											\
		(THIS_	ULONG						ulFlags,					\
				LPMESSAGE					lpMessage,					\
				ULONG FAR *					lpulMsgRef) IPURE;			\
    MAPIMETHOD(OpenStatusEntry)                                         \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPMAPISTATUS FAR *          lppEntry) IPURE;            \
	MAPIMETHOD(ValidateState)											\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(FlushQueues)												\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						cbTargetTransport,			\
				LPENTRYID					lpTargetTransport,			\
				ULONG						ulFlags) IPURE;				\

#undef       INTERFACE
#define      INTERFACE  IXPLogon
DECLARE_MAPI_INTERFACE_(IXPLogon, IUnknown)
{
	BEGIN_INTERFACE	
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IXPLOGON_METHODS(PURE)
};


/* Transport Provider Entry Point */

typedef HRESULT (STDMAPIINITCALLTYPE XPPROVIDERINIT)(
	HINSTANCE			hInstance,
	LPMALLOC			lpMalloc,
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPALLOCATEMORE 		lpAllocateMore,
	LPFREEBUFFER 		lpFreeBuffer,
	ULONG				ulFlags,
	ULONG				ulMAPIVer,
	ULONG FAR *			lpulProviderVer,
	LPXPPROVIDER FAR *	lppXPProvider);

XPPROVIDERINIT XPProviderInit;

/********************************************************************/
/*																	*/
/*							MESSAGE STORE SPI						*/
/*																	*/
/********************************************************************/

/* Flags and enums */

/* For Logon() */

/*#define MAPI_UNICODE			((ULONG) 0x80000000) in mapidefs.h */
/*#define MDB_NO_DIALOG			((ULONG) 0x00000001) in mapidefs.h */
/*#define MDB_WRITE				((ULONG) 0x00000004) in mapidefs.h */
/*#define MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) in mapidefs.h */
/*#define MDB_TEMPORARY			((ULONG) 0x00000020) in mapidefs.h */
/*#define MDB_NO_MAIL			((ULONG) 0x00000080) in mapidefs.h */

/* For SpoolerLogon() */

/*#define MAPI_UNICODE			((ULONG) 0x80000000) in mapidefs.h */
/*#define MDB_NO_DIALOG			((ULONG) 0x00000001) in mapidefs.h */
/*#define MDB_WRITE				((ULONG) 0x00000004) in mapidefs.h */
/*#define MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) in mapidefs.h */

/* GetCredentials, SetCredentials */

#define LOGON_SP_TRANSPORT		((ULONG) 0x00000001)
#define LOGON_SP_PROMPT			((ULONG) 0x00000002)
#define LOGON_SP_NEWPW			((ULONG) 0x00000004)
#define LOGON_CHANGED			((ULONG) 0x00000008)

/* DoMCDialog */

#define DIALOG_FOLDER			((ULONG) 0x00000001)
#define DIALOG_MESSAGE			((ULONG) 0x00000002)
#define DIALOG_PROP				((ULONG) 0x00000004)
#define DIALOG_ATTACH			((ULONG) 0x00000008)

#define DIALOG_MOVE				((ULONG) 0x00000010)
#define DIALOG_COPY				((ULONG) 0x00000020)
#define DIALOG_DELETE			((ULONG) 0x00000040)

#define DIALOG_ALLOW_CANCEL		((ULONG) 0x00000080)
#define DIALOG_CONFIRM_CANCEL	((ULONG) 0x00000100)

/* ExpandRecips */

#define NEEDS_PREPROCESSING		((ULONG) 0x00000001)
#define NEEDS_SPOOLER			((ULONG) 0x00000002)

/* PrepareSubmit */

#define CHECK_SENDER			((ULONG) 0x00000001)
#define NON_STANDARD			((ULONG) 0x00010000)


DECLARE_MAPI_INTERFACE_PTR(IMSLogon, LPMSLOGON);
DECLARE_MAPI_INTERFACE_PTR(IMSProvider, LPMSPROVIDER);

/* Message Store Provider Interface (IMSPROVIDER) */

#define MAPI_IMSPROVIDER_METHODS(IPURE)									\
	MAPIMETHOD(Shutdown)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(Logon)													\
		(THIS_	LPMAPISUP					lpMAPISup,					\
				ULONG						ulUIParam,					\
				LPTSTR						lpszProfileName,			\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulFlags,					\
				LPCIID						lpInterface,				\
				ULONG FAR *					lpcbSpoolSecurity,			\
				LPBYTE FAR *				lppbSpoolSecurity,			\
                LPMAPIERROR FAR *			lppMAPIError,				\
				LPMSLOGON FAR *				lppMSLogon,					\
				LPMDB FAR *					lppMDB) IPURE;				\
	MAPIMETHOD(SpoolerLogon)											\
		(THIS_	LPMAPISUP					lpMAPISup,					\
				ULONG						ulUIParam,					\
				LPTSTR						lpszProfileName,			\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulFlags,					\
				LPCIID						lpInterface,				\
				ULONG						cbSpoolSecurity,			\
				LPBYTE						lpbSpoolSecurity,			\
                LPMAPIERROR FAR *			lppMAPIError,				\
				LPMSLOGON FAR *				lppMSLogon,					\
				LPMDB FAR *					lppMDB) IPURE;				\
	MAPIMETHOD(CompareStoreIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IMSProvider
DECLARE_MAPI_INTERFACE_(IMSProvider, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMSPROVIDER_METHODS(PURE)
};

/* The MSLOGON object is returned by the Logon() method of the
 * MSPROVIDER interface.  This object is for use by MAPIX.DLL.
 */
#define MAPI_IMSLOGON_METHODS(IPURE)									\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(Logoff)													\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(OpenStatusEntry)											\
		(THIS_	LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPVOID FAR *				lppEntry) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IMSLogon
DECLARE_MAPI_INTERFACE_(IMSLogon, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMSLOGON_METHODS(PURE)
};

/* Message Store Provider Entry Point */

typedef HRESULT (STDMAPIINITCALLTYPE MSPROVIDERINIT)(
	HINSTANCE				hInstance,
	LPMALLOC				lpMalloc,			/* AddRef() if you keep it */
	LPALLOCATEBUFFER		lpAllocateBuffer,	/* -> AllocateBuffer */
	LPALLOCATEMORE			lpAllocateMore, 	/* -> AllocateMore   */
	LPFREEBUFFER			lpFreeBuffer, 		/* -> FreeBuffer     */
	ULONG					ulFlags,
	ULONG					ulMAPIVer,
	ULONG FAR *				lpulProviderVer,
	LPMSPROVIDER FAR *		lppMSProvider
);

MSPROVIDERINIT MSProviderInit;


/********************************************************************/
/*																	*/
/*					  MESSAGE SERVICE CONFIGURATION					*/
/*																	*/
/********************************************************************/

/* Flags for service configuration entry point */

/* #define MAPI_UNICODE				 0x80000000 */
/* #define SERVICE_UI_ALWAYS  		 0x00000002	*/
/* #define SERVICE_UI_ALLOWED 		 0x00000010	*/
#define MSG_SERVICE_UI_READ_ONLY	 0x00000008	/* display parameters only */
#define SERVICE_LOGON_FAILED		 0x00000020 /* reconfigure provider */

/* Contexts for service configuration entry point */

#define MSG_SERVICE_INSTALL			0x00000001
#define MSG_SERVICE_CREATE			0x00000002
#define MSG_SERVICE_CONFIGURE		0x00000003
#define MSG_SERVICE_DELETE			0x00000004
#define MSG_SERVICE_UNINSTALL		0x00000005
#define MSG_SERVICE_PROVIDER_CREATE	0x00000006
#define MSG_SERVICE_PROVIDER_DELETE	0x00000007

/* Prototype for service configuration entry point */

typedef HRESULT (STDAPICALLTYPE MSGSERVICEENTRY)(
	HINSTANCE		hInstance,
	LPMALLOC		lpMalloc,
	LPMAPISUP		lpMAPISup,
	ULONG			ulUIParam,
	ULONG			ulFlags,
	ULONG			ulContext,
	ULONG			cValues,
	LPSPropValue	lpProps,
	LPPROVIDERADMIN lpProviderAdmin,
	LPMAPIERROR FAR *lppMapiError
);
typedef MSGSERVICEENTRY FAR *LPMSGSERVICEENTRY;


#ifdef __cplusplus
}
#endif

#endif /* MAPISPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mapiutil.h ===
/*
 *	M A P I U T I L . H
 *
 *  Definitions and prototypes for utility functions provided by MAPI
 *  in MAPI[xx].DLL.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MAPIUTIL_H_
#define _MAPIUTIL_H_

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MAPIX_H
#include <mapix.h>
#endif

#ifdef WIN16
#include <storage.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif


/* IMAPITable in memory */

/* ITableData Interface ---------------------------------------------------- */

DECLARE_MAPI_INTERFACE_PTR(ITableData, LPTABLEDATA);

typedef void (STDAPICALLTYPE CALLERRELEASE)(
	ULONG		ulCallerData,
	LPTABLEDATA	lpTblData,
	LPMAPITABLE	lpVue
);

#define MAPI_ITABLEDATA_METHODS(IPURE)									\
	MAPIMETHOD(HrGetView)												\
		(THIS_	LPSSortOrderSet				lpSSortOrderSet,			\
				CALLERRELEASE FAR *			lpfCallerRelease,			\
				ULONG						ulCallerData,				\
				LPMAPITABLE FAR *			lppMAPITable) IPURE;		\
	MAPIMETHOD(HrModifyRow)												\
		(THIS_	LPSRow) IPURE;											\
	MAPIMETHOD(HrDeleteRow)												\
		(THIS_	LPSPropValue				lpSPropValue) IPURE;		\
	MAPIMETHOD(HrQueryRow)												\
		(THIS_	LPSPropValue				lpsPropValue,				\
				LPSRow FAR *				lppSRow,					\
				ULONG FAR *					lpuliRow) IPURE;			\
	MAPIMETHOD(HrEnumRow)												\
		(THIS_	ULONG						ulRowNumber,				\
				LPSRow FAR *				lppSRow) IPURE;				\
	MAPIMETHOD(HrNotify)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cValues,					\
				LPSPropValue				lpSPropValue) IPURE;		\
	MAPIMETHOD(HrInsertRow)												\
		(THIS_	ULONG						uliRow,						\
				LPSRow						lpSRow) IPURE;				\
	MAPIMETHOD(HrModifyRows)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lpSRowSet) IPURE;			\
	MAPIMETHOD(HrDeleteRows)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lprowsetToDelete,			\
				ULONG FAR *					cRowsDeleted) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE	ITableData
DECLARE_MAPI_INTERFACE_(ITableData, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_ITABLEDATA_METHODS(PURE)
};


/* Entry Point for in memory ITable */


/*	CreateTable()
 *		Creates the internal memory structures and object handle
 *		to bring a new table into existence.
 *
 *	lpInterface
 *		Interface ID of the TableData object (IID_IMAPITableData)
 *
 *	lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *		Function addresses are provided by the caller so that
 *		this DLL allocates/frees memory appropriately.
 *	lpvReserved
 *		Reserved.  Should be NULL.
 *	ulTableType
 *		TBLTYPE_DYNAMIC, etc.  Visible to the calling application
 *		as part of the GetStatus return data on its views
 *	ulPropTagIndexColumn
 *		Index column for use when changing the data
 *	lpSPropTagArrayColumns
 *		Column proptags for the minimum set of columns in the table
 *	lppTableData
 *		Address of the pointer which will receive the TableData object
 */

STDAPI_(SCODE)
CreateTable( LPCIID					lpInterface,
			 ALLOCATEBUFFER FAR *	lpAllocateBuffer,
			 ALLOCATEMORE FAR *		lpAllocateMore,
			 FREEBUFFER FAR *		lpFreeBuffer,
			 LPVOID					lpvReserved,
			 ULONG					ulTableType,
			 ULONG					ulPropTagIndexColumn,
			 LPSPropTagArray		lpSPropTagArrayColumns,
			 LPTABLEDATA FAR *		lppTableData );

/*	HrGetView()
 *		This function obtains a new view on the underlying data
 *		which supports the IMAPITable interface.  All rows and columns
 *		of the underlying table data are initially visible
 *	lpSSortOrderSet
 *		if specified, results in the view being sorted
 *	lpfCallerRelease
 *		pointer to a routine to be called when the view is released, or
 *		NULL.
 *	ulCallerData
 *		arbitrary data the caller wants saved with this view and returned in
 *		the Release callback.
 */

/*	HrModifyRows()
 *		Add or modify a set of rows in the table data
 *	ulFlags
 *		Must be zero
 *	lpSRowSet
 *		Each row in the row set contains all the properties for one row
 *		in the table.  One of the properties must be the index column.  Any
 *		row in the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added.
 *		Each row in LPSRowSet MUST have a unique Index column!
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */

/*	HrModifyRow()
 *		Add or modify one row in the table
 *	lpSRow
 *		This row contains all the properties for one row in the table.
 *		One of the properties must be the index column.	 Any row in
 *		the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */

/*	HrDeleteRows()
 *		Delete a row in the table.
 *	ulFlags
 *		TAD_ALL_ROWS - Causes all rows in the table to be deleted
 *					   lpSRowSet is ignored in this case.
 *	lpSRowSet
 *		Each row in the row set contains all the properties for one row
 *		in the table.  One of the properties must be the index column.  Any
 *		row in the table with the same value for its index column is
 *		deleted.
 *		Each row in LPSRowSet MUST have a unique Index column!
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */
#define	TAD_ALL_ROWS	1

/*	HrDeleteRow()
 *		Delete a row in the table.
 *	lpSPropValue
 *		This property value specifies the row which has this value
 *		for its index column
 */

/*	HrQueryRow()
 *		Returns the values of a specified row in the table
 *	lpSPropValue
 *		This property value specifies the row which has this value
 *		for its index column
 *	lppSRow
 *		Address of where to return a pointer to an SRow
 *	lpuliRow
 *	  Address of where to return the row number. This can be NULL
 *	  if the row number is not required.
 *
 */

/*	HrEnumRow()
 *		Returns the values of a specific (numbered) row in the table
 *	ulRowNumber
 *		Indicates row number 0 to n-1
 *	lppSRow
 *		Address of where to return a pointer to a SRow
 */

/*	HrInsertRow()
 *		Inserts a row into the table.
 *	uliRow
 *		The row number before which this row will be inserted into the table.
 *		Row numbers can be from 0 to n where o to n-1 result in row insertion
 *	  a row number of n results in the row being appended to the table.
 *	lpSRow
 *		This row contains all the properties for one row in the table.
 *		One of the properties must be the index column.	 Any row in
 *		the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */


/* IMAPIProp in memory */

/* IPropData Interface ---------------------------------------------------- */


#define MAPI_IPROPDATA_METHODS(IPURE)									\
	MAPIMETHOD(HrSetObjAccess)											\
		(THIS_	ULONG						ulAccess) IPURE;			\
	MAPIMETHOD(HrSetPropAccess)											\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG FAR *					rgulAccess) IPURE;			\
	MAPIMETHOD(HrGetPropAccess)											\
		(THIS_	LPSPropTagArray FAR *		lppPropTagArray,			\
				ULONG FAR * FAR *			lprgulAccess) IPURE;		\
	MAPIMETHOD(HrAddObjProps)											\
		(THIS_	LPSPropTagArray				lppPropTagArray,			\
				LPSPropProblemArray FAR *	lprgulAccess) IPURE;


#undef		 INTERFACE
#define		 INTERFACE	IPropData
DECLARE_MAPI_INTERFACE_(IPropData, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IPROPDATA_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IPropData, LPPROPDATA);


/* Entry Point for in memory IMAPIProp */


/*	CreateIProp()
 *		Creates the internal memory structures and object handle
 *		to bring a new property interface into existance.
 *
 *	lpInterface
 *		Interface ID of the TableData object (IID_IMAPIPropData)
 *
 *	lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *		Function addresses are provided by the caller so that
 *		this DLL allocates/frees memory appropriately.
 *	lppPropData
 *		Address of the pointer which will receive the IPropData object
 *	lpvReserved
 *		Reserved.  Should be NULL.
 */

STDAPI_(SCODE)
CreateIProp( LPCIID					lpInterface,
			 ALLOCATEBUFFER FAR *	lpAllocateBuffer,
			 ALLOCATEMORE FAR *		lpAllocateMore,
			 FREEBUFFER FAR *		lpFreeBuffer,
			 LPVOID					lpvReserved,
			 LPPROPDATA FAR *		lppPropData );

/*
 *	Defines for prop/obj access
 */
#define IPROP_READONLY		((ULONG) 0x00000001)
#define IPROP_READWRITE		((ULONG) 0x00000002)
#define IPROP_CLEAN			((ULONG) 0x00010000)
#define IPROP_DIRTY			((ULONG) 0x00020000)

/*
 -	HrSetPropAccess
 -
 *	Sets access right attributes on a per-property basis.  By default,
 *	all properties are read/write.
 *
 */

/*
 -	HrSetObjAccess
 -
 *	Sets access rights for the object itself.  By default, the object has
 *	read/write access.
 *
 */

#ifndef NOIDLEENGINE

/* Idle time scheduler */

/*
 *	PRI
 *
 *	Priority of an idle task.
 *	The idle engine sorts tasks by priority, and the one with the higher
 *	value runs first. Within a priority level, the functions are called
 *	round-robin.
 */

#define PRILOWEST	-32768
#define PRIHIGHEST	32767
#define PRIUSER		0

/*
 *	IRO
 *
 *	Idle routine options.  This is a combined bit mask consisting of
 *	individual firo's.	Listed below are the possible bit flags.
 *
 *		FIROWAIT and FIROINTERVAL are mutually exclusive.
 *		If neither of the flags are specified, the default action
 *		is to ignore the time parameter of the idle function and
 *		call it as often as possible if firoPerBlock is not set;
 *		otherwise call it one time only during the idle block
 *		once the time constraint has been set. FIROINTERVAL
 *		is also incompatible with FIROPERBLOCK.
 *
 *		FIROWAIT		- time given is minimum idle time before calling
 *						  for the first time in the block of idle time,
 *						  afterwhich call as often as possible.
 *		FIROINTERVAL	- time given is minimum interval between each
 *						  successive call
 *		FIROPERBLOCK	- called only once per contiguous block of idle
 *						  time
 *		FIRODISABLED	- initially disabled when registered, the
 *						  default is to enable the function when registered.
 *		FIROONCEONLY	- called only one time by the scheduler and then
 *						  deregistered automatically.
 */

#define IRONULL			((USHORT) 0x0000)
#define FIROWAIT		((USHORT) 0x0001)
#define FIROINTERVAL	((USHORT) 0x0002)
#define FIROPERBLOCK	((USHORT) 0x0004)
#define FIRODISABLED	((USHORT) 0x0020)
#define FIROONCEONLY	((USHORT) 0x0040)

/*
 *	IRC
 *
 *	Idle routine change options. This is a combined bit mask consisting
 *	of individual firc's; each one identifies an aspect of the idle task
 *	that can be changed.
 *
 */

#define IRCNULL			((USHORT) 0x0000)
#define FIRCPFN			((USHORT) 0x0001)	/* change function pointer */
#define FIRCPV			((USHORT) 0x0002)	/* change parameter block  */
#define FIRCPRI			((USHORT) 0x0004)	/* change priority		   */
#define FIRCCSEC		((USHORT) 0x0008)	/* change time			   */
#define FIRCIRO			((USHORT) 0x0010)	/* change routine options  */

/*
 *	Type definition for idle functions.	 An idle function takes one
 *	parameter, an PV, and returns a BOOL value.
 */

typedef BOOL (STDAPICALLTYPE FNIDLE) (LPVOID);
typedef FNIDLE FAR *PFNIDLE;

/*
 *	FTG
 *
 *	Function Tag.  Used to identify a registered idle function.
 *
 */

typedef void FAR *FTG;
typedef FTG  FAR *PFTG;
#define FTGNULL			((FTG) NULL)

/*
 -	MAPIInitIdle/MAPIDeinitIdle
 -
 *	Purpose:
 *		Initialises the idle engine
 *		If the initialisation succeded, returns 0, else returns -1
 *
 *	Arguments:
 *		lpvReserved		Reserved, must be NULL.
 */

STDAPI_(LONG)
MAPIInitIdle (LPVOID lpvReserved);

STDAPI_(VOID)
MAPIDeinitIdle (VOID);


/*
 *	FtgRegisterIdleRoutine
 *
 *		Registers the function pfn of type PFNIDLE, i.e., (BOOL (*)(LPVOID))
 *		as an idle function.
 *
 *		The idle function will be called with the parameter pv by the
 *		idle engine. The function has initial priority priIdle,
 *		associated time csecIdle, and options iroIdle.
 */

STDAPI_(FTG)
FtgRegisterIdleRoutine (PFNIDLE lpfnIdle, LPVOID lpvIdleParam,
	short priIdle, ULONG csecIdle, USHORT iroIdle);

/*
 *	DeregisterIdleRoutine
 *
 *		Removes the given routine from the list of idle routines.
 *		The routine will not be called again.  It is the responsibility
 *		of the caller to clean up any data structures pointed to by the
 *		pvIdleParam parameter; this routine does not free the block.
 */

STDAPI_(void)
DeregisterIdleRoutine (FTG ftg);

/*
 *	EnableIdleRoutine
 *
 *		Enables or disables an idle routine.
 */

STDAPI_(void)
EnableIdleRoutine (FTG ftg, BOOL fEnable);

/*
 *	ChangeIdleRoutine
 *
 *		Changes some or all of the characteristics of the given idle
 *		function. The changes to make are indicated with flags in the
 *		ircIdle parameter.
 */

STDAPI_(void)
ChangeIdleRoutine (FTG ftg, PFNIDLE lpfnIdle, LPVOID lpvIdleParam,
	short priIdle, ULONG csecIdle, USHORT iroIdle, USHORT ircIdle);


#endif	/* ! NOIDLEENGINE */


/* IMalloc Utilities */

STDAPI_(LPMALLOC) MAPIGetDefaultMalloc(VOID);


/* StreamOnFile (SOF) */

/*
 *	Methods and #define's for implementing an OLE 2.0 storage stream
 *	(as defined in the OLE 2.0 specs) on top of a system file.
 */

#define SOF_UNIQUEFILENAME	((ULONG) 0x80000000)

STDMETHODIMP OpenStreamOnFile(
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPFREEBUFFER		lpFreeBuffer,
	ULONG				ulFlags,
	LPTSTR				lpszFileName,
	LPTSTR				lpszPrefix,
	LPSTREAM FAR *		lppStream);

typedef HRESULT (STDMETHODCALLTYPE FAR * LPOPENSTREAMONFILE) (
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPFREEBUFFER		lpFreeBuffer,
	ULONG				ulFlags,
	LPTSTR				lpszFileName,
	LPTSTR				lpszPrefix,
	LPSTREAM FAR *		lppStream);

#ifdef	_WIN32
#define OPENSTREAMONFILE "OpenStreamOnFile"
#endif
#ifdef	WIN16
#define OPENSTREAMONFILE "_OPENSTREAMONFILE"
#endif


/* Property interface utilities */

/*
 *	Copies a single SPropValue from Src to Dest.  Handles all the various
 *	types of properties and will link its allocations given the master
 *	allocation object and an allocate more function.
 */
STDAPI_(SCODE)
PropCopyMore( LPSPropValue		lpSPropValueDest,
			  LPSPropValue		lpSPropValueSrc,
			  ALLOCATEMORE *	lpfAllocMore,
			  LPVOID			lpvObject );

/*
 *	Returns the size in bytes of structure at lpSPropValue, including the
 *	Value.
 */
STDAPI_(ULONG)
UlPropSize(	LPSPropValue	lpSPropValue );


STDAPI_(BOOL)
FEqualNames( LPMAPINAMEID lpName1, LPMAPINAMEID lpName2 );

#if defined(_WIN32) && !defined(_WINNT) && !defined(_WIN95) && !defined(_MAC)
#define _WINNT
#endif

STDAPI_(void)
GetInstance(LPSPropValue lpPropMv, LPSPropValue lpPropSv, ULONG uliInst);

extern char rgchCsds[];
extern char rgchCids[];
extern char rgchCsdi[];
extern char rgchCidi[];

STDAPI_(BOOL)
FPropContainsProp( LPSPropValue	lpSPropValueDst,
				   LPSPropValue	lpSPropValueSrc,
				   ULONG		ulFuzzyLevel );

STDAPI_(BOOL)
FPropCompareProp( LPSPropValue	lpSPropValue1,
				  ULONG			ulRelOp,
				  LPSPropValue	lpSPropValue2 );

STDAPI_(LONG)
LPropCompareProp( LPSPropValue	lpSPropValueA,
				  LPSPropValue	lpSPropValueB );

STDAPI_(HRESULT)
HrAddColumns(	LPMAPITABLE			lptbl,
				LPSPropTagArray		lpproptagColumnsNew,
				LPALLOCATEBUFFER	lpAllocateBuffer,
				LPFREEBUFFER		lpFreeBuffer);

STDAPI_(HRESULT)
HrAddColumnsEx(	LPMAPITABLE			lptbl,
				LPSPropTagArray		lpproptagColumnsNew,
				LPALLOCATEBUFFER	lpAllocateBuffer,
				LPFREEBUFFER		lpFreeBuffer,
				void				(FAR *lpfnFilterColumns)(LPSPropTagArray ptaga));


/* Notification utilities */

/*
 *	Function that creates an advise sink object given a notification
 *	callback function and context.
 */

STDAPI
HrAllocAdviseSink( LPNOTIFCALLBACK lpfnCallback,
				   LPVOID lpvContext,
				   LPMAPIADVISESINK FAR *lppAdviseSink );


/*
 *	Wraps an existing advise sink with another one which guarantees
 *	that the original advise sink will be called in the thread on
 *	which it was created.
 */

STDAPI
HrThisThreadAdviseSink( LPMAPIADVISESINK lpAdviseSink,
						LPMAPIADVISESINK FAR *lppAdviseSink);



/*
 *	Allows a client and/or provider to force notifications
 *	which are currently queued in the MAPI notification engine
 *	to be dispatched without doing a message dispatch.
 */

STDAPI HrDispatchNotifications (ULONG ulFlags);


/* Service Provider Utilities */

/*
 *	Structures and utility function for building a display table
 *	from resources.
 */

typedef struct {
	ULONG			ulCtlType;			/* DTCT_LABEL, etc. */
	ULONG			ulCtlFlags;			/* DT_REQUIRED, etc. */
	LPBYTE			lpbNotif;			/*	pointer to notification data */
	ULONG			cbNotif;			/* count of bytes of notification data */
	LPTSTR			lpszFilter;			/* character filter for edit/combobox */
	ULONG			ulItemID;			/* to validate parallel dlg template entry */
	union {								/* ulCtlType discriminates */
		LPVOID			lpv;			/* Initialize this to avoid warnings */
		LPDTBLLABEL		lplabel;
		LPDTBLEDIT		lpedit;
		LPDTBLLBX		lplbx;
		LPDTBLCOMBOBOX	lpcombobox;
		LPDTBLDDLBX		lpddlbx;
		LPDTBLCHECKBOX	lpcheckbox;
		LPDTBLGROUPBOX	lpgroupbox;
		LPDTBLBUTTON	lpbutton;
		LPDTBLRADIOBUTTON lpradiobutton;
		LPDTBLMVLISTBOX	lpmvlbx;
		LPDTBLMVDDLBX	lpmvddlbx;
		LPDTBLPAGE		lppage;
	} ctl;
} DTCTL, FAR *LPDTCTL;

typedef struct {
	ULONG			cctl;
	LPTSTR			lpszResourceName;	/* as usual, may be an integer ID */
	union {								/* as usual, may be an integer ID */
		LPTSTR			lpszComponent;
		ULONG			ulItemID;
	};
	LPDTCTL			lpctl;
} DTPAGE, FAR *LPDTPAGE;



STDAPI
BuildDisplayTable(	LPALLOCATEBUFFER	lpAllocateBuffer,
					LPALLOCATEMORE		lpAllocateMore,
					LPFREEBUFFER		lpFreeBuffer,
					LPMALLOC			lpMalloc,
					HINSTANCE			hInstance,
					UINT				cPages,
					LPDTPAGE			lpPage,
					ULONG				ulFlags,
					LPMAPITABLE *		lppTable,
					LPTABLEDATA	*		lppTblData );


/* MAPI structure validation/copy utilities */

/*
 *	Validate, copy, and adjust pointers in MAPI structures:
 *		notification
 *		property value array
 *		option data
 */

STDAPI_(SCODE)
ScCountNotifications(int cNotifications, LPNOTIFICATION lpNotifications,
		ULONG FAR *lpcb);

STDAPI_(SCODE)
ScCopyNotifications(int cNotification, LPNOTIFICATION lpNotifications,
		LPVOID lpvDst, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocNotifications(int cNotification, LPNOTIFICATION lpNotifications,
		LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);


STDAPI_(SCODE)
ScCountProps(int cValues, LPSPropValue lpPropArray, ULONG FAR *lpcb);

STDAPI_(LPSPropValue)
LpValFindProp(ULONG ulPropTag, ULONG cValues, LPSPropValue lpPropArray);

STDAPI_(SCODE)
ScCopyProps(int cValues, LPSPropValue lpPropArray, LPVOID lpvDst,
		ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocProps(int cValues, LPSPropValue lpPropArray,
		LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScDupPropset(int cValues, LPSPropValue lpPropArray,
		LPALLOCATEBUFFER lpAllocateBuffer, LPSPropValue FAR *lppPropArray);


/* General utility functions */

/* Related to the OLE Component object model */

STDAPI_(ULONG)			UlAddRef(LPVOID lpunk);
STDAPI_(ULONG)			UlRelease(LPVOID lpunk);

/* Related to the MAPI interface */

STDAPI					HrGetOneProp(LPMAPIPROP lpMapiProp, ULONG ulPropTag,
						LPSPropValue FAR *lppProp);
STDAPI					HrSetOneProp(LPMAPIPROP lpMapiProp,
						LPSPropValue lpProp);
STDAPI_(BOOL)			FPropExists(LPMAPIPROP lpMapiProp, ULONG ulPropTag);
STDAPI_(LPSPropValue)	PpropFindProp(LPSPropValue lpPropArray, ULONG cValues,
						ULONG ulPropTag);
STDAPI_(void)			FreePadrlist(LPADRLIST lpAdrlist);
STDAPI_(void)			FreeProws(LPSRowSet lpRows);
STDAPI					HrQueryAllRows(LPMAPITABLE lpTable,
						LPSPropTagArray lpPropTags,
						LPSRestriction lpRestriction,
						LPSSortOrderSet lpSortOrderSet,
						LONG crowsMax,
						LPSRowSet FAR *lppRows);

/* Create or validate the IPM folder tree in a message store */

#define MAPI_FORCE_CREATE	1
#define MAPI_FULL_IPM_TREE	2

STDAPI					HrValidateIPMSubtree(LPMDB lpMDB, ULONG ulFlags,
						ULONG FAR *lpcValues, LPSPropValue FAR *lppValues,
						LPMAPIERROR FAR *lpperr);

/* Encoding and decoding strings */

STDAPI_(BOOL)			FBinFromHex(LPTSTR lpsz, LPBYTE lpb);
STDAPI_(SCODE)			ScBinFromHexBounded(LPTSTR lpsz, LPBYTE lpb, ULONG cb);
STDAPI_(void)			HexFromBin(LPBYTE lpb, int cb, LPTSTR lpsz);
STDAPI_(ULONG)			UlFromSzHex(LPCTSTR lpsz);

/* Encoding and decoding entry IDs */
STDAPI					HrEntryIDFromSz(LPTSTR lpsz, ULONG FAR *lpcb,
						LPENTRYID FAR *lppEntryID);
STDAPI					HrSzFromEntryID(ULONG cb, LPENTRYID lpEntryID,
						LPTSTR FAR *lpsz);
STDAPI					HrComposeEID(LPMAPISESSION lpSession,
						ULONG cbStoreRecordKey, LPBYTE lpStoreRecordKey,
						ULONG cbMsgEntryID, LPENTRYID lpMsgEntryID,
						ULONG FAR *lpcbEID, LPENTRYID FAR *lppEntryID);
STDAPI					HrDecomposeEID(LPMAPISESSION lpSession,
						ULONG cbEntryID, LPENTRYID lpEntryID,
						ULONG FAR *lpcbStoreEntryID,
						LPENTRYID FAR *lppStoreEntryID,
						ULONG FAR *lpcbMsgEntryID,
						LPENTRYID FAR *lppMsgEntryID);
STDAPI					HrComposeMsgID(LPMAPISESSION lpSession,
						ULONG cbStoreSearchKey, LPBYTE pStoreSearchKey,
						ULONG cbMsgEntryID, LPENTRYID lpMsgEntryID,
						LPTSTR FAR *lpszMsgID);
STDAPI					HrDecomposeMsgID(LPMAPISESSION lpSession,
						LPTSTR lpszMsgID,
						ULONG FAR *lpcbStoreEntryID,
						LPENTRYID FAR *lppStoreEntryID,
						ULONG FAR *lppcbMsgEntryID,
						LPENTRYID FAR *lppMsgEntryID);

/* C runtime substitutes */


STDAPI_(LPTSTR)			SzFindCh(LPCTSTR lpsz, USHORT ch);		/* strchr */
STDAPI_(LPTSTR)			SzFindLastCh(LPCTSTR lpsz, USHORT ch);	/* strrchr */
STDAPI_(LPTSTR)			SzFindSz(LPCTSTR lpsz, LPCTSTR lpszKey); /*strstr */
STDAPI_(unsigned int)	UFromSz(LPCTSTR lpsz);					/* atoi */

STDAPI_(SCODE)			ScUNCFromLocalPath(LPSTR lpszLocal, LPSTR lpszUNC,
						UINT cchUNC);
STDAPI_(SCODE)			ScLocalPathFromUNC(LPSTR lpszUNC, LPSTR lpszLocal,
						UINT cchLocal);

/* 64-bit arithmetic with times */

STDAPI_(FILETIME)		FtAddFt(FILETIME ftAddend1, FILETIME ftAddend2);
STDAPI_(FILETIME)		FtMulDwDw(DWORD ftMultiplicand, DWORD ftMultiplier);
STDAPI_(FILETIME)		FtMulDw(DWORD ftMultiplier, FILETIME ftMultiplicand);
STDAPI_(FILETIME)		FtSubFt(FILETIME ftMinuend, FILETIME ftSubtrahend);
STDAPI_(FILETIME)		FtNegFt(FILETIME ft);

/* Message composition */

STDAPI_(SCODE)			ScCreateConversationIndex (ULONG cbParent,
							LPBYTE lpbParent,
							ULONG FAR *	lpcbConvIndex,
							LPBYTE FAR * lppbConvIndex);

/* Store support */

STDAPI WrapStoreEntryID (ULONG ulFlags, LPTSTR lpszDLLName, ULONG cbOrigEntry,
	LPENTRYID lpOrigEntry, ULONG *lpcbWrappedEntry, LPENTRYID *lppWrappedEntry);

/* RTF Sync Utilities */

#define RTF_SYNC_RTF_CHANGED	((ULONG) 0x00000001)
#define RTF_SYNC_BODY_CHANGED	((ULONG) 0x00000002)

STDAPI_(HRESULT)
RTFSync (LPMESSAGE lpMessage, ULONG ulFlags, BOOL FAR * lpfMessageUpdated);


/* Flags for WrapCompressedRTFStream() */

/****** MAPI_MODIFY				((ULONG) 0x00000001) mapidefs.h */
/****** STORE_UNCOMPRESSED_RTF	((ULONG) 0x00008000) mapidefs.h */

STDAPI_(HRESULT)
WrapCompressedRTFStream (LPSTREAM lpCompressedRTFStream,
		ULONG ulFlags, LPSTREAM FAR * lpUncompressedRTFStream);

/* Storage on Stream */

#if defined(_WIN32) || defined(WIN16)
STDAPI_(HRESULT)
HrIStorageFromStream (LPUNKNOWN lpUnkIn,
	LPCIID lpInterface, ULONG ulFlags, LPSTORAGE FAR * lppStorageOut);
#endif


/*
 * Setup and cleanup.
 *
 * Providers never need to make these calls.
 *
 * Test applications and the like which do not call MAPIInitialize
 * may want to call them, so that the few utility functions which
 * need MAPI allocators (and do not ask for them explicitly)
 * will work.
 */

/* All flags are reserved for ScInitMapiUtil. */

STDAPI_(SCODE)			ScInitMapiUtil(ULONG ulFlags);
STDAPI_(VOID)			DeinitMapiUtil(VOID);


/*
 *	Entry point names.
 *	
 *	These are for new entry points defined since MAPI first shipped
 *	in Windows 95. Using these names in a GetProcAddress call makes
 *	it easier to write code which uses them optionally.
 */

#if defined (WIN16)
#define szHrDispatchNotifications "HrDispatchNotifications"
#elif defined (_WIN32) && defined (_X86_)
#define szHrDispatchNotifications "_HrDispatchNotifications@4"
#elif defined (_ALPHA_) || defined (_MIPS_) || defined (_PPC_) || defined(_IA64_)
#define szHrDispatchNotifications "HrDispatchNotifications"
#endif

typedef HRESULT (STDAPICALLTYPE DISPATCHNOTIFICATIONS)(ULONG ulFlags);
typedef DISPATCHNOTIFICATIONS FAR * LPDISPATCHNOTIFICATIONS;

#if defined (WIN16)
#define szScCreateConversationIndex "ScCreateConversationIndex"
#elif defined (_WIN32) && defined (_X86_)
#define szScCreateConversationIndex "_ScCreateConversationIndex@16"
#elif defined (_ALPHA_) || defined (_MIPS_) || defined (_PPC_) || defined(_IA64_)
#define szScCreateConversationIndex "ScCreateConversationIndex"
#endif

typedef SCODE (STDAPICALLTYPE CREATECONVERSATIONINDEX)(ULONG cbParent,
	LPBYTE lpbParent, ULONG FAR *lpcbConvIndex, LPBYTE FAR *lppbConvIndex);
typedef CREATECONVERSATIONINDEX FAR *LPCREATECONVERSATIONINDEX;

#ifdef __cplusplus
}
#endif

#endif /* _MAPIUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mapival.h ===
/*
 *	M A P I V A L . H
 *	
 *	Macros used to validate parameters on standard MAPI object methods.
 *	Used in conjunction with routines found in MAPIU.DLL.
 *	
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef	_INC_VALIDATE
#define	_INC_VALIDATE

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MAPIUTIL_H
#include	<mapiutil.h>
#endif
#include	<stddef.h>
#include	<stdarg.h>


#define MAKE_ENUM(Method, Interface)	Interface##_##Method

typedef enum _tagMethods
{
/* IUnknown */
	MAKE_ENUM(QueryInterface, IUnknown) = 0,
	MAKE_ENUM(AddRef, IUnknown),			/* For completness */
	MAKE_ENUM(Release, IUnknown),			/* For completness */
	
/* IMAPIProps */
	MAKE_ENUM(GetLastError, IMAPIProp),
	MAKE_ENUM(SaveChanges, IMAPIProp),
	MAKE_ENUM(GetProps, IMAPIProp),
	MAKE_ENUM(GetPropList, IMAPIProp),
	MAKE_ENUM(OpenProperty, IMAPIProp),
	MAKE_ENUM(SetProps, IMAPIProp),
	MAKE_ENUM(DeleteProps, IMAPIProp),
	MAKE_ENUM(CopyTo, IMAPIProp),
	MAKE_ENUM(CopyProps, IMAPIProp),
	MAKE_ENUM(GetNamesFromIDs, IMAPIProp),
	MAKE_ENUM(GetIDsFromNames, IMAPIProp),

/* IMAPITable */
	MAKE_ENUM(GetLastError, IMAPITable),
	MAKE_ENUM(Advise, IMAPITable),
	MAKE_ENUM(Unadvise, IMAPITable),
	MAKE_ENUM(GetStatus, IMAPITable),
	MAKE_ENUM(SetColumns, IMAPITable),
	MAKE_ENUM(QueryColumns, IMAPITable),
	MAKE_ENUM(GetRowCount, IMAPITable),
	MAKE_ENUM(SeekRow, IMAPITable),
	MAKE_ENUM(SeekRowApprox, IMAPITable),
	MAKE_ENUM(QueryPosition, IMAPITable),
	MAKE_ENUM(FindRow, IMAPITable),
	MAKE_ENUM(Restrict, IMAPITable),
	MAKE_ENUM(CreateBookmark, IMAPITable),
	MAKE_ENUM(FreeBookmark, IMAPITable),
	MAKE_ENUM(SortTable, IMAPITable),
	MAKE_ENUM(QuerySortOrder, IMAPITable),
	MAKE_ENUM(QueryRows, IMAPITable),
	MAKE_ENUM(Abort, IMAPITable),
	MAKE_ENUM(ExpandRow, IMAPITable),
	MAKE_ENUM(CollapseRow, IMAPITable),
	MAKE_ENUM(WaitForCompletion, IMAPITable),
	MAKE_ENUM(GetCollapseState, IMAPITable),
	MAKE_ENUM(SetCollapseState, IMAPITable),

/* IMAPIContainer */
	MAKE_ENUM(GetContentsTable, IMAPIContainer),
	MAKE_ENUM(GetHierarchyTable, IMAPIContainer),
	MAKE_ENUM(OpenEntry, IMAPIContainer),
	MAKE_ENUM(SetSearchCriteria, IMAPIContainer),
	MAKE_ENUM(GetSearchCriteria, IMAPIContainer),

/* IABContainer */
	MAKE_ENUM(CreateEntry, IABContainer),
	MAKE_ENUM(CopyEntries, IABContainer),
	MAKE_ENUM(DeleteEntries, IABContainer),
	MAKE_ENUM(ResolveNames, IABContainer),

/* IDistList */
	MAKE_ENUM(CreateEntry, IDistList),
	MAKE_ENUM(CopyEntries, IDistList),
	MAKE_ENUM(DeleteEntries, IDistList),
	MAKE_ENUM(ResolveNames, IDistList),

/* IMAPIFolder */
	MAKE_ENUM(CreateMessage, IMAPIFolder),
	MAKE_ENUM(CopyMessages, IMAPIFolder),
	MAKE_ENUM(DeleteMessages, IMAPIFolder),
	MAKE_ENUM(CreateFolder, IMAPIFolder),
	MAKE_ENUM(CopyFolder, IMAPIFolder),
	MAKE_ENUM(DeleteFolder, IMAPIFolder),
	MAKE_ENUM(SetReadFlags, IMAPIFolder),
	MAKE_ENUM(GetMessageStatus, IMAPIFolder),
	MAKE_ENUM(SetMessageStatus, IMAPIFolder),
	MAKE_ENUM(SaveContentsSort, IMAPIFolder),
	MAKE_ENUM(EmptyFolder, IMAPIFolder),

/* IMsgStore */
	MAKE_ENUM(Advise, IMsgStore),
	MAKE_ENUM(Unadvise, IMsgStore),
	MAKE_ENUM(CompareEntryIDs, IMsgStore),
	MAKE_ENUM(OpenEntry, IMsgStore),
	MAKE_ENUM(SetReceiveFolder, IMsgStore),
	MAKE_ENUM(GetReceiveFolder, IMsgStore),
	MAKE_ENUM(GetReceiveFolderTable, IMsgStore),
	MAKE_ENUM(StoreLogoff, IMsgStore),
	MAKE_ENUM(AbortSubmit, IMsgStore),
	MAKE_ENUM(GetOutgoingQueue, IMsgStore),
	MAKE_ENUM(SetLockState, IMsgStore),
	MAKE_ENUM(FinishedMsg, IMsgStore),
	MAKE_ENUM(NotifyNewMail, IMsgStore),

/* IMessage */
	MAKE_ENUM(GetAttachmentTable, IMessage),
	MAKE_ENUM(OpenAttach, IMessage),
	MAKE_ENUM(CreateAttach, IMessage),
	MAKE_ENUM(DeleteAttach, IMessage),
	MAKE_ENUM(GetRecipientTable, IMessage),
	MAKE_ENUM(ModifyRecipients, IMessage),
	MAKE_ENUM(SubmitMessage, IMessage),
	MAKE_ENUM(SetReadFlag, IMessage),


/* IABProvider */
	MAKE_ENUM(Shutdown, IABProvider),
	MAKE_ENUM(Logon, IABProvider),

/* IABLogon */
	MAKE_ENUM(GetLastError, IABLogon),
	MAKE_ENUM(Logoff, IABLogon),
	MAKE_ENUM(OpenEntry, IABLogon),
	MAKE_ENUM(CompareEntryIDs, IABLogon),
	MAKE_ENUM(Advise, IABLogon),
	MAKE_ENUM(Unadvise, IABLogon),
	MAKE_ENUM(OpenStatusEntry, IABLogon),
	MAKE_ENUM(OpenTemplateID, IABLogon),
	MAKE_ENUM(GetOneOffTable, IABLogon),
	MAKE_ENUM(PrepareRecips, IABLogon),

/* IXPProvider */
	MAKE_ENUM(Shutdown, IXPProvider),
	MAKE_ENUM(TransportLogon, IXPProvider),

/* IXPLogon */
	MAKE_ENUM(AddressTypes, IXPLogon),
	MAKE_ENUM(RegisterOptions, IXPLogon),
	MAKE_ENUM(TransportNotify, IXPLogon),
	MAKE_ENUM(Idle, IXPLogon),
	MAKE_ENUM(TransportLogoff, IXPLogon),
	MAKE_ENUM(SubmitMessage, IXPLogon),
	MAKE_ENUM(EndMessage, IXPLogon),
	MAKE_ENUM(Poll, IXPLogon),
	MAKE_ENUM(StartMessage, IXPLogon),
	MAKE_ENUM(OpenStatusEntry, IXPLogon),
	MAKE_ENUM(ValidateState, IXPLogon),
	MAKE_ENUM(FlushQueues, IXPLogon),

/* IMSProvider */
	MAKE_ENUM(Shutdown, IMSProvider),
	MAKE_ENUM(Logon, IMSProvider),
	MAKE_ENUM(SpoolerLogon, IMSProvider),
	MAKE_ENUM(CompareStoreIDs, IMSProvider),

/* IMSLogon */
	MAKE_ENUM(GetLastError, IMSLogon),
	MAKE_ENUM(Logoff, IMSLogon),
	MAKE_ENUM(OpenEntry, IMSLogon),
	MAKE_ENUM(CompareEntryIDs, IMSLogon),
	MAKE_ENUM(Advise, IMSLogon),
	MAKE_ENUM(Unadvise, IMSLogon),
	MAKE_ENUM(OpenStatusEntry, IMSLogon),
	
/* IMAPIControl */
	MAKE_ENUM(GetLastError, IMAPIControl),
	MAKE_ENUM(Activate, IMAPIControl),
	MAKE_ENUM(GetState, IMAPIControl),
	
/* IMAPIStatus */
	MAKE_ENUM(ValidateState, IMAPIStatus),
	MAKE_ENUM(SettingsDialog, IMAPIStatus),
	MAKE_ENUM(ChangePassword, IMAPIStatus),
	MAKE_ENUM(FlushQueues, IMAPIStatus),

/* IStream */
	MAKE_ENUM(Read, IStream),
	MAKE_ENUM(Write, IStream),
	MAKE_ENUM(Seek, IStream),
	MAKE_ENUM(SetSize, IStream),
	MAKE_ENUM(CopyTo, IStream),
	MAKE_ENUM(Commit, IStream),
	MAKE_ENUM(Revert, IStream),
	MAKE_ENUM(LockRegion, IStream),
	MAKE_ENUM(UnlockRegion, IStream),
	MAKE_ENUM(Stat, IStream),
	MAKE_ENUM(Clone, IStream),

/* IMAPIAdviseSink */
	MAKE_ENUM(OnNotify, IMAPIAdviseSink),

} METHODS;


/* Macro wrappers to hide the Validate function return handling */
#if defined(_X86_) || defined( WIN16 )
#ifdef __cplusplus

/* C++ methods can't take the address of the This pointer, so we must
   use the first parameter instead */

#define ValidateParameters(eMethod, First)				\
		{	HRESULT   _hr_;								\
			_hr_ = __CPPValidateParameters(eMethod, (LPVOID) &First);	\
			if (HR_FAILED(_hr_)) return (_hr_);	}

#define UlValidateParameters(eMethod, First)				\
		{	HRESULT   _hr_;								\
			_hr_ = __CPPValidateParameters(eMethod, &First);	\
			if (HR_FAILED(_hr_)) return (ULONG) (_hr_);	}

/* Methods called by MAPI should have correct parameters
   - just assert in Debug to check */
#define CheckParameters(eMethod, First)				\
		AssertSz(HR_SUCCEEDED(__CPPValidateParameters(eMethod, &First)), "Parameter validation failed for method called by MAPI!")


#else /* __cplusplus */

/* For methods that will be called by clients
   - validate always */

#define ValidateParameters(eMethod, ppThis)				\
		{	HRESULT   _hr_;								\
			_hr_ = __ValidateParameters(eMethod, ppThis);	\
			if (HR_FAILED(_hr_)) return (_hr_);	}

#define UlValidateParameters(eMethod, ppThis)				\
		{	HRESULT   _hr_;								\
			_hr_ = __ValidateParameters(eMethod, ppThis);	\
			if (HR_FAILED(_hr_)) return (ULONG) (_hr_);	}

/* Methods called by MAPI should have correct parameters
   - just assert in Debug to check */
#define CheckParameters(eMethod, ppThis)				\
		AssertSz(HR_SUCCEEDED(__ValidateParameters(eMethod, ppThis)), "Parameter validation failed for method called by MAPI!")

#endif /* __cplusplus */
#endif /* _X86_ || WIN16 */

/* Prototypes for functions used to validate complex parameters.
 */
#define FBadPropVal( lpPropVal)	(FAILED(ScCountProps( 1, lpPropVal, NULL)))

#define FBadRgPropVal( lpPropVal, cValues) \
		(FAILED(ScCountProps( cValues, lpPropVal, NULL)))

#define FBadAdrList( lpAdrList) \
		(   AssertSz(   (   offsetof( ADRLIST, cEntries) \
						 == offsetof( SRowSet, cRows)) \
					 && (   offsetof( ADRLIST, aEntries) \
						 == offsetof( SRowSet, aRow)) \
					 && (   offsetof( ADRENTRY, cValues) \
						 == offsetof( SRow, cValues)) \
					 && (   offsetof( ADRENTRY, rgPropVals) \
						 == offsetof( SRow, lpProps)) \
					, "ADRLIST doesn't match SRowSet") \
		 || FBadRowSet( (LPSRowSet) lpAdrList))

STDAPI_(BOOL)
FBadRglpszW( LPWSTR FAR	*lppszW,
			 ULONG		cStrings);

STDAPI_(BOOL)
FBadRowSet( LPSRowSet	lpRowSet);

STDAPI_(BOOL)
FBadRglpNameID( LPMAPINAMEID FAR *	lppNameId,
				ULONG				cNames);

STDAPI_(BOOL)
FBadEntryList( LPENTRYLIST	lpEntryList);


/* BAD_STANDARD_OBJ
 *
 * This macro insures that the object is a writable object of the correct size
 * and that this method belongs to the object.
 *
 * NOTES ON USE!
 *	This depends upon using the standard method of declaring the object
 *	interface.
 *
 *	prefix is the method prefix you chose when declaring the object interface.
 *	method is the standard method name of the calling method.
 *	lpVtbl is the name of the lpVtbl element of your object.
 */
#define BAD_STANDARD_OBJ( lpObj, prefix, method, lpVtbl) \
	(   IsBadWritePtr( (lpObj), sizeof(*lpObj)) \
	 || IsBadReadPtr( (void *) &(lpObj->lpVtbl->method), sizeof(LPVOID)) \
	 ||( ( LPVOID) (lpObj->lpVtbl->method) != (LPVOID) (prefix##method)))


#define FBadUnknown( lpObj ) \
	(	IsBadReadPtr( (lpObj), sizeof(LPVOID) ) \
	 ||	IsBadReadPtr( (lpObj)->lpVtbl, 3 * sizeof(LPUNKNOWN) ) \
	 ||	IsBadCodePtr( (FARPROC)(lpObj)->lpVtbl->QueryInterface ))

/*
 * IUnknown
 */


/*
 * QueryInterface
 */
#define FBadQueryInterface( lpObj, riid, ppvObj)	\
	(   IsBadReadPtr( riid, sizeof(IID)) \
	 || IsBadWritePtr( ppvObj, sizeof(LPVOID)))


/*
 * AddRef
 *	No parameter validation required.
 */
#define FBadAddRef( lpObj)	FALSE


/*
 * Release
 *	No parameter validation required.
 */
#define FBadRelease( lpObj)	FALSE


/*
 * GetLastError
 */
#define FBadGetLastError( lpObj, hResult, ulFlags, lppMAPIError )\
	(IsBadWritePtr( lppMAPIError, sizeof(LPMAPIERROR)))

/*
 * IMAPIProp
 */


/*
 * SaveChanges
 *	No parameter validation required.
 */
#define FBadSaveChanges( lpObj, ulFlags)	FALSE


/*
 * GetProps
 */
#define FBadGetProps( lpObj, lpPTagA, lpcValues, lppPropArray) \
	(   (   lpPTagA \
		 && (   IsBadReadPtr( lpPTagA, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpPTagA, (UINT)(  (lpPTagA->cValues + 1) \
									          * sizeof(ULONG))))) \
	 || IsBadWritePtr( lpcValues, sizeof(ULONG)) \
	 || IsBadWritePtr( lppPropArray, sizeof(LPSPropValue)))


/*
 * GetPropList
 */
#define FBadGetPropList( lpObj, lppPTagA) \
	(IsBadWritePtr( lppPTagA, sizeof(LPSPropTagArray FAR *)))


/*
 * OpenProperty
 */
#define FBadOpenProperty( lpObj, ulPropTag, lpiid, ulInterfaceOptions, ulFlags \
						, lppUnk) \
	(   IsBadReadPtr( lpiid, sizeof(IID)) \
	 || IsBadWritePtr( lppUnk, sizeof (LPUNKNOWN FAR *)))


/*
 * SetProps
 */
#define FBadSetProps( lpObj, cValues, lpPropArray, lppProblems) \
	(   FBadRgPropVal( lpPropArray, (UINT) cValues) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * DeleteProps
 */
#define FBadDeleteProps( lpObj, lpPTagA, lppProblems) \
	(   (   !lpPTagA \
		 || (   IsBadReadPtr( lpPTagA, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpPTagA, (UINT)(  (lpPTagA->cValues + 1) \
									          * sizeof(ULONG))))) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * CopyTo
 */
#define FBadCopyTo( lpIPDAT, ciidExclude, rgiidExclude, lpExcludeProps \
				  , ulUIParam, lpProgress, lpInterface, lpDestObj \
				  , ulFlags, lppProblems) \
	(	(	ciidExclude \
		 && (  IsBadReadPtr( rgiidExclude, (UINT)(ciidExclude * sizeof(IID))))) \
	 || (   lpExcludeProps \
		 && (   IsBadReadPtr( lpExcludeProps, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpExcludeProps \
			 				, (UINT)(  (lpExcludeProps->cValues + 1) \
							         * sizeof(ULONG))))) \
	 || (lpProgress && FBadUnknown( lpProgress )) \
     || (lpInterface && IsBadReadPtr( lpInterface, sizeof(IID))) \
	 || IsBadReadPtr( lpDestObj, sizeof(LPVOID)) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * CopyProps
 */
#define FBadCopyProps( lpIPDAT, lpPropTagArray \
					 , ulUIParam, lpProgress, lpInterface, lpDestObj \
					 , ulFlags, lppProblems) \
	(   (   lpPropTagArray \
		 && (   IsBadReadPtr( lpPropTagArray, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpPropTagArray \
			 				, (UINT)(  (lpPropTagArray->cValues + 1) \
							         * sizeof(ULONG))))) \
	 || (lpProgress && FBadUnknown( lpProgress )) \
     || (lpInterface && IsBadReadPtr( lpInterface, sizeof(IID))) \
	 || IsBadReadPtr( lpDestObj, sizeof(LPVOID)) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))



/*
 * GetNamesFromIDs
 */
#define FBadGetNamesFromIDs( lpIPDAT, lppPropTags, lpPropSetGuid, ulFlags, \
							 lpcPropNames, lpppPropNames) \
	(   IsBadReadPtr( lppPropTags, sizeof(LPSPropTagArray)) \
	 || ( lpPropSetGuid && IsBadReadPtr( lpPropSetGuid, sizeof(GUID))) \
	 || (   *lppPropTags \
		 && (   IsBadReadPtr( *lppPropTags, sizeof(ULONG)) \
		 	 || IsBadReadPtr( *lppPropTags \
			 				, (UINT)( ( ( *lppPropTags)->cValues + 1) \
							         * sizeof(ULONG))))) \
	 || IsBadWritePtr( lpcPropNames, sizeof (ULONG)) \
	 || IsBadWritePtr( lpppPropNames, sizeof (LPVOID FAR *)))



/*
 * GetNamesFromIDs
 */
#define FBadGetIDsFromNames( lpIPDAT, cPropNames, lppPropNames, ulFlags \
						   , lppPropTags) \
	(   (cPropNames && FBadRglpNameID( lppPropNames, cPropNames)) \
	 || IsBadWritePtr( lppPropTags, sizeof(LPULONG FAR *)))


STDAPI_(ULONG)
FBadRestriction( LPSRestriction lpres );

STDAPI_(ULONG)
FBadPropTag( ULONG ulPropTag );

STDAPI_(ULONG)
FBadRow( LPSRow lprow );

STDAPI_(ULONG)
FBadProp( LPSPropValue lpprop );

STDAPI_(ULONG)
FBadSortOrderSet( LPSSortOrderSet lpsos );

STDAPI_(ULONG)
FBadColumnSet( LPSPropTagArray lpptaCols );

/* Validation function

	The eMethod parameter tells us which internal validation to perform.
	
	The ppThis parameter tells us where the stack is, so we can access the other
	parameters.
	
	Becuase of this *magic* we MUST obtain the pointer to the This pointer in
	the method function.
	
*/

#ifdef WIN16
#define BASED_STACK			__based(__segname("_STACK"))
#else
#define BASED_STACK
#endif


#ifdef WIN16
HRESULT	 PASCAL
#else
HRESULT	 STDAPICALLTYPE		
#endif
__CPPValidateParameters(METHODS eMethod, const LPVOID ppFirst);

#ifdef WIN16
HRESULT	 PASCAL
#else
HRESULT	 STDAPICALLTYPE		
#endif
__ValidateParameters(METHODS eMethod, LPVOID ppThis);

#ifdef _MAC
#define STDAPIVCALLTYPE         __cdecl
#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE
#endif /* _MAC */

/* Macro wrappers for platform independent validation */

#if defined(_X86_) || defined( WIN16 )
#define ValidateParms(x)	{ HRESULT _hr_ = HrValidateParameters x; if (HR_FAILED(_hr_)) return (_hr_); }
#define UlValidateParms(x)	{ HRESULT _hr_ = HrValidateParameters x; if (HR_FAILED(_hr_)) return (ULONG)(_hr_); }
#define CheckParms(x) 		AssertSz(HR_SUCCEEDED( HrValidateParameters x), "Parameter validation failed for method called by MAPI!")
#else
#define ValidateParms(x)	{ HRESULT _hr_ = HrValidateParametersV x; if (HR_FAILED(_hr_)) return (_hr_); }
#define UlValidateParms(x)	{ HRESULT _hr_ = HrValidateParametersV x; if (HR_FAILED(_hr_)) return (ULONG)(_hr_); }
#define CheckParms(x) 		AssertSz(HR_SUCCEEDED( HrValidateParametersV x ), "Parameter validation failed for method called by MAPI!")
#endif

#if defined(_X86_) || defined( WIN16 )

#define ValidateParameters1( m, a1 )
#define ValidateParameters2( m, a1, a2 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters3( m, a1, a2, a3 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters4( m, a1, a2, a3, a4 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )

#define UlValidateParameters1( m, a1 )
#define UlValidateParameters2( m, a1, a2 )	\
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters3( m, a1, a2, a3 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters4( m, a1, a2, a3, a4 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )

#define CheckParameters1( m, a1 )
#define CheckParameters2( m, a1, a2 )	\
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters3( m, a1, a2, a3)	\
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters4( m, a1, a2, a3, a4 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters5( m, a1, a2, a3, a4, a5 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )

#else /* !_X86_  && !WIN16 */

#define ValidateParameters1( m, a1 ) \
			ValidateParms( ( m, a1 ) )
#define ValidateParameters2( m, a1, a2 )	\
			ValidateParms( ( m, a1, a2 ))
#define ValidateParameters3( m, a1, a2, a3 )	\
			ValidateParms( ( m, a1, a2, a3 ))
#define ValidateParameters4( m, a1, a2, a3, a4 ) \
			ValidateParms( ( m, a1, a2, a3, a4 ))
#define ValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5 ))
#define ValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define ValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define ValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define ValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define ValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define ValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define ValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define ValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define ValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define ValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define ValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#define UlValidateParameters1( m, a1 ) \
			UlValidateParms( ( m, a1 ) )
#define UlValidateParameters2( m, a1, a2 )	\
			UlValidateParms( ( m, a1, a2 ))
#define UlValidateParameters3( m, a1, a2, a3 )	\
			UlValidateParms( ( m, a1, a2, a3 ))
#define UlValidateParameters4( m, a1, a2, a3, a4 ) \
			UlValidateParms( ( m, a1, a2, a3, a4 ))
#define UlValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5 ))
#define UlValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define UlValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define UlValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define UlValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define UlValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define UlValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define UlValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define UlValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define UlValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define UlValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define UlValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#define CheckParameters1( m, a1 ) \
			CheckParms( ( m, a1 ) )
#define CheckParameters2( m, a1, a2 )	\
			CheckParms( ( m, a1, a2 ))
#define CheckParameters3( m, a1, a2, a3 )	\
			CheckParms( ( m, a1, a2, a3 ))
#define CheckParameters4( m, a1, a2, a3, a4 ) \
			CheckParms( ( m, a1, a2, a3, a4 ))
#define CheckParameters5( m, a1, a2, a3, a4, a5 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5 ))
#define CheckParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define CheckParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define CheckParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define CheckParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define CheckParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define CheckParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define CheckParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define CheckParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define CheckParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define CheckParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define CheckParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#endif /* _X86_ || WIN16 */


/*
 *  	M A P I    P A R A M E T E R   V A L I D A T I O N    M A C R O S
 */


/* IUnknown */

#define Validate_IUnknown_QueryInterface( a1, a2, a3 ) \
			 ValidateParameters3( IUnknown_QueryInterface, a1, a2, a3 )
#define UlValidate_IUnknown_QueryInterface( a1, a2, a3 ) \
			 UlValidateParameters3( IUnknown_QueryInterface, a1, a2, a3 )
#define CheckParameters_IUnknown_QueryInterface( a1, a2, a3 ) \
			 CheckParameters3( IUnknown_QueryInterface, a1, a2, a3 )

#define Validate_IUnknown_AddRef( a1 ) \
			 ValidateParameters1( IUnknown_AddRef, a1 )
#define UlValidate_IUnknown_AddRef( a1 ) \
			 UlValidateParameters1( IUnknown_AddRef, a1 )
#define CheckParameters_IUnknown_AddRef( a1 ) \
			 CheckParameters1( IUnknown_AddRef, a1 )

#define Validate_IUnknown_Release( a1 ) \
			 ValidateParameters1( IUnknown_Release, a1 )
#define UlValidate_IUnknown_Release( a1 ) \
			 UlValidateParameters1( IUnknown_Release, a1 )
#define CheckParameters_IUnknown_Release( a1 ) \
			 CheckParameters1( IUnknown_Release, a1 )


/* IMAPIProp */

#define Validate_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPIProp_SaveChanges( a1, a2 ) \
			 ValidateParameters2( IMAPIProp_SaveChanges, a1, a2 )
#define UlValidate_IMAPIProp_SaveChanges( a1, a2 ) \
			 UlValidateParameters2( IMAPIProp_SaveChanges, a1, a2 )
#define CheckParameters_IMAPIProp_SaveChanges( a1, a2 ) \
			 CheckParameters2( IMAPIProp_SaveChanges, a1, a2 )

#define Validate_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )

#define Validate_IMAPIProp_GetPropList( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIProp_GetPropList, a1, a2, a3 )
#define UlValidate_IMAPIProp_GetPropList( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIProp_GetPropList, a1, a2, a3 )
#define CheckParameters_IMAPIProp_GetPropList( a1, a2, a3 ) \
			 CheckParameters3( IMAPIProp_GetPropList, a1, a2, a3 )

#define Validate_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )
#define UlValidate_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )
#define CheckParameters_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )

#define Validate_IMAPIProp_DeleteProps( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )
#define UlValidate_IMAPIProp_DeleteProps( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )
#define CheckParameters_IMAPIProp_DeleteProps( a1, a2, a3 ) \
			 CheckParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )

#define Validate_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			 ValidateParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )
#define UlValidate_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			 UlValidateParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )
#define CheckParameters_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			 CheckParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )

#define Validate_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 ValidateParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )
#define UlValidate_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 UlValidateParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )
#define CheckParameters_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 CheckParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )

#define Validate_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )


/* IMAPITable */

#define Validate_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPITable_Advise( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_Advise, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_Advise( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_Advise, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_Advise( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_Advise, a1, a2, a3, a4 )

#define Validate_IMAPITable_Unadvise( a1, a2 ) \
			 ValidateParameters2( IMAPITable_Unadvise, a1, a2 )
#define UlValidate_IMAPITable_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_Unadvise, a1, a2 )
#define CheckParameters_IMAPITable_Unadvise( a1, a2 ) \
			 CheckParameters2( IMAPITable_Unadvise, a1, a2 )

#define Validate_IMAPITable_GetStatus( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_GetStatus, a1, a2, a3 )
#define UlValidate_IMAPITable_GetStatus( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_GetStatus, a1, a2, a3 )
#define CheckParameters_IMAPITable_GetStatus( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_GetStatus, a1, a2, a3 )

#define Validate_IMAPITable_SetColumns( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_SetColumns, a1, a2, a3 )
#define UlValidate_IMAPITable_SetColumns( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_SetColumns, a1, a2, a3 )
#define CheckParameters_IMAPITable_SetColumns( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_SetColumns, a1, a2, a3 )

#define Validate_IMAPITable_QueryColumns( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_QueryColumns, a1, a2, a3 )
#define UlValidate_IMAPITable_QueryColumns( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_QueryColumns, a1, a2, a3 )
#define CheckParameters_IMAPITable_QueryColumns( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_QueryColumns, a1, a2, a3 )

#define Validate_IMAPITable_GetRowCount( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_GetRowCount, a1, a2, a3 )
#define UlValidate_IMAPITable_GetRowCount( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_GetRowCount, a1, a2, a3 )
#define CheckParameters_IMAPITable_GetRowCount( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_GetRowCount, a1, a2, a3 )

#define Validate_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )

#define Validate_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )
#define UlValidate_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )
#define CheckParameters_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )

#define Validate_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )

#define Validate_IMAPITable_FindRow( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_FindRow( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_FindRow( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )

#define Validate_IMAPITable_Restrict( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_Restrict, a1, a2, a3 )
#define UlValidate_IMAPITable_Restrict( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_Restrict, a1, a2, a3 )
#define CheckParameters_IMAPITable_Restrict( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_Restrict, a1, a2, a3 )

#define Validate_IMAPITable_CreateBookmark( a1, a2 ) \
			 ValidateParameters2( IMAPITable_CreateBookmark, a1, a2 )
#define UlValidate_IMAPITable_CreateBookmark( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_CreateBookmark, a1, a2 )
#define CheckParameters_IMAPITable_CreateBookmark( a1, a2 ) \
			 CheckParameters2( IMAPITable_CreateBookmark, a1, a2 )

#define Validate_IMAPITable_FreeBookmark( a1, a2 ) \
			 ValidateParameters2( IMAPITable_FreeBookmark, a1, a2 )
#define UlValidate_IMAPITable_FreeBookmark( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_FreeBookmark, a1, a2 )
#define CheckParameters_IMAPITable_FreeBookmark( a1, a2 ) \
			 CheckParameters2( IMAPITable_FreeBookmark, a1, a2 )

#define Validate_IMAPITable_SortTable( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_SortTable, a1, a2, a3 )
#define UlValidate_IMAPITable_SortTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_SortTable, a1, a2, a3 )
#define CheckParameters_IMAPITable_SortTable( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_SortTable, a1, a2, a3 )

#define Validate_IMAPITable_QuerySortOrder( a1, a2 ) \
			 ValidateParameters2( IMAPITable_QuerySortOrder, a1, a2 )
#define UlValidate_IMAPITable_QuerySortOrder( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_QuerySortOrder, a1, a2 )
#define CheckParameters_IMAPITable_QuerySortOrder( a1, a2 ) \
			 CheckParameters2( IMAPITable_QuerySortOrder, a1, a2 )

#define Validate_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )

#define Validate_IMAPITable_Abort( a1 ) \
			 ValidateParameters1( IMAPITable_Abort, a1 )
#define UlValidate_IMAPITable_Abort( a1 ) \
			 UlValidateParameters1( IMAPITable_Abort, a1 )
#define CheckParameters_IMAPITable_Abort( a1 ) \
			 CheckParameters1( IMAPITable_Abort, a1 )

#define Validate_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )

#define Validate_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )

#define Validate_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )


/* IMAPIContainer */

#define Validate_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )
#define UlValidate_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )
#define CheckParameters_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
			 CheckParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )

#define Validate_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )
#define UlValidate_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )
#define CheckParameters_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
			 CheckParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )

#define Validate_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )
#define UlValidate_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )
#define CheckParameters_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )

#define Validate_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )


/* IABContainer */

#define Validate_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )

#define Validate_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )

#define Validate_IABContainer_DeleteEntries( a1, a2, a3 ) \
			 ValidateParameters3( IABContainer_DeleteEntries, a1, a2, a3 )
#define UlValidate_IABContainer_DeleteEntries( a1, a2, a3 ) \
			 UlValidateParameters3( IABContainer_DeleteEntries, a1, a2, a3 )
#define CheckParameters_IABContainer_DeleteEntries( a1, a2, a3 ) \
			 CheckParameters3( IABContainer_DeleteEntries, a1, a2, a3 )

#define Validate_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )


/* IDistList */

#define Validate_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )

#define Validate_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )

#define Validate_IDistList_DeleteEntries( a1, a2, a3 ) \
			 ValidateParameters3( IDistList_DeleteEntries, a1, a2, a3 )
#define UlValidate_IDistList_DeleteEntries( a1, a2, a3 ) \
			 UlValidateParameters3( IDistList_DeleteEntries, a1, a2, a3 )
#define CheckParameters_IDistList_DeleteEntries( a1, a2, a3 ) \
			 CheckParameters3( IDistList_DeleteEntries, a1, a2, a3 )

#define Validate_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )


/* IMAPIFolder */

#define Validate_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )
#define UlValidate_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )
#define CheckParameters_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )

#define Validate_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 ValidateParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define UlValidate_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 UlValidateParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define CheckParameters_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 CheckParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )

#define Validate_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )
#define UlValidate_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )
#define CheckParameters_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
			 CheckParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )

#define Validate_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )
#define UlValidate_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )
#define CheckParameters_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )


/* IMsgStore */

#define Validate_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IMsgStore_Unadvise( a1, a2 ) \
			 ValidateParameters2( IMsgStore_Unadvise, a1, a2 )
#define UlValidate_IMsgStore_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IMsgStore_Unadvise, a1, a2 )
#define CheckParameters_IMsgStore_Unadvise( a1, a2 ) \
			 CheckParameters2( IMsgStore_Unadvise, a1, a2 )

#define Validate_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )
#define UlValidate_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )
#define CheckParameters_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )

#define Validate_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )

#define Validate_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
			 ValidateParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )
#define UlValidate_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )
#define CheckParameters_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
			 CheckParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )

#define Validate_IMsgStore_StoreLogoff( a1, a2 ) \
			 ValidateParameters2( IMsgStore_StoreLogoff, a1, a2 )
#define UlValidate_IMsgStore_StoreLogoff( a1, a2 ) \
			 UlValidateParameters2( IMsgStore_StoreLogoff, a1, a2 )
#define CheckParameters_IMsgStore_StoreLogoff( a1, a2 ) \
			 CheckParameters2( IMsgStore_StoreLogoff, a1, a2 )

#define Validate_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )
#define UlValidate_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )
#define CheckParameters_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
			 CheckParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )

#define Validate_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
			 ValidateParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )
#define UlValidate_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
			 UlValidateParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )
#define CheckParameters_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
			 CheckParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )

#define Validate_IMsgStore_SetLockState( a1, a2, a3 ) \
			 ValidateParameters3( IMsgStore_SetLockState, a1, a2, a3 )
#define UlValidate_IMsgStore_SetLockState( a1, a2, a3 ) \
			 UlValidateParameters3( IMsgStore_SetLockState, a1, a2, a3 )
#define CheckParameters_IMsgStore_SetLockState( a1, a2, a3 ) \
			 CheckParameters3( IMsgStore_SetLockState, a1, a2, a3 )

#define Validate_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )
#define UlValidate_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )
#define CheckParameters_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
			 CheckParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )

#define Validate_IMsgStore_NotifyNewMail( a1, a2 ) \
			 ValidateParameters2( IMsgStore_NotifyNewMail, a1, a2 )
#define UlValidate_IMsgStore_NotifyNewMail( a1, a2 ) \
			 UlValidateParameters2( IMsgStore_NotifyNewMail, a1, a2 )
#define CheckParameters_IMsgStore_NotifyNewMail( a1, a2 ) \
			 CheckParameters2( IMsgStore_NotifyNewMail, a1, a2 )


/* IMessage */

#define Validate_IMessage_GetAttachmentTable( a1, a2, a3 ) \
			 ValidateParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )
#define UlValidate_IMessage_GetAttachmentTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )
#define CheckParameters_IMessage_GetAttachmentTable( a1, a2, a3 ) \
			 CheckParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )

#define Validate_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_GetRecipientTable( a1, a2, a3 ) \
			 ValidateParameters3( IMessage_GetRecipientTable, a1, a2, a3 )
#define UlValidate_IMessage_GetRecipientTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMessage_GetRecipientTable, a1, a2, a3 )
#define CheckParameters_IMessage_GetRecipientTable( a1, a2, a3 ) \
			 CheckParameters3( IMessage_GetRecipientTable, a1, a2, a3 )

#define Validate_IMessage_ModifyRecipients( a1, a2, a3 ) \
			 ValidateParameters3( IMessage_ModifyRecipients, a1, a2, a3 )
#define UlValidate_IMessage_ModifyRecipients( a1, a2, a3 ) \
			 UlValidateParameters3( IMessage_ModifyRecipients, a1, a2, a3 )
#define CheckParameters_IMessage_ModifyRecipients( a1, a2, a3 ) \
			 CheckParameters3( IMessage_ModifyRecipients, a1, a2, a3 )

#define Validate_IMessage_SubmitMessage( a1, a2 ) \
			 ValidateParameters2( IMessage_SubmitMessage, a1, a2 )
#define UlValidate_IMessage_SubmitMessage( a1, a2 ) \
			 UlValidateParameters2( IMessage_SubmitMessage, a1, a2 )
#define CheckParameters_IMessage_SubmitMessage( a1, a2 ) \
			 CheckParameters2( IMessage_SubmitMessage, a1, a2 )

#define Validate_IMessage_SetReadFlag( a1, a2 ) \
			 ValidateParameters2( IMessage_SetReadFlag, a1, a2 )
#define UlValidate_IMessage_SetReadFlag( a1, a2 ) \
			 UlValidateParameters2( IMessage_SetReadFlag, a1, a2 )
#define CheckParameters_IMessage_SetReadFlag( a1, a2 ) \
			 CheckParameters2( IMessage_SetReadFlag, a1, a2 )


/* IABProvider */

#define Validate_IABProvider_Shutdown( a1, a2 ) \
			 ValidateParameters2( IABProvider_Shutdown, a1, a2 )
#define UlValidate_IABProvider_Shutdown( a1, a2 ) \
			 UlValidateParameters2( IABProvider_Shutdown, a1, a2 )
#define CheckParameters_IABProvider_Shutdown( a1, a2 ) \
			 CheckParameters2( IABProvider_Shutdown, a1, a2 )

#define Validate_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 ValidateParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define UlValidate_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 UlValidateParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define CheckParameters_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 CheckParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )


/* IABLogon */

#define Validate_IABLogon_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IABLogon_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IABLogon_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )

#define Validate_IABLogon_Logoff( a1, a2 ) \
			 ValidateParameters2( IABLogon_Logoff, a1, a2 )
#define UlValidate_IABLogon_Logoff( a1, a2 ) \
			 UlValidateParameters2( IABLogon_Logoff, a1, a2 )
#define CheckParameters_IABLogon_Logoff( a1, a2 ) \
			 CheckParameters2( IABLogon_Logoff, a1, a2 )

#define Validate_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IABLogon_Unadvise( a1, a2 ) \
			 ValidateParameters2( IABLogon_Unadvise, a1, a2 )
#define UlValidate_IABLogon_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IABLogon_Unadvise, a1, a2 )
#define CheckParameters_IABLogon_Unadvise( a1, a2 ) \
			 CheckParameters2( IABLogon_Unadvise, a1, a2 )

#define Validate_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )

#define Validate_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 ValidateParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )
#define UlValidate_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 UlValidateParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )
#define CheckParameters_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 CheckParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )

#define Validate_IABLogon_GetOneOffTable( a1, a2, a3 ) \
			 ValidateParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )
#define UlValidate_IABLogon_GetOneOffTable( a1, a2, a3 ) \
			 UlValidateParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )
#define CheckParameters_IABLogon_GetOneOffTable( a1, a2, a3 ) \
			 CheckParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )

#define Validate_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
			 ValidateParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )
#define UlValidate_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )
#define CheckParameters_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
			 CheckParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )


/* IXPProvider */

#define Validate_IXPProvider_Shutdown( a1, a2 ) \
			 ValidateParameters2( IXPProvider_Shutdown, a1, a2 )
#define UlValidate_IXPProvider_Shutdown( a1, a2 ) \
			 UlValidateParameters2( IXPProvider_Shutdown, a1, a2 )
#define CheckParameters_IXPProvider_Shutdown( a1, a2 ) \
			 CheckParameters2( IXPProvider_Shutdown, a1, a2 )

#define Validate_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )


/* IXPLogon */

#define Validate_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )

#define Validate_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
			 ValidateParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )
#define UlValidate_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )
#define CheckParameters_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
			 CheckParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )

#define Validate_IXPLogon_TransportNotify( a1, a2, a3 ) \
			 ValidateParameters3( IXPLogon_TransportNotify, a1, a2, a3 )
#define UlValidate_IXPLogon_TransportNotify( a1, a2, a3 ) \
			 UlValidateParameters3( IXPLogon_TransportNotify, a1, a2, a3 )
#define CheckParameters_IXPLogon_TransportNotify( a1, a2, a3 ) \
			 CheckParameters3( IXPLogon_TransportNotify, a1, a2, a3 )

#define Validate_IXPLogon_Idle( a1, a2 ) \
			 ValidateParameters2( IXPLogon_Idle, a1, a2 )
#define UlValidate_IXPLogon_Idle( a1, a2 ) \
			 UlValidateParameters2( IXPLogon_Idle, a1, a2 )
#define CheckParameters_IXPLogon_Idle( a1, a2 ) \
			 CheckParameters2( IXPLogon_Idle, a1, a2 )

#define Validate_IXPLogon_TransportLogoff( a1, a2 ) \
			 ValidateParameters2( IXPLogon_TransportLogoff, a1, a2 )
#define UlValidate_IXPLogon_TransportLogoff( a1, a2 ) \
			 UlValidateParameters2( IXPLogon_TransportLogoff, a1, a2 )
#define CheckParameters_IXPLogon_TransportLogoff( a1, a2 ) \
			 CheckParameters2( IXPLogon_TransportLogoff, a1, a2 )

#define Validate_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )

#define Validate_IXPLogon_EndMessage( a1, a2, a3 ) \
			 ValidateParameters3( IXPLogon_EndMessage, a1, a2, a3 )
#define UlValidate_IXPLogon_EndMessage( a1, a2, a3 ) \
			 UlValidateParameters3( IXPLogon_EndMessage, a1, a2, a3 )
#define CheckParameters_IXPLogon_EndMessage( a1, a2, a3 ) \
			 CheckParameters3( IXPLogon_EndMessage, a1, a2, a3 )

#define Validate_IXPLogon_Poll( a1, a2 ) \
			 ValidateParameters2( IXPLogon_Poll, a1, a2 )
#define UlValidate_IXPLogon_Poll( a1, a2 ) \
			 UlValidateParameters2( IXPLogon_Poll, a1, a2 )
#define CheckParameters_IXPLogon_Poll( a1, a2 ) \
			 CheckParameters2( IXPLogon_Poll, a1, a2 )

#define Validate_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
			 ValidateParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )
#define UlValidate_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )
#define CheckParameters_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
			 CheckParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )

#define Validate_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )

#define Validate_IXPLogon_ValidateState( a1, a2, a3 ) \
			 ValidateParameters3( IXPLogon_ValidateState, a1, a2, a3 )
#define UlValidate_IXPLogon_ValidateState( a1, a2, a3 ) \
			 UlValidateParameters3( IXPLogon_ValidateState, a1, a2, a3 )
#define CheckParameters_IXPLogon_ValidateState( a1, a2, a3 ) \
			 CheckParameters3( IXPLogon_ValidateState, a1, a2, a3 )

#define Validate_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )


/* IMSProvider */

#define Validate_IMSProvider_Shutdown( a1, a2 ) \
			 ValidateParameters2( IMSProvider_Shutdown, a1, a2 )
#define UlValidate_IMSProvider_Shutdown( a1, a2 ) \
			 UlValidateParameters2( IMSProvider_Shutdown, a1, a2 )
#define CheckParameters_IMSProvider_Shutdown( a1, a2 ) \
			 CheckParameters2( IMSProvider_Shutdown, a1, a2 )

#define Validate_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 ValidateParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define UlValidate_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 UlValidateParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define CheckParameters_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 CheckParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )

#define Validate_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 ValidateParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define UlValidate_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 UlValidateParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define CheckParameters_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 CheckParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )

#define Validate_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )


/* IMSLogon */

#define Validate_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )

#define Validate_IMSLogon_Logoff( a1, a2 ) \
			 ValidateParameters2( IMSLogon_Logoff, a1, a2 )
#define UlValidate_IMSLogon_Logoff( a1, a2 ) \
			 UlValidateParameters2( IMSLogon_Logoff, a1, a2 )
#define CheckParameters_IMSLogon_Logoff( a1, a2 ) \
			 CheckParameters2( IMSLogon_Logoff, a1, a2 )

#define Validate_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IMSLogon_Unadvise( a1, a2 ) \
			 ValidateParameters2( IMSLogon_Unadvise, a1, a2 )
#define UlValidate_IMSLogon_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IMSLogon_Unadvise, a1, a2 )
#define CheckParameters_IMSLogon_Unadvise( a1, a2 ) \
			 CheckParameters2( IMSLogon_Unadvise, a1, a2 )

#define Validate_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )


/* IMAPIControl */

#define Validate_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPIControl_Activate( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIControl_Activate, a1, a2, a3 )
#define UlValidate_IMAPIControl_Activate( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIControl_Activate, a1, a2, a3 )
#define CheckParameters_IMAPIControl_Activate( a1, a2, a3 ) \
			 CheckParameters3( IMAPIControl_Activate, a1, a2, a3 )

#define Validate_IMAPIControl_GetState( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIControl_GetState, a1, a2, a3 )
#define UlValidate_IMAPIControl_GetState( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIControl_GetState, a1, a2, a3 )
#define CheckParameters_IMAPIControl_GetState( a1, a2, a3 ) \
			 CheckParameters3( IMAPIControl_GetState, a1, a2, a3 )


/* IMAPIStatus */

#define Validate_IMAPIStatus_ValidateState( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )
#define UlValidate_IMAPIStatus_ValidateState( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )
#define CheckParameters_IMAPIStatus_ValidateState( a1, a2, a3 ) \
			 CheckParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )

#define Validate_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )
#define UlValidate_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )
#define CheckParameters_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
			 CheckParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )

#define Validate_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )
#define UlValidate_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )
#define CheckParameters_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )

#define Validate_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )


/* IStream */

#define Validate_IStream_Read( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_Read, a1, a2, a3, a4 )
#define UlValidate_IStream_Read( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_Read, a1, a2, a3, a4 )
#define CheckParameters_IStream_Read( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_Read, a1, a2, a3, a4 )

#define Validate_IStream_Write( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_Write, a1, a2, a3, a4 )
#define UlValidate_IStream_Write( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_Write, a1, a2, a3, a4 )
#define CheckParameters_IStream_Write( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_Write, a1, a2, a3, a4 )

#define Validate_IStream_Seek( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_Seek, a1, a2, a3, a4 )
#define UlValidate_IStream_Seek( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_Seek, a1, a2, a3, a4 )
#define CheckParameters_IStream_Seek( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_Seek, a1, a2, a3, a4 )

#define Validate_IStream_SetSize( a1, a2 ) \
			 ValidateParameters2( IStream_SetSize, a1, a2 )
#define UlValidate_IStream_SetSize( a1, a2 ) \
			 UlValidateParameters2( IStream_SetSize, a1, a2 )
#define CheckParameters_IStream_SetSize( a1, a2 ) \
			 CheckParameters2( IStream_SetSize, a1, a2 )

#define Validate_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )
#define UlValidate_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )
#define CheckParameters_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )

#define Validate_IStream_Commit( a1, a2 ) \
			 ValidateParameters2( IStream_Commit, a1, a2 )
#define UlValidate_IStream_Commit( a1, a2 ) \
			 UlValidateParameters2( IStream_Commit, a1, a2 )
#define CheckParameters_IStream_Commit( a1, a2 ) \
			 CheckParameters2( IStream_Commit, a1, a2 )

#define Validate_IStream_Revert( a1 ) \
			 ValidateParameters1( IStream_Revert, a1 )
#define UlValidate_IStream_Revert( a1 ) \
			 UlValidateParameters1( IStream_Revert, a1 )
#define CheckParameters_IStream_Revert( a1 ) \
			 CheckParameters1( IStream_Revert, a1 )

#define Validate_IStream_LockRegion( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_LockRegion, a1, a2, a3, a4 )
#define UlValidate_IStream_LockRegion( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_LockRegion, a1, a2, a3, a4 )
#define CheckParameters_IStream_LockRegion( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_LockRegion, a1, a2, a3, a4 )

#define Validate_IStream_UnlockRegion( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )
#define UlValidate_IStream_UnlockRegion( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )
#define CheckParameters_IStream_UnlockRegion( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )

#define Validate_IStream_Stat( a1, a2, a3 ) \
			 ValidateParameters3( IStream_Stat, a1, a2, a3 )
#define UlValidate_IStream_Stat( a1, a2, a3 ) \
			 UlValidateParameters3( IStream_Stat, a1, a2, a3 )
#define CheckParameters_IStream_Stat( a1, a2, a3 ) \
			 CheckParameters3( IStream_Stat, a1, a2, a3 )

#define Validate_IStream_Clone( a1, a2 ) \
			 ValidateParameters2( IStream_Clone, a1, a2 )
#define UlValidate_IStream_Clone( a1, a2 ) \
			 UlValidateParameters2( IStream_Clone, a1, a2 )
#define CheckParameters_IStream_Clone( a1, a2 ) \
			 CheckParameters2( IStream_Clone, a1, a2 )


/* IMAPIAdviseSink */

#define Validate_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )
#define UlValidate_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )
#define CheckParameters_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
			 CheckParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )


#ifdef WIN16
HRESULT
PASCAL	HrValidateParameters( METHODS eMethod, LPVOID FAR *ppFirstArg );
#elif defined(_X86_)
STDAPI	HrValidateParameters( METHODS eMethod, LPVOID FAR *ppFirstArg );
#else
STDAPIV	HrValidateParametersV( METHODS eMethod, ... );
STDAPIV HrValidateParametersValist( METHODS eMethod, va_list arglist );
#endif /* WIN16 */


#ifdef __cplusplus
}
#endif

#endif	/* _INC_VALIDATE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mapix.h ===
/*
 *	M A P I X . H
 *	
 *	Definitions of objects/flags, etc used by Extended MAPI.
 *	
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPIX_H
#define MAPIX_H

#if _MSC_VER > 1000
#pragma once
#endif

/* Include common MAPI header files if they haven't been already. */
#ifndef MAPIDEFS_H
#include <mapidefs.h>
#endif
#ifndef MAPICODE_H
#include <mapicode.h>
#endif
#ifndef MAPIGUID_H
#include <mapiguid.h>
#endif
#ifndef MAPITAGS_H
#include <mapitags.h>
#endif

#ifdef	__cplusplus
extern "C" {
#endif	

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/* Forward interface declarations */

DECLARE_MAPI_INTERFACE_PTR(IProfAdmin,			LPPROFADMIN);
DECLARE_MAPI_INTERFACE_PTR(IMsgServiceAdmin,	LPSERVICEADMIN);
DECLARE_MAPI_INTERFACE_PTR(IMAPISession,		LPMAPISESSION);

/* ------------------------------------------------------ */
/* shared with simple mapi */

typedef ULONG       FLAGS;

/* MAPILogon() flags.       */

#define MAPI_LOGON_UI           0x00000001  /* Display logon UI					*/
#define MAPI_NEW_SESSION        0x00000002  /* Don't use shared session			*/
#define MAPI_ALLOW_OTHERS       0x00000008  /* Make this a shared session		*/
#define MAPI_EXPLICIT_PROFILE   0x00000010  /* Don't use default profile		*/
#define MAPI_EXTENDED           0x00000020  /* Extended MAPI Logon				*/
#define MAPI_FORCE_DOWNLOAD     0x00001000  /* Get new mail before return		*/
#define MAPI_SERVICE_UI_ALWAYS	0x00002000	/* Do logon UI in all providers		*/
#define MAPI_NO_MAIL			0x00008000	/* Do not activate transports		*/
/* #define MAPI_NT_SERVICE			0x00010000	Allow logon from an NT service	*/
#ifndef MAPI_PASSWORD_UI
#define MAPI_PASSWORD_UI		0x00020000	/* Display password UI only			*/
#endif
#define MAPI_TIMEOUT_SHORT		0x00100000	/* Minimal wait for logon resources	*/

#define MAPI_SIMPLE_DEFAULT (MAPI_LOGON_UI | MAPI_FORCE_DOWNLOAD | MAPI_ALLOW_OTHERS)
#define MAPI_SIMPLE_EXPLICIT (MAPI_NEW_SESSION | MAPI_FORCE_DOWNLOAD | MAPI_EXPLICIT_PROFILE)

/* Structure passed to MAPIInitialize(), and its ulFlags values */

typedef struct
{
	ULONG			ulVersion;
	ULONG			ulFlags;
} MAPIINIT_0, FAR *LPMAPIINIT_0;

typedef MAPIINIT_0 MAPIINIT;
typedef MAPIINIT FAR *LPMAPIINIT;

#define MAPI_INIT_VERSION				0

#define MAPI_MULTITHREAD_NOTIFICATIONS	0x00000001
/* Reserved for MAPI					0x40000000 */
/* #define MAPI_NT_SERVICE				0x00010000	Use from NT service */

/* MAPI base functions */

typedef HRESULT (STDAPICALLTYPE MAPIINITIALIZE)(
	LPVOID			lpMapiInit
);
typedef MAPIINITIALIZE FAR *LPMAPIINITIALIZE;

typedef void (STDAPICALLTYPE MAPIUNINITIALIZE)(void);
typedef MAPIUNINITIALIZE FAR *LPMAPIUNINITIALIZE;

MAPIINITIALIZE		MAPIInitialize;
MAPIUNINITIALIZE	MAPIUninitialize;


/*  Extended MAPI Logon function */


typedef HRESULT (STDMETHODCALLTYPE MAPILOGONEX)(
	ULONG_PTR ulUIParam,
	LPTSTR lpszProfileName,
	LPTSTR lpszPassword,
	ULONG ulFlags,   /*  ulFlags takes all that SimpleMAPI does + MAPI_UNICODE */
	LPMAPISESSION FAR * lppSession
);
typedef MAPILOGONEX FAR *LPMAPILOGONEX;

MAPILOGONEX MAPILogonEx;


typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEBUFFER)(
	ULONG			cbSize,
	LPVOID FAR *	lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEMORE)(
	ULONG			cbSize,
	LPVOID			lpObject,
	LPVOID FAR *	lppBuffer
);

typedef ULONG (STDAPICALLTYPE MAPIFREEBUFFER)(
	LPVOID			lpBuffer
);

typedef MAPIALLOCATEBUFFER FAR	*LPMAPIALLOCATEBUFFER;
typedef MAPIALLOCATEMORE FAR	*LPMAPIALLOCATEMORE;
typedef MAPIFREEBUFFER FAR 		*LPMAPIFREEBUFFER;

MAPIALLOCATEBUFFER MAPIAllocateBuffer;
MAPIALLOCATEMORE MAPIAllocateMore;
MAPIFREEBUFFER MAPIFreeBuffer;

typedef HRESULT (STDMETHODCALLTYPE MAPIADMINPROFILES)(
	ULONG ulFlags,
	LPPROFADMIN FAR *lppProfAdmin
);

typedef MAPIADMINPROFILES FAR *LPMAPIADMINPROFILES;

MAPIADMINPROFILES MAPIAdminProfiles;

/* IMAPISession Interface -------------------------------------------------- */

/* Flags for OpenEntry and others */

/*#define MAPI_MODIFY				((ULONG) 0x00000001) */

/* Flags for Logoff */

#define MAPI_LOGOFF_SHARED      0x00000001  /* Close all shared sessions    */
#define MAPI_LOGOFF_UI          0x00000002  /* It's OK to present UI        */

/* Flags for SetDefaultStore. They are mutually exclusive. */

#define MAPI_DEFAULT_STORE			0x00000001	/* for incoming messages */
#define MAPI_SIMPLE_STORE_TEMPORARY	0x00000002	/* for simple MAPI and CMC */
#define MAPI_SIMPLE_STORE_PERMANENT	0x00000003	/* for simple MAPI and CMC */
#define	MAPI_PRIMARY_STORE			0x00000004	/* Used by some clients */
#define	MAPI_SECONDARY_STORE		0x00000005	/* Used by some clients */

/* Flags for ShowForm. */

#define MAPI_POST_MESSAGE		0x00000001	/* Selects post/send semantics */
#define MAPI_NEW_MESSAGE		0x00000002	/* Governs copying during submission */

/*  MessageOptions */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  QueryDefaultMessageOpt */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

#define MAPI_IMAPISESSION_METHODS(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetMsgStoresTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(OpenMsgStore)											\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPMDB FAR *					lppMDB) IPURE;				\
	MAPIMETHOD(OpenAddressBook)											\
		(THIS_	ULONG_PTR					ulUIParam,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPADRBOOK FAR *				lppAdrBook) IPURE;			\
	MAPIMETHOD(OpenProfileSection)										\
		(THIS_	LPMAPIUID					lpUID,						\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPPROFSECT FAR *			lppProfSect) IPURE;			\
	MAPIMETHOD(GetStatusTable)											\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;	\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(MessageOptions)											\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				LPTSTR						lpszAdrType,				\
				LPMESSAGE					lpMessage) IPURE;			\
	MAPIMETHOD(QueryDefaultMessageOpt)									\
		(THIS_	LPTSTR						lpszAdrType,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcValues,					\
				LPSPropValue FAR *			lppOptions) IPURE;			\
	MAPIMETHOD(EnumAdrTypes)											\
		(THIS_	ULONG						ulFlags,					\
				ULONG FAR *					lpcAdrTypes,				\
				LPTSTR FAR * FAR *			lpppszAdrTypes) IPURE;		\
	MAPIMETHOD(QueryIdentity)											\
		(THIS_	ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(Logoff)													\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				ULONG						ulReserved) IPURE;			\
	MAPIMETHOD(SetDefaultStore)											\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(AdminServices)											\
		(THIS_	ULONG						ulFlags,					\
				LPSERVICEADMIN FAR *		lppServiceAdmin) IPURE;		\
	MAPIMETHOD(ShowForm)												\
		(THIS_	ULONG_PTR					ulUIParam,					\
				LPMDB						lpMsgStore,					\
				LPMAPIFOLDER				lpParentFolder,				\
				LPCIID						lpInterface,				\
				ULONG						ulMessageToken,				\
				LPMESSAGE					lpMessageSent,				\
				ULONG						ulFlags,					\
				ULONG						ulMessageStatus,			\
				ULONG						ulMessageFlags,				\
				ULONG						ulAccess,					\
				LPSTR						lpszMessageClass) IPURE;	\
	MAPIMETHOD(PrepareForm)												\
		(THIS_	LPCIID						lpInterface,				\
				LPMESSAGE					lpMessage,					\
				ULONG FAR *					lpulMessageToken) IPURE;	\


#undef		 INTERFACE
#define		 INTERFACE  IMAPISession
DECLARE_MAPI_INTERFACE_(IMAPISession, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPISESSION_METHODS(PURE)
};

/*DECLARE_MAPI_INTERFACE_PTR(IMAPISession, LPMAPISESSION);*/

/* IAddrBook Interface ----------------------------------------------------- */

/*  CreateOneOff */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */
/****** MAPI_SEND_NO_RICH_INFO		((ULONG) 0x00010000) */

/*  RecipOptions */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  QueryDefaultRecipOpt */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  GetSearchPath */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */


#define MAPI_IADDRBOOK_METHODS(IPURE)									\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;	\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(CreateOneOff)											\
		(THIS_	LPTSTR						lpszName,					\
				LPTSTR						lpszAdrType,				\
				LPTSTR						lpszAddress,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(NewEntry)												\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				ULONG						cbEIDContainer,				\
				LPENTRYID					lpEIDContainer,				\
				ULONG						cbEIDNewEntryTpl,			\
				LPENTRYID					lpEIDNewEntryTpl,			\
				ULONG FAR *					lpcbEIDNewEntry,			\
				LPENTRYID FAR *				lppEIDNewEntry) IPURE;		\
	MAPIMETHOD(ResolveName)												\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				LPTSTR						lpszNewEntryTitle,			\
				LPADRLIST					lpAdrList) IPURE;			\
	MAPIMETHOD(Address)													\
		(THIS_	ULONG_PTR FAR *				lpulUIParam,				\
				LPADRPARM					lpAdrParms,					\
				LPADRLIST FAR *				lppAdrList) IPURE;			\
	MAPIMETHOD(Details)													\
		(THIS_	ULONG FAR *					lpulUIParam,				\
				LPFNDISMISS					lpfnDismiss,				\
				LPVOID						lpvDismissContext,			\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPFNBUTTON					lpfButtonCallback,			\
				LPVOID						lpvButtonContext,			\
				LPTSTR						lpszButtonText,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(RecipOptions)											\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				LPADRENTRY					lpRecip) IPURE;				\
	MAPIMETHOD(QueryDefaultRecipOpt)									\
		(THIS_	LPTSTR						lpszAdrType,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcValues,					\
				LPSPropValue FAR *			lppOptions) IPURE;			\
	MAPIMETHOD(GetPAB)													\
		(THIS_	ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(SetPAB)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetDefaultDir)											\
		(THIS_	ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(SetDefaultDir)											\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetSearchPath)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet FAR *				lppSearchPath) IPURE;		\
	MAPIMETHOD(SetSearchPath)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lpSearchPath) IPURE;		\
	MAPIMETHOD(PrepareRecips)											\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray				lpPropTagArray,				\
				LPADRLIST					lpRecipList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IAddrBook
DECLARE_MAPI_INTERFACE_(IAddrBook, IMAPIProp)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IADDRBOOK_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IAddrBook, LPADRBOOK);

/* IProfAdmin Interface ---------------------------------------------------- */

/* Flags for CreateProfile */
#define MAPI_DEFAULT_SERVICES			0x00000001

/* GetProfileTable */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

#define MAPI_IPROFADMIN_METHODS(IPURE)									\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetProfileTable)											\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(CreateProfile)											\
		(THIS_	LPTSTR						lpszProfileName,			\
				LPTSTR						lpszPassword,				\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteProfile)											\
		(THIS_	LPTSTR						lpszProfileName,			\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ChangeProfilePassword)									\
		(THIS_	LPTSTR						lpszProfileName,			\
				LPTSTR						lpszOldPassword,			\
				LPTSTR						lpszNewPassword,			\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(CopyProfile)												\
		(THIS_	LPTSTR						lpszOldProfileName,			\
				LPTSTR						lpszOldPassword,			\
				LPTSTR						lpszNewProfileName,			\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(RenameProfile)											\
		(THIS_	LPTSTR						lpszOldProfileName,			\
				LPTSTR						lpszOldPassword,			\
				LPTSTR						lpszNewProfileName,			\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SetDefaultProfile)										\
		(THIS_	LPTSTR						lpszProfileName,			\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(AdminServices)											\
		(THIS_	LPTSTR						lpszProfileName,			\
				LPTSTR						lpszPassword,				\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				LPSERVICEADMIN FAR *		lppServiceAdmin) IPURE;		\


#undef		 INTERFACE
#define		 INTERFACE  IProfAdmin
DECLARE_MAPI_INTERFACE_(IProfAdmin, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IPROFADMIN_METHODS(PURE)
};

/* IMsgServiceAdmin Interface ---------------------------------------------- */

/* Values for PR_RESOURCE_FLAGS in message service table */

#define SERVICE_DEFAULT_STORE		0x00000001
#define SERVICE_SINGLE_COPY			0x00000002
#define SERVICE_CREATE_WITH_STORE	0x00000004
#define SERVICE_PRIMARY_IDENTITY	0x00000008
#define SERVICE_NO_PRIMARY_IDENTITY	0x00000020

/*  GetMsgServiceTable */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  GetProviderTable */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

#define MAPI_IMSGSERVICEADMIN_METHODS(IPURE)							\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetMsgServiceTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(CreateMsgService)										\
		(THIS_	LPTSTR						lpszService,				\
				LPTSTR						lpszDisplayName,			\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteMsgService)										\
		(THIS_	LPMAPIUID					lpUID) IPURE;				\
	MAPIMETHOD(CopyMsgService)											\
		(THIS_	LPMAPIUID					lpUID,						\
				LPTSTR						lpszDisplayName,			\
				LPCIID						lpInterfaceToCopy,			\
				LPCIID						lpInterfaceDst,				\
				LPVOID						lpObjectDst,				\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(RenameMsgService)										\
		(THIS_	LPMAPIUID					lpUID,						\
				ULONG						ulFlags,					\
				LPTSTR						lpszDisplayName) IPURE;		\
	MAPIMETHOD(ConfigureMsgService)										\
		(THIS_	LPMAPIUID					lpUID,						\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				ULONG						cValues,					\
				LPSPropValue				lpProps) IPURE;				\
	MAPIMETHOD(OpenProfileSection)										\
		(THIS_	LPMAPIUID					lpUID,						\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPPROFSECT FAR *			lppProfSect) IPURE;			\
	MAPIMETHOD(MsgServiceTransportOrder)								\
		(THIS_	ULONG						cUID,						\
				LPMAPIUID					lpUIDList,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(AdminProviders)											\
		(THIS_	LPMAPIUID					lpUID,						\
				ULONG						ulFlags,					\
				LPPROVIDERADMIN FAR *		lppProviderAdmin) IPURE;	\
	MAPIMETHOD(SetPrimaryIdentity)										\
		(THIS_	LPMAPIUID					lpUID,						\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetProviderTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\


#undef 		 INTERFACE
#define 	 INTERFACE	IMsgServiceAdmin
DECLARE_MAPI_INTERFACE_(IMsgServiceAdmin, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMSGSERVICEADMIN_METHODS(PURE)
};

#ifdef	__cplusplus
}		/*	extern "C" */
#endif	

#endif /* MAPIX_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\msacmdlg.h ===
/***************************************************************************
 *
 *  msacmdlg.h
 *
 *  Copyright (c) 1991-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Description:
 *      Audio Compression Manager Common Dialogs Identifiers
 *
 ***************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#define DLG_ACMFORMATCHOOSE_ID              70
#define IDD_ACMFORMATCHOOSE_BTN_HELP        9
#define IDD_ACMFORMATCHOOSE_CMB_CUSTOM      100
#define IDD_ACMFORMATCHOOSE_CMB_FORMATTAG   101
#define IDD_ACMFORMATCHOOSE_CMB_FORMAT      102
#define IDD_ACMFORMATCHOOSE_BTN_SETNAME     103
#define IDD_ACMFORMATCHOOSE_BTN_DELNAME     104


#define DLG_ACMFILTERCHOOSE_ID              71
#define IDD_ACMFILTERCHOOSE_BTN_HELP        9
#define IDD_ACMFILTERCHOOSE_CMB_CUSTOM      100
#define IDD_ACMFILTERCHOOSE_CMB_FILTERTAG   101
#define IDD_ACMFILTERCHOOSE_CMB_FILTER      102
#define IDD_ACMFILTERCHOOSE_BTN_SETNAME     103
#define IDD_ACMFILTERCHOOSE_BTN_DELNAME     104
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mspab.h ===
/*
 *	M S P A B . H
 *	
 *	Public definitions for the Microsoft Personal Address Book
 *	
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

/*
 *	Microsoft Personal Address Book Provider ID
 *	-------------------------------------------
 */

#if _MSC_VER > 1000
#pragma once
#endif

#define	PAB_PROVIDER_ID		\
{							\
	0xB5, 0x3b, 0xc2, 0xc0,	\
	0x2c, 0x77, 0x10, 0x1a,	\
	0xa1, 0xbc, 0x08, 0x00,	\
	0x2b, 0x2a, 0x56, 0xc2	\
}


/*
 *	Messaging Service Properties
 *	----------------------------
 *
 *	The following properties are required to completely configure
 *	the Microsoft Personal Address Book messaging service with
 *	IMsgServiceAdmin::ConfigureMsgService() if UI is not requested
 *	by passing the UI_SERVICE flag.
 */

/*
 *		Fully qualified pathname of .PAB file to use
 */
#define		PR_PAB_PATH						PROP_TAG( PT_TSTRING,	0x6600 )
#define		PR_PAB_PATH_W					PROP_TAG( PT_UNICODE,	0x6600 )
#define		PR_PAB_PATH_A					PROP_TAG( PT_STRING8,	0x6600 )

/*
 *	The following additional properties may also be passed to
 *	customize the configuration.
 */

/*
 *		PR_DISPLAY_NAME
 *			The display name to be used for the PAB in the address
 *			book hierarchy.
 *
 *		PR_COMMENT
 *			A comment to be associated with the PAB.
 *
 *		PR_PAB_DET_DIR_VIEW_BY
 *			Determines how names of entries in the PAB with separate first
 *			and last names are displayed.
 *
 *			Possible values are:
 *
 *			PAB_DIR_VIEW_FIRST_THEN_LAST	First name followed by last name
 *			(default)						(e.g. "Dave Olsen").
 *
 *			PAB_DIR_VIEW_LAST_THEN_FIRST	Last name followed by separator
 *											followed by first name
 *											(e.g. "Olsen, Dave").
 */
#define		PR_PAB_DET_DIR_VIEW_BY			PROP_TAG( PT_LONG,		0x6601 )

#define		PAB_DIR_VIEW_FIRST_THEN_LAST	0
#define		PAB_DIR_VIEW_LAST_THEN_FIRST	1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\msports.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993-1999.
//
//  File:        msports.h
//
//  Contents:    public header file for COM name arbitration database
//               and Advanced dialog override and invocation
//
//--------------------------------------------------------------------

#ifndef _MSPORTS_H
#define _MSPORTS_H

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SERIAL_ADVANCED_SETTINGS

/*++

Routine Description:

    Displays the advanced properties dialog for the COM port specified by
    DeviceInfoSet and DeviceInfoData.

Arguments:

    ParentHwnd  - the parent window of the window to be displayed

    DeviceInfoSet, DeviceInfoData - SetupDi structures representing the COM port

Return Value:

    ERROR_SUCCESS if the dialog was shown

  --*/
LONG
SerialDisplayAdvancedSettings(IN HWND             ParentHwnd,
                              IN HDEVINFO         DeviceInfoSet,
                              IN PSP_DEVINFO_DATA DeviceInfoData
                              );

/*++

Routine Description:

    Prototype to allow serial port vendors to override the advanced dialog
    represented by the COM port specified by DeviceInfoSet and DeviceInfoData.

    To override the advanced page, place a value named EnumAdvancedDialog under
    the same key in which you would put your EnumPropPages32 value.  The format
    of the value is exactly the same as Enum...32 as well.

Arguments:

    ParentHwnd  - the parent window of the window to be displayed

    HidePollingUI - If TRUE, hide all UI that deals with polling.

    DeviceInfoSet, DeviceInfoData - SetupDi structures representing the COM port

    Reserved - Unused

Return Value:

    TRUE if the user pressed OK, FALSE if Cancel was pressed
--*/

typedef
BOOL
(*PPORT_ADVANCED_DIALOG) (
    IN HWND             ParentHwnd,
    IN BOOL             HidePollingUI,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PVOID            Reserved
    );

#endif

DECLARE_HANDLE(HCOMDB);
typedef HCOMDB *PHCOMDB;
#define HCOMDB_INVALID_HANDLE_VALUE ((HCOMDB) INVALID_HANDLE_VALUE)

//
// Minimum through maximum number of COM names arbitered
//
#define COMDB_MIN_PORTS_ARBITRATED 256
#define COMDB_MAX_PORTS_ARBITRATED 4096

LONG
WINAPI
ComDBOpen (
    PHCOMDB PHComDB
    );
/*++

Routine Description:

    Opens name data base, and returns a handle to be used in future calls.

Arguments:

    None.

Return Value:

    INVALID_HANDLE_VALUE if the call fails, otherwise a valid handle

    If INVALID_HANDLE_VALUE, call GetLastError() to get details (??)

--*/

LONG
WINAPI
ComDBClose (
    HCOMDB HComDB
    );
/*++

Routine Description:

    frees a handle to the database returned from OpenComPortDataBase

Arguments:

    Handle returned from OpenComPortDataBase.

Return Value:

    None

--*/

#define CDB_REPORT_BITS      0x0
#define CDB_REPORT_BYTES     0x1

LONG
WINAPI
ComDBGetCurrentPortUsage (
    HCOMDB   HComDB,
    PBYTE    Buffer,
    DWORD    BufferSize,
    ULONG    ReportType, // CDB_REPORT value
    LPDWORD  MaxPortsReported
    );
/*++

Routine Description:

    if Buffer is NULL, than MaxPortsReported will contain the max number of ports
        the DB will report (this value is NOT the number of bytes need for Buffer).
        ReportType is ignored in this case.

    if ReportType == CDB_REPORT_BITS
        returns a bit array indicating if a comX name is claimed.
        ie, Bit 0 of Byte 0 is com1, bit 1 of byte 0 is com2 and so on.

        BufferSize >= MaxPortsReported / 8


    if ReportType == CDB_REPORT_BYTES
        returns a byte array indicating if a comX name is claimed.  Zero unused, non zero
        used, ie, byte 0 is com1, byte 1 is com2, etc

        BufferSize >= MaxPortsReported

Arguments:

    Handle returned from OpenComPortDataBase.

    Buffer pointes to memory to place bit array

    BufferSize   Size of buffer in bytes

    MaxPortsReported    Pointer to DWORD that holds the number of bytes in buffer filled in

Return Value:

    returns ERROR_SUCCESS if successful.
            ERROR_NOT_CONNECTED cannot connect to DB
            ERROR_MORE_DATA if buffer not large enough

--*/


LONG
WINAPI
ComDBClaimNextFreePort (
    HCOMDB   HComDB,
    LPDWORD  ComNumber
    );
/*++

Routine Description:

    returns the first free COMx value

Arguments:

    Handle returned from OpenComPortDataBase.

Return Value:


    returns ERROR_SUCCESS if successful. or other ERROR_ if not

    if successful, then ComNumber will be that next free com value and claims it in the database


--*/



LONG
WINAPI
ComDBClaimPort (
    HCOMDB   HComDB,
    DWORD    ComNumber,
    BOOL     ForceClaim,
    PBOOL    Forced /* optional */
    );
/*++

Routine Description:

    Attempts to claim a com name in the database

Arguments:

    DataBaseHandle - returned from OpenComPortDataBase.

    ComNumber      - The port value to be claimed

    Force          - If TRUE, will force the port to be claimed even if in use already

    Forced         - will reflect the event that the claim was forced

Return Value:


    returns ERROR_SUCCESS if port name was not already claimed, or if it was claimed
                          and Force was TRUE.

            ERROR_SHARING_VIOLATION if port name is use and Force is false


--*/

LONG
WINAPI
ComDBReleasePort (
    HCOMDB   HComDB,
    DWORD    ComNumber
    );
/*++

Routine Description:

    Releases the port in the database

Arguments:

    DatabaseHandle - returned from OpenComPortDataBase.

    ComNumber      - port to be unclaimed in database

Return Value:


    returns ERROR_SUCCESS if successful
            ERROR_CANTWRITE if the changes cannot be committed
            ERROR_INVALID_PARAMETER if ComNumber is greater than the number of
                                    ports arbitrated


--*/

LONG
WINAPI
ComDBResizeDatabase (
    HCOMDB   HComDB,
    DWORD    NewSize
    );
/*++

Routine Description:

    Resizes the database to the new size.  To get the current size, call
    ComDBGetCurrentPortUsage with a Buffer == NULL.

Arguments:

    DatabaseHandle - returned from OpenComPortDataBase.

    NewSize        - must be a multiple of 1024, with a max of 4096

Return Value:


    returns ERROR_SUCCESS if successful
            ERROR_CANTWRITE if the changes cannot be committed
            ERROR_BAD_LENGTH if NewSize is not greater than the current size or
                             NewSize is greater than COMDB_MAX_PORTS_ARBITRATED

--*/


#ifdef __cplusplus
}
#endif


#endif // _MSPORTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mspst.h ===
/*
 *  M S P S T . H
 *	
 *  This file lists internal properties of the Microsoft Personal
 *  Information Store
 *	
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MSPST_H_
#define _MSPST_H_

#if _MSC_VER > 1000
#pragma once
#endif


/*  The following is a list of properties that may be passed in
    as the properties in the array of SPropValue structure on the
    MsgServiceConfigure function.

    Creating a PST profile section through CreateMsgService.
    The creation of the actual PST file is a two step process.  First the
    client should call CreateMsgService to setup the profile section and then
    ConfigureMsgService to create the PST file.
    The CreateMsgService call will setup the PR_DISPLAY_NAME property in the
    profile section to be used on the PST when it is created.

    Configuring an PST file through ConfigureMsgService.
    The configuration of an PST can take two forms, either configuring an
    existing PST or creating a new PST.  The Microsoft Personal Information
    Store provider will try to find the necessary properties by first looking
    in the array of SPropValue structures provided by the client and then in the
    profile section, except for PR_PST_PW_SZ_OLD for which it will only look
    in the array of properties.

    The Microsoft PST provider will try to open the file specified by the
    PR_PST_PATH property, using the password given in the PR_PST_PW_SZ_OLD
    property.  If it finds a file and it recognizes it as a PST
    file, it will start the configuration routine.  Otherwise it will start the
    creation routine.

    The configuration routine will look for the PR_DISPLAY_NAME_A and
    PR_COMMENT_A properties and set them in the message store object.  Then it
    will look for the PR_PST_REMEMBER_PW property to decide if it should
    remember the password in the profile. (If not found then it will defaut to
    the current status of the profile password.)  Then if it is supposed to
    use UI, it will display the configuration property sheet to the user.  After
    all has succeeded, it will update the profile.

    The creation routine will follow one of two paths to get the PR_PST_PATH
    property.  If it is supposed to use UI it will always display the file open
    dialog to confirm the path passed in or allow the user to change it.  If
    the user chooses an existing file and it recognizes it as an PST it will
    drop back to the configuration routine.  If the user chooses an existing
    file and it is not recognized as an PST file, the user will be given the
    option of choosing another file or  creating a new PST in its place, in
    which case is will continue with the create routine.  If the user chooses
    a new file it will continue with the create routine.  If the routine is not
    allowed to use UI, then the routine will create a file at the given path
    even if another file exists there.

    Once it decides to continue with the creation process it will get the
    PR_DISPLAY_NAME, PR_COMMENT, PR_PST_ENCRYPTION, and PR_PST_SZ_PW_NEW
    properties.  If it is supposed to use UI, it will use these to initialize
    the creation dialog and get any changes the user want.  Then it will create
    a new file and update the profile.

    PR_DISPLAY_NAME_A   display name for the PST service
    PR_COMMENT_A        comment to the place on the PST store object
    PR_PST_PATH         location the store to create or configure
    PR_PST_REMEMBER_PW  whether or not the remember the password in the profile
    PR_PST_ENCRYPTION   encryption level at which to create the file
    PR_PST_PW_SZ_OLD    password of the PST being configured
    PR_PST_PW_SZ_NEW    password to use for future access to the PST
*/

#define PST_EXTERN_PROPID_BASE          (0x6700)
#define PR_PST_PATH                     PROP_TAG(PT_STRING8, PST_EXTERN_PROPID_BASE + 0)
#define PR_PST_REMEMBER_PW              PROP_TAG(PT_BOOLEAN, PST_EXTERN_PROPID_BASE + 1)
#define PR_PST_ENCRYPTION               PROP_TAG(PT_LONG, PST_EXTERN_PROPID_BASE + 2)
#define PR_PST_PW_SZ_OLD                PROP_TAG(PT_STRING8, PST_EXTERN_PROPID_BASE + 3)
#define PR_PST_PW_SZ_NEW                PROP_TAG(PT_STRING8, PST_EXTERN_PROPID_BASE + 4)

#define PSTF_NO_ENCRYPTION              ((DWORD)0x80000000)
#define PSTF_COMPRESSABLE_ENCRYPTION    ((DWORD)0x40000000)
#define PSTF_BEST_ENCRYPTION            ((DWORD)0x20000000)

/*
 *  PR_MDB_PROVIDER is the GUID that represent the Microsoft Personal
 *  Information Store.  This guid is available as a property in the stores
 *  table and on the message store and status objects.
 */
#define MSPST_UID_PROVIDER  {   0x4e, 0x49, 0x54, 0x41, \
                                0xf9, 0xbf, 0xb8, 0x01, \
                                0x00, 0xaa, 0x00, 0x37, \
                                0xd9, 0x6e, 0x00, 0x00 }

#endif  /* _MSPST_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mmreg.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    mmreg.h

Abstract:

    Multimedia Registration

Revision History:

--*/

// Define the following to skip definitions
//
// NOMMIDS      Multimedia IDs are not defined
// NONEWWAVE    No new waveform types are defined except WAVEFORMATEX
// NONEWRIFF    No new RIFF forms are defined
// NOJPEGDIB    No JPEG DIB definitions
// NONEWIC      No new Image Compressor types are defined
// NOBITMAP     No extended bitmap info header definition

#ifndef _INC_MMREG
/* use version number to verify compatibility */
#define _INC_MMREG     158      // version * 100 + revision

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined( RC_INVOKED ) && defined( _MSC_VER )
#if (_MSC_VER <= 800)
#pragma pack(1)
#else
#include "pshpack1.h"   /* Assume byte packing throughout */
#endif
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef NOMMIDS

/* manufacturer IDs */
#ifndef MM_MICROSOFT
#define   MM_MICROSOFT                  1           /* Microsoft Corporation */
#endif

#define   MM_CREATIVE                   2           /* Creative Labs, Inc. */
#define   MM_MEDIAVISION                3           /* Media Vision, Inc. */
#define   MM_FUJITSU                    4           /* Fujitsu Corp. */
#define   MM_PRAGMATRAX                 5           /* PRAGMATRAX Software */
#define   MM_CYRIX                      6           /* Cyrix Corporation */
#define   MM_PHILIPS_SPEECH_PROCESSING  7           /* Philips Speech Processing */
#define   MM_NETXL                      8           /* NetXL, Inc. */
#define   MM_ZYXEL                      9           /* ZyXEL Communications, Inc. */
#define   MM_BECUBED                    10          /* BeCubed Software Inc. */
#define   MM_AARDVARK                   11          /* Aardvark Computer Systems, Inc. */
#define   MM_BINTEC                     12          /* Bin Tec Communications GmbH */
#define   MM_HEWLETT_PACKARD            13          /* Hewlett-Packard Company */
#define   MM_ACULAB                     14          /* Aculab plc */
#define   MM_FAITH                      15          /* Faith,Inc. */
#define   MM_MITEL                      16          /* Mitel Corporation */
#define   MM_QUANTUM3D                  17          /* Quantum3D, Inc. */
#define   MM_SNI                        18          /* Siemens-Nixdorf */
#define   MM_EMU                        19          /* E-mu Systems, Inc. */
#define   MM_ARTISOFT                   20          /* Artisoft, Inc. */
#define   MM_TURTLE_BEACH               21          /* Turtle Beach, Inc. */
#define   MM_IBM                        22          /* IBM Corporation */
#define   MM_VOCALTEC                   23          /* Vocaltec Ltd. */
#define   MM_ROLAND                     24          /* Roland */
#define   MM_DSP_SOLUTIONS              25          /* DSP Solutions, Inc. */
#define   MM_NEC                        26          /* NEC */
#define   MM_ATI                        27          /* ATI Technologies Inc. */
#define   MM_WANGLABS                   28          /* Wang Laboratories, Inc. */
#define   MM_TANDY                      29          /* Tandy Corporation */
#define   MM_VOYETRA                    30          /* Voyetra */
#define   MM_ANTEX                      31          /* Antex Electronics Corporation */
#define   MM_ICL_PS                     32          /* ICL Personal Systems */
#define   MM_INTEL                      33          /* Intel Corporation */
#define   MM_GRAVIS                     34          /* Advanced Gravis */
#define   MM_VAL                        35          /* Video Associates Labs, Inc. */
#define   MM_INTERACTIVE                36          /* InterActive Inc. */
#define   MM_YAMAHA                     37          /* Yamaha Corporation of America */
#define   MM_EVEREX                     38          /* Everex Systems, Inc. */
#define   MM_ECHO                       39          /* Echo Speech Corporation */
#define   MM_SIERRA                     40          /* Sierra Semiconductor Corp */
#define   MM_CAT                        41          /* Computer Aided Technologies */
#define   MM_APPS                       42          /* APPS Software International */
#define   MM_DSP_GROUP                  43          /* DSP Group, Inc. */
#define   MM_MELABS                     44          /* microEngineering Labs */
#define   MM_COMPUTER_FRIENDS           45          /* Computer Friends, Inc. */
#define   MM_ESS                        46          /* ESS Technology */
#define   MM_AUDIOFILE                  47          /* Audio, Inc. */
#define   MM_MOTOROLA                   48          /* Motorola, Inc. */
#define   MM_CANOPUS                    49          /* Canopus, co., Ltd. */
#define   MM_EPSON                      50          /* Seiko Epson Corporation */
#define   MM_TRUEVISION                 51          /* Truevision */
#define   MM_AZTECH                     52          /* Aztech Labs, Inc. */
#define   MM_VIDEOLOGIC                 53          /* Videologic */
#define   MM_SCALACS                    54          /* SCALACS */
#define   MM_KORG                       55          /* Korg Inc. */
#define   MM_APT                        56          /* Audio Processing Technology */
#define   MM_ICS                        57          /* Integrated Circuit Systems, Inc. */
#define   MM_ITERATEDSYS                58          /* Iterated Systems, Inc. */
#define   MM_METHEUS                    59          /* Metheus */
#define   MM_LOGITECH                   60          /* Logitech, Inc. */
#define   MM_WINNOV                     61          /* Winnov, Inc. */
#define   MM_NCR                        62          /* NCR Corporation */
#define   MM_EXAN                       63          /* EXAN */
#define   MM_AST                        64          /* AST Research Inc. */
#define   MM_WILLOWPOND                 65          /* Willow Pond Corporation */
#define   MM_SONICFOUNDRY               66          /* Sonic Foundry */
#define   MM_VITEC                      67          /* Vitec Multimedia */
#define   MM_MOSCOM                     68          /* MOSCOM Corporation */
#define   MM_SILICONSOFT                69          /* Silicon Soft, Inc. */
#define   MM_TERRATEC                   70          /* TerraTec Electronic GmbH */
#define   MM_MEDIASONIC                 71          /* MediaSonic Ltd. */
#define   MM_SANYO                      72          /* SANYO Electric Co., Ltd. */
#define   MM_SUPERMAC                   73          /* Supermac */
#define   MM_AUDIOPT                    74          /* Audio Processing Technology */
#define   MM_NOGATECH                   75          /* NOGATECH Ltd. */
#define   MM_SPEECHCOMP                 76          /* Speech Compression */
#define   MM_AHEAD                      77          /* Ahead, Inc. */
#define   MM_DOLBY                      78          /* Dolby Laboratories */
#define   MM_OKI                        79          /* OKI */
#define   MM_AURAVISION                 80          /* AuraVision Corporation */
#define   MM_OLIVETTI                   81          /* Ing C. Olivetti & C., S.p.A. */
#define   MM_IOMAGIC                    82          /* I/O Magic Corporation */
#define   MM_MATSUSHITA                 83          /* Matsushita Electric Industrial Co., Ltd. */
#define   MM_CONTROLRES                 84          /* Control Resources Limited */
#define   MM_XEBEC                      85          /* Xebec Multimedia Solutions Limited */
#define   MM_NEWMEDIA                   86          /* New Media Corporation */
#define   MM_NMS                        87          /* Natural MicroSystems */
#define   MM_LYRRUS                     88          /* Lyrrus Inc. */
#define   MM_COMPUSIC                   89          /* Compusic */
#define   MM_OPTI                       90          /* OPTi Computers Inc. */
#define   MM_ADLACC                     91          /* Adlib Accessories Inc. */
#define   MM_COMPAQ                     92          /* Compaq Computer Corp. */
#define   MM_DIALOGIC                   93          /* Dialogic Corporation */
#define   MM_INSOFT                     94          /* InSoft, Inc. */
#define   MM_MPTUS                      95          /* M.P. Technologies, Inc. */
#define   MM_WEITEK                     96          /* Weitek */
#define   MM_LERNOUT_AND_HAUSPIE        97          /* Lernout & Hauspie */
#define   MM_QCIAR                      98          /* Quanta Computer Inc. */
#define   MM_APPLE                      99          /* Apple Computer, Inc. */
#define   MM_DIGITAL                    100         /* Digital Equipment Corporation */
#define   MM_MOTU                       101         /* Mark of the Unicorn */
#define   MM_WORKBIT                    102         /* Workbit Corporation */
#define   MM_OSITECH                    103         /* Ositech Communications Inc. */
#define   MM_MIRO                       104         /* miro Computer Products AG */
#define   MM_CIRRUSLOGIC                105         /* Cirrus Logic */
#define   MM_ISOLUTION                  106         /* ISOLUTION  B.V. */
#define   MM_HORIZONS                   107         /* Horizons Technology, Inc. */
#define   MM_CONCEPTS                   108         /* Computer Concepts Ltd. */
#define   MM_VTG                        109         /* Voice Technologies Group, Inc. */
#define   MM_RADIUS                     110         /* Radius */
#define   MM_ROCKWELL                   111         /* Rockwell International */
#define   MM_XYZ                        112         /* Co. XYZ for testing */
#define   MM_OPCODE                     113         /* Opcode Systems */
#define   MM_VOXWARE                    114         /* Voxware Inc. */
#define   MM_NORTHERN_TELECOM           115         /* Northern Telecom Limited */
#define   MM_APICOM                     116         /* APICOM */
#define   MM_GRANDE                     117         /* Grande Software */
#define   MM_ADDX                       118         /* ADDX */
#define   MM_WILDCAT                    119         /* Wildcat Canyon Software */
#define   MM_RHETOREX                   120         /* Rhetorex Inc. */
#define   MM_BROOKTREE                  121         /* Brooktree Corporation */
#define   MM_ENSONIQ                    125         /* ENSONIQ Corporation */
#define   MM_FAST                       126         /* FAST Multimedia AG */
#define   MM_NVIDIA                     127         /* NVidia Corporation */
#define   MM_OKSORI                     128         /* OKSORI Co., Ltd. */
#define   MM_DIACOUSTICS                129         /* DiAcoustics, Inc. */
#define   MM_GULBRANSEN                 130         /* Gulbransen, Inc. */
#define   MM_KAY_ELEMETRICS             131         /* Kay Elemetrics, Inc. */
#define   MM_CRYSTAL                    132         /* Crystal Semiconductor Corporation */
#define   MM_SPLASH_STUDIOS             133         /* Splash Studios */
#define   MM_QUARTERDECK                134         /* Quarterdeck Corporation */
#define   MM_TDK                        135         /* TDK Corporation */
#define   MM_DIGITAL_AUDIO_LABS         136         /* Digital Audio Labs, Inc. */
#define   MM_SEERSYS                    137         /* Seer Systems, Inc. */
#define   MM_PICTURETEL                 138         /* PictureTel Corporation */
#define   MM_ATT_MICROELECTRONICS       139         /* AT&T Microelectronics */
#define   MM_OSPREY                     140         /* Osprey Technologies, Inc. */
#define   MM_MEDIATRIX                  141         /* Mediatrix Peripherals */
#define   MM_SOUNDESIGNS                142         /* SounDesignS M.C.S. Ltd. */
#define   MM_ALDIGITAL                  143         /* A.L. Digital Ltd. */
#define   MM_SPECTRUM_SIGNAL_PROCESSING 144         /* Spectrum Signal Processing, Inc. */
#define   MM_ECS                        145         /* Electronic Courseware Systems, Inc. */
#define   MM_AMD                        146         /* AMD */
#define   MM_COREDYNAMICS               147         /* Core Dynamics */
#define   MM_CANAM                      148         /* CANAM Computers */
#define   MM_SOFTSOUND                  149         /* Softsound, Ltd. */
#define   MM_NORRIS                     150         /* Norris Communications, Inc. */
#define   MM_DDD                        151         /* Danka Data Devices */
#define   MM_EUPHONICS                  152         /* EuPhonics */
#define   MM_PRECEPT                    153         /* Precept Software, Inc. */
#define   MM_CRYSTAL_NET                154         /* Crystal Net Corporation */
#define   MM_CHROMATIC                  155         /* Chromatic Research, Inc. */
#define   MM_VOICEINFO                  156         /* Voice Information Systems, Inc. */
#define   MM_VIENNASYS                  157         /* Vienna Systems */
#define   MM_CONNECTIX                  158         /* Connectix Corporation */
#define   MM_GADGETLABS                 159         /* Gadget Labs LLC */
#define   MM_FRONTIER                   160         /* Frontier Design Group LLC */
#define   MM_VIONA                      161         /* Viona Development GmbH */
#define   MM_CASIO                      162         /* Casio Computer Co., LTD */
#define   MM_DIAMONDMM                  163         /* Diamond Multimedia */
#define   MM_S3                         164         /* S3 */
#define   MM_DVISION                    165         /* D-Vision Systems, Inc. */
#define   MM_NETSCAPE                   166         /* Netscape Communications */
#define   MM_SOUNDSPACE                 167         /* Soundspace Audio */
#define   MM_VANKOEVERING               168         /* VanKoevering Company */
#define   MM_QTEAM                      169         /* Q-Team */
#define   MM_ZEFIRO                     170         /* Zefiro Acoustics */
#define   MM_STUDER                     171         /* Studer Professional Audio AG */
#define   MM_FRAUNHOFER_IIS             172         /* Fraunhofer IIS */
#define   MM_QUICKNET                   173         /* Quicknet Technologies */
#define   MM_ALARIS                     174         /* Alaris, Inc. */
#define   MM_SICRESOURCE                175         /* SIC Resource Inc. */
#define   MM_NEOMAGIC                   176         /* NeoMagic Corporation */
#define   MM_MERGING_TECHNOLOGIES       177         /* Merging Technologies S.A. */
#define   MM_XIRLINK                    178         /* Xirlink, Inc. */
#define   MM_COLORGRAPH                 179         /* Colorgraph (UK) Ltd */
#define   MM_OTI                        180         /* Oak Technology, Inc. */
#define   MM_AUREAL                     181         /* Aureal Semiconductor */
#define   MM_VIVO                       182         /* Vivo Software */
#define   MM_SHARP                      183         /* Sharp */
#define   MM_LUCENT                     184         /* Lucent Technologies */
#define   MM_ATT                        185         /* AT&T Labs, Inc. */
#define   MM_SUNCOM                     186         /* Sun Communications, Inc. */
#define   MM_SORVIS                     187         /* Sorenson Vision */
#define   MM_INVISION                   188         /* InVision Interactive */
#define   MM_BERKOM                     189         /* Deutsche Telekom Berkom GmbH */
#define   MM_MARIAN                     190         /* Marian GbR Leipzig */
#define   MM_DPSINC                     191         /* Digital Processing Systems, Inc. */
#define   MM_BCB                        192         /* BCB Holdings Inc. */
#define   MM_MOTIONPIXELS               193         /* Motion Pixels */
#define   MM_QDESIGN                    194         /* QDesign Corporation */
#define   MM_NMP                        195         /* Nokia Mobile Phones */
#define   MM_DATAFUSION                 196         /* DataFusion Systems (Pty) (Ltd) */
#define   MM_DUCK                       197         /* The Duck Corporation */
#define   MM_FTR                        198         /* Future Technology Resources Pty Ltd */
#define   MM_BERCOS                     199         /* BERCOS GmbH */
#define   MM_ONLIVE                     200         /* OnLive! Technologies, Inc. */
#define   MM_SIEMENS_SBC                201         /* Siemens Business Communications Systems */
#define   MM_TERALOGIC                  202         /* TeraLogic, Inc. */
#define   MM_PHONET                     203         /* PhoNet Communications Ltd. */
#define   MM_WINBOND                    204         /* Winbond Electronics Corp */
#define   MM_VIRTUALMUSIC               205         /* Virtual Music, Inc. */
#define   MM_ENET                       206         /* e-Net, Inc. */
#define   MM_GUILLEMOT                  207         /* Guillemot International */
#define   MM_EMAGIC                     208         /* Emagic Soft- und Hardware GmbH */
#define   MM_MWM                        209         /* MWM Acoustics LLC */
#define   MM_PACIFICRESEARCH            210         /* Pacific Research and Engineering Corporation */
#define   MM_SIPROLAB                   211         /* Sipro Lab Telecom Inc. */
#define   MM_LYNX                       212         /* Lynx Studio Technology, Inc. */
#define   MM_SPECTRUM_PRODUCTIONS       213         /* Spectrum Productions */
#define   MM_DICTAPHONE                 214         /* Dictaphone Corporation */
#define   MM_QUALCOMM                   215         /* QUALCOMM, Inc. */
#define   MM_RZS                        216         /* Ring Zero Systems, Inc */
#define   MM_AUDIOSCIENCE               217         /* AudioScience Inc. */
#define   MM_PINNACLE                   218         /* Pinnacle Systems, Inc. */
#define   MM_EES                        219         /* EES Technik fr Musik GmbH */
#define   MM_HAFTMANN                   220         /* haftmann#software */
#define   MM_LUCID                      221         /* Lucid Technology, Symetrix Inc. */
#define   MM_HEADSPACE                  222         /* Headspace, Inc */
#define   MM_UNISYS                     223         /* UNISYS CORPORATION */
#define   MM_LUMINOSITI                 224         /* Luminositi, Inc. */
#define   MM_ACTIVEVOICE                225         /* ACTIVE VOICE CORPORATION */
#define   MM_DTS                        226         /* Digital Theater Systems, Inc. */
#define   MM_DIGIGRAM                   227         /* DIGIGRAM */
#define   MM_SOFTLAB_NSK                228         /* Softlab-Nsk */
#define   MM_FORTEMEDIA                 229         /* ForteMedia, Inc */
#define   MM_SONORUS                    230         /* Sonorus, Inc. */
#define   MM_ARRAY                      231         /* Array Microsystems, Inc. */
#define   MM_DATARAN                    232         /* Data Translation, Inc. */
#define   MM_I_LINK                     233         /* I-link Worldwide */
#define   MM_SELSIUS_SYSTEMS            234         /* Selsius Systems Inc. */
#define   MM_ADMOS                      235         /* AdMOS Technology, Inc. */
#define   MM_LEXICON                    236         /* Lexicon Inc. */
#define   MM_SGI                        237         /* Silicon Graphics Inc. */
#define   MM_IPI                        238         /* Interactive Product Inc. */
#define   MM_ICE                        239         /* IC Ensemble, Inc. */
#define   MM_VQST                       240         /* ViewQuest Technologies Inc. */
#define   MM_ETEK                       241         /* eTEK Labs Inc. */
#define   MM_CS                         242         /* Consistent Software */
#define   MM_ALESIS                     243         /* Alesis Studio Electronics */
#define   MM_INTERNET                   244         /* INTERNET Corporation */
#define   MM_SONY                       245         /* Sony Corporation */
#define   MM_HYPERACTIVE                246         /* Hyperactive Audio Systems, Inc. */
#define   MM_UHER_INFORMATIC            247         /* UHER informatic GmbH */
#define   MM_SYDEC_NV                   248         /* Sydec NV */
#define   MM_FLEXION                    249         /* Flexion Systems Ltd. */
#define   MM_VIA                        250         /* Via Technologies, Inc. */
#define   MM_MICRONAS                   251         /* Micronas Semiconductors, Inc. */
#define   MM_ANALOGDEVICES              252         /* Analog Devices, Inc. */
#define   MM_HP                         253         /* Hewlett Packard Company */
#define   MM_MATROX_DIV                 254         /* Matrox */
#define   MM_QUICKAUDIO                 255         /* Quick Audio, GbR */
#define   MM_YOUCOM                     256         /* You/Com Audiocommunicatie BV */
#define   MM_RICHMOND                   257         /* Richmond Sound Design Ltd. */
#define   MM_IODD                       258         /* I-O Data Device, Inc. */
#define   MM_ICCC                       259         /* ICCC A/S */
#define   MM_3COM                       260         /* 3COM Corporation */
#define   MM_MALDEN                     261         /* Malden Electronics Ltd. */
#define   MM_3DFX                       262         /* 3Dfx Interactive, Inc. */
#define   MM_MINDMAKER                  263         /* Mindmaker, Inc. */
#define   MM_TELEKOL                    264         /* Telekol Corp. */
#define   MM_ST_MICROELECTRONICS        265         /* ST Microelectronics */
#define   MM_ALGOVISION                 266         /* Algo Vision Systems GmbH */

#define   MM_UNMAPPED                   0xffff      /* extensible MID mapping */

#define   MM_PID_UNMAPPED               MM_UNMAPPED /* extensible PID mapping */

#ifdef GUID_DEFINED
#if !defined(INIT_MMREG_MID)
//{d5a47fa7-6d98-11d1-a21a-00a0c9223196}
#define INIT_MMREG_MID(guid, id)\
{\
    (guid)->Data1 = 0xd5a47fa7 + (USHORT)(id);\
    (guid)->Data2 = 0x6d98;\
    (guid)->Data3 = 0x11d1;\
    (guid)->Data4[0] = 0xa2;\
    (guid)->Data4[1] = 0x1a;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_MMREG_MID(guid)\
    (USHORT)((guid)->Data1 - 0xd5a47fa7)
#define DEFINE_MMREG_MID_GUID(id)\
    0xd5a47fa7+(USHORT)(id), 0x6d98, 0x11d1, 0xa2, 0x1a, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96

#define IS_COMPATIBLE_MMREG_MID(guid)\
    (((guid)->Data1 >= 0xd5a47fa7) &&\
    ((guid)->Data1 < 0xd5a47fa7 + 0xffff) &&\
    ((guid)->Data2 == 0x6d98) &&\
    ((guid)->Data3 == 0x11d1) &&\
    ((guid)->Data4[0] == 0xa2) &&\
    ((guid)->Data4[1] == 0x1a) &&\
    ((guid)->Data4[2] == 0x00) &&\
    ((guid)->Data4[3] == 0xa0) &&\
    ((guid)->Data4[4] == 0xc9) &&\
    ((guid)->Data4[5] == 0x22) &&\
    ((guid)->Data4[6] == 0x31) &&\
    ((guid)->Data4[7] == 0x96))
#endif // !defined(INIT_MMREG_MID)

#if !defined(INIT_MMREG_PID)
//{e36dc2ac-6d9a-11d1-a21a-00a0c9223196}
#define INIT_MMREG_PID(guid, id)\
{\
    (guid)->Data1 = 0xe36dc2ac + (USHORT)(id);\
    (guid)->Data2 = 0x6d9a;\
    (guid)->Data3 = 0x11d1;\
    (guid)->Data4[0] = 0xa2;\
    (guid)->Data4[1] = 0x1a;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_MMREG_PID(guid)\
    (USHORT)((guid)->Data1 - 0xe36dc2ac)
#define DEFINE_MMREG_PID_GUID(id)\
    0xe36dc2ac+(USHORT)(id), 0x6d9a, 0x11d1, 0xa2, 0x1a, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96

#define IS_COMPATIBLE_MMREG_PID(guid)\
    (((guid)->Data1 >= 0xe36dc2ac) &&\
    ((guid)->Data1 < 0xe36dc2ac + 0xffff) &&\
    ((guid)->Data2 == 0x6d9a) &&\
    ((guid)->Data3 == 0x11d1) &&\
    ((guid)->Data4[0] == 0xa2) &&\
    ((guid)->Data4[1] == 0x1a) &&\
    ((guid)->Data4[2] == 0x00) &&\
    ((guid)->Data4[3] == 0xa0) &&\
    ((guid)->Data4[4] == 0xc9) &&\
    ((guid)->Data4[5] == 0x22) &&\
    ((guid)->Data4[6] == 0x31) &&\
    ((guid)->Data4[7] == 0x96))
#endif // !defined(INIT_MMREG_PID)
#endif // GUID_DEFINED

/* MM_MICROSOFT product IDs */

#ifndef MM_MIDI_MAPPER

#define  MM_MIDI_MAPPER                     1       /*  Midi Mapper  */
#define  MM_WAVE_MAPPER                     2       /*  Wave Mapper  */
#define  MM_SNDBLST_MIDIOUT                 3       /*  Sound Blaster MIDI output port  */
#define  MM_SNDBLST_MIDIIN                  4       /*  Sound Blaster MIDI input port  */
#define  MM_SNDBLST_SYNTH                   5       /*  Sound Blaster internal synth  */
#define  MM_SNDBLST_WAVEOUT                 6       /*  Sound Blaster waveform output  */
#define  MM_SNDBLST_WAVEIN                  7       /*  Sound Blaster waveform input  */
#define  MM_ADLIB                           9       /*  Ad Lib Compatible synth  */
#define  MM_MPU401_MIDIOUT                  10      /*  MPU 401 compatible MIDI output port  */
#define  MM_MPU401_MIDIIN                   11      /*  MPU 401 compatible MIDI input port  */
#define  MM_PC_JOYSTICK                     12      /*  Joystick adapter  */

#endif

#define  MM_PCSPEAKER_WAVEOUT               13      /*  PC speaker waveform output  */
#define  MM_MSFT_WSS_WAVEIN                 14      /*  MS Audio Board waveform input  */
#define  MM_MSFT_WSS_WAVEOUT                15      /*  MS Audio Board waveform output  */
#define  MM_MSFT_WSS_FMSYNTH_STEREO         16      /*  MS Audio Board  Stereo FM synth  */
#define  MM_MSFT_WSS_MIXER                  17      /*  MS Audio Board Mixer Driver  */
#define  MM_MSFT_WSS_OEM_WAVEIN             18      /*  MS OEM Audio Board waveform input  */
#define  MM_MSFT_WSS_OEM_WAVEOUT            19      /*  MS OEM Audio Board waveform output  */
#define  MM_MSFT_WSS_OEM_FMSYNTH_STEREO     20      /*  MS OEM Audio Board Stereo FM Synth  */
#define  MM_MSFT_WSS_AUX                    21      /*  MS Audio Board Aux. Port  */
#define  MM_MSFT_WSS_OEM_AUX                22      /*  MS OEM Audio Aux Port  */
#define  MM_MSFT_GENERIC_WAVEIN             23      /*  MS Vanilla driver waveform input  */
#define  MM_MSFT_GENERIC_WAVEOUT            24      /*  MS Vanilla driver wavefrom output  */
#define  MM_MSFT_GENERIC_MIDIIN             25      /*  MS Vanilla driver MIDI in  */
#define  MM_MSFT_GENERIC_MIDIOUT            26      /*  MS Vanilla driver MIDI  external out  */
#define  MM_MSFT_GENERIC_MIDISYNTH          27      /*  MS Vanilla driver MIDI synthesizer  */
#define  MM_MSFT_GENERIC_AUX_LINE           28      /*  MS Vanilla driver aux (line in)  */
#define  MM_MSFT_GENERIC_AUX_MIC            29      /*  MS Vanilla driver aux (mic)  */
#define  MM_MSFT_GENERIC_AUX_CD             30      /*  MS Vanilla driver aux (CD)  */
#define  MM_MSFT_WSS_OEM_MIXER              31      /*  MS OEM Audio Board Mixer Driver  */
#define  MM_MSFT_MSACM                      32      /*  MS Audio Compression Manager  */
#define  MM_MSFT_ACM_MSADPCM                33      /*  MS ADPCM Codec  */
#define  MM_MSFT_ACM_IMAADPCM               34      /*  IMA ADPCM Codec  */
#define  MM_MSFT_ACM_MSFILTER               35      /*  MS Filter  */
#define  MM_MSFT_ACM_GSM610                 36      /*  GSM 610 codec  */
#define  MM_MSFT_ACM_G711                   37      /*  G.711 codec  */
#define  MM_MSFT_ACM_PCM                    38      /*  PCM converter  */

   // Microsoft Windows Sound System drivers

#define  MM_WSS_SB16_WAVEIN                 39      /*  Sound Blaster 16 waveform input  */
#define  MM_WSS_SB16_WAVEOUT                40      /*  Sound Blaster 16  waveform output  */
#define  MM_WSS_SB16_MIDIIN                 41      /*  Sound Blaster 16 midi-in  */
#define  MM_WSS_SB16_MIDIOUT                42      /*  Sound Blaster 16 midi out  */
#define  MM_WSS_SB16_SYNTH                  43      /*  Sound Blaster 16 FM Synthesis  */
#define  MM_WSS_SB16_AUX_LINE               44      /*  Sound Blaster 16 aux (line in)  */
#define  MM_WSS_SB16_AUX_CD                 45      /*  Sound Blaster 16 aux (CD)  */
#define  MM_WSS_SB16_MIXER                  46      /*  Sound Blaster 16 mixer device  */
#define  MM_WSS_SBPRO_WAVEIN                47      /*  Sound Blaster Pro waveform input  */
#define  MM_WSS_SBPRO_WAVEOUT               48      /*  Sound Blaster Pro waveform output  */
#define  MM_WSS_SBPRO_MIDIIN                49      /*  Sound Blaster Pro midi in  */
#define  MM_WSS_SBPRO_MIDIOUT               50      /*  Sound Blaster Pro midi out  */
#define  MM_WSS_SBPRO_SYNTH                 51      /*  Sound Blaster Pro FM synthesis  */
#define  MM_WSS_SBPRO_AUX_LINE              52      /*  Sound Blaster Pro aux (line in )  */
#define  MM_WSS_SBPRO_AUX_CD                53      /*  Sound Blaster Pro aux (CD)  */
#define  MM_WSS_SBPRO_MIXER                 54      /*  Sound Blaster Pro mixer  */
#define  MM_MSFT_WSS_NT_WAVEIN              55      /*  WSS NT wave in  */
#define  MM_MSFT_WSS_NT_WAVEOUT             56      /*  WSS NT wave out  */
#define  MM_MSFT_WSS_NT_FMSYNTH_STEREO      57      /*  WSS NT FM synth  */
#define  MM_MSFT_WSS_NT_MIXER               58      /*  WSS NT mixer  */
#define  MM_MSFT_WSS_NT_AUX                 59      /*  WSS NT aux  */
#define  MM_MSFT_SB16_WAVEIN                60      /*  Sound Blaster 16 waveform input  */
#define  MM_MSFT_SB16_WAVEOUT               61      /*  Sound Blaster 16  waveform output  */
#define  MM_MSFT_SB16_MIDIIN                62      /*  Sound Blaster 16 midi-in  */
#define  MM_MSFT_SB16_MIDIOUT               63      /*  Sound Blaster 16 midi out  */
#define  MM_MSFT_SB16_SYNTH                 64      /*  Sound Blaster 16 FM Synthesis  */
#define  MM_MSFT_SB16_AUX_LINE              65      /*  Sound Blaster 16 aux (line in)  */
#define  MM_MSFT_SB16_AUX_CD                66      /*  Sound Blaster 16 aux (CD)  */
#define  MM_MSFT_SB16_MIXER                 67      /*  Sound Blaster 16 mixer device  */
#define  MM_MSFT_SBPRO_WAVEIN               68      /*  Sound Blaster Pro waveform input  */
#define  MM_MSFT_SBPRO_WAVEOUT              69      /*  Sound Blaster Pro waveform output  */
#define  MM_MSFT_SBPRO_MIDIIN               70      /*  Sound Blaster Pro midi in  */
#define  MM_MSFT_SBPRO_MIDIOUT              71      /*  Sound Blaster Pro midi out  */
#define  MM_MSFT_SBPRO_SYNTH                72      /*  Sound Blaster Pro FM synthesis  */
#define  MM_MSFT_SBPRO_AUX_LINE             73      /*  Sound Blaster Pro aux (line in)  */
#define  MM_MSFT_SBPRO_AUX_CD               74      /*  Sound Blaster Pro aux (CD)  */
#define  MM_MSFT_SBPRO_MIXER                75      /*  Sound Blaster Pro mixer  */

#define  MM_MSFT_MSOPL_SYNTH                76      /*  Yamaha OPL2/OPL3 compatible FM synthesis */

#define  MM_MSFT_VMDMS_LINE_WAVEIN          80     /* Voice Modem Serial Line Wave Input */
#define  MM_MSFT_VMDMS_LINE_WAVEOUT         81     /* Voice Modem Serial Line Wave Output */
#define  MM_MSFT_VMDMS_HANDSET_WAVEIN       82     /* Voice Modem Serial Handset Wave Input */
#define  MM_MSFT_VMDMS_HANDSET_WAVEOUT      83     /* Voice Modem Serial Handset Wave Output */
#define  MM_MSFT_VMDMW_LINE_WAVEIN          84     /* Voice Modem Wrapper Line Wave Input */
#define  MM_MSFT_VMDMW_LINE_WAVEOUT         85     /* Voice Modem Wrapper Line Wave Output */
#define  MM_MSFT_VMDMW_HANDSET_WAVEIN       86     /* Voice Modem Wrapper Handset Wave Input */
#define  MM_MSFT_VMDMW_HANDSET_WAVEOUT      87     /* Voice Modem Wrapper Handset Wave Output */
#define  MM_MSFT_VMDMW_MIXER                88     /* Voice Modem Wrapper Mixer */
#define  MM_MSFT_VMDM_GAME_WAVEOUT          89     /* Voice Modem Game Compatible Wave Device */
#define  MM_MSFT_VMDM_GAME_WAVEIN           90     /* Voice Modem Game Compatible Wave Device */

#define  MM_MSFT_ACM_MSNAUDIO               91
#define  MM_MSFT_ACM_MSG723                 92
#define  MM_MSFT_ACM_MSRT24                 93

#define  MM_MSFT_WDMAUDIO_WAVEOUT           100    /* Generic id for WDM Audio drivers */
#define  MM_MSFT_WDMAUDIO_WAVEIN            101    /* Generic id for WDM Audio drivers */
#define  MM_MSFT_WDMAUDIO_MIDIOUT           102    /* Generic id for WDM Audio drivers */
#define  MM_MSFT_WDMAUDIO_MIDIIN            103    /* Generic id for WDM Audio drivers */
#define  MM_MSFT_WDMAUDIO_MIXER             104    /* Generic id for WDM Audio drivers */
#define  MM_MSFT_WDMAUDIO_AUX               105    /* Generic id for WDM Audio drivers */


/* MM_CREATIVE product IDs */
#define  MM_CREATIVE_SB15_WAVEIN            1       /*  SB (r) 1.5 waveform input  */
#define  MM_CREATIVE_SB20_WAVEIN            2
#define  MM_CREATIVE_SBPRO_WAVEIN           3
#define  MM_CREATIVE_SBP16_WAVEIN           4
#define  MM_CREATIVE_PHNBLST_WAVEIN         5
#define  MM_CREATIVE_SB15_WAVEOUT           101
#define  MM_CREATIVE_SB20_WAVEOUT           102
#define  MM_CREATIVE_SBPRO_WAVEOUT          103
#define  MM_CREATIVE_SBP16_WAVEOUT          104
#define  MM_CREATIVE_PHNBLST_WAVEOUT        105
#define  MM_CREATIVE_MIDIOUT                201     /*  SB (r)  */
#define  MM_CREATIVE_MIDIIN                 202     /*  SB (r)  */
#define  MM_CREATIVE_FMSYNTH_MONO           301     /*  SB (r)  */
#define  MM_CREATIVE_FMSYNTH_STEREO         302     /*  SB Pro (r) stereo synthesizer  */
#define  MM_CREATIVE_MIDI_AWE32             303
#define  MM_CREATIVE_AUX_CD                 401     /*  SB Pro (r) aux (CD)  */
#define  MM_CREATIVE_AUX_LINE               402     /*  SB Pro (r) aux (Line in )  */
#define  MM_CREATIVE_AUX_MIC                403     /*  SB Pro (r) aux (mic)  */
#define  MM_CREATIVE_AUX_MASTER             404
#define  MM_CREATIVE_AUX_PCSPK              405
#define  MM_CREATIVE_AUX_WAVE               406
#define  MM_CREATIVE_AUX_MIDI               407
#define  MM_CREATIVE_SBPRO_MIXER            408
#define  MM_CREATIVE_SB16_MIXER             409

/* MM_MEDIAVISION product IDs */

// Pro Audio Spectrum
#define  MM_MEDIAVISION_PROAUDIO            0x10
#define  MM_PROAUD_MIDIOUT                  (MM_MEDIAVISION_PROAUDIO+1)
#define  MM_PROAUD_MIDIIN                   (MM_MEDIAVISION_PROAUDIO+2)
#define  MM_PROAUD_SYNTH                    (MM_MEDIAVISION_PROAUDIO+3)
#define  MM_PROAUD_WAVEOUT                  (MM_MEDIAVISION_PROAUDIO+4)
#define  MM_PROAUD_WAVEIN                   (MM_MEDIAVISION_PROAUDIO+5)
#define  MM_PROAUD_MIXER                    (MM_MEDIAVISION_PROAUDIO+6)
#define  MM_PROAUD_AUX                      (MM_MEDIAVISION_PROAUDIO+7)

// Thunder Board
#define  MM_MEDIAVISION_THUNDER             0x20
#define  MM_THUNDER_SYNTH                   (MM_MEDIAVISION_THUNDER+3)
#define  MM_THUNDER_WAVEOUT                 (MM_MEDIAVISION_THUNDER+4)
#define  MM_THUNDER_WAVEIN                  (MM_MEDIAVISION_THUNDER+5)
#define  MM_THUNDER_AUX                     (MM_MEDIAVISION_THUNDER+7)

// Audio Port
#define  MM_MEDIAVISION_TPORT               0x40
#define  MM_TPORT_WAVEOUT                   (MM_MEDIAVISION_TPORT+1)
#define  MM_TPORT_WAVEIN                    (MM_MEDIAVISION_TPORT+2)
#define  MM_TPORT_SYNTH                     (MM_MEDIAVISION_TPORT+3)

// Pro Audio Spectrum Plus
#define  MM_MEDIAVISION_PROAUDIO_PLUS       0x50
#define  MM_PROAUD_PLUS_MIDIOUT             (MM_MEDIAVISION_PROAUDIO_PLUS+1)
#define  MM_PROAUD_PLUS_MIDIIN              (MM_MEDIAVISION_PROAUDIO_PLUS+2)
#define  MM_PROAUD_PLUS_SYNTH               (MM_MEDIAVISION_PROAUDIO_PLUS+3)
#define  MM_PROAUD_PLUS_WAVEOUT             (MM_MEDIAVISION_PROAUDIO_PLUS+4)
#define  MM_PROAUD_PLUS_WAVEIN              (MM_MEDIAVISION_PROAUDIO_PLUS+5)
#define  MM_PROAUD_PLUS_MIXER               (MM_MEDIAVISION_PROAUDIO_PLUS+6)
#define  MM_PROAUD_PLUS_AUX                 (MM_MEDIAVISION_PROAUDIO_PLUS+7)

// Pro Audio Spectrum 16
#define  MM_MEDIAVISION_PROAUDIO_16         0x60
#define  MM_PROAUD_16_MIDIOUT               (MM_MEDIAVISION_PROAUDIO_16+1)
#define  MM_PROAUD_16_MIDIIN                (MM_MEDIAVISION_PROAUDIO_16+2)
#define  MM_PROAUD_16_SYNTH                 (MM_MEDIAVISION_PROAUDIO_16+3)
#define  MM_PROAUD_16_WAVEOUT               (MM_MEDIAVISION_PROAUDIO_16+4)
#define  MM_PROAUD_16_WAVEIN                (MM_MEDIAVISION_PROAUDIO_16+5)
#define  MM_PROAUD_16_MIXER                 (MM_MEDIAVISION_PROAUDIO_16+6)
#define  MM_PROAUD_16_AUX                   (MM_MEDIAVISION_PROAUDIO_16+7)

// Pro Audio Studio 16
#define  MM_MEDIAVISION_PROSTUDIO_16        0x60
#define  MM_STUDIO_16_MIDIOUT               (MM_MEDIAVISION_PROSTUDIO_16+1)
#define  MM_STUDIO_16_MIDIIN                (MM_MEDIAVISION_PROSTUDIO_16+2)
#define  MM_STUDIO_16_SYNTH                 (MM_MEDIAVISION_PROSTUDIO_16+3)
#define  MM_STUDIO_16_WAVEOUT               (MM_MEDIAVISION_PROSTUDIO_16+4)
#define  MM_STUDIO_16_WAVEIN                (MM_MEDIAVISION_PROSTUDIO_16+5)
#define  MM_STUDIO_16_MIXER                 (MM_MEDIAVISION_PROSTUDIO_16+6)
#define  MM_STUDIO_16_AUX                   (MM_MEDIAVISION_PROSTUDIO_16+7)

// CDPC
#define  MM_MEDIAVISION_CDPC                0x70
#define  MM_CDPC_MIDIOUT                    (MM_MEDIAVISION_CDPC+1)
#define  MM_CDPC_MIDIIN                     (MM_MEDIAVISION_CDPC+2)
#define  MM_CDPC_SYNTH                      (MM_MEDIAVISION_CDPC+3)
#define  MM_CDPC_WAVEOUT                    (MM_MEDIAVISION_CDPC+4)
#define  MM_CDPC_WAVEIN                     (MM_MEDIAVISION_CDPC+5)
#define  MM_CDPC_MIXER                      (MM_MEDIAVISION_CDPC+6)
#define  MM_CDPC_AUX                        (MM_MEDIAVISION_CDPC+7)

// Opus MV 1208 Chipsent
#define  MM_MEDIAVISION_OPUS1208            0x80
#define  MM_OPUS401_MIDIOUT                 (MM_MEDIAVISION_OPUS1208+1)
#define  MM_OPUS401_MIDIIN                  (MM_MEDIAVISION_OPUS1208+2)
#define  MM_OPUS1208_SYNTH                  (MM_MEDIAVISION_OPUS1208+3)
#define  MM_OPUS1208_WAVEOUT                (MM_MEDIAVISION_OPUS1208+4)
#define  MM_OPUS1208_WAVEIN                 (MM_MEDIAVISION_OPUS1208+5)
#define  MM_OPUS1208_MIXER                  (MM_MEDIAVISION_OPUS1208+6)
#define  MM_OPUS1208_AUX                    (MM_MEDIAVISION_OPUS1208+7)

// Opus MV 1216 chipset
#define  MM_MEDIAVISION_OPUS1216            0x90
#define  MM_OPUS1216_MIDIOUT                (MM_MEDIAVISION_OPUS1216+1)
#define  MM_OPUS1216_MIDIIN                 (MM_MEDIAVISION_OPUS1216+2)
#define  MM_OPUS1216_SYNTH                  (MM_MEDIAVISION_OPUS1216+3)
#define  MM_OPUS1216_WAVEOUT                (MM_MEDIAVISION_OPUS1216+4)
#define  MM_OPUS1216_WAVEIN                 (MM_MEDIAVISION_OPUS1216+5)
#define  MM_OPUS1216_MIXER                  (MM_MEDIAVISION_OPUS1216+6)
#define  MM_OPUS1216_AUX                    (MM_MEDIAVISION_OPUS1216+7)

/* MM_CYRIX product IDs */
#define  MM_CYRIX_XASYNTH                   1
#define  MM_CYRIX_XAMIDIIN                  2
#define  MM_CYRIX_XAMIDIOUT                 3
#define  MM_CYRIX_XAWAVEIN                  4
#define  MM_CYRIX_XAWAVEOUT                 5
#define  MM_CYRIX_XAAUX                     6
#define  MM_CYRIX_XAMIXER                   7

/* MM_PHILIPS_SPEECH_PROCESSING products IDs */
#define  MM_PHILIPS_ACM_LPCBB               1

/* MM_NETXL product IDs */
#define  MM_NETXL_XLVIDEO                   1

/* MM_ZYXEL product IDs */
#define  MM_ZYXEL_ACM_ADPCM                 1

/* MM_AARDVARK product IDs */
#define  MM_AARDVARK_STUDIO12_WAVEOUT       1
#define  MM_AARDVARK_STUDIO12_WAVEIN        2
#define  MM_AARDVARK_STUDIO88_WAVEOUT       3
#define  MM_AARDVARK_STUDIO88_WAVEIN        4

/* MM_BINTEC product IDs */
#define  MM_BINTEC_TAPI_WAVE                1

/* MM_HEWLETT_PACKARD product IDs */
#define  MM_HEWLETT_PACKARD_CU_CODEC        1

/* MM_MITEL product IDs */
#define  MM_MITEL_TALKTO_LINE_WAVEOUT       100
#define  MM_MITEL_TALKTO_LINE_WAVEIN        101
#define  MM_MITEL_TALKTO_HANDSET_WAVEOUT    102
#define  MM_MITEL_TALKTO_HANDSET_WAVEIN     103
#define  MM_MITEL_TALKTO_BRIDGED_WAVEOUT    104
#define  MM_MITEL_TALKTO_BRIDGED_WAVEIN     105
#define  MM_MITEL_MPA_HANDSET_WAVEOUT       200
#define  MM_MITEL_MPA_HANDSET_WAVEIN        201
#define  MM_MITEL_MPA_HANDSFREE_WAVEOUT     202
#define  MM_MITEL_MPA_HANDSFREE_WAVEIN      203
#define  MM_MITEL_MPA_LINE1_WAVEOUT         204
#define  MM_MITEL_MPA_LINE1_WAVEIN          205
#define  MM_MITEL_MPA_LINE2_WAVEOUT         206
#define  MM_MITEL_MPA_LINE2_WAVEIN          207
#define  MM_MITEL_MEDIAPATH_WAVEOUT         300
#define  MM_MITEL_MEDIAPATH_WAVEIN          301

/*  MM_SNI product IDs */
#define  MM_SNI_ACM_G721                    1

/* MM_EMU product IDs */
#define  MM_EMU_APSSYNTH                    1
#define  MM_EMU_APSMIDIIN                   2
#define  MM_EMU_APSMIDIOUT                  3
#define  MM_EMU_APSWAVEIN                   4
#define  MM_EMU_APSWAVEOUT                  5

/* MM_ARTISOFT product IDs */
#define  MM_ARTISOFT_SBWAVEIN               1       /*  Artisoft sounding Board waveform input  */
#define  MM_ARTISOFT_SBWAVEOUT              2       /*  Artisoft sounding Board waveform output  */

/* MM_TURTLE_BEACH product IDs */
#define  MM_TBS_TROPEZ_WAVEIN               37
#define  MM_TBS_TROPEZ_WAVEOUT              38
#define  MM_TBS_TROPEZ_AUX1                 39
#define  MM_TBS_TROPEZ_AUX2                 40
#define  MM_TBS_TROPEZ_LINE                 41

/* MM_IBM product IDs */
#define  MM_MMOTION_WAVEAUX                 1       /*  IBM M-Motion Auxiliary Device  */
#define  MM_MMOTION_WAVEOUT                 2       /*  IBM M-Motion Waveform output  */
#define  MM_MMOTION_WAVEIN                  3       /*  IBM M-Motion  Waveform Input  */
#define  MM_IBM_PCMCIA_WAVEIN               11      /*  IBM waveform input  */
#define  MM_IBM_PCMCIA_WAVEOUT              12      /*  IBM Waveform output  */
#define  MM_IBM_PCMCIA_SYNTH                13      /*  IBM Midi Synthesis  */
#define  MM_IBM_PCMCIA_MIDIIN               14      /*  IBM external MIDI in  */
#define  MM_IBM_PCMCIA_MIDIOUT              15      /*  IBM external MIDI out  */
#define  MM_IBM_PCMCIA_AUX                  16      /*  IBM auxiliary control  */
#define  MM_IBM_THINKPAD200                 17
#define  MM_IBM_MWAVE_WAVEIN                18
#define  MM_IBM_MWAVE_WAVEOUT               19
#define  MM_IBM_MWAVE_MIXER                 20
#define  MM_IBM_MWAVE_MIDIIN                21
#define  MM_IBM_MWAVE_MIDIOUT               22
#define  MM_IBM_MWAVE_AUX                   23
#define  MM_IBM_WC_MIDIOUT                  30
#define  MM_IBM_WC_WAVEOUT                  31
#define  MM_IBM_WC_MIXEROUT                 33

/* MM_VOCALTEC product IDs */
#define  MM_VOCALTEC_WAVEOUT                1
#define  MM_VOCALTEC_WAVEIN                 2

/* MM_ROLAND product IDs */
#define  MM_ROLAND_RAP10_MIDIOUT            10      /* MM_ROLAND_RAP10 */
#define  MM_ROLAND_RAP10_MIDIIN             11      /* MM_ROLAND_RAP10 */
#define  MM_ROLAND_RAP10_SYNTH              12      /* MM_ROLAND_RAP10 */
#define  MM_ROLAND_RAP10_WAVEOUT            13      /* MM_ROLAND_RAP10 */
#define  MM_ROLAND_RAP10_WAVEIN             14      /* MM_ROLAND_RAP10 */
#define  MM_ROLAND_MPU401_MIDIOUT           15
#define  MM_ROLAND_MPU401_MIDIIN            16
#define  MM_ROLAND_SMPU_MIDIOUTA            17
#define  MM_ROLAND_SMPU_MIDIOUTB            18
#define  MM_ROLAND_SMPU_MIDIINA             19
#define  MM_ROLAND_SMPU_MIDIINB             20
#define  MM_ROLAND_SC7_MIDIOUT              21
#define  MM_ROLAND_SC7_MIDIIN               22
#define  MM_ROLAND_SERIAL_MIDIOUT           23
#define  MM_ROLAND_SERIAL_MIDIIN            24
#define  MM_ROLAND_SCP_MIDIOUT              38
#define  MM_ROLAND_SCP_MIDIIN               39
#define  MM_ROLAND_SCP_WAVEOUT              40
#define  MM_ROLAND_SCP_WAVEIN               41
#define  MM_ROLAND_SCP_MIXER                42
#define  MM_ROLAND_SCP_AUX                  48

/* MM_DSP_SOLUTIONS product IDs */
#define  MM_DSP_SOLUTIONS_WAVEOUT           1
#define  MM_DSP_SOLUTIONS_WAVEIN            2
#define  MM_DSP_SOLUTIONS_SYNTH             3
#define  MM_DSP_SOLUTIONS_AUX               4

/* MM_NEC product IDs */
#define  MM_NEC_73_86_SYNTH                 5
#define  MM_NEC_73_86_WAVEOUT               6
#define  MM_NEC_73_86_WAVEIN                7
#define  MM_NEC_26_SYNTH                    9
#define  MM_NEC_MPU401_MIDIOUT              10
#define  MM_NEC_MPU401_MIDIIN               11
#define  MM_NEC_JOYSTICK                    12

/* MM_WANGLABS product IDs */
#define  MM_WANGLABS_WAVEIN1                1       /*  Input audio wave on CPU board models: Exec 4010, 4030, 3450; PC 251/25c, pc 461/25s , pc 461/33c  */
#define  MM_WANGLABS_WAVEOUT1               2

/* MM_TANDY product IDs */
#define  MM_TANDY_VISWAVEIN                 1
#define  MM_TANDY_VISWAVEOUT                2
#define  MM_TANDY_VISBIOSSYNTH              3
#define  MM_TANDY_SENS_MMAWAVEIN            4
#define  MM_TANDY_SENS_MMAWAVEOUT           5
#define  MM_TANDY_SENS_MMAMIDIIN            6
#define  MM_TANDY_SENS_MMAMIDIOUT           7
#define  MM_TANDY_SENS_VISWAVEOUT           8
#define  MM_TANDY_PSSJWAVEIN                9
#define  MM_TANDY_PSSJWAVEOUT               10

/* MM_ANTEX product IDs */
#define  MM_ANTEX_SX12_WAVEIN               1
#define  MM_ANTEX_SX12_WAVEOUT              2
#define  MM_ANTEX_SX15_WAVEIN               3
#define  MM_ANTEX_SX15_WAVEOUT              4
#define  MM_ANTEX_VP625_WAVEIN              5
#define  MM_ANTEX_VP625_WAVEOUT             6
#define  MM_ANTEX_AUDIOPORT22_WAVEIN        7
#define  MM_ANTEX_AUDIOPORT22_WAVEOUT       8
#define  MM_ANTEX_AUDIOPORT22_FEEDTHRU      9

/* MM_INTEL product IDs */
#define  MM_INTELOPD_WAVEIN                 1       /*  HID2 WaveAudio Driver  */
#define  MM_INTELOPD_WAVEOUT                101     /*  HID2  */
#define  MM_INTELOPD_AUX                    401     /*  HID2 for mixing  */
#define  MM_INTEL_NSPMODEMLINEIN            501
#define  MM_INTEL_NSPMODEMLINEOUT           502

/* MM_VAL product IDs */
#define  MM_VAL_MICROKEY_AP_WAVEIN          1
#define  MM_VAL_MICROKEY_AP_WAVEOUT         2

/* MM_INTERACTIVE product IDs */
#define  MM_INTERACTIVE_WAVEIN              0x45
#define  MM_INTERACTIVE_WAVEOUT             0x45

/* MM_YAMAHA product IDs */
#define  MM_YAMAHA_GSS_SYNTH                0x01
#define  MM_YAMAHA_GSS_WAVEOUT              0x02
#define  MM_YAMAHA_GSS_WAVEIN               0x03
#define  MM_YAMAHA_GSS_MIDIOUT              0x04
#define  MM_YAMAHA_GSS_MIDIIN               0x05
#define  MM_YAMAHA_GSS_AUX                  0x06
#define  MM_YAMAHA_SERIAL_MIDIOUT           0x07
#define  MM_YAMAHA_SERIAL_MIDIIN            0x08
#define  MM_YAMAHA_OPL3SA_WAVEOUT           0x10
#define  MM_YAMAHA_OPL3SA_WAVEIN            0x11
#define  MM_YAMAHA_OPL3SA_FMSYNTH           0x12
#define  MM_YAMAHA_OPL3SA_YSYNTH            0x13
#define  MM_YAMAHA_OPL3SA_MIDIOUT           0x14
#define  MM_YAMAHA_OPL3SA_MIDIIN            0x15
#define  MM_YAMAHA_OPL3SA_MIXER             0x17
#define  MM_YAMAHA_OPL3SA_JOYSTICK          0x18
#define  MM_YAMAHA_YMF724LEG_MIDIOUT        0x19
#define  MM_YAMAHA_YMF724LEG_MIDIIN         0x1a
#define  MM_YAMAHA_YMF724_WAVEOUT           0x1b
#define  MM_YAMAHA_YMF724_WAVEIN            0x1c
#define  MM_YAMAHA_YMF724_MIDIOUT           0x1d
#define  MM_YAMAHA_YMF724_AUX               0x1e
#define  MM_YAMAHA_YMF724_MIXER             0x1f
#define  MM_YAMAHA_YMF724LEG_FMSYNTH        0x20
#define  MM_YAMAHA_YMF724LEG_MIXER          0x21
#define  MM_YAMAHA_SXG_MIDIOUT              0x22
#define  MM_YAMAHA_SXG_WAVEOUT              0x23
#define  MM_YAMAHA_SXG_MIXER                0x24
#define  MM_YAMAHA_ACXG_WAVEIN              0x25
#define  MM_YAMAHA_ACXG_WAVEOUT             0x26
#define  MM_YAMAHA_ACXG_MIDIOUT             0x27
#define  MM_YAMAHA_ACXG_MIXER               0x28
#define  MM_YAMAHA_ACXG_AUX                 0x29

/* MM_EVEREX product IDs */
#define  MM_EVEREX_CARRIER                  1

/* MM_ECHO product IDs */
#define  MM_ECHO_SYNTH                      1
#define  MM_ECHO_WAVEOUT                    2
#define  MM_ECHO_WAVEIN                     3
#define  MM_ECHO_MIDIOUT                    4
#define  MM_ECHO_MIDIIN                     5
#define  MM_ECHO_AUX                        6

/* MM_SIERRA product IDs */
#define  MM_SIERRA_ARIA_MIDIOUT             0x14
#define  MM_SIERRA_ARIA_MIDIIN              0x15
#define  MM_SIERRA_ARIA_SYNTH               0x16
#define  MM_SIERRA_ARIA_WAVEOUT             0x17
#define  MM_SIERRA_ARIA_WAVEIN              0x18
#define  MM_SIERRA_ARIA_AUX                 0x19
#define  MM_SIERRA_ARIA_AUX2                0x20
#define  MM_SIERRA_QUARTET_WAVEIN           0x50
#define  MM_SIERRA_QUARTET_WAVEOUT          0x51
#define  MM_SIERRA_QUARTET_MIDIIN           0x52
#define  MM_SIERRA_QUARTET_MIDIOUT          0x53
#define  MM_SIERRA_QUARTET_SYNTH            0x54
#define  MM_SIERRA_QUARTET_AUX_CD           0x55
#define  MM_SIERRA_QUARTET_AUX_LINE         0x56
#define  MM_SIERRA_QUARTET_AUX_MODEM        0x57
#define  MM_SIERRA_QUARTET_MIXER            0x58

/* MM_CAT product IDs */
#define  MM_CAT_WAVEOUT                     1

/* MM_DSP_GROUP product IDs */
#define  MM_DSP_GROUP_TRUESPEECH            1

/* MM_MELABS product IDs */
#define  MM_MELABS_MIDI2GO                  1

/* MM_ESS product IDs */
#define  MM_ESS_AMWAVEOUT                   0x01
#define  MM_ESS_AMWAVEIN                    0x02
#define  MM_ESS_AMAUX                       0x03
#define  MM_ESS_AMSYNTH                     0x04
#define  MM_ESS_AMMIDIOUT                   0x05
#define  MM_ESS_AMMIDIIN                    0x06
#define  MM_ESS_MIXER                       0x07
#define  MM_ESS_AUX_CD                      0x08
#define  MM_ESS_MPU401_MIDIOUT              0x09
#define  MM_ESS_MPU401_MIDIIN               0x0A
#define  MM_ESS_ES488_WAVEOUT               0x10
#define  MM_ESS_ES488_WAVEIN                0x11
#define  MM_ESS_ES488_MIXER                 0x12
#define  MM_ESS_ES688_WAVEOUT               0x13
#define  MM_ESS_ES688_WAVEIN                0x14
#define  MM_ESS_ES688_MIXER                 0x15
#define  MM_ESS_ES1488_WAVEOUT              0x16
#define  MM_ESS_ES1488_WAVEIN               0x17
#define  MM_ESS_ES1488_MIXER                0x18
#define  MM_ESS_ES1688_WAVEOUT              0x19
#define  MM_ESS_ES1688_WAVEIN               0x1A
#define  MM_ESS_ES1688_MIXER                0x1B
#define  MM_ESS_ES1788_WAVEOUT              0x1C
#define  MM_ESS_ES1788_WAVEIN               0x1D
#define  MM_ESS_ES1788_MIXER                0x1E
#define  MM_ESS_ES1888_WAVEOUT              0x1F
#define  MM_ESS_ES1888_WAVEIN               0x20
#define  MM_ESS_ES1888_MIXER                0x21
#define  MM_ESS_ES1868_WAVEOUT              0x22
#define  MM_ESS_ES1868_WAVEIN               0x23
#define  MM_ESS_ES1868_MIXER                0x24
#define  MM_ESS_ES1878_WAVEOUT              0x25
#define  MM_ESS_ES1878_WAVEIN               0x26
#define  MM_ESS_ES1878_MIXER                0x27

/* MM_CANOPUS product IDs */
#define  MM_CANOPUS_ACM_DVREX               1

/* MM_EPSON product IDs */
#define  MM_EPS_FMSND                       1

/* MM_TRUEVISION product IDs */
#define  MM_TRUEVISION_WAVEIN1              1
#define  MM_TRUEVISION_WAVEOUT1             2

/* MM_AZTECH product IDs */
#define  MM_AZTECH_MIDIOUT                  3
#define  MM_AZTECH_MIDIIN                   4
#define  MM_AZTECH_WAVEIN                   17
#define  MM_AZTECH_WAVEOUT                  18
#define  MM_AZTECH_FMSYNTH                  20
#define  MM_AZTECH_MIXER                    21
#define  MM_AZTECH_PRO16_WAVEIN             33
#define  MM_AZTECH_PRO16_WAVEOUT            34
#define  MM_AZTECH_PRO16_FMSYNTH            38
#define  MM_AZTECH_DSP16_WAVEIN             65
#define  MM_AZTECH_DSP16_WAVEOUT            66
#define  MM_AZTECH_DSP16_FMSYNTH            68
#define  MM_AZTECH_DSP16_WAVESYNTH          70
#define  MM_AZTECH_NOVA16_WAVEIN            71
#define  MM_AZTECH_NOVA16_WAVEOUT           72
#define  MM_AZTECH_NOVA16_MIXER             73
#define  MM_AZTECH_WASH16_WAVEIN            74
#define  MM_AZTECH_WASH16_WAVEOUT           75
#define  MM_AZTECH_WASH16_MIXER             76
#define  MM_AZTECH_AUX_CD                   401
#define  MM_AZTECH_AUX_LINE                 402
#define  MM_AZTECH_AUX_MIC                  403
#define  MM_AZTECH_AUX                      404

/* MM_VIDEOLOGIC product IDs */
#define  MM_VIDEOLOGIC_MSWAVEIN             1
#define  MM_VIDEOLOGIC_MSWAVEOUT            2

/* MM_KORG product IDs */
#define  MM_KORG_PCIF_MIDIOUT               1
#define  MM_KORG_PCIF_MIDIIN                2
#define  MM_KORG_1212IO_MSWAVEIN            3
#define  MM_KORG_1212IO_MSWAVEOUT           4

/* MM_APT product IDs */
#define  MM_APT_ACE100CD                    1

/* MM_ICS product IDs */
#define  MM_ICS_WAVEDECK_WAVEOUT            1       /*  MS WSS compatible card and driver  */
#define  MM_ICS_WAVEDECK_WAVEIN             2
#define  MM_ICS_WAVEDECK_MIXER              3
#define  MM_ICS_WAVEDECK_AUX                4
#define  MM_ICS_WAVEDECK_SYNTH              5
#define  MM_ICS_WAVEDEC_SB_WAVEOUT          6
#define  MM_ICS_WAVEDEC_SB_WAVEIN           7
#define  MM_ICS_WAVEDEC_SB_FM_MIDIOUT       8
#define  MM_ICS_WAVEDEC_SB_MPU401_MIDIOUT   9
#define  MM_ICS_WAVEDEC_SB_MPU401_MIDIIN    10
#define  MM_ICS_WAVEDEC_SB_MIXER            11
#define  MM_ICS_WAVEDEC_SB_AUX              12
#define  MM_ICS_2115_LITE_MIDIOUT           13
#define  MM_ICS_2120_LITE_MIDIOUT           14

/* MM_ITERATEDSYS product IDs */
#define  MM_ITERATEDSYS_FUFCODEC            1

/* MM_METHEUS product IDs */
#define  MM_METHEUS_ZIPPER                  1

/* MM_WINNOV product IDs */
#define  MM_WINNOV_CAVIAR_WAVEIN            1
#define  MM_WINNOV_CAVIAR_WAVEOUT           2
#define  MM_WINNOV_CAVIAR_VIDC              3
#define  MM_WINNOV_CAVIAR_CHAMPAGNE         4       /*  Fourcc is CHAM  */
#define  MM_WINNOV_CAVIAR_YUV8              5       /*  Fourcc is YUV8  */

/* MM_NCR product IDs */
#define  MM_NCR_BA_WAVEIN                   1
#define  MM_NCR_BA_WAVEOUT                  2
#define  MM_NCR_BA_SYNTH                    3
#define  MM_NCR_BA_AUX                      4
#define  MM_NCR_BA_MIXER                    5

/* MM_AST product IDs */
#define  MM_AST_MODEMWAVE_WAVEIN            13
#define  MM_AST_MODEMWAVE_WAVEOUT           14

/* MM_WILLOWPOND product IDs */
#define  MM_WILLOWPOND_FMSYNTH_STEREO       20
#define  MM_WILLOWPOND_MPU401               21
#define  MM_WILLOWPOND_SNDPORT_WAVEIN       100
#define  MM_WILLOWPOND_SNDPORT_WAVEOUT      101
#define  MM_WILLOWPOND_SNDPORT_MIXER        102
#define  MM_WILLOWPOND_SNDPORT_AUX          103
#define  MM_WILLOWPOND_PH_WAVEIN            104
#define  MM_WILLOWPOND_PH_WAVEOUT           105
#define  MM_WILLOWPOND_PH_MIXER             106
#define  MM_WILLOWPOND_PH_AUX               107
#define  MM_WILLOPOND_SNDCOMM_WAVEIN        108
#define  MM_WILLOWPOND_SNDCOMM_WAVEOUT      109
#define  MM_WILLOWPOND_SNDCOMM_MIXER        110
#define  MM_WILLOWPOND_SNDCOMM_AUX          111
#define  MM_WILLOWPOND_GENERIC_WAVEIN       112
#define  MM_WILLOWPOND_GENERIC_WAVEOUT      113
#define  MM_WILLOWPOND_GENERIC_MIXER        114
#define  MM_WILLOWPOND_GENERIC_AUX          115

/* MM_VITEC product IDs */
#define  MM_VITEC_VMAKER                    1
#define  MM_VITEC_VMPRO                     2

/* MM_MOSCOM product IDs */
#define  MM_MOSCOM_VPC2400_IN               1       /*  Four Port Voice Processing / Voice Recognition Board  */
#define  MM_MOSCOM_VPC2400_OUT              2       /*  VPC2400 */

/* MM_SILICONSOFT product IDs */
#define  MM_SILICONSOFT_SC1_WAVEIN          1       /*  Waveform in , high sample rate  */
#define  MM_SILICONSOFT_SC1_WAVEOUT         2       /*  Waveform out , high sample rate  */
#define  MM_SILICONSOFT_SC2_WAVEIN          3       /*  Waveform in 2 channels, high sample rate  */
#define  MM_SILICONSOFT_SC2_WAVEOUT         4       /*  Waveform out 2 channels, high sample rate  */
#define  MM_SILICONSOFT_SOUNDJR2_WAVEOUT    5       /*  Waveform out, self powered, efficient  */
#define  MM_SILICONSOFT_SOUNDJR2PR_WAVEIN   6       /*  Waveform in, self powered, efficient  */
#define  MM_SILICONSOFT_SOUNDJR2PR_WAVEOUT  7       /*  Waveform out 2 channels, self powered, efficient  */
#define  MM_SILICONSOFT_SOUNDJR3_WAVEOUT    8       /*  Waveform in 2 channels, self powered, efficient  */

/* MM_TERRATEC product IDs */
#define  MM_TTEWS_WAVEIN                    1
#define  MM_TTEWS_WAVEOUT                   2
#define  MM_TTEWS_MIDIIN                    3
#define  MM_TTEWS_MIDIOUT                   4
#define  MM_TTEWS_MIDISYNTH                 5
#define  MM_TTEWS_MIDIMONITOR               6
#define  MM_TTEWS_VMIDIIN                   7
#define  MM_TTEWS_VMIDIOUT                  8
#define  MM_TTEWS_AUX                       9
#define  MM_TTEWS_MIXER                     10

/* MM_MEDIASONIC product IDs */
#define  MM_MEDIASONIC_ACM_G723             1
#define  MM_MEDIASONIC_ICOM                 2
#define  MM_ICOM_WAVEIN                     3
#define  MM_ICOM_WAVEOUT                    4
#define  MM_ICOM_MIXER                      5
#define  MM_ICOM_AUX                        6
#define  MM_ICOM_LINE                       7

/*  MM_SANYO product IDs */
#define  MM_SANYO_ACM_LD_ADPCM              1

/* MM_AHEAD product IDs */
#define  MM_AHEAD_MULTISOUND                1
#define  MM_AHEAD_SOUNDBLASTER              2
#define  MM_AHEAD_PROAUDIO                  3
#define  MM_AHEAD_GENERIC                   4

/* MM_OLIVETTI product IDs */
#define  MM_OLIVETTI_WAVEIN                 1
#define  MM_OLIVETTI_WAVEOUT                2
#define  MM_OLIVETTI_MIXER                  3
#define  MM_OLIVETTI_AUX                    4
#define  MM_OLIVETTI_MIDIIN                 5
#define  MM_OLIVETTI_MIDIOUT                6
#define  MM_OLIVETTI_SYNTH                  7
#define  MM_OLIVETTI_JOYSTICK               8
#define  MM_OLIVETTI_ACM_GSM                9
#define  MM_OLIVETTI_ACM_ADPCM              10
#define  MM_OLIVETTI_ACM_CELP               11
#define  MM_OLIVETTI_ACM_SBC                12
#define  MM_OLIVETTI_ACM_OPR                13

/* MM_IOMAGIC product IDs */
#define  MM_IOMAGIC_TEMPO_WAVEOUT           1
#define  MM_IOMAGIC_TEMPO_WAVEIN            2
#define  MM_IOMAGIC_TEMPO_SYNTH             3
#define  MM_IOMAGIC_TEMPO_MIDIOUT           4
#define  MM_IOMAGIC_TEMPO_MXDOUT            5
#define  MM_IOMAGIC_TEMPO_AUXOUT            6

/* MM_MATSUSHITA product IDs */
#define  MM_MATSUSHITA_WAVEIN               1
#define  MM_MATSUSHITA_WAVEOUT              2
#define  MM_MATSUSHITA_FMSYNTH_STEREO       3
#define  MM_MATSUSHITA_MIXER                4
#define  MM_MATSUSHITA_AUX                  5

/* MM_NEWMEDIA product IDs */
#define  MM_NEWMEDIA_WAVJAMMER              1       /*  WSS Compatible sound card.  */

/* MM_LYRRUS product IDs */
#define  MM_LYRRUS_BRIDGE_GUITAR            1

/* MM_OPTI product IDs */
#define  MM_OPTI_M16_FMSYNTH_STEREO         0x0001
#define  MM_OPTI_M16_MIDIIN                 0x0002
#define  MM_OPTI_M16_MIDIOUT                0x0003
#define  MM_OPTI_M16_WAVEIN                 0x0004
#define  MM_OPTI_M16_WAVEOUT                0x0005
#define  MM_OPTI_M16_MIXER                  0x0006
#define  MM_OPTI_M16_AUX                    0x0007
#define  MM_OPTI_P16_FMSYNTH_STEREO         0x0010
#define  MM_OPTI_P16_MIDIIN                 0x0011
#define  MM_OPTI_P16_MIDIOUT                0x0012
#define  MM_OPTI_P16_WAVEIN                 0x0013
#define  MM_OPTI_P16_WAVEOUT                0x0014
#define  MM_OPTI_P16_MIXER                  0x0015
#define  MM_OPTI_P16_AUX                    0x0016
#define  MM_OPTI_M32_WAVEIN                 0x0020
#define  MM_OPTI_M32_WAVEOUT                0x0021
#define  MM_OPTI_M32_MIDIIN                 0x0022
#define  MM_OPTI_M32_MIDIOUT                0x0023
#define  MM_OPTI_M32_SYNTH_STEREO           0x0024
#define  MM_OPTI_M32_MIXER                  0x0025
#define  MM_OPTI_M32_AUX                    0x0026

/* MM_COMPAQ product IDs */
#define  MM_COMPAQ_BB_WAVEIN                1
#define  MM_COMPAQ_BB_WAVEOUT               2
#define  MM_COMPAQ_BB_WAVEAUX               3

/* MM_MPTUS product IDs */
#define  MM_MPTUS_SPWAVEOUT                 1       /* Sound Pallette */

/* MM_LERNOUT_AND_HAUSPIE product IDs */
#define  MM_LERNOUT_ANDHAUSPIE_LHCODECACM   1

/* MM_DIGITAL product IDs */
#define  MM_DIGITAL_AV320_WAVEIN            1       /* Digital Audio Video Compression Board */
#define  MM_DIGITAL_AV320_WAVEOUT           2       /* Digital Audio Video Compression Board */
#define  MM_DIGITAL_ACM_G723                3
#define  MM_DIGITAL_ICM_H263                4
#define  MM_DIGITAL_ICM_H261                5

/* MM_MOTU product IDs */
#define  MM_MOTU_MTP_MIDIOUT_ALL            100
#define  MM_MOTU_MTP_MIDIIN_1               101
#define  MM_MOTU_MTP_MIDIOUT_1              101
#define  MM_MOTU_MTP_MIDIIN_2               102
#define  MM_MOTU_MTP_MIDIOUT_2              102
#define  MM_MOTU_MTP_MIDIIN_3               103
#define  MM_MOTU_MTP_MIDIOUT_3              103
#define  MM_MOTU_MTP_MIDIIN_4               104
#define  MM_MOTU_MTP_MIDIOUT_4              104
#define  MM_MOTU_MTP_MIDIIN_5               105
#define  MM_MOTU_MTP_MIDIOUT_5              105
#define  MM_MOTU_MTP_MIDIIN_6               106
#define  MM_MOTU_MTP_MIDIOUT_6              106
#define  MM_MOTU_MTP_MIDIIN_7               107
#define  MM_MOTU_MTP_MIDIOUT_7              107
#define  MM_MOTU_MTP_MIDIIN_8               108
#define  MM_MOTU_MTP_MIDIOUT_8              108

#define  MM_MOTU_MTPII_MIDIOUT_ALL          200
#define  MM_MOTU_MTPII_MIDIIN_SYNC          200
#define  MM_MOTU_MTPII_MIDIIN_1             201
#define  MM_MOTU_MTPII_MIDIOUT_1            201
#define  MM_MOTU_MTPII_MIDIIN_2             202
#define  MM_MOTU_MTPII_MIDIOUT_2            202
#define  MM_MOTU_MTPII_MIDIIN_3             203
#define  MM_MOTU_MTPII_MIDIOUT_3            203
#define  MM_MOTU_MTPII_MIDIIN_4             204
#define  MM_MOTU_MTPII_MIDIOUT_4            204
#define  MM_MOTU_MTPII_MIDIIN_5             205
#define  MM_MOTU_MTPII_MIDIOUT_5            205
#define  MM_MOTU_MTPII_MIDIIN_6             206
#define  MM_MOTU_MTPII_MIDIOUT_6            206
#define  MM_MOTU_MTPII_MIDIIN_7             207
#define  MM_MOTU_MTPII_MIDIOUT_7            207
#define  MM_MOTU_MTPII_MIDIIN_8             208
#define  MM_MOTU_MTPII_MIDIOUT_8            208
#define  MM_MOTU_MTPII_NET_MIDIIN_1         209
#define  MM_MOTU_MTPII_NET_MIDIOUT_1        209
#define  MM_MOTU_MTPII_NET_MIDIIN_2         210
#define  MM_MOTU_MTPII_NET_MIDIOUT_2        210
#define  MM_MOTU_MTPII_NET_MIDIIN_3         211
#define  MM_MOTU_MTPII_NET_MIDIOUT_3        211
#define  MM_MOTU_MTPII_NET_MIDIIN_4         212
#define  MM_MOTU_MTPII_NET_MIDIOUT_4        212
#define  MM_MOTU_MTPII_NET_MIDIIN_5         213
#define  MM_MOTU_MTPII_NET_MIDIOUT_5        213
#define  MM_MOTU_MTPII_NET_MIDIIN_6         214
#define  MM_MOTU_MTPII_NET_MIDIOUT_6        214
#define  MM_MOTU_MTPII_NET_MIDIIN_7         215
#define  MM_MOTU_MTPII_NET_MIDIOUT_7        215
#define  MM_MOTU_MTPII_NET_MIDIIN_8         216
#define  MM_MOTU_MTPII_NET_MIDIOUT_8        216

#define  MM_MOTU_MXP_MIDIIN_MIDIOUT_ALL     300
#define  MM_MOTU_MXP_MIDIIN_SYNC            300
#define  MM_MOTU_MXP_MIDIIN_MIDIIN_1        301
#define  MM_MOTU_MXP_MIDIIN_MIDIOUT_1       301
#define  MM_MOTU_MXP_MIDIIN_MIDIIN_2        302
#define  MM_MOTU_MXP_MIDIIN_MIDIOUT_2       302
#define  MM_MOTU_MXP_MIDIIN_MIDIIN_3        303
#define  MM_MOTU_MXP_MIDIIN_MIDIOUT_3       303
#define  MM_MOTU_MXP_MIDIIN_MIDIIN_4        304
#define  MM_MOTU_MXP_MIDIIN_MIDIOUT_4       304
#define  MM_MOTU_MXP_MIDIIN_MIDIIN_5        305
#define  MM_MOTU_MXP_MIDIIN_MIDIOUT_5       305
#define  MM_MOTU_MXP_MIDIIN_MIDIIN_6        306
#define  MM_MOTU_MXP_MIDIIN_MIDIOUT_6       306

#define  MM_MOTU_MXPMPU_MIDIOUT_ALL         400
#define  MM_MOTU_MXPMPU_MIDIIN_SYNC         400
#define  MM_MOTU_MXPMPU_MIDIIN_1            401
#define  MM_MOTU_MXPMPU_MIDIOUT_1           401
#define  MM_MOTU_MXPMPU_MIDIIN_2            402
#define  MM_MOTU_MXPMPU_MIDIOUT_2           402
#define  MM_MOTU_MXPMPU_MIDIIN_3            403
#define  MM_MOTU_MXPMPU_MIDIOUT_3           403
#define  MM_MOTU_MXPMPU_MIDIIN_4            404
#define  MM_MOTU_MXPMPU_MIDIOUT_4           404
#define  MM_MOTU_MXPMPU_MIDIIN_5            405
#define  MM_MOTU_MXPMPU_MIDIOUT_5           405
#define  MM_MOTU_MXPMPU_MIDIIN_6            406
#define  MM_MOTU_MXPMPU_MIDIOUT_6           406

#define  MM_MOTU_MXN_MIDIOUT_ALL            500
#define  MM_MOTU_MXN_MIDIIN_SYNC            500
#define  MM_MOTU_MXN_MIDIIN_1               501
#define  MM_MOTU_MXN_MIDIOUT_1              501
#define  MM_MOTU_MXN_MIDIIN_2               502
#define  MM_MOTU_MXN_MIDIOUT_2              502
#define  MM_MOTU_MXN_MIDIIN_3               503
#define  MM_MOTU_MXN_MIDIOUT_3              503
#define  MM_MOTU_MXN_MIDIIN_4               504
#define  MM_MOTU_MXN_MIDIOUT_4              504

#define  MM_MOTU_FLYER_MIDI_IN_SYNC         600
#define  MM_MOTU_FLYER_MIDI_IN_A            601
#define  MM_MOTU_FLYER_MIDI_OUT_A           601
#define  MM_MOTU_FLYER_MIDI_IN_B            602
#define  MM_MOTU_FLYER_MIDI_OUT_B           602

#define  MM_MOTU_PKX_MIDI_IN_SYNC           700
#define  MM_MOTU_PKX_MIDI_IN_A              701
#define  MM_MOTU_PKX_MIDI_OUT_A             701
#define  MM_MOTU_PKX_MIDI_IN_B              702
#define  MM_MOTU_PKX_MIDI_OUT_B             702

#define  MM_MOTU_DTX_MIDI_IN_SYNC           800
#define  MM_MOTU_DTX_MIDI_IN_A              801
#define  MM_MOTU_DTX_MIDI_OUT_A             801
#define  MM_MOTU_DTX_MIDI_IN_B              802
#define  MM_MOTU_DTX_MIDI_OUT_B             802

#define  MM_MOTU_MTPAV_MIDIOUT_ALL          900
#define  MM_MOTU_MTPAV_MIDIIN_SYNC          900
#define  MM_MOTU_MTPAV_MIDIIN_1             901
#define  MM_MOTU_MTPAV_MIDIOUT_1            901
#define  MM_MOTU_MTPAV_MIDIIN_2             902
#define  MM_MOTU_MTPAV_MIDIOUT_2            902
#define  MM_MOTU_MTPAV_MIDIIN_3             903
#define  MM_MOTU_MTPAV_MIDIOUT_3            903
#define  MM_MOTU_MTPAV_MIDIIN_4             904
#define  MM_MOTU_MTPAV_MIDIOUT_4            904
#define  MM_MOTU_MTPAV_MIDIIN_5             905
#define  MM_MOTU_MTPAV_MIDIOUT_5            905
#define  MM_MOTU_MTPAV_MIDIIN_6             906
#define  MM_MOTU_MTPAV_MIDIOUT_6            906
#define  MM_MOTU_MTPAV_MIDIIN_7             907
#define  MM_MOTU_MTPAV_MIDIOUT_7            907
#define  MM_MOTU_MTPAV_MIDIIN_8             908
#define  MM_MOTU_MTPAV_MIDIOUT_8            908
#define  MM_MOTU_MTPAV_NET_MIDIIN_1         909
#define  MM_MOTU_MTPAV_NET_MIDIOUT_1        909
#define  MM_MOTU_MTPAV_NET_MIDIIN_2         910
#define  MM_MOTU_MTPAV_NET_MIDIOUT_2        910
#define  MM_MOTU_MTPAV_NET_MIDIIN_3         911
#define  MM_MOTU_MTPAV_NET_MIDIOUT_3        911
#define  MM_MOTU_MTPAV_NET_MIDIIN_4         912
#define  MM_MOTU_MTPAV_NET_MIDIOUT_4        912
#define  MM_MOTU_MTPAV_NET_MIDIIN_5         913
#define  MM_MOTU_MTPAV_NET_MIDIOUT_5        913
#define  MM_MOTU_MTPAV_NET_MIDIIN_6         914
#define  MM_MOTU_MTPAV_NET_MIDIOUT_6        914
#define  MM_MOTU_MTPAV_NET_MIDIIN_7         915
#define  MM_MOTU_MTPAV_NET_MIDIOUT_7        915
#define  MM_MOTU_MTPAV_NET_MIDIIN_8         916
#define  MM_MOTU_MTPAV_NET_MIDIOUT_8        916
#define  MM_MOTU_MTPAV_MIDIIN_ADAT          917
#define  MM_MOTU_MTPAV_MIDIOUT_ADAT         917
#define  MM_MOTU_MXPXT_MIDIIN_SYNC          1000
#define  MM_MOTU_MXPXT_MIDIOUT_ALL          1000
#define  MM_MOTU_MXPXT_MIDIIN_1             1001
#define  MM_MOTU_MXPXT_MIDIOUT_1            1001
#define  MM_MOTU_MXPXT_MIDIOUT_2            1002
#define  MM_MOTU_MXPXT_MIDIIN_2             1002
#define  MM_MOTU_MXPXT_MIDIIN_3             1003
#define  MM_MOTU_MXPXT_MIDIOUT_3            1003
#define  MM_MOTU_MXPXT_MIDIIN_4             1004
#define  MM_MOTU_MXPXT_MIDIOUT_4            1004
#define  MM_MOTU_MXPXT_MIDIIN_5             1005
#define  MM_MOTU_MXPXT_MIDIOUT_5            1005
#define  MM_MOTU_MXPXT_MIDIOUT_6            1006
#define  MM_MOTU_MXPXT_MIDIIN_6             1006
#define  MM_MOTU_MXPXT_MIDIOUT_7            1007
#define  MM_MOTU_MXPXT_MIDIIN_7             1007
#define  MM_MOTU_MXPXT_MIDIOUT_8            1008
#define  MM_MOTU_MXPXT_MIDIIN_8             1008

/* MM_WORKBIT product IDs */
#define  MM_WORKBIT_MIXER                   1      /* Harmony Mixer */
#define  MM_WORKBIT_WAVEOUT                 2      /* Harmony Mixer */
#define  MM_WORKBIT_WAVEIN                  3      /* Harmony Mixer */
#define  MM_WORKBIT_MIDIIN                  4      /* Harmony Mixer */
#define  MM_WORKBIT_MIDIOUT                 5      /* Harmony Mixer */
#define  MM_WORKBIT_FMSYNTH                 6      /* Harmony Mixer */
#define  MM_WORKBIT_AUX                     7      /* Harmony Mixer */
#define  MM_WORKBIT_JOYSTICK                8

/* MM_OSITECH product IDs */
#define  MM_OSITECH_TRUMPCARD               1       /* Trumpcard */

/* MM_MIRO product IDs */
#define  MM_MIRO_MOVIEPRO                   1       /* miroMOVIE pro */
#define  MM_MIRO_VIDEOD1                    2       /* miroVIDEO D1 */
#define  MM_MIRO_VIDEODC1TV                 3       /* miroVIDEO DC1 tv */
#define  MM_MIRO_VIDEOTD                    4       /* miroVIDEO 10/20 TD */
#define  MM_MIRO_DC30_WAVEOUT               5
#define  MM_MIRO_DC30_WAVEIN                6
#define  MM_MIRO_DC30_MIX                   7

/* MM_ISOLUTION product IDs */
#define  MM_ISOLUTION_PASCAL                1

/* MM_ROCKWELL product IDs */
#define  MM_VOICEMIXER                      1
#define  ROCKWELL_WA1_WAVEIN                100
#define  ROCKWELL_WA1_WAVEOUT               101
#define  ROCKWELL_WA1_SYNTH                 102
#define  ROCKWELL_WA1_MIXER                 103
#define  ROCKWELL_WA1_MPU401_IN             104
#define  ROCKWELL_WA1_MPU401_OUT            105
#define  ROCKWELL_WA2_WAVEIN                200
#define  ROCKWELL_WA2_WAVEOUT               201
#define  ROCKWELL_WA2_SYNTH                 202
#define  ROCKWELL_WA2_MIXER                 203
#define  ROCKWELL_WA2_MPU401_IN             204
#define  ROCKWELL_WA2_MPU401_OUT            205

/* MM_VOXWARE product IDs */
#define  MM_VOXWARE_CODEC                   1

/* MM_NORTHERN_TELECOM product IDs */
#define  MM_NORTEL_MPXAC_WAVEIN             1       /* MPX Audio Card Wave Input Device */
#define  MM_NORTEL_MPXAC_WAVEOUT            2       /* MPX Audio Card Wave Output Device */

/* MM_ADDX product IDs */
#define  MM_ADDX_PCTV_DIGITALMIX            1       /* MM_ADDX_PCTV_DIGITALMIX */
#define  MM_ADDX_PCTV_WAVEIN                2       /* MM_ADDX_PCTV_WAVEIN */
#define  MM_ADDX_PCTV_WAVEOUT               3       /* MM_ADDX_PCTV_WAVEOUT */
#define  MM_ADDX_PCTV_MIXER                 4       /* MM_ADDX_PCTV_MIXER */
#define  MM_ADDX_PCTV_AUX_CD                5       /* MM_ADDX_PCTV_AUX_CD */
#define  MM_ADDX_PCTV_AUX_LINE              6       /* MM_ADDX_PCTV_AUX_LINE */

/* MM_WILDCAT product IDs */
#define  MM_WILDCAT_AUTOSCOREMIDIIN         1       /* Autoscore */

/* MM_RHETOREX product IDs */
#define  MM_RHETOREX_WAVEIN                 1
#define  MM_RHETOREX_WAVEOUT                2

/* MM_BROOKTREE product IDs */
#define  MM_BTV_WAVEIN                      1       /* Brooktree PCM Wave Audio In */
#define  MM_BTV_WAVEOUT                     2       /* Brooktree PCM Wave Audio Out */
#define  MM_BTV_MIDIIN                      3       /* Brooktree MIDI In */
#define  MM_BTV_MIDIOUT                     4       /* Brooktree MIDI out */
#define  MM_BTV_MIDISYNTH                   5       /* Brooktree MIDI FM synth */
#define  MM_BTV_AUX_LINE                    6       /* Brooktree Line Input */
#define  MM_BTV_AUX_MIC                     7       /* Brooktree Microphone Input */
#define  MM_BTV_AUX_CD                      8       /* Brooktree CD Input */
#define  MM_BTV_DIGITALIN                   9       /* Brooktree PCM Wave in with subcode information */
#define  MM_BTV_DIGITALOUT                  10      /* Brooktree PCM Wave out with subcode information */
#define  MM_BTV_MIDIWAVESTREAM              11      /* Brooktree WaveStream */
#define  MM_BTV_MIXER                       12      /* Brooktree WSS Mixer driver */

/* MM_ENSONIQ product IDs */
#define  MM_ENSONIQ_SOUNDSCAPE              0x10    /* ENSONIQ Soundscape */
#define  MM_SOUNDSCAPE_WAVEOUT              MM_ENSONIQ_SOUNDSCAPE+1
#define  MM_SOUNDSCAPE_WAVEOUT_AUX          MM_ENSONIQ_SOUNDSCAPE+2
#define  MM_SOUNDSCAPE_WAVEIN               MM_ENSONIQ_SOUNDSCAPE+3
#define  MM_SOUNDSCAPE_MIDIOUT              MM_ENSONIQ_SOUNDSCAPE+4
#define  MM_SOUNDSCAPE_MIDIIN               MM_ENSONIQ_SOUNDSCAPE+5
#define  MM_SOUNDSCAPE_SYNTH                MM_ENSONIQ_SOUNDSCAPE+6
#define  MM_SOUNDSCAPE_MIXER                MM_ENSONIQ_SOUNDSCAPE+7
#define  MM_SOUNDSCAPE_AUX                  MM_ENSONIQ_SOUNDSCAPE+8

/* MM_NVIDIA product IDs */
#define  MM_NVIDIA_WAVEOUT                  1
#define  MM_NVIDIA_WAVEIN                   2
#define  MM_NVIDIA_MIDIOUT                  3
#define  MM_NVIDIA_MIDIIN                   4
#define  MM_NVIDIA_GAMEPORT                 5
#define  MM_NVIDIA_MIXER                    6
#define  MM_NVIDIA_AUX                      7

/* MM_OKSORI product IDs */
#define  MM_OKSORI_BASE                     0                      /* Oksori Base */
#define  MM_OKSORI_OSR8_WAVEOUT             MM_OKSORI_BASE+1       /* Oksori 8bit Wave out */
#define  MM_OKSORI_OSR8_WAVEIN              MM_OKSORI_BASE+2       /* Oksori 8bit Wave in */
#define  MM_OKSORI_OSR16_WAVEOUT            MM_OKSORI_BASE+3       /* Oksori 16 bit Wave out */
#define  MM_OKSORI_OSR16_WAVEIN             MM_OKSORI_BASE+4       /* Oksori 16 bit Wave in */
#define  MM_OKSORI_FM_OPL4                  MM_OKSORI_BASE+5       /* Oksori FM Synth Yamaha OPL4 */
#define  MM_OKSORI_MIX_MASTER               MM_OKSORI_BASE+6       /* Oksori DSP Mixer - Master Volume */
#define  MM_OKSORI_MIX_WAVE                 MM_OKSORI_BASE+7       /* Oksori DSP Mixer - Wave Volume */
#define  MM_OKSORI_MIX_FM                   MM_OKSORI_BASE+8       /* Oksori DSP Mixer - FM Volume */
#define  MM_OKSORI_MIX_LINE                 MM_OKSORI_BASE+9       /* Oksori DSP Mixer - Line Volume */
#define  MM_OKSORI_MIX_CD                   MM_OKSORI_BASE+10      /* Oksori DSP Mixer - CD Volume */
#define  MM_OKSORI_MIX_MIC                  MM_OKSORI_BASE+11      /* Oksori DSP Mixer - MIC Volume */
#define  MM_OKSORI_MIX_ECHO                 MM_OKSORI_BASE+12      /* Oksori DSP Mixer - Echo Volume */
#define  MM_OKSORI_MIX_AUX1                 MM_OKSORI_BASE+13      /* Oksori AD1848 - AUX1 Volume */
#define  MM_OKSORI_MIX_LINE1                MM_OKSORI_BASE+14      /* Oksori AD1848 - LINE1 Volume */
#define  MM_OKSORI_EXT_MIC1                 MM_OKSORI_BASE+15      /* Oksori External - One Mic Connect */
#define  MM_OKSORI_EXT_MIC2                 MM_OKSORI_BASE+16      /* Oksori External - Two Mic Connect */
#define  MM_OKSORI_MIDIOUT                  MM_OKSORI_BASE+17      /* Oksori MIDI Out Device */
#define  MM_OKSORI_MIDIIN                   MM_OKSORI_BASE+18      /* Oksori MIDI In Device */
#define  MM_OKSORI_MPEG_CDVISION            MM_OKSORI_BASE+19      /* Oksori CD-Vision MPEG Decoder */

/* MM_DIACOUSTICS product IDs */
#define  MM_DIACOUSTICS_DRUM_ACTION         1       /* Drum Action */

/* MM_KAY_ELEMETRICS product IDs */
#define  MM_KAY_ELEMETRICS_CSL              0x4300
#define  MM_KAY_ELEMETRICS_CSL_DAT          0x4308
#define  MM_KAY_ELEMETRICS_CSL_4CHANNEL     0x4309

/* MM_CRYSTAL product IDs */
#define  MM_CRYSTAL_CS4232_WAVEIN           1
#define  MM_CRYSTAL_CS4232_WAVEOUT          2
#define  MM_CRYSTAL_CS4232_WAVEMIXER        3
#define  MM_CRYSTAL_CS4232_WAVEAUX_AUX1     4
#define  MM_CRYSTAL_CS4232_WAVEAUX_AUX2     5
#define  MM_CRYSTAL_CS4232_WAVEAUX_LINE     6
#define  MM_CRYSTAL_CS4232_WAVEAUX_MONO     7
#define  MM_CRYSTAL_CS4232_WAVEAUX_MASTER   8
#define  MM_CRYSTAL_CS4232_MIDIIN           9
#define  MM_CRYSTAL_CS4232_MIDIOUT          10
#define  MM_CRYSTAL_CS4232_INPUTGAIN_AUX1   13
#define  MM_CRYSTAL_CS4232_INPUTGAIN_LOOP   14
#define  MM_CRYSTAL_SOUND_FUSION_WAVEIN     21
#define  MM_CRYSTAL_SOUND_FUSION_WAVEOUT    22
#define  MM_CRYSTAL_SOUND_FUSION_MIXER      23
#define  MM_CRYSTAL_SOUND_FUSION_MIDIIN     24
#define  MM_CRYSTAL_SOUND_FUSION_MIDIOUT    25
#define  MM_CRYSTAL_SOUND_FUSION_JOYSTICK   26

/* MM_QUARTERDECK product IDs */
#define  MM_QUARTERDECK_LHWAVEIN            0      /* Quarterdeck L&H Codec Wave In */
#define  MM_QUARTERDECK_LHWAVEOUT           1      /* Quarterdeck L&H Codec Wave Out */

/* MM_TDK product IDs */
#define  MM_TDK_MW_MIDI_SYNTH               1
#define  MM_TDK_MW_MIDI_IN                  2
#define  MM_TDK_MW_MIDI_OUT                 3
#define  MM_TDK_MW_WAVE_IN                  4
#define  MM_TDK_MW_WAVE_OUT                 5
#define  MM_TDK_MW_AUX                      6
#define  MM_TDK_MW_MIXER                    10
#define  MM_TDK_MW_AUX_MASTER               100
#define  MM_TDK_MW_AUX_BASS                 101
#define  MM_TDK_MW_AUX_TREBLE               102
#define  MM_TDK_MW_AUX_MIDI_VOL             103
#define  MM_TDK_MW_AUX_WAVE_VOL             104
#define  MM_TDK_MW_AUX_WAVE_RVB             105
#define  MM_TDK_MW_AUX_WAVE_CHR             106
#define  MM_TDK_MW_AUX_VOL                  107
#define  MM_TDK_MW_AUX_RVB                  108
#define  MM_TDK_MW_AUX_CHR                  109

/* MM_DIGITAL_AUDIO_LABS product IDs */
#define  MM_DIGITAL_AUDIO_LABS_TC           0x01
#define  MM_DIGITAL_AUDIO_LABS_DOC          0x02
#define  MM_DIGITAL_AUDIO_LABS_V8           0x10
#define  MM_DIGITAL_AUDIO_LABS_CPRO         0x11
#define  MM_DIGITAL_AUDIO_LABS_VP           0x12
#define  MM_DIGITAL_AUDIO_LABS_CDLX         0x13
#define  MM_DIGITAL_AUDIO_LABS_CTDIF        0x14

/* MM_SEERSYS product IDs */
#define  MM_SEERSYS_SEERSYNTH               1
#define  MM_SEERSYS_SEERWAVE                2
#define  MM_SEERSYS_SEERMIX                 3
#define  MM_SEERSYS_WAVESYNTH               4
#define  MM_SEERSYS_WAVESYNTH_WG            5
#define  MM_SEERSYS_REALITY                 6

/* MM_OSPREY product IDs */
#define  MM_OSPREY_1000WAVEIN               1
#define  MM_OSPREY_1000WAVEOUT              2

/* MM_SOUNDESIGNS product IDs */
#define  MM_SOUNDESIGNS_WAVEIN              1
#define  MM_SOUNDESIGNS_WAVEOUT             2

/* MM_SPECTRUM_SIGNAL_PROCESSING product IDs */
#define  MM_SSP_SNDFESWAVEIN                1       /* Sound Festa Wave In Device */
#define  MM_SSP_SNDFESWAVEOUT               2       /* Sound Festa Wave Out Device */
#define  MM_SSP_SNDFESMIDIIN                3       /* Sound Festa MIDI In Device */
#define  MM_SSP_SNDFESMIDIOUT               4       /* Sound Festa MIDI Out Device */
#define  MM_SSP_SNDFESSYNTH                 5       /* Sound Festa MIDI Synth Device */
#define  MM_SSP_SNDFESMIX                   6       /* Sound Festa Mixer Device */
#define  MM_SSP_SNDFESAUX                   7       /* Sound Festa Auxilliary Device */

/* MM_ECS product IDs */
#define  MM_ECS_AADF_MIDI_IN                10
#define  MM_ECS_AADF_MIDI_OUT               11
#define  MM_ECS_AADF_WAVE2MIDI_IN           12

/* MM_AMD product IDs */
#define  MM_AMD_INTERWAVE_WAVEIN            1
#define  MM_AMD_INTERWAVE_WAVEOUT           2
#define  MM_AMD_INTERWAVE_SYNTH             3
#define  MM_AMD_INTERWAVE_MIXER1            4
#define  MM_AMD_INTERWAVE_MIXER2            5
#define  MM_AMD_INTERWAVE_JOYSTICK          6
#define  MM_AMD_INTERWAVE_EX_CD             7
#define  MM_AMD_INTERWAVE_MIDIIN            8
#define  MM_AMD_INTERWAVE_MIDIOUT           9
#define  MM_AMD_INTERWAVE_AUX1              10
#define  MM_AMD_INTERWAVE_AUX2              11
#define  MM_AMD_INTERWAVE_AUX_MIC           12
#define  MM_AMD_INTERWAVE_AUX_CD            13
#define  MM_AMD_INTERWAVE_MONO_IN           14
#define  MM_AMD_INTERWAVE_MONO_OUT          15
#define  MM_AMD_INTERWAVE_EX_TELEPHONY      16
#define  MM_AMD_INTERWAVE_WAVEOUT_BASE      17
#define  MM_AMD_INTERWAVE_WAVEOUT_TREBLE    18
#define  MM_AMD_INTERWAVE_STEREO_ENHANCED   19

/* MM_COREDYNAMICS product IDs */
#define  MM_COREDYNAMICS_DYNAMIXHR          1       /* DynaMax Hi-Rez */
#define  MM_COREDYNAMICS_DYNASONIX_SYNTH    2       /* DynaSonix */
#define  MM_COREDYNAMICS_DYNASONIX_MIDI_IN  3
#define  MM_COREDYNAMICS_DYNASONIX_MIDI_OUT 4
#define  MM_COREDYNAMICS_DYNASONIX_WAVE_IN  5
#define  MM_COREDYNAMICS_DYNASONIX_WAVE_OUT 6
#define  MM_COREDYNAMICS_DYNASONIX_AUDIO_IN 7
#define  MM_COREDYNAMICS_DYNASONIX_AUDIO_OUT    8
#define  MM_COREDYNAMICS_DYNAGRAFX_VGA      9       /* DynaGrfx */
#define  MM_COREDYNAMICS_DYNAGRAFX_WAVE_IN  10
#define  MM_COREDYNAMICS_DYNAGRAFX_WAVE_OUT 11

/* MM_CANAM product IDs */
#define  MM_CANAM_CBXWAVEOUT                1
#define  MM_CANAM_CBXWAVEIN                 2

/* MM_SOFTSOUND product IDs */
#define  MM_SOFTSOUND_CODEC                 1

/* MM_NORRIS product IDs */
#define  MM_NORRIS_VOICELINK                1

/* MM_DDD product IDs */
#define  MM_DDD_MIDILINK_MIDIIN             1
#define  MM_DDD_MIDILINK_MIDIOUT            2

/* MM_EUPHONICS product IDs */
#define  MM_EUPHONICS_AUX_CD                1
#define  MM_EUPHONICS_AUX_LINE              2
#define  MM_EUPHONICS_AUX_MASTER            3
#define  MM_EUPHONICS_AUX_MIC               4
#define  MM_EUPHONICS_AUX_MIDI              5
#define  MM_EUPHONICS_AUX_WAVE              6
#define  MM_EUPHONICS_FMSYNTH_MONO          7
#define  MM_EUPHONICS_FMSYNTH_STEREO        8
#define  MM_EUPHONICS_MIDIIN                9
#define  MM_EUPHONICS_MIDIOUT               10
#define  MM_EUPHONICS_MIXER                 11
#define  MM_EUPHONICS_WAVEIN                12
#define  MM_EUPHONICS_WAVEOUT               13
#define  MM_EUPHONICS_EUSYNTH               14

/* MM_CRYSTAL_NET product IDs */
#define  CRYSTAL_NET_SFM_CODEC              1

/* MM_CHROMATIC product IDs */
#define  MM_CHROMATIC_M1                    0x0001
#define  MM_CHROMATIC_M1_WAVEIN             0x0002
#define  MM_CHROMATIC_M1_WAVEOUT            0x0003
#define  MM_CHROMATIC_M1_FMSYNTH            0x0004
#define  MM_CHROMATIC_M1_MIXER              0x0005
#define  MM_CHROMATIC_M1_AUX                0x0006
#define  MM_CHROMATIC_M1_AUX_CD             0x0007
#define  MM_CHROMATIC_M1_MIDIIN             0x0008
#define  MM_CHROMATIC_M1_MIDIOUT            0x0009
#define  MM_CHROMATIC_M1_WTSYNTH            0x0010
#define  MM_CHROMATIC_M1_MPEGWAVEIN         0x0011
#define  MM_CHROMATIC_M1_MPEGWAVEOUT        0x0012
#define  MM_CHROMATIC_M2                    0x0013
#define  MM_CHROMATIC_M2_WAVEIN             0x0014
#define  MM_CHROMATIC_M2_WAVEOUT            0x0015
#define  MM_CHROMATIC_M2_FMSYNTH            0x0016
#define  MM_CHROMATIC_M2_MIXER              0x0017
#define  MM_CHROMATIC_M2_AUX                0x0018
#define  MM_CHROMATIC_M2_AUX_CD             0x0019
#define  MM_CHROMATIC_M2_MIDIIN             0x0020
#define  MM_CHROMATIC_M2_MIDIOUT            0x0021
#define  MM_CHROMATIC_M2_WTSYNTH            0x0022
#define  MM_CHROMATIC_M2_MPEGWAVEIN         0x0023
#define  MM_CHROMATIC_M2_MPEGWAVEOUT        0x0024

/* MM_VIENNASYS product IDs */
#define  MM_VIENNASYS_TSP_WAVE_DRIVER       1

/* MM_CONNECTIX product IDs */
#define  MM_CONNECTIX_VIDEC_CODEC           1

/* MM_GADGETLABS product IDs */
#define  MM_GADGETLABS_WAVE44_WAVEIN        1
#define  MM_GADGETLABS_WAVE44_WAVEOUT       2
#define  MM_GADGETLABS_WAVE42_WAVEIN        3
#define  MM_GADGETLABS_WAVE42_WAVEOUT       4
#define  MM_GADGETLABS_WAVE4_MIDIIN         5
#define  MM_GADGETLABS_WAVE4_MIDIOUT        6

/* MM_FRONTIER product IDs */
#define  MM_FRONTIER_WAVECENTER_MIDIIN      1       /* WaveCenter */
#define  MM_FRONTIER_WAVECENTER_MIDIOUT     2
#define  MM_FRONTIER_WAVECENTER_WAVEIN      3
#define  MM_FRONTIER_WAVECENTER_WAVEOUT     4

/* MM_VIONA product IDs */
#define  MM_VIONA_QVINPCI_MIXER             1       /* Q-Motion PCI II/Bravado 2000 */
#define  MM_VIONA_QVINPCI_WAVEIN            2
#define  MM_VIONAQVINPCI_WAVEOUT            3
#define  MM_VIONA_BUSTER_MIXER              4       /* Buster */
#define  MM_VIONA_CINEMASTER_MIXER          5       /* Cinemaster */
#define  MM_VIONA_CONCERTO_MIXER            6       /* Concerto */

/* MM_CASIO product IDs */
#define  MM_CASIO_WP150_MIDIOUT             1       /* wp150 */
#define  MM_CASIO_WP150_MIDIIN              2
#define  MM_CASIO_LSG_MIDIOUT               3

/* MM_DIAMONDMM product IDs */
#define  MM_DIMD_PLATFORM                   0       /* Freedom Audio */
#define  MM_DIMD_DIRSOUND                   1
#define  MM_DIMD_VIRTMPU                    2
#define  MM_DIMD_VIRTSB                     3
#define  MM_DIMD_VIRTJOY                    4
#define  MM_DIMD_WAVEIN                     5
#define  MM_DIMD_WAVEOUT                    6
#define  MM_DIMD_MIDIIN                     7
#define  MM_DIMD_MIDIOUT                    8
#define  MM_DIMD_AUX_LINE                   9
#define  MM_DIMD_MIXER                      10
#define  MM_DIMD_WSS_WAVEIN                 14
#define  MM_DIMD_WSS_WAVEOUT                15
#define  MM_DIMD_WSS_MIXER                  17
#define  MM_DIMD_WSS_AUX                    21
#define  MM_DIMD_WSS_SYNTH                  76

/* MM_S3 product IDs */
#define  MM_S3_WAVEOUT                      1
#define  MM_S3_WAVEIN                       2
#define  MM_S3_MIDIOUT                      3
#define  MM_S3_MIDIIN                       4
#define  MM_S3_FMSYNTH                      5
#define  MM_S3_MIXER                        6
#define  MM_S3_AUX                          7

/* MM_VANKOEVERING product IDs */
#define  MM_VKC_MPU401_MIDIIN               0x0100
#define  MM_VKC_SERIAL_MIDIIN               0x0101
#define  MM_VKC_MPU401_MIDIOUT              0x0200
#define  MM_VKC_SERIAL_MIDIOUT              0x0201

/* MM_ZEFIRO product IDs */
#define  MM_ZEFIRO_ZA2                      2

/* MM_FRAUNHOFER_IIS product IDs */
#define  MM_FHGIIS_MPEGLAYER3               10

/* MM_QUICKNET product IDs */
#define  MM_QUICKNET_PJWAVEIN               1
#define  MM_QUICKNET_PJWAVEOUT              2

/* MM_SICRESOURCE product IDs */
#define  MM_SICRESOURCE_SSO3D               2
#define  MM_SICRESOURCE_SSOW3DI             3

/* MM_NEOMAGIC product IDs */
#define  MM_NEOMAGIC_SYNTH                  1
#define  MM_NEOMAGIC_WAVEOUT                2
#define  MM_NEOMAGIC_WAVEIN                 3
#define  MM_NEOMAGIC_MIDIOUT                4
#define  MM_NEOMAGIC_MIDIIN                 5
#define  MM_NEOMAGIC_AUX                    6
#define  MM_NEOMAGIC_MW3DX_WAVEOUT          10
#define  MM_NEOMAGIC_MW3DX_WAVEIN           11
#define  MM_NEOMAGIC_MW3DX_MIDIOUT          12
#define  MM_NEOMAGIC_MW3DX_MIDIIN           13
#define  MM_NEOMAGIC_MW3DX_FMSYNTH          14
#define  MM_NEOMAGIC_MW3DX_GMSYNTH          15
#define  MM_NEOMAGIC_MW3DX_MIXER            16
#define  MM_NEOMAGIC_MW3DX_AUX              17
#define  MM_NEOMAGIC_MWAVE_WAVEOUT          20
#define  MM_NEOMAGIC_MWAVE_WAVEIN           21
#define  MM_NEOMAGIC_MWAVE_MIDIOUT          22
#define  MM_NEOMAGIC_MWAVE_MIDIIN           23
#define  MM_NEOMAGIC_MWAVE_MIXER            24
#define  MM_NEOMAGIC_MWAVE_AUX              25

/* MM_MERGING_TECHNOLOGIES product IDs */
#define  MM_MERGING_MPEGL3                  1

/* MM_XIRLINK product IDs */
#define  MM_XIRLINK_VISIONLINK              1

/* MM_OTI product IDs */
#define  MM_OTI_611WAVEIN                   5
#define  MM_OTI_611WAVEOUT                  6
#define  MM_OTI_611MIXER                    7
#define  MM_OTI_611MIDIN                    0x12
#define  MM_OTI_611MIDIOUT                  0x13

/* MM_AUREAL product IDs */
#define  MM_AUREAL_AU8820                   16
#define  MM_AU8820_SYNTH                    17
#define  MM_AU8820_WAVEOUT                  18
#define  MM_AU8820_WAVEIN                   19
#define  MM_AU8820_MIXER                    20
#define  MM_AU8820_AUX                      21
#define  MM_AU8820_MIDIOUT                  22
#define  MM_AU8820_MIDIIN                   23
#define  MM_AUREAL_AU8830                   32
#define  MM_AU8830_SYNTH                    33
#define  MM_AU8830_WAVEOUT                  34
#define  MM_AU8830_WAVEIN                   35
#define  MM_AU8830_MIXER                    36
#define  MM_AU8830_AUX                      37
#define  MM_AU8830_MIDIOUT                  38
#define  MM_AU8830_MIDIIN                   39

/* MM_VIVO product IDs */
#define  MM_VIVO_AUDIO_CODEC                1

/* MM_SHARP product IDs */
#define  MM_SHARP_MDC_MIDI_SYNTH            1
#define  MM_SHARP_MDC_MIDI_IN               2
#define  MM_SHARP_MDC_MIDI_OUT              3
#define  MM_SHARP_MDC_WAVE_IN               4
#define  MM_SHARP_MDC_WAVE_OUT              5
#define  MM_SHARP_MDC_AUX                   6
#define  MM_SHARP_MDC_MIXER                 10
#define  MM_SHARP_MDC_AUX_MASTER            100
#define  MM_SHARP_MDC_AUX_BASS              101
#define  MM_SHARP_MDC_AUX_TREBLE            102
#define  MM_SHARP_MDC_AUX_MIDI_VOL          103
#define  MM_SHARP_MDC_AUX_WAVE_VOL          104
#define  MM_SHARP_MDC_AUX_WAVE_RVB          105
#define  MM_SHARP_MDC_AUX_WAVE_CHR          106
#define  MM_SHARP_MDC_AUX_VOL               107
#define  MM_SHARP_MDC_AUX_RVB               108
#define  MM_SHARP_MDC_AUX_CHR               109

/* MM_LUCENT product IDs */
#define  MM_LUCENT_ACM_G723                 0

/* MM_ATT product IDs */
#define  MM_ATT_G729A                       1

/* MM_MARIAN product IDs */
#define  MM_MARIAN_ARC44WAVEIN              1
#define  MM_MARIAN_ARC44WAVEOUT             2
#define  MM_MARIAN_PRODIF24WAVEIN           3
#define  MM_MARIAN_PRODIF24WAVEOUT          4
#define  MM_MARIAN_ARC88WAVEIN              5
#define  MM_MARIAN_ARC88WAVEOUT             6

/* MM_BCB product IDs */
#define  MM_BCB_NETBOARD_10                 1
#define  MM_BCB_TT75_10                     2

/* MM_MOTIONPIXELS product IDs */
#define  MM_MOTIONPIXELS_MVI2               1

/* MM_QDESIGN product IDs */
#define  MM_QDESIGN_ACM_MPEG                1
#define  MM_QDESIGN_ACM_QDESIGN_MUSIC       2

/* MM_NMP product IDs */
#define  MM_NMP_CCP_WAVEIN                  1
#define  MM_NMP_CCP_WAVEOUT                 2
#define  MM_NMP_ACM_AMR                     10

/* MM_DATAFUSION product IDs */
#define  MM_DF_ACM_G726                     1
#define  MM_DF_ACM_GSM610                   2

/* MM_BERCOS product IDs */
#define  MM_BERCOS_WAVEIN                   1
#define  MM_BERCOS_MIXER                    2
#define  MM_BERCOS_WAVEOUT                  3

/* MM_ONLIVE product IDs */
#define  MM_ONLIVE_MPCODEC                  1

/* MM_PHONET product IDs */
#define  MM_PHONET_PP_WAVEOUT               1
#define  MM_PHONET_PP_WAVEIN                2
#define  MM_PHONET_PP_MIXER                 3

/* MM_FTR product IDs */
#define  MM_FTR_ENCODER_WAVEIN              1
#define  MM_FTR_ACM                         2

/* MM_ENET product IDs */
#define  MM_ENET_T2000_LINEIN               1
#define  MM_ENET_T2000_LINEOUT              2
#define  MM_ENET_T2000_HANDSETIN            3
#define  MM_ENET_T2000_HANDSETOUT           4

/*  MM_EMAGIC product IDs */
#define  MM_EMAGIC_UNITOR8                  1

/*  MM_SIPROLAB product IDs */
#define  MM_SIPROLAB_ACELPNET               1

/*  MM_DICTAPHONE product IDs */
#define  MM_DICTAPHONE_G726                 1       /* G726 ACM codec (g726pcm.acm) */

/*  MM_RZS product IDs */
#define  MM_RZS_ACM_TUBGSM                  1      /* GSM 06.10 CODEC */

/*  MM_EES product IDs */
#define  MM_EES_PCMIDI14                    1
#define  MM_EES_PCMIDI14_IN                 2
#define  MM_EES_PCMIDI14_OUT1               3
#define  MM_EES_PCMIDI14_OUT2               4
#define  MM_EES_PCMIDI14_OUT3               5
#define  MM_EES_PCMIDI14_OUT4               6

/*  MM_HAFTMANN product IDs */
#define  MM_HAFTMANN_LPTDAC2                1

/*  MM_LUCID product IDs */
#define  MM_LUCID_PCI24WAVEIN               1
#define  MM_LUCID_PCI24WAVEOUT              2

/*  MM_HEADSPACE product IDs */
#define  MM_HEADSPACE_HAESYNTH              1
#define  MM_HEADSPACE_HAEWAVEOUT            2
#define  MM_HEADSPACE_HAEWAVEIN             3
#define  MM_HEADSPACE_HAEMIXER              4

/*  MM_UNISYS product IDs */
#define  MM_UNISYS_ACM_NAP                  1

/*  MM_LUMINOSITI product IDs */

#define  MM_LUMINOSITI_SCWAVEIN             1
#define  MM_LUMINOSITI_SCWAVEOUT            2
#define  MM_LUMINOSITI_SCWAVEMIX            3

/*  MM_ACTIVEVOICE product IDs */
#define  MM_ACTIVEVOICE_ACM_VOXADPCM        1

/*  MM_DTS product IDs */
#define  MM_DTS_DS                          1

/*  MM_SOFTLAB_NSK product IDs */
#define  MM_SOFTLAB_NSK_FRW_WAVEIN          1
#define  MM_SOFTLAB_NSK_FRW_WAVEOUT         2
#define  MM_SOFTLAB_NSK_FRW_MIXER           3
#define  MM_SOFTLAB_NSK_FRW_AUX             4

/*  MM_FORTEMEDIA product IDs */
#define  MM_FORTEMEDIA_WAVEIN               1
#define  MM_FORTEMEDIA_WAVEOUT              2
#define  MM_FORTEMEDIA_FMSYNC               3
#define  MM_FORTEMEDIA_MIXER                4
#define  MM_FORTEMEDIA_AUX                  5

/*  MM_SONORUS product IDs */
#define  MM_SONORUS_STUDIO                  1

/*  MM_I_LINK product IDs */
#define  MM_I_LINK_VOICE_CODER              1

/*  MM_SELSIUS_SYSTEMS product IDs */
#define  MM_SELSIUS_SYSTEMS_RTPWAVEOUT      1
#define  MM_SELSIUS_SYSTEMS_RTPWAVEIN       2

/*  MM_ADMOS product IDs */
#define  MM_ADMOS_FM_SYNTH                  1
#define  MM_ADMOS_QS3AMIDIOUT               2
#define  MM_ADMOS_QS3AMIDIIN                3
#define  MM_ADMOS_QS3AWAVEOUT               4
#define  MM_ADMOS_QS3AWAVEIN                5

/* MM_LEXICON product IDs */
#define  MM_LEXICON_STUDIO_WAVE_OUT         1
#define  MM_LEXICON_STUDIO_WAVE_IN          2

/* MM_SGI product IDs */
#define  MM_SGI_320_WAVEIN                  1
#define  MM_SGI_320_WAVEOUT                 2
#define  MM_SGI_320_MIXER                   3
#define  MM_SGI_540_WAVEIN                  4
#define  MM_SGI_540_WAVEOUT                 5
#define  MM_SGI_540_MIXER                   6
#define  MM_SGI_RAD_ADATMONO1_WAVEIN        7
#define  MM_SGI_RAD_ADATMONO2_WAVEIN        8
#define  MM_SGI_RAD_ADATMONO3_WAVEIN        9
#define  MM_SGI_RAD_ADATMONO4_WAVEIN        10
#define  MM_SGI_RAD_ADATMONO5_WAVEIN        11
#define  MM_SGI_RAD_ADATMONO6_WAVEIN        12
#define  MM_SGI_RAD_ADATMONO7_WAVEIN        13
#define  MM_SGI_RAD_ADATMONO8_WAVEIN        14
#define  MM_SGI_RAD_ADATSTEREO12_WAVEIN     15
#define  MM_SGI_RAD_ADATSTEREO34_WAVEIN     16
#define  MM_SGI_RAD_ADATSTEREO56_WAVEIN     17
#define  MM_SGI_RAD_ADATSTEREO78_WAVEIN     18
#define  MM_SGI_RAD_ADAT8CHAN_WAVEIN        19
#define  MM_SGI_RAD_ADATMONO1_WAVEOUT       20
#define  MM_SGI_RAD_ADATMONO2_WAVEOUT       21
#define  MM_SGI_RAD_ADATMONO3_WAVEOUT       22
#define  MM_SGI_RAD_ADATMONO4_WAVEOUT       23
#define  MM_SGI_RAD_ADATMONO5_WAVEOUT       24
#define  MM_SGI_RAD_ADATMONO6_WAVEOUT       25
#define  MM_SGI_RAD_ADATMONO7_WAVEOUT       26
#define  MM_SGI_RAD_ADATMONO8_WAVEOUT       27
#define  MM_SGI_RAD_ADATSTEREO12_WAVEOUT    28
#define  MM_SGI_RAD_ADATSTEREO32_WAVEOUT    29
#define  MM_SGI_RAD_ADATSTEREO56_WAVEOUT    30
#define  MM_SGI_RAD_ADATSTEREO78_WAVEOUT    31
#define  MM_SGI_RAD_ADAT8CHAN_WAVEOUT       32
#define  MM_SGI_RAD_AESMONO1_WAVEIN         33
#define  MM_SGI_RAD_AESMONO2_WAVEIN         34
#define  MM_SGI_RAD_AESSTEREO_WAVEIN        35
#define  MM_SGI_RAD_AESMONO1_WAVEOUT        36
#define  MM_SGI_RAD_AESMONO2_WAVEOUT        37
#define  MM_SGI_RAD_AESSTEREO_WAVEOUT       38

/* MM_IPI product IDs */
#define  MM_IPI_ACM_HSX                     1
#define  MM_IPI_ACM_RPELP                   2
#define  MM_IPI_WF_ASSS                     3
#define  MM_IPI_AT_WAVEOUT                  4
#define  MM_IPI_AT_WAVEIN                   5
#define  MM_IPI_AT_MIXER                    6

/* MM_ICE product IDs */
#define  MM_ICE_WAVEOUT                     1
#define  MM_ICE_WAVEIN                      2
#define  MM_ICE_MTWAVEOUT                   3
#define  MM_ICE_MTWAVEIN                    4
#define  MM_ICE_MIDIOUT1                    5
#define  MM_ICE_MIDIIN1                     6
#define  MM_ICE_MIDIOUT2                    7
#define  MM_ICE_MIDIIN2                     8
#define  MM_ICE_SYNTH                       9
#define  MM_ICE_MIXER                       10
#define  MM_ICE_AUX                         11

/* MM_VQST product IDs */
#define  MM_VQST_VQC1                       1
#define  MM_VQST_VQC2                       2

/* MM_ETEK product IDs */
#define  MM_ETEK_KWIKMIDI_MIDIIN            1
#define  MM_ETEK_KWIKMIDI_MIDIOUT           2

/* MM_INTERNET product IDs */
#define  MM_INTERNET_SSW_MIDIOUT            10
#define  MM_INTERNET_SSW_MIDIIN             11
#define  MM_INTERNET_SSW_WAVEOUT            12
#define  MM_INTERNET_SSW_WAVEIN             13

/* MM_SONY product IDs */
#define  MM_SONY_ACM_SCX                    1

/* MM_UHER_INFORMATIC product IDs */
#define  MM_UH_ACM_ADPCM                    1

/* MM_SYDEC_NV product IDs */
#define  MM_SYDEC_NV_WAVEIN                 1
#define  MM_SYDEC_NV_WAVEOUT                2

/* MM_FLEXION product IDs */
#define  MM_FLEXION_X300_WAVEIN             1
#define  MM_FLEXION_X300_WAVEOUT            2

/* MM_VIA product IDs */
#define  MM_VIA_WAVEOUT                     1
#define  MM_VIA_WAVEIN                      2
#define  MM_VIA_MIXER                       3
#define  MM_VIA_AUX                         4
#define  MM_VIA_MPU401_MIDIOUT              5
#define  MM_VIA_MPU401_MIDIIN               6
#define  MM_VIA_SWFM_SYNTH                  7
#define  MM_VIA_WDM_WAVEOUT                 8
#define  MM_VIA_WDM_WAVEIN                  9
#define  MM_VIA_WDM_MIXER                   10
#define  MM_VIA_WDM_MPU401_MIDIOUT          11
#define  MM_VIA_WDM_MPU401_MIDIIN           12

/* MM_MICRONAS product IDs */
#define  MM_MICRONAS_SC4                    1
#define  MM_MICRONAS_CLP833                 2

/* MM_HP product IDs */
#define  MM_HP_WAVEOUT                      1
#define  MM_HP_WAVEIN                       2

/* MM_QUICKAUDIO product IDs */
#define  MM_QUICKAUDIO_MINIMIDI             1
#define  MM_QUICKAUDIO_MAXIMIDI             2

/* MM_ICCC product IDs */
#define  MM_ICCC_UNA3_WAVEIN                1
#define  MM_ICCC_UNA3_WAVEOUT               2
#define  MM_ICCC_UNA3_AUX                   3
#define  MM_ICCC_UNA3_MIXER                 4

/* MM_3COM product IDs */
#define  MM_3COM_CB_MIXER                   1
#define  MM_3COM_CB_WAVEIN                  2
#define  MM_3COM_CB_WAVEOUT                 3

/* MM_MINDMAKER product IDs */
#define  MM_MINDMAKER_GC_WAVEIN             1
#define  MM_MINDMAKER_GC_WAVEOUT            2
#define  MM_MINDMAKER_GC_MIXER              3

/* MM_TELEKOL product IDs */
#define  MM_TELEKOL_WAVEOUT                 1
#define  MM_TELEKOL_WAVEIN                  2

/* MM_ALGOVISION product IDs */
#define  MM_ALGOVISION_VB80WAVEOUT          1
#define  MM_ALGOVISION_VB80WAVEIN           2
#define  MM_ALGOVISION_VB80MIXER            3
#define  MM_ALGOVISION_VB80AUX              4
#define  MM_ALGOVISION_VB80AUX2             5

#endif  // !NOMMIDS

/* ------------------------------------------------------------------------------ */

/*              INFO LIST CHUNKS (from the Multimedia Programmer's Reference
                                        plus new ones)
*/
#define RIFFINFO_IARL      mmioFOURCC ('I', 'A', 'R', 'L')     /*Archival location  */
#define RIFFINFO_IART      mmioFOURCC ('I', 'A', 'R', 'T')     /*Artist  */
#define RIFFINFO_ICMS      mmioFOURCC ('I', 'C', 'M', 'S')     /*Commissioned  */
#define RIFFINFO_ICMT      mmioFOURCC ('I', 'C', 'M', 'T')     /*Comments  */
#define RIFFINFO_ICOP      mmioFOURCC ('I', 'C', 'O', 'P')     /*Copyright  */
#define RIFFINFO_ICRD      mmioFOURCC ('I', 'C', 'R', 'D')     /*Creation date of subject  */
#define RIFFINFO_ICRP      mmioFOURCC ('I', 'C', 'R', 'P')     /*Cropped  */
#define RIFFINFO_IDIM      mmioFOURCC ('I', 'D', 'I', 'M')     /*Dimensions  */
#define RIFFINFO_IDPI      mmioFOURCC ('I', 'D', 'P', 'I')     /*Dots per inch  */
#define RIFFINFO_IENG      mmioFOURCC ('I', 'E', 'N', 'G')     /*Engineer  */
#define RIFFINFO_IGNR      mmioFOURCC ('I', 'G', 'N', 'R')     /*Genre  */
#define RIFFINFO_IKEY      mmioFOURCC ('I', 'K', 'E', 'Y')     /*Keywords  */
#define RIFFINFO_ILGT      mmioFOURCC ('I', 'L', 'G', 'T')     /*Lightness settings  */
#define RIFFINFO_IMED      mmioFOURCC ('I', 'M', 'E', 'D')     /*Medium  */
#define RIFFINFO_INAM      mmioFOURCC ('I', 'N', 'A', 'M')     /*Name of subject  */
#define RIFFINFO_IPLT      mmioFOURCC ('I', 'P', 'L', 'T')     /*Palette Settings. No. of colors requested.   */
#define RIFFINFO_IPRD      mmioFOURCC ('I', 'P', 'R', 'D')     /*Product  */
#define RIFFINFO_ISBJ      mmioFOURCC ('I', 'S', 'B', 'J')     /*Subject description  */
#define RIFFINFO_ISFT      mmioFOURCC ('I', 'S', 'F', 'T')     /*Software. Name of package used to create file.  */
#define RIFFINFO_ISHP      mmioFOURCC ('I', 'S', 'H', 'P')     /*Sharpness.  */
#define RIFFINFO_ISRC      mmioFOURCC ('I', 'S', 'R', 'C')     /*Source.   */
#define RIFFINFO_ISRF      mmioFOURCC ('I', 'S', 'R', 'F')     /*Source Form. ie slide, paper  */
#define RIFFINFO_ITCH      mmioFOURCC ('I', 'T', 'C', 'H')     /*Technician who digitized the subject.  */

/* New INFO Chunks as of August 30, 1993: */
#define RIFFINFO_ISMP      mmioFOURCC ('I', 'S', 'M', 'P')     /*SMPTE time code  */
/* ISMP: SMPTE time code of digitization start point expressed as a NULL terminated
                text string "HH:MM:SS:FF". If performing MCI capture in AVICAP, this
                chunk will be automatically set based on the MCI start time.
*/
#define RIFFINFO_IDIT      mmioFOURCC ('I', 'D', 'I', 'T')     /*Digitization Time  */
/* IDIT: "Digitization Time" Specifies the time and date that the digitization commenced.
                The digitization time is contained in an ASCII string which
                contains exactly 26 characters and is in the format
                "Wed Jan 02 02:03:55 1990\n\0".
                The ctime(), asctime(), functions can be used to create strings
                in this format. This chunk is automatically added to the capture
                file based on the current system time at the moment capture is initiated.
*/

/*Template line for new additions*/
/*#define RIFFINFO_I      mmioFOURCC ('I', '', '', '')        */

/* ------------------------------------------------------------------------------ */

#ifndef NONEWWAVE

/* WAVE form wFormatTag IDs */
#define  WAVE_FORMAT_UNKNOWN                    0x0000 /* Microsoft Corporation */
#define  WAVE_FORMAT_ADPCM                      0x0002 /* Microsoft Corporation */
#define  WAVE_FORMAT_IEEE_FLOAT                 0x0003 /* Microsoft Corporation */
#define  WAVE_FORMAT_VSELP                      0x0004 /* Compaq Computer Corp. */
#define  WAVE_FORMAT_IBM_CVSD                   0x0005 /* IBM Corporation */
#define  WAVE_FORMAT_ALAW                       0x0006 /* Microsoft Corporation */
#define  WAVE_FORMAT_MULAW                      0x0007 /* Microsoft Corporation */
#define  WAVE_FORMAT_DTS                        0x0008 /* Microsoft Corporation */
#define  WAVE_FORMAT_DRM                        0x0009 /* Microsoft Corporation */
#define  WAVE_FORMAT_OKI_ADPCM                  0x0010 /* OKI */
#define  WAVE_FORMAT_DVI_ADPCM                  0x0011 /* Intel Corporation */
#define  WAVE_FORMAT_IMA_ADPCM                  (WAVE_FORMAT_DVI_ADPCM) /*  Intel Corporation */
#define  WAVE_FORMAT_MEDIASPACE_ADPCM           0x0012 /* Videologic */
#define  WAVE_FORMAT_SIERRA_ADPCM               0x0013 /* Sierra Semiconductor Corp */
#define  WAVE_FORMAT_G723_ADPCM                 0x0014 /* Antex Electronics Corporation */
#define  WAVE_FORMAT_DIGISTD                    0x0015 /* DSP Solutions, Inc. */
#define  WAVE_FORMAT_DIGIFIX                    0x0016 /* DSP Solutions, Inc. */
#define  WAVE_FORMAT_DIALOGIC_OKI_ADPCM         0x0017 /* Dialogic Corporation */
#define  WAVE_FORMAT_MEDIAVISION_ADPCM          0x0018 /* Media Vision, Inc. */
#define  WAVE_FORMAT_CU_CODEC                   0x0019 /* Hewlett-Packard Company */
#define  WAVE_FORMAT_YAMAHA_ADPCM               0x0020 /* Yamaha Corporation of America */
#define  WAVE_FORMAT_SONARC                     0x0021 /* Speech Compression */
#define  WAVE_FORMAT_DSPGROUP_TRUESPEECH        0x0022 /* DSP Group, Inc */
#define  WAVE_FORMAT_ECHOSC1                    0x0023 /* Echo Speech Corporation */
#define  WAVE_FORMAT_AUDIOFILE_AF36             0x0024 /* Virtual Music, Inc. */
#define  WAVE_FORMAT_APTX                       0x0025 /* Audio Processing Technology */
#define  WAVE_FORMAT_AUDIOFILE_AF10             0x0026 /* Virtual Music, Inc. */
#define  WAVE_FORMAT_PROSODY_1612               0x0027 /* Aculab plc */
#define  WAVE_FORMAT_LRC                        0x0028 /* Merging Technologies S.A. */
#define  WAVE_FORMAT_DOLBY_AC2                  0x0030 /* Dolby Laboratories */
#define  WAVE_FORMAT_GSM610                     0x0031 /* Microsoft Corporation */
#define  WAVE_FORMAT_MSNAUDIO                   0x0032 /* Microsoft Corporation */
#define  WAVE_FORMAT_ANTEX_ADPCME               0x0033 /* Antex Electronics Corporation */
#define  WAVE_FORMAT_CONTROL_RES_VQLPC          0x0034 /* Control Resources Limited */
#define  WAVE_FORMAT_DIGIREAL                   0x0035 /* DSP Solutions, Inc. */
#define  WAVE_FORMAT_DIGIADPCM                  0x0036 /* DSP Solutions, Inc. */
#define  WAVE_FORMAT_CONTROL_RES_CR10           0x0037 /* Control Resources Limited */
#define  WAVE_FORMAT_NMS_VBXADPCM               0x0038 /* Natural MicroSystems */
#define  WAVE_FORMAT_CS_IMAADPCM                0x0039 /* Crystal Semiconductor IMA ADPCM */
#define  WAVE_FORMAT_ECHOSC3                    0x003A /* Echo Speech Corporation */
#define  WAVE_FORMAT_ROCKWELL_ADPCM             0x003B /* Rockwell International */
#define  WAVE_FORMAT_ROCKWELL_DIGITALK          0x003C /* Rockwell International */
#define  WAVE_FORMAT_XEBEC                      0x003D /* Xebec Multimedia Solutions Limited */
#define  WAVE_FORMAT_G721_ADPCM                 0x0040 /* Antex Electronics Corporation */
#define  WAVE_FORMAT_G728_CELP                  0x0041 /* Antex Electronics Corporation */
#define  WAVE_FORMAT_MSG723                     0x0042 /* Microsoft Corporation */
#define  WAVE_FORMAT_MPEG                       0x0050 /* Microsoft Corporation */
#define  WAVE_FORMAT_RT24                       0x0052 /* InSoft, Inc. */
#define  WAVE_FORMAT_PAC                        0x0053 /* InSoft, Inc. */
#define  WAVE_FORMAT_MPEGLAYER3                 0x0055 /* ISO/MPEG Layer3 Format Tag */
#define  WAVE_FORMAT_LUCENT_G723                0x0059 /* Lucent Technologies */
#define  WAVE_FORMAT_CIRRUS                     0x0060 /* Cirrus Logic */
#define  WAVE_FORMAT_ESPCM                      0x0061 /* ESS Technology */
#define  WAVE_FORMAT_VOXWARE                    0x0062 /* Voxware Inc */
#define  WAVE_FORMAT_CANOPUS_ATRAC              0x0063 /* Canopus, co., Ltd. */
#define  WAVE_FORMAT_G726_ADPCM                 0x0064 /* APICOM */
#define  WAVE_FORMAT_G722_ADPCM                 0x0065 /* APICOM */
#define  WAVE_FORMAT_DSAT_DISPLAY               0x0067 /* Microsoft Corporation */
#define  WAVE_FORMAT_VOXWARE_BYTE_ALIGNED       0x0069 /* Voxware Inc */
#define  WAVE_FORMAT_VOXWARE_AC8                0x0070 /* Voxware Inc */
#define  WAVE_FORMAT_VOXWARE_AC10               0x0071 /* Voxware Inc */
#define  WAVE_FORMAT_VOXWARE_AC16               0x0072 /* Voxware Inc */
#define  WAVE_FORMAT_VOXWARE_AC20               0x0073 /* Voxware Inc */
#define  WAVE_FORMAT_VOXWARE_RT24               0x0074 /* Voxware Inc */
#define  WAVE_FORMAT_VOXWARE_RT29               0x0075 /* Voxware Inc */
#define  WAVE_FORMAT_VOXWARE_RT29HW             0x0076 /* Voxware Inc */
#define  WAVE_FORMAT_VOXWARE_VR12               0x0077 /* Voxware Inc */
#define  WAVE_FORMAT_VOXWARE_VR18               0x0078 /* Voxware Inc */
#define  WAVE_FORMAT_VOXWARE_TQ40               0x0079 /* Voxware Inc */
#define  WAVE_FORMAT_SOFTSOUND                  0x0080 /* Softsound, Ltd. */
#define  WAVE_FORMAT_VOXWARE_TQ60               0x0081 /* Voxware Inc */
#define  WAVE_FORMAT_MSRT24                     0x0082 /* Microsoft Corporation */
#define  WAVE_FORMAT_G729A                      0x0083 /* AT&T Labs, Inc. */
#define  WAVE_FORMAT_MVI_MVI2                   0x0084 /* Motion Pixels */
#define  WAVE_FORMAT_DF_G726                    0x0085 /* DataFusion Systems (Pty) (Ltd) */
#define  WAVE_FORMAT_DF_GSM610                  0x0086 /* DataFusion Systems (Pty) (Ltd) */
#define  WAVE_FORMAT_ISIAUDIO                   0x0088 /* Iterated Systems, Inc. */
#define  WAVE_FORMAT_ONLIVE                     0x0089 /* OnLive! Technologies, Inc. */
#define  WAVE_FORMAT_SBC24                      0x0091 /* Siemens Business Communications Sys */
#define  WAVE_FORMAT_DOLBY_AC3_SPDIF            0x0092 /* Sonic Foundry */
#define  WAVE_FORMAT_MEDIASONIC_G723            0x0093 /* MediaSonic */
#define  WAVE_FORMAT_PROSODY_8KBPS              0x0094 /* Aculab plc */
#define  WAVE_FORMAT_ZYXEL_ADPCM                0x0097 /* ZyXEL Communications, Inc. */
#define  WAVE_FORMAT_PHILIPS_LPCBB              0x0098 /* Philips Speech Processing */
#define  WAVE_FORMAT_PACKED                     0x0099 /* Studer Professional Audio AG */
#define  WAVE_FORMAT_MALDEN_PHONYTALK           0x00A0 /* Malden Electronics Ltd. */
#define  WAVE_FORMAT_RHETOREX_ADPCM             0x0100 /* Rhetorex Inc. */
#define  WAVE_FORMAT_IRAT                       0x0101 /* BeCubed Software Inc. */
#define  WAVE_FORMAT_VIVO_G723                  0x0111 /* Vivo Software */
#define  WAVE_FORMAT_VIVO_SIREN                 0x0112 /* Vivo Software */
#define  WAVE_FORMAT_DIGITAL_G723               0x0123 /* Digital Equipment Corporation */
#define  WAVE_FORMAT_SANYO_LD_ADPCM             0x0125 /* Sanyo Electric Co., Ltd. */
#define  WAVE_FORMAT_SIPROLAB_ACEPLNET          0x0130 /* Sipro Lab Telecom Inc. */
#define  WAVE_FORMAT_SIPROLAB_ACELP4800         0x0131 /* Sipro Lab Telecom Inc. */
#define  WAVE_FORMAT_SIPROLAB_ACELP8V3          0x0132 /* Sipro Lab Telecom Inc. */
#define  WAVE_FORMAT_SIPROLAB_G729              0x0133 /* Sipro Lab Telecom Inc. */
#define  WAVE_FORMAT_SIPROLAB_G729A             0x0134 /* Sipro Lab Telecom Inc. */
#define  WAVE_FORMAT_SIPROLAB_KELVIN            0x0135 /* Sipro Lab Telecom Inc. */
#define  WAVE_FORMAT_G726ADPCM                  0x0140 /* Dictaphone Corporation */
#define  WAVE_FORMAT_QUALCOMM_PUREVOICE         0x0150 /* Qualcomm, Inc. */
#define  WAVE_FORMAT_QUALCOMM_HALFRATE          0x0151 /* Qualcomm, Inc. */
#define  WAVE_FORMAT_TUBGSM                     0x0155 /* Ring Zero Systems, Inc. */
#define  WAVE_FORMAT_MSAUDIO1                   0x0160 /* Microsoft Corporation */
#define  WAVE_FORMAT_UNISYS_NAP_ADPCM           0x0170 /* Unisys Corp. */
#define  WAVE_FORMAT_UNISYS_NAP_ULAW            0x0171 /* Unisys Corp. */
#define  WAVE_FORMAT_UNISYS_NAP_ALAW            0x0172 /* Unisys Corp. */
#define  WAVE_FORMAT_UNISYS_NAP_16K             0x0173 /* Unisys Corp. */
#define  WAVE_FORMAT_CREATIVE_ADPCM             0x0200 /* Creative Labs, Inc */
#define  WAVE_FORMAT_CREATIVE_FASTSPEECH8       0x0202 /* Creative Labs, Inc */
#define  WAVE_FORMAT_CREATIVE_FASTSPEECH10      0x0203 /* Creative Labs, Inc */
#define  WAVE_FORMAT_UHER_ADPCM                 0x0210 /* UHER informatic GmbH */
#define  WAVE_FORMAT_QUARTERDECK                0x0220 /* Quarterdeck Corporation */
#define  WAVE_FORMAT_ILINK_VC                   0x0230 /* I-link Worldwide */
#define  WAVE_FORMAT_RAW_SPORT                  0x0240 /* Aureal Semiconductor */
#define  WAVE_FORMAT_ESST_AC3                   0x0241 /* ESS Technology, Inc. */
#define  WAVE_FORMAT_IPI_HSX                    0x0250 /* Interactive Products, Inc. */
#define  WAVE_FORMAT_IPI_RPELP                  0x0251 /* Interactive Products, Inc. */
#define  WAVE_FORMAT_CS2                        0x0260 /* Consistent Software */
#define  WAVE_FORMAT_SONY_SCX                   0x0270 /* Sony Corp. */
#define  WAVE_FORMAT_FM_TOWNS_SND               0x0300 /* Fujitsu Corp. */
#define  WAVE_FORMAT_BTV_DIGITAL                0x0400 /* Brooktree Corporation */
#define  WAVE_FORMAT_QDESIGN_MUSIC              0x0450 /* QDesign Corporation */
#define  WAVE_FORMAT_VME_VMPCM                  0x0680 /* AT&T Labs, Inc. */
#define  WAVE_FORMAT_TPC                        0x0681 /* AT&T Labs, Inc. */
#define  WAVE_FORMAT_OLIGSM                     0x1000 /* Ing C. Olivetti & C., S.p.A. */
#define  WAVE_FORMAT_OLIADPCM                   0x1001 /* Ing C. Olivetti & C., S.p.A. */
#define  WAVE_FORMAT_OLICELP                    0x1002 /* Ing C. Olivetti & C., S.p.A. */
#define  WAVE_FORMAT_OLISBC                     0x1003 /* Ing C. Olivetti & C., S.p.A. */
#define  WAVE_FORMAT_OLIOPR                     0x1004 /* Ing C. Olivetti & C., S.p.A. */
#define  WAVE_FORMAT_LH_CODEC                   0x1100 /* Lernout & Hauspie */
#define  WAVE_FORMAT_NORRIS                     0x1400 /* Norris Communications, Inc. */
#define  WAVE_FORMAT_SOUNDSPACE_MUSICOMPRESS    0x1500 /* AT&T Labs, Inc. */
#define  WAVE_FORMAT_DVM                        0x2000 /* FAST Multimedia AG */

#if !defined(WAVE_FORMAT_EXTENSIBLE)
#define  WAVE_FORMAT_EXTENSIBLE                 0xFFFE /* Microsoft */
#endif // !defined(WAVE_FORMAT_EXTENSIBLE)
//
//  the WAVE_FORMAT_DEVELOPMENT format tag can be used during the
//  development phase of a new wave format.  Before shipping, you MUST
//  acquire an official format tag from Microsoft.
//
#define WAVE_FORMAT_DEVELOPMENT         (0xFFFF)

#endif /* NONEWWAVE */

#ifndef WAVE_FORMAT_PCM

/* general waveform format structure (information common to all formats) */
typedef struct waveformat_tag {
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo...) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
} WAVEFORMAT;
typedef WAVEFORMAT       *PWAVEFORMAT;
typedef WAVEFORMAT NEAR *NPWAVEFORMAT;
typedef WAVEFORMAT FAR  *LPWAVEFORMAT;

/* flags for wFormatTag field of WAVEFORMAT */
#define WAVE_FORMAT_PCM     1

/* specific waveform format structure for PCM data */
typedef struct pcmwaveformat_tag {
    WAVEFORMAT  wf;
    WORD        wBitsPerSample;
} PCMWAVEFORMAT;
typedef PCMWAVEFORMAT       *PPCMWAVEFORMAT;
typedef PCMWAVEFORMAT NEAR *NPPCMWAVEFORMAT;
typedef PCMWAVEFORMAT FAR  *LPPCMWAVEFORMAT;

#endif /* WAVE_FORMAT_PCM */

/* general extended waveform format structure
   Use this for all NON PCM formats
   (information common to all formats)
*/
#ifndef _WAVEFORMATEX_
#define _WAVEFORMATEX_
typedef struct tWAVEFORMATEX
{
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo...) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
    WORD    wBitsPerSample;    /* Number of bits per sample of mono data */
    WORD    cbSize;            /* The count in bytes of the size of
                                    extra information (after cbSize) */

} WAVEFORMATEX;
typedef WAVEFORMATEX       *PWAVEFORMATEX;
typedef WAVEFORMATEX NEAR *NPWAVEFORMATEX;
typedef WAVEFORMATEX FAR  *LPWAVEFORMATEX;
#endif /* _WAVEFORMATEX_ */

#ifdef GUID_DEFINED

#ifndef _WAVEFORMATEXTENSIBLE_
#define _WAVEFORMATEXTENSIBLE_
typedef struct {
    WAVEFORMATEX    Format;
    union {
        WORD wValidBitsPerSample;       /* bits of precision  */
        WORD wSamplesPerBlock;          /* valid if wBitsPerSample==0 */
        WORD wReserved;                 /* If neither applies, set to zero. */
    } Samples;
    DWORD           dwChannelMask;      /* which channels are */
                                        /* present in stream  */
    GUID            SubFormat;
} WAVEFORMATEXTENSIBLE, *PWAVEFORMATEXTENSIBLE;
#endif // !_WAVEFORMATEXTENSIBLE_

//
//  Extended PCM waveform format structure based on WAVEFORMATEXTENSIBLE.
//  Use this for multiple channel and hi-resolution PCM data
//
typedef WAVEFORMATEXTENSIBLE    WAVEFORMATPCMEX; /* Format.cbSize = 22 */
typedef WAVEFORMATPCMEX       *PWAVEFORMATPCMEX;
typedef WAVEFORMATPCMEX NEAR *NPWAVEFORMATPCMEX;
typedef WAVEFORMATPCMEX FAR  *LPWAVEFORMATPCMEX;

//
//  Extended format structure using IEEE Float data and based
//  on WAVEFORMATEXTENSIBLE.  Use this for multiple channel
//  and hi-resolution PCM data in IEEE floating point format.
//
typedef WAVEFORMATEXTENSIBLE          WAVEFORMATIEEEFLOATEX; /* Format.cbSize = 22 */
typedef WAVEFORMATIEEEFLOATEX       *PWAVEFORMATIEEEFLOATEX;
typedef WAVEFORMATIEEEFLOATEX NEAR *NPWAVEFORMATIEEEFLOATEX;
typedef WAVEFORMATIEEEFLOATEX FAR  *LPWAVEFORMATIEEEFLOATEX;

#endif // GUID_DEFINED

#ifndef _SPEAKER_POSITIONS_
#define _SPEAKER_POSITIONS_
// Speaker Positions for dwChannelMask in WAVEFORMATEXTENSIBLE:
#define SPEAKER_FRONT_LEFT              0x1
#define SPEAKER_FRONT_RIGHT             0x2
#define SPEAKER_FRONT_CENTER            0x4
#define SPEAKER_LOW_FREQUENCY           0x8
#define SPEAKER_BACK_LEFT               0x10
#define SPEAKER_BACK_RIGHT              0x20
#define SPEAKER_FRONT_LEFT_OF_CENTER    0x40
#define SPEAKER_FRONT_RIGHT_OF_CENTER   0x80
#define SPEAKER_BACK_CENTER             0x100
#define SPEAKER_SIDE_LEFT               0x200
#define SPEAKER_SIDE_RIGHT              0x400
#define SPEAKER_TOP_CENTER              0x800
#define SPEAKER_TOP_FRONT_LEFT          0x1000
#define SPEAKER_TOP_FRONT_CENTER        0x2000
#define SPEAKER_TOP_FRONT_RIGHT         0x4000
#define SPEAKER_TOP_BACK_LEFT           0x8000
#define SPEAKER_TOP_BACK_CENTER         0x10000
#define SPEAKER_TOP_BACK_RIGHT          0x20000

// Bit mask locations reserved for future use
#define SPEAKER_RESERVED                0x7FFC0000

// Used to specify that any possible permutation of speaker configurations
#define SPEAKER_ALL                     0x80000000
#endif // _SPEAKER_POSITIONS_

#ifndef NONEWWAVE

/* Define data for MS ADPCM */

typedef struct adpcmcoef_tag {
        short   iCoef1;
        short   iCoef2;
} ADPCMCOEFSET;
typedef ADPCMCOEFSET       *PADPCMCOEFSET;
typedef ADPCMCOEFSET NEAR *NPADPCMCOEFSET;
typedef ADPCMCOEFSET FAR  *LPADPCMCOEFSET;

/*
 *  this pragma disables the warning issued by the Microsoft C compiler
 *  when using a zero size array as place holder when compiling for
 *  C++ or with -W4.
 *
 */
#ifdef _MSC_VER
#pragma warning(disable:4200)
#endif

typedef struct adpcmwaveformat_tag {
        WAVEFORMATEX    wfx;
        WORD            wSamplesPerBlock;
        WORD            wNumCoef;
#if defined( _MSC_VER )        
        ADPCMCOEFSET    aCoef[];
#else
        ADPCMCOEFSET    aCoef[1];
#endif        
} ADPCMWAVEFORMAT;
typedef ADPCMWAVEFORMAT       *PADPCMWAVEFORMAT;
typedef ADPCMWAVEFORMAT NEAR *NPADPCMWAVEFORMAT;
typedef ADPCMWAVEFORMAT FAR  *LPADPCMWAVEFORMAT;

#ifdef _MSC_VER
#pragma warning(default:4200)
#endif

//
//  Microsoft's DRM structure definitions
//
typedef struct drmwaveformat_tag {
	WAVEFORMATEX    wfx;
	WORD            wReserved;
	ULONG           ulContentId;
	WAVEFORMATEX    wfxSecure;
} DRMWAVEFORMAT;
typedef DRMWAVEFORMAT       *PDRMWAVEFORMAT;
typedef DRMWAVEFORMAT NEAR *NPDRMWAVEFORMAT;
typedef DRMWAVEFORMAT FAR  *LPDRMWAVEFORMAT;


//
//  Intel's DVI ADPCM structure definitions
//
//      for WAVE_FORMAT_DVI_ADPCM   (0x0011)
//
//

typedef struct dvi_adpcmwaveformat_tag {
        WAVEFORMATEX    wfx;
        WORD            wSamplesPerBlock;
} DVIADPCMWAVEFORMAT;
typedef DVIADPCMWAVEFORMAT       *PDVIADPCMWAVEFORMAT;
typedef DVIADPCMWAVEFORMAT NEAR *NPDVIADPCMWAVEFORMAT;
typedef DVIADPCMWAVEFORMAT FAR  *LPDVIADPCMWAVEFORMAT;

//
//  IMA endorsed ADPCM structure definitions--note that this is exactly
//  the same format as Intel's DVI ADPCM.
//
//      for WAVE_FORMAT_IMA_ADPCM   (0x0011)
//
//

typedef struct ima_adpcmwaveformat_tag {
        WAVEFORMATEX    wfx;
        WORD            wSamplesPerBlock;
} IMAADPCMWAVEFORMAT;
typedef IMAADPCMWAVEFORMAT       *PIMAADPCMWAVEFORMAT;
typedef IMAADPCMWAVEFORMAT NEAR *NPIMAADPCMWAVEFORMAT;
typedef IMAADPCMWAVEFORMAT FAR  *LPIMAADPCMWAVEFORMAT;

/*
//VideoLogic's Media Space ADPCM Structure definitions
// for  WAVE_FORMAT_MEDIASPACE_ADPCM    (0x0012)
//
//
*/
typedef struct mediaspace_adpcmwaveformat_tag {
        WAVEFORMATEX    wfx;
        WORD    wRevision;
} MEDIASPACEADPCMWAVEFORMAT;
typedef MEDIASPACEADPCMWAVEFORMAT           *PMEDIASPACEADPCMWAVEFORMAT;
typedef MEDIASPACEADPCMWAVEFORMAT NEAR     *NPMEDIASPACEADPCMWAVEFORMAT;
typedef MEDIASPACEADPCMWAVEFORMAT FAR      *LPMEDIASPACEADPCMWAVEFORMAT;

//
//  Sierra Semiconductor
//
//      for WAVE_FORMAT_SIERRA_ADPCM   (0x0013)
//
//

typedef struct sierra_adpcmwaveformat_tag {
        WAVEFORMATEX    wfx;
        WORD            wRevision;
} SIERRAADPCMWAVEFORMAT;
typedef SIERRAADPCMWAVEFORMAT   *PSIERRAADPCMWAVEFORMAT;
typedef SIERRAADPCMWAVEFORMAT NEAR      *NPSIERRAADPCMWAVEFORMAT;
typedef SIERRAADPCMWAVEFORMAT FAR       *LPSIERRAADPCMWAVEFORMAT;

//
//  Antex Electronics  structure definitions
//
//      for WAVE_FORMAT_G723_ADPCM   (0x0014)
//
//

typedef struct g723_adpcmwaveformat_tag {
        WAVEFORMATEX    wfx;
        WORD            cbExtraSize;
        WORD            nAuxBlockSize;
} G723_ADPCMWAVEFORMAT;
typedef G723_ADPCMWAVEFORMAT *PG723_ADPCMWAVEFORMAT;
typedef G723_ADPCMWAVEFORMAT NEAR *NPG723_ADPCMWAVEFORMAT;
typedef G723_ADPCMWAVEFORMAT FAR  *LPG723_ADPCMWAVEFORMAT;

//
//  DSP Solutions (formerly DIGISPEECH) structure definitions
//
//      for WAVE_FORMAT_DIGISTD   (0x0015)
//
//

typedef struct digistdwaveformat_tag {
        WAVEFORMATEX    wfx;
} DIGISTDWAVEFORMAT;
typedef DIGISTDWAVEFORMAT       *PDIGISTDWAVEFORMAT;
typedef DIGISTDWAVEFORMAT NEAR *NPDIGISTDWAVEFORMAT;
typedef DIGISTDWAVEFORMAT FAR  *LPDIGISTDWAVEFORMAT;

//
//  DSP Solutions (formerly DIGISPEECH) structure definitions
//
//      for WAVE_FORMAT_DIGIFIX   (0x0016)
//
//

typedef struct digifixwaveformat_tag {
        WAVEFORMATEX    wfx;
} DIGIFIXWAVEFORMAT;
typedef DIGIFIXWAVEFORMAT       *PDIGIFIXWAVEFORMAT;
typedef DIGIFIXWAVEFORMAT NEAR *NPDIGIFIXWAVEFORMAT;
typedef DIGIFIXWAVEFORMAT FAR  *LPDIGIFIXWAVEFORMAT;

//
//   Dialogic Corporation
// WAVEFORMAT_DIALOGIC_OKI_ADPCM   (0x0017)
//
typedef struct creative_fastspeechformat_tag{
        WAVEFORMATEX    ewf;
}DIALOGICOKIADPCMWAVEFORMAT;
typedef DIALOGICOKIADPCMWAVEFORMAT       *PDIALOGICOKIADPCMWAVEFORMAT;
typedef DIALOGICOKIADPCMWAVEFORMAT NEAR *NPDIALOGICOKIADPCMWAVEFORMAT;
typedef DIALOGICOKIADPCMWAVEFORMAT FAR  *LPDIALOGICOKIADPCMWAVEFORMAT;

//
//  Yamaha Compression's ADPCM structure definitions
//
//      for WAVE_FORMAT_YAMAHA_ADPCM   (0x0020)
//
//

typedef struct yamaha_adpmcwaveformat_tag {
        WAVEFORMATEX    wfx;

} YAMAHA_ADPCMWAVEFORMAT;
typedef YAMAHA_ADPCMWAVEFORMAT *PYAMAHA_ADPCMWAVEFORMAT;
typedef YAMAHA_ADPCMWAVEFORMAT NEAR *NPYAMAHA_ADPCMWAVEFORMAT;
typedef YAMAHA_ADPCMWAVEFORMAT FAR  *LPYAMAHA_ADPCMWAVEFORMAT;

//
//  Speech Compression's Sonarc structure definitions
//
//      for WAVE_FORMAT_SONARC   (0x0021)
//
//

typedef struct sonarcwaveformat_tag {
        WAVEFORMATEX    wfx;
        WORD            wCompType;
} SONARCWAVEFORMAT;
typedef SONARCWAVEFORMAT       *PSONARCWAVEFORMAT;
typedef SONARCWAVEFORMAT NEAR *NPSONARCWAVEFORMAT;
typedef SONARCWAVEFORMAT FAR  *LPSONARCWAVEFORMAT;

//
//  DSP Groups's TRUESPEECH structure definitions
//
//      for WAVE_FORMAT_DSPGROUP_TRUESPEECH   (0x0022)
//
//

typedef struct truespeechwaveformat_tag {
        WAVEFORMATEX    wfx;
        WORD            wRevision;
        WORD            nSamplesPerBlock;
        BYTE            abReserved[28];
} TRUESPEECHWAVEFORMAT;
typedef TRUESPEECHWAVEFORMAT       *PTRUESPEECHWAVEFORMAT;
typedef TRUESPEECHWAVEFORMAT NEAR *NPTRUESPEECHWAVEFORMAT;
typedef TRUESPEECHWAVEFORMAT FAR  *LPTRUESPEECHWAVEFORMAT;

//
//  Echo Speech Corp structure definitions
//
//      for WAVE_FORMAT_ECHOSC1   (0x0023)
//
//

typedef struct echosc1waveformat_tag {
        WAVEFORMATEX    wfx;
} ECHOSC1WAVEFORMAT;
typedef ECHOSC1WAVEFORMAT       *PECHOSC1WAVEFORMAT;
typedef ECHOSC1WAVEFORMAT NEAR *NPECHOSC1WAVEFORMAT;
typedef ECHOSC1WAVEFORMAT FAR  *LPECHOSC1WAVEFORMAT;

//
//  Audiofile Inc.structure definitions
//
//      for WAVE_FORMAT_AUDIOFILE_AF36   (0x0024)
//
//

typedef struct audiofile_af36waveformat_tag {
        WAVEFORMATEX    wfx;
} AUDIOFILE_AF36WAVEFORMAT;
typedef AUDIOFILE_AF36WAVEFORMAT       *PAUDIOFILE_AF36WAVEFORMAT;
typedef AUDIOFILE_AF36WAVEFORMAT NEAR *NPAUDIOFILE_AF36WAVEFORMAT;
typedef AUDIOFILE_AF36WAVEFORMAT FAR  *LPAUDIOFILE_AF36WAVEFORMAT;

//
//  Audio Processing Technology structure definitions
//
//      for WAVE_FORMAT_APTX   (0x0025)
//
//
typedef struct aptxwaveformat_tag {
        WAVEFORMATEX    wfx;
} APTXWAVEFORMAT;
typedef APTXWAVEFORMAT       *PAPTXWAVEFORMAT;
typedef APTXWAVEFORMAT NEAR *NPAPTXWAVEFORMAT;
typedef APTXWAVEFORMAT FAR  *LPAPTXWAVEFORMAT;

//
//  Audiofile Inc.structure definitions
//
//      for WAVE_FORMAT_AUDIOFILE_AF10   (0x0026)
//
//

typedef struct audiofile_af10waveformat_tag {
        WAVEFORMATEX    wfx;
} AUDIOFILE_AF10WAVEFORMAT;
typedef AUDIOFILE_AF10WAVEFORMAT       *PAUDIOFILE_AF10WAVEFORMAT;
typedef AUDIOFILE_AF10WAVEFORMAT NEAR *NPAUDIOFILE_AF10WAVEFORMAT;
typedef AUDIOFILE_AF10WAVEFORMAT FAR  *LPAUDIOFILE_AF10WAVEFORMAT;

//
/* Dolby's AC-2 wave format structure definition
           WAVE_FORMAT_DOLBY_AC2    (0x0030)*/
//
typedef struct dolbyac2waveformat_tag {
        WAVEFORMATEX    wfx;
        WORD            nAuxBitsCode;
} DOLBYAC2WAVEFORMAT;

/*Microsoft's */
// WAVE_FORMAT_GSM 610           0x0031
//
typedef struct gsm610waveformat_tag {
WAVEFORMATEX    wfx;
WORD                    wSamplesPerBlock;
} GSM610WAVEFORMAT;
typedef GSM610WAVEFORMAT *PGSM610WAVEFORMAT;
typedef GSM610WAVEFORMAT NEAR    *NPGSM610WAVEFORMAT;
typedef GSM610WAVEFORMAT FAR     *LPGSM610WAVEFORMAT;

//
//      Antex Electronics Corp
//
//      for WAVE_FORMAT_ADPCME                  (0x0033)
//
//

typedef struct adpcmewaveformat_tag {
        WAVEFORMATEX    wfx;
        WORD            wSamplesPerBlock;
} ADPCMEWAVEFORMAT;
typedef ADPCMEWAVEFORMAT                *PADPCMEWAVEFORMAT;
typedef ADPCMEWAVEFORMAT NEAR   *NPADPCMEWAVEFORMAT;
typedef ADPCMEWAVEFORMAT FAR    *LPADPCMEWAVEFORMAT;

/*       Control Resources Limited */
// WAVE_FORMAT_CONTROL_RES_VQLPC                 0x0034
//
typedef struct contres_vqlpcwaveformat_tag {
WAVEFORMATEX    wfx;
WORD                    wSamplesPerBlock;
} CONTRESVQLPCWAVEFORMAT;
typedef CONTRESVQLPCWAVEFORMAT *PCONTRESVQLPCWAVEFORMAT;
typedef CONTRESVQLPCWAVEFORMAT NEAR      *NPCONTRESVQLPCWAVEFORMAT;
typedef CONTRESVQLPCWAVEFORMAT FAR       *LPCONTRESVQLPCWAVEFORMAT;

//
//
//
//      for WAVE_FORMAT_DIGIREAL                   (0x0035)
//
//

typedef struct digirealwaveformat_tag {
        WAVEFORMATEX    wfx;
        WORD            wSamplesPerBlock;
} DIGIREALWAVEFORMAT;
typedef DIGIREALWAVEFORMAT *PDIGIREALWAVEFORMAT;
typedef DIGIREALWAVEFORMAT NEAR *NPDIGIREALWAVEFORMAT;
typedef DIGIREALWAVEFORMAT FAR *LPDIGIREALWAVEFORMAT;

//
//  DSP Solutions
//
//      for WAVE_FORMAT_DIGIADPCM   (0x0036)
//
//

typedef struct digiadpcmmwaveformat_tag {
        WAVEFORMATEX    wfx;
        WORD            wSamplesPerBlock;
} DIGIADPCMWAVEFORMAT;
typedef DIGIADPCMWAVEFORMAT       *PDIGIADPCMWAVEFORMAT;
typedef DIGIADPCMWAVEFORMAT NEAR *NPDIGIADPCMWAVEFORMAT;
typedef DIGIADPCMWAVEFORMAT FAR  *LPDIGIADPCMWAVEFORMAT;

/*       Control Resources Limited */
// WAVE_FORMAT_CONTROL_RES_CR10          0x0037
//
typedef struct contres_cr10waveformat_tag {
WAVEFORMATEX    wfx;
WORD                    wSamplesPerBlock;
} CONTRESCR10WAVEFORMAT;
typedef CONTRESCR10WAVEFORMAT *PCONTRESCR10WAVEFORMAT;
typedef CONTRESCR10WAVEFORMAT NEAR       *NPCONTRESCR10WAVEFORMAT;
typedef CONTRESCR10WAVEFORMAT FAR        *LPCONTRESCR10WAVEFORMAT;

//
//  Natural Microsystems
//
//      for WAVE_FORMAT_NMS_VBXADPCM   (0x0038)
//
//

typedef struct nms_vbxadpcmmwaveformat_tag {
        WAVEFORMATEX    wfx;
        WORD            wSamplesPerBlock;
} NMS_VBXADPCMWAVEFORMAT;
typedef NMS_VBXADPCMWAVEFORMAT       *PNMS_VBXADPCMWAVEFORMAT;
typedef NMS_VBXADPCMWAVEFORMAT NEAR *NPNMS_VBXADPCMWAVEFORMAT;
typedef NMS_VBXADPCMWAVEFORMAT FAR  *LPNMS_VBXADPCMWAVEFORMAT;

//
//  Antex Electronics  structure definitions
//
//      for WAVE_FORMAT_G721_ADPCM   (0x0040)
//
//

typedef struct g721_adpcmwaveformat_tag {
        WAVEFORMATEX    wfx;
        WORD            nAuxBlockSize;
} G721_ADPCMWAVEFORMAT;
typedef G721_ADPCMWAVEFORMAT *PG721_ADPCMWAVEFORMAT;
typedef G721_ADPCMWAVEFORMAT NEAR *NPG721_ADPCMWAVEFORMAT;
typedef G721_ADPCMWAVEFORMAT FAR  *LPG721_ADPCMWAVEFORMAT;

//
//
// Microsoft MPEG audio WAV definition
//
/*  MPEG-1 audio wave format (audio layer only).   (0x0050)   */
typedef struct mpeg1waveformat_tag {
    WAVEFORMATEX    wfx;
    WORD            fwHeadLayer;
    DWORD           dwHeadBitrate;
    WORD            fwHeadMode;
    WORD            fwHeadModeExt;
    WORD            wHeadEmphasis;
    WORD            fwHeadFlags;
    DWORD           dwPTSLow;
    DWORD           dwPTSHigh;
} MPEG1WAVEFORMAT;
typedef MPEG1WAVEFORMAT                 *PMPEG1WAVEFORMAT;
typedef MPEG1WAVEFORMAT NEAR           *NPMPEG1WAVEFORMAT;
typedef MPEG1WAVEFORMAT FAR            *LPMPEG1WAVEFORMAT;

#define ACM_MPEG_LAYER1             (0x0001)
#define ACM_MPEG_LAYER2             (0x0002)
#define ACM_MPEG_LAYER3             (0x0004)
#define ACM_MPEG_STEREO             (0x0001)
#define ACM_MPEG_JOINTSTEREO        (0x0002)
#define ACM_MPEG_DUALCHANNEL        (0x0004)
#define ACM_MPEG_SINGLECHANNEL      (0x0008)
#define ACM_MPEG_PRIVATEBIT         (0x0001)
#define ACM_MPEG_COPYRIGHT          (0x0002)
#define ACM_MPEG_ORIGINALHOME       (0x0004)
#define ACM_MPEG_PROTECTIONBIT      (0x0008)
#define ACM_MPEG_ID_MPEG1           (0x0010)

//
// MPEG Layer3 WAVEFORMATEX structure
// for WAVE_FORMAT_MPEGLAYER3 (0x0055)
//
#define MPEGLAYER3_WFX_EXTRA_BYTES   12

// WAVE_FORMAT_MPEGLAYER3 format sructure
//
typedef struct mpeglayer3waveformat_tag {
  WAVEFORMATEX  wfx;
  WORD          wID;
  DWORD         fdwFlags;
  WORD          nBlockSize;
  WORD          nFramesPerBlock;
  WORD          nCodecDelay;
} MPEGLAYER3WAVEFORMAT;

typedef MPEGLAYER3WAVEFORMAT          *PMPEGLAYER3WAVEFORMAT;
typedef MPEGLAYER3WAVEFORMAT NEAR    *NPMPEGLAYER3WAVEFORMAT;
typedef MPEGLAYER3WAVEFORMAT FAR     *LPMPEGLAYER3WAVEFORMAT;

//==========================================================================;

#define MPEGLAYER3_ID_UNKNOWN            0
#define MPEGLAYER3_ID_MPEG               1
#define MPEGLAYER3_ID_CONSTANTFRAMESIZE  2

#define MPEGLAYER3_FLAG_PADDING_ISO      0x00000000
#define MPEGLAYER3_FLAG_PADDING_ON       0x00000001
#define MPEGLAYER3_FLAG_PADDING_OFF      0x00000002

//
//  Creative's ADPCM structure definitions
//
//      for WAVE_FORMAT_CREATIVE_ADPCM   (0x0200)
//
//

typedef struct creative_adpcmwaveformat_tag {
        WAVEFORMATEX    wfx;
        WORD            wRevision;
} CREATIVEADPCMWAVEFORMAT;
typedef CREATIVEADPCMWAVEFORMAT       *PCREATIVEADPCMWAVEFORMAT;
typedef CREATIVEADPCMWAVEFORMAT NEAR *NPCREATIVEADPCMWAVEFORMAT;
typedef CREATIVEADPCMWAVEFORMAT FAR  *LPCREATIVEADPCMWAVEFORMAT;

//
//    Creative FASTSPEECH
// WAVEFORMAT_CREATIVE_FASTSPEECH8   (0x0202)
//
typedef struct creative_fastspeech8format_tag {
        WAVEFORMATEX    wfx;
        WORD wRevision;
} CREATIVEFASTSPEECH8WAVEFORMAT;
typedef CREATIVEFASTSPEECH8WAVEFORMAT       *PCREATIVEFASTSPEECH8WAVEFORMAT;
typedef CREATIVEFASTSPEECH8WAVEFORMAT NEAR *NPCREATIVEFASTSPEECH8WAVEFORMAT;
typedef CREATIVEFASTSPEECH8WAVEFORMAT FAR  *LPCREATIVEFASTSPEECH8WAVEFORMAT;
//
//    Creative FASTSPEECH
// WAVEFORMAT_CREATIVE_FASTSPEECH10   (0x0203)
//
typedef struct creative_fastspeech10format_tag {
        WAVEFORMATEX    wfx;
        WORD wRevision;
} CREATIVEFASTSPEECH10WAVEFORMAT;
typedef CREATIVEFASTSPEECH10WAVEFORMAT       *PCREATIVEFASTSPEECH10WAVEFORMAT;
typedef CREATIVEFASTSPEECH10WAVEFORMAT NEAR *NPCREATIVEFASTSPEECH10WAVEFORMAT;
typedef CREATIVEFASTSPEECH10WAVEFORMAT FAR  *LPCREATIVEFASTSPEECH10WAVEFORMAT;

//
//  Fujitsu FM Towns 'SND' structure
//
//      for WAVE_FORMAT_FMMTOWNS_SND   (0x0300)
//
//

typedef struct fmtowns_snd_waveformat_tag {
        WAVEFORMATEX    wfx;
        WORD            wRevision;
} FMTOWNS_SND_WAVEFORMAT;
typedef FMTOWNS_SND_WAVEFORMAT       *PFMTOWNS_SND_WAVEFORMAT;
typedef FMTOWNS_SND_WAVEFORMAT NEAR *NPFMTOWNS_SND_WAVEFORMAT;
typedef FMTOWNS_SND_WAVEFORMAT FAR  *LPFMTOWNS_SND_WAVEFORMAT;

//
//  Olivetti structure
//
//      for WAVE_FORMAT_OLIGSM   (0x1000)
//
//

typedef struct oligsmwaveformat_tag {
        WAVEFORMATEX    wfx;
} OLIGSMWAVEFORMAT;
typedef OLIGSMWAVEFORMAT     *POLIGSMWAVEFORMAT;
typedef OLIGSMWAVEFORMAT NEAR *NPOLIGSMWAVEFORMAT;
typedef OLIGSMWAVEFORMAT  FAR  *LPOLIGSMWAVEFORMAT;

//
//  Olivetti structure
//
//      for WAVE_FORMAT_OLIADPCM   (0x1001)
//
//

typedef struct oliadpcmwaveformat_tag {
        WAVEFORMATEX    wfx;
} OLIADPCMWAVEFORMAT;
typedef OLIADPCMWAVEFORMAT     *POLIADPCMWAVEFORMAT;
typedef OLIADPCMWAVEFORMAT NEAR *NPOLIADPCMWAVEFORMAT ;
typedef OLIADPCMWAVEFORMAT  FAR  *LPOLIADPCMWAVEFORMAT;

//
//  Olivetti structure
//
//      for WAVE_FORMAT_OLICELP   (0x1002)
//
//

typedef struct olicelpwaveformat_tag {
        WAVEFORMATEX    wfx;
} OLICELPWAVEFORMAT;
typedef OLICELPWAVEFORMAT     *POLICELPWAVEFORMAT;
typedef OLICELPWAVEFORMAT NEAR *NPOLICELPWAVEFORMAT ;
typedef OLICELPWAVEFORMAT  FAR  *LPOLICELPWAVEFORMAT;

//
//  Olivetti structure
//
//      for WAVE_FORMAT_OLISBC   (0x1003)
//
//

typedef struct olisbcwaveformat_tag {
        WAVEFORMATEX    wfx;
} OLISBCWAVEFORMAT;
typedef OLISBCWAVEFORMAT     *POLISBCWAVEFORMAT;
typedef OLISBCWAVEFORMAT NEAR *NPOLISBCWAVEFORMAT ;
typedef OLISBCWAVEFORMAT  FAR  *LPOLISBCWAVEFORMAT;

//
//  Olivetti structure
//
//      for WAVE_FORMAT_OLIOPR   (0x1004)
//
//

typedef struct olioprwaveformat_tag {
        WAVEFORMATEX    wfx;
} OLIOPRWAVEFORMAT;
typedef OLIOPRWAVEFORMAT     *POLIOPRWAVEFORMAT;
typedef OLIOPRWAVEFORMAT NEAR *NPOLIOPRWAVEFORMAT ;
typedef OLIOPRWAVEFORMAT  FAR  *LPOLIOPRWAVEFORMAT;

//
//  Crystal Semiconductor IMA ADPCM format
//
//      for WAVE_FORMAT_CS_IMAADPCM   (0x0039)
//
//

typedef struct csimaadpcmwaveformat_tag {
        WAVEFORMATEX    wfx;
} CSIMAADPCMWAVEFORMAT;
typedef CSIMAADPCMWAVEFORMAT     *PCSIMAADPCMWAVEFORMAT;
typedef CSIMAADPCMWAVEFORMAT NEAR *NPCSIMAADPCMWAVEFORMAT ;
typedef CSIMAADPCMWAVEFORMAT  FAR  *LPCSIMAADPCMWAVEFORMAT;

//==========================================================================;
//
//  ACM Wave Filters
//
//
//==========================================================================;

#ifndef _ACM_WAVEFILTER
#define _ACM_WAVEFILTER

#define WAVE_FILTER_UNKNOWN         0x0000
#define WAVE_FILTER_DEVELOPMENT    (0xFFFF)

typedef struct wavefilter_tag {
    DWORD   cbStruct;           /* Size of the filter in bytes */
    DWORD   dwFilterTag;        /* filter type */
    DWORD   fdwFilter;          /* Flags for the filter (Universal Dfns) */
    DWORD   dwReserved[5];      /* Reserved for system use */
} WAVEFILTER;
typedef WAVEFILTER       *PWAVEFILTER;
typedef WAVEFILTER NEAR *NPWAVEFILTER;
typedef WAVEFILTER FAR  *LPWAVEFILTER;

#endif  /* _ACM_WAVEFILTER */

#ifndef WAVE_FILTER_VOLUME
#define WAVE_FILTER_VOLUME      0x0001

typedef struct wavefilter_volume_tag {
        WAVEFILTER      wfltr;
        DWORD           dwVolume;
} VOLUMEWAVEFILTER;
typedef VOLUMEWAVEFILTER       *PVOLUMEWAVEFILTER;
typedef VOLUMEWAVEFILTER NEAR *NPVOLUMEWAVEFILTER;
typedef VOLUMEWAVEFILTER FAR  *LPVOLUMEWAVEFILTER;

#endif  /* WAVE_FILTER_VOLUME */

#ifndef WAVE_FILTER_ECHO
#define WAVE_FILTER_ECHO        0x0002

typedef struct wavefilter_echo_tag {
        WAVEFILTER      wfltr;
        DWORD           dwVolume;
        DWORD           dwDelay;
} ECHOWAVEFILTER;
typedef ECHOWAVEFILTER       *PECHOWAVEFILTER;
typedef ECHOWAVEFILTER NEAR *NPECHOWAVEFILTER;
typedef ECHOWAVEFILTER FAR  *LPECHOWAVEFILTER;

#endif  /* WAVEFILTER_ECHO */

/* ------------------------------------------------------------------------------ */
//
// New RIFF WAVE Chunks
//

#define RIFFWAVE_inst   mmioFOURCC('i','n','s','t')

struct tag_s_RIFFWAVE_inst {
    BYTE    bUnshiftedNote;
    char    chFineTune;
    char    chGain;
    BYTE    bLowNote;
    BYTE    bHighNote;
    BYTE    bLowVelocity;
    BYTE    bHighVelocity;
};

typedef struct tag_s_RIFFWAVE_INST s_RIFFWAVE_inst;

#endif

/* ------------------------------------------------------------------------------ */
//
// New RIFF Forms
//

#ifndef NONEWRIFF

/* RIFF AVI */

//
// AVI file format is specified in a seperate file (AVIFMT.H),
// which is available in the VfW and Win 32 SDK
//

/* RIFF CPPO */

#define RIFFCPPO        mmioFOURCC('C','P','P','O')

#define RIFFCPPO_objr   mmioFOURCC('o','b','j','r')
#define RIFFCPPO_obji   mmioFOURCC('o','b','j','i')

#define RIFFCPPO_clsr   mmioFOURCC('c','l','s','r')
#define RIFFCPPO_clsi   mmioFOURCC('c','l','s','i')

#define RIFFCPPO_mbr    mmioFOURCC('m','b','r',' ')

#define RIFFCPPO_char   mmioFOURCC('c','h','a','r')

#define RIFFCPPO_byte   mmioFOURCC('b','y','t','e')
#define RIFFCPPO_int    mmioFOURCC('i','n','t',' ')
#define RIFFCPPO_word   mmioFOURCC('w','o','r','d')
#define RIFFCPPO_long   mmioFOURCC('l','o','n','g')
#define RIFFCPPO_dwrd   mmioFOURCC('d','w','r','d')
#define RIFFCPPO_flt    mmioFOURCC('f','l','t',' ')
#define RIFFCPPO_dbl    mmioFOURCC('d','b','l',' ')
#define RIFFCPPO_str    mmioFOURCC('s','t','r',' ')

#endif

/*
//////////////////////////////////////////////////////////////////////////
//
// DIB Compression Defines
//
*/

#ifndef BI_BITFIELDS
#define BI_BITFIELDS    3
#endif

#ifndef QUERYDIBSUPPORT

#define QUERYDIBSUPPORT 3073
#define QDI_SETDIBITS   0x0001
#define QDI_GETDIBITS   0x0002
#define QDI_DIBTOSCREEN 0x0004
#define QDI_STRETCHDIB  0x0008

#endif

#ifndef NOBITMAP
/* Structure definitions */

typedef struct tagEXBMINFOHEADER {
        BITMAPINFOHEADER    bmi;
        /* extended BITMAPINFOHEADER fields */
        DWORD   biExtDataOffset;

        /* Other stuff will go here */

        /* ... */

        /* Format-specific information */
        /* biExtDataOffset points here */

} EXBMINFOHEADER;

#endif          //NOBITMAP

/* New DIB Compression Defines */

#define BICOMP_IBMULTIMOTION    mmioFOURCC('U', 'L', 'T', 'I')
#define BICOMP_IBMPHOTOMOTION   mmioFOURCC('P', 'H', 'M', 'O')
#define BICOMP_CREATIVEYUV      mmioFOURCC('c', 'y', 'u', 'v')

#ifndef NOJPEGDIB

/* New DIB Compression Defines */
#define JPEG_DIB        mmioFOURCC('J','P','E','G')    /* Still image JPEG DIB biCompression */
#define MJPG_DIB        mmioFOURCC('M','J','P','G')    /* Motion JPEG DIB biCompression     */

/* JPEGProcess Definitions */
#define JPEG_PROCESS_BASELINE           0       /* Baseline DCT */

/* AVI File format extensions */
#define AVIIF_CONTROLFRAME              0x00000200L     /* This is a control frame */

    /* JIF Marker byte pairs in JPEG Interchange Format sequence */
#define JIFMK_SOF0    0xFFC0   /* SOF Huff  - Baseline DCT*/
#define JIFMK_SOF1    0xFFC1   /* SOF Huff  - Extended sequential DCT*/
#define JIFMK_SOF2    0xFFC2   /* SOF Huff  - Progressive DCT*/
#define JIFMK_SOF3    0xFFC3   /* SOF Huff  - Spatial (sequential) lossless*/
#define JIFMK_SOF5    0xFFC5   /* SOF Huff  - Differential sequential DCT*/
#define JIFMK_SOF6    0xFFC6   /* SOF Huff  - Differential progressive DCT*/
#define JIFMK_SOF7    0xFFC7   /* SOF Huff  - Differential spatial*/
#define JIFMK_JPG     0xFFC8   /* SOF Arith - Reserved for JPEG extensions*/
#define JIFMK_SOF9    0xFFC9   /* SOF Arith - Extended sequential DCT*/
#define JIFMK_SOF10   0xFFCA   /* SOF Arith - Progressive DCT*/
#define JIFMK_SOF11   0xFFCB   /* SOF Arith - Spatial (sequential) lossless*/
#define JIFMK_SOF13   0xFFCD   /* SOF Arith - Differential sequential DCT*/
#define JIFMK_SOF14   0xFFCE   /* SOF Arith - Differential progressive DCT*/
#define JIFMK_SOF15   0xFFCF   /* SOF Arith - Differential spatial*/
#define JIFMK_DHT     0xFFC4   /* Define Huffman Table(s) */
#define JIFMK_DAC     0xFFCC   /* Define Arithmetic coding conditioning(s) */
#define JIFMK_RST0    0xFFD0   /* Restart with modulo 8 count 0 */
#define JIFMK_RST1    0xFFD1   /* Restart with modulo 8 count 1 */
#define JIFMK_RST2    0xFFD2   /* Restart with modulo 8 count 2 */
#define JIFMK_RST3    0xFFD3   /* Restart with modulo 8 count 3 */
#define JIFMK_RST4    0xFFD4   /* Restart with modulo 8 count 4 */
#define JIFMK_RST5    0xFFD5   /* Restart with modulo 8 count 5 */
#define JIFMK_RST6    0xFFD6   /* Restart with modulo 8 count 6 */
#define JIFMK_RST7    0xFFD7   /* Restart with modulo 8 count 7 */
#define JIFMK_SOI     0xFFD8   /* Start of Image */
#define JIFMK_EOI     0xFFD9   /* End of Image */
#define JIFMK_SOS     0xFFDA   /* Start of Scan */
#define JIFMK_DQT     0xFFDB   /* Define quantization Table(s) */
#define JIFMK_DNL     0xFFDC   /* Define Number of Lines */
#define JIFMK_DRI     0xFFDD   /* Define Restart Interval */
#define JIFMK_DHP     0xFFDE   /* Define Hierarchical progression */
#define JIFMK_EXP     0xFFDF   /* Expand Reference Component(s) */
#define JIFMK_APP0    0xFFE0   /* Application Field 0*/
#define JIFMK_APP1    0xFFE1   /* Application Field 1*/
#define JIFMK_APP2    0xFFE2   /* Application Field 2*/
#define JIFMK_APP3    0xFFE3   /* Application Field 3*/
#define JIFMK_APP4    0xFFE4   /* Application Field 4*/
#define JIFMK_APP5    0xFFE5   /* Application Field 5*/
#define JIFMK_APP6    0xFFE6   /* Application Field 6*/
#define JIFMK_APP7    0xFFE7   /* Application Field 7*/
#define JIFMK_JPG0    0xFFF0   /* Reserved for JPEG extensions */
#define JIFMK_JPG1    0xFFF1   /* Reserved for JPEG extensions */
#define JIFMK_JPG2    0xFFF2   /* Reserved for JPEG extensions */
#define JIFMK_JPG3    0xFFF3   /* Reserved for JPEG extensions */
#define JIFMK_JPG4    0xFFF4   /* Reserved for JPEG extensions */
#define JIFMK_JPG5    0xFFF5   /* Reserved for JPEG extensions */
#define JIFMK_JPG6    0xFFF6   /* Reserved for JPEG extensions */
#define JIFMK_JPG7    0xFFF7   /* Reserved for JPEG extensions */
#define JIFMK_JPG8    0xFFF8   /* Reserved for JPEG extensions */
#define JIFMK_JPG9    0xFFF9   /* Reserved for JPEG extensions */
#define JIFMK_JPG10   0xFFFA   /* Reserved for JPEG extensions */
#define JIFMK_JPG11   0xFFFB   /* Reserved for JPEG extensions */
#define JIFMK_JPG12   0xFFFC   /* Reserved for JPEG extensions */
#define JIFMK_JPG13   0xFFFD   /* Reserved for JPEG extensions */
#define JIFMK_COM     0xFFFE   /* Comment */
#define JIFMK_TEM     0xFF01   /* for temp private use arith code */
#define JIFMK_RES     0xFF02   /* Reserved */
#define JIFMK_00      0xFF00   /* Zero stuffed byte - entropy data */
#define JIFMK_FF      0xFFFF   /* Fill byte */

/* JPEGColorSpaceID Definitions */
#define JPEG_Y          1       /* Y only component of YCbCr */
#define JPEG_YCbCr      2       /* YCbCr as define by CCIR 601 */
#define JPEG_RGB        3       /* 3 component RGB */

/* Structure definitions */

typedef struct tagJPEGINFOHEADER {
    /* compression-specific fields */
    /* these fields are defined for 'JPEG' and 'MJPG' */
    DWORD       JPEGSize;
    DWORD       JPEGProcess;

    /* Process specific fields */
    DWORD       JPEGColorSpaceID;
    DWORD       JPEGBitsPerSample;
    DWORD       JPEGHSubSampling;
    DWORD       JPEGVSubSampling;
} JPEGINFOHEADER;

#ifdef MJPGDHTSEG_STORAGE

/* Default DHT Segment */

MJPGHDTSEG_STORAGE BYTE MJPGDHTSeg[0x1A4] = {
 /* JPEG DHT Segment for YCrCb omitted from MJPG data */
0xFF,0xC4,0x01,0xA2,
0x00,0x00,0x01,0x05,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x01,0x00,0x03,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
0x08,0x09,0x0A,0x0B,0x10,0x00,0x02,0x01,0x03,0x03,0x02,0x04,0x03,0x05,0x05,0x04,0x04,0x00,
0x00,0x01,0x7D,0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,
0x07,0x22,0x71,0x14,0x32,0x81,0x91,0xA1,0x08,0x23,0x42,0xB1,0xC1,0x15,0x52,0xD1,0xF0,0x24,
0x33,0x62,0x72,0x82,0x09,0x0A,0x16,0x17,0x18,0x19,0x1A,0x25,0x26,0x27,0x28,0x29,0x2A,0x34,
0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x53,0x54,0x55,0x56,
0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x73,0x74,0x75,0x76,0x77,0x78,
0x79,0x7A,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,
0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,
0xBA,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,
0xDA,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,
0xF8,0xF9,0xFA,0x11,0x00,0x02,0x01,0x02,0x04,0x04,0x03,0x04,0x07,0x05,0x04,0x04,0x00,0x01,
0x02,0x77,0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,
0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,0xA1,0xB1,0xC1,0x09,0x23,0x33,0x52,0xF0,0x15,0x62,
0x72,0xD1,0x0A,0x16,0x24,0x34,0xE1,0x25,0xF1,0x17,0x18,0x19,0x1A,0x26,0x27,0x28,0x29,0x2A,
0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x53,0x54,0x55,0x56,
0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x73,0x74,0x75,0x76,0x77,0x78,
0x79,0x7A,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,
0x99,0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,
0xB9,0xBA,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,
0xD9,0xDA,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,
0xF9,0xFA
};

/* End DHT default */
#endif

/* End JPEG */
#endif

/* ------------------------------------------------------------------------------ */
//
// Defined IC types
//

#ifndef NONEWIC

#ifndef ICTYPE_VIDEO
#define ICTYPE_VIDEO    mmioFOURCC('v', 'i', 'd', 'c')
#define ICTYPE_AUDIO    mmioFOURCC('a', 'u', 'd', 'c')
#endif

#endif
/*
//   Misc. FOURCC registration
*/

/* Sierra Semiconductor: RDSP- Confidential RIFF file format
//       for the storage and downloading of DSP
//       code for Audio and communications devices.
*/
#define FOURCC_RDSP mmioFOURCC('R', 'D', 'S', 'P')

#ifndef MMNOMIXER
#define MIXERCONTROL_CONTROLTYPE_SRS_MTS                (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 6)
#define MIXERCONTROL_CONTROLTYPE_SRS_ONOFF              (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 7)
#define MIXERCONTROL_CONTROLTYPE_SRS_SYNTHSELECT        (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 8)
#endif

#if !defined( RC_INVOKED ) && defined( _MSC_VER )
#if _MSC_VER <= 800
#pragma pack(1)
#else
#include "poppack.h"    /* Revert to default packing */
#endif
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_MMREG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mipsinst.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    mipsinst.h

Abstract:

    Mips instruction and floating constant definitions.

Author:

    David N. Cutler (davec) 8-May-1992

Revision History:

--*/

#ifndef _MIPSINST_
#define _MIPSINST_
#if _MSC_VER > 1000
#pragma once
#endif


//
// Define MIPS instruction format structures.
//

typedef union _MIPS_INSTRUCTION {
    ULONG Long;
    UCHAR Byte[4];

    struct {
        ULONG Target : 26;
        ULONG Opcode : 6;
    } j_format;

    struct {
        LONG Simmediate : 16;
        ULONG Rt : 5;
        ULONG Rs : 5;
        ULONG Opcode : 6;
    } i_format;

    struct {
        ULONG Uimmediate : 16;
        ULONG Rt : 5;
        ULONG Rs : 5;
        ULONG Opcode : 6;
    } u_format;

    struct {
        ULONG Function : 6;
        ULONG Re : 5;
        ULONG Rd : 5;
        ULONG Rt : 5;
        ULONG Rs : 5;
        ULONG Opcode : 6;
    } r_format;

    struct {
        ULONG Function : 6;
        ULONG Re : 5;
        ULONG Rd : 5;
        ULONG Rt : 5;
        ULONG Format : 4;
        ULONG Fill1 : 1;
        ULONG Opcode : 6;
    } f_format;

    struct {
        ULONG Function : 6;
        ULONG Fd : 5;
        ULONG Fs : 5;
        ULONG Ft : 5;
        ULONG Format : 4;
        ULONG Fill1 : 1;
        ULONG Opcode : 6;
    } c_format;

} MIPS_INSTRUCTION, *PMIPS_INSTRUCTION;

//
// Define MIPS instruction opcode values.
//

#define SPEC_OP 0x0                     // special opcode - use function field
#define BCOND_OP 0x1                    // condition branch
#define J_OP 0x2                        // unconditional jump
#define JAL_OP 0x3                      // jump and link

#define BEQ_OP 0x4                      // branch equal
#define BNE_OP 0x5                      // branch not equal
#define BLEZ_OP 0x6                     // branch less than or equal
#define BGTZ_OP 0x7                     // branch greater than

#define ADDI_OP 0x8                     // add immediate signed integer
#define ADDIU_OP 0x9                    // add immediate unsigned integer
#define SLTI_OP 0xa                     // set less than signed integer
#define SLTIU_OP 0xb                    // set less than unsigned integer

#define ANDI_OP 0xc                     // and unsigned immediate integer
#define ORI_OP 0xd                      // or unsigned immediate integer
#define XORI_OP 0xe                     // exclusive or unsigned immediate
#define LUI_OP  0xf                     // load upper immediate integer

#define COP0_OP 0x10                    // coprocessor 0 operation
#define COP1_OP 0x11                    // coprocessor 1 operation

#define BEQL_OP 0x14                    // branch equal likely
#define BNEL_OP 0x15                    // branch not equal likely
#define BLEZL_OP 0x16                   // branch less than or equal likely
#define BGTZL_OP 0x17                   // branch greater than likely

#define LDL_OP 0x1a                     // load double left integer
#define LDR_OP 0x1b                     // load double right integer

#define LB_OP 0x20                      // load byte signed integer
#define LH_OP 0x21                      // load halfword signed integer
#define LWL_OP 0x22                     // load word left integer
#define LW_OP 0x23                      // load word integer

#define LBU_OP 0x24                     // load byte unsigned integer
#define LHU_OP 0x25                     // load halfword unsigned integer
#define LWR_OP 0x26                     // load word right integer
#define LWU_OP 0x27                     // load word unsigned integer

#define SB_OP 0x28                      // store byte integer
#define SH_OP 0x29                      // store halfword integer
#define SWL_OP 0x2a                     // store word left integer
#define SW_OP 0x2b                      // store word integer register

#define SDL_OP 0x2c                     // store double left integer
#define SDR_OP 0x2d                     // store double right integer
#define SWR_OP 0x2e                     // store word right integer
#define CACHE_OP 0x2f                   // cache operation

#define LL_OP 0x30                      // load linked integer register
#define LWC1_OP 0x31                    // load word floating
#define LWC2_OP 0x32                    // load word coprocessor 2

#define LLD_OP 0x34                     // load locked double integer
#define LDC1_OP 0x35                    // load word double floating
#define LDC2_OP 0x36                    // load double coprocessor 2
#define LD_OP 0x37                      // load double integer

#define SC_OP 0x38                      // store conditional word integer
#define SWC1_OP 0x39                    // store word floating
#define SWC2_OP 0x3a                    // store double coprocessor 2

#define SDC_OP 0x3c                     // store conditional double integer
#define SDC1_OP 0x3d                    // store double floating
#define SDC2_OP 0x3e                    // store double copreocessor 2
#define SD_OP 0x3f                      // store double integer register

//
// Define special function subopcodes.
//

#define SLL_OP 0x0                      // shift left logical integer
#define SRL_OP 0x2                      // shift right logical integer
#define SRA_OP 0x3                      // shift right arithmetic integer

#define SLLV_OP 0x4                     // shift left logical variable integer
#define SRLV_OP 0x6                     // shift right logical variable integer
#define SRAV_OP 0x7                     // shift right arithmetic variable integer

#define JR_OP 0x8                       // jump register
#define JALR_OP 0x9                     // jump and link register

#define SYSCALL_OP 0xc                  // system call trap
#define BREAK_OP 0xd                    // breakpoint trap

#define MFHI_OP 0x10                    // more from high integer
#define MTHI_OP 0x11                    // move to high integer
#define MFLO_OP 0x12                    // move from low integer
#define MTLO_OP 0x13                    // move to low integer

#define MULT_OP 0x18                    // multiply signed integer
#define MULTU_OP 0x19                   // multiply unsigned integer
#define DIV_OP 0x1a                     // divide signed integer
#define DIVU_OP 0x1b                    // divide unsigned integer

#define ADD_OP 0x20                     // add signed integer
#define ADDU_OP 0x21                    // add unsigned integer
#define SUP_OP 0x22                     // subtract signed integer
#define SUBU_OP 0x23                    // subtract unsigned integer

#define AND_OP 0x24                     // and integer
#define OR_OP 0x25                      // or integer
#define XOR_OP 0x26                     // exclusive or integer
#define NOR_OP 0x27                     // nor integer

#define SLT_OP 0x2a                     // set less signed integer
#define SLTU_OP 0x2b                    // set less unsigned integer

//
// Define branch conditional subopcodes.
//

#define BLTZ_OP 0x0                     // branch less that zero integer
#define BGEZ_OP 0x1                     // branch greater than or equal zero integer
#define BLTZL_OP 0x2                    // branch less that zero integer liekly
#define BGEZL_OP 0x3                    // branch greater than or equal zero integer likely

#define BLTZAL_OP 0x10                  // branch less than zero integer and link
#define BGEZAL_OP 0x11                  // branch greater than or equal zero integer and link
#define BLTZALL_OP 0x12                 // branch less than zero integer and link likely
#define BGEZALL_OP 0x13                 // branch greater than or equal zero integer and link likely

//
// Coprocessor branch true and false subfunctions and mask values.
//

#define COPz_BC_MASK 0x3e10000          // coprocessor z branch condition mask
#define COPz_BF 0x1000000               // coprocessor z branch false subfunction
#define COPz_BT 0x1010000               // coprocessor z branch true subfunction

//
// Define floating coprocessor 1 opcodes.
//

#define FLOAT_ADD 0                     // floating add
#define FLOAT_SUBTRACT 1                // floating subtract
#define FLOAT_MULTIPLY 2                // floating multiply
#define FLOAT_DIVIDE 3                  // floating divide
#define FLOAT_SQUARE_ROOT 4             // floating square root
#define FLOAT_ABSOLUTE 5                // floating absolute value
#define FLOAT_MOVE 6                    // floating move
#define FLOAT_NEGATE 7                  // floating negate

#define FLOAT_ROUND_QUADWORD 8          // floating round to longword
#define FLOAT_TRUNC_QUADWORD 9          // floating truncate to longword
#define FLOAT_CEIL_QUADWORD 10          // floating ceiling
#define FLOAT_FLOOR_QUADWORD 11         // floating floor

#define FLOAT_ROUND_LONGWORD 12         // floating round to longword
#define FLOAT_TRUNC_LONGWORD 13         // floating truncate to longword
#define FLOAT_CEIL_LONGWORD 14          // floating ceiling
#define FLOAT_FLOOR_LONGWORD 15         // floating floor

#define FLOAT_ILLEGAL 16                // illegal floating opcode

#define FLOAT_COMPARE_SINGLE 17         // floating compare single
#define FLOAT_COMPARE_DOUBLE 18         // floating compare double

#define FLOAT_CONVERT_SINGLE 32         // floating convert to single
#define FLOAT_CONVERT_DOUBLE 33         // floating convert to double

#define FLOAT_CONVERT_LONGWORD 36       // floating convert to longword integer
#define FLOAT_CONVERT_QUADWORD 37       // floating convert to quadword integer

#define FLOAT_COMPARE 48                // starting floating compare code

//
// Define floating format values.
//

#define FORMAT_SINGLE 0                 // single floating format
#define FORMAT_DOUBLE 1                 // double floating format
#define FORMAT_LONGWORD 4               // longword integer format
#define FORMAT_QUADWORD 5               // quadword integer format

//
// Define jump indirect return address register.
//

#define JUMP_RA 0x3e00008               // jump indirect return address

//
// Define maximum and minimum single and double exponent values.
//

#define DOUBLE_MAXIMUM_EXPONENT 2047
#define DOUBLE_MINIMUM_EXPONENT 0
#define SINGLE_MAXIMUM_EXPONENT 255
#define SINGLE_MINIMUM_EXPONENT 0

//
// Define single and double exponent bias values.
//

#define SINGLE_EXPONENT_BIAS 127
#define DOUBLE_EXPONENT_BIAS 1023

//
// Define the largest single and double values;
//

#define DOUBLE_MAXIMUM_VALUE 0x7fefffffffffffff
#define DOUBLE_MAXIMUM_VALUE_LOW 0xffffffff
#define DOUBLE_MAXIMUM_VALUE_HIGH 0x7fefffff
#define SINGLE_MAXIMUM_VALUE 0x7f7fffff

//
// Define single and double quite and signaling Nan values.
//

#define DOUBLE_NAN_LOW 0xffffffff
#define DOUBLE_QUIET_NAN 0x7ff7ffff
#define DOUBLE_SIGNAL_NAN 0x7fffffff
#define SINGLE_QUIET_NAN 0x7fbfffff
#define SINGLE_SIGNAL_NAN 0x7fffffff
#define DOUBLE_INTEGER_NAN 0x7fffffffffffffff
#define SINGLE_INTEGER_NAN 0x7fffffff

//
// Define positive single and double infinity values.
//

#define DOUBLE_INFINITY_VALUE 0x7ff0000000000000
#define DOUBLE_INFINITY_VALUE_LOW 0x0
#define DOUBLE_INFINITY_VALUE_HIGH 0x7ff00000
#define SINGLE_INFINITY_VALUE 0x7f800000

//
// Define rounding modes.
//

#define ROUND_TO_NEAREST 0              // round to nearest representable value
#define ROUND_TO_ZERO 1                 // round toward zero
#define ROUND_TO_PLUS_INFINITY 2        // round toward plus infinity
#define ROUND_TO_MINUS_INFINITY 3       // round toward minus infinity

#endif // MIPSINST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mcx.h ===
/************************************************************************
*                                                                       *
*   mcx.h -- This module defines the 32-Bit Windows MCX APIs            *
*                                                                       *
*   Copyright (c) 1990-1999, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef _MCX_H_
#define _MCX_H_

#if _MSC_VER > 1000
#pragma once
#endif

typedef struct _MODEMDEVCAPS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // product and version identification
    DWORD   dwModemProviderVersion;
    DWORD   dwModemManufacturerOffset;
    DWORD   dwModemManufacturerSize;
    DWORD   dwModemModelOffset;
    DWORD   dwModemModelSize;
    DWORD   dwModemVersionOffset;
    DWORD   dwModemVersionSize;

    // local option capabilities
    DWORD   dwDialOptions;          // bitmap of supported values
    DWORD   dwCallSetupFailTimer;   // maximum in seconds
    DWORD   dwInactivityTimeout;    // maximum in seconds
    DWORD   dwSpeakerVolume;        // bitmap of supported values
    DWORD   dwSpeakerMode;          // bitmap of supported values
    DWORD   dwModemOptions;         // bitmap of supported values
    DWORD   dwMaxDTERate;           // maximum value in bit/s
    DWORD   dwMaxDCERate;           // maximum value in bit/s

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMDEVCAPS, *PMODEMDEVCAPS, *LPMODEMDEVCAPS;

typedef struct _MODEMSETTINGS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // static local options (read/write)
    DWORD   dwCallSetupFailTimer;       // seconds
    DWORD   dwInactivityTimeout;        // seconds
    DWORD   dwSpeakerVolume;            // level
    DWORD   dwSpeakerMode;              // mode
    DWORD   dwPreferredModemOptions;    // bitmap

    // negotiated options (read only) for current or last call
    DWORD   dwNegotiatedModemOptions;   // bitmap
    DWORD   dwNegotiatedDCERate;        // bit/s

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMSETTINGS, *PMODEMSETTINGS, *LPMODEMSETTINGS;

// Dial Options
#define DIALOPTION_BILLING  0x00000040  // Supports wait for bong "$"
#define DIALOPTION_QUIET    0x00000080  // Supports wait for quiet "@"
#define DIALOPTION_DIALTONE 0x00000100  // Supports wait for dial tone "W"

// SpeakerVolume for MODEMDEVCAPS
#define MDMVOLFLAG_LOW      0x00000001
#define MDMVOLFLAG_MEDIUM   0x00000002
#define MDMVOLFLAG_HIGH     0x00000004

// SpeakerVolume for MODEMSETTINGS
#define MDMVOL_LOW          0x00000000
#define MDMVOL_MEDIUM       0x00000001
#define MDMVOL_HIGH         0x00000002

// SpeakerMode for MODEMDEVCAPS
#define MDMSPKRFLAG_OFF         0x00000001
#define MDMSPKRFLAG_DIAL        0x00000002
#define MDMSPKRFLAG_ON          0x00000004
#define MDMSPKRFLAG_CALLSETUP   0x00000008

// SpeakerMode for MODEMSETTINGS
#define MDMSPKR_OFF         0x00000000
#define MDMSPKR_DIAL        0x00000001
#define MDMSPKR_ON          0x00000002
#define MDMSPKR_CALLSETUP   0x00000003

// Modem Options
#define MDM_COMPRESSION      0x00000001
#define MDM_ERROR_CONTROL    0x00000002
#define MDM_FORCED_EC        0x00000004
#define MDM_CELLULAR         0x00000008
#define MDM_FLOWCONTROL_HARD 0x00000010
#define MDM_FLOWCONTROL_SOFT 0x00000020
#define MDM_CCITT_OVERRIDE   0x00000040
#define MDM_SPEED_ADJUST     0x00000080
#define MDM_TONE_DIAL        0x00000100
#define MDM_BLIND_DIAL       0x00000200
#define MDM_V23_OVERRIDE     0x00000400
#define MDM_DIAGNOSTICS      0x00000800


//=========================================================================
//
//
//      EXTENDED MODEM OPTIONS INFORMATION
//
//      THE following macros define additional bits in dwPreferredModemOptions.
//
//      These bits specify information relevant to making ISDN and GSM
//      calls, such as which protocol to use.
//
//=========================================================================

#define MDM_MASK_BEARERMODE   0x0000f000
#define MDM_SHIFT_BEARERMODE 12

#define MDM_MASK_PROTOCOLID   0x000f0000
#define MDM_SHIFT_PROTOCOLID  16

#define MDM_MASK_PROTOCOLDATA 0x0ff00000
#define MDM_SHIFT_PROTOCOLDATA  20

//
// PROTOCOLINFO is the union of PROTOCOLID and PROTOCOLDATA ...
//
#define MDM_MASK_PROTOCOLINFO  (MDM_MASK_PROTOCOLID|MDM_MASK_PROTOCOLDATA)
#define MDM_SHIFT_PROTOCOLINFO MDM_SHIFT_PROTOCOLID

//
// EXTENDEDINFO is the union of BEARERMODE and PROTOCOLINFO
//
#define MDM_MASK_EXTENDEDINFO (MDM_MASK_BEARERMODE|MDM_MASK_PROTOCOLINFO)
#define MDM_SHIFT_EXTENDEDINFO  MDM_SHIFT_BEARERMODE


#define MDM_GET_BEARERMODE(_dwOptions) \
                   (((_dwOptions)&MDM_MASK_BEARERMODE) >> MDM_SHIFT_BEARERMODE)

#define MDM_SET_BEARERMODE(_dwOptions,_bm)     \
    (((_dwOptions) &= ~MDM_MASK_BEARERMODE), \
    ((_dwOptions)  |= (((_bm)<<MDM_SHIFT_BEARERMODE)&MDM_MASK_BEARERMODE)))

#define MDM_GET_PROTOCOLID(_dwOptions) \
               (((_dwOptions)&MDM_MASK_PROTOCOLID) >> MDM_SHIFT_PROTOCOLID)

#define MDM_SET_PROTOCOLID(_dwOptions,_prot)     \
    (((_dwOptions) &= ~MDM_MASK_PROTOCOLID), \
    ((_dwOptions)  |= (((_prot)<<MDM_SHIFT_PROTOCOLID)&MDM_MASK_PROTOCOLID)))

#define MDM_GET_PROTOCOLDATA(_dwOptions) \
               (((_dwOptions)&MDM_MASK_PROTOCOLDATA) >> MDM_SHIFT_PROTOCOLDATA)

#define MDM_SET_PROTOCOLDATA(_dwOptions,_pd)     \
   (((_dwOptions) &= ~MDM_MASK_PROTOCOLDATA), \
   ((_dwOptions)  |= (((_pd)<<MDM_SHIFT_PROTOCOLDATA)&MDM_MASK_PROTOCOLDATA)))

//
// MDM_GET_PROTOCOLINFO gets the protocol-id and info bits in
// their IN-PLACE form (preserving their place in dwModemPreferredOptions)
//
#define MDM_GET_PROTOCOLINFO(_dwOptions) \
               ((_dwOptions)&MDM_MASK_PROTOCOLINFO)

//
// MDM_SET_PROTOCOLINFO takes as its argument the protocol-id and info bits in
// their IN-PLACE form (final position within dwModemPreferredOptions)
//
#define MDM_SET_PROTOCOLINFO(_dwOptions,_pinfo)     \
  (((_dwOptions) &= ~MDM_MASK_PROTOCOLINFO), \
  ((_dwOptions)  |= ((_pinfo)&MDM_MASK_PROTOCOLINFO)))

//
// MDM_GEN_PROTOCOLINFO generates the  the protocol-id and info bits in
// their IN-PLACE form (final position  within dwModemPreferredOptions).
//
#define MDM_GEN_PROTOCOLINFO(_pid, _pdata) \
        ((((_pid  )<<MDM_SHIFT_PROTOCOLID  )&MDM_MASK_PROTOCOLID  )   \
        |(((_pdata)<<MDM_SHIFT_PROTOCOLDATA)&MDM_MASK_PROTOCOLDATA))

//
// MDM_GET_EXTENDEDIONFO gets the bearermode and protocol information in
// their IN-PLACE form (preserving their place in dwModemPreferredOptions)
//
#define MDM_GET_EXTENDEDINFO(_dwOptions) \
               ((_dwOptions)&MDM_MASK_EXTENDEDINFO)

//
// MDM_SET_PROTOCOLINFO takes as its argument the bearermode and
// protocol bits in their IN-PLACE form (final position within
// dwModemPreferredOptions)
//
#define MDM_SET_EXTENDEDINFO(_dwOptions,_extinfo)     \
  (((_dwOptions) &= ~MDM_MASK_EXTENDEDINFO), \
  ((_dwOptions)  |= ((_extinfo) & MDM_MASK_EXTENDEDINFO)))


//
// MDM_GEN_EXTENDEDINFO generates the bearermode and protocol information
// in their IN-PLACE form (final position within dwModemPreferredOptions0.
//
#define MDM_GEN_EXTENDEDINFO(_bearermode, _pinfo)   \
        (((_pinfo)&MDM_MASK_PROTOCOLINFO  )         \
         |(((_bearermode)<<MDM_SHIFT_BEARERMODE)&MDM_MASK_BEARERMODE))


//=========================================================================
//  BEARER MODES
//=========================================================================
//
#define MDM_BEARERMODE_ANALOG   0x0
#define MDM_BEARERMODE_ISDN     0x1
#define MDM_BEARERMODE_GSM      0x2


//=========================================================================
//  PROTOCOL IDs
//=========================================================================
//
#define MDM_PROTOCOLID_DEFAULT  0x0
#define MDM_PROTOCOLID_HDLCPPP  0x1
#define MDM_PROTOCOLID_V128     0x2
#define MDM_PROTOCOLID_X75      0x3
#define MDM_PROTOCOLID_V110     0x4
#define MDM_PROTOCOLID_V120     0x5
#define MDM_PROTOCOLID_AUTO     0x6 // Auto protocol detection.
#define MDM_PROTOCOLID_ANALOG   0x7 // Applicable only to GSM
#define MDM_PROTOCOLID_GPRS     0x8
#define MDM_PROTOCOLID_PIAFS    0x9


//=========================================================================
//  HDLC PPP PROTOCOL INFORMATION
//=========================================================================
//
// Following are specific to the HDLC-PPP protocol.
// The shifts are w.r.t. the start of the PROTOCOLDATA field.

#define MDM_SHIFT_HDLCPPP_SPEED    0x0
#define MDM_MASK_HDLCPPP_SPEED     0x7  // 3 bits

#define MDM_HDLCPPP_SPEED_DEFAULT  0x0
#define MDM_HDLCPPP_SPEED_64K      0x1
#define MDM_HDLCPPP_SPEED_56K      0x2


#define MDM_SHIFT_HDLCPPP_AUTH     0x3
#define MDM_MASK_HDLCPPP_AUTH      (0x7<<3)  // 3 bits

#define MDM_HDLCPPP_AUTH_DEFAULT   0x0
#define MDM_HDLCPPP_AUTH_NONE      0x1
#define MDM_HDLCPPP_AUTH_PAP       0x2
#define MDM_HDLCPPP_AUTH_CHAP      0x3
#define MDM_HDLCPPP_AUTH_MSCHAP    0x4


#define MDM_SHIFT_HDLCPPP_ML       0x6
#define MDM_MASK_HDLCPPP_ML        (0x3<<6)  // 2 bits

#define MDM_HDLCPPP_ML_DEFAULT     0x0
#define MDM_HDLCPPP_ML_NONE        0x1
#define MDM_HDLCPPP_ML_2           0x2

#define MDM_GEN_HDLCPPP_PROTOCOL_DATA(_speed, _auth, _ml)           \
    ((((_speed)<<MDM_SHIFT_HDLCPPP_SPEED)&MDM_MASK_HDLCPPP_SPEED)   \
    |(((_auth )<<MDM_SHIFT_HDLCPPP_AUTH )&MDM_MASK_HDLCPPP_AUTH )   \
    |(((_ml   )<<MDM_SHIFT_HDLCPPP_ML   )&MDM_MASK_HDLCPPP_ML   ))


#define MDM_PROTOCOL_HDLCPPP_64K        \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_64K,      \
            MDM_HDLCPPP_AUTH_DEFAULT,   \
            MDM_HDLCPPP_ML_DEFAULT      \
            )                           \
        )

#define MDM_PROTOCOL_HDLCPPP_56K        \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_56K,      \
            MDM_HDLCPPP_AUTH_DEFAULT,   \
            MDM_HDLCPPP_ML_DEFAULT      \
            )                           \
        )

#define MDM_PROTOCOL_HDLCPPP_112K       \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_56K,      \
            MDM_HDLCPPP_AUTH_DEFAULT,   \
            MDM_HDLCPPP_ML_2            \
            )                           \
        )

#define MDM_PROTOCOL_HDLCPPP_112K_PAP   \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_56K,      \
            MDM_HDLCPPP_AUTH_PAP,       \
            MDM_HDLCPPP_ML_2            \
            )                           \
        )

#define MDM_PROTOCOL_HDLCPPP_112K_CHAP  \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_56K,      \
            MDM_HDLCPPP_AUTH_CHAP,      \
            MDM_HDLCPPP_ML_2            \
            )                           \
        )

#define MDM_PROTOCOL_HDLCPPP_112K_MSCHAP\
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_56K,      \
            MDM_HDLCPPP_AUTH_MSCHAP,    \
            MDM_HDLCPPP_ML_2            \
            )                           \
        )
#define MDM_PROTOCOL_HDLCPPP_128K       \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_64K,      \
            MDM_HDLCPPP_AUTH_DEFAULT,   \
            MDM_HDLCPPP_ML_2            \
            )                           \
        )

#define MDM_PROTOCOL_HDLCPPP_128K_PAP   \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_64K,      \
            MDM_HDLCPPP_AUTH_PAP,       \
            MDM_HDLCPPP_ML_2            \
            )                           \
        )

#define MDM_PROTOCOL_HDLCPPP_128K_CHAP  \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_64K,      \
            MDM_HDLCPPP_AUTH_CHAP,      \
            MDM_HDLCPPP_ML_2            \
            )                           \
        )

#define MDM_PROTOCOL_HDLCPPP_128K_MSCHAP\
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_64K,      \
            MDM_HDLCPPP_AUTH_MSCHAP,    \
            MDM_HDLCPPP_ML_2            \
            )                           \
        )

//=========================================================================
//  V120 PROTOCOL INFORMATION
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================

#define MDM_SHIFT_V120_SPEED    0x0
#define MDM_MASK_V120_SPEED     0x7  // 3 bits

#define MDM_V120_SPEED_DEFAULT  0x0
#define MDM_V120_SPEED_64K      0x1
#define MDM_V120_SPEED_56K      0x2


#define MDM_SHIFT_V120_ML       0x6
#define MDM_MASK_V120_ML        (0x3<<6)  // 2 bits

#define MDM_V120_ML_DEFAULT     0x0
#define MDM_V120_ML_NONE        0x1
#define MDM_V120_ML_2           0x2


#define MDM_GEN_V120_PROTOCOL_DATA(_speed, _ml)               \
    ((((_speed)<<MDM_SHIFT_V120_SPEED)&MDM_MASK_V120_SPEED)   \
    |(((_ml   )<<MDM_SHIFT_V120_ML   )&MDM_MASK_V120_ML   ))


#define MDM_PROTOCOL_V120_64K       \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V120,        \
        MDM_GEN_V120_PROTOCOL_DATA (\
            MDM_V120_SPEED_64K,     \
            MDM_V120_ML_NONE        \
            )                       \
        )

#define MDM_PROTOCOL_V120_56K       \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V120,        \
        MDM_GEN_V120_PROTOCOL_DATA (\
            MDM_V120_SPEED_56K,     \
            MDM_V120_ML_NONE        \
            )                       \
        )

#define MDM_PROTOCOL_V120_112K      \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V120,        \
        MDM_GEN_V120_PROTOCOL_DATA (\
            MDM_V120_SPEED_56K,     \
            MDM_V120_ML_2           \
            )                       \
        )

#define MDM_PROTOCOL_V120_128K      \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V120,        \
        MDM_GEN_V120_PROTOCOL_DATA (\
            MDM_V120_SPEED_64K,     \
            MDM_V120_ML_2           \
            )                       \
        )


//=========================================================================
//  X75 PROTOCOL INFORMATION
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================


#define MDM_SHIFT_X75_DATA    0x0
#define MDM_MASK_X75_DATA     0x7  // 3 bits

#define MDM_X75_DATA_DEFAULT  0x0
#define MDM_X75_DATA_64K      0x1
#define MDM_X75_DATA_128K     0x2
#define MDM_X75_DATA_T_70     0x3
#define MDM_X75_DATA_BTX      0x4

#define MDM_GEN_X75_PROTOCOL_DATA(_data) \
    (((_data)<<MDM_SHIFT_X75_DATA)&MDM_MASK_X75_DATA)


#define MDM_PROTOCOL_X75_64K        \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_X75,         \
        MDM_GEN_X75_PROTOCOL_DATA ( \
            MDM_X75_DATA_64K        \
            )                       \
        )

#define MDM_PROTOCOL_X75_128K       \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_X75,         \
        MDM_GEN_X75_PROTOCOL_DATA ( \
            MDM_X75_DATA_128K       \
            )                       \
        )

#define MDM_PROTOCOL_X75_T_70       \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_X75,         \
        MDM_GEN_X75_PROTOCOL_DATA ( \
            MDM_X75_DATA_T_70       \
            )                       \
        )                           \

#define MDM_PROTOCOL_X75_BTX        \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_X75,         \
        MDM_GEN_X75_PROTOCOL_DATA ( \
            MDM_X75_DATA_BTX        \
            )                       \
        )


//=========================================================================
//  V110 PROTOCOL INFORMATION
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================


#define MDM_SHIFT_V110_SPEED   0x0
#define MDM_MASK_V110_SPEED    0xf  // 4 bits

#define MDM_V110_SPEED_DEFAULT 0x0
#define MDM_V110_SPEED_1DOT2K  0x1
#define MDM_V110_SPEED_2DOT4K  0x2
#define MDM_V110_SPEED_4DOT8K  0x3
#define MDM_V110_SPEED_9DOT6K  0x4
#define MDM_V110_SPEED_12DOT0K 0x5
#define MDM_V110_SPEED_14DOT4K 0x6
#define MDM_V110_SPEED_19DOT2K 0x7
#define MDM_V110_SPEED_28DOT8K 0x8
#define MDM_V110_SPEED_38DOT4K 0x9
#define MDM_V110_SPEED_57DOT6K 0xA

#define MDM_GEN_V110_PROTOCOL_DATA(_data) \
    (((_data)<<MDM_SHIFT_V110_SPEED)&MDM_MASK_V110_SPEED)


#define MDM_PROTOCOL_V110_1DOT2K    \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_1DOT2K   \
            )                       \
        )

#define MDM_PROTOCOL_V110_2DOT4K    \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_2DOT4K   \
            )                       \
        )

#define MDM_PROTOCOL_V110_4DOT8K    \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_4DOT8K   \
            )                       \
        )

#define MDM_PROTOCOL_V110_9DOT6K    \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_9DOT6K   \
            )                       \
        )

#define MDM_PROTOCOL_V110_12DOT0K   \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_12DOT0K  \
            )                       \
        )

#define MDM_PROTOCOL_V110_14DOT4K   \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_14DOT4K  \
            )                       \
        )

#define MDM_PROTOCOL_V110_19DOT2K   \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_19DOT2K  \
            )                       \
        )

#define MDM_PROTOCOL_V110_28DOT8K   \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_28DOT8K  \
            )                       \
        )

#define MDM_PROTOCOL_V110_38DOT4K   \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_38DOT4K  \
            )                       \
        )

#define MDM_PROTOCOL_V110_57DOT6K   \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_57DOT6K  \
            )                       \
        )

//=========================================================================
//  AUTO PROTOCOL INFORMATION (ie, when the protocol is detected automatically)
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================
//
// Following are specific to the AUTO-protocol
//

#define MDM_SHIFT_AUTO_SPEED    0x0
#define MDM_MASK_AUTO_SPEED     0x7  // 3 bits
#define MDM_AUTO_SPEED_DEFAULT  0x0

#define MDM_SHIFT_AUTO_ML       0x6
#define MDM_MASK_AUTO_ML        (0x3<<6)  // 2 bits
#define MDM_AUTO_ML_DEFAULT     0x0
#define MDM_AUTO_ML_NONE        0x1
#define MDM_AUTO_ML_2           0x2

#define MDM_GEN_AUTO_PROTOCOL_DATA(_speed, _ml)             \
    ((((_speed)<<MDM_SHIFT_AUTO_SPEED)&MDM_MASK_AUTO_SPEED) \
    |(((_ml   )<<MDM_SHIFT_AUTO_ML   )&MDM_MASK_AUTO_ML))


#define MDM_PROTOCOL_AUTO_1CH       \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_AUTO,        \
        MDM_GEN_AUTO_PROTOCOL_DATA (\
            MDM_AUTO_SPEED_DEFAULT, \
            MDM_AUTO_ML_NONE        \
            )                       \
        )

#define MDM_PROTOCOL_AUTO_2CH       \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_AUTO,        \
        MDM_GEN_AUTO_PROTOCOL_DATA (\
            MDM_AUTO_SPEED_DEFAULT, \
            MDM_AUTO_ML_2           \
            )                       \
        )

//=========================================================================
//  ANALOG PROTOCOL INFORMATION (Applicable only to GSM)
//=========================================================================
//
// Following are specific to GSM Analog protocol
//

#define MDM_ANALOG_RLP_ON       0x0
#define MDM_ANALOG_RLP_OFF      0x1
#define MDM_ANALOG_V34          0x2

#define MDM_GEN_ANALOG_PROTOCOL_DATA(_rlp) \
    (_rlp)


#define MDM_PROTOCOL_ANALOG_RLP         \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_ANALOG,          \
        MDM_GEN_ANALOG_PROTOCOL_DATA (  \
            MDM_ANALOG_RLP_ON           \
            )                           \
        )

#define MDM_PROTOCOL_ANALOG_NRLP        \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_ANALOG,          \
        MDM_GEN_ANALOG_PROTOCOL_DATA (  \
            MDM_ANALOG_RLP_OFF          \
            )                           \
        )

//
//  v34 anolog for isdn
//
#define MDM_PROTOCOL_ANALOG_V34         \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_ANALOG,          \
        MDM_GEN_ANALOG_PROTOCOL_DATA (  \
            MDM_ANALOG_V34              \
            )                           \
        )


//=========================================================================
//  GPRS PROTOCOL INFORMATION (Applicable only to GSM)
//=========================================================================
//
// Following are specific to GPRS protocol
//

#define MDM_PROTOCOL_GPRS             \
    MDM_GEN_PROTOCOLINFO(             \
        MDM_PROTOCOLID_GPRS,          \
        0                             \
        )


//=========================================================================
//  PIAFS PROTOCOL INFORMATION
//=========================================================================
//
// Following are specific to PIAFS protocol
//

#define MDM_PIAFS_INCOMING            0
#define MDM_PIAFS_OUTGOING            1

#define MDM_PROTOCOL_PIAFS_INCOMING   \
    MDM_GEN_PROTOCOLINFO(             \
        MDM_PROTOCOLID_PIAFS,         \
        MDM_PIAFS_INCOMING            \
        )

#define MDM_PROTOCOL_PIAFS_OUTGOING   \
    MDM_GEN_PROTOCOLINFO(             \
        MDM_PROTOCOLID_PIAFS,         \
        MDM_PIAFS_OUTGOING           \
        )

#endif /* _MCX_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mountmgr.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    mountmgr.h

Abstract:

    This file defines the external mount point interface for administering
    mount points.

Author:

    norbertk

Revision History:

--*/

#ifndef _MOUNTMGR_
#define _MOUNTMGR_

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef FAR
#define FAR
#endif


#define MOUNTMGR_DEVICE_NAME        L"\\Device\\MountPointManager"
#define MOUNTMGR_DOS_DEVICE_NAME    L"\\\\.\\MountPointManager"

#define MOUNTMGRCONTROLTYPE  ((ULONG) 'm')
#define MOUNTDEVCONTROLTYPE  ((ULONG) 'M')

//
// These are the IOCTLs supported by the mount point manager.
//

#define IOCTL_MOUNTMGR_CREATE_POINT                 CTL_CODE(MOUNTMGRCONTROLTYPE, 0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_DELETE_POINTS                CTL_CODE(MOUNTMGRCONTROLTYPE, 1, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_POINTS                 CTL_CODE(MOUNTMGRCONTROLTYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY         CTL_CODE(MOUNTMGRCONTROLTYPE, 3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER            CTL_CODE(MOUNTMGRCONTROLTYPE, 4, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS          CTL_CODE(MOUNTMGRCONTROLTYPE, 5, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED   CTL_CODE(MOUNTMGRCONTROLTYPE, 6, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED   CTL_CODE(MOUNTMGRCONTROLTYPE, 7, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_CHANGE_NOTIFY                CTL_CODE(MOUNTMGRCONTROLTYPE, 8, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE      CTL_CODE(MOUNTMGRCONTROLTYPE, 9, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES    CTL_CODE(MOUNTMGRCONTROLTYPE, 10, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION  CTL_CODE(MOUNTMGRCONTROLTYPE, 11, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH        CTL_CODE(MOUNTMGRCONTROLTYPE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS       CTL_CODE(MOUNTMGRCONTROLTYPE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Input structure for IOCTL_MOUNTMGR_CREATE_POINT.
//

typedef struct _MOUNTMGR_CREATE_POINT_INPUT {
    USHORT  SymbolicLinkNameOffset;
    USHORT  SymbolicLinkNameLength;
    USHORT  DeviceNameOffset;
    USHORT  DeviceNameLength;
} MOUNTMGR_CREATE_POINT_INPUT, *PMOUNTMGR_CREATE_POINT_INPUT;

//
// Input structure for IOCTL_MOUNTMGR_DELETE_POINTS,
// IOCTL_MOUNTMGR_QUERY_POINTS, and IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY.
//

typedef struct _MOUNTMGR_MOUNT_POINT {
    ULONG   SymbolicLinkNameOffset;
    USHORT  SymbolicLinkNameLength;
    ULONG   UniqueIdOffset;
    USHORT  UniqueIdLength;
    ULONG   DeviceNameOffset;
    USHORT  DeviceNameLength;
} MOUNTMGR_MOUNT_POINT, *PMOUNTMGR_MOUNT_POINT;

//
// Output structure for IOCTL_MOUNTMGR_DELETE_POINTS,
// IOCTL_MOUNTMGR_QUERY_POINTS, and IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY.
//

typedef struct _MOUNTMGR_MOUNT_POINTS {
    ULONG                   Size;
    ULONG                   NumberOfMountPoints;
    MOUNTMGR_MOUNT_POINT    MountPoints[1];
} MOUNTMGR_MOUNT_POINTS, *PMOUNTMGR_MOUNT_POINTS;

//
// Input structure for IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER.
//

typedef struct _MOUNTMGR_DRIVE_LETTER_TARGET {
    USHORT  DeviceNameLength;
    WCHAR   DeviceName[1];
} MOUNTMGR_DRIVE_LETTER_TARGET, *PMOUNTMGR_DRIVE_LETTER_TARGET;

//
// Output structure for IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER.
//

typedef struct _MOUNTMGR_DRIVE_LETTER_INFORMATION {
    BOOLEAN DriveLetterWasAssigned;
    UCHAR   CurrentDriveLetter;
} MOUNTMGR_DRIVE_LETTER_INFORMATION, *PMOUNTMGR_DRIVE_LETTER_INFORMATION;

//
// Input structure for IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED and
// IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED.
//

typedef struct _MOUNTMGR_VOLUME_MOUNT_POINT {
    USHORT  SourceVolumeNameOffset;
    USHORT  SourceVolumeNameLength;
    USHORT  TargetVolumeNameOffset;
    USHORT  TargetVolumeNameLength;
} MOUNTMGR_VOLUME_MOUNT_POINT, *PMOUNTMGR_VOLUME_MOUNT_POINT;

//
// Input structure for IOCTL_MOUNTMGR_CHANGE_NOTIFY.
// Output structure for IOCTL_MOUNTMGR_CHANGE_NOTIFY.
//

typedef struct _MOUNTMGR_CHANGE_NOTIFY_INFO {
    ULONG   EpicNumber;
} MOUNTMGR_CHANGE_NOTIFY_INFO, *PMOUNTMGR_CHANGE_NOTIFY_INFO;

//
// Input structure for IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE,
// IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION,
// IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH, and
// IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS.
//

typedef struct _MOUNTMGR_TARGET_NAME {
    USHORT  DeviceNameLength;
    WCHAR   DeviceName[1];
} MOUNTMGR_TARGET_NAME, *PMOUNTMGR_TARGET_NAME;

//
// Output structure for IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH and
// IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS.
//

typedef struct _MOUNTMGR_VOLUME_PATHS {
    ULONG   MultiSzLength;
    WCHAR   MultiSz[1];
} MOUNTMGR_VOLUME_PATHS, *PMOUNTMGR_VOLUME_PATHS;

//
// Macro that defines what a "drive letter" mount point is.  This macro can
// be used to scan the result from QUERY_POINTS to discover which mount points
// are find "drive letter" mount points.
//

#define MOUNTMGR_IS_DRIVE_LETTER(s) (   \
    (s)->Length == 28 &&                \
    (s)->Buffer[0] == '\\' &&           \
    (s)->Buffer[1] == 'D' &&            \
    (s)->Buffer[2] == 'o' &&            \
    (s)->Buffer[3] == 's' &&            \
    (s)->Buffer[4] == 'D' &&            \
    (s)->Buffer[5] == 'e' &&            \
    (s)->Buffer[6] == 'v' &&            \
    (s)->Buffer[7] == 'i' &&            \
    (s)->Buffer[8] == 'c' &&            \
    (s)->Buffer[9] == 'e' &&            \
    (s)->Buffer[10] == 's' &&           \
    (s)->Buffer[11] == '\\' &&          \
    (s)->Buffer[12] >= 'A' &&           \
    (s)->Buffer[12] <= 'Z' &&           \
    (s)->Buffer[13] == ':')

//
// Macro that defines what a "volume name" mount point is.  This macro can
// be used to scan the result from QUERY_POINTS to discover which mount points
// are "volume name" mount points.
//

#define MOUNTMGR_IS_VOLUME_NAME(s) (                                          \
     ((s)->Length == 96 || ((s)->Length == 98 && (s)->Buffer[48] == '\\')) && \
     (s)->Buffer[0] == '\\' &&                                                \
     ((s)->Buffer[1] == '?' || (s)->Buffer[1] == '\\') &&                     \
     (s)->Buffer[2] == '?' &&                                                 \
     (s)->Buffer[3] == '\\' &&                                                \
     (s)->Buffer[4] == 'V' &&                                                 \
     (s)->Buffer[5] == 'o' &&                                                 \
     (s)->Buffer[6] == 'l' &&                                                 \
     (s)->Buffer[7] == 'u' &&                                                 \
     (s)->Buffer[8] == 'm' &&                                                 \
     (s)->Buffer[9] == 'e' &&                                                 \
     (s)->Buffer[10] == '{' &&                                                \
     (s)->Buffer[19] == '-' &&                                                \
     (s)->Buffer[24] == '-' &&                                                \
     (s)->Buffer[29] == '-' &&                                                \
     (s)->Buffer[34] == '-' &&                                                \
     (s)->Buffer[47] == '}'                                                   \
    )

#define MOUNTMGR_IS_DOS_VOLUME_NAME(s) (    \
     MOUNTMGR_IS_VOLUME_NAME(s) &&          \
     (s)->Length == 96 &&                   \
     (s)->Buffer[1] == '\\'                 \
    )

#define MOUNTMGR_IS_DOS_VOLUME_NAME_WB(s) ( \
     MOUNTMGR_IS_VOLUME_NAME(s) &&          \
     (s)->Length == 98 &&                   \
     (s)->Buffer[1] == '\\'                 \
    )

#define MOUNTMGR_IS_NT_VOLUME_NAME(s) (     \
     MOUNTMGR_IS_VOLUME_NAME(s) &&          \
     (s)->Length == 96 &&                   \
     (s)->Buffer[1] == '?'                  \
    )

#define MOUNTMGR_IS_NT_VOLUME_NAME_WB(s) (  \
     MOUNTMGR_IS_VOLUME_NAME(s) &&          \
     (s)->Length == 98 &&                   \
     (s)->Buffer[1] == '?'                  \
    )

//
// The following IOCTL is supported by mounted devices.
//

#define IOCTL_MOUNTDEV_QUERY_DEVICE_NAME    CTL_CODE(MOUNTDEVCONTROLTYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Output structure for IOCTL_MOUNTDEV_QUERY_DEVICE_NAME.
//

typedef struct _MOUNTDEV_NAME {
    USHORT  NameLength;
    WCHAR   Name[1];
} MOUNTDEV_NAME, *PMOUNTDEV_NAME;

//
// Devices that wish to be mounted should report this GUID in
// IoRegisterDeviceInterface.
//

DEFINE_GUID(MOUNTDEV_MOUNTED_DEVICE_GUID, 0x53f5630d, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\msviddrv.h ===
/****************************************************************************/
/*                                                                          */
/*        MSVIDDRV.H - Include file for messages to video capture drivers   */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1999, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MSVIDDRV
#define _INC_MSVIDDRV	50	/* version number */

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****************************************************************************

                 Digital Video Messages (DVM_)

****************************************************************************/

// General messages
#define DVM_START                         DRV_USER
#define DVM_GETERRORTEXT                  (DVM_START + 0)
#define DVM_GETVIDEOAPIVER                (DVM_START + 1)

// This value increments each time the API changes
// It is passed to the driver in the DRV_OPEN message.
#define VIDEOAPIVERSION 		4

// General messages applicable to all channel types
#define DVM_DIALOG			(DVM_START + 100)
#define DVM_CONFIGURESTORAGE		(DVM_START + 101)
#define DVM_GET_CHANNEL_CAPS         	(DVM_START + 102)
#define DVM_UPDATE         		(DVM_START + 103)

// Single frame msg
#define DVM_FRAME			(DVM_START + 200)

// stream messages
#define DVM_STREAM_MSG_START            (DVM_START + 300)
#define DVM_STREAM_MSG_END              (DVM_START + 399)

#define DVM_STREAM_ADDBUFFER            (DVM_START + 300)
#define DVM_STREAM_FINI                 (DVM_START + 301)
#define DVM_STREAM_GETERROR             (DVM_START + 302)
#define DVM_STREAM_GETPOSITION          (DVM_START + 303)
#define DVM_STREAM_INIT                 (DVM_START + 304)
#define DVM_STREAM_PREPAREHEADER        (DVM_START + 305)
#define DVM_STREAM_RESET                (DVM_START + 306)
#define DVM_STREAM_START                (DVM_START + 307)
#define DVM_STREAM_STOP                 (DVM_START + 308)
#define DVM_STREAM_UNPREPAREHEADER      (DVM_START + 309)

// Following added post VFW1.1a, but are now obsolete
#define DVM_STREAM_ALLOCHDRANDBUFFER    (DVM_START + 310)
#define DVM_STREAM_FREEHDRANDBUFFER     (DVM_START + 311)
// The 2 messages above will be removed once the ALLOCBUFFER code is ready

// Following added for Win95 and NTPPC
#define DVM_STREAM_ALLOCBUFFER          (DVM_START + 312)
#define DVM_STREAM_FREEBUFFER           (DVM_START + 313)

// NOTE that DVM_CONFIGURE numbers will start at 0x1000 (for configure API)


/****************************************************************************

                            Open Definitions

****************************************************************************/
#define OPEN_TYPE_VCAP mmioFOURCC('v', 'c', 'a', 'p')

// The following structure is the same as IC_OPEN
// to allow compressors and capture devices to share
// the same DriverProc.

typedef struct tag_video_open_parms {
    DWORD               dwSize;         // sizeof(VIDEO_OPEN_PARMS)
    FOURCC              fccType;        // 'vcap'
    FOURCC              fccComp;        // unused
    DWORD               dwVersion;      // version of msvideo opening you
    DWORD               dwFlags;        // channel type
    DWORD               dwError;        // if open fails, this is why
    LPVOID              pV1Reserved;    // Reserved
    LPVOID              pV2Reserved;    // Reserved
    DWORD               dnDevNode;      // Devnode for PnP devices
} VIDEO_OPEN_PARMS, FAR * LPVIDEO_OPEN_PARMS;

typedef struct tag_video_geterrortext_parms {
       DWORD  dwError;          // The error number to identify
#ifdef _WIN32
       LPWSTR lpText;		// Text buffer to fill
#else
       LPSTR lpText;		// Text buffer to fill
#endif
       DWORD  dwLength;		// Size of text buffer in characters
} VIDEO_GETERRORTEXT_PARMS, FAR * LPVIDEO_GETERRORTEXT_PARMS;

typedef struct tag_video_stream_init_parms {
       DWORD  dwMicroSecPerFrame;
       DWORD  dwCallback;
       DWORD  dwCallbackInst;
       DWORD  dwFlags;
       HANDLE hVideo;
} VIDEO_STREAM_INIT_PARMS, FAR * LPVIDEO_STREAM_INIT_PARMS;

typedef struct tag_video_configure_parms {
       LPDWORD  lpdwReturn;	// Return parameter from configure MSG.
       LPVOID	lpData1;	// Pointer to data 1.
       DWORD	dwSize1;	// size of data buffer 1.
       LPVOID	lpData2;	// Pointer to data 2.
       DWORD	dwSize2;	// size of data buffer 2.
} VIDEOCONFIGPARMS, FAR * LPVIDEOCONFIGPARMS;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDDRV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\msacmdrv.h ===
//==========================================================================;
//
//  msacmdrv.h
//
//  Copyright (c) 1992-1999 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//      Audio Compression Manager Public Header File for Drivers
//
//  History:
//
//==========================================================================;

#ifndef _INC_ACMDRV
#define _INC_ACMDRV         /* #defined if msacmdrv.h has been included */

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_INC_ACM)
#ifndef RC_INVOKED
#error MSACM.H to be included first
#endif
#endif

#include "pshpack1.h"   /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {                /* Assume C declarations for C++ */
#endif  /* __cplusplus */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Version:
//
//  the version is a 32 bit number that is broken into three parts as
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows:
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) &
//      wBuild = LOWORD(dwVersion)
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define MAKE_ACM_VERSION(mjr, mnr, bld) (((long)(mjr)<<24)| \
                                         ((long)(mnr)<<16)| \
                                         ((long)bld))


#ifdef WIN32
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  under WIN32 all drivers use unicode structures.  these have already
//  been #defined in MSACM.H.  however, regardless of whether UNICODE is
//  defined, we will define these structures as unicode structures for use
//  in 32-bit drivers.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#undef ACMDRIVERDETAILS
#undef PACMDRIVERDETAILS
#undef LPACMDRIVERDETAILS

#undef ACMFORMATTAGDETAILS
#undef PACMFORMATTAGDETAILS
#undef LPACMFORMATTAGDETAILS

#undef ACMFORMATDETAILS
#undef PACMFORMATDETAILS
#undef LPACMFORMATDETAILS

#undef ACMFORMATCHOOSE
#undef PACMFORMATCHOOSE
#undef LPACMFORMATCHOOSE

#undef ACMFILTERTAGDETAILS
#undef PACMFILTERTAGDETAILS
#undef LPACMFILTERTAGDETAILS

#undef ACMFILTERDETAILS
#undef PACMFILTERDETAILS
#undef LPACMFILTERDETAILS

#undef ACMFILTERCHOOSE
#undef PACMFILTERCHOOSE
#undef LPACMFILTERCHOOSE

#define ACMDRIVERDETAILS        ACMDRIVERDETAILSW
#define PACMDRIVERDETAILS       PACMDRIVERDETAILSW
#define LPACMDRIVERDETAILS      LPACMDRIVERDETAILSW

#define ACMFORMATTAGDETAILS     ACMFORMATTAGDETAILSW
#define PACMFORMATTAGDETAILS    PACMFORMATTAGDETAILSW
#define LPACMFORMATTAGDETAILS   LPACMFORMATTAGDETAILSW

#define ACMFORMATDETAILS	ACMFORMATDETAILSW
#define PACMFORMATDETAILS	PACMFORMATDETAILSW
#define LPACMFORMATDETAILS	LPACMFORMATDETAILSW

#define ACMFORMATCHOOSE		ACMFORMATCHOOSEW
#define PACMFORMATCHOOSE	PACMFORMATCHOOSEW
#define LPACMFORMATCHOOSE	LPACMFORMATCHOOSEW

#define ACMFILTERTAGDETAILS     ACMFILTERTAGDETAILSW
#define PACMFILTERTAGDETAILS    PACMFILTERTAGDETAILSW
#define LPACMFILTERTAGDETAILS   LPACMFILTERTAGDETAILSW

#define ACMFILTERDETAILS	ACMFILTERDETAILSW
#define PACMFILTERDETAILS	PACMFILTERDETAILSW
#define LPACMFILTERDETAILS	LPACMFILTERDETAILSW

#define ACMFILTERCHOOSE		ACMFILTERCHOOSEW
#define PACMFILTERCHOOSE	PACMFILTERCHOOSEW
#define LPACMFILTERCHOOSE	LPACMFILTERCHOOSEW

#endif

//
//
//
//
//
#define ACMDRVOPENDESC_SECTIONNAME_CHARS

#ifdef _WIN32
typedef struct tACMDRVOPENDESCA
{
    DWORD           cbStruct;       // sizeof(ACMDRVOPENDESC)
    FOURCC          fccType;        // 'audc'
    FOURCC          fccComp;        // sub-type (not used--must be 0)
    DWORD           dwVersion;      // current version of ACM opening you
    DWORD           dwFlags;        //
    DWORD           dwError;        // result from DRV_OPEN request
    LPCSTR          pszSectionName; // see DRVCONFIGINFO.lpszDCISectionName
    LPCSTR          pszAliasName;   // see DRVCONFIGINFO.lpszDCIAliasName
    DWORD	    dnDevNode;	    // devnode id for pnp drivers.

} ACMDRVOPENDESCA, *PACMDRVOPENDESCA, FAR *LPACMDRVOPENDESCA;

typedef struct tACMDRVOPENDESCW
{
    DWORD           cbStruct;       // sizeof(ACMDRVOPENDESC)
    FOURCC          fccType;        // 'audc'
    FOURCC          fccComp;        // sub-type (not used--must be 0)
    DWORD           dwVersion;      // current version of ACM opening you
    DWORD           dwFlags;        //
    DWORD           dwError;        // result from DRV_OPEN request
    LPCWSTR         pszSectionName; // see DRVCONFIGINFO.lpszDCISectionName
    LPCWSTR         pszAliasName;   // see DRVCONFIGINFO.lpszDCIAliasName
    DWORD	    dnDevNode;	    // devnode id for pnp drivers.

} ACMDRVOPENDESCW, *PACMDRVOPENDESCW, FAR *LPACMDRVOPENDESCW;

#define ACMDRVOPENDESC      ACMDRVOPENDESCW
#define PACMDRVOPENDESC     PACMDRVOPENDESCW
#define LPACMDRVOPENDESC    LPACMDRVOPENDESCW
#else
typedef struct tACMDRVOPENDESC
{
    DWORD           cbStruct;       // sizeof(ACMDRVOPENDESC)
    FOURCC          fccType;        // 'audc'
    FOURCC          fccComp;        // sub-type (not used--must be 0)
    DWORD           dwVersion;      // current version of ACM opening you
    DWORD           dwFlags;        //
    DWORD           dwError;        // result from DRV_OPEN request
    LPCSTR          pszSectionName; // see DRVCONFIGINFO.lpszDCISectionName
    LPCSTR          pszAliasName;   // see DRVCONFIGINFO.lpszDCIAliasName
    DWORD	    dnDevNode;	    // devnode id for pnp drivers.

} ACMDRVOPENDESC, *PACMDRVOPENDESC, FAR *LPACMDRVOPENDESC;
#endif


//
//
//
//
//
typedef struct tACMDRVSTREAMINSTANCE
{
    DWORD               cbStruct;
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    LPWAVEFILTER        pwfltr;
    DWORD_PTR           dwCallback;
    DWORD_PTR           dwInstance;
    DWORD               fdwOpen;
    DWORD               fdwDriver;
    DWORD_PTR           dwDriver;
    HACMSTREAM          has;

} ACMDRVSTREAMINSTANCE, *PACMDRVSTREAMINSTANCE, FAR *LPACMDRVSTREAMINSTANCE;


//
//  NOTE! this structure must match the ACMSTREAMHEADER in msacm.h but
//  defines more information for the driver writing convenience
//
typedef struct tACMDRVSTREAMHEADER FAR *LPACMDRVSTREAMHEADER;
typedef struct tACMDRVSTREAMHEADER
{
    DWORD                   cbStruct;
    DWORD                   fdwStatus;
    DWORD_PTR               dwUser;
    LPBYTE                  pbSrc;
    DWORD                   cbSrcLength;
    DWORD                   cbSrcLengthUsed;
    DWORD_PTR               dwSrcUser;
    LPBYTE                  pbDst;
    DWORD                   cbDstLength;
    DWORD                   cbDstLengthUsed;
    DWORD_PTR               dwDstUser;

    DWORD                   fdwConvert;     // flags passed from convert func
    LPACMDRVSTREAMHEADER    padshNext;      // for async driver queueing
    DWORD                   fdwDriver;      // driver instance flags
    DWORD_PTR               dwDriver;       // driver instance data

    //
    //  all remaining fields are used by the ACM for bookkeeping purposes.
    //  an ACM driver should never use these fields (though than can be
    //  helpful for debugging)--note that the meaning of these fields
    //  may change, so do NOT rely on them in shipping code.
    //
    DWORD                   fdwPrepared;
    DWORD_PTR               dwPrepared;
    LPBYTE                  pbPreparedSrc;
    DWORD                   cbPreparedSrcLength;
    LPBYTE                  pbPreparedDst;
    DWORD                   cbPreparedDstLength;

} ACMDRVSTREAMHEADER, *PACMDRVSTREAMHEADER;


//
//  structure for ACMDM_STREAM_SIZE message
//
//
typedef struct tACMDRVSTREAMSIZE
{
    DWORD               cbStruct;
    DWORD               fdwSize;
    DWORD               cbSrcLength;
    DWORD               cbDstLength;

} ACMDRVSTREAMSIZE, *PACMDRVSTREAMSIZE, FAR *LPACMDRVSTREAMSIZE;



//
//  structure containing the information for the ACMDM_FORMAT_SUGGEST message
//
//
typedef struct tACMDRVFORMATSUGGEST
{
    DWORD               cbStruct;           // sizeof(ACMDRVFORMATSUGGEST)
    DWORD               fdwSuggest;         // Suggest flags
    LPWAVEFORMATEX      pwfxSrc;            // Source Format
    DWORD               cbwfxSrc;           // Source Size
    LPWAVEFORMATEX      pwfxDst;            // Dest format
    DWORD               cbwfxDst;           // Dest Size

} ACMDRVFORMATSUGGEST, *PACMDRVFORMATSUGGEST, FAR *LPACMDRVFORMATSUGGEST;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Messages
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ACMDM_DRIVER_NOTIFY             (ACMDM_BASE + 1)
#define ACMDM_DRIVER_DETAILS            (ACMDM_BASE + 10)

#define ACMDM_HARDWARE_WAVE_CAPS_INPUT  (ACMDM_BASE + 20)
#define ACMDM_HARDWARE_WAVE_CAPS_OUTPUT (ACMDM_BASE + 21)

#define ACMDM_FORMATTAG_DETAILS         (ACMDM_BASE + 25)
#define ACMDM_FORMAT_DETAILS            (ACMDM_BASE + 26)
#define ACMDM_FORMAT_SUGGEST            (ACMDM_BASE + 27)

#define ACMDM_FILTERTAG_DETAILS         (ACMDM_BASE + 50)
#define ACMDM_FILTER_DETAILS            (ACMDM_BASE + 51)

#define ACMDM_STREAM_OPEN               (ACMDM_BASE + 76)
#define ACMDM_STREAM_CLOSE              (ACMDM_BASE + 77)
#define ACMDM_STREAM_SIZE               (ACMDM_BASE + 78)
#define ACMDM_STREAM_CONVERT            (ACMDM_BASE + 79)
#define ACMDM_STREAM_RESET              (ACMDM_BASE + 80)
#define ACMDM_STREAM_PREPARE            (ACMDM_BASE + 81)
#define ACMDM_STREAM_UNPREPARE          (ACMDM_BASE + 82)
#define ACMDM_STREAM_UPDATE	        (ACMDM_BASE + 83)


#include "poppack.h"    /* Revert to default packing */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_ACMDRV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\napmmc_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.02.0216 */
/* at Thu Nov 12 15:52:14 1998
 */
/* Compiler settings for napmmc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IIASAttributeInfo = {0x60F41BE3,0x06DF,0x11D2,{0x95,0xAA,0x00,0x60,0xB0,0x57,0x66,0x42}};


const IID IID_IIASEnumerableAttributeInfo = {0x9A407537,0x0A20,0x11D2,{0x95,0xB0,0x00,0x60,0xB0,0x57,0x66,0x42}};


const IID IID_IIASAttributeEditor = {0xCB2418D2,0x0709,0x11D2,{0x95,0xAB,0x00,0x60,0xB0,0x57,0x66,0x42}};


const IID IID_IIASNASVendors = {0xC54EC3BA,0x7442,0x11d2,{0xA0,0x36,0x00,0x60,0xB0,0x57,0x66,0x42}};


const IID LIBID_NAPMMCLib = {0x5880CD5B,0x8EC0,0x11d1,{0x95,0x70,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_NAPSnapin = {0x5880CD5C,0x8EC0,0x11d1,{0x95,0x70,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_NAPSnapinAbout = {0x5880CD5D,0x8EC0,0x11d1,{0x95,0x70,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_LoggingSnapin = {0x2E19B602,0x48EB,0x11d2,{0x83,0xCA,0x00,0x10,0x4B,0xCA,0x42,0xCF}};


const CLSID CLSID_LoggingSnapinAbout = {0x2E19B603,0x48EB,0x11d2,{0x83,0xCA,0x00,0x10,0x4B,0xCA,0x42,0xCF}};


const CLSID CLSID_IASAttributeInfo = {0x60F41BE4,0x06DF,0x11D2,{0x95,0xAA,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_IASEnumerableAttributeInfo = {0x9A407538,0x0A20,0x11D2,{0x95,0xB0,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_IASIPAttributeEditor = {0xCB2418D3,0x0709,0x11D2,{0x95,0xAB,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_IASMultivaluedAttributeEditor = {0xB3B443EF,0x0728,0x11D2,{0x95,0xAC,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_IASVendorSpecificAttributeEditor = {0xD601D57D,0x085B,0x11D2,{0x95,0xAF,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_IASEnumerableAttributeEditor = {0x5F7B221A,0x086B,0x11D2,{0x95,0xAF,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_IASStringAttributeEditor = {0x1ABAAF84,0x086F,0x11D2,{0x95,0xAF,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_IASGroupsAttributeEditor = {0xA9E6F356,0x317C,0x11d2,{0x80,0x5D,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_IASNASVendors = {0xC54EC3BB,0x7442,0x11d2,{0xA0,0x36,0x00,0x60,0xB0,0x57,0x66,0x42}};


#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.02.0216 */
/* at Thu Nov 12 15:52:17 1998
 */
/* Compiler settings for napmmc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IIASAttributeInfo = {0x60F41BE3,0x06DF,0x11D2,{0x95,0xAA,0x00,0x60,0xB0,0x57,0x66,0x42}};


const IID IID_IIASEnumerableAttributeInfo = {0x9A407537,0x0A20,0x11D2,{0x95,0xB0,0x00,0x60,0xB0,0x57,0x66,0x42}};


const IID IID_IIASAttributeEditor = {0xCB2418D2,0x0709,0x11D2,{0x95,0xAB,0x00,0x60,0xB0,0x57,0x66,0x42}};


const IID IID_IIASNASVendors = {0xC54EC3BA,0x7442,0x11d2,{0xA0,0x36,0x00,0x60,0xB0,0x57,0x66,0x42}};


const IID LIBID_NAPMMCLib = {0x5880CD5B,0x8EC0,0x11d1,{0x95,0x70,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_NAPSnapin = {0x5880CD5C,0x8EC0,0x11d1,{0x95,0x70,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_NAPSnapinAbout = {0x5880CD5D,0x8EC0,0x11d1,{0x95,0x70,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_LoggingSnapin = {0x2E19B602,0x48EB,0x11d2,{0x83,0xCA,0x00,0x10,0x4B,0xCA,0x42,0xCF}};


const CLSID CLSID_LoggingSnapinAbout = {0x2E19B603,0x48EB,0x11d2,{0x83,0xCA,0x00,0x10,0x4B,0xCA,0x42,0xCF}};


const CLSID CLSID_IASAttributeInfo = {0x60F41BE4,0x06DF,0x11D2,{0x95,0xAA,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_IASEnumerableAttributeInfo = {0x9A407538,0x0A20,0x11D2,{0x95,0xB0,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_IASIPAttributeEditor = {0xCB2418D3,0x0709,0x11D2,{0x95,0xAB,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_IASMultivaluedAttributeEditor = {0xB3B443EF,0x0728,0x11D2,{0x95,0xAC,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_IASVendorSpecificAttributeEditor = {0xD601D57D,0x085B,0x11D2,{0x95,0xAF,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_IASEnumerableAttributeEditor = {0x5F7B221A,0x086B,0x11D2,{0x95,0xAF,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_IASStringAttributeEditor = {0x1ABAAF84,0x086F,0x11D2,{0x95,0xAF,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_IASGroupsAttributeEditor = {0xA9E6F356,0x317C,0x11d2,{0x80,0x5D,0x00,0x60,0xB0,0x57,0x66,0x42}};


const CLSID CLSID_IASNASVendors = {0xC54EC3BB,0x7442,0x11d2,{0xA0,0x36,0x00,0x60,0xB0,0x57,0x66,0x42}};


#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\msdatt.h ===
//--------------------------------------------------------------------
// Microsoft OLE DB Rowset Service Provider
// (C) Copyright 1994-1999 By Microsoft Corporation.
//
// @doc
//
// @module MSDATT.H | Service Provider Specific definitions
//
//--------------------------------------------------------------------

#ifndef  _MSDATT_H_
#define  _MSDATT_H_

#if _MSC_VER > 1000
#pragma once
#endif

// Provider Class Id
#ifdef DBINITCONSTANTS
extern const GUID CLSID_MSDATT               = {0xc8b522ceL,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
#else // !DBINITCONSTANTS
extern const GUID CLSID_MSDATT;
#endif // DBINITCONSTANTS

#endif //_MSDATT_H_
//----
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\nddesec.h ===
//
//  NDDESEC.H
//  Copyright (c) 1994-1999, Microsoft Corp. All rights reserved.
//

#ifndef          _INC_NDDESEC
#define          _INC_NDDESEC

#if _MSC_VER > 1000
#pragma once
#endif

#define NDDE_SHAREDB_ADD	   (0x00000001)
#define NDDE_SHAREDB_DELETE	   (0x00000002)
#define NDDE_SHAREDB_LIST	   (0x00000004)

#define NDDE_SHAREDB_ADMIN	(NDDE_SHAREDB_ADD |			\
			         NDDE_SHAREDB_DELETE |			\
				 NDDE_SHAREDB_LIST |			\
				 READ_CONTROL |				\
				 WRITE_DAC |				\
				 WRITE_OWNER)

#define NDDE_SHAREDB_OPER	(NDDE_SHAREDB_ADD |			\
			         NDDE_SHAREDB_DELETE |			\
				 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_POWER	(NDDE_SHAREDB_ADD |			\
			         NDDE_SHAREDB_DELETE |			\
				 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_USER	(NDDE_SHAREDB_ADD |			\
			         NDDE_SHAREDB_DELETE |			\
				 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_EVERYONE	(NDDE_SHAREDB_LIST)

#define NDDE_SHARE_READ		   (0x00000001)
#define NDDE_SHARE_WRITE	   (0x00000002)
#define NDDE_SHARE_INITIATE_STATIC (0x00000004)
#define NDDE_SHARE_INITIATE_LINK   (0x00000008)
#define NDDE_SHARE_REQUEST	   (0x00000010)
#define NDDE_SHARE_ADVISE	   (0x00000020)
#define NDDE_SHARE_POKE		   (0x00000040)
#define NDDE_SHARE_EXECUTE	   (0x00000080)
#define NDDE_SHARE_ADD_ITEMS	   (0x00000100)
#define NDDE_SHARE_LIST_ITEMS	   (0x00000200)

#define NDDE_SHARE_GENERIC_READ	(NDDE_SHARE_READ |			\
			         NDDE_SHARE_INITIATE_STATIC |		\
				 NDDE_SHARE_REQUEST |			\
				 NDDE_SHARE_ADVISE |			\
				 NDDE_SHARE_LIST_ITEMS)

#define NDDE_SHARE_GENERIC_WRITE (NDDE_SHARE_INITIATE_STATIC |		\
			          NDDE_SHARE_INITIATE_LINK |		\
				  NDDE_SHARE_POKE |			\
				  DELETE)

#define NDDE_SHARE_GENERIC_EXECUTE (NDDE_SHARE_INITIATE_STATIC |	\
			            NDDE_SHARE_INITIATE_LINK |		\
				    NDDE_SHARE_EXECUTE)

#define NDDE_SHARE_GENERIC_ALL (NDDE_SHARE_READ |			\
				NDDE_SHARE_WRITE |			\
			        NDDE_SHARE_INITIATE_STATIC |		\
			        NDDE_SHARE_INITIATE_LINK |		\
				NDDE_SHARE_REQUEST |			\
				NDDE_SHARE_ADVISE |			\
				NDDE_SHARE_POKE |			\
				NDDE_SHARE_EXECUTE |			\
				NDDE_SHARE_ADD_ITEMS |			\
				NDDE_SHARE_LIST_ITEMS |			\
				DELETE |				\
				READ_CONTROL |				\
				WRITE_DAC |				\
				WRITE_OWNER)


#define NDDE_ITEM_REQUEST	   (0x00000001)
#define NDDE_ITEM_ADVISE	   (0x00000002)
#define NDDE_ITEM_POKE		   (0x00000004)

#define NDDE_ITEM_GENERIC_READ	  (NDDE_ITEM_REQUEST | NDDE_ITEM_ADVISE)
#define NDDE_ITEM_GENERIC_WRITE   (NDDE_ITEM_POKE)
#define NDDE_ITEM_GENERIC_EXECUTE (0)
#define NDDE_ITEM_GENERIC_ALL     (NDDE_ITEM_REQUEST |			\
				   NDDE_ITEM_ADVISE |			\
				   NDDE_ITEM_POKE |			\
				   DELETE |				\
				   READ_CONTROL |			\
				   WRITE_DAC |				\
				   WRITE_OWNER)

#define NDDE_GUI_NONE	  	(0)

#define NDDE_GUI_READ		(NDDE_SHARE_GENERIC_READ)

#define NDDE_GUI_READ_LINK	(NDDE_SHARE_GENERIC_READ |		\
				 NDDE_SHARE_INITIATE_LINK)

#define NDDE_GUI_CHANGE		(NDDE_SHARE_GENERIC_READ |		\
				 NDDE_SHARE_GENERIC_WRITE |		\
				 NDDE_SHARE_GENERIC_EXECUTE)

#define NDDE_GUI_FULL_CONTROL	(NDDE_SHARE_GENERIC_ALL)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\negossp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       negossp.h
//
//  Contents:   Negotiate Package
//
//  Classes:
//
//  Functions:
//
//  History:    7-26-96   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __NEGOSSP_H__
#define __NEGOSSP_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef NEGOSSP_NAME
#define NEGOSSP_NAME_W  L"Negotiate"
#define NEGOSSP_NAME_A  "Negotiate"

#ifdef UNICODE
#define NEGOSSP_NAME    NEGOSSP_NAME_W
#else
#define NEGOSSP_NAME    NEGOSSP_NAME_A
#endif

#endif // NEGOSSP_NAME

#define NEGOSSP_RPCID   9



#ifndef SEC_WINNT_AUTH_IDENTITY_VERSION
#define SEC_WINNT_AUTH_IDENTITY_VERSION 0x200

#pragma message("WARNING: include security.h to get definition of SEC_WINNT_AUTH_IDENTITY_EX")
typedef struct _SEC_WINNT_AUTH_IDENTITY_EXW {
    unsigned long Version;
    unsigned long Length;
    unsigned short SEC_FAR *User;
    unsigned long UserLength;
    unsigned short SEC_FAR *Domain;
    unsigned long DomainLength;
    unsigned short SEC_FAR *Password;
    unsigned long PasswordLength;
    unsigned long Flags;
    unsigned short SEC_FAR * PackageList;
    unsigned long PackageListLength;
} SEC_WINNT_AUTH_IDENTITY_EXW, *PSEC_WINNT_AUTH_IDENTITY_EXW;


typedef struct _SEC_WINNT_AUTH_IDENTITY_EXA {
    unsigned long Version;
    unsigned long Length;
    unsigned char SEC_FAR *User;
    unsigned long UserLength;
    unsigned char SEC_FAR *Domain;
    unsigned long DomainLength;
    unsigned char SEC_FAR *Password;
    unsigned long PasswordLength;
    unsigned long Flags;
    unsigned char SEC_FAR * PackageList;
    unsigned long PackageListLength;
} SEC_WINNT_AUTH_IDENTITY_EXA, *PSEC_WINNT_AUTH_IDENTITY_EXA;
#endif // SEC_WINNT_AUTH_IDENTITY_VERSION


#endif // __NEGOSSP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\newat.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    newat.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the new (cairo) schedule service API-s.

Author:

    jim harriger (jimharr)       04 - february - 1994

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include NETCONS.H and LMAT.h before this file, since this
	file depends on values defined in NETCONS.H.

Revision History:

    Jim Harriger          (jimharr)         13 may 93
    -- added NetSchedule(foo)Ex Routines, for Cairo
    Jim Harriger          (jimharr)         12 jul 94
    -- modified API structures for new multi-trigger functionality.
--*/

#ifndef _NEWAT_
#define _NEWAT_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


// structures for new ..Ex API's

typedef struct _AT_TRIGGER_POINT {
    LARGE_INTEGER   MinuteMask;
    DWORD   HourMask;
    DWORD   DaysOfMonth;
    USHORT  DaysOfWeek;
} AT_TRIGGER_POINT, *PAT_TRIGGER_POINT, *LPAT_TRIGGER_POINT;

typedef struct _AT_INFO_EX {
    GUID    UserProxy;
    LPWSTR  Command;
    USHORT  Flags;
    USHORT cTriggerPoints;
    AT_TRIGGER_POINT *atpTriggerPoints;
} AT_INFO_EX, *PAT_INFO_EX, *LPAT_INFO_EX;

typedef struct _AT_ENUM_EX {
    GUID    UserProxy;
    LPWSTR  Command;
    DWORD   JobId;
    USHORT  Flags;
    USHORT cTriggerPoints;
    AT_TRIGGER_POINT *atpTriggerPoints;
} AT_ENUM_EX, *PAT_ENUM_EX, *LPAT_ENUM_EX;

//
// new API functions
//

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobAddEx(
    IN      LPWSTR          Servername  OPTIONAL,
    IN      LPBYTE          Buffer,
    OUT     LPDWORD         JobId
    );

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobEnumEx(
    IN      LPWSTR          Servername              OPTIONAL,
    OUT     LPBYTE *        PointerToBuffer,
    IN      DWORD           PrefferedMaximumLength,
    OUT     LPDWORD         EntriesRead,
    OUT     LPDWORD         TotalEntries,
    IN OUT  LPDWORD         ResumeHandle
    );

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobGetInfoEx(
    IN      LPWSTR          Servername              OPTIONAL,
    IN      DWORD           JobId,
    OUT     LPBYTE *        PointerToBuffer
    );

#ifdef __cplusplus
}
#endif

#endif // _NEWAT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\newdev.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    newdev.h

Abstract:

    Public header file for Windows NT Driver Installation DLL.

--*/

#ifndef _INC_NEWDEV
#define _INC_NEWDEV

#include <pshpack1.h>   // Assume byte packing throughout

#ifdef __cplusplus
extern "C" {
#endif


#define INSTALLFLAG_FORCE           0x00000001      // Force the installation of the specified driver
#define INSTALLFLAG_READONLY        0x00000002      // Do a read-only install (no file copy)
#define INSTALLFLAG_NONINTERACTIVE  0x00000004      // No UI shown at all. API will fail if any UI must be shown.
#define INSTALLFLAG_BITS            0x00000007


BOOL
WINAPI
UpdateDriverForPlugAndPlayDevicesA(
    HWND hwndParent,
    LPCSTR HardwareId,
    LPCSTR FullInfPath,
    DWORD InstallFlags,
    PBOOL bRebootRequired OPTIONAL
    );

BOOL
WINAPI
UpdateDriverForPlugAndPlayDevicesW(
    HWND hwndParent,
    LPCWSTR HardwareId,
    LPCWSTR FullInfPath,
    DWORD InstallFlags,
    PBOOL bRebootRequired OPTIONAL
    );

#ifdef UNICODE
#define UpdateDriverForPlugAndPlayDevices UpdateDriverForPlugAndPlayDevicesW
#else
#define UpdateDriverForPlugAndPlayDevices UpdateDriverForPlugAndPlayDevicesA
#endif



#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif // _INC_NEWDEV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\nminsert.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    NMInsert.h

Abstract:

    This header file defines constants types and functions for inserting
    frames into a running Netmon capture.

Author:

    a-flexd     07-09-96        Created.

Revision History:


Mini-DOC:

Netmon allows a programming interface to insert frames into a running capture.
There are two different ways to do this.  You can either used the defined
interfaces in the NMExt API suite to start the capture, define the filter etc,
or you can use the "raw" interface.  Using this interface will insert a frame
into EVERY running capture.  For example, if you your two different Netmons
running, one on ethernet and one on FDDI, you will get the inserted frame
into both captures.
Calling TransmitSpecialFrame if Netmon is not running is just fine.  Nothing
will happen, the data will just be dropped.

The entry point defined below (TransmitSpecialFrame) is contained in NAL.DLL.
NT4.0 is the first version of NT that contains the entry point, specifically
build 346.

NOTE NOTE NOTE:  You should NOT link to the NAL.LIB to acquire this
functionality.  NAL.DLL is not gaurenteed to be installed on a standard NT
machine.  Instead use Loadlibrary to acquire the entry point.

When a frame is inserted, a fake media header and parent protocol is created
for your data.  We create a "TRAIL" protocol header that hands off to your
data.  The parsing of your data depends on the FRAME_TYPE_ that you specify.
If you specify a known frame type, we will parse it for you.  For example, the
FRAME_TYPE_MESSAGE uses a data structure that looks something like this:

    typedef struct _MessageFRAME
    {
        DWORD  dwValue1;
        DWORD  dwValue2;
        CHAR   szMessage[];
    } MessageFRAME;

Just fill out one of these and point to it when you call TransmitSpecialFrame
with the FRAME_TYPE_MESSAGE.
FRAME_TYPE_COMMENT is just an array of printable chars.  If you want to make
your own data structure, pick a number above 1000 and use that number as the
FrameType parameter.  Note that you must add your number and parser name to
the TRAIL.INI file in the Netmon parsers directory.

Example:

setup:
    TRANSMITSPECIALFRAME_FN lpfnTransmitSpecialFrame = NULL;

    hInst = LoadLibrary ("NAL.DLL" );
    if (hInst)
        lpfnTransmitSpecialFrame = (TRANSMITSPECIALFRAME_FN)GetProcAddress ( hInst, "TransmitSpecialFrame" );

    if (( hInst==NULL ) || ( lpfnTransmitSpecialFrame==NULL) )
    {
        ...
    }

usage:
    lpfnTransmitSpecialFrame( FRAME_TYPE_COMMENT, 0, (unsigned char *)pStr, strlen(pStr)+1 );


Contacts:

    Flex Dolphynn    (a-FlexD)
    Steve Hiskey     (SteveHi)
    Arthur Brooking  (ArthurB)

--*/

#ifndef _INSERTFRAME_
#define _INSERTFRAME_

#if _MSC_VER > 1000
#pragma once
#endif

//  VALUES BELOW 100 ARE FOR FUTURE NETMON USE
//  VALUES 100 - 1000 ARE FOR INTERNAL MICROSOFT USE
//  VALUES ABOVE 1000 ARE FOR USER-DEFINED TYPES

#define FRAME_TYPE_GENERIC           101
#define FRAME_TYPE_BOOKMARK          102
#define FRAME_TYPE_STATISTICS        103
#define FRAME_TYPE_ODBC              104
#define FRAME_TYPE_MESSAGE           105
#define FRAME_TYPE_COMMENT           106

//  FLAGS FOR INSERTSPECIALFRAME
//  THIS FLAG WILL CAUSE THE FRAME IT IS APPLIED TO TO BE SKIPPED AS AN ENDPOINT
//  FOR THE GENERATED STATISTICS
#define SPECIALFLAG_SKIPSTAT         0x0001
//  THIS FLAG WILL CAUSE THE GENERATED STATISTICS TO ONLY TAKE
//  INTO CONSIDERATION THSE FRAMES WHICH PASS THE CURRENT FILTER
#define SPECIALFLAG_FILTERSTAT    0x0002

#ifdef __cplusplus
extern "C" {
#endif

VOID WINAPI TransmitSpecialFrame( DWORD FrameType, DWORD Flags, LPBYTE pUserData, DWORD UserDataLength);

//  FUNCTION POINTER DEFINITION FOR GETPROCADDRESS
typedef VOID (_stdcall * TRANSMITSPECIALFRAME_FN)(DWORD, DWORD, LPBYTE, DWORD);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\nmsupp.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1991-1999. All rights reserved.
//
//  MODULE: bhsupp.h
//=============================================================================

#if !defined(_NMSUPP_H)

#define _NMSUPP_H

#pragma pack(1)

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __cplusplus
#ifndef try
#define try                         __try
#endif

#ifndef except
#define except                      __except
#endif
#endif

//=============================================================================
//  Windows version constants.
//=============================================================================

#define WINDOWS_VERSION_UNKNOWN     0
#define WINDOWS_VERSION_WIN32S      1
#define WINDOWS_VERSION_WIN32C      2
#define WINDOWS_VERSION_WIN32       3

//=============================================================================
//  Frame masks.
//=============================================================================

#define FRAME_MASK_ETHERNET         ((BYTE) ~0x01)
#define FRAME_MASK_TOKENRING        ((BYTE) ~0x80)
#define FRAME_MASK_FDDI             ((BYTE) ~0x01)

//=============================================================================
//  ACCESSRIGHTS
//=============================================================================

typedef enum _ACCESSRIGHTS
{
    AccessRightsNoAccess,               //... Access denied, invalid password.
    AccessRightsMonitoring,             //... Monitoring mode only.
    AccessRightsUserAccess,             //... User-level access rights.
    AccessRightsAllAccess               //... All access.
} ACCESSRIGHTS;

typedef ACCESSRIGHTS *PACCESSRIGHTS;

typedef LPVOID HPASSWORD;

#define HANDLE_TYPE_PASSWORD            MAKE_IDENTIFIER('P', 'W', 'D', '$')

//=============================================================================
//  Object heap type.
//=============================================================================

typedef LPVOID HOBJECTHEAP;                 //... Opaque.

//=============================================================================
//  Object cleanup procedure.
//=============================================================================

typedef VOID (WINAPI *OBJECTPROC)(HOBJECTHEAP, LPVOID);

#pragma pack()

//=============================================================================
//  Network Monitor timers.
//=============================================================================

typedef struct _TIMER *HTIMER;

typedef VOID (WINAPI *BHTIMERPROC)(LPVOID);

extern  HTIMER WINAPI BhSetTimer(BHTIMERPROC TimerProc, LPVOID InstData, DWORD TimeOut);

extern  VOID   WINAPI BhKillTimer(HTIMER hTimer);

//=============================================================================
//  Network Monitor driver support.
//=============================================================================

extern LPVOID WINAPI BhAllocSystemMemory(DWORD nBytes);

extern LPVOID WINAPI BhFreeSystemMemory(LPVOID ptr);

extern LPVOID WINAPI BhGetNetworkRequestAddress(DWORD NalRequestType);

//=============================================================================
//  Network Monitor global error API.
//=============================================================================

extern DWORD  WINAPI BhGetLastError(VOID);

extern DWORD  WINAPI BhSetLastError(DWORD Error);

//=============================================================================
//  Object manager function prototypes.
//=============================================================================

extern HOBJECTHEAP WINAPI CreateObjectHeap(DWORD ObjectSize, OBJECTPROC ObjectProc);

extern HOBJECTHEAP WINAPI DestroyObjectHeap(HOBJECTHEAP hObjectHeap);

extern LPVOID      WINAPI AllocObject(HOBJECTHEAP hObjectHeap);

extern LPVOID      WINAPI FreeObject(HOBJECTHEAP hObjectHeap, LPVOID ObjectMemory);

extern DWORD       WINAPI GrowObjectHeap(HOBJECTHEAP hObjectHeap, DWORD nObjects);

extern DWORD       WINAPI GetObjectHeapSize(HOBJECTHEAP hObjectHeap);

extern VOID        WINAPI PurgeObjectHeap(HOBJECTHEAP hObjectHeap);

//=============================================================================
//  Memory functions.
//=============================================================================

extern LPVOID     WINAPI AllocMemory(SIZE_T size);

extern LPVOID     WINAPI ReallocMemory(LPVOID ptr, SIZE_T NewSize);

extern VOID       WINAPI FreeMemory(LPVOID ptr);

extern VOID       WINAPI TestMemory(LPVOID ptr);

extern SIZE_T     WINAPI MemorySize(LPVOID ptr);

extern HANDLE     WINAPI MemoryHandle(LPBYTE ptr);

//=============================================================================
//  Password API's.
//=============================================================================

extern HPASSWORD    WINAPI CreatePassword(LPSTR password);

extern VOID         WINAPI DestroyPassword(HPASSWORD hPassword);

extern ACCESSRIGHTS WINAPI ValidatePassword(HPASSWORD hPassword);

//=============================================================================
//  EXPRESSION API's
//=============================================================================

extern LPEXPRESSION         WINAPI InitializeExpression(LPEXPRESSION Expression);

extern LPPATTERNMATCH       WINAPI InitializePattern(LPPATTERNMATCH Pattern, LPVOID ptr, DWORD offset, DWORD length);

extern LPEXPRESSION         WINAPI AndExpression(LPEXPRESSION Expression, LPPATTERNMATCH Pattern);

extern LPEXPRESSION         WINAPI OrExpression(LPEXPRESSION Expression, LPPATTERNMATCH Pattern);

extern LPPATTERNMATCH       WINAPI NegatePattern(LPPATTERNMATCH Pattern);

extern LPADDRESSTABLE       WINAPI AdjustOperatorPrecedence(LPADDRESSTABLE AddressTable);

extern LPADDRESS            WINAPI NormalizeAddress(LPADDRESS Address);

extern LPADDRESSTABLE       WINAPI NormalizeAddressTable(LPADDRESSTABLE AddressTable);

//=============================================================================
//  SERVICE API's
//=============================================================================

extern HANDLE               WINAPI BhOpenService(LPSTR ServiceName);

extern VOID                 WINAPI BhCloseService(HANDLE ServiceHandle);

extern DWORD                WINAPI BhStartService(HANDLE ServiceHandle);

extern DWORD                WINAPI BhStopService(HANDLE ServiceHandle);

//=============================================================================
//  MISC. API's
//=============================================================================

extern DWORD                WINAPI BhGetWindowsVersion(VOID);

extern BOOL                 WINAPI IsDaytona(VOID);

extern VOID                 _cdecl dprintf(LPSTR format, ...);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\msimdb.h ===
//--------------------------------------------------------------------
//
// Microsoft In-Memory Database
// (C) Copyright 1998 By Microsoft Corporation.
//
//
//--------------------------------------------------------------------

#ifndef  _MSIMDB_H_
	#define  _MSIMDB_H_

	//
	// MSIMDB property specific definitions
	//
	// The GUID for the MSIMDB specific property set on the session
	//
	// {AFE68CE9-C367-11d1-AC4F-0000F8758E41}
	_declspec(selectany) extern const GUID DBPROPSET_IMDBSESSION =
			{ 0xafe68ce9, 0xc367, 0x11d1, { 0xac, 0x4f, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x41 } };


	//----------------------------------------------------------------------------
	// Props for DBPROPSET_IMDBSESSION
	//
	#define IMDBPROP_SESS_ISOLEVEL				0x01	// I4
														//		DBPROPVAL_TI_READCOMMITTED (Default),
														//		DBPROPVAL_TI_REPEATABLEREAD,
														//		DBPROPVAL_TI_SERIALIZABLE

	#define IMDBPROP_SESS_OPENROWSET_TIMEOUT	0x02	// I2 0 (30s wait, Default)
	#define IMDBPROP_SESS_SMALL_TABLES			0x03	// BOOL VARIANT_FALSE (Default)
	#define IMDBPROP_SESS_PESSIMISTIC_LOCKING	0x04	// BOOL VARIANT_FALSE (Default)
	#define IMDBPROP_SESS_WRITE_THROUGH			0x05	// BOOL VARIANT_FALSE (Default)
	#define IMDBPROP_SESS_CREATE_COHERENT		0x06	// BOOL VARIANT_TRUE (Default)
	#define IMDBPROP_SESS_DROP_COHERENT			0x07	// BOOL VARIANT_TRUE (Default)
	#define IMDBPROP_SESS_ROWSET_LIFETIME		0x08	// I4 300 (300s wait, Default)


	#define IMDBPROP_SESS_OPENROWSET_TIMEOUT_DEFAULT_VALUE  30
	#define IMDBPROP_SESS_OPENROWSET_TIMEOUT_MIN_VALUE      0
	#define IMDBPROP_SESS_OPENROWSET_TIMEOUT_MAX_VALUE      0xffff


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Mon Dec 14 12:35:36 1998
 */
/* Compiler settings for tspm.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data
    VC __declspec() decoration level:
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tspm_h__
#define __tspm_h__

/* Forward Declarations */

#ifndef __ITxProperty_FWD_DEFINED__
#define __ITxProperty_FWD_DEFINED__
typedef interface ITxProperty ITxProperty;
#endif 	/* __ITxProperty_FWD_DEFINED__ */


#ifndef __ITxPropertyGroup_FWD_DEFINED__
#define __ITxPropertyGroup_FWD_DEFINED__
typedef interface ITxPropertyGroup ITxPropertyGroup;
#endif 	/* __ITxPropertyGroup_FWD_DEFINED__ */


#ifndef __ITxPropertyGroupManager_FWD_DEFINED__
#define __ITxPropertyGroupManager_FWD_DEFINED__
typedef interface ITxPropertyGroupManager ITxPropertyGroupManager;
#endif 	/* __ITxPropertyGroupManager_FWD_DEFINED__ */


#ifndef __TransactedPropertyGroupManager_FWD_DEFINED__
#define __TransactedPropertyGroupManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class TransactedPropertyGroupManager TransactedPropertyGroupManager;
#else
typedef struct TransactedPropertyGroupManager TransactedPropertyGroupManager;
#endif /* __cplusplus */

#endif 	/* __TransactedPropertyGroupManager_FWD_DEFINED__ */


#ifndef __TransactedPropertyGroup_FWD_DEFINED__
#define __TransactedPropertyGroup_FWD_DEFINED__

#ifdef __cplusplus
typedef class TransactedPropertyGroup TransactedPropertyGroup;
#else
typedef struct TransactedPropertyGroup TransactedPropertyGroup;
#endif /* __cplusplus */

#endif 	/* __TransactedPropertyGroup_FWD_DEFINED__ */


#ifndef __TransactedProperty_FWD_DEFINED__
#define __TransactedProperty_FWD_DEFINED__

#ifdef __cplusplus
typedef class TransactedProperty TransactedProperty;
#else
typedef struct TransactedProperty TransactedProperty;
#endif /* __cplusplus */

#endif 	/* __TransactedProperty_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/* interface __MIDL_itf_tspm_0000 */
/* [local] */

//=--------------------------------------------------------------------------=
// @doc
//
// @module	TSPM.H | TSPM interfaces:
//                      ITxProperty
//                      ITxPropertyGroup
//                      ITxPropertyGroupManager
//
// Copyright (c) 1998, Microsoft Corporation, All Rights Reserved
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// Interface Definitions
//=--------------------------------------------------------------------------=

typedef /* [public] */
enum __MIDL___MIDL_itf_tspm_0000_0001
    {	DISPID_CREATEGROUP	= 1,
	DISPID_REMOVEGROUP	= DISPID_CREATEGROUP + 1,
	DISPID_CREATEPROPERTY	= DISPID_REMOVEGROUP + 1,
	DISPID_GETPROPERTY	= DISPID_CREATEPROPERTY + 1,
	DISPID_REMOVEPROPERTY	= DISPID_GETPROPERTY + 1,
	DISPID_GETGROUP	= DISPID_REMOVEPROPERTY + 1
    }	TSPM_METHODS;

typedef /* [public] */
enum __MIDL___MIDL_itf_tspm_0000_0002
    {	DISPID_NAME	= 140,
	DISPID_PROPERTYGROUP	= DISPID_NAME + 1,
	DISPID_ISOLATIONLEVEL	= DISPID_PROPERTYGROUP + 1,
	DISPID_CONCURRENCYMODE	= DISPID_ISOLATIONLEVEL + 1,
	DISPID_PROPERTYGROUPMANAGER	= DISPID_CONCURRENCYMODE + 1,
	DISPID_COUNT	= DISPID_PROPERTYGROUPMANAGER + 1,
	DISPID_CACHECOHERENTLY	= DISPID_COUNT + 1,
	DISPID_WRITETHROUGH	= DISPID_CACHECOHERENTLY + 1
    }	TSPM_PROPERTIES;


extern RPC_IF_HANDLE __MIDL_itf_tspm_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tspm_0000_v0_0_s_ifspec;

#ifndef __ITxProperty_INTERFACE_DEFINED__
#define __ITxProperty_INTERFACE_DEFINED__

/* interface ITxProperty */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_ITxProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("6A8DEEA8-4101-11D2-912C-0000F8758E8D")
    ITxProperty : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name(
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPropertyName) = 0;

        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PropertyGroup(
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppPropertyGroup) = 0;

        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Value(
            /* [retval][out] */ VARIANT __RPC_FAR *pvarPropertyValue) = 0;

        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Value(
            /* [in] */ VARIANT varPropertyValue) = 0;

    };

#else 	/* C style interface */

    typedef struct ITxPropertyVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITxProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITxProperty __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITxProperty __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            ITxProperty __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            ITxProperty __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            ITxProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            ITxProperty __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )(
            ITxProperty __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPropertyName);

        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PropertyGroup )(
            ITxProperty __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppPropertyGroup);

        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )(
            ITxProperty __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarPropertyValue);

        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )(
            ITxProperty __RPC_FAR * This,
            /* [in] */ VARIANT varPropertyValue);

        END_INTERFACE
    } ITxPropertyVtbl;

    interface ITxProperty
    {
        CONST_VTBL struct ITxPropertyVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITxProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITxProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITxProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)

#define ITxProperty_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITxProperty_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITxProperty_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITxProperty_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITxProperty_get_Name(This,pbstrPropertyName)	\
    (This)->lpVtbl -> get_Name(This,pbstrPropertyName)

#define ITxProperty_get_PropertyGroup(This,ppPropertyGroup)	\
    (This)->lpVtbl -> get_PropertyGroup(This,ppPropertyGroup)

#define ITxProperty_get_Value(This,pvarPropertyValue)	\
    (This)->lpVtbl -> get_Value(This,pvarPropertyValue)

#define ITxProperty_put_Value(This,varPropertyValue)	\
    (This)->lpVtbl -> put_Value(This,varPropertyValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITxProperty_get_Name_Proxy(
    ITxProperty __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPropertyName);


void __RPC_STUB ITxProperty_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITxProperty_get_PropertyGroup_Proxy(
    ITxProperty __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppPropertyGroup);


void __RPC_STUB ITxProperty_get_PropertyGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITxProperty_get_Value_Proxy(
    ITxProperty __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarPropertyValue);


void __RPC_STUB ITxProperty_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITxProperty_put_Value_Proxy(
    ITxProperty __RPC_FAR * This,
    /* [in] */ VARIANT varPropertyValue);


void __RPC_STUB ITxProperty_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITxProperty_INTERFACE_DEFINED__ */


#ifndef __ITxPropertyGroup_INTERFACE_DEFINED__
#define __ITxPropertyGroup_INTERFACE_DEFINED__

/* interface ITxPropertyGroup */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_ITxPropertyGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("46DB591E-4101-11D2-912C-0000F8758E8D")
    ITxPropertyGroup : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateProperty(
            /* [string][in] */ const BSTR bstrPropertyName,
            /* [in] */ VARIANT_BOOL __RPC_FAR *pvarboolExists,
            /* [retval][out] */ ITxProperty __RPC_FAR *__RPC_FAR *ppTxProperty) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProperty(
            /* [string][in] */ const BSTR bstrPropertyName,
            /* [retval][out] */ ITxProperty __RPC_FAR *__RPC_FAR *ppTxProperty) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveProperty(
            /* [string][in] */ const BSTR bstrPropertyName) = 0;

        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE _NewEnum(
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppIEnumObjects) = 0;

        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name(
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPropertyGroupName) = 0;

        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_WriteThrough(
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarboolWriteThrough) = 0;

        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CacheCoherently(
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarboolCacheCoherently) = 0;

        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PropertyGroupManager(
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppPropertyGroupManager) = 0;

        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count(
            /* [retval][out] */ long __RPC_FAR *plCountProperties) = 0;

    };

#else 	/* C style interface */

    typedef struct ITxPropertyGroupVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITxPropertyGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITxPropertyGroup __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITxPropertyGroup __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            ITxPropertyGroup __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            ITxPropertyGroup __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            ITxPropertyGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            ITxPropertyGroup __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateProperty )(
            ITxPropertyGroup __RPC_FAR * This,
            /* [string][in] */ const BSTR bstrPropertyName,
            /* [in] */ VARIANT_BOOL __RPC_FAR *pvarboolExists,
            /* [retval][out] */ ITxProperty __RPC_FAR *__RPC_FAR *ppTxProperty);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )(
            ITxPropertyGroup __RPC_FAR * This,
            /* [string][in] */ const BSTR bstrPropertyName,
            /* [retval][out] */ ITxProperty __RPC_FAR *__RPC_FAR *ppTxProperty);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveProperty )(
            ITxPropertyGroup __RPC_FAR * This,
            /* [string][in] */ const BSTR bstrPropertyName);

        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )(
            ITxPropertyGroup __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppIEnumObjects);

        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )(
            ITxPropertyGroup __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPropertyGroupName);

        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WriteThrough )(
            ITxPropertyGroup __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarboolWriteThrough);

        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CacheCoherently )(
            ITxPropertyGroup __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarboolCacheCoherently);

        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PropertyGroupManager )(
            ITxPropertyGroup __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppPropertyGroupManager);

        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )(
            ITxPropertyGroup __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCountProperties);

        END_INTERFACE
    } ITxPropertyGroupVtbl;

    interface ITxPropertyGroup
    {
        CONST_VTBL struct ITxPropertyGroupVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITxPropertyGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITxPropertyGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITxPropertyGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITxPropertyGroup_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITxPropertyGroup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITxPropertyGroup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITxPropertyGroup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITxPropertyGroup_CreateProperty(This,bstrPropertyName,pvarboolExists,ppTxProperty)	\
    (This)->lpVtbl -> CreateProperty(This,bstrPropertyName,pvarboolExists,ppTxProperty)

#define ITxPropertyGroup_GetProperty(This,bstrPropertyName,ppTxProperty)	\
    (This)->lpVtbl -> GetProperty(This,bstrPropertyName,ppTxProperty)

#define ITxPropertyGroup_RemoveProperty(This,bstrPropertyName)	\
    (This)->lpVtbl -> RemoveProperty(This,bstrPropertyName)

#define ITxPropertyGroup__NewEnum(This,ppIEnumObjects)	\
    (This)->lpVtbl -> _NewEnum(This,ppIEnumObjects)

#define ITxPropertyGroup_get_Name(This,pbstrPropertyGroupName)	\
    (This)->lpVtbl -> get_Name(This,pbstrPropertyGroupName)

#define ITxPropertyGroup_get_WriteThrough(This,pvarboolWriteThrough)	\
    (This)->lpVtbl -> get_WriteThrough(This,pvarboolWriteThrough)

#define ITxPropertyGroup_get_CacheCoherently(This,pvarboolCacheCoherently)	\
    (This)->lpVtbl -> get_CacheCoherently(This,pvarboolCacheCoherently)

#define ITxPropertyGroup_get_PropertyGroupManager(This,ppPropertyGroupManager)	\
    (This)->lpVtbl -> get_PropertyGroupManager(This,ppPropertyGroupManager)

#define ITxPropertyGroup_get_Count(This,plCountProperties)	\
    (This)->lpVtbl -> get_Count(This,plCountProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroup_CreateProperty_Proxy(
    ITxPropertyGroup __RPC_FAR * This,
    /* [string][in] */ const BSTR bstrPropertyName,
    /* [in] */ VARIANT_BOOL __RPC_FAR *pvarboolExists,
    /* [retval][out] */ ITxProperty __RPC_FAR *__RPC_FAR *ppTxProperty);


void __RPC_STUB ITxPropertyGroup_CreateProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroup_GetProperty_Proxy(
    ITxPropertyGroup __RPC_FAR * This,
    /* [string][in] */ const BSTR bstrPropertyName,
    /* [retval][out] */ ITxProperty __RPC_FAR *__RPC_FAR *ppTxProperty);


void __RPC_STUB ITxPropertyGroup_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroup_RemoveProperty_Proxy(
    ITxPropertyGroup __RPC_FAR * This,
    /* [string][in] */ const BSTR bstrPropertyName);


void __RPC_STUB ITxPropertyGroup_RemoveProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroup__NewEnum_Proxy(
    ITxPropertyGroup __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppIEnumObjects);


void __RPC_STUB ITxPropertyGroup__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroup_get_Name_Proxy(
    ITxPropertyGroup __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPropertyGroupName);


void __RPC_STUB ITxPropertyGroup_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroup_get_WriteThrough_Proxy(
    ITxPropertyGroup __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarboolWriteThrough);


void __RPC_STUB ITxPropertyGroup_get_WriteThrough_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroup_get_CacheCoherently_Proxy(
    ITxPropertyGroup __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarboolCacheCoherently);


void __RPC_STUB ITxPropertyGroup_get_CacheCoherently_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroup_get_PropertyGroupManager_Proxy(
    ITxPropertyGroup __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppPropertyGroupManager);


void __RPC_STUB ITxPropertyGroup_get_PropertyGroupManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroup_get_Count_Proxy(
    ITxPropertyGroup __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCountProperties);


void __RPC_STUB ITxPropertyGroup_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITxPropertyGroup_INTERFACE_DEFINED__ */


#ifndef __ITxPropertyGroupManager_INTERFACE_DEFINED__
#define __ITxPropertyGroupManager_INTERFACE_DEFINED__

/* interface ITxPropertyGroupManager */
/* [unique][helpstring][dual][uuid][object] */

//=--------------------------------------------------------------------------=
// Enumerated Properties
//=--------------------------------------------------------------------------=


typedef 
enum tagTSPM_ISOLATIONLEVEL
    {	
	IsoLevelReadCommitted		= 0,
	IsoLevelRepeatableRead		= 1,
	IsoLevelSerializable		= 2
    }	TSPM_ISOLATIONLEVEL;

typedef 
enum tagTSPM_CONCURRENCYMODE
    {	
	ConcurModeOptimistic		= 0,
	ConcurModePessimistic		= 1
    }	TSPM_CONCURRENCYMODE;

typedef 
enum tagTSPM_SECURITYSETTING
    {	
	SecurityAllAccess			= 0,
	SecurityUserAccount			= 1,
	SecuritySelectedAccounts	= 2
    }	TSPM_SECURITYSETTING;


EXTERN_C const IID IID_ITxPropertyGroupManager;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("B97C237C-7D7E-11D2-BEA0-00805F0D8F97")
    ITxPropertyGroupManager : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreatePropertyGroup(
            /* [string][in] */ const BSTR bstrPropertyGroupName,
            /* [out] */ VARIANT_BOOL __RPC_FAR *pvarboolExists,
            /* [in] */ VARIANT_BOOL varboolWriteThrough,
            /* [in] */ VARIANT_BOOL varboolRemoveAtProcessTermination,
            /* [in] */ TSPM_SECURITYSETTING eSecuritySetting,
            /* [string][in] */ const BSTR bstrAccessAccounts,
            /* [in] */ VARIANT_BOOL varboolReserved,
            /* [retval][out] */ ITxPropertyGroup __RPC_FAR *__RPC_FAR *ppTxPropertyGroup) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPropertyGroup(
            /* [string][in] */ const BSTR bstrPropertyGroupName,
            /* [in] */ VARIANT_BOOL varboolWriteThrough,
            /* [retval][out] */ ITxPropertyGroup __RPC_FAR *__RPC_FAR *ppTxPropertyGroup) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemovePropertyGroup(
            /* [string][in] */ const BSTR bstrPropertyGroupName) = 0;

        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE _NewEnum(
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppIEnumObjects) = 0;

        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsolationLevel(
            /* [retval][out] */ TSPM_ISOLATIONLEVEL __RPC_FAR *peIsolationLevel) = 0;

        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_IsolationLevel(
            /* [in] */ TSPM_ISOLATIONLEVEL eIsolationLevel) = 0;

        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ConcurrencyMode(
            /* [retval][out] */ TSPM_CONCURRENCYMODE __RPC_FAR *peConcurrencyMode) = 0;

        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ConcurrencyMode(
            /* [in] */ TSPM_CONCURRENCYMODE eConcurrencyMode) = 0;

        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count(
            /* [retval][out] */ long __RPC_FAR *plCountPropertyGroups) = 0;

    };

#else 	/* C style interface */

    typedef struct ITxPropertyGroupManagerVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITxPropertyGroupManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITxPropertyGroupManager __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITxPropertyGroupManager __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            ITxPropertyGroupManager __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            ITxPropertyGroupManager __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            ITxPropertyGroupManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            ITxPropertyGroupManager __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertyGroup )(
            ITxPropertyGroupManager __RPC_FAR * This,
            /* [string][in] */ const BSTR bstrPropertyGroupName,
            /* [out] */ VARIANT_BOOL __RPC_FAR *pvarboolExists,
            /* [in] */ VARIANT_BOOL varboolWriteThrough,
            /* [in] */ VARIANT_BOOL varboolRemoveAtProcessTermination,
            /* [in] */ TSPM_SECURITYSETTING eSecuritySetting,
            /* [string][in] */ const BSTR bstrAccessAccounts,
            /* [in] */ VARIANT_BOOL varboolReserved,
            /* [retval][out] */ ITxPropertyGroup __RPC_FAR *__RPC_FAR *ppTxPropertyGroup);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyGroup )(
            ITxPropertyGroupManager __RPC_FAR * This,
            /* [string][in] */ const BSTR bstrPropertyGroupName,
            /* [in] */ VARIANT_BOOL varboolWriteThrough,
            /* [retval][out] */ ITxPropertyGroup __RPC_FAR *__RPC_FAR *ppTxPropertyGroup);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemovePropertyGroup )(
            ITxPropertyGroupManager __RPC_FAR * This,
            /* [string][in] */ const BSTR bstrPropertyGroupName);

        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )(
            ITxPropertyGroupManager __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppIEnumObjects);

        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsolationLevel )(
            ITxPropertyGroupManager __RPC_FAR * This,
            /* [retval][out] */ TSPM_ISOLATIONLEVEL __RPC_FAR *peIsolationLevel);

        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IsolationLevel )(
            ITxPropertyGroupManager __RPC_FAR * This,
            /* [in] */ TSPM_ISOLATIONLEVEL eIsolationLevel);

        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConcurrencyMode )(
            ITxPropertyGroupManager __RPC_FAR * This,
            /* [retval][out] */ TSPM_CONCURRENCYMODE __RPC_FAR *peConcurrencyMode);

        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ConcurrencyMode )(
            ITxPropertyGroupManager __RPC_FAR * This,
            /* [in] */ TSPM_CONCURRENCYMODE eConcurrencyMode);

        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )(
            ITxPropertyGroupManager __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCountPropertyGroups);

        END_INTERFACE
    } ITxPropertyGroupManagerVtbl;

    interface ITxPropertyGroupManager
    {
        CONST_VTBL struct ITxPropertyGroupManagerVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITxPropertyGroupManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITxPropertyGroupManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITxPropertyGroupManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITxPropertyGroupManager_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITxPropertyGroupManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITxPropertyGroupManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITxPropertyGroupManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITxPropertyGroupManager_CreatePropertyGroup(This,bstrPropertyGroupName,pvarboolExists,varboolWriteThrough,varboolRemoveAtProcessTermination,eSecuritySetting,bstrAccessAccounts,varboolReserved,ppTxPropertyGroup)	\
    (This)->lpVtbl -> CreatePropertyGroup(This,bstrPropertyGroupName,pvarboolExists,varboolWriteThrough,varboolRemoveAtProcessTermination,eSecuritySetting,bstrAccessAccounts,varboolReserved,ppTxPropertyGroup)

#define ITxPropertyGroupManager_GetPropertyGroup(This,bstrPropertyGroupName,varboolWriteThrough,ppTxPropertyGroup)	\
    (This)->lpVtbl -> GetPropertyGroup(This,bstrPropertyGroupName,varboolWriteThrough,ppTxPropertyGroup)

#define ITxPropertyGroupManager_RemovePropertyGroup(This,bstrPropertyGroupName)	\
    (This)->lpVtbl -> RemovePropertyGroup(This,bstrPropertyGroupName)

#define ITxPropertyGroupManager__NewEnum(This,ppIEnumObjects)	\
    (This)->lpVtbl -> _NewEnum(This,ppIEnumObjects)

#define ITxPropertyGroupManager_get_IsolationLevel(This,peIsolationLevel)	\
    (This)->lpVtbl -> get_IsolationLevel(This,peIsolationLevel)

#define ITxPropertyGroupManager_put_IsolationLevel(This,eIsolationLevel)	\
    (This)->lpVtbl -> put_IsolationLevel(This,eIsolationLevel)

#define ITxPropertyGroupManager_get_ConcurrencyMode(This,peConcurrencyMode)	\
    (This)->lpVtbl -> get_ConcurrencyMode(This,peConcurrencyMode)

#define ITxPropertyGroupManager_put_ConcurrencyMode(This,eConcurrencyMode)	\
    (This)->lpVtbl -> put_ConcurrencyMode(This,eConcurrencyMode)

#define ITxPropertyGroupManager_get_Count(This,plCountPropertyGroups)	\
    (This)->lpVtbl -> get_Count(This,plCountPropertyGroups)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroupManager_CreatePropertyGroup_Proxy(
    ITxPropertyGroupManager __RPC_FAR * This,
    /* [string][in] */ const BSTR bstrPropertyGroupName,
    /* [out] */ VARIANT_BOOL __RPC_FAR *pvarboolExists,
    /* [in] */ VARIANT_BOOL varboolWriteThrough,
    /* [in] */ VARIANT_BOOL varboolRemoveAtProcessTermination,
    /* [in] */ TSPM_SECURITYSETTING eSecuritySetting,
    /* [string][in] */ const BSTR bstrAccessAccounts,
    /* [in] */ VARIANT_BOOL varboolReserved,
    /* [retval][out] */ ITxPropertyGroup __RPC_FAR *__RPC_FAR *ppTxPropertyGroup);


void __RPC_STUB ITxPropertyGroupManager_CreatePropertyGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroupManager_GetPropertyGroup_Proxy(
    ITxPropertyGroupManager __RPC_FAR * This,
    /* [string][in] */ const BSTR bstrPropertyGroupName,
    /* [in] */ VARIANT_BOOL varboolWriteThrough,
    /* [retval][out] */ ITxPropertyGroup __RPC_FAR *__RPC_FAR *ppTxPropertyGroup);


void __RPC_STUB ITxPropertyGroupManager_GetPropertyGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroupManager_RemovePropertyGroup_Proxy(
    ITxPropertyGroupManager __RPC_FAR * This,
    /* [string][in] */ const BSTR bstrPropertyGroupName);


void __RPC_STUB ITxPropertyGroupManager_RemovePropertyGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroupManager__NewEnum_Proxy(
    ITxPropertyGroupManager __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppIEnumObjects);


void __RPC_STUB ITxPropertyGroupManager__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroupManager_get_IsolationLevel_Proxy(
    ITxPropertyGroupManager __RPC_FAR * This,
    /* [retval][out] */ TSPM_ISOLATIONLEVEL __RPC_FAR *peIsolationLevel);


void __RPC_STUB ITxPropertyGroupManager_get_IsolationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroupManager_put_IsolationLevel_Proxy(
    ITxPropertyGroupManager __RPC_FAR * This,
    /* [in] */ TSPM_ISOLATIONLEVEL eIsolationLevel);


void __RPC_STUB ITxPropertyGroupManager_put_IsolationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroupManager_get_ConcurrencyMode_Proxy(
    ITxPropertyGroupManager __RPC_FAR * This,
    /* [retval][out] */ TSPM_CONCURRENCYMODE __RPC_FAR *peConcurrencyMode);


void __RPC_STUB ITxPropertyGroupManager_get_ConcurrencyMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroupManager_put_ConcurrencyMode_Proxy(
    ITxPropertyGroupManager __RPC_FAR * This,
    /* [in] */ TSPM_CONCURRENCYMODE eConcurrencyMode);


void __RPC_STUB ITxPropertyGroupManager_put_ConcurrencyMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITxPropertyGroupManager_get_Count_Proxy(
    ITxPropertyGroupManager __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCountPropertyGroups);


void __RPC_STUB ITxPropertyGroupManager_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITxPropertyGroupManager_INTERFACE_DEFINED__ */



#ifndef __TSPM_LIBRARY_DEFINED__
#define __TSPM_LIBRARY_DEFINED__

/* library TSPM */
/* [helpstring][version][uuid] */


EXTERN_C const IID LIBID_TSPM;

EXTERN_C const CLSID CLSID_TransactedPropertyGroupManager;

#ifdef __cplusplus

class DECLSPEC_UUID("DEBCE1BC-7D7E-11D2-BEA0-00805F0D8F97")
TransactedPropertyGroupManager;
#endif

EXTERN_C const CLSID CLSID_TransactedPropertyGroup;

#ifdef __cplusplus

class DECLSPEC_UUID("46DB591F-4101-11D2-912C-0000F8758E8D")
TransactedPropertyGroup;
#endif

EXTERN_C const CLSID CLSID_TransactedProperty;

#ifdef __cplusplus

class DECLSPEC_UUID("6A8DEEA9-4101-11D2-912C-0000F8758E8D")
TransactedProperty;
#endif
#endif /* __TSPM_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * );
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * );

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * );
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif


// The interface IIDs for TSPM
_declspec(selectany) extern
const IID IID_ITxProperty = {0x6A8DEEA8,0x4101,0x11D2,{0x91,0x2C,0x00,0x00,0xF8,0x75,0x8E,0x8D}};

_declspec(selectany) extern
const IID IID_ITxPropertyGroup = {0x46DB591E,0x4101,0x11D2,{0x91,0x2C,0x00,0x00,0xF8,0x75,0x8E,0x8D}};

_declspec(selectany) extern
const IID IID_ITxPropertyGroupManager = {0xB97C237C,0x7D7E,0x11D2,{0xBE,0xA0,0x00,0x80,0x5F,0x0D,0x8F,0x97}};

_declspec(selectany) extern
const IID LIBID_TSPM = {0xBA4B54BC,0x4101,0x11D2,{0x91,0x2C,0x00,0x00,0xF8,0x75,0x8E,0x8D}};

_declspec(selectany) extern
const CLSID CLSID_TransactedPropertyGroupManager = {0xDEBCE1BC,0x7D7E,0x11D2,{0xBE,0xA0,0x00,0x80,0x5F,0x0D,0x8F,0x97}};

_declspec(selectany) extern
const CLSID CLSID_TransactedPropertyGroup = {0x46DB591F,0x4101,0x11D2,{0x91,0x2C,0x00,0x00,0xF8,0x75,0x8E,0x8D}};

_declspec(selectany) extern
const CLSID CLSID_TransactedProperty = {0x6A8DEEA9,0x4101,0x11D2,{0x91,0x2C,0x00,0x00,0xF8,0x75,0x8E,0x8D}};

#endif // _MSIMDB_H_

//
// End Of File
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\nspapip.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    nspapip.h

Abstract:

    Internel Name Space Provider API prototypes and manifests.  This
    header file should only be included by name space providers.  NSPAPI
    users should include only nspapi.h See the "Windows NT NameSpace
    Provider Specification" document for details.


Author:

    David Treadwell (davidtr)   28-Apr-1994

Environment:

    User Mode -Win32

Notes:

Revision History:

    28-Apr-1994     DavidTr      Created first cut.

--*/

#ifndef _NSPAPIP_INCLUDED
#define _NSPAPIP_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

//
// Standard priority values for the dwPriority field of NS_ROUTINE.
//
#define NS_STANDARD_FAST_PRIORITY   (500)
#define NS_MAX_FAST_PRIORITY        (999)
#define NS_STANDARD_PRIORITY        (2000)

//
// Indices for the alpfnFunctions array field of NS_ROUTINE.
//
#define NSPAPI_GET_ADDRESS_BY_NAME  (0x00000000)
#define NSPAPI_GET_SERVICE          (0x00000001)
#define NSPAPI_SET_SERVICE          (0x00000002)

//
// Structures used by the provider interface.
//

typedef
INT
(APIENTRY *LPGET_ADDR_BY_NAME_PROC) (
    IN     LPGUID          lpServiceType,
    IN     LPWSTR          lpServiceName,
    IN     LPDWORD         lpdwProtocols,
    IN     DWORD           dwResolution,
    IN     OUT LPVOID      lpCsaddrBuffer,
    IN     OUT LPDWORD     lpdwBufferLength,
    IN OUT LPWSTR          lpAliasBuffer,
    IN OUT LPDWORD         lpdwAliasBufferLength,
    IN     HANDLE          hCancellationEvent
    );

typedef struct _NS_ROUTINE {
    DWORD        dwFunctionCount;
    LPFN_NSPAPI *alpfnFunctions;
    DWORD        dwNameSpace;
    DWORD        dwPriority;
} NS_ROUTINE, *PNS_ROUTINE, * FAR LPNS_ROUTINE;

typedef
DWORD

(APIENTRY *LPLOAD_NAME_SPACE_PROC) (
    IN OUT LPDWORD         lpdwVersion,
    IN OUT LPNS_ROUTINE    nsrBuffer,
    IN OUT LPDWORD         lpdwBufferLength
    );

typedef
INT
(APIENTRY *LPGET_SERVICE_PROC) (
    IN     LPGUID          lpServiceType,
    IN     LPWSTR          lpServiceName,
    IN     DWORD           dwProperties,
    IN     BOOL            fUnicodeBlob,
    OUT    LPSERVICE_INFO  lpServiceInfo,
    IN OUT LPDWORD         lpdwBufferLen
    );

typedef
DWORD
(APIENTRY *LPSET_SERVICE_PROC) (
    IN     DWORD           dwOperation,
    IN     DWORD           dwFlags,
    IN     BOOL            fUnicodeBlob,
    IN     LPSERVICE_INFO  lpServiceInfo
    );

//
// Internal Functions
//
DWORD
APIENTRY
NPGetService (
    IN     LPGUID          lpServiceType,
    IN     LPWSTR          lpServiceName,
    IN     DWORD           dwProperties,
    IN     BOOL            fUnicodeBlob,
    OUT    LPSERVICE_INFO  lpServiceInfo,
    IN OUT LPDWORD         lpdwBufferLen
    );

DWORD
APIENTRY
NPSetService (
    IN     DWORD           dwOperation,
    IN     DWORD           dwFlags,
    IN     BOOL            fUnicodeBlob,
    IN     LPSERVICE_INFO  lpServiceInfo
    );

INT
APIENTRY
NPGetAddressByName (
    IN     LPGUID          lpServiceType,
    IN     LPWSTR          lpServiceName,
    IN     LPDWORD         lpdwProtocols,
    IN     DWORD           dwResolution,
    IN OUT LPVOID          lpCsaddrBuffer,
    IN OUT LPDWORD         lpdwBufferLength,
    IN OUT LPWSTR          lpAliasBuffer,
    IN OUT LPDWORD         lpdwAliasBufferLength,
    IN     HANDLE          hCancellationEvent
    );

INT
APIENTRY
NPLoadNameSpaces (
    IN OUT LPDWORD         lpdwVersion,
    IN OUT LPNS_ROUTINE    nsrBuffer,
    IN OUT LPDWORD         lpdwBufferLength
    );

#endif  // _NSPAPIP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntagp.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    ntagp.h

Abstract:

    This file defines the external interface for the AGP bus filter driver

Author:

    John Vert (jvert) 10/26/1997

Revision History:

--*/
#ifndef _NTAGP_
#define _NTAGP_

#if _MSC_VER > 1000
#pragma once
#endif

DEFINE_GUID(GUID_AGP_BUS_INTERFACE_STANDARD, 0x2ef74803, 0xd8d3, 0x11d1, 0x9c, 0xaa, 0x00, 0xc0, 0xf0, 0x16, 0x56, 0x36 );
//
// Define AGP Interface version
//
#define AGP_BUS_INTERFACE_V1 1
#define AGP_BUS_INTERFACE_V2 2

//
// Define AGP Capabilities field
//
#define AGP_CAPABILITIES_MAP_PHYSICAL   0x00000001

typedef
NTSTATUS
(*PAGP_BUS_SET_RATE)(
    IN PVOID AgpContext,
    IN ULONG AgpRate
    );

typedef
NTSTATUS
(*PAGP_BUS_RESERVE_MEMORY)(
    IN PVOID AgpContext,
    IN ULONG NumberOfPages,
    IN MEMORY_CACHING_TYPE MemoryType,
    OUT PVOID *MapHandle,
    OUT OPTIONAL PHYSICAL_ADDRESS *PhysicalAddress
    );

typedef
NTSTATUS
(*PAGP_BUS_RELEASE_MEMORY)(
    IN PVOID AgpContext,
    IN PVOID MapHandle
    );

typedef
NTSTATUS
(*PAGP_BUS_COMMIT_MEMORY)(
    IN PVOID AgpContext,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    IN OUT PMDL Mdl OPTIONAL,
    OUT PHYSICAL_ADDRESS *MemoryBase
    );

typedef
NTSTATUS
(*PAGP_BUS_FREE_MEMORY)(
    IN PVOID AgpContext,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    );

typedef
NTSTATUS
(*PAGP_GET_MAPPED_PAGES)(
    IN PVOID AgpContext,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mld
    );

typedef struct _AGP_BUS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID AgpContext;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // AGP bus interfaces
    //

    ULONG Capabilities;
    PAGP_BUS_RESERVE_MEMORY ReserveMemory;
    PAGP_BUS_RELEASE_MEMORY ReleaseMemory;
    PAGP_BUS_COMMIT_MEMORY CommitMemory;
    PAGP_BUS_FREE_MEMORY FreeMemory;
    PAGP_GET_MAPPED_PAGES GetMappedPages;
    PAGP_BUS_SET_RATE SetRate;
} AGP_BUS_INTERFACE_STANDARD, *PAGP_BUS_INTERFACE_STANDARD;

//
// I don't believe we need to maintain compatibility with older binary
// versions of videoprt, the only consumer of this interface, but we'll
// go ahead and support v1 as an exercise
//
#define AGP_BUS_INTERFACE_V1_SIZE \
    (sizeof(AGP_BUS_INTERFACE_STANDARD) - sizeof(PAGP_BUS_SET_RATE))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\msstkppg.h ===
//=--------------------------------------------------------------------------=
// MSStkPPg.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for msprop32's property pages.
//
#ifndef _MS_STOCK_PROP_PAGES_H_

// {7EBDAAE0-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockFontPage, 0x7ebdaae0, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

// {7EBDAAE1-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockColorPage, 0x7ebdaae1, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

// {7EBDAAE2-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockPicturePage, 0x7ebdaae2, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

#define _MS_STOCK_PROP_PAGES_H_
#endif // _MS_STOCK_PROP_PAGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntapmsdk.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    ntapmsdk.h

Abstract:

    This header contain nt apm support constants that need to be
    defined in sdk\inc so it can be used by setup, sdktools, etc,

    None of this should appear in the actual sdk or any other public
    distribution of header data.

Author:

    Bryan M. Willman (bryanwi) 16-Sep-1998

Revision History:

--*/

#ifndef _NTAPMSDK_
#define _NTAPMSDK_

#if _MSC_VER > 1000
#pragma once
#endif

//
// APM Registery information stored by ntdetect
//

typedef struct _APM_REGISTRY_INFO {

    //
    // OLD part of the structure, leave this alone
    // so that we can dual boot with NT4.
    //

    UCHAR       ApmRevMajor;
    UCHAR       ApmRevMinor;

    USHORT      ApmInstallFlags;

    //
    // Defines for 16 bit interface connect
    //

    USHORT      Code16BitSegment;
    USHORT      Code16BitOffset;
    USHORT      Data16BitSegment;

    //
    // NEW part of the structure for NT5.
    //

    UCHAR       Signature[3];
    UCHAR       Valid;

    //
    // Detection Log Space
    //

    UCHAR       DetectLog[16];      // see hwapm in halx86

} APM_REGISTRY_INFO, *PAPM_REGISTRY_INFO;

#endif // _NTAPMSDK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntddfs.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddfs.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the File system device.

Author:

    Steve Wood (stevewo) 27-May-1990

Revision History:

--*/

#ifndef _NTDDFS_
#define _NTDDFS_

#if _MSC_VER > 1000
#pragma once
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_FS_DEVICE_NAME "\\Device\\UNKNOWN"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_FS_BASE                   FILE_DEVICE_DISK_FILE_SYSTEM


//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

#endif  // _NTDDFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntddapmt.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    ntddapmt.h

Abstract:

    Public interface definitions for APMTEST.SYS, the
        Advanced Power Management UI test device driver.

--*/

#ifndef _NTDDAPMT_
#define _NTDDAPMT_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//  APM_IOCTL_GET_VERSION
//      Gets the version of the installed APM device.
//
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM version.

// Returned by APM_IOCTL_GET_VERSION

#define APM_DRIVER_VERSION 0x0400

#define APM_IOCTL_GET_VERSION               0x80FF0004

//  APM_IOCTL_GET_APM_BIOS_VERSION
//      Gets the version of the APM BIOS that APM has detected.
//
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM BIOS version.
#define APM_IOCTL_GET_APM_BIOS_VERSION      0x80FF0008

//  APM_IOCTL_GET_PM_LEVEL
//      Gets the level of power management interaction between APM and the
//      APM BIOS.
//
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD to receive the current power management
//                  level.
#define APM_IOCTL_GET_PM_LEVEL              0x80FF000C

//  APM_IOCTL_SET_PM_LEVEL
//      Sets the level of power management interaction between APM and the
//      APM BIOS.
//
//  lpvInBuffer:    Pointer to APM_SET_PM_LEVEL_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM return code.
#define APM_IOCTL_SET_PM_LEVEL              0x80FF0010

#define PMLEVEL_ADVANCED 0x0001

typedef struct _APM_SET_PM_LEVEL_PARAM {
    DWORD PowerManagementLevel;
}   APM_SET_PM_LEVEL_PARAM;

//  APM_IOCTL_SET_DEVICE_STATE
//      Sets the power state (e.g., OFF) of the specified device ID.  Not valid
//      for the system device (all devices power managed by the APM BIOS).
//
//  lpvInBuffer:    Pointer to APM_SET_DEVICE_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM return code.
#define APM_IOCTL_SET_DEVICE_STATE          0x80FF0014

//
//  Power device ID type and standard IDs as defined by the APM 1.1
//  specification.
//

typedef DWORD                           POWER_DEVICE_ID;

#define PDI_APM_BIOS                    0x0000
#define PDI_MANAGED_BY_APM_BIOS         0x0001
#define PDI_MANAGED_BY_APM_BIOS_OLD     0xFFFF

//
//  Power state type and standard power states as defined by the APM 1.1
//  specification.
//

#define PSTATE_APM_ENABLED              0x0000
#define PSTATE_STANDBY                  0x0001
#define PSTATE_SUSPEND                  0x0002
#define PSTATE_OFF                      0x0003

typedef struct _APM_SET_DEVICE_PARAM {
    POWER_DEVICE_ID PowerDeviceID;
    DWORD PowerState;
}   APM_SET_DEVICE_PARAM;

//  APM_IOCTL_RESTORE_DEFAULTS
//      Reinitializes all APM BIOS power-on defaults.
//
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM return code.
#define APM_IOCTL_RESTORE_DEFAULTS          0x80FF001C

//  APM_IOCTL_GET_STATUS
//      Gets the current power status of the specified device ID.
//
//  lpvInBuffer:    Pointer to APM_GET_STATUS_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM return code.
#define APM_IOCTL_GET_STATUS                0x80FF0020

typedef struct _POWER_STATUS {
    BYTE PS_AC_Line_Status;
    BYTE PS_Battery_Status;
    BYTE PS_Battery_Flag;
    BYTE PS_Battery_Life_Percentage;
    WORD PS_Battery_Life_Time;
}   POWER_STATUS;

typedef POWER_STATUS *LPPOWER_STATUS;

typedef struct _APM_GET_STATUS_PARAM {
    POWER_DEVICE_ID PowerDeviceID;
    LPPOWER_STATUS lpPowerStatus;
}   APM_GET_STATUS_PARAM;

//  APM_IOCTL_GET_STATE
//      Gets the power state (e.g., OFF) of the specified device ID.
//
//  lpvInBuffer:    Pointer to APM_GET_STATE_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM return code.
#define APM_IOCTL_GET_STATE                 0x80FF0024

typedef struct _APM_GET_STATE_PARAM {
    POWER_DEVICE_ID PowerDeviceID;
    LPDWORD lpPowerState;
}   GET_STATE_PARAM;

//  APM_IOCTL_OEM_APM_FUNCTION
//      Calls an OEM defined APM BIOS extension.
//
//  lpvInBuffer:    Pointer to APM_OEM_APM_FUNCTION_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM return code.
#define APM_IOCTL_OEM_APM_FUNCTION          0x80FF0028

//
//  OEM APM Register Structure used by _APM_OEM_APM_Function.
//

struct _OEM_APM_BYTE_REGS {
    WORD OEMAPM_Reserved1[6];
    BYTE OEMAPM_BL;
    BYTE OEMAPM_BH;
    WORD OEMAPM_Reserved2;
    BYTE OEMAPM_DL;
    BYTE OEMAPM_DH;
    WORD OEMAPM_Reserved3;
    BYTE OEMAPM_CL;
    BYTE OEMAPM_CH;
    WORD OEMAPM_Reserved4;
    BYTE OEMAPM_AL;
    BYTE OEMAPM_AH;
    WORD OEMAPM_Reserved5;
    BYTE OEMAPM_Flags;
    BYTE OEMAPM_Reserved6[3];
};

struct _OEM_APM_WORD_REGS {
    WORD OEMAPM_DI;
    WORD OEMAPM_Reserved7;
    WORD OEMAPM_SI;
    WORD OEMAPM_Reserved8;
    WORD OEMAPM_BP;
    WORD OEMAPM_Reserved9;
    WORD OEMAPM_BX;
    WORD OEMAPM_Reserved10;
    WORD OEMAPM_DX;
    WORD OEMAPM_Reserved11;
    WORD OEMAPM_CX;
    WORD OEMAPM_Reserved12;
    WORD OEMAPM_AX;
    WORD OEMAPM_Reserved13[3];
};
struct _OEM_APM_DWORD_REGS {
    DWORD OEMAPM_EDI;
    DWORD OEMAPM_ESI;
    DWORD OEMAPM_EBP;
    DWORD OEMAPM_EBX;
    DWORD OEMAPM_EDX;
    DWORD OEMAPM_ECX;
    DWORD OEMAPM_EAX;
    DWORD OEMAPM_Reserved14;
};

typedef union _OEM_APM_REGS {
    struct _OEM_APM_BYTE_REGS ByteRegs;
    struct _OEM_APM_WORD_REGS WordRegs;
    struct _OEM_APM_DWORD_REGS DwordRegs;
}   OEM_APM_REGS, *LPOEM_APM_REGS;

typedef struct _APM_OEM_APM_FUNCTION_PARAM {
    LPOEM_APM_REGS lpOemApmRegs;
}   APM_OEM_APM_FUNCTION_PARAM;

//  APM_IOCTL_W32_GET_SYSTEM_STATUS
//      Gets the current power status of the system.  Follows the Win32
//      GetSystemPowerStatus API convention.
//
//  lpvInBuffer:    Pointer to APM_W32_GET_SYSTEM_STATUS_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the boolean return code.
#define APM_IOCTL_W32_GET_SYSTEM_STATUS     0x80FF0034

// APM_CAPABILITIES, Capabilities flags:
#define CAPS_SUPPORTS_STANDBY   1
#define CAPS_SUPPORTS_SUSPEND   2
#define CAPS_SUPPORTS_HIBERNATE 4

typedef struct APM_CAPABILITIES_S   {
        WORD Capabilities;
        BYTE BatteryCount;
        BYTE Reserved;
}APM_CAPABILITIES, *PAPM_CAPABILITIES;

typedef struct _WIN32_SYSTEM_POWER_STATUS {
    BYTE W32PS_AC_Line_Status;
    BYTE W32PS_Battery_Flag;
    BYTE W32PS_Battery_Life_Percent;
    BYTE W32PS_Reserved1;
    DWORD W32PS_Battery_Life_Time;
    DWORD W32PS_Battery_Full_Life_Time;
}   WIN32_SYSTEM_POWER_STATUS;

typedef WIN32_SYSTEM_POWER_STATUS *LPWIN32_SYSTEM_POWER_STATUS;

typedef struct _APM_W32_GET_SYSTEM_STATUS_PARAM {
    LPWIN32_SYSTEM_POWER_STATUS lpWin32SystemPowerStatus;
}   APM_W32_GET_SYSTEM_STATUS_PARAM;


//  APM_IOCTL_GET_CAPABILITIES
//      Gets the capabilities bitmask of an APM 1.2 machine.
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to APM_CAPABILITIES structure.
#define APM_IOCTL_GET_CAPABILITIES          0x80FF003C

typedef struct _APM_GET_CAPABILITIES_PARAM {
        PAPM_CAPABILITIES   pApmCaps;
}   APM_GET_CAPABILITIES_PARAM;

//  APM_IOCTL_GET_RING_RESUME_STATUS
//      Gets the ring resume status.
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD which will contain the status.
#define APM_IOCTL_GET_RING_RESUME_STATUS    0x80FF0040


//  APM_IOCTL_ENABLE_RING_RESUME
//      Sets the ring resume status.
//  lpvInBuffer:    Points to new status.
//  lpvOutBuffer:   Pointer to APM_CAPABILITIES structure.
#define APM_IOCTL_ENABLE_RING_RESUME          0x80FF0044

#ifdef __cplusplus
}
#endif

#endif  // _NTDDAPMT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\nb30.h ===
//*++
//
// Copyright (c) 1991-1999  Microsoft Corporation
//
// Module Name:
//
//  nb30.h
//
// Abstract:
//
//  This module contains the definitions for portable NetBIOS 3.0
//  support.
//
//--*/

#ifndef NCB_INCLUDED
#define NCB_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************
 *                                                              *
 *              Data structure templates                        *
 *                                                              *
 ****************************************************************/

#define NCBNAMSZ        16    /* absolute length of a net name           */
#define MAX_LANA       254    /* lana's in range 0 to MAX_LANA inclusive */

/*
 * Network Control Block
 */

typedef struct _NCB {
    UCHAR   ncb_command;            /* command code                   */
    UCHAR   ncb_retcode;            /* return code                    */
    UCHAR   ncb_lsn;                /* local session number           */
    UCHAR   ncb_num;                /* number of our network name     */
    PUCHAR  ncb_buffer;             /* address of message buffer      */
    WORD    ncb_length;             /* size of message buffer         */
    UCHAR   ncb_callname[NCBNAMSZ]; /* blank-padded name of remote    */
    UCHAR   ncb_name[NCBNAMSZ];     /* our blank-padded netname       */
    UCHAR   ncb_rto;                /* rcv timeout/retry count        */
    UCHAR   ncb_sto;                /* send timeout/sys timeout       */
    void (CALLBACK *ncb_post)( struct _NCB * ); /* POST routine address        */
    UCHAR   ncb_lana_num;           /* lana (adapter) number          */
    UCHAR   ncb_cmd_cplt;           /* 0xff => commmand pending       */
#ifdef _WIN64
    UCHAR   ncb_reserve[18];        /* reserved, used by BIOS         */
#else
    UCHAR   ncb_reserve[10];        /* reserved, used by BIOS         */
#endif
    HANDLE  ncb_event;              /* HANDLE to Win32 event which    */
                                    /* will be set to the signalled   */
                                    /* state when an ASYNCH command   */
                                    /* completes                      */
} NCB, *PNCB;

/*
 *  Structure returned to the NCB command NCBASTAT is ADAPTER_STATUS followed
 *  by an array of NAME_BUFFER structures.
 */

typedef struct _ADAPTER_STATUS {
    UCHAR   adapter_address[6];
    UCHAR   rev_major;
    UCHAR   reserved0;
    UCHAR   adapter_type;
    UCHAR   rev_minor;
    WORD    duration;
    WORD    frmr_recv;
    WORD    frmr_xmit;

    WORD    iframe_recv_err;

    WORD    xmit_aborts;
    DWORD   xmit_success;
    DWORD   recv_success;

    WORD    iframe_xmit_err;

    WORD    recv_buff_unavail;
    WORD    t1_timeouts;
    WORD    ti_timeouts;
    DWORD   reserved1;
    WORD    free_ncbs;
    WORD    max_cfg_ncbs;
    WORD    max_ncbs;
    WORD    xmit_buf_unavail;
    WORD    max_dgram_size;
    WORD    pending_sess;
    WORD    max_cfg_sess;
    WORD    max_sess;
    WORD    max_sess_pkt_size;
    WORD    name_count;
} ADAPTER_STATUS, *PADAPTER_STATUS;

typedef struct _NAME_BUFFER {
    UCHAR   name[NCBNAMSZ];
    UCHAR   name_num;
    UCHAR   name_flags;
} NAME_BUFFER, *PNAME_BUFFER;

//  values for name_flags bits.

#define NAME_FLAGS_MASK 0x87

#define GROUP_NAME      0x80
#define UNIQUE_NAME     0x00

#define REGISTERING     0x00
#define REGISTERED      0x04
#define DEREGISTERED    0x05
#define DUPLICATE       0x06
#define DUPLICATE_DEREG 0x07

/*
 *  Structure returned to the NCB command NCBSSTAT is SESSION_HEADER followed
 *  by an array of SESSION_BUFFER structures. If the NCB_NAME starts with an
 *  asterisk then an array of these structures is returned containing the
 *  status for all names.
 */

typedef struct _SESSION_HEADER {
    UCHAR   sess_name;
    UCHAR   num_sess;
    UCHAR   rcv_dg_outstanding;
    UCHAR   rcv_any_outstanding;
} SESSION_HEADER, *PSESSION_HEADER;

typedef struct _SESSION_BUFFER {
    UCHAR   lsn;
    UCHAR   state;
    UCHAR   local_name[NCBNAMSZ];
    UCHAR   remote_name[NCBNAMSZ];
    UCHAR   rcvs_outstanding;
    UCHAR   sends_outstanding;
} SESSION_BUFFER, *PSESSION_BUFFER;

//  Values for state

#define LISTEN_OUTSTANDING      0x01
#define CALL_PENDING            0x02
#define SESSION_ESTABLISHED     0x03
#define HANGUP_PENDING          0x04
#define HANGUP_COMPLETE         0x05
#define SESSION_ABORTED         0x06

/*
 *  Structure returned to the NCB command NCBENUM.
 *
 *  On a system containing lana's 0, 2 and 3, a structure with
 *  length =3, lana[0]=0, lana[1]=2 and lana[2]=3 will be returned.
 */

typedef struct _LANA_ENUM {
    UCHAR   length;         //  Number of valid entries in lana[]
    UCHAR   lana[MAX_LANA+1];
} LANA_ENUM, *PLANA_ENUM;

/*
 *  Structure returned to the NCB command NCBFINDNAME is FIND_NAME_HEADER followed
 *  by an array of FIND_NAME_BUFFER structures.
 */

typedef struct _FIND_NAME_HEADER {
    WORD    node_count;
    UCHAR   reserved;
    UCHAR   unique_group;
} FIND_NAME_HEADER, *PFIND_NAME_HEADER;

typedef struct _FIND_NAME_BUFFER {
    UCHAR   length;
    UCHAR   access_control;
    UCHAR   frame_control;
    UCHAR   destination_addr[6];
    UCHAR   source_addr[6];
    UCHAR   routing_info[18];
} FIND_NAME_BUFFER, *PFIND_NAME_BUFFER;

/*
 *  Structure provided with NCBACTION. The purpose of NCBACTION is to provide
 *  transport specific extensions to netbios.
 */

typedef struct _ACTION_HEADER {
    ULONG   transport_id;
    USHORT  action_code;
    USHORT  reserved;
} ACTION_HEADER, *PACTION_HEADER;

//  Values for transport_id

#define ALL_TRANSPORTS  "M\0\0\0"
#define MS_NBF          "MNBF"


/****************************************************************
 *                                                              *
 *              Special values and constants                    *
 *                                                              *
 ****************************************************************/

/*
 *      NCB Command codes
 */

#define NCBCALL         0x10            /* NCB CALL                           */
#define NCBLISTEN       0x11            /* NCB LISTEN                         */
#define NCBHANGUP       0x12            /* NCB HANG UP                        */
#define NCBSEND         0x14            /* NCB SEND                           */
#define NCBRECV         0x15            /* NCB RECEIVE                        */
#define NCBRECVANY      0x16            /* NCB RECEIVE ANY                    */
#define NCBCHAINSEND    0x17            /* NCB CHAIN SEND                     */
#define NCBDGSEND       0x20            /* NCB SEND DATAGRAM                  */
#define NCBDGRECV       0x21            /* NCB RECEIVE DATAGRAM               */
#define NCBDGSENDBC     0x22            /* NCB SEND BROADCAST DATAGRAM        */
#define NCBDGRECVBC     0x23            /* NCB RECEIVE BROADCAST DATAGRAM     */
#define NCBADDNAME      0x30            /* NCB ADD NAME                       */
#define NCBDELNAME      0x31            /* NCB DELETE NAME                    */
#define NCBRESET        0x32            /* NCB RESET                          */
#define NCBASTAT        0x33            /* NCB ADAPTER STATUS                 */
#define NCBSSTAT        0x34            /* NCB SESSION STATUS                 */
#define NCBCANCEL       0x35            /* NCB CANCEL                         */
#define NCBADDGRNAME    0x36            /* NCB ADD GROUP NAME                 */
#define NCBENUM         0x37            /* NCB ENUMERATE LANA NUMBERS         */
#define NCBUNLINK       0x70            /* NCB UNLINK                         */
#define NCBSENDNA       0x71            /* NCB SEND NO ACK                    */
#define NCBCHAINSENDNA  0x72            /* NCB CHAIN SEND NO ACK              */
#define NCBLANSTALERT   0x73            /* NCB LAN STATUS ALERT               */
#define NCBACTION       0x77            /* NCB ACTION                         */
#define NCBFINDNAME     0x78            /* NCB FIND NAME                      */
#define NCBTRACE        0x79            /* NCB TRACE                          */


#define ASYNCH          0x80            /* high bit set == asynchronous       */

/*
 *      NCB Return codes
 */

#define NRC_GOODRET     0x00    /* good return                                */
                                /* also returned when ASYNCH request accepted */
#define NRC_BUFLEN      0x01    /* illegal buffer length                      */
#define NRC_ILLCMD      0x03    /* illegal command                            */
#define NRC_CMDTMO      0x05    /* command timed out                          */
#define NRC_INCOMP      0x06    /* message incomplete, issue another command  */
#define NRC_BADDR       0x07    /* illegal buffer address                     */
#define NRC_SNUMOUT     0x08    /* session number out of range                */
#define NRC_NORES       0x09    /* no resource available                      */
#define NRC_SCLOSED     0x0a    /* session closed                             */
#define NRC_CMDCAN      0x0b    /* command cancelled                          */
#define NRC_DUPNAME     0x0d    /* duplicate name                             */
#define NRC_NAMTFUL     0x0e    /* name table full                            */
#define NRC_ACTSES      0x0f    /* no deletions, name has active sessions     */
#define NRC_LOCTFUL     0x11    /* local session table full                   */
#define NRC_REMTFUL     0x12    /* remote session table full                  */
#define NRC_ILLNN       0x13    /* illegal name number                        */
#define NRC_NOCALL      0x14    /* no callname                                */
#define NRC_NOWILD      0x15    /* cannot put * in NCB_NAME                   */
#define NRC_INUSE       0x16    /* name in use on remote adapter              */
#define NRC_NAMERR      0x17    /* name deleted                               */
#define NRC_SABORT      0x18    /* session ended abnormally                   */
#define NRC_NAMCONF     0x19    /* name conflict detected                     */
#define NRC_IFBUSY      0x21    /* interface busy, IRET before retrying       */
#define NRC_TOOMANY     0x22    /* too many commands outstanding, retry later */
#define NRC_BRIDGE      0x23    /* ncb_lana_num field invalid                 */
#define NRC_CANOCCR     0x24    /* command completed while cancel occurring   */
#define NRC_CANCEL      0x26    /* command not valid to cancel                */
#define NRC_DUPENV      0x30    /* name defined by anther local process       */
#define NRC_ENVNOTDEF   0x34    /* environment undefined. RESET required      */
#define NRC_OSRESNOTAV  0x35    /* required OS resources exhausted            */
#define NRC_MAXAPPS     0x36    /* max number of applications exceeded        */
#define NRC_NOSAPS      0x37    /* no saps available for netbios              */
#define NRC_NORESOURCES 0x38    /* requested resources are not available      */
#define NRC_INVADDRESS  0x39    /* invalid ncb address or length > segment    */
#define NRC_INVDDID     0x3B    /* invalid NCB DDID                           */
#define NRC_LOCKFAIL    0x3C    /* lock of user area failed                   */
#define NRC_OPENERR     0x3f    /* NETBIOS not loaded                         */
#define NRC_SYSTEM      0x40    /* system error                               */

#define NRC_PENDING     0xff    /* asynchronous command is not yet finished   */

/****************************************************************
 *                                                              *
 *              main user entry point for NetBIOS 3.0           *
 *                                                              *
 * Usage: result = Netbios( pncb );                             *
 ****************************************************************/

UCHAR
APIENTRY
Netbios(
    PNCB pncb
    );

/****************************************************************
 *                                                              *
 *              Prefix for callback routines                    *
 *                                                              *
 * Usage in a declaration: NCB_POST MyPostRoutine( PNCB pncb ); *
 ****************************************************************/

#define NCB_POST void CALLBACK

#ifdef __cplusplus
}
#endif

#endif /* NCB_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\nddeapi.h ===
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
* Copyright (c) Microsoft Inc. 1995-1999                                *
*               All Rights Reserved.                                    *
************************************************************************/

#ifndef          _INC_NDDEAPI
#define          _INC_NDDEAPI

#if _MSC_VER > 1000
#pragma once
#endif

#include <pshpack1.h>   /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif    /* __cplusplus */

#ifndef CNLEN           /* If not included with netapi header */
#define CNLEN           15                  /* Computer name length     */
#define UNCLEN          (CNLEN+2)           /* UNC computer name length */
#endif /* CNLEN */

// the choice of this char affects legal share,topic, etc. names
#define SEP_CHAR    ','
#define BAR_CHAR    "|"
#define SEP_WCHAR   L','
#define BAR_WCHAR   L"|"

/* API error codes  */
#define NDDE_NO_ERROR                   0
#define NDDE_ACCESS_DENIED              1
#define NDDE_BUF_TOO_SMALL              2
#define NDDE_ERROR_MORE_DATA            3
#define NDDE_INVALID_SERVER             4
#define NDDE_INVALID_SHARE              5
#define NDDE_INVALID_PARAMETER          6
#define NDDE_INVALID_LEVEL              7
#define NDDE_INVALID_PASSWORD           8
#define NDDE_INVALID_ITEMNAME           9
#define NDDE_INVALID_TOPIC             10
#define NDDE_INTERNAL_ERROR            11
#define NDDE_OUT_OF_MEMORY             12
#define NDDE_INVALID_APPNAME           13
#define NDDE_NOT_IMPLEMENTED           14
#define NDDE_SHARE_ALREADY_EXIST       15
#define NDDE_SHARE_NOT_EXIST           16
#define NDDE_INVALID_FILENAME          17
#define NDDE_NOT_RUNNING               18
#define NDDE_INVALID_WINDOW            19
#define NDDE_INVALID_SESSION           20
#define NDDE_INVALID_ITEM_LIST         21
#define NDDE_SHARE_DATA_CORRUPTED      22
#define NDDE_REGISTRY_ERROR            23
#define NDDE_CANT_ACCESS_SERVER        24
#define NDDE_INVALID_SPECIAL_COMMAND   25
#define NDDE_INVALID_SECURITY_DESC     26
#define NDDE_TRUST_SHARE_FAIL          27

/* string size constants */
#define MAX_NDDESHARENAME       256
#define MAX_DOMAINNAME          15
#define MAX_USERNAME            15
#define MAX_APPNAME             255
#define MAX_TOPICNAME           255
#define MAX_ITEMNAME            255

/* connectFlags bits for ndde service affix */
#define NDDEF_NOPASSWORDPROMPT  0x0001
#define NDDEF_NOCACHELOOKUP     0x0002
#define NDDEF_STRIP_NDDE        0x0004


/* NDDESHAREINFO - contains information about a NDDE share */

struct NDdeShareInfo_tag {
    LONG                    lRevision;
    LPTSTR                  lpszShareName;
    LONG                    lShareType;
    LPTSTR                  lpszAppTopicList;
    LONG                    fSharedFlag;
    LONG                    fService;
    LONG                    fStartAppFlag;
    LONG                    nCmdShow;
    LONG                    qModifyId[2];
    LONG                    cNumItems;
    LPTSTR                  lpszItemList;
};
typedef struct NDdeShareInfo_tag   NDDESHAREINFO;
typedef struct NDdeShareInfo_tag * PNDDESHAREINFO;

/*  Share Types */
#define SHARE_TYPE_OLD      0x01                // Excel|sheet1.xls
#define SHARE_TYPE_NEW      0x02                // ExcelWorksheet|sheet1.xls
#define SHARE_TYPE_STATIC   0x04                // ClipSrv|SalesData

/*
    Add new share
*/
UINT WINAPI
NDdeShareAddA (
    LPSTR                   lpszServer, // server to execute on ( must be NULL )
    UINT                    nLevel,     // info level must be 2
    PSECURITY_DESCRIPTOR    pSD,        // initial security descriptor (optional)
    LPBYTE                  lpBuffer,   // contains (NDDESHAREINFO) + data
    DWORD                   cBufSize    // sizeof supplied buffer
);

UINT WINAPI
NDdeShareAddW (
    LPWSTR                  lpszServer, // server to execute on ( must be NULL )
    UINT                    nLevel,     // info level must be 2
    PSECURITY_DESCRIPTOR    pSD,        // initial security descriptor (optional)
    LPBYTE                  lpBuffer,   // contains (NDDESHAREINFO) + data
    DWORD                   cBufSize    // sizeof supplied buffer
);

/*
    Delete a share
*/
UINT WINAPI
NDdeShareDelA (
    LPSTR   lpszServer,     // server to execute on ( must be NULL )
    LPSTR   lpszShareName,  // name of share to delete
    UINT    wReserved       // reserved for force level (?) 0 for now
);

UINT WINAPI
NDdeShareDelW (
    LPWSTR  lpszServer,     // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,  // name of share to delete
    UINT    wReserved       // reserved for force level (?) 0 for now
);

/*
    Get Share Security Descriptor
*/

UINT WINAPI
NDdeGetShareSecurityA(
    LPSTR                   lpszServer,     // server to execute on ( must be NULL )
    LPSTR                   lpszShareName,  // name of share to delete
    SECURITY_INFORMATION    si,             // requested information
    PSECURITY_DESCRIPTOR    pSD,            // address of security descriptor
    DWORD                   cbSD,           // size of buffer for security descriptor
    LPDWORD                 lpcbsdRequired  // address of required size of buffer
);

UINT WINAPI
NDdeGetShareSecurityW(
    LPWSTR                  lpszServer,     // server to execute on ( must be NULL )
    LPWSTR                  lpszShareName,  // name of share to delete
    SECURITY_INFORMATION    si,             // requested information
    PSECURITY_DESCRIPTOR    pSD,            // address of security descriptor
    DWORD                   cbSD,           // size of buffer for security descriptor
    LPDWORD                 lpcbsdRequired  // address of required size of buffer
);

/*
    Set Share Security Descriptor
*/

UINT WINAPI
NDdeSetShareSecurityA(
    LPSTR                   lpszServer,     // server to execute on ( must be NULL )
    LPSTR                   lpszShareName,  // name of share to delete
    SECURITY_INFORMATION    si,             // type of information to set
    PSECURITY_DESCRIPTOR    pSD             // address of security descriptor
);

UINT WINAPI
NDdeSetShareSecurityW(
    LPWSTR                  lpszServer,     // server to execute on ( must be NULL )
    LPWSTR                  lpszShareName,  // name of share to delete
    SECURITY_INFORMATION    si,             // type of information to set
    PSECURITY_DESCRIPTOR    pSD             // address of security descriptor
);

/*
    Enumerate shares
*/
UINT WINAPI
NDdeShareEnumA (
    LPSTR   lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
);

UINT WINAPI
NDdeShareEnumW (
    LPWSTR  lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
);

/*
    Get information on a share
*/
UINT WINAPI
NDdeShareGetInfoA (
    LPSTR   lpszServer,         // server to execute on ( must be NULL )
    LPSTR   lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // gets struct containing (NDDESHAREINFO) + data
    DWORD   cBufSize,           // sizeof buffer
    LPDWORD lpnTotalAvailable,  // number of bytes available
    LPWORD  lpnItems            // item mask for partial getinfo (must be 0)
);

UINT WINAPI
NDdeShareGetInfoW (
    LPWSTR  lpszServer,         // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // gets struct containing (NDDESHAREINFO) + data
    DWORD   cBufSize,           // sizeof buffer
    LPDWORD lpnTotalAvailable,  // number of bytes available
    LPWORD  lpnItems            // item mask for partial getinfo (must be 0)
);

/*
    Modify DDE share data
*/
UINT WINAPI
NDdeShareSetInfoA (
    LPSTR   lpszServer,         // server to execute on ( must be NULL )
    LPSTR   lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // points to struct with (NDDESHAREINFO) + data
    DWORD   cBufSize,           // sizeof buffer
    WORD    sParmNum            // Parameter index ( must be 0 - entire )
);

UINT WINAPI
NDdeShareSetInfoW (
    LPWSTR  lpszServer,         // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // points to struct with (NDDESHAREINFO) + data
    DWORD   cBufSize,           // sizeof buffer
    WORD    sParmNum            // Parameter index ( must be 0 - entire )
);

/*
    Set/Create a trusted share
*/

UINT WINAPI
NDdeSetTrustedShareA (
    LPSTR   lpszServer,         // server to execute on ( must be NULL )
    LPSTR   lpszShareName,      // name of share to delete
    DWORD   dwTrustOptions      // trust options to apply
);

UINT WINAPI
NDdeSetTrustedShareW (
    LPWSTR  lpszServer,         // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,      // name of share to delete
    DWORD   dwTrustOptions      // trust options to apply
);

                                            /*  Trusted share options       */
#define NDDE_TRUST_SHARE_START  0x80000000L     // Start App Allowed
#define NDDE_TRUST_SHARE_INIT   0x40000000L     // Init Conv Allowed
#define NDDE_TRUST_SHARE_DEL    0x20000000L     // Delete Trusted Share (on set)
#define NDDE_TRUST_CMD_SHOW     0x10000000L     // Use supplied cmd show
#define NDDE_CMD_SHOW_MASK      0x0000FFFFL     // Command Show mask

/*
    Get a trusted share options
*/

UINT WINAPI
NDdeGetTrustedShareA (
    LPSTR       lpszServer,         // server to execute on ( must be NULL )
    LPSTR       lpszShareName,      // name of share to query
    LPDWORD     lpdwTrustOptions,   // trust options in effect
    LPDWORD     lpdwShareModId0,    // first word of share mod id
    LPDWORD     lpdwShareModId1     // second word of share mod id
);

UINT WINAPI
NDdeGetTrustedShareW (
    LPWSTR      lpszServer,         // server to execute on ( must be NULL )
    LPWSTR      lpszShareName,      // name of share to query
    LPDWORD     lpdwTrustOptions,   // trust options in effect
    LPDWORD     lpdwShareModId0,    // first word of share mod id
    LPDWORD     lpdwShareModId1     // second word of share mod id
);


/*
    Enumerate trusted shares
*/
UINT WINAPI
NDdeTrustedShareEnumA (
    LPSTR   lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
);

UINT WINAPI
NDdeTrustedShareEnumW (
    LPWSTR  lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
);

/*
    Convert error code to string value
*/
UINT WINAPI
NDdeGetErrorStringA (
    UINT    uErrorCode,         // Error code to get string for
    LPSTR   lpszErrorString,    // buffer to hold error string
    DWORD   cBufSize            // sizeof buffer
);

UINT WINAPI
NDdeGetErrorStringW (
    UINT    uErrorCode,         // Error code to get string for
    LPWSTR  lpszErrorString,    // buffer to hold error string
    DWORD   cBufSize            // sizeof buffer
);

/*
    Validate share name format
*/
BOOL WINAPI
NDdeIsValidShareNameA (
    LPSTR shareName
);

BOOL WINAPI
NDdeIsValidShareNameW (
    LPWSTR shareName
);

/*
    Validate application/topic list format
*/
BOOL WINAPI
NDdeIsValidAppTopicListA (
    LPSTR targetTopic
);

BOOL WINAPI
NDdeIsValidAppTopicListW (
    LPWSTR targetTopic
);

#ifdef UNICODE
#define NDdeShareAdd            NDdeShareAddW
#define NDdeShareDel            NDdeShareDelW
#define NDdeSetShareSecurity    NDdeSetShareSecurityW
#define NDdeGetShareSecurity    NDdeGetShareSecurityW
#define NDdeShareEnum           NDdeShareEnumW
#define NDdeShareGetInfo        NDdeShareGetInfoW
#define NDdeShareSetInfo        NDdeShareSetInfoW
#define NDdeGetErrorString      NDdeGetErrorStringW
#define NDdeIsValidShareName    NDdeIsValidShareNameW
#define NDdeIsValidAppTopicList NDdeIsValidAppTopicListW
#define NDdeSetTrustedShare     NDdeSetTrustedShareW
#define NDdeGetTrustedShare     NDdeGetTrustedShareW
#define NDdeTrustedShareEnum    NDdeTrustedShareEnumW
#else
#define NDdeShareAdd            NDdeShareAddA
#define NDdeShareDel            NDdeShareDelA
#define NDdeSetShareSecurity    NDdeSetShareSecurityA
#define NDdeGetShareSecurity    NDdeGetShareSecurityA
#define NDdeShareEnum           NDdeShareEnumA
#define NDdeShareGetInfo        NDdeShareGetInfoA
#define NDdeShareSetInfo        NDdeShareSetInfoA
#define NDdeGetErrorString      NDdeGetErrorStringA
#define NDdeIsValidShareName    NDdeIsValidShareNameA
#define NDdeIsValidAppTopicList NDdeIsValidAppTopicListA
#define NDdeSetTrustedShare     NDdeSetTrustedShareA
#define NDdeGetTrustedShare     NDdeGetTrustedShareA
#define NDdeTrustedShareEnum    NDdeTrustedShareEnumA
#endif

#ifdef __cplusplus
}
#endif    /* __cplusplus */

#include <poppack.h>

#endif  /* _INC_NDDEAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntddmup.h ===
/*++ BUILD Version: 0001    // Increent this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddmup.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Multiple UNC prodiver system device.

Author:

    Manny Weiser (mannyw) 27-Dec-1991

Revision History:

--*/

#ifndef _NTDDMUP_
#define _NTDDMUP_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
//

#define DD_MUP_DEVICE_NAME L"\\Device\\Mup"    // ntifs

//
// NtFsControlFile FsControlCode values for this device.
//

#define FSCTL_MUP_REGISTER_UNC_PROVIDER     CTL_CODE(FILE_DEVICE_MULTI_UNC_PROVIDER, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Fs control parameter blocks.
//

typedef struct _REDIRECTOR_REGISTRATION {
    ULONG DeviceNameOffset;
    ULONG DeviceNameLength;
    ULONG ShortNameOffset;
    ULONG ShortNameLength;
    BOOLEAN MailslotsSupported;
    // PWCH DeviceName[];
    // PWCH ShortName[];
} REDIRECTOR_REGISTRATION, *PREDIRECTOR_REGISTRATION;


//!!! Move to redir
//
// NtDeviceIoControlFile calls to the redirector
//
// begin_ntifs

#define IOCTL_REDIR_QUERY_PATH              CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, 99, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef struct _QUERY_PATH_REQUEST {
    ULONG PathNameLength;
    PIO_SECURITY_CONTEXT SecurityContext;
    WCHAR FilePathName[1];
} QUERY_PATH_REQUEST, *PQUERY_PATH_REQUEST;

typedef struct _QUERY_PATH_RESPONSE {
    ULONG LengthAccepted;
} QUERY_PATH_RESPONSE, *PQUERY_PATH_RESPONSE;

// end_ntifs

#ifdef __cplusplus
}
#endif

#endif  // _NTDDMUP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntddnpfs.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddnpfs.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Named pipe file system device.

Author:

    Steve Wood (stevewo) 27-May-1990

Revision History:

--*/

#ifndef _NTDDNPFS_
#define _NTDDNPFS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_NPFS_DEVICE_NAME "\\Device\\UNKNOWN"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_NPFS_BASE                 FILE_DEVICE_NAMED_PIPE


//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

#ifdef __cplusplus
}
#endif

#endif  // _NTDDNPFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntddnull.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddnull.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Null device.

Author:

    Steve Wood (stevewo) 27-May-1990

Revision History:

--*/

#ifndef _NTDDNULL_
#define _NTDDNULL_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_NULL_DEVICE_NAME "\\Device\\Null"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_NULL_BASE                 FILE_DEVICE_NULL


//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

#ifdef __cplusplus
}
#endif

#endif  // _NTDDNULL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\napmmc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0216 */
/* at Thu Nov 12 15:52:14 1998
 */
/* Compiler settings for napmmc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __napmmc_h__
#define __napmmc_h__

#if _MSC_VER > 1000
#pragma once
#endif

/* Forward Declarations */

#ifndef __IIASAttributeInfo_FWD_DEFINED__
#define __IIASAttributeInfo_FWD_DEFINED__
typedef interface IIASAttributeInfo IIASAttributeInfo;
#endif 	/* __IIASAttributeInfo_FWD_DEFINED__ */


#ifndef __IIASEnumerableAttributeInfo_FWD_DEFINED__
#define __IIASEnumerableAttributeInfo_FWD_DEFINED__
typedef interface IIASEnumerableAttributeInfo IIASEnumerableAttributeInfo;
#endif 	/* __IIASEnumerableAttributeInfo_FWD_DEFINED__ */


#ifndef __IIASAttributeEditor_FWD_DEFINED__
#define __IIASAttributeEditor_FWD_DEFINED__
typedef interface IIASAttributeEditor IIASAttributeEditor;
#endif 	/* __IIASAttributeEditor_FWD_DEFINED__ */


#ifndef __IIASNASVendors_FWD_DEFINED__
#define __IIASNASVendors_FWD_DEFINED__
typedef interface IIASNASVendors IIASNASVendors;
#endif 	/* __IIASNASVendors_FWD_DEFINED__ */


#ifndef __NAPSnapin_FWD_DEFINED__
#define __NAPSnapin_FWD_DEFINED__

#ifdef __cplusplus
typedef class NAPSnapin NAPSnapin;
#else
typedef struct NAPSnapin NAPSnapin;
#endif /* __cplusplus */

#endif 	/* __NAPSnapin_FWD_DEFINED__ */


#ifndef __NAPSnapinAbout_FWD_DEFINED__
#define __NAPSnapinAbout_FWD_DEFINED__

#ifdef __cplusplus
typedef class NAPSnapinAbout NAPSnapinAbout;
#else
typedef struct NAPSnapinAbout NAPSnapinAbout;
#endif /* __cplusplus */

#endif 	/* __NAPSnapinAbout_FWD_DEFINED__ */


#ifndef __LoggingSnapin_FWD_DEFINED__
#define __LoggingSnapin_FWD_DEFINED__

#ifdef __cplusplus
typedef class LoggingSnapin LoggingSnapin;
#else
typedef struct LoggingSnapin LoggingSnapin;
#endif /* __cplusplus */

#endif 	/* __LoggingSnapin_FWD_DEFINED__ */


#ifndef __LoggingSnapinAbout_FWD_DEFINED__
#define __LoggingSnapinAbout_FWD_DEFINED__

#ifdef __cplusplus
typedef class LoggingSnapinAbout LoggingSnapinAbout;
#else
typedef struct LoggingSnapinAbout LoggingSnapinAbout;
#endif /* __cplusplus */

#endif 	/* __LoggingSnapinAbout_FWD_DEFINED__ */


#ifndef __IASAttributeInfo_FWD_DEFINED__
#define __IASAttributeInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class IASAttributeInfo IASAttributeInfo;
#else
typedef struct IASAttributeInfo IASAttributeInfo;
#endif /* __cplusplus */

#endif 	/* __IASAttributeInfo_FWD_DEFINED__ */


#ifndef __IASEnumerableAttributeInfo_FWD_DEFINED__
#define __IASEnumerableAttributeInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class IASEnumerableAttributeInfo IASEnumerableAttributeInfo;
#else
typedef struct IASEnumerableAttributeInfo IASEnumerableAttributeInfo;
#endif /* __cplusplus */

#endif 	/* __IASEnumerableAttributeInfo_FWD_DEFINED__ */


#ifndef __IASIPAttributeEditor_FWD_DEFINED__
#define __IASIPAttributeEditor_FWD_DEFINED__

#ifdef __cplusplus
typedef class IASIPAttributeEditor IASIPAttributeEditor;
#else
typedef struct IASIPAttributeEditor IASIPAttributeEditor;
#endif /* __cplusplus */

#endif 	/* __IASIPAttributeEditor_FWD_DEFINED__ */


#ifndef __IASMultivaluedAttributeEditor_FWD_DEFINED__
#define __IASMultivaluedAttributeEditor_FWD_DEFINED__

#ifdef __cplusplus
typedef class IASMultivaluedAttributeEditor IASMultivaluedAttributeEditor;
#else
typedef struct IASMultivaluedAttributeEditor IASMultivaluedAttributeEditor;
#endif /* __cplusplus */

#endif 	/* __IASMultivaluedAttributeEditor_FWD_DEFINED__ */


#ifndef __IASVendorSpecificAttributeEditor_FWD_DEFINED__
#define __IASVendorSpecificAttributeEditor_FWD_DEFINED__

#ifdef __cplusplus
typedef class IASVendorSpecificAttributeEditor IASVendorSpecificAttributeEditor;
#else
typedef struct IASVendorSpecificAttributeEditor IASVendorSpecificAttributeEditor;
#endif /* __cplusplus */

#endif 	/* __IASVendorSpecificAttributeEditor_FWD_DEFINED__ */


#ifndef __IASEnumerableAttributeEditor_FWD_DEFINED__
#define __IASEnumerableAttributeEditor_FWD_DEFINED__

#ifdef __cplusplus
typedef class IASEnumerableAttributeEditor IASEnumerableAttributeEditor;
#else
typedef struct IASEnumerableAttributeEditor IASEnumerableAttributeEditor;
#endif /* __cplusplus */

#endif 	/* __IASEnumerableAttributeEditor_FWD_DEFINED__ */


#ifndef __IASStringAttributeEditor_FWD_DEFINED__
#define __IASStringAttributeEditor_FWD_DEFINED__

#ifdef __cplusplus
typedef class IASStringAttributeEditor IASStringAttributeEditor;
#else
typedef struct IASStringAttributeEditor IASStringAttributeEditor;
#endif /* __cplusplus */

#endif 	/* __IASStringAttributeEditor_FWD_DEFINED__ */


#ifndef __IASGroupsAttributeEditor_FWD_DEFINED__
#define __IASGroupsAttributeEditor_FWD_DEFINED__

#ifdef __cplusplus
typedef class IASGroupsAttributeEditor IASGroupsAttributeEditor;
#else
typedef struct IASGroupsAttributeEditor IASGroupsAttributeEditor;
#endif /* __cplusplus */

#endif 	/* __IASGroupsAttributeEditor_FWD_DEFINED__ */


#ifndef __IASNASVendors_FWD_DEFINED__
#define __IASNASVendors_FWD_DEFINED__

#ifdef __cplusplus
typedef class IASNASVendors IASNASVendors;
#else
typedef struct IASNASVendors IASNASVendors;
#endif /* __cplusplus */

#endif 	/* __IASNASVendors_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "sdoias.h"

#ifdef __cplusplus
extern "C"{
#endif

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

#ifndef __IIASAttributeInfo_INTERFACE_DEFINED__
#define __IIASAttributeInfo_INTERFACE_DEFINED__

/* interface IIASAttributeInfo */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IIASAttributeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("60F41BE3-06DF-11D2-95AA-0060B0576642")
    IIASAttributeInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AttributeID(
            /* [retval][out] */ ATTRIBUTEID __RPC_FAR *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AttributeID(
            /* [in] */ ATTRIBUTEID newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AttributeName(
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AttributeName(
            /* [in] */ BSTR newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AttributeSyntax(
            /* [retval][out] */ ATTRIBUTESYNTAX __RPC_FAR *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AttributeSyntax(
            /* [in] */ ATTRIBUTESYNTAX newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AttributeRestriction(
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AttributeRestriction(
            /* [in] */ long newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VendorID(
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_VendorID(
            /* [in] */ long newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AttributeDescription(
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AttributeDescription(
            /* [in] */ BSTR newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VendorName(
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_VendorName(
            /* [in] */ BSTR newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SyntaxString(
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SyntaxString(
            /* [in] */ BSTR newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EditorProgID(
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EditorProgID(
            /* [in] */ BSTR newVal) = 0;

    };

#else 	/* C style interface */

    typedef struct IIASAttributeInfoVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IIASAttributeInfo __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IIASAttributeInfo __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AttributeID )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [retval][out] */ ATTRIBUTEID __RPC_FAR *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AttributeID )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [in] */ ATTRIBUTEID newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AttributeName )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AttributeName )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AttributeSyntax )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [retval][out] */ ATTRIBUTESYNTAX __RPC_FAR *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AttributeSyntax )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [in] */ ATTRIBUTESYNTAX newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AttributeRestriction )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AttributeRestriction )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [in] */ long newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VendorID )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_VendorID )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [in] */ long newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AttributeDescription )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AttributeDescription )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VendorName )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_VendorName )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SyntaxString )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SyntaxString )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EditorProgID )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EditorProgID )(
            IIASAttributeInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);

        END_INTERFACE
    } IIASAttributeInfoVtbl;

    interface IIASAttributeInfo
    {
        CONST_VTBL struct IIASAttributeInfoVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IIASAttributeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIASAttributeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIASAttributeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIASAttributeInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IIASAttributeInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IIASAttributeInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IIASAttributeInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IIASAttributeInfo_get_AttributeID(This,pVal)	\
    (This)->lpVtbl -> get_AttributeID(This,pVal)

#define IIASAttributeInfo_put_AttributeID(This,newVal)	\
    (This)->lpVtbl -> put_AttributeID(This,newVal)

#define IIASAttributeInfo_get_AttributeName(This,pVal)	\
    (This)->lpVtbl -> get_AttributeName(This,pVal)

#define IIASAttributeInfo_put_AttributeName(This,newVal)	\
    (This)->lpVtbl -> put_AttributeName(This,newVal)

#define IIASAttributeInfo_get_AttributeSyntax(This,pVal)	\
    (This)->lpVtbl -> get_AttributeSyntax(This,pVal)

#define IIASAttributeInfo_put_AttributeSyntax(This,newVal)	\
    (This)->lpVtbl -> put_AttributeSyntax(This,newVal)

#define IIASAttributeInfo_get_AttributeRestriction(This,pVal)	\
    (This)->lpVtbl -> get_AttributeRestriction(This,pVal)

#define IIASAttributeInfo_put_AttributeRestriction(This,newVal)	\
    (This)->lpVtbl -> put_AttributeRestriction(This,newVal)

#define IIASAttributeInfo_get_VendorID(This,pVal)	\
    (This)->lpVtbl -> get_VendorID(This,pVal)

#define IIASAttributeInfo_put_VendorID(This,newVal)	\
    (This)->lpVtbl -> put_VendorID(This,newVal)

#define IIASAttributeInfo_get_AttributeDescription(This,pVal)	\
    (This)->lpVtbl -> get_AttributeDescription(This,pVal)

#define IIASAttributeInfo_put_AttributeDescription(This,newVal)	\
    (This)->lpVtbl -> put_AttributeDescription(This,newVal)

#define IIASAttributeInfo_get_VendorName(This,pVal)	\
    (This)->lpVtbl -> get_VendorName(This,pVal)

#define IIASAttributeInfo_put_VendorName(This,newVal)	\
    (This)->lpVtbl -> put_VendorName(This,newVal)

#define IIASAttributeInfo_get_SyntaxString(This,pVal)	\
    (This)->lpVtbl -> get_SyntaxString(This,pVal)

#define IIASAttributeInfo_put_SyntaxString(This,newVal)	\
    (This)->lpVtbl -> put_SyntaxString(This,newVal)

#define IIASAttributeInfo_get_EditorProgID(This,pVal)	\
    (This)->lpVtbl -> get_EditorProgID(This,pVal)

#define IIASAttributeInfo_put_EditorProgID(This,newVal)	\
    (This)->lpVtbl -> put_EditorProgID(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_get_AttributeID_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [retval][out] */ ATTRIBUTEID __RPC_FAR *pVal);


void __RPC_STUB IIASAttributeInfo_get_AttributeID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_put_AttributeID_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [in] */ ATTRIBUTEID newVal);


void __RPC_STUB IIASAttributeInfo_put_AttributeID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_get_AttributeName_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IIASAttributeInfo_get_AttributeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_put_AttributeName_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IIASAttributeInfo_put_AttributeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_get_AttributeSyntax_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [retval][out] */ ATTRIBUTESYNTAX __RPC_FAR *pVal);


void __RPC_STUB IIASAttributeInfo_get_AttributeSyntax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_put_AttributeSyntax_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [in] */ ATTRIBUTESYNTAX newVal);


void __RPC_STUB IIASAttributeInfo_put_AttributeSyntax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_get_AttributeRestriction_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IIASAttributeInfo_get_AttributeRestriction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_put_AttributeRestriction_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IIASAttributeInfo_put_AttributeRestriction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_get_VendorID_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IIASAttributeInfo_get_VendorID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_put_VendorID_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IIASAttributeInfo_put_VendorID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_get_AttributeDescription_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IIASAttributeInfo_get_AttributeDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_put_AttributeDescription_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IIASAttributeInfo_put_AttributeDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_get_VendorName_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IIASAttributeInfo_get_VendorName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_put_VendorName_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IIASAttributeInfo_put_VendorName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_get_SyntaxString_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IIASAttributeInfo_get_SyntaxString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_put_SyntaxString_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IIASAttributeInfo_put_SyntaxString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_get_EditorProgID_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IIASAttributeInfo_get_EditorProgID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIASAttributeInfo_put_EditorProgID_Proxy(
    IIASAttributeInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IIASAttributeInfo_put_EditorProgID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIASAttributeInfo_INTERFACE_DEFINED__ */


#ifndef __IIASEnumerableAttributeInfo_INTERFACE_DEFINED__
#define __IIASEnumerableAttributeInfo_INTERFACE_DEFINED__

/* interface IIASEnumerableAttributeInfo */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IIASEnumerableAttributeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("9A407537-0A20-11D2-95B0-0060B0576642")
    IIASEnumerableAttributeInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountEnumerateID(
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnumerateID(
            long index,
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddEnumerateID(
            /* [in] */ long newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountEnumerateDescription(
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnumerateDescription(
            long index,
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddEnumerateDescription(
            /* [in] */ BSTR newVal) = 0;

    };

#else 	/* C style interface */

    typedef struct IIASEnumerableAttributeInfoVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IIASEnumerableAttributeInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IIASEnumerableAttributeInfo __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IIASEnumerableAttributeInfo __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            IIASEnumerableAttributeInfo __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            IIASEnumerableAttributeInfo __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            IIASEnumerableAttributeInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            IIASEnumerableAttributeInfo __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CountEnumerateID )(
            IIASEnumerableAttributeInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnumerateID )(
            IIASEnumerableAttributeInfo __RPC_FAR * This,
            long index,
            /* [retval][out] */ long __RPC_FAR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddEnumerateID )(
            IIASEnumerableAttributeInfo __RPC_FAR * This,
            /* [in] */ long newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CountEnumerateDescription )(
            IIASEnumerableAttributeInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnumerateDescription )(
            IIASEnumerableAttributeInfo __RPC_FAR * This,
            long index,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddEnumerateDescription )(
            IIASEnumerableAttributeInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);

        END_INTERFACE
    } IIASEnumerableAttributeInfoVtbl;

    interface IIASEnumerableAttributeInfo
    {
        CONST_VTBL struct IIASEnumerableAttributeInfoVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IIASEnumerableAttributeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIASEnumerableAttributeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIASEnumerableAttributeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIASEnumerableAttributeInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IIASEnumerableAttributeInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IIASEnumerableAttributeInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IIASEnumerableAttributeInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IIASEnumerableAttributeInfo_get_CountEnumerateID(This,pVal)	\
    (This)->lpVtbl -> get_CountEnumerateID(This,pVal)

#define IIASEnumerableAttributeInfo_get_EnumerateID(This,index,pVal)	\
    (This)->lpVtbl -> get_EnumerateID(This,index,pVal)

#define IIASEnumerableAttributeInfo_AddEnumerateID(This,newVal)	\
    (This)->lpVtbl -> AddEnumerateID(This,newVal)

#define IIASEnumerableAttributeInfo_get_CountEnumerateDescription(This,pVal)	\
    (This)->lpVtbl -> get_CountEnumerateDescription(This,pVal)

#define IIASEnumerableAttributeInfo_get_EnumerateDescription(This,index,pVal)	\
    (This)->lpVtbl -> get_EnumerateDescription(This,index,pVal)

#define IIASEnumerableAttributeInfo_AddEnumerateDescription(This,newVal)	\
    (This)->lpVtbl -> AddEnumerateDescription(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIASEnumerableAttributeInfo_get_CountEnumerateID_Proxy(
    IIASEnumerableAttributeInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IIASEnumerableAttributeInfo_get_CountEnumerateID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIASEnumerableAttributeInfo_get_EnumerateID_Proxy(
    IIASEnumerableAttributeInfo __RPC_FAR * This,
    long index,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IIASEnumerableAttributeInfo_get_EnumerateID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IIASEnumerableAttributeInfo_AddEnumerateID_Proxy(
    IIASEnumerableAttributeInfo __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IIASEnumerableAttributeInfo_AddEnumerateID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIASEnumerableAttributeInfo_get_CountEnumerateDescription_Proxy(
    IIASEnumerableAttributeInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IIASEnumerableAttributeInfo_get_CountEnumerateDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIASEnumerableAttributeInfo_get_EnumerateDescription_Proxy(
    IIASEnumerableAttributeInfo __RPC_FAR * This,
    long index,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IIASEnumerableAttributeInfo_get_EnumerateDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IIASEnumerableAttributeInfo_AddEnumerateDescription_Proxy(
    IIASEnumerableAttributeInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IIASEnumerableAttributeInfo_AddEnumerateDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIASEnumerableAttributeInfo_INTERFACE_DEFINED__ */


#ifndef __IIASAttributeEditor_INTERFACE_DEFINED__
#define __IIASAttributeEditor_INTERFACE_DEFINED__

/* interface IIASAttributeEditor */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IIASAttributeEditor;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("CB2418D2-0709-11D2-95AB-0060B0576642")
    IIASAttributeEditor : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Edit(
            /* [in] */ IIASAttributeInfo __RPC_FAR *pIASAttributeInfo,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [out][in] */ BSTR __RPC_FAR *pReserved) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo(
            /* [in] */ IIASAttributeInfo __RPC_FAR *pIASAttributeInfo,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [out] */ BSTR __RPC_FAR *pVendorName,
            /* [out] */ BSTR __RPC_FAR *pValueAsString,
            /* [out][in] */ BSTR __RPC_FAR *pReserved) = 0;

    };

#else 	/* C style interface */

    typedef struct IIASAttributeEditorVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IIASAttributeEditor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IIASAttributeEditor __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IIASAttributeEditor __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            IIASAttributeEditor __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            IIASAttributeEditor __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            IIASAttributeEditor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            IIASAttributeEditor __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Edit )(
            IIASAttributeEditor __RPC_FAR * This,
            /* [in] */ IIASAttributeInfo __RPC_FAR *pIASAttributeInfo,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [out][in] */ BSTR __RPC_FAR *pReserved);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayInfo )(
            IIASAttributeEditor __RPC_FAR * This,
            /* [in] */ IIASAttributeInfo __RPC_FAR *pIASAttributeInfo,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [out] */ BSTR __RPC_FAR *pVendorName,
            /* [out] */ BSTR __RPC_FAR *pValueAsString,
            /* [out][in] */ BSTR __RPC_FAR *pReserved);

        END_INTERFACE
    } IIASAttributeEditorVtbl;

    interface IIASAttributeEditor
    {
        CONST_VTBL struct IIASAttributeEditorVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IIASAttributeEditor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIASAttributeEditor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIASAttributeEditor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIASAttributeEditor_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IIASAttributeEditor_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IIASAttributeEditor_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IIASAttributeEditor_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IIASAttributeEditor_Edit(This,pIASAttributeInfo,pVal,pReserved)	\
    (This)->lpVtbl -> Edit(This,pIASAttributeInfo,pVal,pReserved)

#define IIASAttributeEditor_GetDisplayInfo(This,pIASAttributeInfo,pVal,pVendorName,pValueAsString,pReserved)	\
    (This)->lpVtbl -> GetDisplayInfo(This,pIASAttributeInfo,pVal,pVendorName,pValueAsString,pReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IIASAttributeEditor_Edit_Proxy(
    IIASAttributeEditor __RPC_FAR * This,
    /* [in] */ IIASAttributeInfo __RPC_FAR *pIASAttributeInfo,
    /* [in] */ VARIANT __RPC_FAR *pVal,
    /* [out][in] */ BSTR __RPC_FAR *pReserved);


void __RPC_STUB IIASAttributeEditor_Edit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IIASAttributeEditor_GetDisplayInfo_Proxy(
    IIASAttributeEditor __RPC_FAR * This,
    /* [in] */ IIASAttributeInfo __RPC_FAR *pIASAttributeInfo,
    /* [in] */ VARIANT __RPC_FAR *pVal,
    /* [out] */ BSTR __RPC_FAR *pVendorName,
    /* [out] */ BSTR __RPC_FAR *pValueAsString,
    /* [out][in] */ BSTR __RPC_FAR *pReserved);


void __RPC_STUB IIASAttributeEditor_GetDisplayInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIASAttributeEditor_INTERFACE_DEFINED__ */


#ifndef __IIASNASVendors_INTERFACE_DEFINED__
#define __IIASNASVendors_INTERFACE_DEFINED__

/* interface IIASNASVendors */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IIASNASVendors;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C54EC3BA-7442-11d2-A036-0060B0576642")
    IIASNASVendors : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitFromSdo( 
            /* [in] */ ISdoCollection __RPC_FAR *pSdoVendorsCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VendorName( 
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR __RPC_FAR *pVendorName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VendorID( 
            /* [in] */ long lIndex,
            /* [retval][out] */ long __RPC_FAR *pVendorID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VendorIDToOrdinal( 
            /* [in] */ long lVendorID,
            /* [retval][out] */ long __RPC_FAR *plIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIASNASVendorsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IIASNASVendors __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IIASNASVendors __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IIASNASVendors __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IIASNASVendors __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IIASNASVendors __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IIASNASVendors __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IIASNASVendors __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitFromSdo )( 
            IIASNASVendors __RPC_FAR * This,
            /* [in] */ ISdoCollection __RPC_FAR *pSdoVendorsCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Size )( 
            IIASNASVendors __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VendorName )( 
            IIASNASVendors __RPC_FAR * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR __RPC_FAR *pVendorName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VendorID )( 
            IIASNASVendors __RPC_FAR * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ long __RPC_FAR *pVendorID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VendorIDToOrdinal )( 
            IIASNASVendors __RPC_FAR * This,
            /* [in] */ long lVendorID,
            /* [retval][out] */ long __RPC_FAR *plIndex);
        
        END_INTERFACE
    } IIASNASVendorsVtbl;

    interface IIASNASVendors
    {
        CONST_VTBL struct IIASNASVendorsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIASNASVendors_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIASNASVendors_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIASNASVendors_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIASNASVendors_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IIASNASVendors_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IIASNASVendors_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IIASNASVendors_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IIASNASVendors_InitFromSdo(This,pSdoVendorsCollection)	\
    (This)->lpVtbl -> InitFromSdo(This,pSdoVendorsCollection)

#define IIASNASVendors_get_Size(This,plCount)	\
    (This)->lpVtbl -> get_Size(This,plCount)

#define IIASNASVendors_get_VendorName(This,lIndex,pVendorName)	\
    (This)->lpVtbl -> get_VendorName(This,lIndex,pVendorName)

#define IIASNASVendors_get_VendorID(This,lIndex,pVendorID)	\
    (This)->lpVtbl -> get_VendorID(This,lIndex,pVendorID)

#define IIASNASVendors_get_VendorIDToOrdinal(This,lVendorID,plIndex)	\
    (This)->lpVtbl -> get_VendorIDToOrdinal(This,lVendorID,plIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IIASNASVendors_InitFromSdo_Proxy( 
    IIASNASVendors __RPC_FAR * This,
    /* [in] */ ISdoCollection __RPC_FAR *pSdoVendorsCollection);


void __RPC_STUB IIASNASVendors_InitFromSdo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIASNASVendors_get_Size_Proxy( 
    IIASNASVendors __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB IIASNASVendors_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIASNASVendors_get_VendorName_Proxy( 
    IIASNASVendors __RPC_FAR * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ BSTR __RPC_FAR *pVendorName);


void __RPC_STUB IIASNASVendors_get_VendorName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIASNASVendors_get_VendorID_Proxy( 
    IIASNASVendors __RPC_FAR * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ long __RPC_FAR *pVendorID);


void __RPC_STUB IIASNASVendors_get_VendorID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IIASNASVendors_get_VendorIDToOrdinal_Proxy( 
    IIASNASVendors __RPC_FAR * This,
    /* [in] */ long lVendorID,
    /* [retval][out] */ long __RPC_FAR *plIndex);


void __RPC_STUB IIASNASVendors_get_VendorIDToOrdinal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIASNASVendors_INTERFACE_DEFINED__ */



#ifndef __NAPMMCLib_LIBRARY_DEFINED__
#define __NAPMMCLib_LIBRARY_DEFINED__

/* library NAPMMCLib */
/* [helpstring][version][uuid] */


EXTERN_C const IID LIBID_NAPMMCLib;

EXTERN_C const CLSID CLSID_NAPSnapin;

#ifdef __cplusplus

class DECLSPEC_UUID("5880CD5C-8EC0-11d1-9570-0060B0576642")
NAPSnapin;
#endif

EXTERN_C const CLSID CLSID_NAPSnapinAbout;

#ifdef __cplusplus

class DECLSPEC_UUID("5880CD5D-8EC0-11d1-9570-0060B0576642")
NAPSnapinAbout;
#endif

EXTERN_C const CLSID CLSID_LoggingSnapin;

#ifdef __cplusplus

class DECLSPEC_UUID("2E19B602-48EB-11d2-83CA-00104BCA42CF")
LoggingSnapin;
#endif

EXTERN_C const CLSID CLSID_LoggingSnapinAbout;

#ifdef __cplusplus

class DECLSPEC_UUID("2E19B603-48EB-11d2-83CA-00104BCA42CF")
LoggingSnapinAbout;
#endif

EXTERN_C const CLSID CLSID_IASAttributeInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("60F41BE4-06DF-11D2-95AA-0060B0576642")
IASAttributeInfo;
#endif

EXTERN_C const CLSID CLSID_IASEnumerableAttributeInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("9A407538-0A20-11D2-95B0-0060B0576642")
IASEnumerableAttributeInfo;
#endif

EXTERN_C const CLSID CLSID_IASIPAttributeEditor;

#ifdef __cplusplus

class DECLSPEC_UUID("CB2418D3-0709-11D2-95AB-0060B0576642")
IASIPAttributeEditor;
#endif

EXTERN_C const CLSID CLSID_IASMultivaluedAttributeEditor;

#ifdef __cplusplus

class DECLSPEC_UUID("B3B443EF-0728-11D2-95AC-0060B0576642")
IASMultivaluedAttributeEditor;
#endif

EXTERN_C const CLSID CLSID_IASVendorSpecificAttributeEditor;

#ifdef __cplusplus

class DECLSPEC_UUID("D601D57D-085B-11D2-95AF-0060B0576642")
IASVendorSpecificAttributeEditor;
#endif

EXTERN_C const CLSID CLSID_IASEnumerableAttributeEditor;

#ifdef __cplusplus

class DECLSPEC_UUID("5F7B221A-086B-11D2-95AF-0060B0576642")
IASEnumerableAttributeEditor;
#endif

EXTERN_C const CLSID CLSID_IASStringAttributeEditor;

#ifdef __cplusplus

class DECLSPEC_UUID("1ABAAF84-086F-11D2-95AF-0060B0576642")
IASStringAttributeEditor;
#endif

EXTERN_C const CLSID CLSID_IASGroupsAttributeEditor;

#ifdef __cplusplus

class DECLSPEC_UUID("A9E6F356-317C-11d2-805D-0060B0576642")
IASGroupsAttributeEditor;
#endif

EXTERN_C const CLSID CLSID_IASNASVendors;

#ifdef __cplusplus

class DECLSPEC_UUID("C54EC3BB-7442-11d2-A036-0060B0576642")
IASNASVendors;
#endif
#endif /* __NAPMMCLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * );
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * );

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * );
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntddsnd.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddsnd.h

Abstract:

    This is the include file that defines all the common
    constants and types for sound devices.

Author:

    Nigel Thompson (NigelT) 17-May-91

Revision History:

--*/

#ifndef _NTDDSND_
#define _NTDDSND_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Define the IOCTL base values for sound devices and each class
// of sound device
//

#define IOCTL_SOUND_BASE                  FILE_DEVICE_SOUND
#define IOCTL_WAVE_BASE 0x0000
#define IOCTL_MIDI_BASE 0x0080

//
// Define some useful limits
//

#define SOUND_MAX_DEVICE_NAME 80    // BUGBUG this is a wild guess
#define SOUND_MAX_DEVICES     100   // Max no of devices of a given type

#ifdef __cplusplus
}
#endif

#endif // _NTDDSND_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntddrdr.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    ntddrdr.h

Abstract:

    This is the include file that defines all constants and types for
    accessing a network redirector device.

Author:

    Manny Weiser (mannyw)     27-Jun-1993

Revision History:

--*/

#ifndef _NTDDRDR_
#define _NTDDRDR_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define RDR_SERVER_LENGTH   80
#define RDR_QUEUE_LENGTH    80

//
// NtDeviceIoControlFile/NtFsControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//
//
//      Method = 00 - Buffer both input and output buffers for the request
//      Method = 01 - Buffer input, map output buffer to an MDL as an IN buff
//      Method = 10 - Buffer input, map output buffer to an MDL as an OUT buff
//      Method = 11 - Do not buffer either the input or output
//

#define IOCTL_REDIR_BASE                 FILE_DEVICE_NETWORK_REDIRECTOR

#define _REDIR_CONTROL_CODE(request, method, access) \
                CTL_CODE(IOCTL_REDIR_BASE, request, method, access)

#define FSCTL_GET_PRINT_ID           _REDIR_CONTROL_CODE(1, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _QUERY_PRINT_JOB_INFO {
    ULONG       JobId;                           // Print job ID
    WCHAR       ServerName[RDR_SERVER_LENGTH+1]; // Server name
    WCHAR       QueueName[RDR_QUEUE_LENGTH+1];   // Queue name.
} QUERY_PRINT_JOB_INFO, *PQUERY_PRINT_JOB_INFO;

#ifdef __cplusplus
}
#endif

#endif  // ifndef _NTDDRDR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntddstrm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    ntddstrm.h

Abstract:

    This header file defines constants and types for accessing the NT
    STREAMS environment.

    Include the STREAMS header file, <sys/stropts.h>, before this !!

Author:

    Eric Chin (ericc)    July 2, 1991

Revision History:

--*/

#ifndef _NTDDSTRM_
#define _NTDDSTRM_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
#define DD_STREAMS_DEVICE_NAME              "\\Device\\Streams"


//
// EA to be used when opening a STREAMS driver for putmsg()/getmsg().
//
#define NormalStreamEA                      "NormalStream"
#define NORMAL_STREAM_EA_LENGTH             (sizeof(NormalStreamEA) - 1)


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
#define _STRM_CTRL_CODE(function, method, access) \
                CTL_CODE(FILE_DEVICE_STREAMS, function, method, access)


#define IOCTL_STREAMS_GETMSG        _STRM_CTRL_CODE( 0, METHOD_BUFFERED, \
                                                        FILE_READ_ACCESS)

#define IOCTL_STREAMS_IOCTL         _STRM_CTRL_CODE( 1, METHOD_BUFFERED, \
                                                        FILE_ANY_ACCESS)

#define IOCTL_STREAMS_POLL          _STRM_CTRL_CODE( 2, METHOD_BUFFERED, \
                                                        FILE_ANY_ACCESS)

#define IOCTL_STREAMS_PUTMSG        _STRM_CTRL_CODE( 3, METHOD_BUFFERED, \
                                                        FILE_WRITE_ACCESS)

#define IOCTL_STREAMS_TDI_TEST      _STRM_CTRL_CODE(32, METHOD_BUFFERED, \
                                                        FILE_ANY_ACCESS)



struct queue;                               // forward declaration for ANSI C

/*
 * General buffer structure (putmsg, getmsg, etc)
 */

struct strbuf {
        int     maxlen;                 /* no. of bytes in buffer */
        int     len;                    /* no. of bytes returned */
        char    *buf;                   /* pointer to data */
};

/*
 * General ioctl
 */

struct strioctl {
	int 	ic_cmd;			/* command */
	int	ic_timout;		/* timeout value */
	int	ic_len;			/* length of data */
	char	*ic_dp;			/* pointer to data */
};


//
// NtDeviceIoControlFile InputBuffer/OutputBuffer Record Structures
//
//
typedef struct _GETMSG_ARGS_INOUT_ {        // getmsg()
    int                     a_retval;       //  return value
    long                    a_flags;        //  0 or RS_HIPRI
    struct strbuf           a_ctlbuf;       //  (required)
    struct strbuf           a_databuf;      //  (required)
    char                    a_stuff[1];     //  a_ctlbuf.buf  (optional)
                                            //  a_databuf.buf (optional)
} GETMSG_ARGS_INOUT, *PGETMSG_ARGS_INOUT;


typedef struct _ISTR_ARGS_INOUT {           // ioctl(I_STR)
    int                     a_iocode;       //  I_STR, retval on return
    struct strioctl         a_strio;        //  (required)
    int                     a_unused[2];    //  (required)
    char                    a_stuff[1];     //  (optional)

} ISTR_ARGS_INOUT, *PISTR_ARGS_INOUT;


typedef struct _PUTMSG_ARGS_IN_ {           // ioctl(I_FDINSERT) and putmsg()
    int                     a_iocode;       //  I_FDINSERT or 0
    long                    a_flags;        //  0 or RS_HIPRI
    struct strbuf           a_ctlbuf;       //  (required)
    struct strbuf           a_databuf;      //  (required)

    union {                                 //  used only for I_FDINSERT
        HANDLE              i_fildes;       //      (optional)
        struct queue *      i_targetq;      //      for Stream Head Driver use
    } a_insert;

    int                     a_offset;       //  (optional)
    char                    a_stuff[1];     //  a_ctlbuf.buf  (optional)
                                            //  a_databuf.buf (optional)
} PUTMSG_ARGS_IN, *PPUTMSG_ARGS_IN;


typedef struct _STRM_ARGS_OUT_ {            // generic return parameters
    int     a_retval;                       //  return value
    int     a_errno;                        //  errno if retval == -1

} STRM_ARGS_OUT, *PSTRM_ARGS_OUT;


#ifdef __cplusplus
}
#endif

#endif  // ifndef _NTDDSTRM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntddtdi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddtdi.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Transport driver interface device.

Author:

    Steve Wood (stevewo) 27-May-1990

Revision History:

    Dave Beaver (dbeaver) 5 June 1991
     add support for TDI version 2.0 -- associate_address,
                                        disassociate_address

--*/

#ifndef _NTDDTDI_
#define _NTDDTDI_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_TDI_DEVICE_NAME "\\Device\\UNKNOWN"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define _TDI_CONTROL_CODE(request,method) \
            CTL_CODE(FILE_DEVICE_TRANSPORT, request, method, FILE_ANY_ACCESS)

#define IOCTL_TDI_ACCEPT                _TDI_CONTROL_CODE( 0, METHOD_BUFFERED )
#define IOCTL_TDI_CONNECT               _TDI_CONTROL_CODE( 1, METHOD_BUFFERED )
#define IOCTL_TDI_DISCONNECT            _TDI_CONTROL_CODE( 2, METHOD_BUFFERED )
#define IOCTL_TDI_LISTEN                _TDI_CONTROL_CODE( 3, METHOD_BUFFERED )
#define IOCTL_TDI_QUERY_INFORMATION     _TDI_CONTROL_CODE( 4, METHOD_OUT_DIRECT )
#define IOCTL_TDI_RECEIVE               _TDI_CONTROL_CODE( 5, METHOD_OUT_DIRECT )
#define IOCTL_TDI_RECEIVE_DATAGRAM      _TDI_CONTROL_CODE( 6, METHOD_OUT_DIRECT )
#define IOCTL_TDI_SEND                  _TDI_CONTROL_CODE( 7, METHOD_IN_DIRECT )
#define IOCTL_TDI_SEND_DATAGRAM         _TDI_CONTROL_CODE( 8, METHOD_IN_DIRECT )
#define IOCTL_TDI_SET_EVENT_HANDLER     _TDI_CONTROL_CODE( 9, METHOD_BUFFERED )
#define IOCTL_TDI_SET_INFORMATION       _TDI_CONTROL_CODE( 10, METHOD_IN_DIRECT )
#define IOCTL_TDI_ASSOCIATE_ADDRESS     _TDI_CONTROL_CODE( 11, METHOD_BUFFERED )
#define IOCTL_TDI_DISASSOCIATE_ADDRESS  _TDI_CONTROL_CODE( 12, METHOD_BUFFERED )
#define IOCTL_TDI_ACTION                _TDI_CONTROL_CODE( 13, METHOD_OUT_DIRECT )

#ifdef __cplusplus
}
#endif

#endif // ndef _NTDDTDI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntddtime.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    ntddtime.h

Abstract:

    This include file defines all constants and types for
    accessing an NT wave device.

Author:

    Robin Speed (RobinSp) 30-Jan-92

Revision History:

--*/

#ifndef _NTDDTIME_
#define _NTDDTIME_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define FILE_DEVICE_TIME 0x00000026


//
// Timer IOCTLs
//

#define IOCTL_TIMER_SET_TIMER_EVENT   CTL_CODE(FILE_DEVICE_TIME, FILE_DEVICE_TIME + 0x0001, METHOD_BUFFERED, FILE_WRITE_DATA)
#define IOCTL_TIMER_GET_TIME          CTL_CODE(FILE_DEVICE_TIME, FILE_DEVICE_TIME + 0x0002, METHOD_NEITHER, FILE_WRITE_DATA)
#define IOCTL_TIMER_GET_DEV_CAPS      CTL_CODE(FILE_DEVICE_TIME, FILE_DEVICE_TIME + 0x0003, METHOD_BUFFERED, FILE_WRITE_DATA)
#define IOCTL_TIMER_BEGIN_MIN_PERIOD  CTL_CODE(FILE_DEVICE_TIME, FILE_DEVICE_TIME + 0x0004, METHOD_NEITHER, FILE_WRITE_DATA)
#define IOCTL_TIMER_END_MIN_PERIOD    CTL_CODE(FILE_DEVICE_TIME, FILE_DEVICE_TIME + 0x0005, METHOD_BUFFERED, FILE_WRITE_DATA)
#define IOCTL_TIMER_RESET             CTL_CODE(FILE_DEVICE_TIME, FILE_DEVICE_TIME + 0x0006, METHOD_BUFFERED, FILE_WRITE_DATA)
#define IOCTL_TIMER_RESET_EVENT       CTL_CODE(FILE_DEVICE_TIME, FILE_DEVICE_TIME + 0x0007, METHOD_NEITHER, FILE_WRITE_DATA)

#define DD_TIMER_DEVICE_NAME_U     L"\\Device\\Timer"

#define IO_TIMER_INCREMENT 8

typedef struct {
    ULONG EventTime;                      // Time in ms for event
    ULONG EventId;                        // Id (cannot be 0)
    LARGE_INTEGER EventTicks;             // Driver use (not seen by caller)
} TIMER_DD_SET_EVENT, *PTIMER_DD_SET_EVENT;

#ifdef __cplusplus
}
#endif

#endif  // _NTDDTIME_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntconfig.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    ntconfig.h

Abstract:

    This module contains the definitions associated with the conventions
    used to access the configuration registry.

Author:

    Andre Vachon (andreva) 17-Apr-1992

Revision History:

    28-Apr-1992 JohnRo
        Made changes to be consistent with win32 service controller APIs.
--*/

#ifndef _NTCONFIG_
#define _NTCONFIG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

// begin_ntddk begin_wdm begin_nthal
// begin_winnt
//
// Predefined Value Types.
//

#define REG_NONE                    ( 0 )   // No value type
#define REG_SZ                      ( 1 )   // Unicode nul terminated string
#define REG_EXPAND_SZ               ( 2 )   // Unicode nul terminated string
                                            // (with environment variable references)
#define REG_BINARY                  ( 3 )   // Free form binary
#define REG_DWORD                   ( 4 )   // 32-bit number
#define REG_DWORD_LITTLE_ENDIAN     ( 4 )   // 32-bit number (same as REG_DWORD)
#define REG_DWORD_BIG_ENDIAN        ( 5 )   // 32-bit number
#define REG_LINK                    ( 6 )   // Symbolic Link (unicode)
#define REG_MULTI_SZ                ( 7 )   // Multiple Unicode strings
#define REG_RESOURCE_LIST           ( 8 )   // Resource list in the resource map
#define REG_FULL_RESOURCE_DESCRIPTOR ( 9 )  // Resource list in the hardware description
#define REG_RESOURCE_REQUIREMENTS_LIST ( 10 )
#define REG_QWORD                   ( 11 )  // 64-bit number
#define REG_QWORD_LITTLE_ENDIAN     ( 11 )  // 64-bit number (same as REG_QWORD)

// end_ntddk end_wdm end_nthal

// begin_ntddk begin_wdm begin_nthal
//
// Service Types (Bit Mask)
//
#define SERVICE_KERNEL_DRIVER          0x00000001
#define SERVICE_FILE_SYSTEM_DRIVER     0x00000002
#define SERVICE_ADAPTER                0x00000004
#define SERVICE_RECOGNIZER_DRIVER      0x00000008

#define SERVICE_DRIVER                 (SERVICE_KERNEL_DRIVER | \
                                        SERVICE_FILE_SYSTEM_DRIVER | \
                                        SERVICE_RECOGNIZER_DRIVER)

#define SERVICE_WIN32_OWN_PROCESS      0x00000010
#define SERVICE_WIN32_SHARE_PROCESS    0x00000020
#define SERVICE_WIN32                  (SERVICE_WIN32_OWN_PROCESS | \
                                        SERVICE_WIN32_SHARE_PROCESS)

#define SERVICE_INTERACTIVE_PROCESS    0x00000100

#define SERVICE_TYPE_ALL               (SERVICE_WIN32  | \
                                        SERVICE_ADAPTER | \
                                        SERVICE_DRIVER  | \
                                        SERVICE_INTERACTIVE_PROCESS)

//
// Start Type
//

#define SERVICE_BOOT_START             0x00000000
#define SERVICE_SYSTEM_START           0x00000001
#define SERVICE_AUTO_START             0x00000002
#define SERVICE_DEMAND_START           0x00000003
#define SERVICE_DISABLED               0x00000004

//
// Error control type
//
#define SERVICE_ERROR_IGNORE           0x00000000
#define SERVICE_ERROR_NORMAL           0x00000001
#define SERVICE_ERROR_SEVERE           0x00000002
#define SERVICE_ERROR_CRITICAL         0x00000003

//
//
// Define the registry driver node enumerations
//

typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType               = SERVICE_KERNEL_DRIVER,
    FileSystemType           = SERVICE_FILE_SYSTEM_DRIVER,
    Win32ServiceOwnProcess   = SERVICE_WIN32_OWN_PROCESS,
    Win32ServiceShareProcess = SERVICE_WIN32_SHARE_PROCESS,
    AdapterType              = SERVICE_ADAPTER,
    RecognizerType           = SERVICE_RECOGNIZER_DRIVER
} SERVICE_NODE_TYPE;

typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad    = SERVICE_BOOT_START,
    SystemLoad  = SERVICE_SYSTEM_START,
    AutoLoad    = SERVICE_AUTO_START,
    DemandLoad  = SERVICE_DEMAND_START,
    DisableLoad = SERVICE_DISABLED
} SERVICE_LOAD_TYPE;

typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError   = SERVICE_ERROR_IGNORE,
    NormalError   = SERVICE_ERROR_NORMAL,
    SevereError   = SERVICE_ERROR_SEVERE,
    CriticalError = SERVICE_ERROR_CRITICAL
} SERVICE_ERROR_TYPE;

// end_winnt
// end_ntddk end_wdm end_nthal

// begin_ntddk begin_wdm begin_nthal

//
// Resource List definitions
//

// begin_ntminiport begin_ntndis

//
// Defines the Type in the RESOURCE_DESCRIPTOR
//
// NOTE:  For all CM_RESOURCE_TYPE values, there must be a
// corresponding ResType value in the 32-bit ConfigMgr headerfile
// (cfgmgr32.h).  Values in the range [0x6,0x80) use the same values
// as their ConfigMgr counterparts.  CM_RESOURCE_TYPE values with
// the high bit set (i.e., in the range [0x80,0xFF]), are
// non-arbitrated resources.  These correspond to the same values
// in cfgmgr32.h that have their high bit set (however, since
// cfgmgr32.h uses 16 bits for ResType values, these values are in
// the range [0x8000,0x807F).  Note that ConfigMgr ResType values
// cannot be in the range [0x8080,0xFFFF), because they would not
// be able to map into CM_RESOURCE_TYPE values.  (0xFFFF itself is
// a special value, because it maps to CmResourceTypeDeviceSpecific.)
//

typedef int CM_RESOURCE_TYPE;

// CmResourceTypeNull is reserved

#define CmResourceTypeNull                0   // ResType_All or ResType_None (0x0000)
#define CmResourceTypePort                1   // ResType_IO (0x0002)
#define CmResourceTypeInterrupt           2   // ResType_IRQ (0x0004)
#define CmResourceTypeMemory              3   // ResType_Mem (0x0001)
#define CmResourceTypeDma                 4   // ResType_DMA (0x0003)
#define CmResourceTypeDeviceSpecific      5   // ResType_ClassSpecific (0xFFFF)
#define CmResourceTypeBusNumber           6   // ResType_BusNumber (0x0006)
// end_wdm
#define CmResourceTypeMaximum             7
// begin_wdm
#define CmResourceTypeNonArbitrated     128   // Not arbitrated if 0x80 bit set
#define CmResourceTypeConfigData        128   // ResType_Reserved (0x8000)
#define CmResourceTypeDevicePrivate     129   // ResType_DevicePrivate (0x8001)
#define CmResourceTypePcCardConfig      130   // ResType_PcCardConfig (0x8002)
#define CmResourceTypeMfCardConfig      131   // ResType_MfCardConfig (0x8003)

//
// Defines the ShareDisposition in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,    // Reserved
    CmResourceShareDeviceExclusive,
    CmResourceShareDriverExclusive,
    CmResourceShareShared
} CM_SHARE_DISPOSITION;

//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

#define CM_RESOURCE_MEMORY_COMBINEDWRITE    0x0008
#define CM_RESOURCE_MEMORY_24               0x0010
#define CM_RESOURCE_MEMORY_CACHEABLE        0x0020

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

#define CM_RESOURCE_PORT_MEMORY                             0x0000
#define CM_RESOURCE_PORT_IO                                 0x0001
#define CM_RESOURCE_PORT_10_BIT_DECODE                      0x0004
#define CM_RESOURCE_PORT_12_BIT_DECODE                      0x0008
#define CM_RESOURCE_PORT_16_BIT_DECODE                      0x0010
#define CM_RESOURCE_PORT_POSITIVE_DECODE                    0x0020
#define CM_RESOURCE_PORT_PASSIVE_DECODE                     0x0040
#define CM_RESOURCE_PORT_WINDOW_DECODE                      0x0080

//
// Define the bit masks for Flags when type is CmResourceTypeDma
//

#define CM_RESOURCE_DMA_8                   0x0000
#define CM_RESOURCE_DMA_16                  0x0001
#define CM_RESOURCE_DMA_32                  0x0002
#define CM_RESOURCE_DMA_8_AND_16            0x0004
#define CM_RESOURCE_DMA_BUS_MASTER          0x0008
#define CM_RESOURCE_DMA_TYPE_A              0x0010
#define CM_RESOURCE_DMA_TYPE_B              0x0020
#define CM_RESOURCE_DMA_TYPE_F              0x0040

// end_ntminiport end_ntndis

//
// This structure defines one type of resource used by a driver.
//
// There can only be *1* DeviceSpecificData block. It must be located at
// the end of all resource descriptors in a full descriptor block.
//

//
// Make sure alignment is made properly by compiler; otherwise move
// flags back to the top of the structure (common to all members of the
// union).
//
// begin_ntndis

#include "pshpack4.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    UCHAR Type;
    UCHAR ShareDisposition;
    USHORT Flags;
    union {

        //
        // Range of resources, inclusive.  These are physical, bus relative.
        // It is known that Port and Memory below have the exact same layout
        // as Generic.
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Generic;

        //
        // end_wdm
        // Range of port numbers, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        // begin_wdm
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Port;

        //
        // end_wdm
        // IRQL and vector. Should be same values as were passed to
        // HalGetInterruptVector().
        // begin_wdm
        //

        struct {
            ULONG Level;
            ULONG Vector;
            KAFFINITY Affinity;
        } Interrupt;

        //
        // Range of memory addresses, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;    // 64 bit physical addresses.
            ULONG Length;
        } Memory;

        //
        // Physical DMA channel.
        //

        struct {
            ULONG Channel;
            ULONG Port;
            ULONG Reserved1;
        } Dma;

        //
        // Device driver private data, usually used to help it figure
        // what the resource assignments decisions that were made.
        //

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Start;
            ULONG Length;
            ULONG Reserved;
        } BusNumber;

        //
        // Device Specific information defined by the driver.
        // The DataSize field indicates the size of the data in bytes. The
        // data is located immediately after the DeviceSpecificData field in
        // the structure.
        //

        struct {
            ULONG DataSize;
            ULONG Reserved1;
            ULONG Reserved2;
        } DeviceSpecificData;
    } u;
} CM_PARTIAL_RESOURCE_DESCRIPTOR, *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#include "poppack.h"

//
// A Partial Resource List is what can be found in the ARC firmware
// or will be generated by ntdetect.com.
// The configuration manager will transform this structure into a Full
// resource descriptor when it is about to store it in the regsitry.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_PARTIAL_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;
    ULONG Count;
    CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
} CM_PARTIAL_RESOURCE_LIST, *PCM_PARTIAL_RESOURCE_LIST;

//
// A Full Resource Descriptor is what can be found in the registry.
// This is what will be returned to a driver when it queries the registry
// to get device information; it will be stored under a key in the hardware
// description tree.
//
// end_wdm
// Note: The BusNumber and Type are redundant information, but we will keep
// it since it allows the driver _not_ to append it when it is creating
// a resource list which could possibly span multiple buses.
//
// begin_wdm
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
    INTERFACE_TYPE InterfaceType; // unused for WDM
    ULONG BusNumber; // unused for WDM
    CM_PARTIAL_RESOURCE_LIST PartialResourceList;
} CM_FULL_RESOURCE_DESCRIPTOR, *PCM_FULL_RESOURCE_DESCRIPTOR;

//
// The Resource list is what will be stored by the drivers into the
// resource map via the IO API.
//

typedef struct _CM_RESOURCE_LIST {
    ULONG Count;
    CM_FULL_RESOURCE_DESCRIPTOR List[1];
} CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;

// end_ntndis
//
// Define the structures used to interpret configuration data of
// \\Registry\machine\hardware\description tree.
// Basically, these structures are used to interpret component
// sepcific data.
//

//
// Define DEVICE_FLAGS
//

typedef struct _DEVICE_FLAGS {
    ULONG Failed : 1;
    ULONG ReadOnly : 1;
    ULONG Removable : 1;
    ULONG ConsoleIn : 1;
    ULONG ConsoleOut : 1;
    ULONG Input : 1;
    ULONG Output : 1;
} DEVICE_FLAGS, *PDEVICE_FLAGS;

//
// Define Component Information structure
//

typedef struct _CM_COMPONENT_INFORMATION {
    DEVICE_FLAGS Flags;
    ULONG Version;
    ULONG Key;
    KAFFINITY AffinityMask;
} CM_COMPONENT_INFORMATION, *PCM_COMPONENT_INFORMATION;

// end_ntddk end_wdm end_nthal

// begin_ntddk begin_wdm begin_nthal
//
// The following structures are used to interpret x86
// DeviceSpecificData of CM_PARTIAL_RESOURCE_DESCRIPTOR.
// (Most of the structures are defined by BIOS.  They are
// not aligned on word (or dword) boundary.
//

//
// Define the Rom Block structure
//

typedef struct _CM_ROM_BLOCK {
    ULONG Address;
    ULONG Size;
} CM_ROM_BLOCK, *PCM_ROM_BLOCK;

// begin_ntminiport begin_ntndis

#include "pshpack1.h"

// end_ntminiport end_ntndis

//
// Define INT13 driver parameter block
//

typedef struct _CM_INT13_DRIVE_PARAMETER {
    USHORT DriveSelect;
    ULONG MaxCylinders;
    USHORT SectorsPerTrack;
    USHORT MaxHeads;
    USHORT NumberDrives;
} CM_INT13_DRIVE_PARAMETER, *PCM_INT13_DRIVE_PARAMETER;

// begin_ntminiport begin_ntndis

//
// Define Mca POS data block for slot
//

typedef struct _CM_MCA_POS_DATA {
    USHORT AdapterId;
    UCHAR PosData1;
    UCHAR PosData2;
    UCHAR PosData3;
    UCHAR PosData4;
} CM_MCA_POS_DATA, *PCM_MCA_POS_DATA;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _EISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT AddressLowWord;
    UCHAR AddressHighByte;
    USHORT MemorySize;
} EISA_MEMORY_CONFIGURATION, *PEISA_MEMORY_CONFIGURATION;


//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _EISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} EISA_IRQ_CONFIGURATION, *PEISA_IRQ_CONFIGURATION;


//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIGURATION_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIGURATION_BYTE0;

typedef struct _DMA_CONFIGURATION_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIGURATION_BYTE1;

typedef struct _EISA_DMA_CONFIGURATION {
    DMA_CONFIGURATION_BYTE0 ConfigurationByte0;
    DMA_CONFIGURATION_BYTE1 ConfigurationByte1;
} EISA_DMA_CONFIGURATION, *PEISA_DMA_CONFIGURATION;


//
// Port description of eisa data block structure
//

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *PEISA_PORT_DESCRIPTOR;

typedef struct _EISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} EISA_PORT_CONFIGURATION, *PEISA_PORT_CONFIGURATION;


//
// Eisa slot information definition
// N.B. This structure is different from the one defined
//      in ARC eisa addendum.
//

typedef struct _CM_EISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} CM_EISA_SLOT_INFORMATION, *PCM_EISA_SLOT_INFORMATION;


//
// Eisa function information definition
//

typedef struct _CM_EISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    EISA_MEMORY_CONFIGURATION EisaMemory[9];
    EISA_IRQ_CONFIGURATION EisaIrq[7];
    EISA_DMA_CONFIGURATION EisaDma[4];
    EISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} CM_EISA_FUNCTION_INFORMATION, *PCM_EISA_FUNCTION_INFORMATION;

//
// The following defines the way pnp bios information is stored in
// the registry \\HKEY_LOCAL_MACHINE\HARDWARE\Description\System\MultifunctionAdapter\x
// key, where x is an integer number indicating adapter instance. The
// "Identifier" of the key must equal to "PNP BIOS" and the
// "ConfigurationData" is organized as follow:
//
//      CM_PNP_BIOS_INSTALLATION_CHECK        +
//      CM_PNP_BIOS_DEVICE_NODE for device 1  +
//      CM_PNP_BIOS_DEVICE_NODE for device 2  +
//                ...
//      CM_PNP_BIOS_DEVICE_NODE for device n
//

//
// Pnp BIOS device node structure
//

typedef struct _CM_PNP_BIOS_DEVICE_NODE {
    USHORT Size;
    UCHAR Node;
    ULONG ProductId;
    UCHAR DeviceType[3];
    USHORT DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} CM_PNP_BIOS_DEVICE_NODE,*PCM_PNP_BIOS_DEVICE_NODE;

//
// Pnp BIOS Installation check
//

typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[4];             // $PnP (ascii)
    UCHAR Revision;
    UCHAR Length;
    USHORT ControlField;
    UCHAR Checksum;
    ULONG EventFlagAddress;         // Physical address
    USHORT RealModeEntryOffset;
    USHORT RealModeEntrySegment;
    USHORT ProtectedModeEntryOffset;
    ULONG ProtectedModeCodeBaseAddress;
    ULONG OemDeviceId;
    USHORT RealModeDataBaseAddress;
    ULONG ProtectedModeDataBaseAddress;
} CM_PNP_BIOS_INSTALLATION_CHECK, *PCM_PNP_BIOS_INSTALLATION_CHECK;

#include "poppack.h"

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86

// end_ntminiport end_ntndis

//
// The following structures are used to interpret mips
// DeviceSpecificData of CM_PARTIAL_RESOURCE_DESCRIPTOR.
//

//
// Device data records for adapters.
//

//
// The device data record for the Emulex SCSI controller.
//

typedef struct _CM_SCSI_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    UCHAR HostIdentifier;
} CM_SCSI_DEVICE_DATA, *PCM_SCSI_DEVICE_DATA;

//
// Device data records for controllers.
//

//
// The device data record for the Video controller.
//

typedef struct _CM_VIDEO_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    ULONG VideoClock;
} CM_VIDEO_DEVICE_DATA, *PCM_VIDEO_DEVICE_DATA;

//
// The device data record for the SONIC network controller.
//

typedef struct _CM_SONIC_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    USHORT DataConfigurationRegister;
    UCHAR EthernetAddress[8];
} CM_SONIC_DEVICE_DATA, *PCM_SONIC_DEVICE_DATA;

//
// The device data record for the serial controller.
//

typedef struct _CM_SERIAL_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    ULONG BaudClock;
} CM_SERIAL_DEVICE_DATA, *PCM_SERIAL_DEVICE_DATA;

//
// Device data records for peripherals.
//

//
// The device data record for the Monitor peripheral.
//

typedef struct _CM_MONITOR_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    USHORT HorizontalScreenSize;
    USHORT VerticalScreenSize;
    USHORT HorizontalResolution;
    USHORT VerticalResolution;
    USHORT HorizontalDisplayTimeLow;
    USHORT HorizontalDisplayTime;
    USHORT HorizontalDisplayTimeHigh;
    USHORT HorizontalBackPorchLow;
    USHORT HorizontalBackPorch;
    USHORT HorizontalBackPorchHigh;
    USHORT HorizontalFrontPorchLow;
    USHORT HorizontalFrontPorch;
    USHORT HorizontalFrontPorchHigh;
    USHORT HorizontalSyncLow;
    USHORT HorizontalSync;
    USHORT HorizontalSyncHigh;
    USHORT VerticalBackPorchLow;
    USHORT VerticalBackPorch;
    USHORT VerticalBackPorchHigh;
    USHORT VerticalFrontPorchLow;
    USHORT VerticalFrontPorch;
    USHORT VerticalFrontPorchHigh;
    USHORT VerticalSyncLow;
    USHORT VerticalSync;
    USHORT VerticalSyncHigh;
} CM_MONITOR_DEVICE_DATA, *PCM_MONITOR_DEVICE_DATA;

//
// The device data record for the Floppy peripheral.
//

typedef struct _CM_FLOPPY_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    CHAR Size[8];
    ULONG MaxDensity;
    ULONG MountDensity;
    //
    // New data fields for version >= 2.0
    //
    UCHAR StepRateHeadUnloadTime;
    UCHAR HeadLoadTime;
    UCHAR MotorOffTime;
    UCHAR SectorLengthCode;
    UCHAR SectorPerTrack;
    UCHAR ReadWriteGapLength;
    UCHAR DataTransferLength;
    UCHAR FormatGapLength;
    UCHAR FormatFillCharacter;
    UCHAR HeadSettleTime;
    UCHAR MotorSettleTime;
    UCHAR MaximumTrackValue;
    UCHAR DataTransferRate;
} CM_FLOPPY_DEVICE_DATA, *PCM_FLOPPY_DEVICE_DATA;

//
// The device data record for the Keyboard peripheral.
// The KeyboardFlags is defined (by x86 BIOS INT 16h, function 02) as:
//      bit 7 : Insert on
//      bit 6 : Caps Lock on
//      bit 5 : Num Lock on
//      bit 4 : Scroll Lock on
//      bit 3 : Alt Key is down
//      bit 2 : Ctrl Key is down
//      bit 1 : Left shift key is down
//      bit 0 : Right shift key is down
//

typedef struct _CM_KEYBOARD_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    UCHAR Type;
    UCHAR Subtype;
    USHORT KeyboardFlags;
} CM_KEYBOARD_DEVICE_DATA, *PCM_KEYBOARD_DEVICE_DATA;

//
// Declaration of the structure for disk geometries
//

typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA {
    ULONG BytesPerSector;
    ULONG NumberOfCylinders;
    ULONG SectorsPerTrack;
    ULONG NumberOfHeads;
} CM_DISK_GEOMETRY_DEVICE_DATA, *PCM_DISK_GEOMETRY_DEVICE_DATA;

// end_wdm
//
// Declaration of the structure for the PcCard ISA IRQ map
//

typedef struct _CM_PCCARD_DEVICE_DATA {
    UCHAR Flags;
    UCHAR ErrorCode;
    USHORT Reserved;
    ULONG BusData;
    ULONG DeviceId;
    ULONG LegacyBaseAddress;
    UCHAR IRQMap[16];
} CM_PCCARD_DEVICE_DATA, *PCM_PCCARD_DEVICE_DATA;

// Definitions for Flags

#define PCCARD_MAP_ERROR        0x01
#define PCCARD_DEVICE_PCI       0x10

#define PCCARD_SCAN_DISABLED    0x01
#define PCCARD_MAP_ZERO         0x02
#define PCCARD_NO_TIMER         0x03
#define PCCARD_NO_PIC           0x04
#define PCCARD_NO_LEGACY_BASE   0x05
#define PCCARD_DUP_LEGACY_BASE  0x06
#define PCCARD_NO_CONTROLLERS   0x07

// begin_wdm
// begin_ntminiport

//
// Defines Resource Options
//

#define IO_RESOURCE_PREFERRED       0x01
#define IO_RESOURCE_DEFAULT         0x02
#define IO_RESOURCE_ALTERNATIVE     0x08


//
// This structure defines one type of resource requested by the driver
//

typedef struct _IO_RESOURCE_DESCRIPTOR {
    UCHAR Option;
    UCHAR Type;                         // use CM_RESOURCE_TYPE
    UCHAR ShareDisposition;             // use CM_SHARE_DISPOSITION
    UCHAR Spare1;
    USHORT Flags;                       // use CM resource flag defines
    USHORT Spare2;                      // align

    union {
        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Port;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory;

        struct {
            ULONG MinimumVector;
            ULONG MaximumVector;
        } Interrupt;

        struct {
            ULONG MinimumChannel;
            ULONG MaximumChannel;
        } Dma;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Generic;

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Length;
            ULONG MinBusNumber;
            ULONG MaxBusNumber;
            ULONG Reserved;
        } BusNumber;

        struct {
            ULONG Priority;   // use LCPRI_Xxx values in cfg.h
            ULONG Reserved1;
            ULONG Reserved2;
        } ConfigData;

    } u;

} IO_RESOURCE_DESCRIPTOR, *PIO_RESOURCE_DESCRIPTOR;

// end_ntminiport


typedef struct _IO_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;

    ULONG Count;
    IO_RESOURCE_DESCRIPTOR Descriptors[1];
} IO_RESOURCE_LIST, *PIO_RESOURCE_LIST;


typedef struct _IO_RESOURCE_REQUIREMENTS_LIST {
    ULONG ListSize;
    INTERFACE_TYPE InterfaceType; // unused for WDM
    ULONG BusNumber; // unused for WDM
    ULONG SlotNumber;
    ULONG Reserved[3];
    ULONG AlternativeLists;
    IO_RESOURCE_LIST  List[1];
} IO_RESOURCE_REQUIREMENTS_LIST, *PIO_RESOURCE_REQUIREMENTS_LIST;

// end_ntddk end_wdm end_nthal

#ifdef __cplusplus
}
#endif

#endif // _NTCONFIG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntddvdsk.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddvdsk.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Virtual Disk device.

Author:

    Steve Wood (stevewo) 27-May-1990

Revision History:

--*/

#ifndef _NTDDVDSK_
#define _NTDDVDSK_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_VDSK_DEVICE_NAME "\\Device\\UNKNOWN"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_VDSK_BASE                  FILE_DEVICE_VIRTUAL_DISK


//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

#ifdef __cplusplus
}
#endif

#endif   // _NTDDVDSK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntdskreg.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    ntdskreg.h

Abstract:

    This file contains disk registry data structures.

Authors:

    mglass
    bobri

Notes:

Revision History:

--*/

#ifndef _NTDSKREG_
#define _NTDSKREG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Component types for FT members.  If a disk partition
// is not a part of an FT component then it is stamped
// as "NotAnFtMember".
//

typedef enum {
    Mirror,
    Stripe,
    StripeWithParity,
    VolumeSet,
    NotAnFtMember,
    WholeDisk
} FT_TYPE;

//
// FT_PARTITION_STATE is an enumerated type that describes the state of an
// NTFT member.
// Up to one member can be 'orphaned', that is missing or out of sync with
// the other members.  The orphaned member will remain orphaned until recovery
// action is commenced in DISKMAN.EXE.
// When READs are directed at an orphaned member, the data is returned from
// the redundant copy.  WRITEs go to the secondary members only.
//
// Note that SyncRedundantCopy should NEVER be seen by anything other
// than ft itself.
//

typedef enum _FT_PARTITION_STATE {
    Healthy,
    Orphaned,
    Regenerating,
    Initializing,
    SyncRedundantCopy
} FT_PARTITION_STATE, *PFT_PARTITION_STATE;

//
// The description of a partition on a disk.
//

#include "pshpack4.h"
typedef struct _DISK_PARTITION {

    FT_TYPE            FtType;
    FT_PARTITION_STATE FtState;
    LARGE_INTEGER      StartingOffset;
    LARGE_INTEGER      Length;
    LARGE_INTEGER      FtLength;
    ULONG              ReservedTwoLongs[2];
    UCHAR              DriveLetter;
    BOOLEAN            AssignDriveLetter;
    USHORT             LogicalNumber;
    USHORT             FtGroup;
    USHORT             FtMember;
    BOOLEAN            Modified;
    UCHAR              ReservedChars[3];

} DISK_PARTITION, *PDISK_PARTITION;

//
// The description of a disk.
//

typedef struct _DISK_DESCRIPTION {

    USHORT NumberOfPartitions;
    USHORT ReservedShort;
    ULONG  Signature;

    //
    // An array for NumberOfPartitions
    //

    DISK_PARTITION Partitions[1];

} DISK_DESCRIPTION, *PDISK_DESCRIPTION;

//
// Header for all disk descriptions.
//

typedef struct _DISK_REGISTRY {

    USHORT NumberOfDisks;
    USHORT ReservedShort;

    //
    // An array for NumberOfDisks.
    //

    DISK_DESCRIPTION Disks[1];

} DISK_REGISTRY, *PDISK_REGISTRY;
#include "poppack.h"

//
// Function prototypes.
//


//
// Set the current registry information.
//

NTSTATUS
DiskRegistrySet(
    IN PDISK_REGISTRY Buffer
    );


//
// Add a single disk to the registry.  This disk is not a part of
// a Fault Tolerance volume.
//

NTSTATUS
DiskRegistryAddNewDisk(
    IN PDISK_DESCRIPTION Buffer
    );

//
// Get the current registry information.
// A Buffer address == NULL indicates that the caller only wants.
// to know the size of the registry information.
//

NTSTATUS
DiskRegistryGet(
    OUT PDISK_REGISTRY Buffer,
    OUT PULONG        LengthReturned
    );

//
// Determine if FT is installed and currently active in the system.
//

BOOLEAN
FtInstalled(
    );

//
// Cause an FT set to be initialized at the earliest possible moment.
//

VOID
DiskRegistryInitializeSet(
    IN USHORT  FtType,
    IN USHORT  FtGroup
    );

//
// Cause an FT set member to be regenerated at the earliest possible moment.
//

VOID
DiskRegistryRegenerateSet(
    IN USHORT  FtType,
    IN USHORT  FtGroup,
    IN USHORT  FtMember
    );

//
// Enable the FT driver.
//

BOOLEAN
DiskRegistryEnableFt();

//
// Disable the FT driver.
//

VOID
DiskRegistryDisableFt();

//
// Determine if the existing FT registry information requires the FT driver.
//

BOOLEAN
DiskRegistryRequiresFt();

//
// Update drive letter assignment.
//

BOOLEAN
DiskRegistryAssignDriveLetter(
    ULONG         Signature,
    LARGE_INTEGER StartingOffset,
    LARGE_INTEGER Length,
    UCHAR         DriveLetter
    );

//
// Determine if DoubleSpace support is set to automount double space
// volumes on removable media.
//

BOOLEAN
DiskRegistryAutomountCurrentState(
    );

//
// Set the automount state for double space volumes on removable media.
//

NTSTATUS
DiskRegistryDblSpaceRemovable(
    IN BOOLEAN Automount
    );

//
// Set the drive letter for space mount information in the registry.
//

NTSTATUS
DiskRegistryAssignDblSpaceLetter(
    IN PWSTR CvfName,
    IN WCHAR DriveLetter
    );

//
// Set up the registry information for CdRom drive letters.
//

NTSTATUS
DiskRegistryAssignCdRomLetter(
    IN PWSTR CdromName,
    IN WCHAR DriveLetter
    );

#ifdef __cplusplus
}
#endif

#endif // _NTDSKREG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntddpsch.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    ntddpsch.h

Abstract:

    defines that are exported to user mode

Author:

Revision History:

--*/

#ifndef _NTDDPSCH_
#define _NTDDPSCH_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// flow data returned in the Stats structure
//

#pragma pack(1)
typedef struct _PS_COMPONENT_STATS {

#define PS_COMPONENT_ADAPTER        1
#define PS_COMPONENT_FLOW           2
#define PS_COMPONENT_CONFORMER      3
#define PS_COMPONENT_SHAPER         4
#define PS_COMPONENT_DRRSEQ         5

    ULONG Type;
    ULONG Length;
    UCHAR Stats[1];
} PS_COMPONENT_STATS, *PPS_COMPONENT_STATS;
#pragma pack()

#pragma pack(1)
typedef struct _PS_CONFORMER_STATS {
    ULONG NonconformingPacketsScheduled;
} PS_CONFORMER_STATS, *PPS_CONFORMER_STATS;
#pragma pack()

#pragma pack(1)
typedef struct _PS_SHAPER_STATS {
    ULONG MaxPacketsInShaper;
    ULONG AveragePacketsInShaper;
} PS_SHAPER_STATS, *PPS_SHAPER_STATS;
#pragma pack()

#pragma pack(1)
typedef struct _PS_DRRSEQ_STATS {
    ULONG MaxPacketsInNetcard;
    ULONG AveragePacketsInNetcard;
    ULONG MaxPacketsInSequencer;
    ULONG AveragePacketsInSequencer;
    ULONG NonconformingPacketsTransmitted;
} PS_DRRSEQ_STATS, *PPS_DRRSEQ_STATS;
#pragma pack()


#pragma pack(1)
typedef struct _PS_FLOW_STATS {

    ULONG DroppedPackets;
    ULONG PacketsScheduled;
	ULONG PacketsTransmitted;
    LARGE_INTEGER BytesScheduled;
    LARGE_INTEGER BytesTransmitted;
} PS_FLOW_STATS, *PPS_FLOW_STATS;
#pragma pack()

#pragma pack(1)
typedef struct _PS_ADAPTER_STATS {

    //
    // OutOfPackets is incremented when no packets for sending/receive packet
    // indications are available.
    //

    ULONG OutOfPackets;

    //
    // general flow stats
    //

    ULONG FlowsOpened;
    ULONG FlowsClosed;
    ULONG FlowsRejected;
    ULONG FlowsModified;
    ULONG FlowModsRejected;
    ULONG MaxSimultaneousFlows;

} PS_ADAPTER_STATS, *PPS_ADAPTER_STATS;
#pragma pack()

//
// Defines that can be used for OID_QOS_FLOW_MODE
//
#define ADAPTER_FLOW_MODE_DIFFSERV           1
#define ADAPTER_FLOW_MODE_STANDARD           2


#ifdef __cplusplus
}
#endif

#endif /* _NTDDPSCH_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntlpcapi.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

    ntlpcapi.h

Abstract:

    This is the include file for the Local Procedure Call (LPC) sub-component
    of NTOS.

Author:

    Steve Wood (stevewo) 13-Mar-1989

Revision History:

--*/

#ifndef _NTLPCAPI_
#define _NTLPCAPI_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Connection Port Type Specific Access Rights.
//

#define PORT_CONNECT (0x0001)

#define PORT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | \
                         SYNCHRONIZE | 0x1)

// begin_ntifs begin_nthal

#if defined(USE_LPC6432)
#define LPC_CLIENT_ID CLIENT_ID64
#define LPC_SIZE_T ULONGLONG
#define LPC_PVOID ULONGLONG
#define LPC_HANDLE ULONGLONG
#else
#define LPC_CLIENT_ID CLIENT_ID
#define LPC_SIZE_T SIZE_T
#define LPC_PVOID PVOID
#define LPC_HANDLE HANDLE
#endif


typedef struct _PORT_MESSAGE {
    union {
        struct {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union {
        struct {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union {
        LPC_CLIENT_ID ClientId;
        double DoNotUseThisField;       // Force quadword alignment
    };
    ULONG MessageId;
    union {
        LPC_SIZE_T ClientViewSize;          // Only valid on LPC_CONNECTION_REQUEST message
        ULONG CallbackId;                   // Only valid on LPC_REQUEST message
    };
//  UCHAR Data[];
} PORT_MESSAGE, *PPORT_MESSAGE;

// end_ntifs end_nthal

typedef struct _PORT_DATA_ENTRY {
    LPC_PVOID Base;
    ULONG Size;
} PORT_DATA_ENTRY, *PPORT_DATA_ENTRY;

typedef struct _PORT_DATA_INFORMATION {
    ULONG CountDataEntries;
    PORT_DATA_ENTRY DataEntries[1];
} PORT_DATA_INFORMATION, *PPORT_DATA_INFORMATION;


//
// Valid return values for the PORT_MESSAGE Type file
//

#define LPC_REQUEST             1
#define LPC_REPLY               2
#define LPC_DATAGRAM            3
#define LPC_LOST_REPLY          4
#define LPC_PORT_CLOSED         5
#define LPC_CLIENT_DIED         6
#define LPC_EXCEPTION           7
#define LPC_DEBUG_EVENT         8
#define LPC_ERROR_EVENT         9
#define LPC_CONNECTION_REQUEST 10

// begin_ntifs

//
// The following bit may be placed in the Type field of a message
// prior calling NtRequestPort or NtRequestWaitReplyPort.  If the
// previous mode is KernelMode, the bit it left as is and passed
// to the receiver of the message.  Otherwise the bit is clear.
//

#define LPC_KERNELMODE_MESSAGE  (CSHORT)0x8000

// end_ntifs

#define PORT_VALID_OBJECT_ATTRIBUTES (OBJ_CASE_INSENSITIVE)

// begin_ntddk begin_wdm
#ifdef _WIN64
#define PORT_MAXIMUM_MESSAGE_LENGTH 512
#else
#define PORT_MAXIMUM_MESSAGE_LENGTH 256
#endif
// end_ntddk end_wdm

#if defined(USE_LPC6432)
#undef PORT_MAXIMUM_MESSAGE_LENGTH
#define PORT_MAXIMUM_MESSAGE_LENGTH 512
#endif

typedef struct _LPC_CLIENT_DIED_MSG {
    PORT_MESSAGE PortMsg;
    LARGE_INTEGER CreateTime;
} LPC_CLIENT_DIED_MSG, *PLPC_CLIENT_DIED_MSG;

// begin_ntifs

typedef struct _PORT_VIEW {
    ULONG Length;
    LPC_HANDLE SectionHandle;
    ULONG SectionOffset;
    LPC_SIZE_T ViewSize;
    LPC_PVOID ViewBase;
    LPC_PVOID ViewRemoteBase;
} PORT_VIEW, *PPORT_VIEW;

typedef struct _REMOTE_PORT_VIEW {
    ULONG Length;
    LPC_SIZE_T ViewSize;
    LPC_PVOID ViewBase;
} REMOTE_PORT_VIEW, *PREMOTE_PORT_VIEW;

// end_ntifs

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreatePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateWaitablePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage
    );


// begin_ntifs

NTSYSCALLAPI
NTSTATUS
NTAPI
NtConnectPort(
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT PPORT_VIEW ClientView OPTIONAL,
    IN OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,
    OUT PULONG MaxMessageLength OPTIONAL,
    IN OUT PVOID ConnectionInformation OPTIONAL,
    IN OUT PULONG ConnectionInformationLength OPTIONAL
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSecureConnectPort(
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT PPORT_VIEW ClientView OPTIONAL,
    IN PSID RequiredServerSid,
    IN OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,
    OUT PULONG MaxMessageLength OPTIONAL,
    IN OUT PVOID ConnectionInformation OPTIONAL,
    IN OUT PULONG ConnectionInformationLength OPTIONAL
    );

// end_ntifs

NTSYSCALLAPI
NTSTATUS
NTAPI
NtListenPort(
    IN HANDLE PortHandle,
    OUT PPORT_MESSAGE ConnectionRequest
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAcceptConnectPort(
    OUT PHANDLE PortHandle,
    IN PVOID PortContext,
    IN PPORT_MESSAGE ConnectionRequest,
    IN BOOLEAN AcceptConnection,
    IN OUT PPORT_VIEW ServerView OPTIONAL,
    OUT PREMOTE_PORT_VIEW ClientView OPTIONAL
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompleteConnectPort(
    IN HANDLE PortHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRequestPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage
    );

// begin_ntifs

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRequestWaitReplyPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    );

// end_ntifs

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplyPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE ReplyMessage
    );


NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplyWaitReplyPort(
    IN HANDLE PortHandle,
    IN OUT PPORT_MESSAGE ReplyMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplyWaitReceivePort(
    IN HANDLE PortHandle,
    OUT PVOID *PortContext OPTIONAL,
    IN PPORT_MESSAGE ReplyMessage OPTIONAL,
    OUT PPORT_MESSAGE ReceiveMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplyWaitReceivePortEx(
    IN HANDLE PortHandle,
    OUT PVOID *PortContext OPTIONAL,
    IN PPORT_MESSAGE ReplyMessage OPTIONAL,
    OUT PPORT_MESSAGE ReceiveMessage,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtImpersonateClientOfPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadRequestData(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    OUT PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT PSIZE_T NumberOfBytesRead OPTIONAL
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteRequestData(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    IN PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT PSIZE_T NumberOfBytesWritten OPTIONAL
    );


typedef enum _PORT_INFORMATION_CLASS {
    PortBasicInformation
#if DEVL
,   PortDumpInformation
#endif
} PORT_INFORMATION_CLASS;


NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationPort(
    IN HANDLE PortHandle,
    IN PORT_INFORMATION_CLASS PortInformationClass,
    OUT PVOID PortInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );

#ifdef __cplusplus
}
#endif

#endif  // _NTLPCAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntdddlc.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation
          (c) 1991  Nokia Data Systems AB

Module Name:

    ntdddlc.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the DLC driver interface device.

Author:

    Antti Saarenheimo (o-anttis) 08-JUNE-1991

Revision History:

--*/

#ifndef _NTDDDLC_
#define _NTDDDLC_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//


#define FILE_DEVICE_DLC     FILE_DEVICE_TRANSPORT

#define DD_DLC_DEVICE_NAME L"\\Device\\Dlc"

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define _DLC_CONTROL_CODE(request,method) \
    CTL_CODE(FILE_DEVICE_DLC, request, method, FILE_ANY_ACCESS)

#define IOCTL_DLC_READ                  _DLC_CONTROL_CODE(0, METHOD_BUFFERED)
#define IOCTL_DLC_RECEIVE               _DLC_CONTROL_CODE(1, METHOD_BUFFERED)
#define IOCTL_DLC_TRANSMIT              _DLC_CONTROL_CODE(2, METHOD_OUT_DIRECT)
#define IOCTL_DLC_BUFFER_FREE           _DLC_CONTROL_CODE(3, METHOD_BUFFERED)
#define IOCTL_DLC_BUFFER_GET            _DLC_CONTROL_CODE(4, METHOD_BUFFERED)
#define IOCTL_DLC_BUFFER_CREATE         _DLC_CONTROL_CODE(5, METHOD_BUFFERED)
#define IOCTL_DLC_SET_EXCEPTION_FLAGS   _DLC_CONTROL_CODE(6, METHOD_BUFFERED)
#define IOCTL_DLC_CLOSE_STATION         _DLC_CONTROL_CODE(7, METHOD_OUT_DIRECT)
#define IOCTL_DLC_CONNECT_STATION       _DLC_CONTROL_CODE(8, METHOD_BUFFERED)
#define IOCTL_DLC_FLOW_CONTROL          _DLC_CONTROL_CODE(9, METHOD_BUFFERED)
#define IOCTL_DLC_OPEN_STATION          _DLC_CONTROL_CODE(10, METHOD_BUFFERED)
#define IOCTL_DLC_RESET                 _DLC_CONTROL_CODE(11, METHOD_OUT_DIRECT)
#define IOCTL_DLC_READ_CANCEL           _DLC_CONTROL_CODE(12, METHOD_BUFFERED)
#define IOCTL_DLC_RECEIVE_CANCEL        _DLC_CONTROL_CODE(13, METHOD_BUFFERED)
#define IOCTL_DLC_QUERY_INFORMATION     _DLC_CONTROL_CODE(14, METHOD_BUFFERED)
#define IOCTL_DLC_SET_INFORMATION       _DLC_CONTROL_CODE(15, METHOD_BUFFERED)
#define IOCTL_DLC_TIMER_CANCEL          _DLC_CONTROL_CODE(16, METHOD_BUFFERED)
#define IOCTL_DLC_TIMER_CANCEL_GROUP    _DLC_CONTROL_CODE(17, METHOD_BUFFERED)
#define IOCTL_DLC_TIMER_SET             _DLC_CONTROL_CODE(18, METHOD_BUFFERED)
#define IOCTL_DLC_OPEN_SAP              _DLC_CONTROL_CODE(19, METHOD_BUFFERED)
#define IOCTL_DLC_CLOSE_SAP             _DLC_CONTROL_CODE(20, METHOD_OUT_DIRECT)
#define IOCTL_DLC_OPEN_DIRECT           _DLC_CONTROL_CODE(21, METHOD_BUFFERED)
#define IOCTL_DLC_CLOSE_DIRECT          _DLC_CONTROL_CODE(22, METHOD_OUT_DIRECT)
#define IOCTL_DLC_OPEN_ADAPTER          _DLC_CONTROL_CODE(23, METHOD_BUFFERED)
#define IOCTL_DLC_CLOSE_ADAPTER         _DLC_CONTROL_CODE(24, METHOD_BUFFERED)
#define IOCTL_DLC_REALLOCTE_STATION     _DLC_CONTROL_CODE(25, METHOD_BUFFERED)
#define IOCTL_DLC_READ2                 _DLC_CONTROL_CODE(26, METHOD_BUFFERED)
#define IOCTL_DLC_RECEIVE2              _DLC_CONTROL_CODE(27, METHOD_BUFFERED)
#define IOCTL_DLC_TRANSMIT2             _DLC_CONTROL_CODE(28, METHOD_BUFFERED)
#define IOCTL_DLC_COMPLETE_COMMAND      _DLC_CONTROL_CODE(29, METHOD_BUFFERED)
#define IOCTL_DLC_TRACE_INITIALIZE      _DLC_CONTROL_CODE(30, METHOD_OUT_DIRECT)

#define IOCTL_DLC_MAX                   _DLC_CONTROL_CODE(30, METHOD_BUFFERED)

#define IOCTL_DLC_LAST_COMMAND          31  // for xlation tables

#ifdef __cplusplus
}
#endif

#endif  // _NTDDDLC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntlsapi.h ===
/*
 * Copyright (C) Microsoft Corporation, 1990-1999
 *
 * LSAPI.H
 *
 * NOTE:  If you are using this header file on the Windows for DOS platform,
 *        then you are required to include "windows.h" prior to including
 *        this header file.
 */

#ifndef LSAPI_H
#define LSAPI_H

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(WINVER)  // Windows for NT or DOS
#if defined(WINAPIV)
#define LS_API_ENTRY WINAPIV
#else
#define LS_API_ENTRY WINAPI
#endif
#else
#define LS_API_ENTRY
#endif

typedef unsigned long    LS_STATUS_CODE;
typedef ULONG_PTR LS_HANDLE;

// **************************************************
// Standard LSAPI C status codes
//***************************************************
#define LS_SUCCESS                           ((LS_STATUS_CODE) 0x0)
#define LS_BAD_HANDLE                        ((LS_STATUS_CODE) 0xC0001001)
#define LS_INSUFFICIENT_UNITS                ((LS_STATUS_CODE) 0xC0001002)
#define LS_SYSTEM_UNAVAILABLE                ((LS_STATUS_CODE) 0xC0001003)
#define LS_LICENSE_TERMINATED                ((LS_STATUS_CODE) 0xC0001004)
#define LS_AUTHORIZATION_UNAVAILABLE         ((LS_STATUS_CODE) 0xC0001005)
#define LS_LICENSE_UNAVAILABLE               ((LS_STATUS_CODE) 0xC0001006)
#define LS_RESOURCES_UNAVAILABLE             ((LS_STATUS_CODE) 0xC0001007)
#define LS_NETWORK_UNAVAILABLE               ((LS_STATUS_CODE) 0xC0001008)
#define LS_TEXT_UNAVAILABLE                  ((LS_STATUS_CODE) 0x80001009)
#define LS_UNKNOWN_STATUS                    ((LS_STATUS_CODE) 0xC000100A)
#define LS_BAD_INDEX                         ((LS_STATUS_CODE) 0xC000100B)
#define LS_LICENSE_EXPIRED                   ((LS_STATUS_CODE) 0x8000100C)
#define LS_BUFFER_TOO_SMALL                  ((LS_STATUS_CODE) 0xC000100D)
#define LS_BAD_ARG                           ((LS_STATUS_CODE) 0xC000100E)

//***************************************************
//* Nt LS API data structure and constant
//***************************************************

#define NT_LS_USER_NAME               ((ULONG) 0)  // username only
#define NT_LS_USER_SID                ((ULONG) 1)  // SID only

typedef struct {
   ULONG    DataType;                 // Type of the following data, ie. user name, sid...
   VOID     *Data;                    // Actual data. username, sid, etc...
                                      // if call the unicode API character data
                                      // must be in unicode as well
   BOOL     IsAdmin;
} NT_LS_DATA;


//
// Prototypes for License Request routines
//

typedef LS_STATUS_CODE
    (LS_API_ENTRY * PNT_LICENSE_REQUEST_W)(
    LPWSTR      ProductName,
    LPWSTR      Version,
    LS_HANDLE   *LicenseHandle,
    NT_LS_DATA  *NtData);

typedef LS_STATUS_CODE
    (LS_API_ENTRY * PNT_LS_FREE_HANDLE)(
    LS_HANDLE   LicenseHandle );


#ifdef UNICODE
#define NtLicenseRequest  NtLicenseRequestW
#else
#define NtLicenseRequest  NtLicenseRequestA
#endif // !UNICODE

LS_STATUS_CODE LS_API_ENTRY NtLicenseRequestA(
                  LPSTR       ProductName,
                  LPSTR       Version,
                  LS_HANDLE   FAR *LicenseHandle,
                  NT_LS_DATA  *NtData);

LS_STATUS_CODE LS_API_ENTRY NtLicenseRequestW(
                  LPWSTR      ProductName,
                  LPWSTR      Version,
                  LS_HANDLE   FAR *LicenseHandle,
                  NT_LS_DATA  *NtData);


LS_STATUS_CODE LS_API_ENTRY NtLSFreeHandle(
                  LS_HANDLE   LicenseHandle );


/***************************************************/
/* standard LS API c datatype definitions          */
/***************************************************/

typedef char             LS_STR;
typedef unsigned long    LS_ULONG;
typedef long             LS_LONG;
typedef void             LS_VOID;

typedef struct {
   LS_STR        MessageDigest[16];  /* a 128-bit message digest          */
} LS_MSG_DIGEST;

typedef struct {
   LS_ULONG      SecretIndex;        /* index of secret, X                */
   LS_ULONG      Random;             /* a random 32-bit value, R          */
   LS_MSG_DIGEST MsgDigest;          /* the message digest h(in,R,S,Sx)   */
} LS_CHALLDATA;

typedef struct {
   LS_ULONG      Protocol;           /* Specifies the protocol            */
   LS_ULONG      Size;               /* size of ChallengeData structure   */
   LS_CHALLDATA  ChallengeData;      /* challenge & response              */
} LS_CHALLENGE;


/***************************************************/
/* Standard LSAPI C constant definitions           */
/***************************************************/

#define LS_DEFAULT_UNITS            ((LS_ULONG) 0xFFFFFFFF)
#define LS_ANY                      ((LS_STR FAR *) "")
#define LS_USE_LAST                 ((LS_ULONG) 0x0800FFFF)
#define LS_INFO_NONE                ((LS_ULONG) 0)
#define LS_INFO_SYSTEM              ((LS_ULONG) 1)
#define LS_INFO_DATA                ((LS_ULONG) 2)
#define LS_UPDATE_PERIOD            ((LS_ULONG) 3)
#define LS_LICENSE_CONTEXT          ((LS_ULONG) 4)
#define LS_BASIC_PROTOCOL           ((LS_ULONG) 0x00000001)
#define LS_SQRT_PROTOCOL            ((LS_ULONG) 0x00000002)
#define LS_OUT_OF_BAND_PROTOCOL     ((LS_ULONG) 0xFFFFFFFF)
#define LS_NULL                     ((LS_VOID FAR *) NULL)


#ifdef __cplusplus
}
#endif

#endif /* LSAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntprfctr.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1999 Microsoft Corporation

Module Name:

    ntprfctr.h

Abstract:

    Contains symbolic definitions of the "Standard" Perfmon Counter Objects
    These are the integer and unicode string values used in the registry to
    locate and identify counter titles and help text.

Author:

    Bob Watson (a-robw) 16 Nov 92

Revision History:

    Bob Watson (bobw)   22 Oct 97   added job object & RSVP counters


--*/
#ifndef _NTPRFCTR_H_
#define _NTPRFCTR_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
//  These values correspond to the values assigned to these object titles
//  in the registry
//
#define NULL_OBJECT_TITLE_INDEX               0

#define SYSTEM_OBJECT_TITLE_INDEX             2
#define PROCESSOR_OBJECT_TITLE_INDEX        238
#define MEMORY_OBJECT_TITLE_INDEX             4
#define CACHE_OBJECT_TITLE_INDEX             86
#define PHYSICAL_DISK_OBJECT_TITLE_INDEX    234
#define LOGICAL_DISK_OBJECT_TITLE_INDEX     236
#define PROCESS_OBJECT_TITLE_INDEX          230
#define THREAD_OBJECT_TITLE_INDEX           232
#define OBJECT_OBJECT_TITLE_INDEX           260
#define REDIRECTOR_OBJECT_TITLE_INDEX       262
#define SERVER_OBJECT_TITLE_INDEX           330
#define SERVER_QUEUE_OBJECT_TITLE_INDEX    1300
#define PAGEFILE_OBJECT_TITLE_INDEX         700
#define BROWSER_OBJECT_TITLE_INDEX           52
#define HEAP_OBJECT_TITLE_INDEX            1760
//
//  The number of "standard" object types
//
#define NT_NUM_PERF_OBJECT_TYPES             15
//
//  Costly Items
//
#define EXPROCESS_OBJECT_TITLE_INDEX        786
#define IMAGE_OBJECT_TITLE_INDEX            740
#define THREAD_DETAILS_OBJECT_TITLE_INDEX   816
#define LONG_IMAGE_OBJECT_TITLE_INDEX      1408

#define NT_NUM_COSTLY_OBJECT_TYPES            4

#define EXTENSIBLE_OBJECT_INDEX      0xFFFFFFFF

//
//  Microsoft provided extensible counters
//
// these have to match the titles  in PERFCTRS.INI (they don't do it
// by themselves, unfortunately!

#define TCP_OBJECT_TITLE_INDEX              638
#define UDP_OBJECT_TITLE_INDEX              658
#define IP_OBJECT_TITLE_INDEX               546
#define ICMP_OBJECT_TITLE_INDEX             582
#define NET_OBJECT_TITLE_INDEX              510

#define NBT_OBJECT_TITLE_INDEX              502

#define NBF_OBJECT_TITLE_INDEX              492
#define NBF_RESOURCE_OBJECT_TITLE_INDEX     494

//
//  Microsoft extensible counters for other components that are included
//  in the Daytona system.
//
#define FTP_FIRST_COUNTER_INDEX             824
#define FTP_FIRST_HELP_INDEX                825
#define FTP_LAST_COUNTER_INDEX              856
#define FTP_LAST_HELP_INDEX                 857

// as of NT5.0 the RAS counters have been moved to 
// extensible counters above the last base index (1847)
#define RAS_FIRST_COUNTER_INDEX             870
#define RAS_FIRST_HELP_INDEX                871
#define RAS_LAST_COUNTER_INDEX              908
#define RAS_LAST_HELP_INDEX                 909

#define WIN_FIRST_COUNTER_INDEX             920
#define WIN_FIRST_HELP_INDEX                921
#define WIN_LAST_COUNTER_INDEX              950
#define WIN_LAST_HELP_INDEX                 951

#define SFM_FIRST_COUNTER_INDEX            1000
#define SFM_FIRST_HELP_INDEX               1001
#define SFM_LAST_COUNTER_INDEX             1034
#define SFM_LAST_HELP_INDEX                1035

#define ATK_FIRST_COUNTER_INDEX            1050
#define ATK_FIRST_HELP_INDEX               1051
#define ATK_LAST_COUNTER_INDEX             1102
#define ATK_LAST_HELP_INDEX                1103

#define BH_FIRST_COUNTER_INDEX             1110
#define BH_FIRST_HELP_INDEX                1111
#define BH_LAST_COUNTER_INDEX              1126
#define BH_LAST_HELP_INDEX                 1127

#define TAPI_FIRST_COUNTER_INDEX           1150
#define TAPI_FIRST_HELP_INDEX              1151
#define TAPI_LAST_COUNTER_INDEX            1178
#define TAPI_LAST_HELP_INDEX               1179

// NetWare counters have different Object indexes depending
// on whether the system is a Workstation or a Server.
// The rest of the counter indexes are the same (from 1232 to 1247)
#define NWCS_GATEWAY_COUNTER_INDEX         1228
#define NWCS_GATEWAY_HELP_INDEX            1229
#define NWCS_CLIENT_COUNTER_INDEX          1230
#define NWCS_CLIENT_HELP_INDEX             1231
#define NWCS_FIRST_COUNTER_INDEX           1230
#define NWCS_FIRST_HELP_INDEX              1231
#define NWCS_LAST_COUNTER_INDEX            1246
#define NWCS_LAST_HELP_INDEX               1247

// spooler performance counter indices

#define LSPL_FIRST_COUNTER_INDEX           1450
#define LSPL_FIRST_HELP_INDEX              1451
#define LSPL_LAST_COUNTER_INDEX            1498
#define LSPL_LAST_HELP_INDEX               1499

// job object acct & performance counters

#define JOB_FIRST_COUNTER_INDEX            1500
#define JOB_FIRST_HELP_INDEX               1501
#define JOB_OBJECT_TITLE_INDEX             1500
#define JOB_DETAILS_OBJECT_TITLE_INDEX     1548
#define JOB_LAST_COUNTER_INDEX             1548
#define JOB_LAST_HELP_INDEX                1549

// RSVP service counters have been moved to 
// the extensible index space

// next available index:                   1810
// last available index:                   1847

#ifdef __cplusplus
}
#endif

#endif  //_NTPRFCTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntverp.h ===
/****************************************************************************
 *                                                                          *
 *      ntverp.H        -- Version information for internal builds          *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION, VER_PRODUCTVERSION_STR and             *
 *      VER_PRODUCTBETA_STR values.                                         *
 *                                                                          *
 ****************************************************************************/

/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*                                                              */
/* the VER_PRODUCTBUILD lines must contain the product          */
/* comments and end with the build#<CR><LF>                     */
/*                                                              */
/* the VER_PRODUCTBETA_STR lines must  contain the product      */
/* comments and end with "some string"<CR><LF>                  */
/*--------------------------------------------------------------*/

#if _MSC_VER > 1000
#pragma once
#endif

#define VER_PRODUCTBUILD            /* NT */   2600
#define VER_PRODUCTBUILD_QFE        1106

#ifndef NO_RC_VERSION
#define VER_PRODUCTRCVERSION        (257)
#endif


#if defined(NASHVILLE)
// IE components now use NT's VER_PRODUCTBUILD, but define other different major/minor version #'s
#include <ieverp.h>
#else

#define VER_PRODUCTMAJORVERSION     5
#define VER_PRODUCTMINORVERSION     1

#define VER_PRODUCTBETA_STR         /* NT */     ""

#define VER_PRODUCTVERSION_MAJORMINOR2(x,y) #x "." #y
#define VER_PRODUCTVERSION_MAJORMINOR1(x,y) VER_PRODUCTVERSION_MAJORMINOR2(x, y)
#define VER_PRODUCTVERSION_STRING   VER_PRODUCTVERSION_MAJORMINOR1(VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION)

#define VER_PRODUCTVERSION          VER_PRODUCTMAJORVERSION,VER_PRODUCTMINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION_W        (0x0501)
#define VER_PRODUCTVERSION_DW       (0x05010000 | VER_PRODUCTBUILD)

/*--------------------------------------------------------------*/
/* this value is used by third party drivers build with the DDK */
/* and internally, to avoid version number conflicts.           */
/*--------------------------------------------------------------*/
#define VER_DDK_PRODUCTVERSION       5,01
#define VER_DDK_PRODUCTVERSION_STR  "5.01"

#endif

#if     (VER_PRODUCTBUILD < 10)
#define VER_BPAD "000"
#elif   (VER_PRODUCTBUILD < 100)
#define VER_BPAD "00"
#elif   (VER_PRODUCTBUILD < 1000)
#define VER_BPAD "0"
#else
#define VER_BPAD
#endif

#define VER_PRODUCTVERSION_STR2(x,y) VER_PRODUCTVERSION_STRING "." VER_BPAD #x "." #y
#define VER_PRODUCTVERSION_STR1(x,y) VER_PRODUCTVERSION_STR2(x, y)
#define VER_PRODUCTVERSION_STR       VER_PRODUCTVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if DBG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is prerelease */
#if BETA
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#if OFFICIAL_BUILD
#define VER_PRIVATE                 0
#else
#define VER_PRIVATE                 VS_FF_PRIVATEBUILD
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_NT_WINDOWS32
#define VER_FILEFLAGS               (VER_PRERELEASE|VER_DEBUG|VER_PRIVATE)

// @@BEGIN_DDKSPLIT
#if 0
// @@END_DDKSPLIT
#define VER_COMPANYNAME_STR         "Windows (R) 2000 DDK provider"
#define VER_PRODUCTNAME_STR         "Windows (R) 2000 DDK driver"
#define VER_LEGALTRADEMARKS_STR     \
"Windows (R) is a registered trademark of Microsoft Corporation."
// @@BEGIN_DDKSPLIT
#else

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows\256 Operating System"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows\256 is a registered trademark of Microsoft Corporation."
#endif
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntddtx.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddtx.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the transaction device.

Author:

    Chandan Chauhan (ChandanC) 15-Feb-1991

Revision History:

--*/

#if _MSC_VER > 1000
#pragma once
#endif


#define IOCTL_TRNXT_XCEIVE	 0x12
#define IOCTL_TRNXT_READ	 0x22
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntddpcm.h ===
/*++

Copyright (c) 1994-1999  Digital Equipment Corporation

Module Name:

    ntddpcm.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the PCMCIA Adapters.

// @@BEGIN_DDKSPLIT
Author:

    Jeff McLeman

Revision History:

    Ravisankar Pudipeddi (ravisp) 1-Jan-1997

// @@END_DDKSPLIT
--*/

#ifndef _NTDDPCMH_
#define _NTDDPCMH_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define IOCTL_PCMCIA_BASE                 FILE_DEVICE_CONTROLLER

#define DD_PCMCIA_DEVICE_NAME "\\\\.\\Pcmcia"


//
// IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_GET_TUPLE_DATA         CTL_CODE(IOCTL_PCMCIA_BASE, 3000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SOCKET_INFORMATION     CTL_CODE(IOCTL_PCMCIA_BASE, 3004, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Tuple request parameters.
//

typedef struct _TUPLE_REQUEST {
   USHORT  Socket;
} TUPLE_REQUEST, *PTUPLE_REQUEST;

#define MANUFACTURER_NAME_LENGTH 64
#define DEVICE_IDENTIFIER_LENGTH 64
#define DRIVER_NAME_LENGTH       32

#define PcmciaInvalidControllerType 0xffffffff

//
// Controller classes returned in socket information structure.
//

typedef enum _PCMCIA_CONTROLLER_CLASS {
   PcmciaInvalidControllerClass = -1,
   PcmciaIntelCompatible,
   PcmciaCardBusCompatible,
   PcmciaElcController,
   PcmciaDatabook,     
   PcmciaPciPcmciaBridge,
   PcmciaCirrusLogic,  
   PcmciaTI,           
   PcmciaTopic,        
   PcmciaRicoh,        
   PcmciaDatabookCB,   
   PcmciaOpti,         
   PcmciaTrid,         
   PcmciaO2Micro,      
   PcmciaNEC,          
   PcmciaNEC_98                
} PCMCIA_CONTROLLER_CLASS, *PPCMCIA_CONTROLLER_CLASS;


typedef struct _PCMCIA_SOCKET_INFORMATION {
   USHORT  Socket;
   USHORT  TupleCrc;
   UCHAR   Manufacturer[MANUFACTURER_NAME_LENGTH];
   UCHAR   Identifier[DEVICE_IDENTIFIER_LENGTH];
   UCHAR   DriverName[DRIVER_NAME_LENGTH];
   UCHAR   DeviceFunctionId;
   UCHAR   Reserved;
   UCHAR   CardInSocket;
   UCHAR   CardEnabled;
   ULONG   ControllerType;
} PCMCIA_SOCKET_INFORMATION, *PPCMCIA_SOCKET_INFORMATION;

//
// macros to crack the ControllerId field of the socket info structure
//
#define PcmciaClassFromControllerType(type) ((PCMCIA_CONTROLLER_CLASS)((type) & 0xff))
#define PcmciaModelFromControllerType(type) (((type) >> 8) & 0x3ffff)
#define PcmciaRevisionFromControllerType(type) ((type) >> 26)


// @@BEGIN_DDKSPLIT
//
// These are macros to manipulate the PcCardConfig type resource
// descriptors - which are set by configmgr when passing in override
// configurations.
//

//
// Type of the descriptor: 1 .. 0xFFFF
//
#define DPTYPE_PCMCIA_CONFIGURATION 0x1
#define DPTYPE_PCMCIA_MF_CONFIGURATION 0x2

//
// The device private structure for PC-Card configuration:
//
// Data[0] is configuration descriptior. Lay out below.
//   Byte 0: Configuration entry number (config index)
//   Byte 1: IO window flags
//   Byte 2: Type of configuration, hardcoded to DPTYPE_PCMCIA_CONFIGURATION
//   Byte 3: unused
//
// Data [1]:  Cardbase offset for first memory window, flags in upper byte
// Data [2]:  Cardbase offset for second memory window, flags in upper byte
//
//
// The device private structure for MF-Card configuration:
//
// Data[0] is configuration descriptior. Lay out below.
//   Byte 0: Configuration Option Register (config index)
//   Byte 1: Configuration and Status Register
//           Audio Enable (bit 3)
//   Byte 2: Type of configuration, hardcoded to DPTYPE_PCMCIA_MF_CONFIGURATION
//   Byte 3: Port Io resource descriptor index
//
// Data [1]:  Configuration Register base
// Data [2]:  Unused
//

//
// Macros for manipulating the IoResource device privates
//
#define PCMRES_SET_DESCRIPTOR_TYPE(IoResourceDesc, Type)    (IoResourceDesc)->u.DevicePrivate.Data[0] |= ((Type) << sizeof(UCHAR)*8*2)
#define PCMRES_GET_DESCRIPTOR_TYPE(IoResourceDesc) ((UCHAR) ((IoResourceDesc)->u.DevicePrivate.Data[0] >> sizeof(UCHAR)*8*2))

//
// Macros specific to DPTYPE_PCMCIA_CONFIGURATION
//

#define PCMRES_SET_CONFIG_INDEX(desc, ConfigIndex) (desc)->u.DevicePrivate.Data[0] |= ConfigIndex
#define PCMRES_GET_CONFIG_INDEX(desc)    ((UCHAR) ((desc)->u.DevicePrivate.Data[0]))
//
// Define maximum indeces for i/o and memory
//

#define PCMRES_PCMCIA_MAX_IO 2
#define PCMRES_PCMCIA_MAX_MEM 2

//
// Flag definitions for Data[0]
//

#define PCMRESF_IO_16BIT_ACCESS  0x00000100
#define PCMRESF_IO_ZERO_WAIT_8   0x00000200
#define PCMRESF_IO_SOURCE_16     0x00000400
#define PCMRESF_IO_WAIT_16       0x00000800
#define PCMRESF_IO_FLAGS_2       0x0000F000              // used by second window

#define PCMRESF_PCMCIA_TYPE_2    0x80000000              // new format indicator

//
// Flag definitions for Data[1], Data[2]
//

#define PCMRES_BASE64MB_MASK     0x03ffffff

#define PCMRESF_MEM_16BIT_ACCESS 0x04000000
#define PCMRESF_MEM_ATTRIBUTE    0x08000000
#define PCMRESF_MEM_WAIT_1       0x10000000
#define PCMRESF_MEM_WAIT_2       0x20000000
#define PCMRESF_MEM_WAIT_3       0x30000000

//
// Macros specific to DPTYPE_PCMCIA_CONFIGURATION
//


#define PCMRES_SET_IO_FLAG(desc, index, flag) (desc)->u.DevicePrivate.Data[0] |= (flag << (index * 4))
#define PCMRES_GET_IO_FLAG(desc, index, flag) (((desc)->u.DevicePrivate.Data[0] & (flag << (index * 4))) != 0)
 
#define PCMRES_SET_MEMORY_FLAG(desc, index, flag) (desc)->u.DevicePrivate.Data[index+1] |= flag 
#define PCMRES_GET_MEMORY_FLAG(desc, index, flag) (((desc)->u.DevicePrivate.Data[index+1] & flag) != 0)

#define PCMRES_SET_MEMORY_CARDBASE(desc, index, base)  (desc)->u.DevicePrivate.Data[index+1] |= (base & PCMRES_BASE64MB_MASK)
#define PCMRES_GET_MEMORY_CARDBASE(desc, index)       ((ULONG) ((desc)->u.DevicePrivate.Data[index+1] & PCMRES_BASE64MB_MASK))

#define PCMRES_SET_MEMORY_WAITSTATES PCMRES_SET_MEMORY_FLAG
#define PCMRES_GET_MEMORY_WAITSTATES(desc, index) ((UCHAR) (((desc)->u.DevicePrivate.Data[index+1] >> 28)) & 3)


//
// Macros specific to DPTYPE_PCMCIA_MF_CONFIGURATION
//

#define PCMRESF_AUDIO_ENABLE     0x00000800
#define PCMRES_MF_PORT_INDEX_SHIFT   24

#define PCMRES_SET_CONFIG_OPTIONS(desc, opt)      (desc)->u.DevicePrivate.Data[0] |= opt
#define PCMRES_GET_CONFIG_OPTIONS(desc) ((UCHAR) ((desc)->u.DevicePrivate.Data[0]))

#define PCMRES_SET_PORT_RESOURCE_INDEX(desc, Index)    (desc)->u.DevicePrivate.Data[0] |= ((Index) << PCMRES_MF_PORT_INDEX_SHIFT)
#define PCMRES_GET_PORT_RESOURCE_INDEX(desc) ((UCHAR) ((desc)->u.DevicePrivate.Data[0] >> PCMRES_MF_PORT_INDEX_SHIFT))

#define PCMRES_SET_AUDIO_ENABLE(desc)           (desc)->u.DevicePrivate.Data[0] |= PCMRESF_AUDIO_ENABLE
#define PCMRES_GET_AUDIO_ENABLE(desc) ((UCHAR) ((desc)->u.DevicePrivate.Data[0] &  PCMRESF_AUDIO_ENABLE) != 0)

#define PCMRES_SET_CONFIG_REGISTER_BASE(desc, cfgbase)  (desc)->u.DevicePrivate.Data[1] = cfgbase
#define PCMRES_GET_CONFIG_REGISTER_BASE(desc)          ((desc)->u.DevicePrivate.Data[1])

//
// The following macros are in the process of being obseleted
//

#define IORES_SET_DESCRIPTOR_TYPE PCMRES_SET_DESCRIPTOR_TYPE 
#define IORES_GET_DESCRIPTOR_TYPE PCMRES_GET_DESCRIPTOR_TYPE 

#define IORES_SET_CONFIG_INDEX PCMRES_SET_CONFIG_INDEX 
#define IORES_GET_CONFIG_INDEX PCMRES_GET_CONFIG_INDEX 

#define IORES_SET_IO_16BIT_ACCESS(desc)         PCMRES_SET_IO_FLAG(desc, 0, PCMRESF_IO_16BIT_ACCESS)
#define IORES_GET_IO_16BIT_ACCESS(desc)         PCMRES_GET_IO_FLAG(desc, 0, PCMRESF_IO_16BIT_ACCESS)
#define IORES_SET_IO_8BIT_ACCESS(desc)           
#define IORES_SET_IO_ZERO_WAIT_8(desc)          PCMRES_SET_IO_FLAG(desc, 0, PCMRESF_IO_ZERO_WAIT_8)
#define IORES_SET_IO_SOURCE_16(desc)            PCMRES_SET_IO_FLAG(desc, 0, PCMRESF_IO_SOURCE_16)
#define IORES_SET_IO_WAIT_16(desc)              PCMRES_SET_IO_FLAG(desc, 0, PCMRESF_IO_WAIT_16)
#define IORES_GET_IO_ZERO_WAIT_8(desc)          PCMRES_GET_IO_FLAG(desc, 0, PCMRESF_IO_ZERO_WAIT_8) 
#define IORES_GET_IO_SOURCE_16(desc)            PCMRES_GET_IO_FLAG(desc, 0, PCMRESF_IO_SOURCE_16)   
#define IORES_GET_IO_WAIT_16(desc)              PCMRES_GET_IO_FLAG(desc, 0, PCMRESF_IO_WAIT_16)     
#define IORES_SET_MEM_16BIT_ACCESS(desc)        PCMRES_SET_MEMORY_FLAG(desc, 0, PCMRESF_MEM_16BIT_ACCESS)
#define IORES_GET_MEM_16BIT_ACCESS(desc)        PCMRES_GET_MEMORY_FLAG(desc, 0, PCMRESF_MEM_16BIT_ACCESS)
#define IORES_SET_MEM_8BIT_ACCESS(desc)   
#define IORES_SET_MEM_1_ATTRIBUTE_ACCESS(desc)  PCMRES_SET_MEMORY_FLAG(desc, 0, PCMRESF_MEM_ATTRIBUTE)
#define IORES_GET_MEM_1_ATTRIBUTE_ACCESS(desc)  PCMRES_GET_MEMORY_FLAG(desc, 0, PCMRESF_MEM_ATTRIBUTE)
#define IORES_SET_MEM_2_ATTRIBUTE_ACCESS(desc)  PCMRES_SET_MEMORY_FLAG(desc, 1, PCMRESF_MEM_ATTRIBUTE)
#define IORES_GET_MEM_2_ATTRIBUTE_ACCESS(desc)  PCMRES_GET_MEMORY_FLAG(desc, 1, PCMRESF_MEM_ATTRIBUTE)
#define IORES_SET_MEMORY_CARDBASE_1(desc, base) PCMRES_SET_MEMORY_CARDBASE(desc, 0, base)
#define IORES_GET_MEMORY_CARDBASE_1(desc)       PCMRES_GET_MEMORY_CARDBASE(desc, 0)
#define IORES_SET_MEMORY_CARDBASE_2(desc, base) PCMRES_SET_MEMORY_CARDBASE(desc, 1, base)
#define IORES_GET_MEMORY_CARDBASE_2(desc)       PCMRES_GET_MEMORY_CARDBASE(desc, 1)      
#define IORES_SET_MEM_WAIT_ONE(desc)            PCMRES_SET_MEMORY_WAITSTATES(desc, 0, PCMRESF_MEM_WAIT_1)
#define IORES_SET_MEM_WAIT_TWO(desc)            PCMRES_SET_MEMORY_WAITSTATES(desc, 0, PCMRESF_MEM_WAIT_2)
#define IORES_SET_MEM_WAIT_THREE(desc)          PCMRES_SET_MEMORY_WAITSTATES(desc, 0, PCMRESF_MEM_WAIT_3)
#define IORES_GET_MEM_WAIT(desc)                PCMRES_GET_MEMORY_WAITSTATES(desc, 0)

#define IORES_SET_CONFIG_OPTIONS       PCMRES_SET_CONFIG_OPTIONS      
#define IORES_GET_CONFIG_OPTIONS       PCMRES_GET_CONFIG_OPTIONS      
#define IORES_SET_PORT_RESOURCE_INDEX  PCMRES_SET_PORT_RESOURCE_INDEX 
#define IORES_GET_PORT_RESOURCE_INDEX  PCMRES_GET_PORT_RESOURCE_INDEX 
#define IORES_SET_AUDIO_ENABLE         PCMRES_SET_AUDIO_ENABLE        
#define IORES_GET_AUDIO_ENABLE         PCMRES_GET_AUDIO_ENABLE        
#define IORES_SET_CONFIG_REGISTER_BASE PCMRES_SET_CONFIG_REGISTER_BASE
#define IORES_GET_CONFIG_REGISTER_BASE PCMRES_GET_CONFIG_REGISTER_BASE

#define CMRES_SET_DESCRIPTOR_TYPE      IORES_SET_DESCRIPTOR_TYPE
#define CMRES_GET_DESCRIPTOR_TYPE      IORES_GET_DESCRIPTOR_TYPE

#define CMRES_SET_CONFIG_INDEX         IORES_SET_CONFIG_INDEX
#define CMRES_GET_CONFIG_INDEX         IORES_GET_CONFIG_INDEX

#define CMRES_SET_IO_16BIT_ACCESS      IORES_SET_IO_16BIT_ACCESS
#define CMRES_GET_IO_16BIT_ACCESS      IORES_GET_IO_16BIT_ACCESS
#define CMRES_SET_IO_8BIT_ACCESS       IORES_SET_IO_8BIT_ACCESS

#define CMRES_SET_IO_ZERO_WAIT_8       IORES_SET_IO_ZERO_WAIT_8
#define CMRES_SET_IO_SOURCE_16         IORES_SET_IO_SOURCE_16
#define CMRES_SET_IO_WAIT_16           IORES_SET_IO_WAIT_16
#define CMRES_GET_IO_ZERO_WAIT_8       IORES_GET_IO_ZERO_WAIT_8
#define CMRES_GET_IO_SOURCE_16         IORES_GET_IO_SOURCE_16
#define CMRES_GET_IO_WAIT_16           IORES_GET_IO_WAIT_16

#define CMRES_SET_MEM_16BIT_ACCESS     IORES_SET_MEM_16BIT_ACCESS
#define CMRES_GET_MEM_16BIT_ACCESS     IORES_GET_MEM_16BIT_ACCESS
#define CMRES_SET_MEM_8BIT_ACCESS      IORES_SET_MEM_8BIT_ACCESS

#define CMRES_SET_MEM_WAIT_ONE         IORES_SET_MEM_WAIT_ONE
#define CMRES_SET_MEM_WAIT_TWO         IORES_SET_MEM_WAIT_TWO
#define CMRES_SET_MEM_WAIT_THREE       IORES_SET_MEM_WAIT_THREE
#define CMRES_GET_MEM_WAIT             IORES_GET_MEM_WAIT

#define CMRES_SET_MEM_1_ATTRIBUTE_ACCESS IORES_SET_MEM_1_ATTRIBUTE_ACCESS 
#define CMRES_GET_MEM_1_ATTRIBUTE_ACCESS IORES_GET_MEM_1_ATTRIBUTE_ACCESS 
#define CMRES_SET_MEM_2_ATTRIBUTE_ACCESS IORES_SET_MEM_2_ATTRIBUTE_ACCESS 
#define CMRES_GET_MEM_2_ATTRIBUTE_ACCESS IORES_GET_MEM_2_ATTRIBUTE_ACCESS 

#define CMRES_SET_MEMORY_CARDBASE_1    IORES_SET_MEMORY_CARDBASE_1
#define CMRES_GET_MEMORY_CARDBASE_1    IORES_GET_MEMORY_CARDBASE_1
#define CMRES_SET_MEMORY_CARDBASE_2    IORES_SET_MEMORY_CARDBASE_2
#define CMRES_GET_MEMORY_CARDBASE_2    IORES_GET_MEMORY_CARDBASE_2

#define CMRES_SET_CONFIG_OPTIONS       IORES_SET_CONFIG_OPTIONS
#define CMRES_GET_CONFIG_OPTIONS       IORES_GET_CONFIG_OPTIONS
#define CMRES_SET_PORT_RESOURCE_INDEX  IORES_SET_PORT_RESOURCE_INDEX
#define CMRES_GET_PORT_RESOURCE_INDEX  IORES_GET_PORT_RESOURCE_INDEX
#define CMRES_SET_AUDIO_ENABLE         IORES_SET_AUDIO_ENABLE
#define CMRES_GET_AUDIO_ENABLE         IORES_GET_AUDIO_ENABLE
#define CMRES_SET_CONFIG_REGISTER_BASE IORES_SET_CONFIG_REGISTER_BASE
#define CMRES_GET_CONFIG_REGISTER_BASE IORES_GET_CONFIG_REGISTER_BASE

//
// Begin pcmcia exported interfaces to other drivers
//
// @@END_DDKSPLIT

#ifdef _NTDDK_

DEFINE_GUID( GUID_PCMCIA_INTERFACE_STANDARD,     0xbed5dadfL, 0x38fb, 0x11d1, 0x94, 0x62, 0x00, 0xc0, 0x4f, 0xb9, 0x60, 0xee);

#define  PCMCIA_MEMORY_8BIT_ACCESS     0
#define  PCMCIA_MEMORY_16BIT_ACCESS    1

typedef
BOOLEAN
(*PPCMCIA_MODIFY_MEMORY_WINDOW)(
                               IN   PVOID Context,
                               IN   ULONGLONG HostBase,
                               IN   ULONGLONG CardBase,
                               IN   BOOLEAN Enable,
                               IN   ULONG   WindowSize OPTIONAL,
                               IN   UCHAR   AccessSpeed OPTIONAL,
                               IN   UCHAR   BusWidth OPTIONAL,
                               IN   BOOLEAN IsAttributeMemory OPTIONAL
                               );

#define     PCMCIA_VPP_0V     0
#define     PCMCIA_VPP_12V    1
#define     PCMCIA_VPP_IS_VCC 2

typedef
BOOLEAN
(*PPCMCIA_SET_VPP)(
                  IN  PVOID Context,
                  IN  UCHAR VppLevel
                  );

typedef
BOOLEAN
(*PPCMCIA_IS_WRITE_PROTECTED)(
                             IN PVOID Context
                             );

//
// These are interfaces for manipulating memory windows, setting Vpp etc.,
// primarily used by flash memory card drivers
//
typedef struct _PCMCIA_INTERFACE_STANDARD {
   USHORT Size;
   USHORT Version;
   PINTERFACE_REFERENCE InterfaceReference;
   PINTERFACE_DEREFERENCE  InterfaceDereference;
   PVOID Context;
   PPCMCIA_MODIFY_MEMORY_WINDOW ModifyMemoryWindow;
   PPCMCIA_SET_VPP           SetVpp;
   PPCMCIA_IS_WRITE_PROTECTED     IsWriteProtected;
} PCMCIA_INTERFACE_STANDARD, *PPCMCIA_INTERFACE_STANDARD;

//
// Definitions for PCMCIA_BUS_INTERFACE_STANDARD.
// This interface is obtained using GUID_PCMCIA_BUS_INTERFACE_STANDARD
// and is used for reading/writing to PCMCIA config. space
//

typedef
ULONG
(*PPCMCIA_READ_WRITE_CONFIG) (
                             IN PVOID   Context,
                             IN ULONG   WhichSpace,
                             IN PUCHAR  Buffer,
                             IN ULONG   Offset,
                             IN ULONG   Length
                             );
//
// WhichSpace for IRP_MN_READ_CONFIG/WRITE_CONFIG
// and PCMCIA_BUS_INTERFACE_STANDARD
//
typedef ULONG MEMORY_SPACE;

#define    PCCARD_PCI_CONFIGURATION_SPACE    0  // for cardbus cards
#define    PCCARD_ATTRIBUTE_MEMORY           1
#define    PCCARD_COMMON_MEMORY              2
#define    PCCARD_ATTRIBUTE_MEMORY_INDIRECT  3
#define    PCCARD_COMMON_MEMORY_INDIRECT     4

// Legacy support
//
#define    PCMCIA_CONFIG_SPACE               PCCARD_ATTRIBUTE_MEMORY

typedef struct _PCMCIA_BUS_INTERFACE_STANDARD {
   //
   // generic interface header
   //
   USHORT Size;
   USHORT Version;
   PVOID Context;
   PINTERFACE_REFERENCE InterfaceReference;
   PINTERFACE_DEREFERENCE InterfaceDereference;
   //
   // standard PCMCIA bus interfaces
   //
   PPCMCIA_READ_WRITE_CONFIG ReadConfig;
   PPCMCIA_READ_WRITE_CONFIG WriteConfig;
} PCMCIA_BUS_INTERFACE_STANDARD, *PPCMCIA_BUS_INTERFACE_STANDARD;

#endif

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntddsjoy.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    swndr3p.h

Abstract:

    Definitions of all constants and types for the Sidewinder 3p joystick.

Author:

    edbriggs 30-Nov-95


Revision History:


--*/


#ifndef __NTDDSJOY_H__
#define __NTDDSJOY_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define UnusedParameter(x) x = x



//
// Device Name
//

#define JOY_DD_DEVICE_NAME       "\\Device\\IBMJOY"
#define JOY_DD_DEVICE_NAME_U    L"\\Device\\IBMJOY"


//
// Device Parameters
//

#define JOY_DD_NAXES             "NumberOfAxes"
#define JOY_DD_NAXES_U          L"NumberOfAxes"

#define JOY_DD_DEVICE_TYPE       "DeviceType"
#define JOY_DD_DEVICE_TYPE_U    L"DeviceType"

#define JOY_DD_DEVICE_ADDRESS    "DeviceAddress"
#define JOY_DD_DEVICE_ADDRESS_U L"DeviceAddress"




//
// Device Types
//

#define JOY_TYPE_UNKNOWN       0x00
#define JOY_TYPE_SIDEWINDER    0x01

//
// Device I/O Port Address
//

#define JOY_IO_PORT_ADDRESS    0x201

//
// Device specific bitmasks
//


#define X_AXIS_BITMASK	0x01
#define CLOCK_BITMASK	0x10
#define DATA0_BITMASK	0x20
#define DATA1_BITMASK	0x40
#define DATA2_BITMASK	0x80
#define ALLDATA_BITMASK	0xE0
#define ALLAXIS_BITMASK 0x0F


//
// Analog joystick bitmasks
//

#define JOYSTICK2_BUTTON2   0x80
#define JOYSTICK2_BUTTON1   0x40
#define JOYSTICK1_BUTTON2   0x20
#define JOYSTICK1_BUTTON1   0x10
#define JOYSTICK2_Y_MASK    0x08
#define JOYSTICK2_X_MASK    0x04
#define JOYSTICK1_R_MASK    0x08
#define JOYSTICK1_Z_MASK    0x04
#define JOYSTICK1_Y_MASK    0x02
#define JOYSTICK1_X_MASK    0x01


#define JOY_START_TIMERS    0


//
// Device specific timer values
//

#define ANALOG_POLL_TIMEOUT 5000            // 5 mS upper bound on analog polling
#define ANALOG_POLL_RESOLUTION  100         // 100 uS accuracy on polling time

#define ANALOG_XA_VERYSLOW	1500
#define	ANALOG_XA_SLOW		1200
#define ANALOG_XA_MEDIUM	900
#define ANALOG_XA_FAST		300
#define ANALOG_XA_VERYFAST	100

#define DIGITAL_XA_VERYSLOW	1100
#define	DIGITAL_XA_SLOW		700
#define DIGITAL_XA_MEDIUM	510
#define DIGITAL_XA_FAST		100
#define DIGITAL_XA_VERYFAST	50

#define GODIGITAL_BASEDELAY_VERYSLOW	25
#define GODIGITAL_BASEDELAY_SLOW	    50
#define GODIGITAL_BASEDELAY_MEDIUM	    75
#define GODIGITAL_BASEDELAY_FAST	    120
#define GODIGITAL_BASEDELAY_VERYFAST	130


//
// Device specific operating mode. Both INVALID_MODE and MAXIMUM_MODE are for
// assertion checking and do not correspond to real operating modes
//


#define SIDEWINDER3P_INVALID_MODE           0
#define SIDEWINDER3P_ANALOG_MODE            1
#define SIDEWINDER3P_DIGITAL_MODE           2
#define SIDEWINDER3P_ENHANCED_DIGITAL_MODE  3
#define SIDEWINDER3P_MAXIMUM_MODE           4


#define CLOCK_RISING_EDGE     0
#define CLOCK_FALLING_EDGE    1


//
// These constants define how polling errors will be handled
//

#define MAX_ENHANCEDMODE_ATTEMPTS   10


//
// Joystick position information is transfered from the device driver to other
// drivers or applications using the JOY_DD_INPUT_DATA structure. Since
// the type of data returned varies whether the device is in analog mode or
// digital mode, a union is formed to convey both types of data. The Mode
// variable allows the recipient of the data to determing how to interpret
// the data.
//


typedef struct {

    //
    // True if the device is unplugged. This is determined by a timeout
    // mechanism
    //
    BOOL    Unplugged;

    //
    // The mode is a value used to allow the recipient to determine how to
    // interpret the data and the union. Valid values are:
    //
    //         SIDEWINDER3P_ANALOG_MODE,
    //         SIDEWINDER3P_DIGITAL_MODE,
    //         SIDEWINDER3P_ENHANCED_DIGITAL_MODE
    //

    DWORD   Mode;


    union {

      //
      // Digital mode data packet
      //

        struct {

          //
          // Digital Positioning information values as follows
          //
          //  name     range        direction
          //  ----     -----        ---------
          //
          //  XOffset  [0..1024)    0 = leftmost, 1023 = rightmost
          //  YOffset  [0..1024)    0 = up,       1023 = down
          //  RzOffset [0..512)     0 = left,      511 = right
          //  TOffset  [0..1024)    Throttle position
          //

          WORD   XOffset;
          WORD   YOffset;
          WORD   RzOffset;
          WORD   TOffset;

          //
          // hat position. The hat is an eight position switch.
          // 0 = Not Pressed; 1 = 0 degrees, 2 = 45, 3 = 90 ... 8 = 315
          // 0 degrees is up.
          //

          BYTE   Hat;

          //
          // Button states. Buttons are bitmapped into the low order
          // bit 0 - 7.  Depressed = 0, released = 1.
          //

          BYTE   Buttons;

          //
          // Checksum for packet
          //

          BYTE   Checksum;

          //
          // Switch indicating whether we are emulating a CH Joystick or a
          // Thrustmaster Joystick.
          //

          BYTE   Switch_CH_TM;

          //
          // Driver Internal processing determines if the checksum and framing
          // of the packet are correct. The following boolean values reflect
          // the findings
          //

          BOOL   fChecksumCorrect;
          BOOL   fSyncBitsCorrect;

        } DigitalData;


      //
      // Analog mode data packet
      //

        struct {

          //
          // The number of axi configured for this device (specified in the
          // registry).
          //

          DWORD   Axi;

          //
          // current button state bitmask
          //

          DWORD   Buttons;

          //
          // X, Y, Z, and T axi positioning information contained below. The
          // values are expressed interms of microseconds. The values are
          // generated by measuring the duration of a pulse supplied by
          // the IBM compatable or Soundblaster game port. This is the raw
          // data, and it is the callers responsibility to perform
          // calibration, ranging, hysteresis, etc.
          //
          // Because of inaccuracies in sampling this data, there is some
          // variation in readings of a stationary joystick.
          //
          //
          // Analog Positioning information for Microsoft Sidewinder IIId P
          // values as follows (range information measured using a
          // Soundblaster analog game port.
          //
          //           apprx
          //  name     range        direction
          //  ----     -----        ---------
          //
          //  XTime  20..1600 uS    20 = leftmost, 1600 = rightmost
          //  YTime  20..1600 uS    20 = up,       1600 = down
          //  ZTime  20..1600 uS    20 = left,     1600 = right
          //  TTime  20..1600 uS    20 = forward   1600 = back
          //

          DWORD   XTime;   // Time in microseconds for X
          DWORD   YTime;   // Time in microseconds for Y
          DWORD   ZTime;   // Time in microseconds for Z if 3-axis
          DWORD   TTime;   // Time in microseconds for Throttle if 4 axis

        } AnalogData;

    } u;

} JOY_DD_INPUT_DATA, *PJOY_DD_INPUT_DATA;



//
// The following IOCTL codes are used for testing the device driver. They
// export internal functions of the driver which will not be needed in the
// final version of the driver
//

#define JOY_TYPE 40001

#define IOCTL_JOY_GET_DRIVER_MODE_DWORD \
    CTL_CODE( JOY_TYPE, 0x900, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_JOY_GET_DEVICE_MODE_DWORD \
    CTL_CODE( JOY_TYPE, 0x901, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_JOY_SET_DIGITAL_MODE \
    CTL_CODE( JOY_TYPE, 0x902, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_JOY_GET_STATISTICS \
    CTL_CODE( JOY_TYPE, 0x903, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_JOY_SET_ENHANCED_MODE \
    CTL_CODE( JOY_TYPE, 0x904, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_JOY_SET_ANALOG_MODE \
    CTL_CODE( JOY_TYPE, 0x905, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_JOY_GET_JOYREGHWCONFIG \
    CTL_CODE( JOY_TYPE, 0x906, METHOD_BUFFERED, FILE_READ_ACCESS)



typedef union
{
    BYTE    Byte;
    WORD    Word;
    DWORD   Dword;

} JOY_IOCTL_INFO, *PJOY_IOCTL_INFO;


typedef struct
{
    DWORD   Retries[MAX_ENHANCEDMODE_ATTEMPTS];
    DWORD   EnhancedPolls;
    DWORD   EnhancedPollTimeouts;
    DWORD   EnhancedPollErrors;
    DWORD   Frequency;
    DWORD   dwQPCLatency;
    LONG    nReadLoopMax;
    DWORD   nVersion;
    DWORD   nPolledTooSoon;
    DWORD   nReset;
} JOY_STATISTICS, *PJOY_STATISTICS;

#ifdef __cplusplus
}
#endif

#endif // __NTDDJOY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\oledbtyp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994-1999.
//
//  File:       oledbtyp.h
//
//  Contents:   Necessary type definitions for OLD-DB interfaces
//
//  Notes:	This file works around the fact that not everyone yet
//		has oleaut.h.
//		We just conditionally include the right type definitions
//		for whatever platform we're running on.
//
//  History:    25 Aug 94   Alanw	Created
//
//+---------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined( _VARNT_DEFINED )
#include <oaidl.h>
#endif //!defined( _VARNT_DEFINED )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\mstest.inc ===
'--------------------------------------------------------------------------
'
'  MSTEST.INC Version 2.00
'  API Declarations for TEST Tools
'
'  NOTE: All API are ALIAS'd to themselves to support NT
'        API Not yet supported under NT are IFDEF'd out using the
'        predefine symbol of NT.
'
'  To include the various portions of this file, any combination of the
'  following $DEFINE's must be used in your script prior to $INCLUDEing
'  MSTEST.INC:
'
'  i.e. IN YOUR SCRIPT add a line such as the following to DEFINE one of
'       the SYMBOLS below, so you only include what you need.
'
'  REM$ DEFINE MSTest         - to get everything in this include file
'  REM$ DEFINE TestCtrl       - to get ALL the TESTCTRL declarations etc.
'  REM$ DEFINE TestScrn       - to get ALL the TESTSCRN declarations etc.
'  REM$ DEFINE TestDlgs       - to get ALL the TESTDLGS declarations etc.
'  REM$ DEFINE TestEvnt       - to get ALL the TESTEVNT declarations etc.
'  REM$ DEFINE TestUI         - to get ALL the TESTUI   declarations etc.
'
' OR USE ANY OF THE FOLLOWING SYMBOLS TO GET PARTIAL
'
'     MSTEST: includes all of MSTEST.INC
'
'         TESTCTRL: includes all of TESTCTRL
'             W_MISC    TESTCTRL Miscellaneous routines
'             W_WINDOW  TESTCTRL Window routines
'             W_MENU    TESTCTRL Menu routines
'             W_ERROR:  TESTCTRL error routines
'             W_CONTROL: includes all of the control declares & routines
'                 W_BUTTON:  includes all of the BUTTON declares etc.
'                 W_CHECK:             "         CHECKBOX
'                 W_OPTION             "         OPTION BUTTON
'                 W_EDIT               "         EDIT CONTROL
'                 W_LIST               "         LIST BOX
'                 W_COMBO              "         COMBO BOX
'
'         TESTSCRN:  includes all of TESTSCRN, Declares & Error codes
'             TESTSCRN_DECL: includes all SCR Declares
'             TESTSCRN_ERRS: includes all SCR Error codes
'
'         TESTDLGS: includes all of TESTDLGS, Declares & Error codes
'             TESTDLGS_DECL: includes all DLGS Declares
'             TESTDLGS_ERRS: includes all DLGS Error codes
'
'         TESTEVNT: includes all TESTEVNT Declares
'
'     W_ERROR_TRAP: Just like W_ERROR, but includes a generic
'                   WErrorTrap to display WError and ErrorText
'                   NOTE: This is not included from any other define.
'
'  NOTE: Including MSTEST.INC without out using any of the above $DEFINE's
'        will include only TESTDRVR.EXE trappable and untrappable error
'        codes, and declares for CRLF, TRUE (-1), FALSE(0), Key values for
'        DoKeys() from TESTEVNT and few routines from TESTCtrl.
'
'---------------------------------------------------------------------------
'
'              Copyright (C) 1991-1992 Microsoft Corporation
'
'  You have a royalty-free right to use, modify, reproduce and distribute
'  this file (and/or any modified version) in any way you find useful,
'  provided that you agree that Microsoft has no warranty, obligation or
'  liability for its contents.  Refer to the Microsoft Windows Programmer's
'  Reference for further information.
'
'  This file is not garanteed by Microsoft to be error free.  Every effort
'  has been made to ensure proper data-types and declarations etc., but no
'  testing has been performed using this include file.  Additionally, some
'  API's, though listed, may not be compatible with the TESTDrvr language.
'
'----------------------------------------------------------------------------

'                                                       *********************
'$IFNDEF MSTEST_INCLUDED
'$DEFINE MSTEST_INCLUDED
'                                                       *********************

'----------------------------------------------------------------------------
' Generic Global Variables
'----------------------------------------------------------------------------
Global CRLF As String        ' UNDONE: Change to Const X = Chr$()
CRLF = Chr$(13) + Chr$(10)   '         once supported

Const TRUE  = -1
Const FALSE = 0


'----------------------------------------------------------------------------
' Unrecoverable TESTDRVR error codes
'----------------------------------------------------------------------------
Const ERR_STACK_OVERFLOW         = 0
Const ERR_STACK_UNDERFLOW        = 1
Const ERR_OUT_OF_STRING_SPACE    = 2
Const ERR_CANT_LOAD_TESTVIEW_DLL = 3
Const ERR_OUT_OF_MEMORY          = 4


'----------------------------------------------------------------------------
' Recoverable TESTDRVR error codes
'----------------------------------------------------------------------------
Const ERR_GOSUB_STACK_OVERFLOW   = 5
Const ERR_RETURN_WITHOUT_GOSUB   = 6
Const ERR_BAD_FILE_NUMBER        = 7
Const ERR_FILE_IO                = 8
Const ERR_RUN_CMD_TOO_LONG       = 9
Const ERR_SHELL_CMD_TOO_LONG     = 10
Const ERR_SETFILE                = 11
Const ERR_FILE_NUMBER_IN_USE     = 12
Const ERR_CANT_OPEN_FILE         = 13
Const ERR_ILLEGAL_FUNCTION_CALL  = 14
Const ERR_INVALID_PATH           = 15
Const ERR_INVALID_DRIVE          = 16
Const ERR_NO_CURRENT_WORKING_DIR = 17
Const ERR_BAD_RUN_CMD            = 18
Const ERR_DIVISION_BY_ZERO       = 19
Const ERR_CANT_LOAD_DLL          = 20
Const ERR_PROC_NOT_FOUND_IN_DLL  = 21
Const ERR_CANNOT_RESUME          = 22
Const ERR_MEM_ALLOC              = 23
Const ERR_INVALID_POINTER        = 24
Const ERR_INVALID_ALLOC_SIZE     = 25
Const ERR_NULL_PIONTER_REF       = 26
Const ERR_SUBSCRIPT_RANGE        = 27
Const ERR_INPUT_PAST_EOF         = 28
Const ERR_FILELIST_PROC          = 29
Const ERR_INVALID_ATTRIBUTE      = 30

'$ifdef WINUSER_SHOW_COMMANDS AND NOT NT

'----------------------------------------------------------------------------
' RUN statement Show commands: RUN "command"[, [NOWAIT][, ShowCommand]]
' NOTE:  These are the same as the SW_ constants in Windows.h
'----------------------------------------------------------------------------
Const SW_HIDE            = 0
Const SW_SHOWNORMAL      = 1
Const SW_NORMAL          = 1
Const SW_SHOWMINIMIZED   = 2
Const SW_SHOWMAXIMIZED   = 3
Const SW_MAXIMIZE        = 3
Const SW_SHOWNOACTIVATE  = 4
Const SW_SHOW            = 5
Const SW_MINIMIZE        = 6
Const SW_SHOWMINNOACTIVE = 7
Const SW_SHOWNA          = 8
Const SW_RESTORE         = 9

'$endif WINUSER_SHOW_COMMANDS AND NOT NT

'----------------------------------------------------------------------------
' Key contants used with WKey, PlayKeys, & PlayKeyshWnd
'----------------------------------------------------------------------------
Const K_ENTER  = "{ENTER}"
Const K_ESC    = "{ESC}"
Const K_UP     = "{UP}"
Const K_DOWN   = "{DOWN}"
Const K_LEFT   = "{LEFT}"
Const K_RIGHT  = "{RIGHT}"
Const K_END    = "{END}"
Const K_PGUP   = "{PGUP}"
Const K_PGDN   = "{PGDN}"
Const K_INSERT = "{INSERT}"
Const K_INS    = "{INSERT}"
Const K_DELETE = "{DELETE}"
Const K_DEL    = "{DELETE}"
Const K_HOME   = "{HOME}"
Const K_TAB    = "{TAB}"
Const K_BS     = "{BS}"
Const K_F1     = "{F1}"
Const K_F2     = "{F2}"
Const K_F3     = "{F3}"
Const K_F4     = "{F4}"
Const K_F5     = "{F5}"
Const K_F6     = "{F6}"
Const K_F7     = "{F7}"
Const K_F8     = "{F8}"
Const K_F9     = "{F9}"
Const K_F10    = "{F10}"
Const K_F11    = "{F11}"
Const K_F12    = "{F12}"
Const K_F13    = "{F13}"
Const K_F14    = "{F14}"
Const K_F15    = "{F15}"
Const K_F16    = "{F16}"
Const K_SHIFT  = "+"
Const K_CTRL   = "^"
Const K_ALT    = "%"

' TESTCtrl API & Constants that are always declared.
'
' WGetFocus() simply preforms the exact function as the windows
' GetFocus() API.  Is contained in TESTCtrl since it is such a
' commonly used API in scripts, and it makes it much easier to
' use since it is defined simply by including MSTEST.INC.  It is
' renamed to prevent duplicate definitions due to scripts that
' do define GetFocus() and include MSTEST.INC.
'---------------------------------------------------------------
Declare Function WGetFocus    Lib "TESTCtrl.dll" Alias "WGetFocus"    () As Integer
Declare Sub      WSetActWnd   Lib "TESTCtrl.dll" Alias "WSetActWnd"   (hWnd%)
Declare Function WGetActWnd   Lib "TESTCtrl.dll" Alias "WGetActWnd"   (hWnd%) As Integer
Declare Function WFndWnd      Lib "TESTCtrl.dll" Alias "WFndWnd"      (lpszCaption$, wFlags%) As Integer
Declare Function WFndWndC     Lib "TESTCtrl.dll" Alias "WFndWndC"     (lpszText$, lpszClass$, wFlags%) As Integer
Declare Function WFndWndWait  Lib "TESTCtrl.dll" Alias "WFndWndWait"  (lpszCaption$, wFlags%, wSeconds%) As Integer
Declare Function WFndWndWaitC Lib "TESTCtrl.dll" Alias "WFndWndWaitC" (lpszText$, lpszClass$, wFlags%, wSeconds%) As Integer

Const FW_DEFAULT     = &h0000  'Default
Const FW_RESTOREICON = &h0081  '&h0080 Or FW_FOCUS
Const FW_NOEXIST     = &h0040
Const FW_EXIST       = &h0000  'Default
Const FW_CHILDNOTOK  = &h0020
Const FW_CHILDOK     = &h0000  'Default
Const FW_HIDDENOK    = &h0010
Const FW_HIDDENNOTOK = &h0000  'Default
Const FW_ACTIVE      = &h0008
Const FW_ALL         = &h0000  'Default
Const FW_CASE        = &h0004
Const FW_NOCASE      = &h0000  'Default
Const FW_PART        = &h0002
Const FW_FULL        = &h0000  'Default
Const FW_FOCUS       = &h0001
Const FW_NOFOCUS     = &h0000  'Default

' TESTEvnt API that are always defined.
'--------------------------------------
Declare Sub DoKeys     Lib "TESTEvnt.Dll" Alias "DoKeys" (lpStr$)
Declare Sub DoKeysHwnd Lib "TESTEvnt.Dll" Alias "DoKeyshWnd" (hWnd%, lpStr$)

' Useful function when working with the Windows API,
' to extract the HI/LO wordt from a Long Integer.
'---------------------------------------------------
Declare Function HIWORD(LongVar&) As Integer
Function HIWORD (LongVar&) Static As Integer
    HIWORD = LongVar& / 65536
End Function

Declare Function LOWORD(LongVar&) As Integer
Function LOWORD (LongVar&) Static As Integer
    LOWORD = LongVar& And &H0000FFFF
End Function

' Useful function when working with the Windows API,
' to extract the HI/LO byte from am Integer.
'---------------------------------------------------
Declare Function HIBYTE(IntVar%) As Integer
Function HIBYTE (IntVar%) Static As Integer
    HIBYTE = IntVar% / 256
End Function

Declare Function LOBYTE(IntVar%) As Integer
Function LOBYTE (IntVar%) Static As Integer
    LOBYTE = IntVar% And &H00FF
End Function

'                                                       *********************
'$ENDIF MSTEST_INCLUDED
'                                                       *********************

'----------------------------------------------------------------------------
'  DEFINE's that control the inclusion of the remainder of MSTEST.INC
'----------------------------------------------------------------------------
'$IFDEF MSTEST
    '$DEFINE TESTCTRL
    '$DEFINE TESTSCRN
    '$DEFINE TESTDLGS
    '$DEFINE TESTEVNT
    '$DEFINE TESTUI
'$ENDIF

'$IFDEF TESTCTRL
    '$DEFINE W_MISC
    '$DEFINE W_WINDOW
    '$DEFINE W_MENU
    '$DEFINE W_ERROR
    '$DEFINE W_CONTROL
'$ENDIF

'$IFDEF W_ERROR_TRAP
    '$DEFINE W_ERROR
'$ENDIF

'$IFDEF W_CONTROL
    '$DEFINE W_BUTTON
    '$DEFINE W_CHECK
    '$DEFINE W_OPTION
    '$DEFINE W_EDIT
    '$DEFINE W_LIST
    '$DEFINE W_COMBO
'$ENDIF

'$IFDEF TESTSCRN
    '$DEFINE TESTSCRN_DECL
    '$DEFINE TESTSCRN_ERRS
'$ENDIF

'$IFDEF TESTDLGS
    '$DEFINE TESTDLGS_DECL
    '$DEFINE TESTDLGS_ERRS
'$ENDIF

'$IFDEF  W_BUTTON OR W_CHECK OR W_OPTION OR W_EDIT OR W_LIST OR W_COMBO
    '$DEFINE W_A_CONTROL
'$ENDIF

'                                                       *********************
'$IFDEF TESTUI AND NOT TESTUI_INCLUDED AND NOT NT
'                                                       *********************
'----------------------------------------------------------------------------
' TESTUI.dll:
'   Function declarations for use with TESTUI
'----------------------------------------------------------------------------
Declare Function DlgBox         Lib "TESTUI.dll" Alias "DlgBox"         (DlgId%,  hwndOwner%, proc As CallBack, ResFile$) As Integer
Declare Function DlgBox3D       Lib "TESTUI.dll" Alias "DlgBox3D"       (DlgId%,  hwndOwner%, proc As CallBack, ResFile$) As Integer
Declare Function SetScriptMenu  Lib "TESTUI.dll" Alias "SetScriptMenu"  (MenuId%, hwnd%, ResFile$) As Integer
Declare Function SetIconBar     Lib "TESTUI.dll" Alias "SetIconBar"     (IconBarId%, proc As Callback, AppName$, ResFile$, fAlwaysOnTop%) As Integer
Declare Function SetSysMenu     Lib "TESTUI.dll" Alias "SetSysMenu"     (MenuId%, proc As Callback, AppName$, ResFile$) As Integer
Declare Function SetSysMenu3D   Lib "TESTUI.dll" Alias "SetSysMenu3D"   (MenuId%, proc As Callback, AppName$, ResFile$) As Integer
Declare Function MSTLoadIcon    Lib "TESTUI.dll" Alias "MSTLoadIcon"    (IconId%, ResFile$) As Integer
Declare Sub      MSTDestroyIcon Lib "TESTUI.dll" Alias "MSTDestroyIcon" (hIcon%)

'                                                       *********************
'$DEFINE TESTUI_INCLUDED
'$ENDIF
'$IFDEF W_MISC AND NOT W_MISC_INCLUDED
'                                                       *********************


'----------------------------------------------------------------------------
' W_MISC:  Miscellanious Routines, types and Constants.
'----------------------------------------------------------------------------
Const MAX_CAPTION = 128

Type INFO
    hWnd            As Integer
    hWndParent      As Integer
    szClass         As String * MAX_CAPTION
    szCaption       As String * MAX_CAPTION
    szParentClass   As String * MAX_CAPTION
    szParentCaption As String * MAX_CAPTION
    szModuleName    As String * MAX_CAPTION
    lStyle          As Long
    fChild          As Integer
    wID             As Integer
    wLeft           As Integer
    wTop            As Integer
    wRight          As Integer
    wBottom         As Integer
    wWidth          As Integer
    wHeight         As Integer
End Type

' The 4 WMessage[W|L] API are slight variations on the windows
' SendMessage() API.  Two things are provided:
'
'   Validation of hWnd%: - If invalid an error value that
'                          is trappable by WErrorTrap is
'                        - If hWnd is NULL, the message goes
'                          to the ActiveWindow.
'   Only need paramaters: Pass in only the paramaters that are needed:
'       WMessage:   Wp and Lp are set to zero
'       WMessageW:  Lp is set to zero
'       WMessageL:  Wp is set to zero
'       WMessageWL: just like SendMessage() but with hWnd validation
'---------------------------------------------------------------------
Declare Function WMessage       Lib "TESTCtrl.dll" Alias "WMessage"       (hWnd%, wMsg%)
Declare Function WMessageW      Lib "TESTCtrl.dll" Alias "WMessageW"      (hWnd%, wMsg%, wp%)
Declare Function WMessageL      Lib "TESTCtrl.dll" Alias "WMessageL"      (hWnd%, wMsg%, lp As Any)
Declare Function WMessageWL     Lib "TESTCtrl.dll" Alias "WMessageWL"     (hWnd%, wMsg%, wp%, lp As Any)
Declare Function WIsVisible     Lib "TESTCtrl.dll" Alias "WIsVisible"     (hWnd%) As Integer
Declare Function WTextLen       Lib "TESTCtrl.dll" Alias "WTextLen"       (hWnd%) As Long
Declare Sub      WGetText       Lib "TESTCtrl.dll" Alias "WGetText"       (hWnd%, lpszBuffer$)
Declare Sub      WSetText       Lib "TESTCtrl.dll" Alias "WSetText"       (hWnd%, lpszText$)
Declare Function WNumAltKeys    Lib "TESTCtrl.dll" Alias "WNumAltKeys"    () As Integer
Declare Sub      WGetAltKeys    Lib "TESTCtrl.dll" Alias "WGetAltKeys"    (lpszBuff$)
Declare Function WNumDupAltKeys Lib "TESTCtrl.dll" Alias "WNumDupAltKeys" () As Integer
Declare Sub      WGetDupAltKeys Lib "TESTCtrl.dll" Alias "WGetDupAltKeys" (lpszBuff$)
Declare Sub      WDisplayInfo   Lib "TESTCtrl.dll" Alias "WDisplayInfo"   (hWnd%, wDisplay%)
Declare Sub      WGetInfo       Lib "TESTCtrl.dll" Alias "WGetInfo"       (hWnd%, lpInfo As INFO)

' Layered routines to simulate string functions for the coresponding
' TESTCtrl API
'----------------------------------------------------------------------------
Declare Function GetText       (hWnd%) As String
Declare Function GetAltKeys    () As String
Declare Function GetDupAltKeys () As String

Const DI_DIALOG  = 1
Const DI_DEBUG   = 2
Const DI_BOTH    = 3

'----------------------------------------------------------------------------
' GetText: Layered routine for WGetText()
'----------------------------------------------------------------------------
Function GetText(hWnd%) Static As String
Dim lpszBuffer As String
Dim textLength As Long
    GetText = ""
    textLength = WTextLen(hWnd%)
    If textLength > 0 Then
        lpszBuffer = String$(textLength+1, " ")
        WGetText hWnd%, lpszBuffer
        GetText = lpszBuffer
    End If
    lpszBuffer = ""
End Function

'----------------------------------------------------------------------------
' GetAltKeys: Layered routine for WGetAltKeys()
'----------------------------------------------------------------------------
Function GetAltKeys() Static As String
Dim lpszBuffer As String
    lpszBuffer = String$(WNumAltKeys()+1, " ")
    WGetAltKeys lpszBuffer
    GetAltKeys = lpszBuffer
    lpszBuffer = ""
End Function

'----------------------------------------------------------------------------
' GetDupAltKeys: Layered routine for WGetDupAltKeys()
'----------------------------------------------------------------------------
Function GetDupAltKeys() Static As String
Dim lpszBuffer As String
    lpszBuffer = String$(WNumDupAltKeys()+1, " ")
    WGetDupAltKeys lpszBuffer
    GetDupAltKeys = lpszBuffer
    lpszBuffer = ""
End Function

'                                                       *********************
'$DEFINE W_MISC_INCLUDED
'$ENDIF
'$IFDEF TESTEVNT AND NOT TESTEVNT_INCLUDED
'                                                       *********************

'----------------------------------------------------------------------------
' TESTEvnt.Dll:
'   Function declarations for use with TESTEvnt
'----------------------------------------------------------------------------
'$IFNDEF NT

TYPE  MEMORYINFO
    LargestAvail        AS LONG     ' Largest available free block in bytes
    MaxPagesUnlock      AS LONG     ' Maximum unlocked page allocation in pages
    MaxPagesLocked      AS LONG     ' Maximum locked page allocation in pages
    TotalLinBytes       AS LONG     ' Linear address space size in bytes
    TotalUnlockBytes    AS LONG     ' Total number of unlocked bytes
    TotalFreePhysBytes  AS LONG     ' Total number of free physical bytes
    TotalPhysBytes      AS LONG     ' Total number of physical bytes
    FreeLinBytes        AS LONG     ' Free linear address space in bytes
    SwapFileSize        AS LONG     ' Size of paging file/partition in bytes
    Reserved1           AS LONG     ' reserved for future expansion, all bits set
    Reserved2           AS LONG     ' reserved for future expansion, all bits set
    Reserved3           AS LONG     ' reserved for future expansion, all bits set
    Reserved4           AS LONG     ' reserved for future expansion, all bits set
    NumSelectors        AS INTEGER  ' Total number of selectors on current LDT
    NumFreeSelectors    AS INTEGER  ' Number of free selectors on current LDT
    GlobalHeapFree      AS LONG     ' Number of free Global bytes
    USERHeapFree        AS LONG     ' Number of free bytes in USER.EXE's heap
    GDIHeapFree         AS LONG     ' Number of free bytes in GDI.EXE's heap
    SysResFree          AS INTEGER  ' *PERCENTAGE* of free system resources
END TYPE

Declare Sub      WaitUntilIdle        Lib "TESTEVNT.DLL" Alias "WaitUntilIdle"        ()
Declare Function GetMemoryInfo        Lib "TESTEvnt.Dll" Alias "GetMemoryInfo"        (lpMemInfo As MEMORYINFO) As Integer
Declare Function VMGetScreenCols      Lib "TESTEvnt.Dll" Alias "VMGetScreenCols"      (HWND%) As Integer
Declare Function VMGetCursPos         Lib "TESTEvnt.Dll" Alias "VMGetCursPos"         (HWND%) As Integer
Declare Function VMGetScreen          Lib "TESTEvnt.Dll" Alias "VMGetScreen"          (HWND%, UINT%, UINT%, UINT%, UINT%, LPSTR$) As Integer
Declare Function VMGetScreenClip      Lib "TESTEvnt.Dll" Alias "VMGetScreenClip"      (HWND%, UINT%, UINT%, UINT%, UINT%) As Integer
Declare Sub      VMSetBackground      Lib "TESTEvnt.Dll" Alias "VMSetBackground"      (HWND%, BOOL%)
Declare Function VMPipeOpen           Lib "TESTEvnt.Dll" Alias "VMPipeOpen"           (HWND%, SCRIPTSUB As Callback ) As Integer
Declare Function VMPipeClose          Lib "TESTEvnt.Dll" Alias "VMPipeClose"          (HWND%) As Integer
Declare Function VMPipeGetText        Lib "TESTEvnt.Dll" Alias "VMPipeGetText"        (HWND%, LPSTR$ ) As Integer

CONST PIPESTRINGSIZE        = 129           ' 128 chars + NULL

' **  VMPipeGetText() Return values... **
'----------------------------------------
CONST PGT_FAILED            = &H0000
CONST PGT_COMPLETE          = &H0001
CONST PGT_MOREREADY         = &H0002

'$ENDIF NT 'for TESTEvnt VM Stuff

Declare Sub      QueKeys              Lib "TESTEvnt.Dll" Alias "QueKeys"              (lpStr$)
Declare Sub      QueKeyDn             Lib "TESTEvnt.Dll" Alias "QueKeyDn"             (lpStr$)
Declare Sub      QueKeyUp             Lib "TESTEvnt.Dll" Alias "QueKeyUp"             (lpStr$)
Declare Sub      QueSetSpeed          Lib "TESTEvnt.Dll" Alias "QueSetSpeed"          (ms%)
Declare Sub      QuePause             Lib "TESTEvnt.Dll" Alias "QuePause"             (ms&)
Declare Sub      QueFlush             Lib "TESTEvnt.Dll" Alias "QueFlush"             (fRestoreKeyState%)
Declare Sub      QueEmpty             Lib "TESTEvnt.Dll" Alias "QueEmpty"             ()
Declare Sub      QueMouseMove         Lib "TESTEvnt.Dll" Alias "QueMouseMove"         (x%, y%)
Declare Sub      QueMouseDn           Lib "TESTEvnt.Dll" Alias "QueMouseDn"           (iBtn%, x%, y%)
Declare Sub      QueMouseUp           Lib "TESTEvnt.Dll" Alias "QueMouseUp"           (iBtn%, x%, y%)
Declare Sub      QueMouseClick        Lib "TESTEvnt.Dll" Alias "QueMouseClick"        (iBtn%, x%, y%)
Declare Sub      QueMouseDblClk       Lib "TESTEvnt.Dll" Alias "QueMouseDblClk"       (iBtn%, x%, y%)
Declare Sub      QueMouseDblDn        Lib "TESTEvnt.Dll" Alias "QueMouseDblDn"        (iBtn%, x%, y%)
Declare Sub      QueSetFocus          Lib "TESTEvnt.Dll" Alias "QueSetFocus"          (hwnd%)
Declare Sub      QueSetRelativeWindow Lib "TESTEvnt.Dll" Alias "QueSetRelativeWindow" (hwnd%)

'$ifndef VK_WINAPI
Const VK_LBUTTON = 1
Const VK_RBUTTON = 2
Const VK_MBUTTON = 4
'$define VK_WINAPI
'$endif

'                                                       *********************
'$DEFINE TESTEVNT_INCLUDED
'$ENDIF
'$IFDEF TESTSCRN_DECL AND NOT TESTSCRN_DECL_INCLUDED
'                                                       *********************


'----------------------------------------------------------------------------
' TESTScrn.DLL:
'       Type, Const, and Function declarations for use with TESTScrn
'----------------------------------------------------------------------------
Type wRect
    x1 As Integer
    y1 As Integer
    x2 As Integer
    y2 As Integer
End Type

Const SCRNAPPEND  = 0
Const SCRNREPLACE = 1
Const SCRNINSERT  = 2

'*** TESTSCRN.DLL Routines
'
Declare Function fCompFiles             Lib "TESTScrn.DLL" Alias "fCompFiles"             (lpszFileName1$, Scr1%, lpszFileName2$, Scr2%, CompareType%) As Integer
Declare Function fCompScreenActivate    Lib "TESTScrn.DLL" Alias "fCompScreenActivate"    (lpszFileName$, OpenKeys$, CloseKeys$, lpRect As wRect, Scr1%, Hide%, Flag%) As Integer
Declare Function fCompScreen            Lib "TESTScrn.DLL" Alias "fCompScreen"            (lpszFileName$, lpRect As wRect, Scr1%, Hide%, Flag%) As Integer
Declare Function fCompWindowActivate    Lib "TESTScrn.DLL" Alias "fCompWindowActivate"    (lpszFileName$, OpenKeys$, CloseKeys$, Scr1%, Hide%, Flag%) As Integer
Declare Function fCompWindow            Lib "TESTScrn.DLL" Alias "fCompWindow"            (lpszFileName$, hWnd%, Scr1%, Hide%, Flag%) As Integer
Declare Function fDelScreen             Lib "TESTScrn.DLL" Alias "fDelScreen"             (lpszFileName$, Scr%) As Integer
Declare Function fDumpFileToClip        Lib "TESTScrn.DLL" Alias "fDumpFileToClip"        (lpszFileName$, Scr%) As Integer
Declare Function fDumpScreenActivate    Lib "TESTScrn.DLL" Alias "fDumpScreenActivate"    (lpszFileName$, OpenKeys$, CloseKeys$, lpRect As wRect, Action%, Scr1%, Flag%) As Integer
Declare Function fDumpScreen            Lib "TESTScrn.DLL" Alias "fDumpScreen"            (lpszFileName$, lpRect As wRect, Action%, Scr1%, Flag%) As Integer
Declare Function fDumpSrnToClipActivate Lib "TESTScrn.DLL" Alias "fDumpSrnToClipActivate" (OpenKeys$, CloseKeys$, lpRect As wRect, Hide%) As Integer
Declare Function fDumpSrnToClip         Lib "TESTScrn.DLL" Alias "fDumpSrnToClip"         (lpRect As wRect, Hide%) As Integer
Declare Function fDumpWindowActivate    Lib "TESTScrn.DLL" Alias "fDumpWindowActivate"    (lpszFileName$, OpenKeys$, CloseKeys$, Action%, Scr1%, Flag%) As Integer
Declare Function fDumpWindow            Lib "TESTScrn.DLL" Alias "fDumpWindow"            (lpszFileName$, wHnd%, Action%, Scr1%, Flag%) As Integer
Declare Function fDumpWndToClipActivate Lib "TESTScrn.DLL" Alias "fDumpWndToClipActivate" (OpenKeys$, CloseKeys$, Hide%) As Integer
Declare Function fDumpWndToClip         Lib "TESTScrn.DLL" Alias "fDumpWndToClip"         (hWnd%, Hide%) As Integer
Declare Function fFileInfo              Lib "TESTScrn.DLL" Alias "fFileInfo"              (lpszName$, lpRect AS wRect, VideoMode AS POINTER TO INTEGER, Count AS POINTER TO INTEGER) As Integer
Declare Function fGetDLLVersion         Lib "TESTScrn.DLL" Alias "fGetDLLVersion"         (lpszFileName$) As Integer
Declare Function fGetMaxScreen          Lib "TESTScrn.DLL" Alias "fGetMaxScreen"          (lpszFileName$) As Integer
Declare Function fGetOS                 Lib "TESTScrn.DLL" Alias "fGetOS"                 (lpszFileName$) As Integer
Declare Function fSaveFileToDIB         Lib "TESTScrn.DLL" Alias "fSaveFileToDIB"         (lpszFileName1$, Scr%, lpszFileName2$) As Integer
Declare Function fSaveSrnToDIBActivate  Lib "TESTScrn.DLL" Alias "fSaveSrnToDIBActivate"  (lpszFileName$, OpenKeys$, CloseKeys$, lpRect As wRect, Hide%) As Integer
Declare Function fSaveSrnToDIB          Lib "TESTScrn.DLL" Alias "fSaveSrnToDIB"          (lpszFileName$, lpRect As wRect, Hide%) As Integer
Declare Function fSaveWndToDIBActivate  Lib "TESTScrn.DLL" Alias "fSaveWndToDIBActivate"  (lpszFileName$, OpenKeys$, CloseKeys$, Hide%) As Integer
Declare Function fSaveWndToDIB          Lib "TESTScrn.DLL" Alias "fSaveWndToDIB"          (lpszFileName$, hWnd%, Hide%) As Integer
Declare Function fViewScreen            Lib "TESTScrn.DLL" Alias "fViewScreen"            (lpszFileName$, hWnd%, Scr1%, Action%) As Integer


'                                                       *********************
'$DEFINE TESTSCRN_DECL_INCLUDED
'$ENDIF
'$IFDEF TESTSCRN_ERRS AND NOT TESTSCRN_ERRS_INCLUDED
'                                                       *********************


'*** TESTScrn.DLL Error Codes
'
Const ERR_SCR_NOERROR    = 0
Const ERR_SCR_FILEACCESS = 301
Const ERR_SCR_INVALIDFIL = 302
Const ERR_SCR_INVALSRNID = 303
Const ERR_SCR_INVALSRNMD = 304
Const ERR_SCR_OUTOMEMORY = 305
Const ERR_SCR_READSRNFIL = 306
Const ERR_SCR_RELMEMORY  = 307
Const ERR_SCR_CREATEDDB  = 308
Const ERR_SCR_RWSRNTABLE = 309
Const ERR_SCR_RWCOLTABLE = 310
Const ERR_SCR_WSRNIMAGE  = 311
Const ERR_SCR_WFILEHEAD  = 312
Const ERR_SCR_CREATEDIB  = 313
Const ERR_SCR_SCREENSIZE = 314
Const ERR_SCR_DISPSCREEN = 315
Const ERR_SCR_INVALIDACT = 316
Const ERR_SCR_IMAGEDIFF  = 317
Const ERR_SCR_SRNSIZEDIF = 318
Const ERR_SCR_FILEEXIST  = 319
Const ERR_SCR_CTEMPFILE  = 320
Const ERR_SCR_HIDEWIN    = 321
Const ERR_SCR_INVALWHAND = 322
Const ERR_SCR_OFILEFORM  = 323
Const ERR_SCR_SRNFILEFUL = 324
Const ERR_SCR_INVALSCALE = 325
Const ERR_SCR_OPENCB     = 326
Const ERR_SCR_EMPTYCB    = 327
Const ERR_SCR_COPYTOCB   = 328
Const ERR_SCR_CLOSECB    = 329
Const ERR_SCR_CREATEPAL  = 330
Const ERR_SCR_LIBLOADERR = 331


'                                                       *********************
'$DEFINE TESTSCRN_ERRS_INCLUDED
'$ENDIF
'$IFNDEF NT
'$IFDEF TESTDLGS_DECL AND NOT TESTDLGS_DECL_INCLUDED
'                                                       *********************


'----------------------------------------------------------------------------
' TESTDlgs.DLL:
'       Type, Const, and Function declarations for use with TESTDlgs
'----------------------------------------------------------------------------
Const cchCLASSMAC = 32
Const cchTEXTMAC  = 256
Const wVEREB      = 1

Type DCR
    xLeft  As Integer
    yMin   As Integer
    xRight As Integer
    yLast  As Integer
End Type

Declare Function AwaitSaveCompletion Lib "TESTDlgs.DLL" Alias "AwaitSaveCompletion" () As Integer
Declare Function ComparisonResults   Lib "TESTDlgs.DLL" Alias "ComparisonResults"   () As Integer
Declare Function CmpWindow           Lib "TESTDlgs.DLL" Alias "CmpWindow"           (hWnd%, nDialog%, fIncludeParent%) As Integer
Declare Function CmpWindowActivate   Lib "TESTDlgs.DLL" Alias "CmpWindowActivate"   (lpszOpenKeys$, lpszCloseKey$, nDialog%, fIncludeParent%) As Integer
Declare Function CmpWindowCaption    Lib "TESTDlgs.DLL" Alias "CmpWindowCaption"    (lpszCap$, nDialog%, fIncludeParent%) As Integer
Declare Function CmpWindowDelayed    Lib "TESTDlgs.DLL" Alias "CmpWindowDelayed"    (nDelay%, nDialog%, fIncludeParent%, lpszCloseKeys$) As Integer
Declare Function FindWindowCaption   Lib "TESTDlgs.DLL" Alias "FindWindowCaption"   (lpszCap$, hWndStart%) As Integer
Declare Function SaveMenu            Lib "TESTDlgs.DLL" Alias "SaveMenu"            (hWnd%, nDialog%, lpszDesc$, fReplace%) As Integer
Declare Function SaveMenuActivate    Lib "TESTDlgs.DLL" Alias "SaveMenuActivate"    (lpszOpenKeys$, lpszCloseKeys$, nDialog%, lpszDesc$, fReplace%) As Integer
Declare Function SaveMenuCaption     Lib "TESTDlgs.DLL" Alias "SaveMenuCaption"     (lpszCap$, nDialog%, lpszDesc$, fReplace%) As Integer
Declare Function SaveMenuDelayed     Lib "TESTDlgs.DLL" Alias "SaveMenuDelayed"     (nDelay%, nDialog%, lpszDesc$, fReplace%, CloseKeys$) As Integer
Declare Function SaveWindow          Lib "TESTDlgs.DLL" Alias "SaveWindow"          (hWnd%, nDialog%, lpszDesc$, fReplace%, fIncludeParent%) As Integer
Declare Function SaveWindowActivate  Lib "TESTDlgs.DLL" Alias "SaveWindowActivate"  (lpszOpenKeys$, lpszCloseKeys$, nDialog%, lpszDesc$, fReplace%, fIncludeParent%) As Integer
Declare Function SaveWindowCaption   Lib "TESTDlgs.DLL" Alias "SaveWindowCaption"   (lpszCap$, nDialog%, lpszDesc$, fReplace%, fIncludeParent%) As Integer
Declare Function SaveWindowDelayed   Lib "TESTDlgs.DLL" Alias "SaveWindowDelayed"   (nDelay%, nDialog%, lpszDesc$, fReplace%, fIncludeParent%, lpszCloseKeys$) As Integer
Declare Function SetDialogFile       Lib "TESTDlgs.DLL" Alias "SetDialogFile"       (lpszDialogName$) As Integer
Declare Function SetLogFile          Lib "TESTDlgs.DLL" Alias "SetLogFile"          (lpszLogName$) As Integer


'                                                       *********************
'$DEFINE TESTDLGS_DECL_INCLUDED
'$ENDIF
'$IFDEF TESTDLGS_ERRS AND NOT TESTDLGS_ERRS_INCLUDED
'                                                       *********************


'*** Function return codes
'
Const ERR_DLGS_NOERR          =   0
Const ERR_DLGS_FUZZY          =  -1
Const ERR_DLGS_EXCESS         =  -2
Const ERR_DLGS_CTLNOTFOUND    =  -3
Const ERR_DLGS_NODLGFILE      = -10
Const ERR_DLGS_FILENOTFOUND   = -11
Const ERR_DLGS_BADWDLFILE     = -12
Const ERR_DLGS_LIBLOADERR     = -13
Const ERR_DLGS_SAVEERR        = -14
Const ERR_DLGS_DLGFILEERR     = -15
Const ERR_DLGS_TMPFILEERR     = -16
Const ERR_DLGS_VERSIONERR     = -17
Const ERR_DLGS_DLGFILEFULL    = -18
Const ERR_DLGS_OUTOFMEMORY    = -20
Const ERR_DLGS_BUFFERERR      = -21
Const ERR_DLGS_NOTIMER        = -22
Const ERR_DLGS_NODYNDIALOG    = -30
Const ERR_DLGS_INVALIDHWND    = -31
Const ERR_DLGS_BADCAPTION     = -32
Const ERR_DLGS_BADDLGNUM      = -33
Const ERR_DLGS_BADCTLINDEX    = -34
Const ERR_DLGS_BADCTLTYPE     = -35
Const ERR_DLGS_BADSAVEACTION  = -36
Const ERR_DLGS_APPSPECIFIC    = -37


'                                                       *********************
'$DEFINE TESTDLGS_ERRS_INCLUDED
'$ENDIF
'$ENDIF NT for TESTDLGS
'$IFDEF W_WINDOW AND NOT W_WINDOW_INCLUDED
'                                                       *********************


'----------------------------------------------------------------------------
' TESTCtrl.dll routines, types, & constants
'----------------------------------------------------------------------------

'*** Window size and position types
'
Type WNDPOS
    wLeft   As Integer
    wTop    As Integer
End Type

Type WNDSIZ
    wWidth  As Integer
    wHeight As Integer
End Type

Type WNDPOSSIZ
    wLeft   As Integer
    wTop    As Integer
    wWidth  As Integer
    wHeight As Integer
End Type

'*** Window Positioning and Sizing routines & contants
'
Declare Sub      WMinWnd       Lib "TESTCtrl.dll" Alias "WMinWnd"       (hWnd%)
Declare Sub      WMaxWnd       Lib "TESTCtrl.dll" Alias "WMaxWnd"       (hWnd%)
Declare Sub      WResWnd       Lib "TESTCtrl.dll" Alias "WResWnd"       (hWnd%)
Declare Sub      WSetWndPos    Lib "TESTCtrl.dll" Alias "WSetWndPos"    (hWnd%, wLeft%, wTop%)
Declare Sub      WSetWndSiz    Lib "TESTCtrl.dll" Alias "WSetWndSiz"    (hWnd%, wWidth%, wHeight%)
Declare Sub      WSetWndPosSiz Lib "TESTCtrl.dll" Alias "WSetWndPosSiz" (hWnd%, wLeft%, wTop%, wWidth%, wHeight%)
Declare Sub      WAdjWndPos    Lib "TESTCtrl.dll" Alias "WAdjWndPos"    (hWnd%, deltaLeft%,  deltaTop%)
Declare Sub      WAdjWndSiz    Lib "TESTCtrl.dll" Alias "WAdjWndSiz"    (hWnd%, deltaWidth%, deltaHeight%)
Declare Sub      WAdjWndPosSiz Lib "TESTCtrl.dll" Alias "WAdjWndPosSiz" (hWnd%, deltaLeft%,  deltaTop%, deltaWidth%, deltaHeight%)
Declare Sub      WGetWndPos    Lib "TESTCtrl.dll" Alias "WGetWndPos"    (hWnd%, lpWndPos    As WNDPOS,    fRelative%)
Declare Sub      WGetWndSiz    Lib "TESTCtrl.dll" Alias "WGetWndSiz"    (hWnd%, lpWndSiz    As WNDSIZ)
Declare Sub      WGetWndPosSiz Lib "TESTCtrl.dll" Alias "WGetWndPosSiz" (hWnd%, lpWndPosSiz As WNDPOSSIZ, fRelative%)
Declare Function WIsMaximized  Lib "TESTCtrl.dll" Alias "WIsMaximized"  (hWnd%) As Integer
Declare Function WIsMinimized  Lib "TESTCtrl.dll" Alias "WIsMinimized"  (hWnd%) As Integer


Const W_RELATIVE = TRUE
Const W_ABSOLUTE = FALSE


'                                                       *********************
'$DEFINE W_WINDOW_INCLUDED
'$ENDIF
'$IFDEF W_MENU AND NOT W_MENU_INCLUDED
'                                                       *********************


'*** Menu routines & constants
'
Declare Sub      WSysMenu           Lib "TESTCtrl.dll" Alias "WSysMenu"           (hWnd%)
Declare Function WSysMenuExists     Lib "TESTCtrl.dll" Alias "WSysMenuExists"     (hWnd%) As Integer
Declare Sub      WMenu              Lib "TESTCtrl.dll" Alias "WMenu"              (lpszName$)
Declare Sub      WMenuEx      CDECL Lib "TESTCtrl.dll" Alias "WMenuEx"            (lpszName$, ...)
Declare Function WMenuExists        Lib "TESTCtrl.dll" Alias "WMenuExists"        (lpszName$) As Integer
Declare Function WMenuGrayed        Lib "TESTCtrl.dll" Alias "WMenuGrayed"        (lpszName$) As Integer
Declare Function WMenuChecked       Lib "TESTCtrl.dll" Alias "WMenuChecked"       (lpszName$) As Integer
Declare Function WMenuEnabled       Lib "TESTCtrl.dll" Alias "WMenuEnabled"       (lpszName$) As Integer
Declare Function WMenuCount         Lib "TESTCtrl.dll" Alias "WMenuCount"         () As Integer
Declare Sub      WMenuText          Lib "TESTCtrl.dll" Alias "WMenuText"          (lpszName$, lpszBuffer$)
Declare Function WMenuLen           Lib "TESTCtrl.dll" Alias "WMenuLen"           (lpszName$) As Integer
Declare Sub      WMenuFullText      Lib "TESTCtrl.dll" Alias "WMenuFullText"      (lpszName$, lpszBuffer$)
Declare Function WMenuFullLen       Lib "TESTCtrl.dll" Alias "WMenuFullLen"       (lpszName$) As Integer
Declare Sub      WMenuEnd           Lib "TESTCtrl.dll" Alias "WMenuEnd"           ()
Declare Function WMenuNumAltKeys    Lib "TESTCtrl.dll" Alias "WMenuNumAltKeys"    () As Integer
Declare Sub      WMenuGetAltKeys    Lib "TESTCtrl.dll" Alias "WMenuGetAltKeys"    (lpszBuff$)
Declare Function WMenuNumDupAltKeys Lib "TESTCtrl.dll" Alias "WMenuNumDupAltKeys" () As Integer
Declare Sub      WMenuGetDupAltKeys Lib "TESTCtrl.dll" Alias "WMenuGetDupAltKeys" (lpszBuff$)

' Layered routines to simulate string functions for the coresponding
' TESTCtrl API
'----------------------------------------------------------------------------
Declare Function MenuText          (lpszName$) As String
Declare Function MenuFullText      (lpszName$) As String
Declare Function MenuGetAltKeys    () As String
Declare Function MenuGetDupAltKeys () As String

' Unlike the rest of the menu routines, WMenuSeparator() does not ignore
' menu separators when specifing indexes.  The first menu item is item #1
' the second #2, and so on including all separators.
'------------------------------------------------------------------------
Declare Function WMenuSeparator Lib "TESTCtrl.dll" Alias "WMenuSeparator" (sIndex%) As Integer

' Obsolete Menu API
'------------------
Declare Sub      WMenuX         Lib "TESTCtrl.dll" Alias "WMenuX"        (iIndex%)
Declare Function WMenuGrayedX   Lib "TESTCtrl.dll" Alias "WMenuGrayedX"  (iIndex%) As Integer
Declare Function WMenuCheckedX  Lib "TESTCtrl.dll" Alias "WMenuCheckedX" (iIndex%) As Integer
Declare Function WMenuEnabledX  Lib "TESTCtrl.dll" Alias "WMenuEnabledX" (iIndex%) As Integer


'----------------------------------------------------------------------------
' MenuText: Layered routine for WMenuText()
'----------------------------------------------------------------------------
Function MenuText(lpszName$) Static As String
Dim lpszBuffer As String
Dim menuLength As Integer
    MenuText = ""
    menuLength = WMenuLen(lpszName$)
    If menuLength >= 0 Then
        lpszBuffer = String$(menuLength+1, " ")
        WMenuText lpszName$, lpszBuffer
        MenuText = lpszBuffer
    End if
    lpszBuffer = ""
End Function

'----------------------------------------------------------------------------
' MenuFullText: Layered routine for WMenuFullText()
'----------------------------------------------------------------------------
Function MenuFullText(lpszName$) Static As String
Dim lpszBuffer As String
Dim menuLength As Integer
    MenuFullText = ""
    menuLength = WMenuFullLen(lpszName$)
    If menuLength >= 0 Then
        lpszBuffer = String$(menuLength+1, " ")
        WMenuFullText lpszName$, lpszBuffer
        MenuFullText = lpszBuffer
    End If
    lpszBuffer = ""
End Function

'----------------------------------------------------------------------------
' MenuGetAltKeys: Layered routine for WMenuGetAltKeys()
'----------------------------------------------------------------------------
Function MenuGetAltKeys() Static As String
Dim lpszBuffer As String
    lpszBuffer = String$(WMenuNumAltKeys()+1, " ")
    WMenuGetAltKeys lpszBuffer
    MenuGetAltKeys = lpszBuffer
    lpszBuffer = ""
End Function

'----------------------------------------------------------------------------
' MenuGetDupAltKeys: Layered routine for WMenuGetDupAltKeys()
'----------------------------------------------------------------------------
Function MenuGetDupAltKeys() Static As String
Dim lpszBuffer As String
    lpszBuffer = String$(WMenuNumDupAltKeys()+1, " ")
    WMenuGetDupAltKeys lpszBuffer
    MenuGetDupAltKeys = lpszBuffer
    lpszBuffer = ""
End Function

'                                                       *********************
'$DEFINE W_MENU_INCLUDED
'$ENDIF
'$IFDEF W_A_CONTROL AND NOT W_A_CONTROL_INCLUDED
'                                                       *********************


'*** Global routine & constants used by all controls
'
Declare Sub WStaticSetClass Lib "TESTCtrl.dll" Alias "WStaticSetClass" (lpszClassName$)
Declare Sub WResetClasses   Lib "TESTCtrl.dll" Alias "WResetClasses"   ()


'                                                       *********************
'$DEFINE W_A_CONTROL_INCLUDED
'$ENDIF
'$IFDEF W_BUTTON AND NOT W_BUTTON_INCLUDED
'                                                       *********************


'*** Button routines
'
Declare Sub      WButtonSetClass Lib "TESTCtrl.dll" Alias "WButtonSetClass" (lpszClassName$)
Declare Function WButtonExists   Lib "TESTCtrl.dll" Alias "WButtonExists"   (lpszName$) As Integer
Declare Function WButtonEnabled  Lib "TESTCtrl.dll" Alias "WButtonEnabled"  (lpszName$) As Integer
Declare Function WButtonFocus    Lib "TESTCtrl.dll" Alias "WButtonFocus"    (lpszName$) As Integer
Declare Sub      WButtonClick    Lib "TESTCtrl.dll" Alias "WButtonClick"    (lpszName$)
Declare Sub      WButtonHide     Lib "TESTCtrl.dll" Alias "WButtonHide"     (lpszName$)
Declare Sub      WButtonShow     Lib "TESTCtrl.dll" Alias "WButtonShow"     (lpszName$)
Declare Sub      WButtonEnable   Lib "TESTCtrl.dll" Alias "WButtonEnable"   (lpszName$)
Declare Sub      WButtonDisable  Lib "TESTCtrl.dll" Alias "WButtonDisable"  (lpszName$)
Declare Function WButtonDefault  Lib "TESTCtrl.dll" Alias "WButtonDefault"  (lpszName$) As Integer
Declare Function WButtonDefaults Lib "TESTCtrl.dll" Alias "WButtonDefaults" () As Integer
Declare Sub      WButtonSetFocus Lib "TESTCtrl.dll" Alias "WButtonSetFocus" (lpszName$)

'                                                       *********************
'$DEFINE W_BUTTON_INCLUDED
'$ENDIF
'$IFDEF W_CHECK AND NOT W_CHECK_INCLUDED
'                                                       *********************


' CheckBox routines
'
Declare Sub      WCheckSetClass Lib "TESTCtrl.dll" Alias "WCheckSetClass" (lpszClassName$)
Declare Function WCheckExists   Lib "TESTCtrl.dll" Alias "WCheckExists"   (lpszName$) As Integer
Declare Function WCheckEnabled  Lib "TESTCtrl.dll" Alias "WCheckEnabled"  (lpszName$) As Integer
Declare Function WCheckFocus    Lib "TESTCtrl.dll" Alias "WCheckFocus"    (lpszName$) As Integer
Declare Function WCheckState    Lib "TESTCtrl.dll" Alias "WCheckState"    (lpszName$) As Integer
Declare Sub      WCheckClick    Lib "TESTCtrl.dll" Alias "WCheckClick"    (lpszName$)
Declare Sub      WCheckHide     Lib "TESTCtrl.dll" Alias "WCheckHide"     (lpszName$)
Declare Sub      WCheckShow     Lib "TESTCtrl.dll" Alias "WCheckShow"     (lpszName$)
Declare Sub      WCheckEnable   Lib "TESTCtrl.dll" Alias "WCheckEnable"   (lpszName$)
Declare Sub      WCheckDisable  Lib "TESTCtrl.dll" Alias "WCheckDisable"  (lpszName$)
Declare Sub      WCheckCheck    Lib "TESTCtrl.dll" Alias "WCheckCheck"    (lpszName$)
Declare Sub      WCheckUnCheck  Lib "TESTCtrl.dll" Alias "WCheckUnCheck"  (lpszName$)
Declare Sub      WCheckSetFocus Lib "TESTCtrl.dll" Alias "WCheckSetFocus" (lpszName$)

Const UNCHECKED = 0
Const CHECKED   = 1
Const GRAYED    = 2


'                                                       *********************
'$DEFINE W_CHECK_INCLUDED
'$ENDIF
'$IFDEF W_OPTION AND NOT W_OPTION_INCLUDED
'                                                       *********************


'*** Option Button routines
'
Declare Sub      WOptionSetClass Lib "TESTCtrl.dll" Alias "WOptionSetClass" (lpszClassName$)
Declare Function WOptionExists   Lib "TESTCtrl.dll" Alias "WOptionExists"   (lpszName$) As Integer
Declare Function WOptionEnabled  Lib "TESTCtrl.dll" Alias "WOptionEnabled"  (lpszName$) As Integer
Declare Function WOptionFocus    Lib "TESTCtrl.dll" Alias "WOptionFocus"    (lpszName$) As Integer
Declare Function WOptionState    Lib "TESTCtrl.dll" Alias "WOptionState"    (lpszName$) As Integer
Declare Sub      WOptionClick    Lib "TESTCtrl.dll" Alias "WOptionClick"    (lpszName$)
Declare Sub      WOptionHide     Lib "TESTCtrl.dll" Alias "WOptionHide"     (lpszName$)
Declare Sub      WOptionShow     Lib "TESTCtrl.dll" Alias "WOptionShow"     (lpszName$)
Declare Sub      WOptionEnable   Lib "TESTCtrl.dll" Alias "WOptionEnable"   (lpszName$)
Declare Sub      WOptionDisable  Lib "TESTCtrl.dll" Alias "WOptionDisable"  (lpszName$)
Declare Sub      WOptionSelect   Lib "TESTCtrl.dll" Alias "WOptionSelect"   (lpszName$)
Declare Sub      WOptionSetFocus Lib "TESTCtrl.dll" Alias "WOptionSetFocus" (lpszName$)

'                                                       *********************
'$DEFINE W_OPTION_INCLUDED
'$ENDIF
'$IFDEF W_LIST AND NOT W_LIST_INCLUDED
'                                                       *********************


'*** Listbox routines
'
Declare Sub      WListSetClass     Lib "TESTCtrl.dll" Alias "WListSetClass"     (lpszClass$)
Declare Function WListExists       Lib "TESTCtrl.dll" Alias "WListExists"       (lpszName$) As Integer
Declare Function WListCount        Lib "TESTCtrl.dll" Alias "WListCount"        (lpszName$) As Integer
Declare Sub      WListText         Lib "TESTCtrl.dll" Alias "WListText"         (lpszName$, lpszBuffer$)
Declare Function WListLen          Lib "TESTCtrl.dll" Alias "WListLen"          (lpszName$) As Integer
Declare Function WListIndex        Lib "TESTCtrl.dll" Alias "WListIndex"        (lpszName$) As Integer
Declare Function WListTopIndex     Lib "TESTCtrl.dll" Alias "WListTopIndex"     (lpszName$) As Integer
Declare Sub      WListItemText     Lib "TESTCtrl.dll" Alias "WListItemText"     (lpszName$, iItem%, lpszBuffer$)
Declare Function WListItemLen      Lib "TESTCtrl.dll" Alias "WListItemLen"      (lpszName$, iItem%) As Integer
Declare Function WListItemExists   Lib "TESTCtrl.dll" Alias "WListItemExists"   (lpszName$, lpszItem$) As Integer
Declare Sub      WListItemClk      Lib "TESTCtrl.dll" Alias "WListItemClk"      (lpszName$, iItem%)
Declare Sub      WListItemCtrlClk  Lib "TESTCtrl.dll" Alias "WListItemCtrlClk"  (lpszName$, iItem%)
Declare Sub      WListItemShftClk  Lib "TESTCtrl.dll" Alias "WListItemShftClk"  (lpszName$, iItem%)
Declare Sub      WListItemDblClk   Lib "TESTCtrl.dll" Alias "WListItemDblClk"   (lpszName$, iItem%)
Declare Sub      WListItemClkT     Lib "TESTCtrl.dll" Alias "WListItemClkT"     (lpszName$, lpszItem$)
Declare Sub      WListItemCtrlClkT Lib "TESTCtrl.dll" Alias "WListItemCtrlClkT" (lpszName$, lpszItem$)
Declare Sub      WListItemShftClkT Lib "TESTCtrl.dll" Alias "WListItemShftClkT" (lpszName$, lpszItem$)
Declare Sub      WListItemDblClkT  Lib "TESTCtrl.dll" Alias "WListItemDblClkT"  (lpszName$, lpszItem$)
Declare Function WListSelCount     Lib "TESTCtrl.dll" Alias "WListSelCount"     (lpszName$) As Integer
Declare Sub      WListSelItems     Lib "TESTCtrl.dll" Alias "WListSelItems"     (lpszName$, lpIntArray As Pointer To Integer)
Declare Sub      WListClear        Lib "TESTCtrl.dll" Alias "WListClear"        (lpszName$)
Declare Sub      WListAddItem      Lib "TESTCtrl.dll" Alias "WListAddItem"      (lpszName$, lpszItem$)
Declare Sub      WListDelItem      Lib "TESTCtrl.dll" Alias "WListDelItem"      (lpszName$, iItem%)
Declare Sub      WListDelItemT     Lib "TESTCtrl.dll" Alias "WListDelItemT"     (lpszName$, lpszItem$)
Declare Function WListEnabled      Lib "TESTCtrl.dll" Alias "WListEnabled"      (lpszName$) As Integer
Declare Sub      WListSetFocus     Lib "TESTCtrl.dll" Alias "WListSetFocus"     (lpszName$)

' Layered routines to simulate string functions for the coresponding
' TESTCtrl API
'----------------------------------------------------------------------------
Declare Function ListText     (lpszName$) As String
Declare Function ListItemText (lpszName$, iItem%) As String

'----------------------------------------------------------------------------
' ListText: Layered routine for WListText()
'----------------------------------------------------------------------------
Function ListText(lpszName$) Static As String
Dim lpszBuffer As String
Dim itemLength As Integer
    ListText = ""
    itemLength = WListLen(lpszName)
    If itemLength >= 0 Then
        lpszBuffer = String$(itemLength+1, " ")
        WListText lpszName, lpszBuffer
        ListText = lpszBuffer
    End If
    lpszBuffer = ""
End Function

'----------------------------------------------------------------------------
' ListItemText: Layered routine for WListItemText()
'----------------------------------------------------------------------------
Function ListItemText(lpszName$, sItem%) Static As String
Dim lpszBuffer As String
Dim itemLength As Integer
    ListItemText = ""
    itemLength = WListItemLen(lpszName, sItem)
    If itemLength >= 0 Then
        lpszBuffer = String$(itemLength+1, " ")
        WListItemText lpszName, sItem, lpszBuffer
        ListItemText = lpszBuffer
    End If
    lpszBuffer = ""
End Function


'                                                       *********************
'$DEFINE W_LIST_INCLUDED
'$ENDIF
'$IFDEF W_COMBO AND NOT W_COMBO_INCLUDED
'                                                       *********************


'*** Combobox routines
'
Declare Sub      WComboSetClass    Lib "TESTCtrl.dll" Alias "WComboSetClass"    (lpszClass$)
Declare Sub      WComboSetLBClass  Lib "TESTCtrl.dll" Alias "WComboSetLBClass"  (lpszClass$)
Declare Function WComboExists      Lib "TESTCtrl.dll" Alias "WComboExists"      (lpszName$) As Integer
Declare Function WComboCount       Lib "TESTCtrl.dll" Alias "WComboCount"       (lpszName$) As Integer
Declare Sub      WComboSetText     Lib "TESTCtrl.dll" Alias "WComboSetText"     (lpszName$, lpszText$)
Declare Sub      WComboText        Lib "TESTCtrl.dll" Alias "WComboText"        (lpszName$, lpszBuffer$)
Declare Function WComboLen         Lib "TESTCtrl.dll" Alias "WComboLen"         (lpszName$) As Integer
Declare Sub      WComboSelText     Lib "TESTCtrl.dll" Alias "WComboSelText"     (lpszName$, lpszBuffer$)
Declare Function WComboSelLen      Lib "TESTCtrl.dll" Alias "WComboSelLen"      (lpszName$) As Integer
Declare Function WComboIndex       Lib "TESTCtrl.dll" Alias "WComboIndex"       (lpszName$) As Integer
Declare Sub      WComboItemText    Lib "TESTCtrl.dll" Alias "WComboItemText"    (lpszName$, iItem%, lpszBuffer$)
Declare Function WComboItemLen     Lib "TESTCtrl.dll" Alias "WComboItemLen"     (lpszName$, iItem%) As Integer
Declare Function WComboItemExists  Lib "TESTCtrl.dll" Alias "WComboItemExists"  (lpszName$, lpszItem$) As Integer
Declare Sub      WComboItemClk     Lib "TESTCtrl.dll" Alias "WComboItemClk"     (lpszName$, iItem%)
Declare Sub      WComboItemDblClk  Lib "TESTCtrl.dll" Alias "WComboItemDblClk"  (lpszName$, iItem%)
Declare Sub      WComboItemClkT    Lib "TESTCtrl.dll" Alias "WComboItemClkT"    (lpszName$, lpszItem$)
Declare Sub      WComboItemDblClkT Lib "TESTCtrl.dll" Alias "WComboItemDblClkT" (lpszName$, lpszItem$)
Declare Sub      WComboClear       Lib "TESTCtrl.dll" Alias "WComboClear"       (lpszName$)
Declare Sub      WComboAddItem     Lib "TESTCtrl.dll" Alias "WComboAddItem"     (lpszName$, lpszItem$)
Declare Sub      WComboDelItem     Lib "TESTCtrl.dll" Alias "WComboDelItem"     (lpszName$, iItem%)
Declare Sub      WComboDelItemT    Lib "TESTCtrl.dll" Alias "WComboDelItemT"    (lpszName$, lpszItem$)
Declare Function WComboEnabled     Lib "TESTCtrl.dll" Alias "WComboEnabled"     (lpszName$) As Integer
Declare Sub      WComboSetFocus    Lib "TESTCtrl.dll" Alias "WComboSetFocus"    (lpszName$)

' Layered routines to simulate string functions for the coresponding
' TESTCtrl API
'----------------------------------------------------------------------------
Declare Function ComboText     (lpszName$) As String
Declare Function ComboSelText  (lpszName$) As String
Declare Function ComboItemText (lpszName$, iItem%) As String

'----------------------------------------------------------------------------
' ComboText: Layered routine for WComboText()
'----------------------------------------------------------------------------
Function ComboText(lpszName$) Static As String
Dim lpszBuffer As String
Dim itemLength As Integer
    ComboText = ""
    itemLength = WComboLen(lpszName$)
    If itemLength >= 0 Then
        lpszBuffer = String$(itemLength+1, " ")
        WComboText lpszName, lpszBuffer
        ComboText = lpszBuffer
    End If
    lpszBuffer = ""
End Function

'----------------------------------------------------------------------------
' ComboSelText: Layered routine for WComboSelText()
'----------------------------------------------------------------------------
Function ComboSelText(lpszName$) Static As String
Dim lpszBuffer As String
Dim itemLength As Integer
    ComboSelText = ""
    itemLength = WComboSelLen(lpszName$)
    If itemLength >= 0 Then
        lpszBuffer = String$(itemLength+1, " ")
        WComboSelText lpszName, lpszBuffer
        ComboSelText = lpszBuffer
    End If
    lpszBuffer = ""
End Function

'----------------------------------------------------------------------------
' ComboItemText: Layered routine for WComboItemText()
'----------------------------------------------------------------------------
Function ComboItemText(lpszName$, sItem%) Static As String
Dim lpszBuffer As String
Dim itemLength As Integer
    ComboItemText = ""
    itemLength = WComboItemLen(lpszName, sItem)
    If itemLength >= 0 Then
        lpszBuffer = String$(itemLength+1, " ")
        WComboItemText lpszName, sItem, lpszBuffer
        ComboItemText = lpszBuffer
    End If
    lpszBuffer = ""
End Function


'                                                       *********************
'$DEFINE W_COMBO_INCLUDED
'$ENDIF
'$IFDEF W_EDIT AND NOT W_EDIT_INCLUDED
'                                                       *********************


'*** Edit box routines
'
Declare Sub      WEditSetClass Lib "TESTCtrl.dll" Alias "WEditSetClass" (lpszClass$)
Declare Function WEditExists   Lib "TESTCtrl.dll" Alias "WEditExists"   (lpszName$) As Integer
Declare Function WEditLen      Lib "TESTCtrl.dll" Alias "WEditLen"      (lpszName$) As Long
Declare Sub      WEditText     Lib "TESTCtrl.dll" Alias "WEditText"     (lpszName$, lpszBuffer$)
Declare Sub      WEditSetText  Lib "TESTCtrl.dll" Alias "WEditSetText"  (lpszName$, lpszBuffer$)
Declare Sub      WEditSelText  Lib "TESTCtrl.dll" Alias "WEditSelText"  (lpszName$, lpszBuffer$)
Declare Function WEditSelLen   Lib "TESTCtrl.dll" Alias "WEditSelLen"   (lpszName$) As Long
Declare Sub      WEditLineText Lib "TESTCtrl.dll" Alias "WEditLineText" (lpszName$, lIndex&, lpszBuffer$)
Declare Function WEditLineLen  Lib "TESTCtrl.dll" Alias "WEditLineLen"  (lpszName$, lIndex&) As Long
Declare Function WEditPos      Lib "TESTCtrl.dll" Alias "WEditPos"      (lpszName$) As Long
Declare Function WEditLine     Lib "TESTCtrl.dll" Alias "WEditLine"     (lpszName$) As Long
Declare Function WEditChar     Lib "TESTCtrl.dll" Alias "WEditChar"     (lpszName$) As Long
Declare Function WEditFirst    Lib "TESTCtrl.dll" Alias "WEditFirst"    (lpszName$) As Long
Declare Function WEditLines    Lib "TESTCtrl.dll" Alias "WEditLines"    (lpszName$) As Long
Declare Sub      WEditClick    Lib "TESTCtrl.dll" Alias "WEditClick"    (lpszName$)
Declare Function WEditEnabled  Lib "TESTCtrl.dll" Alias "WEditEnabled"  (lpszName$) As Integer
Declare Sub      WEditSetFocus Lib "TESTCtrl.dll" Alias "WEditSetFocus" (lpszName$)

' Layered routines to simulate string functions for the coresponding
' TESTCtrl API
'----------------------------------------------------------------------------
Declare Function EditText     (lpszName$) As String
Declare Function EditSelText  (lpszName$) As String
Declare Function EditLineText (lpszName$, lIndex&) As String

'----------------------------------------------------------------------------
' EditText: Layered routine for WEditText()
'----------------------------------------------------------------------------
Function EditText(lpszName$) Static As String
Dim textLength As Long
Dim lpszBuffer As String
    EditText = ""
    textLength = WEditLen(lpszName)
    If textLength >= 0 Then
        lpszBuffer = String$(textLength+1, " ")
        WEditText lpszName, lpszBuffer
        EditText = lpszBuffer
    End If
    lpszBuffer = ""
End Function

'----------------------------------------------------------------------------
' EditSelText: Layered routine for WEditSelText()
'----------------------------------------------------------------------------
Function EditSelText(lpszName$) Static As String
Dim selLength  As Long
Dim lpszBuffer As String
    EditSelText = ""
    selLength = WEditSelLen(lpszName)
    If selLength >= 0 Then
        lpszBuffer = String$(selLength+1, " ")
        WEditSelText lpszName, lpszBuffer
        EditSelText = lpszBuffer
    End If
    lpszBuffer = ""
End Function

'----------------------------------------------------------------------------
' EditLineText: Layered routine for WEditLineText()
'----------------------------------------------------------------------------
Function EditLineText(lpszName$, lIndex&) Static As String
Dim lineLength As Long
Dim lpszBuffer As String
    EditLineText = ""
    lineLength = WEditLineLen(lpszName, lIndex)
    If lineLength >= 0 Then
        lpszBuffer = String$(lineLength+1, " ")
        WEditLineText lpszName, lIndex&, lpszBuffer
        EditLineText = lpszBuffer
    End if
    lpszBuffer = ""
End Function


'                                                       *********************
'$DEFINE W_EDIT_INCLUDED
'$ENDIF
'$IFDEF W_ERROR AND NOT W_ERROR_INCLUDED
'                                                       *********************


Declare Function WError     Lib "TESTCtrl.dll" Alias "WError"     () As Integer
Declare Sub      WErrorSet  Lib "TESTCtrl.dll" Alias "WErrorSet"  (iErrorNum%)
Declare Sub      WErrorText Lib "TESTCtrl.dll" Alias "WErrorText" (lpszBuffer$)
Declare Function WErrorLen  Lib "TESTCtrl.dll" Alias "WErrorLen"  () As Integer

' Layered routines to simulate string functions for the coresponding
' TESTCtrl API
'----------------------------------------------------------------------------
Declare Function ErrorText () As String

Const NO_ERROR                       =  0
Const ERR_MENU_NOT_FOUND             =  1
Const ERR_MENU_ITEM_NOT_FOUND        =  2
Const ERR_NOT_A_LISTBOX              =  3
Const ERR_LISTBOX_NOT_FOUND          =  4
Const ERR_ITEM_NOT_IN_LISTBOX        =  5
Const ERR_INVALID_LISTBOX_INDEX      =  6
Const ERR_LISTBOX_HAS_NO_STRINGS     =  7
Const ERR_LISTBOX_IS_NOT_MULTISELECT =  8
Const ERR_NOT_A_COMBOBOX             =  9
Const ERR_COMBOBOX_NOT_FOUND         = 10
Const ERR_ITEM_NOT_IN_COMBOBOX       = 11
Const ERR_INVALID_COMBOBOX_INDEX     = 12
Const ERR_COMBOBOX_HAS_NO_EDITBOX    = 13
Const ERR_COMBOBOX_HAS_NO_STRINGS    = 14
Const ERR_NOT_AN_EDITBOX             = 15
Const ERR_EDITBOX_NOT_FOUND          = 16
Const ERR_BUTTON_NOT_FOUND           = 17
Const ERR_OPTION_BUTTON_NOT_FOUND    = 18
Const ERR_CHECKBOX_NOT_FOUND         = 19
Const ERR_INVALID_WINDOW_HANDLE      = 20
Const ERR_NO_SYSTEM_MENU             = 21
Const ERR_INVALID_MENU_INDEX         = 22
Const MAX_ERROR                      = 23

'----------------------------------------------------------------------------
' ErrorText: Layered routine for WErrorText() of TESTCtrl.DLL.
'            Simulates a DLL String Function.
'----------------------------------------------------------------------------
Function ErrorText() Static As String
Dim lpszBuffer  As String
Dim errorLength As Integer
    errorLength= WErrorLen()
    lpszBuffer = String$(errorLength+1, " ")
    WErrorText lpszBuffer
    ErrorText = lpszBuffer
    lpszBuffer = ""
End Function


'                                                       *********************
'$DEFINE W_ERROR_INCLUDED
'$ENDIF
'$IFDEF W_ERROR_TRAP AND NOT W_ERROR_TRAP_INCLUDED
'                                                       *********************


'----------------------------------------------------------------------------
' WErrorTrap: This trap is in TESTCTRL.DLL.
'
'   This trap is here in MSTEST.INC just so it is easy to quickly add a
' trap that will display any TESTCTRL error messages.  It is only included if
' W_ERROR_TRAP is defined, so if WErrorTrap() is to be used for more than
' just to display the TESTCTRL error messages, W_ERROR_TRAP should no be
' defined. and a custom WErrorTrap() should be added to your script.
'----------------------------------------------------------------------------
Trap WErrorTrap From "TESTCTRL.DLL"
    Print WError;" ";ErrorText
End Trap


'                                                       *********************
'$DEFINE W_ERROR_TRAP_INCLUDED
'$ENDIF
'                                                       *********************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntfsprop.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ntfsprop.h

Abstract:

    This module contains the structure definitions for nt property Fsctl calls.

Author:

    Mark Zbikowski (MarkZ) 23-April-1996


--*/


#ifndef _NTFSPROP_
#define _NTFSPROP_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
//  WARNING!  This file requires OBJIDL.H.
//


//
//  VARIABLE_STRUCTURE_SIZE returns the size of a structure S that contains
//  an array of C structures V
//

#define VARIABLE_STRUCTURE_SIZE(S,V,C) ((int)sizeof( S ) + ((C) - 1) * (int)sizeof( V ))

//
//  COUNTED_STRING is length-preceded unicode string.  This does NOT include
//  a trailing L'\0'
//

typedef struct _COUNTED_STRING
{
    USHORT Length;
    WCHAR Text[1];
} COUNTED_STRING, *PCOUNTED_STRING;

#define COUNTED_STRING_SIZE(l)      \
    (sizeof( COUNTED_STRING ) - sizeof ( WCHAR ) + (l))
#define COUNTED_STRING_LENGTH(c)    \
    ((c)->Length)
#define COUNTED_STRING_TEXT(c)      \
    (&(c)->Text[0])

//
//  PROPERTY_SPECIFIER is a serialized form of a PROPSPEC.  Instead of
//  a LPWSTR, there is an offset from the beginning of the
//  PROPERTY_SPECIFICATIONS to a COUNTED_STRING
//
//  #define	PRSPEC_LPWSTR	( 0 )
//  #define	PRSPEC_PROPID	( 1 )

typedef struct _PROPERTY_SPECIFIER
{
    ULONG Variant;                  //  Distinguish the type
    union {                         //  Switch on Variant
        PROPID Id;                  //  Property ID
        ULONG NameOffset;           //  Offset to COUNTED_STRING
    };
} PROPERTY_SPECIFIER, *PPROPERTY_SPECIFIER;


//
//  PROPERTY_SPECIFICATIONS is a serialized form of an array PROPERTY_SPECIFIERs.
//  Immediately following PROPERTY_SPECIFICATIONS on a USHORT boundary are
//  of the name strings.  Each name string is a COUNTED_STRING
//

typedef struct _PROPERTY_SPECIFICATIONS {
    ULONG Length;                   //  Length in bytes of structure and name strings
    ULONG Count;                    //  Count of PROPERTY_SPECIFIERS
    PROPERTY_SPECIFIER Specifiers[1];   //  Array of actual specifiers, length Count
} PROPERTY_SPECIFICATIONS, *PPROPERTY_SPECIFICATIONS;

#define PROPERTY_SPECIFICATIONS_SIZE(c) \
    (VARIABLE_STRUCTURE_SIZE( PROPERTY_SPECIFICATIONS, PROPERTY_SPECIFIER, (c) ))
#define PROPERTY_SPECIFIER_ID(PS,I)      \
    ((PS)->Specifiers[(I)].Id)
#define PROPERTY_SPECIFIER_COUNTED_STRING(PS,I)  \
    ((PCOUNTED_STRING)Add2Ptr( (PS), (PS)->Specifiers[(I)].NameOffset))
#define PROPERTY_SPECIFIER_NAME(PS,I)    \
    (&PROPERTY_SPECIFIER_COUNTED_STRING( PS, I )->Text[0])
#define PROPERTY_SPECIFIER_NAME_LENGTH(PS,I) \
    (PROPERTY_SPECIFIER_COUNTED_STRING( PS, I )->Length)


//
//  PROPERTY_VALUES is a serialized form of an array of SERIALIZEDPROPERTYVALUES.
//  Immediately following the structure are the values, each of which is on a DWORD
//  boundary.  The last PropertyValue (count+1) is used only to help determine the
//  size of the last property value.  The offsets to the values are relative
//  to the address of the PROPERTY_VALUES structure itself.
//

typedef struct _PROPERTY_VALUES {
    ULONG Length;                   //  Length in bytes of structure and values
    ULONG Count;                    //  Count of SERIALIZEDPROPERTYVALUES
    ULONG PropertyValueOffset[1];   //  Array of offsets to actual values, length count + 1
} PROPERTY_VALUES, *PPROPERTY_VALUES;

#define PROPERTY_VALUES_SIZE(c) \
    (VARIABLE_STRUCTURE_SIZE( PROPERTY_VALUES, ULONG, (c) + 1 ))
#define PROPERTY_VALUE_LENGTH(v,i)  \
    ((v)->PropertyValueOffset[(i) + 1] - (v)->PropertyValueOffset[(i)])
#define PROPERTY_VALUE(v,i) \
    ((SERIALIZEDPROPERTYVALUE *) Add2Ptr( (v), (v)->PropertyValueOffset[(i)]))


//
//  PROPERTY_IDS is a serialized form of an array of PROPIDs
//

typedef struct _PROPERTY_IDS {
    ULONG Count;                    //  Count of the number of propids
    PROPID PropertyIds[1];          //  Array of propids, length Count
} PROPERTY_IDS, *PPROPERTY_IDS;

#define PROPERTY_IDS_SIZE(c)    \
    (VARIABLE_STRUCTURE_SIZE( PROPERTY_IDS, PROPID, (c) ))
#define PROPERTY_ID(p,i)        \
    ((p)->PropertyIds[i])


//
//  PROPERTY_NAMES is a serialized array of strings's.  Following the structure
//  are the individual strings, each of which is on a WCHAR boundary.  The
//  offsets to the property names are relative to the beginning of the
//  PROPERTY_NAMES structure.  There are count+1 offsets allowing the length
//  of each to be calculated.
//

typedef struct _PROPERTY_NAMES {
    ULONG Length;                   //  Length in bytes of structure and values
    ULONG Count;                    //  Count of strings
    ULONG PropertyNameOffset[1];    //  Array of offsets to property names.
} PROPERTY_NAMES, *PPROPERTY_NAMES;

#define PROPERTY_NAMES_SIZE(c)  \
    (VARIABLE_STRUCTURE_SIZE( PROPERTY_NAMES, ULONG, (c) + 1 ))
#define PROPERTY_NAME_LENGTH(v,i)   \
    ((v)->PropertyNameOffset[(i) + 1] - (v)->PropertyNameOffset[(i)])
#define PROPERTY_NAME(v,i)          \
    ((PWCHAR) Add2Ptr( (v), (v)->PropertyNameOffset[(i)]))

//
//  All property output buffers are preceded by PROPERTY_OUTPUT_HEADER
//  which contains the amount of data returned.  If STATUS_BUFFER_OVERFLOW
//  is returned, the Length field contains the length required to satisfy
//  the request.
//

typedef struct _PROPERTY_OUTPUT_HEADER {
    ULONG Length;                   //  Total length in bytes of output buffer
} PROPERTY_OUTPUT_HEADER, *PPROPERTY_OUTPUT_HEADER;

//
//  PROPERTY_READ_CONTROL is the structure used to control all property read
//  operations.  Following the structure on a DWORD boundary is either
//  an instaence of PROPERTY_IDS or PROPERTY_SPECIFICATIONS, depending on
//  the operation code.
//
//  On successful output, the data buffer will contain, on DWORD boundaries,
//  in order PROPERTY_VALUES, PROPERTY_IDS, and PROPERTY_NAMES.  Each structure
//  may be absent depending on the setting of the operation code:
//
//  PRC_READ_PROP:   PROPERTY_SPECIFICATIONS => PROPERTY_OUTPUT_HEADER
//                                              PROPERTY_VALUES
//
//  PRC_READ_NAME:   PROPERTY_IDS => PROPERTY_OUTPUT_HEADER
//                                   PROPERTY_NAMES
//
//                             / PROPERTY_OUTPUT_HEADER
//  PRC_READ_ALL:    <empty> =>  PROPERTY_IDS
//                             \ PROPERTY_NAMES
//                               PROPERTY_VALUES
//

typedef enum _READ_CONTROL_OPERATION {
    PRC_READ_PROP = 0,
    PRC_READ_NAME = 1,
    PRC_READ_ALL  = 2,
} READ_CONTROL_OPERATION;

typedef struct _PROPERTY_READ_CONTROL {
    READ_CONTROL_OPERATION Op;
} PROPERTY_READ_CONTROL, *PPROPERTY_READ_CONTROL;


//
//  PROPERTY_WRITE_CONTROL is the structure used to control all property write
//  operations.  Following the structure on a DWORD boundary is either an instance
//  of PROPERTY_IDS or PROPERTY_SPECIFICATIONS (used to control which properties are
//  being changed) and followed by PROPERTY_VALUES and PROPERTY_NAMES.  The
//  presence of these are dependent on the operation code.
//
//  On successful outputs, the data buffer will contain, on DWORD boundaries,
//  in order PROPERTY_IDS.  Each structure may be absent
//  depending on the setting of the operation code:
//
//  PWC_WRITE_PROP:  PROPERTY_SPECIFICATIONS \__/ PROPERTY_OUTPUT_HEADER
//                   PROPERTY_VALUES         /  \ PROPERTY_IDS
//
//  PWC_DELETE_PROP: PROPERTY_SPECIFICATIONS => <empty>
//
//  PWC_WRITE_NAME:  PROPERTY_IDS   \__ <empty>
//                   PROPERTY_NAMES /
//
//  PWC_DELETE_NAME: PROPERTY_IDS => <empty>
//
//                   PROPERTY_IDS    \
//  PWC_WRITE_ALL:   PROPERTY_NAMES   => <empty>
//                   PROPERTY_VALUES /

typedef enum _WRITE_CONTROL_OPERATION {
    PWC_WRITE_PROP  = 0,
    PWC_DELETE_PROP = 1,
    PWC_WRITE_NAME  = 2,
    PWC_DELETE_NAME = 3,
    PWC_WRITE_ALL   = 4,
} WRITE_CONTROL_OPERATION;

typedef struct _PROPERTY_WRITE_CONTROL {
    WRITE_CONTROL_OPERATION Op;
    PROPID NextPropertyId;
} PROPERTY_WRITE_CONTROL, *PPROPERTY_WRITE_CONTROL;

#ifdef __cplusplus
}
#endif

#endif  //  _NTFSPROP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ossmmgmt.h ===
/*****************************************************************************/
/* Copyright (C) 1991-1999 Open Systems Solutions, Inc.  All rights reserved.*/
/*****************************************************************************/

/* THIS FILE IS PROPRIETARY MATERIAL OF OPEN SYSTEMS SOLUTIONS, INC.
 * AND MAY ONLY BE USED BY DIRECT LICENSEES OF OPEN SYSTEMS SOLUTIONS, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED. */

/*************************************************************************/
/* FILE: @(#)ossmmgmt.h	5.8.1.2  97/10/20       */
/*************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#include <stddef.h>
#include "ossdll.h"


enum errcode {
    moreInput,          /* input is exhausted and more was requested;
			   context indicates number of bytes requested */
			/* decode returns MORE_INPUT (not a negative
			   error code) */
    moreOutput,         /* requests for output exceed restraint
			   or space provided by user buffer;
			   context indicates bytes allocated so far
			   plus amount requested */
			/* decode returns MORE_BUF */
    zeroBytesRequested, /* memory request for zero bytes.
			   This should not happen; report error to OSS;
			   context ignored */
			/* decode returns FATAL_ERROR */
    sizeTooBig,         /* request to allocate more than 'ossblock' bytes;
			   context indicates number of bytes requested;
			   This should not happen; report error to OSS */
			/* decode returns FATAL_ERROR */
    outOfMemory,        /* memory allocation failure; context indicates
			   number of bytes requested */
			/* decode returns OUT_MEMORY */
    invalidObject,      /* unrecognized memory object passed in argument
			   to function; context 0 means object not recognized,
			   1 means control information within object is flawed */
			/* decode returns FATAL_ERROR */
#ifdef LEAN_STACK
    moreStack,          /* requests for stack storage exceed
			   space provided by user buffer;
			   context indicates bytes allocated so far
			   plus amount requested */
			/* decode returns MORE_BUF */
    hookedStack,        /* request for stack storage cannot be
			   served in the parent context (world) when
			   user-provided buffer is used by the child
			   context */
			/* decode returns MEM_ERROR */
#endif
    memmgrUndefinedErr  /* error OSS has not anticipated; e.g., I/O Error;
			   handlerr prints context.
			   (I cannot print context as a hex value
			   with the current error message code <---) */
			/* decode returns FATAL_ERROR */
};

extern void     handlerr(struct ossGlobal *, enum errcode err, unsigned long context);
extern int      DLL_ENTRY dpduWalk(struct ossGlobal *, int, void *, void *,
			void (DLL_ENTRY_FPTR *_System freer)(struct ossGlobal *, void *));
#if defined(_WINDOWS) || defined(_WIN32) || \
    defined(__OS2__)  || defined(NETWARE_DLL)
extern void     DLL_ENTRY ossFreer(void *, void *);
#else
#ifndef _ICC
static void     DLL_ENTRY freer(struct ossGlobal *, void *);
#endif /* _ICC */
#endif /* _WINDOWS || _WIN32 || __OS2__ || NETWARE_DLL */

int             DLL_ENTRY ossMemMgrId(struct ossGlobal *);

unsigned char  *DLL_ENTRY dopenIn(struct ossGlobal *, void **p_hdl, unsigned long *inlen);
unsigned long   DLL_ENTRY dclosIn(struct ossGlobal *, void **p_hdl, size_t bytes_decoded);
unsigned char  *DLL_ENTRY dswapIn(struct ossGlobal *, void **p_hdl, size_t *inlen);
void            DLL_ENTRY dopenOut(struct ossGlobal *, void *hdl, unsigned long length,
                        unsigned long limit);
unsigned long   DLL_ENTRY dclosOut(struct ossGlobal *, void **p_hdl);
void           *DLL_ENTRY dallcOut(struct ossGlobal *, size_t size, char root);
#ifdef LEAN_STACK
void  	        DLL_ENTRY_FDEF openStack(struct ossGlobal *world, OssBuf *stack);
void  	        DLL_ENTRY_FDEF hookStack(struct ossGlobal *world, struct ossGlobal *root);
void  	        DLL_ENTRY_FDEF unhookStack(struct ossGlobal *world, struct ossGlobal *root);
void           *DLL_ENTRY_FDEF allocStack(struct ossGlobal *world, size_t size);
unsigned char  *DLL_ENTRY_FDEF lockStack(struct ossGlobal *world, void *hdl);
void  	        DLL_ENTRY_FDEF freeStack(struct ossGlobal *world, void *hdl);
void  		DLL_ENTRY_FDEF closeStack(struct ossGlobal *world);
#endif /* LEAN_STACK */
void            DLL_ENTRY openWork(struct ossGlobal *);
void            DLL_ENTRY closWork(struct ossGlobal *);
void           *DLL_ENTRY allcWork(struct ossGlobal *, size_t size);
unsigned char  *DLL_ENTRY lockMem(struct ossGlobal *, void *hdl);
void            DLL_ENTRY unlokMem(struct ossGlobal *, void *hdl, char free);
void            DLL_ENTRY pushHndl(struct ossGlobal *, void *);
unsigned char  *DLL_ENTRY popHndl(struct ossGlobal *, void **handl, size_t length);
void            DLL_ENTRY drcovObj(struct ossGlobal *, int pdu_num, void * hdl, void *ctl_tbl);

unsigned char  *DLL_ENTRY eopenIn(struct ossGlobal *, void *lock, size_t length);	/* Clear encoder input-memory resources */
unsigned char  *DLL_ENTRY eswapIn(struct ossGlobal *, void *unlock, void *lock, size_t length);	/* Swap new data into input memory */
void            DLL_ENTRY eclosIn(struct ossGlobal *, void * unlock); /* Free encoder input-memory resources */

unsigned char  *DLL_ENTRY eopenOut(struct ossGlobal *, void **object, size_t *outlen, char queue);   /* Clear encoder output-memory resources */
unsigned char  *DLL_ENTRY eswapOut(struct ossGlobal *, void **object, size_t used, size_t *outlen);  /* Dispose of output data and get memory */
unsigned char  *DLL_ENTRY exferObj(struct ossGlobal *, void **, void **, unsigned long *, unsigned long);
unsigned char  *DLL_ENTRY dxferObj(struct ossGlobal *world, void **inn, void **out, size_t *tOffset, unsigned long *toLength);
unsigned char  *DLL_ENTRY asideBegin(struct ossGlobal *world, void **objectTo, size_t used, size_t *lengthTo);
unsigned char  *DLL_ENTRY asideSwap(struct ossGlobal *world, void **objectTo, size_t used, size_t *lengthTo);
void           *DLL_ENTRY asideEnd(struct ossGlobal *world, void *object, size_t used);
unsigned char  *DLL_ENTRY setDump(struct ossGlobal *world, void **objectTo, void *set, size_t *lengthTo);
unsigned long   DLL_ENTRY eclosOut(struct ossGlobal *, void **object, size_t used, char low);        /* Free encoder output-memory resources */
void            DLL_ENTRY ercovObj(struct ossGlobal *);	/* Free all encoder memory resources */
void            DLL_ENTRY ossSetSort(struct ossGlobal *, void *, unsigned char ct);	/* Order set by comparing through "ossObjCmp" */
unsigned char   DLL_ENTRY egetByte(struct ossGlobal *world, void *inn, unsigned long offset);
extern int      DLL_ENTRY ossMinit(struct ossGlobal *world);
extern void     DLL_ENTRY ossMterm(struct ossGlobal *world);
void           *DLL_ENTRY _ossMarkObj(struct ossGlobal *world, OssObjType objType, void *object);
void           *DLL_ENTRY _ossUnmarkObj(struct ossGlobal *world, void *objHndl);
void           *DLL_ENTRY _ossGetObj(struct ossGlobal *world, void *objHndl);
#if defined(__arm)
OssObjType      DLL_ENTRY _ossTestObj(struct ossGlobal *world, void *objHndl);
#else
void           *DLL_ENTRY _ossTestObj(struct ossGlobal *world, void *objHndl);
#endif /* __arm */
void            DLL_ENTRY _ossFreeObjectStack(struct ossGlobal *world);
void            DLL_ENTRY _ossSetTimeout(struct ossGlobal *world, long timeout);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ntquery.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-1999.
//
//  File:       NtQuery.h
//
//  Contents:   Main query header; Defines all exported query API
//
//----------------------------------------------------------------------------

#if !defined(__NTQUERY_H__)
#define __NTQUERY_H__

#if _MSC_VER > 1000
#pragma once
#endif

#if defined(__cplusplus)
extern "C"
{
#endif

//
// Use this path for the null catalog, one that doesn't have an index.
// Use it to search for properties of files that are not indexed.
//

#define CINULLCATALOG L"::_noindex_::"

//
// Use this path to connect to the server for administration work
// (i.e. DocStoreAdmin.) No catalog is associated with the connection
//

#define CIADMIN L"::_nodocstore_::"

//
// Minimal support for persistent handlers.
//

STDAPI LoadIFilter( WCHAR const * pwcsPath,
                    IUnknown *    pUnkOuter,
                    void **       ppIUnk );

STDAPI BindIFilterFromStorage( IStorage * pStg,
                               IUnknown * pUnkOuter,
                               void **    ppIUnk );

STDAPI BindIFilterFromStream( IStream *  pStm,
                              IUnknown * pUnkOuter,
                              void **    ppIUnk );

STDAPI LocateCatalogsW( WCHAR const * pwszScope,
                        ULONG         iBmk,
                        WCHAR *       pwszMachine,
                        ULONG *       pccMachine,
                        WCHAR *       pwszCat,
                        ULONG *       pccCat );

//
// For calling from VB
//

STDAPI LocateCatalogsA( char const * pwszScope,
                        ULONG        iBmk,
                        char  *      pwszMachine,
                        ULONG *      pccMachine,
                        char *       pwszCat,
                        ULONG *      pccCat );

#ifdef UNICODE
#define LocateCatalogs  LocateCatalogsW
#else
#define LocateCatalogs  LocateCatalogsA
#endif // !UNICODE

// The Index Server Data Source Object CLSID

#define CLSID_INDEX_SERVER_DSO \
    { 0xF9AE8980, 0x7E52, 0x11d0, \
      { 0x89, 0x64, 0x00, 0xC0, 0x4F, 0xD6, 0x11, 0xD7 } }


// The storage property set

#define PSGUID_STORAGE \
    { 0xb725f130, 0x47ef, 0x101a, \
      { 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac } }

//#define PID_STG_DICTIONARY            ((PROPID) 0x00000000) //reserved
//#define PID_STG_CODEPAGE              ((PROPID) 0x00000001) //reserved
#define PID_STG_DIRECTORY               ((PROPID) 0x00000002)
#define PID_STG_CLASSID                 ((PROPID) 0x00000003)
#define PID_STG_STORAGETYPE             ((PROPID) 0x00000004)
#define PID_STG_VOLUME_ID               ((PROPID) 0x00000005)
#define PID_STG_PARENT_WORKID           ((PROPID) 0x00000006)
#define PID_STG_SECONDARYSTORE          ((PROPID) 0x00000007)
#define PID_STG_FILEINDEX               ((PROPID) 0x00000008)
#define PID_STG_LASTCHANGEUSN           ((PROPID) 0x00000009)
#define PID_STG_NAME                    ((PROPID) 0x0000000a)
#define PID_STG_PATH                    ((PROPID) 0x0000000b)
#define PID_STG_SIZE                    ((PROPID) 0x0000000c)
#define PID_STG_ATTRIBUTES              ((PROPID) 0x0000000d)
#define PID_STG_WRITETIME               ((PROPID) 0x0000000e)
#define PID_STG_CREATETIME              ((PROPID) 0x0000000f)
#define PID_STG_ACCESSTIME              ((PROPID) 0x00000010)
#define PID_STG_CHANGETIME              ((PROPID) 0x00000011)
#define PID_STG_CONTENTS                ((PROPID) 0x00000013)
#define PID_STG_SHORTNAME               ((PROPID) 0x00000014)
#define PID_STG_MAX                     PID_STG_SHORTNAME
#define CSTORAGEPROPERTY                0x15

// File System Content Index Framework property set

#define DBPROPSET_FSCIFRMWRK_EXT \
    { 0xA9BD1526, 0x6A80, 0x11D0, \
      { 0x8C, 0x9D, 0x00, 0x20, 0xAF, 0x1D, 0x74, 0x0E } }

#define DBPROP_CI_CATALOG_NAME     2
#define DBPROP_CI_INCLUDE_SCOPES   3
#define DBPROP_CI_DEPTHS           4 // obsolete
#define DBPROP_CI_SCOPE_FLAGS      4
#define DBPROP_CI_EXCLUDE_SCOPES   5
#define DBPROP_CI_SECURITY_ID      6
#define DBPROP_CI_QUERY_TYPE       7

// Query Extension property set

#define DBPROPSET_QUERYEXT \
    { 0xA7AC77ED, 0xF8D7, 0x11CE, \
      { 0xA7, 0x98, 0x00, 0x20, 0xF8, 0x00, 0x80, 0x25 } }

#define DBPROP_USECONTENTINDEX           2
#define DBPROP_DEFERNONINDEXEDTRIMMING   3
#define DBPROP_USEEXTENDEDDBTYPES        4
#define DBPROP_FIRSTROWS                 7

// Content Index Framework Core property set

#define DBPROPSET_CIFRMWRKCORE_EXT \
    { 0xafafaca5, 0xb5d1, 0x11d0, \
      { 0x8c, 0x62, 0x00, 0xc0, 0x4f, 0xc2, 0xdb, 0x8d } }

#define DBPROP_MACHINE      2
#define DBPROP_CLIENT_CLSID 3

// MSIDXS Rowset property set

#define DBPROPSET_MSIDXS_ROWSETEXT \
    { 0xaa6ee6b0, 0xe828, 0x11d0, \
      { 0xb2, 0x3e, 0x00, 0xaa, 0x00, 0x47, 0xfc, 0x01 } }

#define MSIDXSPROP_ROWSETQUERYSTATUS        2
#define MSIDXSPROP_COMMAND_LOCALE_STRING    3
#define MSIDXSPROP_QUERY_RESTRICTION        4

//
// Query status values returned by MSIDXSPROP_ROWSETQUERYSTATUS
//
// Bits   Effect
// -----  -----------------------------------------------------
// 00-02  Fill Status: How data is being updated, if at all.
// 03-15  Bitfield query reliability: How accurate the result is

#define STAT_BUSY                       ( 0 )
#define STAT_ERROR                      ( 0x1 )
#define STAT_DONE                       ( 0x2 )
#define STAT_REFRESH                    ( 0x3 )
#define QUERY_FILL_STATUS(x)            ( ( x ) & 0x7 )

#define STAT_PARTIAL_SCOPE              ( 0x8 )
#define STAT_NOISE_WORDS                ( 0x10 )
#define STAT_CONTENT_OUT_OF_DATE        ( 0x20 )
#define STAT_REFRESH_INCOMPLETE         ( 0x40 )
#define STAT_CONTENT_QUERY_INCOMPLETE   ( 0x80 )
#define STAT_TIME_LIMIT_EXCEEDED        ( 0x100 )
#define STAT_SHARING_VIOLATION          ( 0x200 )
#define QUERY_RELIABILITY_STATUS(x)     ( ( x ) & 0xFFF8 )

// Scope flags

#define QUERY_SHALLOW        0
#define QUERY_DEEP           1
#define QUERY_PHYSICAL_PATH  0
#define QUERY_VIRTUAL_PATH   2

// query property set (PSGUID_QUERY) properties not defined in oledb.h

#define PROPID_QUERY_WORKID        5
#define PROPID_QUERY_UNFILTERED    7
#define PROPID_QUERY_VIRTUALPATH   9
#define PROPID_QUERY_LASTSEENTIME 10

//
// Change or get the current state of a catalog specified.
//
#define CICAT_STOPPED     0x1
#define CICAT_READONLY    0x2
#define CICAT_WRITABLE    0x4
#define CICAT_NO_QUERY    0x8
#define CICAT_GET_STATE   0x10
#define CICAT_ALL_OPENED  0x20

STDAPI SetCatalogState ( WCHAR const * pwcsCat,
                         WCHAR const * pwcsMachine,
                         DWORD dwNewState,
                         DWORD * pdwOldState );

//
// Query catalog state
//

#define CI_STATE_SHADOW_MERGE          0x0001    // Index is performing a shadow merge
#define CI_STATE_MASTER_MERGE          0x0002    // Index is performing a master merge
#define CI_STATE_CONTENT_SCAN_REQUIRED 0x0004    // Index is likely corrupt, and a rescan is required
#define CI_STATE_ANNEALING_MERGE       0x0008    // Index is performing an annealing (optimizing) merge
#define CI_STATE_SCANNING              0x0010    // Scans are in-progress
#define CI_STATE_RECOVERING            0x0020    // Index metadata is being recovered
#define CI_STATE_INDEX_MIGRATION_MERGE 0x0040    // Reserved for future use
#define CI_STATE_LOW_MEMORY            0x0080    // Indexing is paused due to low memory availability
#define CI_STATE_HIGH_IO               0x0100    // Indexing is paused due to a high rate of I/O
#define CI_STATE_MASTER_MERGE_PAUSED   0x0200    // Master merge is paused
#define CI_STATE_READ_ONLY             0x0400    // Indexing has been manually paused (read-only)
#define CI_STATE_BATTERY_POWER         0x0800    // Indexing is paused to conserve battery life
#define CI_STATE_USER_ACTIVE           0x1000    // Indexing is paused due to high user activity (keyboard/mouse)
#define CI_STATE_STARTING              0x2000    // Index is still starting up
#define CI_STATE_READING_USNS          0x4000    // USNs on NTFS volumes are being processed

#ifndef CI_STATE_DEFINED
#define CI_STATE_DEFINED
#include <pshpack4.h>
typedef struct  _CI_STATE
    {
    DWORD cbStruct;
    DWORD cWordList;
    DWORD cPersistentIndex;
    DWORD cQueries;
    DWORD cDocuments;
    DWORD cFreshTest;
    DWORD dwMergeProgress;
    DWORD eState;
    DWORD cFilteredDocuments;
    DWORD cTotalDocuments;
    DWORD cPendingScans;
    DWORD dwIndexSize;
    DWORD cUniqueKeys;
    DWORD cSecQDocuments;
    DWORD dwPropCacheSize;
    }   CI_STATE;

#include <poppack.h>
#endif   // CI_STATE_DEFINED

STDAPI CIState( WCHAR const * pwcsCat,
                WCHAR const * pwcsMachine,
                CI_STATE *    pCiState );

#if defined __ICommand_INTERFACE_DEFINED__

//
// Create an ICommand, specifying scopes, catalogs, and machines
//
STDAPI CIMakeICommand( ICommand **           ppCommand,
                       ULONG                 cScope,
                       DWORD const *         aDepths,
                       WCHAR const * const * awcsScope,
                       WCHAR const * const * awcsCatalogs,
                       WCHAR const * const * awcsMachine );

//
// Create an ICommand, specifying a catalog and machine
//

STDAPI CICreateCommand( IUnknown **   ppCommand,     // New object
                        IUnknown *    pUnkOuter,     // Outer unknown
                        REFIID        riid,          // IID of returned object.
                                                     // Must be IID_IUnknown unless pUnkOuter == 0
                        WCHAR const * pwcsCatalog,   // Catalog
                        WCHAR const * pwcsMachine ); // Machine


#if defined __ICommandTree_INTERFACE_DEFINED__

typedef struct tagCIPROPERTYDEF
{
    LPWSTR wcsFriendlyName;
    DWORD  dbType;
    DBID   dbCol;
} CIPROPERTYDEF;

//
// Values for ulDialect in CITextToSelectTreeEx and CITextToFullTreeEx
//

#define ISQLANG_V1 1 // Same as the non-Ex versions
#define ISQLANG_V2 2

//
// Convert pwszRestriction in Triplish to a command tree.
//
STDAPI CITextToSelectTree( WCHAR const *     pwszRestriction,
                           DBCOMMANDTREE * * ppTree,
                           ULONG             cProperties,
             /*optional*/  CIPROPERTYDEF *   pProperties,
                           LCID              LocaleID );

STDAPI CITextToSelectTreeEx( WCHAR const *     pwszRestriction,
                             ULONG             ulDialect,
                             DBCOMMANDTREE * * ppTree,
                             ULONG             cProperties,
               /*optional*/  CIPROPERTYDEF *   pProperties,
                             LCID              LocaleID );

//
// Convert pwszRestriction in Triplish, project columns, sort columns
// and grouping columns to a command tree.
//
STDAPI CITextToFullTree( WCHAR const *     pwszRestriction,
                         WCHAR const *     pwszColumns,
                         WCHAR const *     pwszSortColumns, // may be NULL
                         WCHAR const *     pwszGroupings,   // may be NULL
                         DBCOMMANDTREE * * ppTree,
                         ULONG             cProperties,
           /*optional*/  CIPROPERTYDEF *   pProperties,
                         LCID              LocaleID );

STDAPI CITextToFullTreeEx( WCHAR const *     pwszRestriction,
                           ULONG             ulDialect,
                           WCHAR const *     pwszColumns,
                           WCHAR const *     pwszSortColumns, // may be NULL
                           WCHAR const *     pwszGroupings,   // may be NULL
                           DBCOMMANDTREE * * ppTree,
                           ULONG             cProperties,
             /*optional*/  CIPROPERTYDEF *   pProperties,
                           LCID              LocaleID );

//
// Build a simple restriction node.
//

STDAPI CIBuildQueryNode( WCHAR const *wcsProperty,    // friendly property name
                         DBCOMMANDOP dbOperator,    // enumerated constant
                         PROPVARIANT const *pvarPropertyValue, // value of the property
                         DBCOMMANDTREE ** ppTree, // ptr to tree returned here. should be non-null
                         ULONG cProperties,
                         CIPROPERTYDEF const * pProperty, // Can be 0.
                         LCID LocaleID );  // locale id to interpret strings

//
// Build a restriction tree from an existing tree (could be empty) and a newly added node/tree.
//

STDAPI CIBuildQueryTree( DBCOMMANDTREE const *pExistingTree,  // existing tree. can be null.
                         DBCOMMANDOP dbBoolOp,   // enumerator constant
                         ULONG cSiblings, // number of siblings in the array
                         DBCOMMANDTREE const * const *ppSibsToCombine,
                         DBCOMMANDTREE ** ppTree);   // ptr to tree returned here. should be non-null

//
// Convert restriction tree, project columns, sort columns
// and grouping columns to a command tree.
//
STDAPI CIRestrictionToFullTree( DBCOMMANDTREE const *pTree,
                         WCHAR const * pwszColumns,
                         WCHAR const * pwszSortColumns, // may be NULL
                         WCHAR const * pwszGroupings,   // may be NULL
                         DBCOMMANDTREE * * ppTree,
                         ULONG cProperties,
           /*optional*/  CIPROPERTYDEF * pReserved,
                         LCID LocaleID );

#endif  // __ICommandTree_INTERFACE_DEFINED__
#endif  // __ICommand_INTERFACE_DEFINED__

#if defined(__cplusplus)
}
#endif

#endif // __NTQUERY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\nt_vdd.h ===
/*
 *  Copyright (C) Microsoft Corporation, 1990-1999
 *  nt_vdd.h
 *
 *  VDD services exports and defines
 *
 */

#ifndef _NT_VDD
#define _NT_VDD

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * IO port service prototypes and data structure definitions
 **/

/** Basic typedefs of VDD IO hooks **/

typedef VOID (*PFNVDD_INB)   (WORD iport,BYTE * data);
typedef VOID (*PFNVDD_INW)   (WORD iport,WORD * data);
typedef VOID (*PFNVDD_INSB)  (WORD iport,BYTE * data,WORD count);
typedef VOID (*PFNVDD_INSW)  (WORD iport,WORD * data,WORD count);
typedef VOID (*PFNVDD_OUTB)  (WORD iport,BYTE data);
typedef VOID (*PFNVDD_OUTW)  (WORD iport,WORD data);
typedef VOID (*PFNVDD_OUTSB) (WORD iport,BYTE * data,WORD count);
typedef VOID (*PFNVDD_OUTSW) (WORD iport,WORD * data,WORD count);

/**  Array of handlers for VDD IO hooks. **/

typedef struct _VDD_IO_HANDLERS {
    PFNVDD_INB   inb_handler;
    PFNVDD_INW   inw_handler;
    PFNVDD_INSB  insb_handler;
    PFNVDD_INSW  insw_handler;
    PFNVDD_OUTB  outb_handler;
    PFNVDD_OUTW  outw_handler;
    PFNVDD_OUTSB outsb_handler;
    PFNVDD_OUTSW outsw_handler;
} VDD_IO_HANDLERS, *PVDD_IO_HANDLERS;

/** Port Range structure **/

typedef struct _VDD_IO_PORTRANGE {
        WORD   First;
        WORD   Last;
} VDD_IO_PORTRANGE, *PVDD_IO_PORTRANGE;


BOOL VDDInstallIOHook (
     HANDLE            hVDD,
     WORD              cPortRange,
     PVDD_IO_PORTRANGE pPortRange,
     PVDD_IO_HANDLERS  IOhandler
);


VOID VDDDeInstallIOHook (
     HANDLE            hVdd,
     WORD              cPortRange,
     PVDD_IO_PORTRANGE pPortRange
);


WORD VDDReserveIrqLine (
     HANDLE hVdd,
     WORD IrqLine
     );

BOOL VDDReleaseIrqLine (
     HANDLE hVdd,
     WORD IrqLine
     );

/**
 * DMA service prototypes and data structure definitions
 **/


/** Buffer definition for returning DMA information **/

typedef struct _VDD_DMA_INFO {
    WORD    addr;
    WORD    count;
    WORD    page;
    BYTE    status;
    BYTE    mode;
    BYTE    mask;
} VDD_DMA_INFO, *PVDD_DMA_INFO;

/** bits for querying the DMA information **/

#define VDD_DMA_ADDR    0x01
#define VDD_DMA_COUNT   0x02
#define VDD_DMA_PAGE    0x04
#define VDD_DMA_STATUS  0x08
#define VDD_DMA_ALL VDD_DMA_ADDR | VDD_DMA_COUNT | VDD_DMA_PAGE | VDD_DMA_STATUS


DWORD VDDRequestDMA (
    HANDLE hVDD,
    WORD  iChannel,
    PVOID Buffer,
    DWORD  length
);


BOOL VDDSetDMA (
    HANDLE hVDD,
    WORD iChannel,
    WORD fDMA,
    PVDD_DMA_INFO Buffer
);


BOOL VDDQueryDMA (
     HANDLE        hVDD,
     WORD          iChannel,
     PVDD_DMA_INFO pDmaInfo
);


/**
 * Memory mapped I/O service prototypes and data structure definitions
 **/

typedef VOID (*PVDD_MEMORY_HANDLER) (PVOID FaultAddress, ULONG RWMode);

BOOL VDDInstallMemoryHook (
   HANDLE hVDD,
   PVOID pStart,
   DWORD count,
   PVDD_MEMORY_HANDLER MemoryHandler
);

BOOL VDDDeInstallMemoryHook (
   HANDLE hVDD,
   PVOID pStart,
   DWORD count
);

BOOL VDDAllocMem(
  HANDLE hVDD,
  PVOID Address,
  DWORD Size
);


BOOL VDDFreeMem(
  HANDLE hVDD,
  PVOID Address,
  DWORD Size
);

/**
 * Misc. service prototypes and data structure definitions
 **/


BOOL VDDIncludeMem(
  HANDLE hVDD,
  PVOID Address,
  DWORD Size
);


VOID VDDTerminateVDM();

/** Basic typedefs of VDD User hooks **/

typedef VOID (*PFNVDD_UCREATE)      (USHORT DosPDB);
typedef VOID (*PFNVDD_UTERMINATE)   (USHORT DosPDB);
typedef VOID (*PFNVDD_UBLOCK)       (VOID);
typedef VOID (*PFNVDD_URESUME)      (VOID);

/**  Array of handlers for VDD User hooks. **/

typedef struct _VDD_USER_HANDLERS {
    HANDLE              hvdd;
    PFNVDD_UCREATE      ucr_handler;
    PFNVDD_UTERMINATE   uterm_handler;
    PFNVDD_UBLOCK       ublock_handler;
    PFNVDD_URESUME      uresume_handler;
    struct _VDD_USER_HANDLERS *next;
} VDD_USER_HANDLERS, *PVDD_USER_HANDLERS;

/** Function prototypes **/

BOOL VDDInstallUserHook (
     HANDLE             hVDD,
     PFNVDD_UCREATE     Ucr_Handler,
     PFNVDD_UTERMINATE  Uterm_Handler,
     PFNVDD_UBLOCK      Ublock_handler,
     PFNVDD_URESUME     Uresume_handler
);


BOOL VDDDeInstallUserHook (
     HANDLE            hVdd
);

VOID VDDTerminateUserHook(USHORT DosPDB);
VOID VDDCreateUserHook(USHORT DosPDB);
VOID VDDBlockUserHook(VOID);
VOID VDDResumeUserHook(VOID);

VOID VDDSimulate16(VOID);


SHORT  VDDAllocateDosHandle(ULONG pPDB, PVOID* ppSFT, PVOID* ppJFT);
VOID   VDDAssociateNtHandle(PVOID pSFT, HANDLE h32File, WORD wAccess);
BOOL   VDDReleaseDosHandle (ULONG pPDB, SHORT hFile);
HANDLE VDDRetrieveNtHandle (ULONG pPDB, SHORT hFile, PVOID* ppSFT, PVOID* ppJFT);


VOID
VdmTraceEvent(
    USHORT Type,
    USHORT wData,
    ULONG  lData
    );

#if DBG
#define VDM_TRACE(Type, wData, lData) VdmTraceEvent(Type, wData, lData)
#else
#define VDM_TRACE(Type, wData, lData) TRUE
#endif

typedef enum {
    VDM_V86,
    VDM_PM
} VDM_MODE;

typedef enum {
    VDM_NO_ERROR,
    VDM_ERROR_INVALID_BUFFER_SIZE,
    VDM_ERROR_INVALID_FUNCTION,
} VDM_ERROR_TYPE;

typedef enum {
    VDM_GET_TICK_COUNT,
    VDM_GET_TIMER0_INITIAL_COUNT,
    VDM_GET_LAST_UPDATED_TIMER0_COUNT,
    VDM_LATCH_TIMER0_COUNT,
    VDM_SET_NEXT_TIMER0_COUNT,
} VDM_INFO_TYPE;

#ifndef MSW_PE
#define MSW_PE 0x1
#endif

#define getMODE() ((getMSW() & MSW_PE) ? VDM_PM : VDM_V86)

PVOID
VdmMapFlat(
    USHORT selector,
    ULONG offset,
    VDM_MODE mode
    );

#ifdef _X86_

#define VdmUnmapFlat(sel, off, buffer, mode) TRUE
#define VdmFlushCache(sel, off, len, mode) TRUE

#else

BOOL
VdmUnmapFlat(
    USHORT selector,
    ULONG offset,
    PVOID buffer,
    VDM_MODE mode
    );


BOOL
VdmFlushCache(
    USHORT selector,
    ULONG offset,
    ULONG length,
    VDM_MODE mode
    );

#endif

BOOL
VdmParametersInfo(
    VDM_INFO_TYPE infotype,
    PVOID pBuffer,
    ULONG cbBufferSize
    );

VDM_INFO_TYPE
VdmGetParametersInfoError(
    VOID
    );

#ifdef __cplusplus
}
#endif

#endif  // ifndef _NT_VDD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ossber.h ===
/*****************************************************************************/
/* Copyright (C) 1989-1999 Open Systems Solutions, Inc.  All rights reserved.*/
/*****************************************************************************/

/* THIS FILE IS PROPRIETARY MATERIAL OF OPEN SYSTEMS SOLUTIONS, INC.
 * AND MAY BE USED ONLY BY DIRECT LICENSEES OF OPEN SYSTEMS SOLUTIONS, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED. */

/**************************************************************************/
/*
 * FILE: @(#)coderror.h	5.16.1.1  97/10/20
# @(#)errindex.sh	1.5 94/06/22
 */
/* FILE: @(#)ossber.hh	5.32  97/06/17				  */
/*							 		  */
/* function: Define the interfaces to the routines in ossber.a for the    */
/* OSS optimized encoder and decoder.					  */
/*									  */
/*									  */
/* changes:								  */
/*	06/28/90  pet	created 					  */
/*									  */
/**************************************************************************/

#ifndef ossber_hdr_file
#define ossber_hdr_file

#if _MSC_VER > 1000
#pragma once
#endif

#include <setjmp.h>
#include "asn1hdr.h"

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(push, ossPacking, 4)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack(1)
#elif defined(__BORLANDC__) && defined(__MSDOS__)
#ifdef _BC31
#pragma option -a-
#else
#pragma option -a1
#endif /* _BC31 */
#elif defined(__BORLANDC__) && defined(__WIN32__)
#pragma option -a4
#elif defined(__IBMC__)
#pragma pack(4)
#elif defined(__WATCOMC__) && defined(__NT__)
#pragma pack(push, 4)
#elif defined(__WATCOMC__) && (defined(__WINDOWS__) || defined(__DOS__))
#pragma pack(push, 1)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=mac68k
#endif

#define _dstd_parms_def char **_pos, long *_buf_len, long _length
#define _dstd_parms _pos, _buf_len, _length
#define _sdstd_parms_def char **_pos, long *_buf_len
#define _sdstd_parms _pos, _buf_len

#define _std_parms_def char **_pos, long *_max_len, _Bool _userbuf
#define _std_parms _pos, _max_len, _userbuf

#ifndef OSS_BOOL
#define OSS_BOOL
typedef char    _Bool;
#endif

#ifdef __cplusplus
extern "C"
{
#endif

/* Entry Points for the Interface Routines */

#ifndef _OSSNOANSI

typedef    int       (DLL_ENTRY_FPTR *_System _Encode_function)(struct ossGlobal *world, int pdunum,
	                void *inbuf, char **outbuf, long *outlen,
	                void *ctl_tbl, unsigned flags,
	                char errmsg[]);

typedef    int       (DLL_ENTRY_FPTR *_System _Decode_function)(struct ossGlobal *world, int *pduNum,
	                char **inbuf, long *inlen, void **outbuf,
	                long *outlen, void *ctl_tbl, unsigned flags,
	                char errmsg[]);

typedef    int       (DLL_ENTRY_FPTR *_System _FreePDU_function)(struct ossGlobal *world, int pdunum,
                        void *data, void *ctl_tbl);

typedef    void      (DLL_ENTRY_FPTR *_System _Ossinit_function)(struct ossGlobal *);

#else

typedef    int       (*_Encode_function)();

typedef    int       (*_Decode_function)();

typedef    int       (*_FreePDU_function)();

typedef    void      (*_Ossinit_function)();

#endif /* _OSSNOANSI */


typedef struct _entry_point_struct_ {
	_Ossinit_function	_ossinit_function;
	_Encode_function        _ber_encode_function;
	_Decode_function        _ber_decode_function;
	_FreePDU_function	_freePDU_function;
	unsigned short int      _oss_ber_version_number;
	_Encode_function        _per_encode_function;
	_Decode_function        _per_decode_function;
	unsigned short int      _oss_per_version_number;
	unsigned int            _oss_pa_count;
	struct _char_data       *_chars_ptr;
}               _entry_point_struct;





/* Error Handling */


/* The index to the error messages.  NOTE:  The enumerated constants here
   must match those in coderror.h. */

enum _err_index {
_no_msg , _small_buffer , _type_not_impl , _pdu_range ,
_bad_argument , _version_mismatch_toed , _version_mismatch_soed ,
_out_stor , _bad_choice , _stor_error , _int_too_long ,
_uint_too_long , _bit_str_comp , _access_serialization ,
_constrainedBy , _singleValue_integer , _singleValue_uinteger ,
_singleValue_real , _singleValue_string , _singleValue_void ,
_valueRange_integer , _valueRange_uinteger , _valueRange_real ,
_sizeConstraint_length , _sizeConstraint_number , _oPA_constraint
, _absence_constraint , _presence_constraint , _openType_error ,
_tableConstraint , _componentRelation , _not_enumerated ,
_null_tbl , _null_fcn , _corrupted_tbl , _neg_uinteger ,
_typeConstraint , _bit_str_too_long , _pdu_range_recursive ,
_enc_oid_too_long , _more_input , _more_output ,
_zero_bytes_requested , _size_too_big , _out_of_memory ,
_invalid_object , _memmgr_undefined_err , _bad_encrules_err ,
_toed_rules_not_impl_err , _unlinked_encrules_err ,
_table_mismatch , _type_not_supported ,
_type_not_supported_decreal , _real_dll_failed ,
_indef_length_not_supported , _cstrain_dll_failed ,
_cmp_dll_failed , _cmp_code_not_linked , _real_code_not_linked ,
_pdv_code_not_linked , _pdv_dll_failed , _oid_dll_failed ,
_type_not_supported_der_toed , _toed_rules_not_supp_err ,
_bad_objid , _bad_pointer , _bad_time , _bad_der_time , _too_long
, _toom_field , _mandatory_field , _zero_length_ANY ,
_zero_length_OpenType , _inval_dec_real , _inval_mixed_real ,
_tag_long_nec , _tag_too_long , _exp_long_nec , _exp_too_long ,
_int_long_nec , _subid_long_nec , _subid_too_long ,
_length_too_long , _size_too_long , _non_std_eoc , _unknown_size
, _inconsis_len , _tag_mismatch , _pdu_mismatch , _extra_bits ,
_inval_enc , _no_dec_dig , _no_exp_dig , _inval_nr1 , _inval_nr2
, _inval_nr3 , _real_long_zero , _undef_enc , _truncate ,
_null_in_nlltrm , _unknown_field , _field_repeat , _field_omit ,
_expec_eoc , _indef_len_prim , _expec_constr_fnd_prim ,
_expec_prim_fnd_constr , _unknown_type , _end_of_input ,
_cannot_happen , _neg_not_allowed , _expect_tag , _more_value ,
_real_too_large , _too_many_subids , _too_many_optional_fields ,
_too_many_ext_additions , _indef_length_der , _hindmost_error
};



/* typedef's for the context information */

typedef enum _context_type {
    _boolean_type, _integer_type, _enumerated_type, _real_type,
    _bitstring_type, _octetstring_type, _null_type, _sequence_type,
    _sequence_of_type, _set_type, _set_of_type, _choice_type,
    _charstring_type, _object_identifier_type, _time_type, _any_type,
    _opentype
}               _Context_Type;

typedef struct _context_id {
    char           *_element_name;
    char           *_element_type;
    _Context_Type   _type;
}               _Context_Id;


typedef struct _context_element {
    struct _context_element *_parent;
    _Context_Id    *_id;
    long            _occurrence;/* For SET OF or SEQUENCE OF */
}               _Context_Element;

typedef enum _context_state {
    _encoding_tag, _encoding_length, _encoding_data,
    _decoding_tag, _decoding_length, _decoding_data
}               _Context_State;

typedef struct _context_anchor {
    _Context_Element *_last;
    int             _pdu_number;
    _Context_Id    *_pdu_id;
    _Context_State  _state;
}               _Context_Anchor;

typedef  char _Per_Inverted_Index[128];


extern _Context_Anchor _oss_context_anchor;

/* The error routines */

#ifndef _OSSNOANSI

extern void DLL_ENTRY _oss_enc_error(struct ossGlobal *g, _Bool _jump,
                               enum _err_index _error_code, long _data);

#else

extern void     _oss_enc_error();

#endif /* _OSSNOANSI */


#define _oss_dec_error _oss_enc_error



#ifndef _OSSNOANSI

/* Encode Routines */

extern long DLL_ENTRY _oss_encd_length(struct ossGlobal *g, _std_parms_def,
                                 unsigned long _data);
extern void DLL_ENTRY _oss_enci_length(struct ossGlobal *g, _std_parms_def,
                                 unsigned long _data);
extern long DLL_ENTRY _oss_encd_tag(struct ossGlobal *g, _std_parms_def,
                              unsigned short _data, _Bool _constructed);
extern void DLL_ENTRY _oss_enci_tag(struct ossGlobal *g, _std_parms_def,
                              unsigned short _data, _Bool _constructed);
extern long DLL_ENTRY _oss_encd_bool(struct ossGlobal *g, _std_parms_def,
                               ossBoolean _data);
extern void DLL_ENTRY _oss_enci_bool(struct ossGlobal *g, _std_parms_def,
                               ossBoolean _data);
extern long DLL_ENTRY _oss_encd_int(struct ossGlobal *g, _std_parms_def,
				LONG_LONG _data);
extern void DLL_ENTRY _oss_enci_int(struct ossGlobal *g, _std_parms_def,
				LONG_LONG _data);
extern long DLL_ENTRY _oss_encd_uint(struct ossGlobal *g, _std_parms_def,
				ULONG_LONG _data);
extern void DLL_ENTRY _oss_enci_uint(struct ossGlobal *g, _std_parms_def,
				ULONG_LONG _data);
extern long DLL_ENTRY _oss_encd_huge_int(struct ossGlobal *g, _std_parms_def,
			       void *_data);
extern long DLL_ENTRY _oss_encd_uhuge_int(struct ossGlobal *g, _std_parms_def,
			       void *_data);
extern long DLL_ENTRY _oss_encd_real(struct ossGlobal *g, _std_parms_def,
                               double _data);
extern long DLL_ENTRY _oss_encd_creal(struct ossGlobal *g, _std_parms_def,
			       char *_data);
extern long DLL_ENTRY _oss_encd_mreal(struct ossGlobal *g, _std_parms_def,
			       MixedReal *_data);
extern void DLL_ENTRY _oss_enci_real(struct ossGlobal *g, _std_parms_def,
                               double _data);
extern void DLL_ENTRY _oss_enci_creal(struct ossGlobal *g, _std_parms_def,
			       char *_data);
extern void DLL_ENTRY _oss_enci_mreal(struct ossGlobal *g, _std_parms_def,
			       MixedReal *_data);
extern long DLL_ENTRY _oss_encd_alobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, short _array_size);
extern long DLL_ENTRY _oss_encd_asobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, short _array_size);
extern long DLL_ENTRY _oss_encd_aiobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, short _array_size);
extern void DLL_ENTRY _oss_enci_alobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, short _array_size);
extern void DLL_ENTRY _oss_enci_asobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, short _array_size);
extern void DLL_ENTRY _oss_enci_aiobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, short _array_size);
extern long DLL_ENTRY _oss_encd_llobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern long DLL_ENTRY _oss_encd_lsobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern long DLL_ENTRY _oss_encd_liobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern void DLL_ENTRY _oss_enci_llobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern void DLL_ENTRY _oss_enci_lsobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern void DLL_ENTRY _oss_enci_liobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern long DLL_ENTRY _oss_encd_ulobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern long DLL_ENTRY _oss_encd_usobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern long DLL_ENTRY _oss_encd_uiobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern void DLL_ENTRY _oss_enci_ulobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern void DLL_ENTRY _oss_enci_usobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern void DLL_ENTRY _oss_enci_uiobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern long DLL_ENTRY _oss_encd_pbit(struct ossGlobal *g, _std_parms_def,
                               void *_data, long _bit_count);
extern void DLL_ENTRY _oss_enci_pbit(struct ossGlobal *g, _std_parms_def,
                               void *_data, long _bit_count);
extern long DLL_ENTRY _oss_encd_ubit(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern void DLL_ENTRY _oss_enci_ubit(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern long DLL_ENTRY _oss_encd_vbit(struct ossGlobal *g, _std_parms_def,
                               void *_data, long _array_size,
                               char _lengthsize);
extern void DLL_ENTRY _oss_enci_vbit(struct ossGlobal *g, _std_parms_def,
                               void *_data, long _array_size,
                               char _lengthsize);
extern long DLL_ENTRY _oss_encd_nstr(struct ossGlobal *g, _std_parms_def,
                               char *_data, long _size_c);
extern void DLL_ENTRY _oss_enci_nstr(struct ossGlobal *g, _std_parms_def,
                               char *_data, long _size_c);
extern long DLL_ENTRY _oss_encd_pstr(struct ossGlobal *g, _std_parms_def,
                               char *_data, long _byte_count);
extern void DLL_ENTRY _oss_enci_pstr(struct ossGlobal *g, _std_parms_def,
                               char *_data, long _byte_count);
extern long DLL_ENTRY _oss_encd_ustr(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern void DLL_ENTRY _oss_enci_ustr(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern long DLL_ENTRY _oss_encd_vstr(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern void DLL_ENTRY _oss_enci_vstr(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern long DLL_ENTRY _oss_encd_uoct(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern void DLL_ENTRY _oss_enci_uoct(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern long DLL_ENTRY _oss_encd_voct(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern void DLL_ENTRY _oss_enci_voct(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern long DLL_ENTRY _oss_encd_gtime(struct ossGlobal *g, _std_parms_def,
                                GeneralizedTime*_data);
extern void DLL_ENTRY _oss_enci_gtime(struct ossGlobal *g, _std_parms_def,
                                GeneralizedTime *_data);
extern long DLL_ENTRY _oss_encd_utime(struct ossGlobal *g, _std_parms_def,
                                UTCTime *_data);
extern void DLL_ENTRY _oss_enci_utime(struct ossGlobal *g, _std_parms_def,
                                UTCTime *_data);
extern long DLL_ENTRY _oss_encd_uany(struct ossGlobal *g, _std_parms_def,
                               void *_data);
extern void DLL_ENTRY _oss_enci_uany(struct ossGlobal *g, _std_parms_def,
                               void *_data);
extern long DLL_ENTRY _oss_encd_opentype(struct ossGlobal *g, _std_parms_def,
                               void *_data);
extern void DLL_ENTRY _oss_enci_opentype(struct ossGlobal *g, _std_parms_def,
                               void *_data);
extern long DLL_ENTRY _oss_encd_bmpstr(struct ossGlobal *g, _std_parms_def,
                    void *data, char lengthsize,
		    long size_c);
extern long DLL_ENTRY _oss_enci_bmpstr(struct ossGlobal *g, _std_parms_def,
                    void *data, char lengthsize,
		    long size_c);
extern long DLL_ENTRY _oss_encd_unistr(struct ossGlobal *g, _std_parms_def,
                    void *data, char lengthsize,
		    long size_c);
extern long DLL_ENTRY _oss_enci_unistr(struct ossGlobal *g, _std_parms_def,
                    void *data, char lengthsize,
		    long size_c);

extern long DLL_ENTRY _oss_encd_eobjid(struct ossGlobal *g, _std_parms_def,
				  void *data, long size_c);

extern long DLL_ENTRY _oss_encd_dubit(struct ossGlobal *g, _std_parms_def,
		  void *data, char lengthsize, long size_c, _Bool named_bits);

extern long DLL_ENTRY _oss_encd_dvbit(struct ossGlobal *g, _std_parms_def,
		    void *data, long array_size,
		  char lengthsize, _Bool named_bits);


/* Decode Routines */
/* these return values */
extern void DLL_ENTRY _oss_dec_tag(struct ossGlobal *g, _sdstd_parms_def,
                             unsigned short *tag, _Bool *con);
extern long DLL_ENTRY _oss_dec_length(struct ossGlobal *g, _sdstd_parms_def);


extern ossBoolean DLL_ENTRY _oss_dec_bool(struct ossGlobal *g, _dstd_parms_def);
extern LONG_LONG DLL_ENTRY _oss_dec_llint(struct ossGlobal *g, _dstd_parms_def);
extern long DLL_ENTRY _oss_dec_lint(struct ossGlobal *g, _dstd_parms_def);
extern int  DLL_ENTRY _oss_dec_iint(struct ossGlobal *g, _dstd_parms_def);
extern short DLL_ENTRY _oss_dec_sint(struct ossGlobal *g, _dstd_parms_def);
extern void DLL_ENTRY _oss_dec_hint(struct ossGlobal *g, _dstd_parms_def,
				_Bool userbuf, void *data);
extern ULONG_LONG DLL_ENTRY _oss_dec_ullint(struct ossGlobal *g, _dstd_parms_def);
extern unsigned long DLL_ENTRY _oss_dec_ulint(struct ossGlobal *g, _dstd_parms_def);
extern unsigned int DLL_ENTRY _oss_dec_uiint(struct ossGlobal *g, _dstd_parms_def);
extern unsigned short DLL_ENTRY _oss_dec_usint(struct ossGlobal *g, _dstd_parms_def);

/* The code for this one is so huge that it would be criminal to
 * repeat it three times.  Caller should cast the returned value
 * to what she wants.
 */
extern void DLL_ENTRY _oss_dec_real(struct ossGlobal *g, _dstd_parms_def,
				double *data);
extern void DLL_ENTRY _oss_dec_freal(struct ossGlobal *g, _dstd_parms_def,
				float *data);
extern void DLL_ENTRY _oss_dec_creal(struct ossGlobal *g, _dstd_parms_def,
				  _Bool _userbuf, char **_data);
extern void DLL_ENTRY _oss_dec_mreal(struct ossGlobal *g, _dstd_parms_def,
				  _Bool _userbuf, MixedReal *_data);

/* Two versions of these functions.  If the type has the pointer
 * directive, then its size is not fixed--the function will allocate
 * the memory.  Otherwise the caller allocates the memory.  (Actually,
 * the type will probably be enclosed in another type, and therefore
 * the memory has already been allocated.)
 */
extern void DLL_ENTRY _oss_dec_alobjid_ptr(struct ossGlobal *g, _dstd_parms_def,
                                     _Bool _userbuf, void **_data,
                                     short _array_size);
extern void DLL_ENTRY _oss_dec_alobjid(struct ossGlobal *g, _dstd_parms_def,
                                 void *_data, short _array_size);

extern void DLL_ENTRY _oss_dec_aiobjid_ptr(struct ossGlobal *g, _dstd_parms_def,
                                     _Bool _userbuf, void **_data,
                                     short _array_size);
extern void DLL_ENTRY _oss_dec_aiobjid(struct ossGlobal *g, _dstd_parms_def,
                                 void *_data, short _array_size);

extern void DLL_ENTRY _oss_dec_asobjid_ptr(struct ossGlobal *g, _dstd_parms_def,
                                     _Bool _userbuf, void **_data,
                                     short _array_size);
extern void DLL_ENTRY _oss_dec_asobjid(struct ossGlobal *g, _dstd_parms_def,
                                 void *_data, short _array_size);

/* These allocate all their own memory.  */
extern void DLL_ENTRY _oss_dec_llobjid(struct ossGlobal *g, _dstd_parms_def,
                                 _Bool _userbuf, void **_data, long _size_c);
extern void DLL_ENTRY _oss_dec_liobjid(struct ossGlobal *g, _dstd_parms_def,
                                 _Bool _userbuf, void **_data, long _size_c);
extern void DLL_ENTRY _oss_dec_lsobjid(struct ossGlobal *g, _dstd_parms_def,
                                 _Bool _userbuf, void **_data, long _size_c);

/*  These are passed the structure containing the count, but allocate
  *  space for the data itself. */
extern void DLL_ENTRY _oss_dec_ulobjid(struct ossGlobal *g, _dstd_parms_def,
                                 _Bool _userbuf, void *_data, short _size_c);
extern void DLL_ENTRY _oss_dec_uiobjid(struct ossGlobal *g, _dstd_parms_def,
                                 _Bool _userbuf, void *_data, short _size_c);
extern void DLL_ENTRY _oss_dec_usobjid(struct ossGlobal *g, _dstd_parms_def,
                                 _Bool _userbuf, void *_data, short _size_c);

/* Caller allocates memory for this one.  Call for both e_pad & e_big_pad. */
extern void DLL_ENTRY _oss_dec_pbit(struct ossGlobal *g, _dstd_parms_def,
                              void *_data, unsigned long _bit_count,
                              _Bool _cons, _Bool _named_bits);

/* See comment before dec_ulobjid. */
extern void DLL_ENTRY _oss_dec_ubit(struct ossGlobal *g, _dstd_parms_def,
                              _Bool _userbuf, void *_data,
                              char _lengthsize, long _size_c, _Bool _cons);

/* Two versions of this one too.  */
extern void DLL_ENTRY _oss_dec_vbit_ptr(struct ossGlobal *g, _dstd_parms_def,
                                  _Bool _userbuf, void **_data,
                                  long _array_size, char _lengthsize,
                                  _Bool _cons);
extern void DLL_ENTRY _oss_dec_vbit(struct ossGlobal *g, _dstd_parms_def,
                              void *_data, long _array_size,
                              char _lengthsize, _Bool _cons);

extern void DLL_ENTRY _oss_dec_nstr_ptr(struct ossGlobal *g, _dstd_parms_def,
                                  _Bool _userbuf, char **_data, long _size_c,
                                  _Bool _cons);
extern void DLL_ENTRY _oss_dec_nstr(struct ossGlobal *g, _dstd_parms_def,
                              char *_data, long _size_c, _Bool _cons);

extern void DLL_ENTRY _oss_dec_pstr(struct ossGlobal *g, _dstd_parms_def,
                              char *_data, long _byte_count, _Bool _cons);
extern void DLL_ENTRY _oss_dec_ustr(struct ossGlobal *g, _dstd_parms_def,
                              _Bool _userbuf, void *_data,
                              char _lengthsize, long _size_c, _Bool _cons);

extern void DLL_ENTRY _oss_dec_vstr_ptr(struct ossGlobal *g, _dstd_parms_def,
                                  _Bool _userbuf, void **_data,
                                  char _lengthsize, long _size_c, _Bool _cons);
extern void DLL_ENTRY _oss_dec_vstr(struct ossGlobal *g, _dstd_parms_def,
                              void *_data, char _lengthsize, long _array_size,
                              _Bool _cons);

extern void DLL_ENTRY _oss_dec_uoct(struct ossGlobal *g, _dstd_parms_def,
                              _Bool _userbuf, void *_data,
                              char _lengthsize, long _size_c, _Bool _cons);

extern void DLL_ENTRY _oss_dec_voct_ptr(struct ossGlobal *g, _dstd_parms_def,
                                  _Bool _userbuf, void **_data,
                                  char _lengthsize, long _size_c, _Bool _cons);
extern void DLL_ENTRY _oss_dec_voct(struct ossGlobal *g, _dstd_parms_def,
                              void *_data, char _lengthsize, long _array_size,
                              _Bool _cons);

extern void DLL_ENTRY _oss_dec_gtime(struct ossGlobal *g, _dstd_parms_def,
                               GeneralizedTime *_data);
extern void DLL_ENTRY _oss_dec_utime(struct ossGlobal *g, _dstd_parms_def,
                               UTCTime *_data);

extern void DLL_ENTRY _oss_dec_uany(struct ossGlobal *g, _dstd_parms_def,
                              _Bool _userbuf, void *_data);

extern void DLL_ENTRY _oss_dec_opentype(struct ossGlobal *g, _dstd_parms_def,
                              _Bool _userbuf, void *_data);

extern void DLL_ENTRY _oss_dec_bmpstr(struct ossGlobal *g, _dstd_parms_def,
                    _Bool userbuf, void *data,
		    char lengthsize, long size_c, _Bool cons);
extern void DLL_ENTRY _oss_dec_unistr(struct ossGlobal *g, _dstd_parms_def,
                    _Bool userbuf, void *data,
		    char lengthsize, long size_c, _Bool cons);

extern void DLL_ENTRY _oss_dec_eobjid(struct ossGlobal *g, _dstd_parms_def,
                    _Bool userbuf, void *data,
		    long size_c);

/* Other functions */

/* called to count the items for set of or sequence of. */
extern long DLL_ENTRY _oss_count_setof_items(struct ossGlobal *g, _dstd_parms_def);

/* called to skip past items for the EXTENSIBLE directive */
extern void _oss_skip_past_item(struct ossGlobal *g, _dstd_parms_def);

extern void DLL_ENTRY _oss_beginBlock(struct ossGlobal *g, long count,
    char **pos, long *max_len);

extern void DLL_ENTRY _oss_nextItem(struct ossGlobal *g, long *max_len);

extern void DLL_ENTRY _oss_endBlock(struct ossGlobal *g, char ** pos, long *max_len,
    unsigned char ct);

/* called to perform limited check for default value */
extern _Bool DLL_ENTRY _oss_not_dflt(struct ossGlobal *g, void *data, void *dflt,
   long totalsize, long max_length, int kind);

#else

/* Encode Routines */

extern long     _oss_encd_length();
extern void     _oss_enci_length();
extern long     _oss_encd_tag();
extern void     _oss_enci_tag();


extern long     _oss_encd_bool();
extern void     _oss_enci_bool();
extern long     _oss_encd_int();
extern void     _oss_enci_int();
extern long     _oss_encd_uint();
extern void     _oss_enci_uint();
extern void     _oss_encd_huge_int();
extern void     _oss_encd_uhuge_int();
extern long     _oss_encd_real();
extern void     _oss_enci_real();
extern long     _oss_encd_alobjid();
extern long     _oss_encd_asobjid();
extern long     _oss_encd_aiobjid();
extern void     _oss_enci_alobjid();
extern void     _oss_enci_asobjid();
extern void     _oss_enci_aiobjid();
extern long     _oss_encd_llobjid();
extern long     _oss_encd_lsobjid();
extern long     _oss_encd_liobjid();
extern void     _oss_enci_llobjid();
extern void     _oss_enci_lsobjid();
extern void     _oss_enci_liobjid();
extern long     _oss_encd_ulobjid();
extern long     _oss_encd_usobjid();
extern long     _oss_encd_uiobjid();
extern void     _oss_enci_ulobjid();
extern void     _oss_enci_usobjid();
extern void     _oss_enci_uiobjid();
extern long     _oss_encd_eobjid();
extern long     _oss_encd_pbit();
extern void     _oss_enci_pbit();
extern long     _oss_encd_ubit();
extern void     _oss_enci_ubit();
extern long     _oss_encd_vbit();
extern void     _oss_enci_vbit();
extern long     _oss_encd_nstr();
extern void     _oss_enci_nstr();
extern long     _oss_encd_pstr();
extern void     _oss_enci_pstr();
extern long     _oss_encd_ustr();
extern void     _oss_enci_ustr();
extern long     _oss_encd_vstr();
extern void     _oss_enci_vstr();
extern long     _oss_encd_uoct();
extern void     _oss_enci_uoct();
extern long     _oss_encd_voct();
extern void     _oss_enci_voct();
extern long     _oss_encd_gtime();
extern void     _oss_enci_gtime();
extern long     _oss_encd_utime();
extern void     _oss_enci_utime();
extern long     _oss_encd_uany();
extern void     _oss_enci_uany();
extern long     _oss_encd_opentype();
extern void     _oss_enci_opentype();
extern long     _oss_encd_bmpstr();
extern long     _oss_enci_bmpstr();
extern long     _oss_encd_unistr();
extern long     _oss_enci_unistr();

/* Decode Routines */
/* these return values */
extern void     _oss_dec_tag();
extern long     _oss_dec_length();


extern ossBoolean _oss_dec_bool();
extern long     _oss_dec_lint();
extern int      _oss_dec_iint();
extern short    _oss_dec_sint();
extern void     _oss_dec_hint();
extern unsigned long _oss_dec_ulint();
extern unsigned int _oss_dec_uiint();
extern unsigned short _oss_dec_usint();

/* The code for this one is so huge that it would be criminal to
 * repeat it three times.  Caller should cast the returned value
 * to what she wants.
 */
extern double   _oss_dec_real();

/* Two versions of these functions.  If the type has the pointer
 * directive, then its size is not fixed--the function will allocate
 * the memory.  Otherwise the caller allocates the memory.  (Actually,
 * the type will probably be enclosed in another type, and therefore
 * the memory has already been allocated.)
 */
extern void     _oss_dec_alobjid_ptr();
extern void     _oss_dec_alobjid();

extern void     _oss_dec_aiobjid_ptr();
extern void     _oss_dec_aiobjid();

extern void     _oss_dec_asobjid_ptr();
extern void     _oss_dec_asobjid();

/* These allocate all their own memory.  */
extern void     _oss_dec_llobjid();
extern void     _oss_dec_liobjid();
extern void     _oss_dec_lsobjid();

/*  These are passed the structure containing the count, but allocate
  *  space for the data itself. */
extern void     _oss_dec_ulobjid();
extern void     _oss_dec_uiobjid();
extern void     _oss_dec_usobjid();

/* Caller allocates memory for this one.  Call for both e_pad & e_big_pad. */
extern void     _oss_dec_pbit();

/* See comment before dec_ulobjid. */
extern void     _oss_dec_ubit();

/* Two versions of this one too.  */
extern void     _oss_dec_vbit_ptr();
extern void     _oss_dec_vbit();

extern void     _oss_dec_nstr_ptr();
extern void     _oss_dec_nstr();

extern void     _oss_dec_pstr();
extern void     _oss_dec_ustr();

extern void     _oss_dec_vstr_ptr();
extern void     _oss_dec_vstr();

extern void     _oss_dec_uoct();

extern void     _oss_dec_voct_ptr();
extern void     _oss_dec_voct();

extern void     _oss_dec_gtime();
extern void     _oss_dec_utime();

extern void     _oss_dec_uany();

extern void     _oss_dec_opentype();

extern void     _oss_dec_bmpstr();
extern void     _oss_dec_unistr();
extern void     _oss_dec_eobjid();


/* Other functions */

/* called to count the items for set of or sequence of. */
extern long     _oss_count_setof_items();

/* called to skip past items for the EXTENSIBLE directive */
extern void     _oss_skip_past_item();

/* called to perform limited check for default value */
extern _Bool _oss_not_dflt();

#endif /* _OSSNOANSI */

typedef struct _EncDecGlobals {

   jmp_buf	  *_oss_err_env;
#ifndef _OSSNOANSI
   void		 (*_old_sigsegv)(int);
   void		 (*_old_sigbus)(int);
#else
   void		 (*_old_sigsegv)();
   void		 (*_old_sigbus)();
#endif
   int		   _oss_asn1err;
   char		  *_oss_err_msg;
  _Bool		   _buffer_provided;
  _Bool		   _tag_decoded;
  _Bool		   _restrain_mode;
   long		   _restrain_size;
  _Context_Anchor  _oss_context_anchor;
   char		  *_oss_outbufpos;
   long		   _oss_outbuflen;
  _mem_array	   _oss_mem;
  _mem_array	  *_oss_mem_tail;
  _mem_array	  *_oss_temp_tail;
  _mem_array	   _oss_temp_mem;
   long		   _oss_mem_alloc;
   long		   _oss_out_alloc;
   unsigned int     relax_ber: 1;
   unsigned int     der: 1;
   unsigned char    man[sizeof(double)];
#if defined(_WINDOWS) || defined(_DLL) || defined(OS2_DLL)
   void (DLL_ENTRY_FPTR *_System _oss_enc_error)(struct ossGlobal *g,
			_Bool _jump, enum _err_index _error_code, long _data);
#endif /* _WINDOWS || _DLL || OS2_DLL */
   _Bool            _aligned;
    int             _bitpos;
    struct ossGlobal *_prev;
    char           *_oss_inbufpos;
    long            _oss_inbuflen;
    void           *_prevbuf;
    long             encoding_length;
    void           *_blockptr;
    struct ossGlobal *_next;
    FILE           *asn1outSaved;
    int		  (*asn1prntSaved)(FILE *stream, const char *format, ...);
} _EncDecGlobals;

#ifdef __cplusplus
}
#endif

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(pop, ossPacking)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack()
#elif defined(__BORLANDC__) && (defined(__WIN32__) || defined(__MSDOS__))
#pragma option -a.
#elif defined(__IBMC__)
#pragma pack()
#elif defined(__WATCOMC__)
#pragma pack(pop)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=reset
#endif

	/*
	 * The following macros must be #defined if you compile the ASN.1
	 * compiler generated files (.c files) and link-edit with the import
	 * library ossapit.lib, i.e the OSS DLLs ossapit.dll, apit.dll,
	 * and toedber.dll/toedper.dll are used.  The following must not
	 * be #defined if you link-edit with the static library toedcode.lib.
	 */
#if defined(_DLL) || defined(OS2_DLL) ||\
   (defined(_WINDOWS) && !defined(_WIN32))
#define _oss_count_setof_items (*_g->ft.berTbl->_oss_count_setof_itemsp)
#define _oss_dec_aiobjid       (*_g->ft.berTbl->_oss_dec_aiobjidp)
#define _oss_dec_aiobjid_ptr   (*_g->ft.berTbl->_oss_dec_aiobjid_ptrp)
#define _oss_dec_alobjid       (*_g->ft.berTbl->_oss_dec_alobjidp)
#define _oss_dec_alobjid_ptr   (*_g->ft.berTbl->_oss_dec_alobjid_ptrp)
#define _oss_dec_asobjid       (*_g->ft.berTbl->_oss_dec_asobjidp)
#define _oss_dec_asobjid_ptr   (*_g->ft.berTbl->_oss_dec_asobjid_ptrp)
#define _oss_dec_bool          (*_g->ft.berTbl->_oss_dec_boolp)
#define _oss_dec_creal         (*_g->ft.berTbl->_oss_dec_crealp)
#define _oss_dec_freal         (*_g->ft.berTbl->_oss_dec_frealp)
#define _oss_dec_getmem        (*_g->ft.apiTbl->_oss_dec_getmemp)
#define _oss_dec_gtime         (*_g->ft.berTbl->_oss_dec_gtimep)
#define _oss_dec_hint          (*_g->ft.berTbl->_oss_dec_hintp)
#define _oss_dec_iint          (*_g->ft.berTbl->_oss_dec_iintp)
#define _oss_dec_length        (*_g->ft.berTbl->_oss_dec_lengthp)
#define _oss_dec_lint          (*_g->ft.berTbl->_oss_dec_lintp)
#define _oss_dec_liobjid       (*_g->ft.berTbl->_oss_dec_liobjidp)
#define _oss_dec_llint         (*_g->ft.berTbl->_oss_dec_llintp)
#define _oss_dec_llobjid       (*_g->ft.berTbl->_oss_dec_llobjidp)
#define _oss_dec_lsobjid       (*_g->ft.berTbl->_oss_dec_lsobjidp)
#define _oss_dec_mreal         (*_g->ft.berTbl->_oss_dec_mrealp)
#define _oss_dec_nstr          (*_g->ft.berTbl->_oss_dec_nstrp)
#define _oss_dec_nstr_ptr      (*_g->ft.berTbl->_oss_dec_nstr_ptrp)
#define _oss_dec_opentype      (*_g->ft.berTbl->_oss_dec_opentypep)
#define _oss_dec_pbit          (*_g->ft.berTbl->_oss_dec_pbitp)
#define _oss_dec_pstr          (*_g->ft.berTbl->_oss_dec_pstrp)
#define _oss_dec_real          (*_g->ft.berTbl->_oss_dec_realp)
#define _oss_dec_sint          (*_g->ft.berTbl->_oss_dec_sintp)
#define _oss_dec_tag           (*_g->ft.berTbl->_oss_dec_tagp)
#define _oss_dec_uany          (*_g->ft.berTbl->_oss_dec_uanyp)
#define _oss_dec_ubit          (*_g->ft.berTbl->_oss_dec_ubitp)
#define _oss_dec_uiint         (*_g->ft.berTbl->_oss_dec_uiintp)
#define _oss_dec_uiobjid       (*_g->ft.berTbl->_oss_dec_uiobjidp)
#define _oss_dec_ulint         (*_g->ft.berTbl->_oss_dec_ulintp)
#define _oss_dec_ullint        (*_g->ft.berTbl->_oss_dec_ullintp)
#define _oss_dec_ulobjid       (*_g->ft.berTbl->_oss_dec_ulobjidp)
#define _oss_dec_uoct          (*_g->ft.berTbl->_oss_dec_uoctp)
#define _oss_dec_usint         (*_g->ft.berTbl->_oss_dec_usintp)
#define _oss_dec_usobjid       (*_g->ft.berTbl->_oss_dec_usobjidp)
#define _oss_dec_ustr          (*_g->ft.berTbl->_oss_dec_ustrp)
#define _oss_dec_utime         (*_g->ft.berTbl->_oss_dec_utimep)
#define _oss_dec_vbit          (*_g->ft.berTbl->_oss_dec_vbitp)
#define _oss_dec_vbit_ptr      (*_g->ft.berTbl->_oss_dec_vbit_ptrp)
#define _oss_dec_voct          (*_g->ft.berTbl->_oss_dec_voctp)
#define _oss_dec_voct_ptr      (*_g->ft.berTbl->_oss_dec_voct_ptrp)
#define _oss_dec_vstr          (*_g->ft.berTbl->_oss_dec_vstrp)
#define _oss_dec_vstr_ptr      (*_g->ft.berTbl->_oss_dec_vstr_ptrp)
#define _oss_enc_error         (*_g->ft.berTbl->_oss_enc_errorp)
#define _oss_enc_pop           (*_g->ft.apiTbl->_oss_enc_popp)
#define _oss_enc_push          (*_g->ft.apiTbl->_oss_enc_pushp)
#define _oss_encd_aiobjid      (*_g->ft.berTbl->_oss_encd_aiobjidp)
#define _oss_encd_alobjid      (*_g->ft.berTbl->_oss_encd_alobjidp)
#define _oss_encd_asobjid      (*_g->ft.berTbl->_oss_encd_asobjidp)
#define _oss_encd_bool         (*_g->ft.berTbl->_oss_encd_boolp)
#define _oss_encd_creal        (*_g->ft.berTbl->_oss_encd_crealp)
#define _oss_encd_gtime        (*_g->ft.berTbl->_oss_encd_gtimep)
#define _oss_encd_huge_int     (*_g->ft.berTbl->_oss_encd_huge_intp)
#define _oss_encd_uhuge_int    (*_g->ft.berTbl->_oss_encd_uhuge_intp)
#define _oss_encd_int          (*_g->ft.berTbl->_oss_encd_intp)
#define _oss_encd_length       (*_g->ft.berTbl->_oss_encd_lengthp)
#define _oss_encd_liobjid      (*_g->ft.berTbl->_oss_encd_liobjidp)
#define _oss_encd_llobjid      (*_g->ft.berTbl->_oss_encd_llobjidp)
#define _oss_encd_lsobjid      (*_g->ft.berTbl->_oss_encd_lsobjidp)
#define _oss_encd_mreal        (*_g->ft.berTbl->_oss_encd_mrealp)
#define _oss_encd_nstr         (*_g->ft.berTbl->_oss_encd_nstrp)
#define _oss_encd_opentype     (*_g->ft.berTbl->_oss_encd_opentypep)
#define _oss_encd_pbit         (*_g->ft.berTbl->_oss_encd_pbitp)
#define _oss_encd_pstr         (*_g->ft.berTbl->_oss_encd_pstrp)
#define _oss_encd_real         (*_g->ft.berTbl->_oss_encd_realp)
#define _oss_encd_tag          (*_g->ft.berTbl->_oss_encd_tagp)
#define _oss_encd_uany         (*_g->ft.berTbl->_oss_encd_uanyp)
#define _oss_encd_ubit         (*_g->ft.berTbl->_oss_encd_ubitp)
#define _oss_encd_uint         (*_g->ft.berTbl->_oss_encd_uintp)
#define _oss_encd_uiobjid      (*_g->ft.berTbl->_oss_encd_uiobjidp)
#define _oss_encd_ulobjid      (*_g->ft.berTbl->_oss_encd_ulobjidp)
#define _oss_encd_uoct         (*_g->ft.berTbl->_oss_encd_uoctp)
#define _oss_encd_usobjid      (*_g->ft.berTbl->_oss_encd_usobjidp)
#define _oss_encd_ustr         (*_g->ft.berTbl->_oss_encd_ustrp)
#define _oss_encd_utime        (*_g->ft.berTbl->_oss_encd_utimep)
#define _oss_encd_vbit         (*_g->ft.berTbl->_oss_encd_vbitp)
#define _oss_encd_voct         (*_g->ft.berTbl->_oss_encd_voctp)
#define _oss_encd_vstr         (*_g->ft.berTbl->_oss_encd_vstrp)
#define _oss_enci_aiobjid      (*_g->ft.berTbl->_oss_enci_aiobjidp)
#define _oss_enci_alobjid      (*_g->ft.berTbl->_oss_enci_alobjidp)
#define _oss_enci_asobjid      (*_g->ft.berTbl->_oss_enci_asobjidp)
#define _oss_enci_bool         (*_g->ft.berTbl->_oss_enci_boolp)
#define _oss_enci_creal        (*_g->ft.berTbl->_oss_enci_crealp)
#define _oss_enci_gtime        (*_g->ft.berTbl->_oss_enci_gtimep)
#define _oss_enci_int          (*_g->ft.berTbl->_oss_enci_intp)
#define _oss_enci_length       (*_g->ft.berTbl->_oss_enci_lengthp)
#define _oss_enci_liobjid      (*_g->ft.berTbl->_oss_enci_liobjidp)
#define _oss_enci_llobjid      (*_g->ft.berTbl->_oss_enci_llobjidp)
#define _oss_enci_lsobjid      (*_g->ft.berTbl->_oss_enci_lsobjidp)
#define _oss_enci_mreal        (*_g->ft.berTbl->_oss_enci_mrealp)
#define _oss_enci_nstr         (*_g->ft.berTbl->_oss_enci_nstrp)
#define _oss_enci_opentype     (*_g->ft.berTbl->_oss_enci_opentypep)
#define _oss_enci_pbit         (*_g->ft.berTbl->_oss_enci_pbitp)
#define _oss_enci_pstr         (*_g->ft.berTbl->_oss_enci_pstrp)
#define _oss_enci_real         (*_g->ft.berTbl->_oss_enci_realp)
#define _oss_enci_tag          (*_g->ft.berTbl->_oss_enci_tagp)
#define _oss_enci_uany         (*_g->ft.berTbl->_oss_enci_uanyp)
#define _oss_enci_ubit         (*_g->ft.berTbl->_oss_enci_ubitp)
#define _oss_enci_uint         (*_g->ft.berTbl->_oss_enci_uintp)
#define _oss_enci_uiobjid      (*_g->ft.berTbl->_oss_enci_uiobjidp)
#define _oss_enci_ulobjid      (*_g->ft.berTbl->_oss_enci_ulobjidp)
#define _oss_enci_uoct         (*_g->ft.berTbl->_oss_enci_uoctp)
#define _oss_enci_usobjid      (*_g->ft.berTbl->_oss_enci_usobjidp)
#define _oss_enci_ustr         (*_g->ft.berTbl->_oss_enci_ustrp)
#define _oss_enci_utime        (*_g->ft.berTbl->_oss_enci_utimep)
#define _oss_enci_vbit         (*_g->ft.berTbl->_oss_enci_vbitp)
#define _oss_enci_voct         (*_g->ft.berTbl->_oss_enci_voctp)
#define _oss_enci_vstr         (*_g->ft.berTbl->_oss_enci_vstrp)
#define _oss_free_creal        (*_g->ft.berTbl->_oss_free_crealp)
#define _oss_releaseMem        (*_g->ft.apiTbl->_oss_releaseMemp)
#define _oss_set_outmem_d      (*_g->ft.apiTbl->_oss_set_outmem_dp)
#define _oss_encd_eobjid       (*_g->ft.berTbl->_oss_encd_eobjidp)
#define _oss_dec_eobjid        (*_g->ft.berTbl->_oss_dec_eobjidp)
#define _oss_encd_dubit        (*_g->ft.berTbl->_oss_encd_dubitp)
#define _oss_encd_dvbit        (*_g->ft.berTbl->_oss_encd_dvbitp)
#define _oss_not_dflt          (*_g->ft.berTbl->_oss_not_dfltp)
#define _oss_beginBlock        (*_g->ft.apiTbl->_oss_beginBlockp)
#define _oss_nextItem          (*_g->ft.apiTbl->_oss_nextItemp)
#define _oss_endBlock          (*_g->ft.apiTbl->_oss_endBlockp)
#endif /* _DLL || OS2_DLL || (_WINDOWS && !_WIN32) */

#endif /* ossber_hdr_file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\packoff.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    packoff.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    packoff.h is the complement to packon.h.  An inclusion of packoff.h
    MUST ALWAYS be preceded by an inclusion of packon.h, in one-to-one
    correspondence.

Author:

    Chuck Lenzmeier (chuckl) 4-Mar-1990

Revision History:

    15-Apr-1991 JohnRo
        Created lint-able variant.
--*/

#if ! (defined(lint) || defined(_lint))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#endif
#pragma pack()
#endif // ! (defined(lint) || defined(_lint))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ossglobl.h ===
/*
 * Copyright (C) 1992-1999 Open Systems Solutions, Inc.  All rights reserved
 */
/*
 * THIS FILE IS PROPRIETARY MATERIAL OF OPEN SYSTEMS SOLUTIONS, INC. AND
 * MAY BE USED ONLY BY DIRECT LICENSEES OF OPEN SYSTEMS SOLUTIONS, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED.
 */
/*
 * FILE: @(#)ossglobl.h	5.28.1.2  97/09/24
 */

#ifndef OSSGLOBL_H
#define OSSGLOBL_H

#if _MSC_VER > 1000
#pragma once
#endif

#include "ossdll.h"

#ifndef OSS_TOED
#define _EncDecGlobals soedData
#endif
#ifndef ossMemMgrVarLen
#ifdef __OS400__
#define ossMemMgrVarLen 100
#define ossEncDecVarLen 500    /* The size of the
				  encDecVar array shouldn't be less than
				  the sizeof(world->c) since the latter
				  structure overlays encDecVar */
#else
#define ossMemMgrVarLen 48
#define ossEncDecVarLen 192    /* The size of the
				  encDecVar array shouldn't be less than
				  the sizeof(world->c) since the latter
				  structure overlays encDecVar */
#endif /* __OS400__ */
#if !defined(EOF) && !defined(_FILE_DEFINED)
typedef char FILE;
#endif /* !EOF && !_FILE_DEFINED */

#ifndef ERR_MSG_LENGTH
#define ERR_MSG_LENGTH 512      /* length of error messages to be output */
#endif

#ifdef __cplusplus
extern "C"
{
#endif

typedef enum  {
    OSS_BASIC = 0,
    OSS_SPARTAN
} OssAPI;

typedef enum  {
    OSS_BER = 0,
    OSS_PER_ALIGNED,
    OSS_PER_UNALIGNED,
    OSS_DER
} ossEncodingRules;

	/*
	 * List of supported compatibility modes
	 */
typedef enum {
    OSS_CUSTOM_COMPATIBILITY = -2, /* Any combination of compatibility
                                    * flags set by a call to the function
                                    * ossSetCompatibilityFlags() */
    OSS_CURRENT_VERSION = 0,       /* Current version */
    OSS_VERSION_412,         /* Includes the following compatibility flags:
                              * OSS_V412_TIME_AND_WIDE_CHAR_STRINGS,
                              * OSS_TRUNCATE_0_SECONDS_FROM_GENERALIZED_TIME,
                              * OSS_TRUNCATE_0_SECONDS_FROM_UTC_TIME and
                              * OSS_EXTENDED_UNRESTRICTED_CHAR_STRINGS
			      * OSS_ALLOW_ZERO_LENGTH_OPENTYPE_STRINGS
			      */
    OSS_VERSION_419          /* Includes the following compatibiity flags:
                              * OSS_TRUNCATE_0_SECONDS_FROM_GENERALIZED_TIME,
                                OSS_TRUNCATE_0_SECONDS_FROM_UTC_TIME and
                                OSS_EXTENDED_UNRESTRICTED_CHAR_STRINGS
			      * OSS_ALLOW_ZERO_LENGTH_OPENTYPE_STRINGS
			      */
} OssRuntimeVersion;

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(push, ossPacking, 4)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack(1)
#elif defined(__BORLANDC__) && defined(__MSDOS__)
#ifdef _BC31
#pragma option -a-
#else
#pragma option -a1
#endif /* _BC31 */
#elif defined(__BORLANDC__) && defined(__WIN32__)
#pragma option -a4
#elif defined(__IBMC__)
#pragma pack(4)
#elif defined(__WATCOMC__) && defined(__NT__)
#pragma pack(push, 4)
#elif defined(__WATCOMC__) && (defined(__WINDOWS__) || defined(__DOS__))
#pragma pack(push, 1)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=mac68k
#endif

typedef struct ossGlobal {
    /*
     * used for communicating with the memory manager and the tracing-routine
     */
				/* low-level memory allocator */
    void       *(DLL_ENTRY_FPTR *_System mallocp)(size_t p);
				/* memory re-allocator */
    void       *(DLL_ENTRY_FPTR *_System reallocp)(void *p, size_t s);
				/* low-level memory freer */
    void        (DLL_ENTRY_FPTR *_System freep)(void *p);
    size_t      asn1chop;       /* 0 means do not truncate strings; greater
				 * value means truncate long output strings
				 * (OCTET STRING, BIT STRING, Character String)
				 * to be "asn1chop" bytes long.  Read by
				 * encoder&decoder tracing and "printPDU"
				 */
    size_t      ossblock;       /* if not 0, size of largest block
				 * to allocate */
    size_t      ossprefx;       /* # bytes to leave before OSAK data buffer */

    FILE        *asn1out;       /* tracing output file */

    /* low-level tracing-output function; default is fprintf() */
    int (*asn1prnt)(FILE *stream, const char *format, ...);

	/*
	 * available for use by user application
	 */
    void        *userVar;

	/*
	 * used for storing DLL- & library NLMs-related parameters
	 */
#if defined(_WINDOWS) || defined(_WIN32) || \
    defined(__OS2__)  || defined(NETWARE_DLL)
    FunctionTables    ft;
#endif /* _WINDOWS || _DLL || __OS2__ || NETWARE_DLL */

	/*
	 * related to the new API; not for direct reference by user code
	 */
    void             *ctlTbl;
    OssAPI            api;
    ossEncodingRules  encRules;
    unsigned long     encodingFlags;
    unsigned long     decodingFlags;
    long              decodingLength;
    char              errMsg[ERR_MSG_LENGTH];

	/*
	 * reserved for use by the encoder/decoder
	 */
    double            reserved[4];

	/*
	 * reserved for use by the memory manager and the tracing-routine
	 */
#ifdef storing
    struct storHandling t;
#else /* not storing */
    long int    memMgrVar[ossMemMgrVarLen];
#endif

#if defined(OSS_TOED)
    struct _EncDecGlobals c;
#elif defined(coding)
    struct _EncDecGlobals c;
#else
    long int encDecVar[ossEncDecVarLen];
#endif
} OssGlobal;

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(pop, ossPacking)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack()
#elif defined(__BORLANDC__) && (defined(__WIN32__) || defined(__MSDOS__))
#pragma option -a.
#elif defined(__IBMC__)
#pragma pack()
#elif defined(__WATCOMC__)
#pragma pack(pop)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=reset
#endif

PUBLIC int              DLL_ENTRY ossSetEncodingRules(struct ossGlobal *world,
						ossEncodingRules rules);
PUBLIC ossEncodingRules DLL_ENTRY ossGetEncodingRules(struct ossGlobal *world);
PUBLIC int              DLL_ENTRY ossSetDecodingLength(struct ossGlobal *world,
							long bufferLength);
PUBLIC long             DLL_ENTRY ossGetDecodingLength(struct ossGlobal *world);
PUBLIC int              DLL_ENTRY ossSetEncodingFlags(struct ossGlobal *world,
							unsigned long flags);
PUBLIC unsigned long    DLL_ENTRY ossGetEncodingFlags(struct ossGlobal *world);
PUBLIC int              DLL_ENTRY ossSetDecodingFlags(struct ossGlobal *world,
							unsigned long flags);
PUBLIC unsigned long    DLL_ENTRY ossGetDecodingFlags(struct ossGlobal *world);
PUBLIC char            *DLL_ENTRY ossGetErrMsg(struct ossGlobal *world);
PUBLIC int              DLL_ENTRY ossCallerIsDecoder(struct ossGlobal *world);
PUBLIC int              DLL_ENTRY ossSetFlags(struct ossGlobal *world,
							unsigned long flags);
PUBLIC int              DLL_ENTRY ossSetRuntimeVersion(struct ossGlobal *world,
						OssRuntimeVersion version);
PUBLIC OssRuntimeVersion DLL_ENTRY ossGetRuntimeVersion(struct ossGlobal *world);
PUBLIC int              DLL_ENTRY ossSetCompatibilityFlags(struct ossGlobal *world,
							unsigned long flag);
PUBLIC unsigned long    DLL_ENTRY ossGetCompatibilityFlags(struct ossGlobal *world);
PUBLIC int              DLL_ENTRY ossGetOssGlobalSize(void);
			/*
			 * The following are declarations for link routines
			 * needed to link the encoding rule or rules specified
			 * on the compiler command line.  The function calls
			 * are generated by the compiler into _ossinit_...()
			 * in the control table.  These functions are not
			 * meant to be referenced by user code.
			 */
PUBLIC void DLL_ENTRY ossLinkAPI(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkBer(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkPer(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkDer(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkConstraint(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkUserConstraint(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkBerReal(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkPerReal(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkCmpValue(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkCpyValue(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkPerPDV(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkOid(OssGlobal *);

#ifdef __cplusplus
}
#endif
#endif /* ossMemMgrVarLen */
#endif /* OSSGLOBL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\packon.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    packon.h

Abstract:

    This file turns packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    The file packoff.h is the complement to this file.

Author:

    Chuck Lenzmeier (chuckl) 4-Mar-1990

Revision History:

    15-Apr-1991 JohnRo
        Created lint-able variant.
--*/

#if ! (defined(lint) || defined(_lint))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#endif
#pragma pack(1)                 // x86, MS compiler; MIPS, MIPS compiler
#endif // ! (defined(lint) || defined(_lint))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\objsel.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       objsel.h
//
//  Contents:   Object Picker Dialog public header
//
//---------------------------------------------------------------------------

#ifndef __OBJSEL_H_
#define __OBJSEL_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
#define EXTERN_C    extern "C"
#else
#define EXTERN_C    extern
#endif
#endif

EXTERN_C const GUID DECLSPEC_SELECTANY CLSID_DsObjectPicker =
    {0x17d6ccd8,0x3b7b,0x11d2,{0xb9, 0xe0, 0x00, 0xc0, 0x4f, 0xd8, 0xdb, 0xf7}};

EXTERN_C const GUID DECLSPEC_SELECTANY IID_IDsObjectPicker =
    {0x0c87e64e,0x3b7a,0x11d2,{0xb9,0xe0,0x00,0xc0,0x4f,0xd8,0xdb,0xf7}};

/*
CLIPBOARD FORMATS
=================

CFSTR_DSOP_DS_SELECTION_LIST
    Returns an HGLOBAL for global memory containing a DS_SELECTION_LIST
    variable length structure.
*/

#define CFSTR_DSOP_DS_SELECTION_LIST    TEXT("CFSTR_DSOP_DS_SELECTION_LIST")


/*
SCOPE TYPES
===========

A scope is an entry in the "Look In" dropdown list of the Object Picker
dialog.

When initializing the DS Object Picker, DSOP_SCOPE_TYPEs are used with
DSOP_SCOPE_INIT_INFO.flType member to specify which types of scopes the
DS Object Picker should put in the "Look In" list.

DSOP_SCOPE_TYPE_TARGET_COMPUTER
    Computer specified by DSOP_INIT_INFO.pwzTargetComputer, NULL is
    local computer.

DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
    Uplevel domain to which target computer is joined.

DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN
    Downlevel domain to which target computer is joined.

DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
    All domains in the enterprise to which the target computer belongs
    other than the JOINED_DOMAIN or USER_SPECIFIED_*_SCOPEs.

DSOP_SCOPE_TYPE_GLOBAL_CATALOG
    The Entire Directory scope.

DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
    All uplevel domains external to the enterprise but trusted by the
    domain to which the target computer is joined.

DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
    All downlevel domains external to the enterprise but trusted by the
    domain to which the target computer is joined.

DSOP_SCOPE_TYPE_WORKGROUP
    The workgroup of which TARGET_COMPUTER is a member.  Applies only if the
    TARGET_COMPUTER is not joined to a domain.

DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE
    Any uplevel or downlevel scope generated by processing user input.  If
    neither of these types is specified, user entries that do not refer to
    one of the scopes in the "Look In" control will be rejected.

*/

#define DSOP_SCOPE_TYPE_TARGET_COMPUTER                 0x00000001
#define DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN           0x00000002
#define DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN         0x00000004
#define DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN               0x00000008
#define DSOP_SCOPE_TYPE_GLOBAL_CATALOG                  0x00000010
#define DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN         0x00000020
#define DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN       0x00000040
#define DSOP_SCOPE_TYPE_WORKGROUP                       0x00000080
#define DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE      0x00000100
#define DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE    0x00000200


/*
DSOP_SCOPE_INIT_INFO flags
==========================

The flScope member can contain zero or more of the following flags:

DSOP_SCOPE_FLAG_STARTING_SCOPE
    The scope should be the first one selected in the Look In control after
    dialog initialization.  If more than one scope specifies this flag,
    the one which is chosen to be the starting scope is implementation
    dependant.

DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT
    ADs paths for objects selected from this scope should be converted to use
    the WinNT provider.

DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP
    ADs paths for objects selected from this scope should be converted to use
    the LDAP provider.

DSOP_SCOPE_FLAG_WANT_PROVIDER_GC
    ADs paths for objects selected from this scope should be converted to use
    the GC provider.

DSOP_SCOPE_FLAG_WANT_SID_PATH
    ADs paths for objects selected from this scope having an objectSid
    attribute should be converted to the form LDAP://<SID=x>, where x
    represents the hexidecimal digits of the objectSid attribute value.

DSOP_SCOPE_FLAG_WANT_DOWNLEVEL_BUILTIN_PATH
    ADs paths for downlevel well-known SID objects (for example,
    DSOP_DOWNLEVEL_FILTER_INTERACTIVE) are an empty string unless this flag is
    specified.  If it is, the paths will be of the form
    WinNT://NT AUTHORITY/Interactive or WinNT://Creator owner.

DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS
    If the scope filter contains the DSOP_FILTER_USERS or
    DSOP_DOWNLEVEL_FILTER_USERS flag, then check the Users checkbox by
    default in the Look For dialog.

DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS


DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS

DSOP_SCOPE_FLAG_DEFAULT_FILTER_CONTACTS
*/

#define DSOP_SCOPE_FLAG_STARTING_SCOPE              0x00000001
#define DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT         0x00000002
#define DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP          0x00000004
#define DSOP_SCOPE_FLAG_WANT_PROVIDER_GC            0x00000008
#define DSOP_SCOPE_FLAG_WANT_SID_PATH               0x00000010
#define DSOP_SCOPE_FLAG_WANT_DOWNLEVEL_BUILTIN_PATH 0x00000020
#define DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS        0x00000040
#define DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS       0x00000080
#define DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS    0x00000100
#define DSOP_SCOPE_FLAG_DEFAULT_FILTER_CONTACTS     0x00000200


/*
The flMixedModeOnly/flNativeModeOnly member of an uplevel scope can
contain one or more of the following flags (at least one must be specified):

DSOP_FILTER_INCLUDE_ADVANCED_VIEW
    Include objects which have the attribute showInAdvancedViewOnly set to
    true.

DSOP_FILTER_USERS
    Include user objects.

DSOP_FILTER_BUILTIN_GROUPS
    Include group objects with a groupType value having the flag
    GROUP_TYPE_BUILTIN_LOCAL_GROUP.

DSOP_FILTER_WELL_KNOWN_PRINCIPALS
    Include the contents of the WellKnown Security Principals container.

DSOP_FILTER_UNIVERSAL_GROUPS_DL
    Include distribution list universal groups.

DSOP_FILTER_UNIVERSAL_GROUPS_SE
    Include security enabled universal groups.

DSOP_FILTER_GLOBAL_GROUPS_DL
    Include distribution list global groups.

DSOP_FILTER_GLOBAL_GROUPS_SE
    Include security enabled global groups.

DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL
    Include distribution list domain global groups.

DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
    Include security enabled domain local groups.

DSOP_FILTER_CONTACTS
    Include contact objects.

DSOP_FILTER_COMPUTERS
    Include computer objects.
*/

#define DSOP_FILTER_INCLUDE_ADVANCED_VIEW   0x00000001
#define DSOP_FILTER_USERS                   0x00000002
#define DSOP_FILTER_BUILTIN_GROUPS          0x00000004
#define DSOP_FILTER_WELL_KNOWN_PRINCIPALS   0x00000008
#define DSOP_FILTER_UNIVERSAL_GROUPS_DL     0x00000010
#define DSOP_FILTER_UNIVERSAL_GROUPS_SE     0x00000020
#define DSOP_FILTER_GLOBAL_GROUPS_DL        0x00000040
#define DSOP_FILTER_GLOBAL_GROUPS_SE        0x00000080
#define DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL  0x00000100
#define DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE  0x00000200
#define DSOP_FILTER_CONTACTS                0x00000400
#define DSOP_FILTER_COMPUTERS               0x00000800


/*
The flFilter member of a downlevel scope can contain one or more of the
following flags:

DSOP_DOWNLEVEL_FILTER_USERS
    Include user objects.

DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS
    Include all local groups.

DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS
    Include all global groups.

DSOP_DOWNLEVEL_FILTER_COMPUTERS
    Include computer objects

DSOP_DOWNLEVEL_FILTER_WORLD
    Include builtin security principal World (Everyone).

DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER
    Include builtin security principal Authenticated User.

DSOP_DOWNLEVEL_FILTER_ANONYMOUS
    Include builtin security principal Anonymous.

DSOP_DOWNLEVEL_FILTER_BATCH
    Include builtin security principal Batch.

DSOP_DOWNLEVEL_FILTER_CREATOR_OWNER
    Include builtin security principal Creator Owner.

DSOP_DOWNLEVEL_FILTER_CREATOR_GROUP
    Include builtin security principal Creator Group.

DSOP_DOWNLEVEL_FILTER_DIALUP
    Include builtin security principal Dialup.

DSOP_DOWNLEVEL_FILTER_INTERACTIVE
    Include builtin security principal Interactive.

DSOP_DOWNLEVEL_FILTER_NETWORK
    Include builtin security principal Network.

DSOP_DOWNLEVEL_FILTER_SERVICE
    Include builtin security principal Service.

DSOP_DOWNLEVEL_FILTER_SYSTEM
    Include builtin security principal System.

DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS
    Exclude local builtin groups returned by groups enumeration.

DSOP_DOWNLEVEL_FILTER_TERMINAL_SERVER
    Include builtin security principal Terminal Server.

DSOP_DOWNLEVEL_FILTER_LOCAL_SERVICE
    Include builtin security principal Local Service

DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE
    Include builtin security principal Network Service

DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS
    Include all builtin security principals.
*/

#define DSOP_DOWNLEVEL_FILTER_USERS                   0x80000001
#define DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS            0x80000002
#define DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS           0x80000004
#define DSOP_DOWNLEVEL_FILTER_COMPUTERS               0x80000008
#define DSOP_DOWNLEVEL_FILTER_WORLD                   0x80000010
#define DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER      0x80000020
#define DSOP_DOWNLEVEL_FILTER_ANONYMOUS               0x80000040
#define DSOP_DOWNLEVEL_FILTER_BATCH                   0x80000080
#define DSOP_DOWNLEVEL_FILTER_CREATOR_OWNER           0x80000100
#define DSOP_DOWNLEVEL_FILTER_CREATOR_GROUP           0x80000200
#define DSOP_DOWNLEVEL_FILTER_DIALUP                  0x80000400
#define DSOP_DOWNLEVEL_FILTER_INTERACTIVE             0x80000800
#define DSOP_DOWNLEVEL_FILTER_NETWORK                 0x80001000
#define DSOP_DOWNLEVEL_FILTER_SERVICE                 0x80002000
#define DSOP_DOWNLEVEL_FILTER_SYSTEM                  0x80004000
#define DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS  0x80008000
#define DSOP_DOWNLEVEL_FILTER_TERMINAL_SERVER         0x80010000
#define DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS      0x80020000
#define DSOP_DOWNLEVEL_FILTER_LOCAL_SERVICE           0x80040000
#define DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE         0x80080000
#define DSOP_DOWNLEVEL_FILTER_REMOTE_LOGON            0x80100000


/*
DSOP_UPLEVEL_FILTER_FLAGS
=========================

Contains the DSOP_FILTER_* flags for use with a DSOP_SCOPE_INIT_INFO
structure when the scope is uplevel (DS-aware).

flBothModes
    Flags to use for an uplevel scope, regardless of whether it is a
    mixed or native mode domain.

flMixedModeOnly
    Flags to use when an uplevel domain is in mixed mode.

flNativeModeOnly
    Flags to use when an uplevel domain is in native mode.


DSOP_FILTER_FLAGS
=================

Uplevel
    Contains flags to use for an uplevel scope.

flDownlevel
    Flags to use for a downlevel scope.
*/

typedef struct _DSOP_UPLEVEL_FILTER_FLAGS
{
    ULONG       flBothModes;
    ULONG       flMixedModeOnly;
    ULONG       flNativeModeOnly;
} DSOP_UPLEVEL_FILTER_FLAGS;

typedef struct _DSOP_FILTER_FLAGS
{
    DSOP_UPLEVEL_FILTER_FLAGS   Uplevel;
    ULONG                       flDownlevel;
} DSOP_FILTER_FLAGS;


/*
DSOP_SCOPE_INIT_INFO
====================

Each DSOP_SCOPE_INIT_INFO structure in the array DSOP_INIT_INFO.aDsScopeInfos
describes a single scope or a group of scopes with the same settings.

cbSize
    Size, in bytes, of the entire structure.

flType
    DSOP_SCOPE_TYPE_* flags.  It is legal to combine multiple values via
    bitwise OR if all of the types of scopes combined in this way require
    the same settings.

flScope
    DSOP_SCOPE_ * flags.

FilterFlags
    DSOP_FILTER_* flags that indicate which types of objects should be
    presented to the user in this scope.

pwzDcName
    Name of the DC of a domain.  This member is used only if the flType
    member contains the flag DSOP_SCOPE_TYPE_JOINED_DOMAIN.  If that flag is
    not set, this member must be NULL.

pwzADsPath
    Currently not supported, must be NULL.

hr
    Filled with S_OK if the scope represented by this structure could be
    created, or an error message indicating why it could not.  If
    IDsObjectPicker::SetScopes returns a success code, this value will
    also be a success code.
*/

typedef struct _DSOP_SCOPE_INIT_INFO
{
    ULONG               cbSize;
    ULONG               flType;
    ULONG               flScope;
    DSOP_FILTER_FLAGS   FilterFlags;
    PCWSTR              pwzDcName;      // OPTIONAL
    PCWSTR              pwzADsPath;     // OPTIONAL
    HRESULT             hr;
} DSOP_SCOPE_INIT_INFO, *PDSOP_SCOPE_INIT_INFO;

typedef const DSOP_SCOPE_INIT_INFO *PCDSOP_SCOPE_INIT_INFO;

/*
DSOP_INIT_INFO flags
====================

The following flags may be set in DSOP_INIT_INFO.flOptions:

DSOP_FLAG_MULTISELECT
    Allow multiple selections.  If this flag is not set, the dialog will
    return zero or one objects.

DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK
    If this flag is NOT set, then the DSOP_SCOPE_TYPE_TARGET_COMPUTER flag
    will be ignored if the target computer is a DC.  This flag has no effect
    unless DSOP_SCOPE_TYPE_TARGET_COMPUTER is specified.

*/

#define DSOP_FLAG_MULTISELECT                    0x00000001
#define DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK  0x00000002

/*
DSOP_INIT_INFO
==============

Used to configure the DS Object Picker dialog.

cbSize
    Size, in bytes, of entire structure.

pwzTargetComputer
    Sets the computer associated with DSOP_SCOPE_TARGET_COMPUTER, and
    which is used to determine the joined domain and enterprise.
    If this value is NULL, the target computer is the local machine.

cDsScopeInfos
    Count of elements in aDsScopeInfos.  Must be at least 1, since
    the object picker cannot operate without at least one scope.

aDsScopeInfos
    Array of scope initialization structures.  Must be present and
    contain at least one element.

flOptions
    Various DS Object Picker flags (DSOP_FLAG_MULTISELECT).

cAttributesToFetch
    Count of elements in apwzAttributeNames.  Can be 0.

apwzAttributeNames
    Array of names of attributes to fetch for each object.  Ignored
    if cAttributesToFetch is 0.
*/

typedef struct _DSOP_INIT_INFO
{
    ULONG                       cbSize;
    PCWSTR                      pwzTargetComputer;
    ULONG                       cDsScopeInfos;
    PDSOP_SCOPE_INIT_INFO       aDsScopeInfos;
    ULONG                       flOptions;
    ULONG                       cAttributesToFetch;
    PCWSTR                     *apwzAttributeNames;
} DSOP_INIT_INFO, *PDSOP_INIT_INFO;

typedef const DSOP_INIT_INFO *PCDSOP_INIT_INFO;

/*
DS_SELECTION
============
Describes an object selected by the user.

pwzName
    The object's RDN.

pwzADsPath
    The object's ADsPath.

pwzClass
    The object's class attribute value.

pwzUPN
    The object's userPrincipalName attribute value.

pvarFetchedAttributes
    An array of VARIANTs, one for each attribute fetched.

flScopeType
    A single DSOP_SCOPE_TYPE_* flag describing the type of the scope
    from which this object was selected.


DS_SELECTION_LIST
=================
Available as a clipboard format from the data object returned by
IDsObjectPicker::InvokeDialog.  Contains a list of objects that the user
selected.

cItems
    Number of elements in the aDsSelection array.

cFetchedAttributes
    Number of elements in each DSSELECTION.avarFetchedAttributes member.

aDsSelection
    Array of cItems DSSELECTION structures.
*/


typedef struct _DS_SELECTION
{
    PWSTR      pwzName;
    PWSTR      pwzADsPath;
    PWSTR      pwzClass;
    PWSTR      pwzUPN;
    VARIANT   *pvarFetchedAttributes;
    ULONG      flScopeType;
} DS_SELECTION, *PDS_SELECTION;


typedef struct _DS_SELECTION_LIST
{
    ULONG           cItems;
    ULONG           cFetchedAttributes;
    DS_SELECTION    aDsSelection[ANYSIZE_ARRAY];
} DS_SELECTION_LIST, *PDS_SELECTION_LIST;

//
// Object Picker Interfaces
//

//
// The main interface to the DS Object Picker, used to initialize it,
// invoke the dialog, and return the user's selections.
//

#undef INTERFACE
#define INTERFACE IDsObjectPicker

DECLARE_INTERFACE_(IDsObjectPicker, IUnknown)
{
    // *** IUnknown methods ***

    STDMETHOD(QueryInterface)(
        THIS_
        REFIID riid,
        PVOID *ppv) PURE;

    STDMETHOD_(ULONG,AddRef)(THIS) PURE;

    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDsObjectPicker methods ***

    // Sets scope, filter, etc. for use with next invocation of dialog
    STDMETHOD(Initialize)(
        THIS_
        PDSOP_INIT_INFO pInitInfo) PURE;

    // Creates the modal DS Object Picker dialog.
    STDMETHOD(InvokeDialog)(
         THIS_
         HWND               hwndParent,
         IDataObject      **ppdoSelections) PURE;
};

#endif // __OBJSEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\oemupgex.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT5.0
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       O E M U P G E X . H
//
//  Contents:   Function prototypes needed for OEM network upgrade
//
//  Notes:
//
//----------------------------------------------------------------------------

#ifndef __OEMUPGEX_H__
#define __OEMUPGEX_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef WINNT32P_H
typedef enum {
    UNKNOWN,
    NT_WORKSTATION,
    NT_SERVER
} PRODUCTTYPE;
#endif

typedef struct
{
    PRODUCTTYPE ProductType;
    DWORD       dwBuildNumber;
} ProductInfo;

typedef struct
{
    ProductInfo From;
    ProductInfo To;
} NetUpgradeInfo;

typedef struct
{
    WCHAR   szCompanyName[256];
    WCHAR   szSupportNumber[256];
    WCHAR   szSupportUrl[256];
    WCHAR   szInstructionsToUser[1024];
} VENDORINFO;

const DWORD c_dwMaxProductIdLen = 255;

const DWORD NUA_LOAD_POST_UPGRADE        = 0x0001;
const DWORD NUA_REQUEST_ABORT_UPGRADE    = 0x0002;
const DWORD NUA_ABORT_UPGRADE            = 0x0004;
const DWORD NUA_SKIP_INSTALL_IN_GUI_MODE = 0x80000L;

typedef struct
{
    LPTSTR mszServicesNotToBeDeleted;
} NetUpgradeData;

// Names of functions exported from OEM DLL
//

#define c_szPreUpgradeInitialize        "PreUpgradeInitialize"
#define c_szDoPreUpgradeProcessing      "DoPreUpgradeProcessing"
#define c_szPostUpgradeInitialize       "PostUpgradeInitialize"
#define c_szDoPostUpgradeProcessing     "DoPostUpgradeProcessing"

// Names of functions exported from netupgrd.dll
//
#define c_szNetUpgradeAddSection        "NetUpgradeAddSection"
#define c_szNetUpgradeAddLineToSection  "NetUpgradeAddLineToSection"

// Keys in OemSection
//
#define  c_szInfToRunBeforeInstall      TEXT("InfToRunBeforeInstall")
#define  c_szInfToRunAfterInstall       TEXT("InfToRunAfterInstall")

//
// Prototypes for functions exported from OEM DLL
//

LONG __stdcall
GetListOfServicesNotToBeDeleted(OUT LPTSTR* pmszServices);

typedef LONG
(__stdcall *GetListOfServicesNotToBeDeletedPrototype)
     (OUT LPTSTR* pmszServices);


//+---------------------------------------------------------------------------
//
//  Function:   PreUpgradeInitialize
//
//  Purpose:    Intialize OEM DLL
//
//  Arguments:
//      szWorkingDir     [in]   name of temporary directory to be used
//      pNetUpgradeInfo  [in]   pointer to NetUpgradeInfo structure
//      pviVendorInfo    [out]  information about OEM
//      pdwFlags         [out]  pointer to flags
//      pNetUpgradeData  [out]  pointer to NetUpgradeData structure
//
//  Returns:    ERROR_SUCCESS in case of success, win32 error otherwise
//
//  Notes:
//      This function is called before any other function in this dll.
//      The main purpose of calling this function is to obtain
//      identification information and to allow the DLL to initialize
//      its internal data
//
LONG __stdcall
PreUpgradeInitialize(IN  LPCTSTR         szWorkingDir,
                     IN  NetUpgradeInfo* pNetUpgradeInfo,
                     OUT VENDORINFO*     pviVendorInfo,
                     OUT DWORD*          pdwFlags,
                     OUT NetUpgradeData* pNetUpgradeData);

typedef LONG
(__stdcall *PreUpgradeInitializePrototype)
     (IN  LPCTSTR         szWorkingDir,
      IN  NetUpgradeInfo* pNetUpgradeInfo,
      OUT VENDORINFO*     pviVendorInfo,
      OUT DWORD*          pdwFlags,
      OUT NetUpgradeData* pNetUpgradeData);

//+---------------------------------------------------------------------------
//
//  Function:   DoPreUpgradeProcessing
//
//  Purpose:    Intialize OEM DLL
//
//  Arguments:
//      hParentWindow    [in]  window handle for showing UI
//      hkeyParams       [in]  handle to parameters key in registry
//      szPreNT5InfId    [in]  pre-NT5 InfID
//      szPreNT5Instance [in]  pre-NT5 instance name
//      szNT5InfId       [in]  NT5 InfId
//      szSectionName    [in]  section name to be used for writing info
//      pviVendorInfo    [out] information about OEM
//      pdwFlags         [out] pointer to flags
//      pvReserved       [in]  reserved
//
//  Returns:    ERROR_SUCCESS in case of success, win32 error otherwise
//
//  Notes:
//      This function is called once per component to be upgraded.
//
LONG __stdcall
DoPreUpgradeProcessing(IN   HWND        hParentWindow,
                       IN   HKEY        hkeyParams,
                       IN   LPCTSTR     szPreNT5InfId,
                       IN   LPCTSTR     szPreNT5Instance,
                       IN   LPCTSTR     szNT5InfId,
                       IN   LPCTSTR     szSectionName,
                       OUT  VENDORINFO* pviVendorInfo,
                       OUT  DWORD*      pdwFlags,
                       IN   LPVOID      pvReserved);

typedef LONG
(__stdcall *DoPreUpgradeProcessingPrototype)
     (IN   HWND    hParentWindow,
      IN   HKEY    hkeyParams,
      IN   LPCTSTR szPreNT5InfId,
      IN   LPCTSTR szPreNT5Instance,
      IN   LPCTSTR szNT5InfId,
      IN   LPCTSTR szSectionName,
      OUT  VENDORINFO* pviVendorInfo,
      OUT  DWORD*  pdwFlags,
      IN   LPVOID  pvReserved);


//+---------------------------------------------------------------------------
//
//  Function:   PostUpgradeInitialize
//
//  Purpose:    Intialize OEM DLL during GUI mode setup
//
//  Arguments:
//      szWorkingDir     [in]   name of temporary directory to be used
//      pNetUpgradeInfo  [in]   pointer to NetUpgradeInfo structure
//      pviVendorInfo    [out]  information about OEM
//      pvReserved       [out]  reserved
//
//  Returns:    ERROR_SUCCESS in case of success, win32 error otherwise
//
//  Notes:
//      This function is called in GUI mode setup before
//      any other function in this dll .
//      The main purpose of calling this function is to obtain
//      identification information and to allow the DLL to initialize
//      its internal data
//
LONG __stdcall
PostUpgradeInitialize(IN LPCTSTR          szWorkingDir,
                      IN  NetUpgradeInfo* pNetUpgradeInfo,
                      OUT VENDORINFO*     pviVendorInfo,
                      OUT LPVOID          pvReserved);

typedef LONG
(__stdcall *PostUpgradeInitializePrototype)
     (IN LPCTSTR          szWorkingDir,
      IN  NetUpgradeInfo* pNetUpgradeInfo,
      OUT VENDORINFO*     pviVendorInfo,
      OUT LPVOID          pvReserved);



//+---------------------------------------------------------------------------
//
//  Function:   DoPostUpgradeProcessing
//
//  Purpose:    Intialize OEM DLL
//
//  Arguments:
//      hParentWindow    [in]  window handle for showing UI
//      hkeyParams       [in]  handle to parameters key in registry
//      szPreNT5Instance [in]  pre-NT5 instance name
//      szNT5InfId       [in]  NT5 InfId
//      hinfAnswerFile   [in]  handle to answer-file
//      szSectionName    [in]  name of section having component parameters
//      pviVendorInfo    [out] information about OEM
//      pvReserved       [in]  reserved
//
//  Returns:    ERROR_SUCCESS in case of success, win32 error otherwise
//
//  Notes:
//      This function is called once per component upgraded.
//
LONG __stdcall
DoPostUpgradeProcessing(IN  HWND    hParentWindow,
                        IN  HKEY    hkeyParams,
                        IN  LPCTSTR szPreNT5Instance,
                        IN  LPCTSTR szNT5InfId,
                        IN  HINF    hinfAnswerFile,
                        IN  LPCTSTR szSectionName,
                        OUT VENDORINFO* pviVendorInfo,
                        IN  LPVOID  pvReserved);

typedef LONG
(__stdcall *DoPostUpgradeProcessingPrototype)
     (IN  HWND    hParentWindow,
      IN  HKEY    hkeyParams,
      IN  LPCTSTR szPreNT5Instance,
      IN  LPCTSTR szNT5InfId,
      IN  HINF    hinfAnswerFile,
      IN  LPCTSTR szSectionName,
      OUT VENDORINFO* pviVendorInfo,
      IN  LPVOID  pvReserved);


//
// Prototypes for functions exported by netupgrd.dll
//

LONG __stdcall
NetUpgradeAddSection(IN LPCTSTR szSectionName);

typedef LONG
(__stdcall *NetUpgradeAddSectionPrototype) (IN LPCTSTR szSectionName);


LONG __stdcall
NetUpgradeAddLineToSection(IN LPCTSTR szSectionName,
                           IN LPCTSTR szLine);

typedef LONG
(__stdcall *NetUpgradeAddLineToSectionPrototype) (IN LPCTSTR szSectionName,
                                                  IN LPCTSTR szLine);


#ifdef __cplusplus
}
#endif

#endif      // __OEMUPGEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\pcrt32.h ===
/*
 * porting macros for c runtimes - use these to let 16 bit crt calls work
 * properly on 32 bit code.
 */

#if _MSC_VER > 1000
#pragma once
#endif

#define _ffree free
#define _fmalloc malloc
#define _fmemccpy memccpy
#define _fmemchr memchr
#define _fmemcmp memcmp
#define _fmemcpy memcpy
#define _fmemicmp _memicmp
#define _fmemmove memmove
#define _fmemset memset
#define _frealloc realloc
#define _fstrcat strcat
#define _fstrchr strchr
#define _fstrcmp strcmp
#define _fstrcpy strcpy
#define _fstrcspn strcspn
#define _fstrdup _strdup
#define _fstricmp _stricmp
#define _fstrlen strlen
#define _fstrlwr _strlwr
#define _fstrncat strncat
#define _fstrncmp strncmp
#define _fstrncpy strncpy
#define _fstrnicmp _strnicmp
#define _fstrnset strnset
#define _fstrpbrk strpbrk
#define _fstrrchr strrchr
#define _fstrrev strrev
#define _fstrset strset
#define _fstrspn strspn
#define _fstrstr strstr
#define _fstrtok strtok
#define _fstrupr _strupr
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\patchbc.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    Patchbc.h

Abstract:

    Public header file for a module used to patch translated messages
    into arrays that constitute Windows NT file system and master boot code.

Author:

    Ted Miller (tedm) 6 May 1997

Revision History:

--*/

#if _MSC_VER > 1000
#pragma once
#endif


/*

    Various modules in the Windows NT need to lay the mbr or file system
    boot records, such as format, setup, etc. Boot code for fat, fat32,
    ntfs, and the mbr is each built into a corresponding header file
    in sdk\inc. Each header file has an array of bytes that constitute
    the boot code itself. The code has no text in it, but instead has some
    placeholders for text that need to be patched in at run-time by
    users of those header files. This allows localization of the
    boot messages without recompiles.

    As built, each boot code array has a WORD in a known place that
    indicates where in the array the messages are supposed to start.
    In addition the boot code expects to look in that same place to
    find the offset of any message it needs. Thus code in this
    module reads the value that was built into the array and replaces
    it with values of the latter type.

    For the file system boot code, the message offset table is located
    immediately before the 2-byte 55aa sig (for fat) or the 4-byte 000055aa
    sig (for fat32 and ntfs).

    Fat/Fat32 share 3 messages, whose offsets are expected to be in the
    following order in the offset table:

        NTLDR is missing
        Disk error
        Press any key to restart

    NTFS has 4 messages, whose offsets are expected to be in the following
    order in the offset table:

        A disk read error occurred
        NTLDR is missing
        NTLDR is compressed
        Press Ctrl+Alt+Del to restart

    For the master boot code, the message offset table is immediately before
    the NTFT signature and has 3 messages (thus it starts at offset 0x1b5).
    The offsets are expected to be in the following order:

        Invalid partition table
        Error loading operating system
        Missing operating system

    Finally note that to allow one-byte values to be stored in the message
    offset tables we store the offset - 256.

    The routines below return FALSE if the text is too long to fit in the
    available space.
*/

#ifdef __cplusplus
extern "C" {
#endif
BOOLEAN
PatchMessagesIntoFatBootCode(
    IN OUT PUCHAR  BootCode,
    IN     BOOLEAN IsFat32,
    IN     LPCSTR  MsgNtldrMissing,
    IN     LPCSTR  MsgDiskError,
    IN     LPCSTR  MsgPressKey
    );

BOOLEAN
PatchMessagesIntoNtfsBootCode(
    IN OUT PUCHAR  BootCode,
    IN     LPCSTR  MsgNtldrMissing,
    IN     LPCSTR  MsgNtldrCompressed,
    IN     LPCSTR  MsgDiskError,
    IN     LPCSTR  MsgPressKey
    );

BOOLEAN
PatchMessagesIntoMasterBootCode(
    IN OUT PUCHAR  BootCode,
    IN     LPCSTR  MsgInvalidTable,
    IN     LPCSTR  MsgIoError,
    IN     LPCSTR  MsgMissingOs
    );
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\plan32.h ===
/*****************************************************************************\
* Copyright (C) Microsoft Corporation, 1990-1999
* PLAN32.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides macros to map portable lanman code to its 32 bit form.
\*****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif


/*----------------------------------LANMAN----------------------------------*/

/* LANMAN MACROS: */

#define COPYTOARRAY(pDest, pSource)     pDest = pSource

/* LANMAN API: */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ossdll.h ===
/*
 * Copyright (C) 1993-1999 Open Systems Solutions, Inc.  All rights reserved.
 *
 * THIS FILE IS PROPRIETARY MATERIAL OF OPEN SYSTEMS SOLUTIONS, INC.
 * AND MAY ONLY BE USED BY DIRECT LICENSEES OF OPEN SYSTEMS SOLUTIONS, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED.
 *
 * FILE: @(#)ossdll.h	5.57.1.1  97/06/08
 */


#ifndef OSSDLL_H
#define OSSDLL_H

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(push, ossPacking, 4)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack(1)
#elif defined(__BORLANDC__) && defined(__MSDOS__)
#ifdef _BC31
#pragma option -a-
#else
#pragma option -a1
#endif /* _BC31 */
#elif defined(__BORLANDC__) && defined(__WIN32__)
#pragma option -a4
#elif defined(__IBMC__)
#pragma pack(4)
#elif defined(__WATCOMC__) && defined(__NT__)
#pragma pack(push, 4)
#elif defined(__WATCOMC__) && (defined(__WINDOWS__) || defined(__DOS__))
#pragma pack(push, 1)
#endif /* _MSC_VER && _WIN32 */

#if defined(_WINDOWS) || defined(_WIN32) || defined(WIN32) || \
    defined(__WIN32__) || defined(__OS2__)  || defined(NETWARE_DLL)
#include <stdio.h>
#include <limits.h>
#include <stdarg.h>
#if !defined(__OS2__) && !defined(NETWARE_DLL) && !defined(_NTSDK)
#include <windows.h>
#endif /* !__OS2__ && !NETWARE_DLL && !_NTSDK */
#include "asn1hdr.h"
#ifndef DLL_ENTRY
#if defined(_WIN32) || defined(WIN32) || defined(__WIN32__)
#ifdef __BORLANDC__
#define PUBLIC
#define DLL_ENTRY      __stdcall __export
#define DLL_ENTRY_FDEF __stdcall __export
#define DLL_ENTRY_FPTR __stdcall __export
#elif defined(__IBMC__)
#define PUBLIC
#define DLL_ENTRY      WINAPI
#define DLL_ENTRY_FDEF WINAPI __export
#define DLL_ENTRY_FPTR WINAPI
#elif defined(__WATCOMC__)
#define PUBLIC
#define DLL_ENTRY      WINAPI __export
#define DLL_ENTRY_FDEF WINAPI __export
#define DLL_ENTRY_FPTR WINAPI __export
#elif defined(_NTSDK)
typedef void *         HINSTANCE;
typedef void *         HWND;
typedef char           BOOL;
typedef long           LONG;
#define PUBLIC         __declspec(dllexport)
#define DLL_ENTRY
#define DLL_ENTRY_FDEF
#define DLL_ENTRY_FPTR
#else
#define PUBLIC
#define DLL_ENTRY      WINAPI
#define DLL_ENTRY_FDEF WINAPI
#define DLL_ENTRY_FPTR WINAPI
#endif /* __BORLANDC__ */
#define _System
#elif defined(_WINDOWS)
#define PUBLIC
#ifdef DPMI_DLL
#define DLL_ENTRY      FAR PASCAL __export
#define DLL_ENTRY_FDEF FAR PASCAL __export
#define DLL_ENTRY_FPTR FAR PASCAL __export
#else
#define DLL_ENTRY      far pascal _export
#define DLL_ENTRY_FDEF far pascal _export
#define DLL_ENTRY_FPTR far pascal _export
#endif /* DPMI_DLL */
#define _System
#elif defined(__OS2__)
#define PUBLIC
#define DLL_ENTRY      _System
#define DLL_ENTRY_FDEF _Export _System
#define DLL_ENTRY_FPTR
#define HWND int
#define LONG long
#define BOOL char
#define DWORD unsigned long
#define HINSTANCE unsigned long
#elif defined(NETWARE_DLL)
#define PUBLIC
#define DLL_ENTRY
#define DLL_ENTRY_FDEF
#define DLL_ENTRY_FPTR
#define _Export
#undef _System
#define _System
#define LONG unsigned long
#define HWND int
#define DWORD LONG
#define BOOL char
#define HINSTANCE LONG
#endif /* _WIN32 || WIN32 || __WIN32__ */
#endif /* DLL_ENTRY */

#define BUFFERSIZE 1024
			/*
			 * NUMBER_OF_LINES_IN_BLOCK is the number of
			 * 4-byte offsets in a block of memory allocated
			 * at a time.  Each offset corresponds to a line
			 * of a text file to be displayed in a window.
			 */
#define NUMBER_OF_LINES_IN_BLOCK 200

typedef struct memblock {
    struct memblock     *prev;
    struct memblock     *next;
    LONG                *fileOffset;
    short               *lineLength;
    short                blockNumber;
} MEMBLOCK;

#ifdef __alpha
#define ossArg LONG_LONG
#else
#define ossArg int
#endif /* __alpha */

typedef struct memManagerTbl {
    int			 (DLL_ENTRY_FPTR *_System ossMinitp)(void *);
    unsigned char	*(DLL_ENTRY_FPTR *_System dopenInp)(void *,
						void **, unsigned long *);
    unsigned long	 (DLL_ENTRY_FPTR *_System dclosInp)(void *,
						void **, size_t);
    unsigned char	*(DLL_ENTRY_FPTR *_System dswapInp)(void *,
						void **, size_t *);
    void		 (DLL_ENTRY_FPTR *_System dopenOutp)(void *, void *,
						unsigned long, unsigned long);
    unsigned char	*(DLL_ENTRY_FPTR *_System dxferObjp)(void *,
						void **inn, void **out,
						size_t *, unsigned long *);
    unsigned long	 (DLL_ENTRY_FPTR *_System dclosOutp)(void *, void **);
    void		*(DLL_ENTRY_FPTR *_System dallcOutp)(void *, size_t,
								char root);
    void		 (DLL_ENTRY_FPTR *_System openWorkp)(void *);
    void		 (DLL_ENTRY_FPTR *_System pushHndlp)(void *, void *);
    unsigned char	*(DLL_ENTRY_FPTR *_System popHndlp)(void *,
							void **, size_t);
    void		 (DLL_ENTRY_FPTR *_System closWorkp)(void *);
    void		*(DLL_ENTRY_FPTR *_System allcWorkp)(void *, size_t);
    unsigned char	*(DLL_ENTRY_FPTR *_System lockMemp)(void *, void *);
    void		 (DLL_ENTRY_FPTR *_System unlokMemp)(void *, void *,
								char);
    void		 (DLL_ENTRY_FPTR *_System ossFreerp)(void *, void *);
    int			 (DLL_ENTRY_FPTR *_System freePDUp)(void *, int,
							void *, void *);
    void		 (DLL_ENTRY_FPTR *_System drcovObjp)(void *, int,
							void *, void *);
    unsigned char	*(DLL_ENTRY_FPTR *_System eopenInp)(void *, void *,
								size_t);
    unsigned char	*(DLL_ENTRY_FPTR *_System eswapInp)(void *, void *,
							void *, size_t);
    void		 (DLL_ENTRY_FPTR *_System eclosInp)(void *, void *);
    unsigned char	*(DLL_ENTRY_FPTR *_System eopenOutp)(void *, void **,
							size_t *, char);
    unsigned char	*(DLL_ENTRY_FPTR *_System eswapOutp)(void *, void **,
							size_t, size_t *);
    unsigned char	*(DLL_ENTRY_FPTR *_System exferObjp)(void *, void **,
				void **, unsigned long *, unsigned long);
    unsigned long	 (DLL_ENTRY_FPTR *_System eclosOutp)(void *, void **,
							size_t, char);
    void		 (DLL_ENTRY_FPTR *_System ercovObjp)(void *);
    unsigned char	*(DLL_ENTRY_FPTR *_System asideBeginp)(void *,
						void **, size_t, size_t *);
    unsigned char	*(DLL_ENTRY_FPTR *_System asideSwapp)(void *,
						void **, size_t, size_t *);
    void		*(DLL_ENTRY_FPTR *_System asideEndp)(void *,
							void *, size_t);
    unsigned char	*(DLL_ENTRY_FPTR *_System setDumpp)(void *, void **,
							void *, size_t *);
    void		 (DLL_ENTRY_FPTR *_System ossSetSortp)(void *, void *,
							unsigned char);
    void		 (DLL_ENTRY_FPTR *_System freeBUFp)(void *, void *);
    unsigned char	 (DLL_ENTRY_FPTR *_System egetBytep)(void *, void *,
							unsigned long);
    void		*(DLL_ENTRY_FPTR *_System _ossMarkObjp)(void *,
								int, void *);
    void		*(DLL_ENTRY_FPTR *_System _ossUnmarkObjp)(void *,
								void *);
    void		*(DLL_ENTRY_FPTR *_System _ossGetObjp)(void *,
								void *);
    void		*(DLL_ENTRY_FPTR *_System _ossTestObjp)(void *,
								void *);
    void		(DLL_ENTRY_FPTR *_System _ossFreeObjectStackp)(void *);
    void		(DLL_ENTRY_FPTR *_System ossMtermp)(void *);
    void		(DLL_ENTRY_FPTR *_System _ossSetTimeoutp)(void *, long);
    int			memMgrType;
} MemManagerTbl;

#define osswinit ossWinit
#ifndef __IBMC__
PUBLIC int       DLL_ENTRY ossOpenTraceWindow(struct ossGlobal *);
void                      *getStartAddress(struct ossGlobal *, char *);
void            *DLL_ENTRY ossGetHeader(void);
PUBLIC HINSTANCE DLL_ENTRY ossLoadDll(struct ossGlobal *, char *);
PUBLIC int       DLL_ENTRY ossFreeDll(struct ossGlobal *, char *);
int                        ossWriteWindow(struct ossGlobal *, HWND);
PUBLIC int       DLL_ENTRY ossPrintWin(struct ossGlobal *, const char *,
			ossArg, ossArg, ossArg, ossArg, ossArg, ossArg,
					ossArg, ossArg, ossArg, ossArg);
PUBLIC int       DLL_ENTRY ossReadLine(struct ossGlobal *, HWND, FILE *,
						char *, MEMBLOCK *, LONG);
PUBLIC void      DLL_ENTRY ossFreeList(struct ossGlobal *);
PUBLIC void      DLL_ENTRY ossSaveTraceInfo(struct ossGlobal *, HWND, char *);
PUBLIC void      DLL_ENTRY ossWterm(struct ossGlobal *);
PUBLIC HINSTANCE DLL_ENTRY ossLoadMemoryManager(struct ossGlobal *, int, char *);
PUBLIC int       DLL_ENTRY ossWinit(struct ossGlobal *, void *, char *, HWND);
int              DLL_ENTRY oss_test(struct ossGlobal *);
int                        ossGeneric(struct ossGlobal *, HWND);
extern const int           ossEncoderDecoderType;
	/*
	 * The following two functions are used by the memory manager &
	 * tracing routine DLL as low level memory allocator and freer
	 * replacing the default--which is malloc() and free()--in the
	 * sample tests.  See ossgnrc.c for more information.
	 */
extern void *DLL_ENTRY getmem(size_t);
extern void  DLL_ENTRY rlsmem(void *);
extern HINSTANCE hInst;
#endif /* !__IBMC__ */
#endif /* _WINDOWS ||_WIN32 || WIN32 || __WIN32__ || __OS2__ || NETWARE_DLL */


#if defined(_WINDOWS) || defined(_WIN32) || \
    defined(__OS2__)  || defined(NETWARE_DLL)

#if defined(_WINDOWS) || defined(_DLL) || \
    defined(OS2_DLL)  || defined(NETWARE_DLL)
#define OSS_PLUS_INFINITY  "PLUS_INFINITY"
#define OSS_MINUS_INFINITY "MINUS_INFINITY"
#define ossNaN             "NOT_A_NUMBER"
#endif /* _WINDOWS || _DLL || OS2_DLL || NETWARE_DLL */


typedef struct cstrainTbl {
    int  (DLL_ENTRY_FPTR *_System ossConstrainp)(void *, int, void *, void *);
} CstrainTbl;

typedef struct berTbl {
    int   (DLL_ENTRY_FPTR *_System ossBerEncodep)(void *, int, void *,
				char **, long *, void *, unsigned, char *);
    int   (DLL_ENTRY_FPTR *_System ossBerDecodep)(void *, int *, char **,
			long *, void **, long *, void *, unsigned, char *);
#ifdef SOED
    int   (DLL_ENTRY_FPTR *_System berEncodeOpenTypep)(void *, int,
				void *, void **, long *, void *, unsigned);
    int   (DLL_ENTRY_FPTR *_System berDecodeOpenTypep)(void  *, int *, void **,
				long  *, void **, long *, void *, unsigned);
    void  (DLL_ENTRY_FPTR *_System enc_errorp)(void *, int, void *);
    void  (DLL_ENTRY_FPTR *_System dec_errorp)(void *, int, void *);
    long  (DLL_ENTRY_FPTR *_System writetobufferp)(void *, unsigned char c);
    long  (DLL_ENTRY_FPTR *_System write_intp)(void *, char length, LONG_LONG);
    long  (DLL_ENTRY_FPTR *_System write_valuep)(void *, unsigned long,
							unsigned char *, char);
    int   (DLL_ENTRY_FPTR *_System numbitsp)(long);
    void  (DLL_ENTRY_FPTR *_System fpeHandlerp)(int);
    void *(DLL_ENTRY_FPTR *_System new_perm_pointed_top)(void *, void *,
							size_t, size_t);
    void  (DLL_ENTRY_FPTR *_System release_work_spacep)(void *, void *, size_t);
    void *(DLL_ENTRY_FPTR *_System copy_from_work_spacep)(void *, size_t,
					size_t suffix, void *, size_t, char);
    unsigned char (DLL_ENTRY_FPTR *_System get_bytep)(void *);
    void  (DLL_ENTRY_FPTR *_System set_intp)(void *, unsigned char *,
			unsigned int, LONG_LONG value, int);
    void *(DLL_ENTRY_FPTR *_System reserve_work_spacep)(void *, size_t, size_t *);
    long  (DLL_ENTRY_FPTR *_System encode_lengthp)(void *, long);
    void  (DLL_ENTRY_FPTR *_System debug_realp)(void *, char, unsigned char *, int, long);
    void  (DLL_ENTRY_FPTR *_System debug_strp)(void *, unsigned char *, size_t);
#else
#define   _dstd_parms_defx char **, long *, long
#define   _sdstd_parms_defx char **, long *
#define   _std_parms_defx char **, long *, char
    LONG_LONG (DLL_ENTRY_FPTR *_System _oss_dec_llintp)     (void *, _dstd_parms_defx);
    ULONG_LONG (DLL_ENTRY_FPTR *_System _oss_dec_ullintp)   (void *, _dstd_parms_defx);
    char (DLL_ENTRY_FPTR *_System _oss_dec_boolp)           (void *, _dstd_parms_defx);
    int  (DLL_ENTRY_FPTR *_System _oss_dec_iintp)           (void *, _dstd_parms_defx);
    long (DLL_ENTRY_FPTR *_System _oss_count_setof_itemsp)  (void *, _dstd_parms_defx);
    long (DLL_ENTRY_FPTR *_System _oss_dec_lengthp)         (void *, _sdstd_parms_defx);
    long (DLL_ENTRY_FPTR *_System _oss_dec_lintp)           (void *, _dstd_parms_defx);
    long (DLL_ENTRY_FPTR *_System _oss_encd_aiobjidp)       (void *, _std_parms_defx, void *, short);
    long (DLL_ENTRY_FPTR *_System _oss_encd_alobjidp)       (void *, _std_parms_defx, void *, short);
    long (DLL_ENTRY_FPTR *_System _oss_encd_asobjidp)       (void *, _std_parms_defx, void *, short);
    long (DLL_ENTRY_FPTR *_System _oss_encd_boolp)          (void *, _std_parms_defx, char);
    long (DLL_ENTRY_FPTR *_System _oss_encd_crealp)         (void *, _std_parms_defx, char *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_gtimep)         (void *, _std_parms_defx, void *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_huge_intp)      (void *, _std_parms_defx, void *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_uhuge_intp)     (void *, _std_parms_defx, void *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_intp)           (void *, _std_parms_defx, LONG_LONG _data);
    long (DLL_ENTRY_FPTR *_System _oss_encd_lengthp)        (void *, _std_parms_defx, unsigned long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_liobjidp)       (void *, _std_parms_defx, void *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_llobjidp)       (void *, _std_parms_defx, void *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_lsobjidp)       (void *, _std_parms_defx, void *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_mrealp)         (void *, _std_parms_defx, void *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_nstrp)          (void *, _std_parms_defx, char *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_opentypep)      (void *, _std_parms_defx, void *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_pbitp)          (void *, _std_parms_defx, void *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_pstrp)          (void *, _std_parms_defx, char *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_realp)          (void *, _std_parms_defx, double);
    long (DLL_ENTRY_FPTR *_System _oss_encd_tagp)           (void *, _std_parms_defx, unsigned short, char);
    long (DLL_ENTRY_FPTR *_System _oss_encd_uanyp)          (void *, _std_parms_defx, void *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_ubitp)          (void *, _std_parms_defx, void *, char, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_uintp)          (void *, _std_parms_defx, ULONG_LONG);
    long (DLL_ENTRY_FPTR *_System _oss_encd_uiobjidp)       (void *, _std_parms_defx, void *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_ulobjidp)       (void *, _std_parms_defx, void *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_uoctp)          (void *, _std_parms_defx, void *, char, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_usobjidp)       (void *, _std_parms_defx, void *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_ustrp)          (void *, _std_parms_defx, void *, char, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_utimep)         (void *, _std_parms_defx, void *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_vbitp)          (void *, _std_parms_defx, void *, long, char);
    long (DLL_ENTRY_FPTR *_System _oss_encd_voctp)          (void *, _std_parms_defx, void *, char, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_vstrp)          (void *, _std_parms_defx, void *, char, long);
    short (DLL_ENTRY_FPTR *_System _oss_dec_sintp)          (void *, _dstd_parms_defx);
    unsigned int (DLL_ENTRY_FPTR *_System _oss_dec_uiintp)  (void *, _dstd_parms_defx);
    unsigned long (DLL_ENTRY_FPTR *_System _oss_dec_ulintp) (void *, _dstd_parms_defx);
    unsigned short (DLL_ENTRY_FPTR *_System _oss_dec_usintp)(void *, _dstd_parms_defx);
    void (DLL_ENTRY_FPTR *_System _oss_dec_aiobjid_ptrp)    (void *, _dstd_parms_defx, char, void **, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_aiobjidp)        (void *, _dstd_parms_defx, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_alobjid_ptrp)    (void *, _dstd_parms_defx, char, void **, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_alobjidp)        (void *, _dstd_parms_defx, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_asobjid_ptrp)    (void *, _dstd_parms_defx, char, void **, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_asobjidp)        (void *, _dstd_parms_defx, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_crealp)          (void *, _dstd_parms_defx, char, char **);
    void (DLL_ENTRY_FPTR *_System _oss_dec_frealp)          (void *, _dstd_parms_defx, float *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_gtimep)          (void *, _dstd_parms_defx, void *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_hintp)           (void *, _dstd_parms_defx, char, void *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_liobjidp)        (void *, _dstd_parms_defx, char, void **, long);
    void (DLL_ENTRY_FPTR *_System _oss_dec_llobjidp)        (void *, _dstd_parms_defx, char, void **, long);
    void (DLL_ENTRY_FPTR *_System _oss_dec_lsobjidp)        (void *, _dstd_parms_defx, char, void **, long);
    void (DLL_ENTRY_FPTR *_System _oss_dec_mrealp)          (void *, _dstd_parms_defx, char, void *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_nstr_ptrp)       (void *, _dstd_parms_defx, char, char **, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_nstrp)           (void *, _dstd_parms_defx, char *, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_opentypep)       (void *, _dstd_parms_defx, char, void *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_pbitp)           (void *, _dstd_parms_defx, void *, unsigned long, char, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_pstrp)           (void *, _dstd_parms_defx, char *, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_realp)           (void *, _dstd_parms_defx, double *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_tagp)            (void *, _sdstd_parms_defx, unsigned short *, char *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_uanyp)           (void *, _dstd_parms_defx, char, void *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_ubitp)           (void *, _dstd_parms_defx, char, void *, char, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_uiobjidp)        (void *, _dstd_parms_defx, char, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_ulobjidp)        (void *, _dstd_parms_defx, char, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_uoctp)           (void *, _dstd_parms_defx, char, void *, char, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_usobjidp)        (void *, _dstd_parms_defx, char, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_ustrp)           (void *, _dstd_parms_defx, char, void *, char, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_utimep)          (void *, _dstd_parms_defx, void *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_vbit_ptrp)       (void *, _dstd_parms_defx, char, void **, long, char, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_vbitp)           (void *, _dstd_parms_defx, void *, long, char, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_voct_ptrp)       (void *, _dstd_parms_defx, char, void **, char, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_voctp)           (void *, _dstd_parms_defx, void *, char, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_vstr_ptrp)       (void *, _dstd_parms_defx, char, void **, char, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_vstrp)           (void *, _dstd_parms_defx, void *, char, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_enc_errorp)          (void *, char, int, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_aiobjidp)       (void *, _std_parms_defx, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_enci_alobjidp)       (void *, _std_parms_defx, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_enci_asobjidp)       (void *, _std_parms_defx, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_enci_boolp)          (void *, _std_parms_defx, char);
    void (DLL_ENTRY_FPTR *_System _oss_enci_crealp)         (void *, _std_parms_defx, char *);
    void (DLL_ENTRY_FPTR *_System _oss_enci_gtimep)         (void *, _std_parms_defx, void *);
    void (DLL_ENTRY_FPTR *_System _oss_enci_intp)           (void *, _std_parms_defx, LONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_enci_lengthp)        (void *, _std_parms_defx, unsigned long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_liobjidp)       (void *, _std_parms_defx, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_llobjidp)       (void *, _std_parms_defx, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_lsobjidp)       (void *, _std_parms_defx, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_mrealp)         (void *, _std_parms_defx, void *);
    void (DLL_ENTRY_FPTR *_System _oss_enci_nstrp)          (void *, _std_parms_defx, char *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_opentypep)      (void *, _std_parms_defx, void *);
    void (DLL_ENTRY_FPTR *_System _oss_enci_pbitp)          (void *, _std_parms_defx, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_pstrp)          (void *, _std_parms_defx, char *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_realp)          (void *, _std_parms_defx, double);
    void (DLL_ENTRY_FPTR *_System _oss_enci_tagp)           (void *, _std_parms_defx, unsigned short, char);
    void (DLL_ENTRY_FPTR *_System _oss_enci_uanyp)          (void *, _std_parms_defx, void *);
    void (DLL_ENTRY_FPTR *_System _oss_enci_ubitp)          (void *, _std_parms_defx, void *, char, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_uintp)          (void *, _std_parms_defx, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_enci_uiobjidp)       (void *, _std_parms_defx, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_ulobjidp)       (void *, _std_parms_defx, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_uoctp)          (void *, _std_parms_defx, void *, char, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_usobjidp)       (void *, _std_parms_defx, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_ustrp)          (void *, _std_parms_defx, void *, char, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_utimep)         (void *, _std_parms_defx, void *);
    void (DLL_ENTRY_FPTR *_System _oss_enci_vbitp)          (void *, _std_parms_defx, void *, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_enci_voctp)          (void *, _std_parms_defx, void *, char, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_vstrp)          (void *, _std_parms_defx, void *, char, long);
    void (DLL_ENTRY_FPTR *_System _oss_free_crealp)         (void *, char *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_eobjidp)        (void *, _std_parms_defx, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_dec_eobjidp)         (void *, _dstd_parms_defx, char, void *, long);
    long (DLL_ENTRY_FPTR *_System _oss_write_bytes_dp)      (void *, _std_parms_defx, unsigned char *, long);
    char (DLL_ENTRY_FPTR *_System _oss_not_dfltp)           (void *, void *, void *, long, long, int);
    long (DLL_ENTRY_FPTR *_System _oss_encd_dubitp)         (void *, _std_parms_defx, void *, char, long, char);
    long (DLL_ENTRY_FPTR *_System _oss_encd_dvbitp)         (void *, _std_parms_defx, void *, long, char, char);
#endif /* SOED */
} BERTbl;

typedef struct perTbl {
    int  (DLL_ENTRY_FPTR *_System ossPerEncodep)(void *, int, void *, char **, long *, void *, unsigned, char *);
    int  (DLL_ENTRY_FPTR *_System ossPerDecodep)(void *, int *, char **, long *, void **, long *, void *, unsigned, char *);
#ifdef SOED
    int  (DLL_ENTRY_FPTR *_System perEncodeOpenTypep)(void *, int,
				void *, void **, long *, void *, unsigned);
    int  (DLL_ENTRY_FPTR *_System perDecodeOpenTypep)(void  *, int *, void **,
				long  *, void **, long *, void *, unsigned);
    void (DLL_ENTRY_FPTR *_System encode_PDUp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System decode_PDUp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System den_errorp)(void *, int, void *);
    void (DLL_ENTRY_FPTR *_System encode_lengthp)(void *, long, LONG_LONG, LONG_LONG);
    void (DLL_ENTRY_FPTR *_System debug_realp)(void *, char, unsigned char *, int, long);
    void (DLL_ENTRY_FPTR *_System debug_strp)(void *, unsigned char *, size_t);
    void (DLL_ENTRY_FPTR *_System append_to_field_listp)(void *, unsigned char *, LONG_LONG, int);
    int  (DLL_ENTRY_FPTR *_System numbitsp)(long);
    void (DLL_ENTRY_FPTR *_System decode_lengthp)(void *, unsigned long *, unsigned long, unsigned long, unsigned short *);
    unsigned char (DLL_ENTRY_FPTR *_System get_octetp)(void *, unsigned short, char);
    void (DLL_ENTRY_FPTR *_System set_intp)(void *, unsigned char *, unsigned int, LONG_LONG, int);
    void (DLL_ENTRY_FPTR *_System set_uintp)(void *, unsigned char *, unsigned int, ULONG_LONG, int);
    LONG_LONG (DLL_ENTRY_FPTR *_System twos_comp_intp)(unsigned char *, int);
    void (DLL_ENTRY_FPTR *_System get_octetsp)(void *, unsigned char *, LONG_LONG, unsigned short, char);
    void (DLL_ENTRY_FPTR *_System encode_normally_small_numberp)(void *, ULONG_LONG, char);
    void (DLL_ENTRY_FPTR *_System decode_normally_small_numberp)(void *, LONG_LONG *, char);
    void (DLL_ENTRY_FPTR *_System add_fieldp)(void *, char *, int, int);
    void (DLL_ENTRY_FPTR *_System output_linep)(void *);
    unsigned char (DLL_ENTRY_FPTR *_System get_bitp)(void *, unsigned short, char);
    unsigned char *(DLL_ENTRY_FPTR *_System dswapOutp)(void *, void *, void **, size_t, char, char);
    void (DLL_ENTRY_FPTR *_System debug_objidp)(void *, unsigned char *, int, int, int);
#else
    void (DLL_ENTRY_FPTR *_System _oss_penc_unconstr_intp)(void *, LONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_kmstrp)       (void *, char *, ULONG_LONG, ULONG_LONG, ULONG_LONG, int, long, char);
    LONG_LONG (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_intp)(void *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_ub_kmstrp)    (void *, void *, char **, int, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_ntp_kmstrp)   (void *, char **, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_appendp)           (void *, unsigned char *, unsigned long, int);
    void (DLL_ENTRY_FPTR *_System _oss_penc_unconstr_bitp)(void *, unsigned char *, ULONG_LONG, char);
    void (DLL_ENTRY_FPTR *_System _oss_penc_constr_bitp)  (void *, unsigned char *, ULONG_LONG, ULONG_LONG, ULONG_LONG, char, char);
    void (DLL_ENTRY_FPTR *_System _oss_penc_unconstr_octp)(void *, unsigned char *, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_constr_octp)  (void *, unsigned char *, ULONG_LONG, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_link_objidsp) (void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_objidsp)      (void *, unsigned short *, unsigned long);
    void (DLL_ENTRY_FPTR *_System _oss_penc_link_objidlp) (void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_objidlp)      (void *, unsigned long *, unsigned long);
    void (DLL_ENTRY_FPTR *_System _oss_penc_link_objidip) (void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_objidip)      (void *, unsigned int *, unsigned long);
    void (DLL_ENTRY_FPTR *_System _oss_penc_nkmstrp)      (void *, char *, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_opentypep)    (void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_nonneg_intp)  (void *, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_realp)        (void *, double);
    void (DLL_ENTRY_FPTR *_System _oss_penc_uenump)       (void *, unsigned long, void *, void *);
    unsigned long (DLL_ENTRY_FPTR *_System _oss_penc_lengthp)(void *, ULONG_LONG, ULONG_LONG, ULONG_LONG, char);
    void (DLL_ENTRY_FPTR *_System _oss_penc_gtimep)       (void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_utimep)       (void *, void *);
    unsigned char (DLL_ENTRY_FPTR *_System _oss_get_bitp) (void *, int);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_ubitp)(void *, void *, unsigned char **, int);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_constr_ubitp) (void *, void *, unsigned char **, int, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_vbit_ptrp)(void *, void **, int);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_vbitp)(void *, void *, unsigned char *, int, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_constr_voctp) (void *, void *, unsigned char  *, int, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_uoctp)(void *, void *, unsigned char **, int);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_voct_ptrp)(void *, void **, int);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_constr_uoctp) (void *, void *, unsigned char **value, int, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_constr_vbitp) (void *, void *, unsigned char *, int, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_link_objidsp) (void *, void **);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_link_objidip) (void *, void **);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_link_objidlp) (void *, void **);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_uobjidsp)     (void *, unsigned short **, unsigned short *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_uobjidip)     (void *, unsigned int **, unsigned short *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_uobjidlp)     (void *, unsigned long **, unsigned short *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_aobjidsp)     (void *, unsigned short *, unsigned short *, unsigned short);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_aobjidip)     (void *, unsigned int *, unsigned short *, unsigned short);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_aobjidlp)     (void *, unsigned long *, unsigned short *, unsigned short);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_aobjids_ptrp) (void *, void **);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_aobjidi_ptrp) (void *, void **);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_aobjidl_ptrp) (void *, void **);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_ntp_nkmstrp)  (void *, char **);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_opentypep)    (void *, void *);
    ULONG_LONG (DLL_ENTRY_FPTR *_System _oss_pdec_nonneg_intp)(void *, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_get_bitsp)         (void *, unsigned char *, unsigned long, int);
    float  (DLL_ENTRY_FPTR *_System _oss_pdec_frealp)     (void *);
    double (DLL_ENTRY_FPTR *_System _oss_pdec_realp)      (void *);
    unsigned long (DLL_ENTRY_FPTR *_System _oss_pdec_uenump)(void *, void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_lsofp)        (void *, unsigned long *, ULONG_LONG, ULONG_LONG, unsigned char, char *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_usofp)        (void *, unsigned long *, unsigned char **, int, long, ULONG_LONG, ULONG_LONG, unsigned char, char *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_asofp)        (void *, unsigned long *, int, ULONG_LONG, ULONG_LONG, unsigned char, char *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_gtimep)       (void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_utimep)       (void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_asof_ptrp)    (void *, void **, int, long, long, char *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_nt_kmstrp)    (void *, void *, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_va_kmstrp)    (void *, void *, char *, int, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_vap_kmstrp)   (void *, void **, int, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_pad_kmstrp)   (void *, void *, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_enc_errorp)        (void *, char, int, long);
    double (DLL_ENTRY_FPTR *_System _oss_pdec_binrealp)   (void *, unsigned char, long);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_constr_bpbitp)(void *, unsigned char *, int, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_constr_pbitp) (void *, void *, int, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_constr_vbit_ptrp)(void *, void **, int, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_constr_voct_ptrp)(void *, void **, int, ULONG_LONG, ULONG_LONG);
    unsigned long (DLL_ENTRY_FPTR *_System _oss_pdec_eapp)(void *, unsigned char **);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_easp)         (void *, unsigned char *, unsigned long, unsigned long);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_chrrealp)     (void *, unsigned char, long, double *, unsigned char *);
    long (DLL_ENTRY_FPTR *_System _oss_pdec_enump)        (void *, void *, void *);
    ULONG_LONG (DLL_ENTRY_FPTR *_System _oss_pdec_indeflen_intp)(void *, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_nt_nkmstrp)   (void *, char *, unsigned long);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_bmpstrp)      (void *, void *, unsigned short **, int, ULONG_LONG, ULONG_LONG, int, long, char);
    char *(DLL_ENTRY_FPTR *_System _oss_pdec_crealp)      (void *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_pad_kmstr_ptrp)(void *, char **, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_lengthp)      (void *, unsigned long *, ULONG_LONG, ULONG_LONG, char *);
    MixedReal (DLL_ENTRY_FPTR *_System _oss_pdec_mrealp)  (void *);
    void *(DLL_ENTRY_FPTR *_System _oss_pdec_popp)        (void *);
    void *(DLL_ENTRY_FPTR *_System _oss_pdec_pushp)       (void *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_uanyp)        (void *, void *);
#if INT_MAX == 2147483647
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unistrp)      (void *, void *, int **, int, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_penc_unistrp)      (void *, int *, ULONG_LONG, ULONG_LONG, ULONG_LONG, int, long, char);
#else
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unistrp)      (void *, void *, long **, int, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_penc_unistrp)      (void *, long *, ULONG_LONG, ULONG_LONG, ULONG_LONG, int, long, char);
#endif
    LONG_LONG  (DLL_ENTRY_FPTR *_System _oss_pdec_semicon_intp)(void *, LONG_LONG);
    ULONG_LONG (DLL_ENTRY_FPTR *_System _oss_pdec_semicon_uintp)(void *, ULONG_LONG);
    ULONG_LONG (DLL_ENTRY_FPTR *_System _oss_pdec_small_intp)(void *);
    unsigned long (DLL_ENTRY_FPTR *_System _oss_pdec_small_lenp)(void *);
    long (DLL_ENTRY_FPTR *_System _oss_pdec_subidp)       (void *, long, long, long *, long *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_ub_nkmstrp)   (void *, void *, char **, int);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_bpbitp)(void *, unsigned char *, long);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_pbitp)(void *, void *, int);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_hugep)(void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_vap_nkmstrp)   (void *, void **, int);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_va_nkmstrp)    (void *, void *, char *, int, unsigned long);
    void (DLL_ENTRY_FPTR *_System _oss_penc_constr_bpbitp) (void *, void *, ULONG_LONG, ULONG_LONG, char, char);
    void (DLL_ENTRY_FPTR *_System _oss_penc_constr_pbitp)  (void *, ULONG_LONG, ULONG_LONG, ULONG_LONG, ULONG_LONG, char, char);
    void (DLL_ENTRY_FPTR *_System _oss_penc_crealp)        (void *, char *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_enump)         (void *, long, void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_indeflen_intp) (void *, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_mrealp)        (void *, MixedReal);
    void *(DLL_ENTRY_FPTR *_System _oss_pop_globalp)       (void *);
    void *(DLL_ENTRY_FPTR *_System _oss_push_globalp)      (void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_semicon_intp)  (void *, LONG_LONG, LONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_semicon_uintp) (void *, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_small_intp)    (void *, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_small_lenp)    (void *, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_subidp)        (void *, int, unsigned long, unsigned long *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_uanyp)         (void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_unconstr_hugep)(void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_unconstr_pbitp)(void *, ULONG_LONG, ULONG_LONG, ULONG_LONG, char);
    void (DLL_ENTRY_FPTR *_System _oss_penc_semicon_hugep) (void *, void *, LONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_semicon_hugep) (void *, void *, LONG_LONG);
    unsigned char (DLL_ENTRY_FPTR *_System _oss_get_octetp)(void *, int);
    void (DLL_ENTRY_FPTR *_System _oss_penc_eobjidp)       (void *, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_eobjidp)       (void *, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_free_crealp)        (void *, char *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_sotp)          (void *);
#endif /* SOED */
} PERTbl;

typedef struct apiTbl {
    int (DLL_ENTRY_FPTR *_System ossSetEncodingRulesp)(void *, int);
    int (DLL_ENTRY_FPTR *_System ossGetEncodingRulesp)(void *);
    int (DLL_ENTRY_FPTR *_System ossSetRuntimeVersionp)(void *, int);
    int (DLL_ENTRY_FPTR *_System ossGetRuntimeVersionp)(void *);
    int (DLL_ENTRY_FPTR *_System ossSetCompatibilityFlagsp)(void *, unsigned long);
    unsigned long (DLL_ENTRY_FPTR *_System ossGetCompatibilityFlagsp)(void *);
    int (DLL_ENTRY_FPTR *_System encodep)(void *, int, void *, char **,
					long *, void *, unsigned, char *);
    int (DLL_ENTRY_FPTR *_System decodep)(void *, int *, char **, long *,
				void **, long *, void *, unsigned, char *);
    int (DLL_ENTRY_FPTR *_System ossSetDecodingLengthp)(void *, long);
    long (DLL_ENTRY_FPTR *_System ossGetDecodingLengthp)(void *);
    int (DLL_ENTRY_FPTR *_System ossSetEncodingFlagsp)(void *, unsigned long);
    int (DLL_ENTRY_FPTR *_System ossSetFlagsp)(void *, unsigned long);
    unsigned long (DLL_ENTRY_FPTR *_System ossGetEncodingFlagsp)(void *);
    int (DLL_ENTRY_FPTR *_System ossSetDecodingFlagsp)(void *, unsigned long);
    unsigned long (DLL_ENTRY_FPTR *_System ossGetDecodingFlagsp)(void *);
    char *(DLL_ENTRY_FPTR *_System ossGetErrMsgp)(void *world);
    void (DLL_ENTRY_FPTR *_System ossPrintHexp)(void *, char *, long);
    int (DLL_ENTRY_FPTR *_System ossEncodep)(void *, int, void *, void *);
    int (DLL_ENTRY_FPTR *_System ossDecodep)(void *, int *, void *, void **);
    int (DLL_ENTRY_FPTR *_System ossPrintPDUp)(void *, int, void *);
    int (DLL_ENTRY_FPTR *_System ossFreePDUp)(void *, int, void *);
    void (DLL_ENTRY_FPTR *_System ossFreeBufp)(void *, void *);
    int  (DLL_ENTRY_FPTR *ossPrintWinp)(void *, const char *,
				ossArg, ossArg, ossArg, ossArg, ossArg,
					ossArg, ossArg, ossArg, ossArg, ossArg);
    int  (DLL_ENTRY_FPTR *_System ossReadLinep)(void *, HWND, FILE *,
						char *, MEMBLOCK *, LONG);
    void (DLL_ENTRY_FPTR *_System ossFreeListp)(void *);
    void (DLL_ENTRY_FPTR *_System ossSaveTraceInfop)(void *, HWND, char *);
    void (DLL_ENTRY_FPTR *_System osstracep)(void *, void *p, size_t);
    int  (DLL_ENTRY_FPTR *_System ossOpenTraceWindowp)(void *);
    int  (DLL_ENTRY_FPTR *_System ossOpenTraceFilep)(void *, char *);
    int  (DLL_ENTRY_FPTR *_System ossCloseTraceFilep)(void *);
    long (DLL_ENTRY_FPTR *_System ossDetermineEncodingLengthp)(void *,
								int, void *);
    int  (DLL_ENTRY_FPTR *_System ossCallerIsDecoderp)(void *);
    void *(DLL_ENTRY_FPTR *_System ossMarkObjp)(void *, int, void *);
    void *(DLL_ENTRY_FPTR *_System ossUnmarkObjp)(void *, void *);
    void *(DLL_ENTRY_FPTR *_System ossGetObjp)(void *, void *);
    void *(DLL_ENTRY_FPTR *_System ossTestObjp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System ossFreeObjectStackp)(void *);
    void (DLL_ENTRY_FPTR *_System ossSetTimeoutp)(void *, long);
#ifndef SOED
    void (DLL_ENTRY_FPTR *_System ossMinitp)(void *);
    void *(DLL_ENTRY_FPTR *_System _oss_dec_getmemp)(void *, long, char);
    void *(DLL_ENTRY_FPTR *_System _oss_enc_getmemp)(void *, char);
    void *(DLL_ENTRY_FPTR *_System _oss_enc_popp)(void *);
    void (DLL_ENTRY_FPTR *_System _oss_enc_pushp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_releaseMemp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_freeMemp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_freeGlobalsp)(void *);
    void (DLL_ENTRY_FPTR *_System _oss_freeDerBlocksp)(void *);
    void (DLL_ENTRY_FPTR *_System _oss_set_outmem_ip)(void *, long,
							long *, char **);
    void (DLL_ENTRY_FPTR *_System _oss_set_outmem_dp)(void *, long,
							long *, char **);
    void (DLL_ENTRY_FPTR *_System _oss_set_outmem_pp)(void *, long *, char **);
    void (DLL_ENTRY_FPTR *_System _oss_set_outmem_pbp)(void *, long *, char **, unsigned);
    void (DLL_ENTRY_FPTR *_System _oss_beginBlockp)(void *, long, char **, long *);
    void (DLL_ENTRY_FPTR *_System _oss_nextItemp)(void *, long *);
    void (DLL_ENTRY_FPTR *_System _oss_endBlockp)(void *, char **, long *, unsigned char);
#endif /* !SOED */
    int  api;
} ApiTbl;

typedef struct cpyvalTbl {
    int (DLL_ENTRY_FPTR *_System ossCpyValuep)(void *, int, void *, void **);
} CpyValTbl;

typedef struct cmpvalTbl {
    int (DLL_ENTRY_FPTR *_System ossCmpValuep)(void *, int, void *, void *);
} CmpValTbl;

typedef struct berrealTbl {
    long (DLL_ENTRY_FPTR *_System ossBerEncodeRealp)(void *, void *,
							unsigned char *);
    long (DLL_ENTRY_FPTR *_System ossBerDecodeRealp)(void *, void *,
								long, char);
    void (DLL_ENTRY_FPTR *_System ossPrintRealp)(void *, void *,
							unsigned char *);
} BerRealTbl;

typedef struct perrealTbl {
    void (DLL_ENTRY_FPTR *_System ossPerEncodeRealp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System ossPerDecodeRealp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System ossPrintRealp)(void *, void *,
							unsigned char *);
} PerRealTbl;

typedef struct perpdvTbl {
    void (DLL_ENTRY_FPTR *_System ossPerEncodePDVp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System ossPerDecodePDVp)(void *, void *);
} PerPDVTbl;

typedef struct berpdvTbl {
    void (DLL_ENTRY_FPTR *_System ossBerEncodePDVp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System ossBerDecodePDVp)(void *, void *);
} BerPDVTbl;

typedef struct oidTbl {
int (DLL_ENTRY_FPTR *_System ossEncodedOidToAsnValp)(void *,
						const void *, void *);
int (DLL_ENTRY_FPTR *_System ossEncodedOidToDotValp)(void *,
						const void *, void *);
int (DLL_ENTRY_FPTR *_System ossAsnValToEncodedOidp)(void *,
						const char *, void *);
int (DLL_ENTRY_FPTR *_System ossDotValToEncodedOidp)(void *,
						const char *, void *);
} OidTbl;

/*
 * The structure "WinParm" is used to store DLL-related information.
 */
typedef struct functionTables {
    HWND        hWnd;           /* Handle of the window */
    LONG        index;          /* Current index into the file pointer array;
                                 * it indicates the number of lines written */
    MEMBLOCK   *memBlock;       /* Pointer to a current node of a memory
                                 * handling linked list of MEMBLOCKs */
    MEMBLOCK   *startBlock;     /* Pointer to the first node of a memory
                                 * handling linked list of MEMBLOCKs */
    short       length;         /* Length of a line that is written only
                                 * in part and no '\n' symbol was reached yet */
    short       blockNumber;    /* Current MEMBLOCK number */
    FILE       *tmpfp;          /* Temporary output file with tracing info */
    char        tmpfn[16];      /* Temporary output file name */
    BOOL        endSwitch;      /* Indicates if a '\n' symbol was reached or
                                 * not when writing a tracing info file to
                                 * a window */
    BOOL        conSwitch;      /* If FALSE, the output goes to a console,
                                 * otherwise to a window */
    BOOL	ossEncoderDecoderType; /* SOED vs. TOED */
    BOOL	cstrainNeeded;  /* If TRUE, constraint checking is needed */
    CstrainTbl *cstrainTbl;     /* Constraint checker DLL function table */
    BERTbl     *berTbl;         /* BER & DER DLL function table */
    PERTbl     *perTbl;         /* PER DLL function table */
    ApiTbl     *apiTbl;         /* Spartan/basic API DLL function table */
    CpyValTbl  *cpyvalTbl;      /* Value copier DLL function table */
    CmpValTbl  *cmpvalTbl;      /* Value comparator DLL function table */
    BerRealTbl *berrealTbl;     /* BER/DER encoder/decoder real DLL function
                                 * table */
    BerPDVTbl  *berpdvTbl;      /* PER encoder/decoder EMBEDDED PDV DLL
                                 * function table */
    PerRealTbl *perrealTbl;     /* PER encoder/decoder real DLL function table */
    PerPDVTbl  *perpdvTbl;      /* BER encoder/decoder EMBEDDED PDV DLL
                                 * function table */
    OidTbl     *oidTbl;         /* OBJECT IDENTIFIER converter DLL
                                 * function table */
    HINSTANCE   hBerDLL;        /* Handle of BER/DER encoder/decoder DLL */
    HINSTANCE   hPerDLL;        /* Handle of PER DLL */
    HINSTANCE   hCtlDLL;        /* Handle of control table/code file DLL */
    HINSTANCE   hMemDLL;        /* Handle of memory manager DLL */
    HINSTANCE   hCstrainDLL;    /* Handle of constraint checker DLL */
    HINSTANCE   hApiDLL;        /* Handle of Spartan/basic API DLL */
    HINSTANCE   hCpyvalDLL;     /* Handle of value copier DLL */
    HINSTANCE   hCmpvalDLL;     /* Handle of value comparator DLL */
    HINSTANCE   hBerrealDLL;    /* Handle of BER/DER encoder/decoder real DLL */
    HINSTANCE   hBerpdvDLL;     /* Handle of BER encoder/decoder EMBEDDED PDV
                                 * DLL */
    HINSTANCE   hPerrealDLL;    /* Handle of PER encoder/decoder real DLL */
    HINSTANCE   hPerpdvDLL;     /* Handle of PER encoder/decoder EMBEDDED PDV
                                 * DLL */
    HINSTANCE   hOidDLL;        /* Handle of OBJID converter DLL */
    MemManagerTbl *memMgrTbl;   /* Memory manager DLL function table */
    void       *reserved[10];   /* Reserved for possible future use */
} FunctionTables;

#if defined(_WINDOWS) && !defined(_WIN32) && !defined(WIN32)
#define GWL_USERDATA 0
#endif /* _WINDOWS && !_WIN32 && !WIN32 */
extern void *ctl_tbl;
#elif !defined(DLL_ENTRY)
#include <stdarg.h>
#if defined(_WIN32) || defined(WIN32)
#include <windows.h>
#define DLL_ENTRY      WINAPI
#define DLL_ENTRY_FDEF WINAPI
#define DLL_ENTRY_FPTR WINAPI
#else
#define DLL_ENTRY
#define DLL_ENTRY_FDEF
#define DLL_ENTRY_FPTR
#define PUBLIC
#endif /* _WIN32 || WIN32 */
#undef  _System
#define _System
#endif /* _WINDOWS || _WIN32 || __OS2__ || NETWARE_DLL */
#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(pop, ossPacking)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack()
#elif defined(__BORLANDC__) && (defined(__WIN32__) || defined(__MSDOS__))
#pragma option -a.
#elif defined(__IBMC__)
#pragma pack()
#elif defined(__WATCOMC__)
#pragma pack(pop)
#endif /* _MSC_VER && _WIN32 */
#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* OSSDLL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ossper.h ===
/*****************************************************************************/
/* Copyright (C) 1989-1999 Open Systems Solutions, Inc.  All rights reserved.*/
/*****************************************************************************/

/* THIS FILE IS PROPRIETARY MATERIAL OF OPEN SYSTEMS SOLUTIONS, INC.
 * AND MAY BE USED ONLY BY DIRECT LICENSEES OF OPEN SYSTEMS SOLUTIONS, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED. */

/*
 *
 * FILE: @(#)ossper.h	5.6  97/06/08
 *
 * function: Define the interfaces to the routines in the OSS PER
 * time-optimized encoder and decoder.
 *
 */

#ifndef ossper_hdr_file
#define ossper_hdr_file

#if _MSC_VER > 1000
#pragma once
#endif

#include <limits.h>
#include "asn1hdr.h"

#define Aligned   1
#define Unaligned 0

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(push, ossPacking, 4)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack(1)
#elif defined(__BORLANDC__) && defined(__MSDOS__)
#ifdef _BC31
#pragma option -a-
#else
#pragma option -a1
#endif /* _BC31 */
#elif defined(__BORLANDC__) && defined(__WIN32__)
#pragma option -a4
#elif defined(__IBMC__)
#pragma pack(4)
#elif defined(__WATCOMC__) && defined(__NT__)
#pragma pack(push, 4)
#elif defined(__WATCOMC__) && (defined(__WINDOWS__) || defined(__DOS__))
#pragma pack(push, 1)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=mac68k
#endif

struct _enum_data {
	int      num;    /* number of enumerations */
	long    *enums;  /* pointer to sorted array of enumerations */
};

struct _char_data {
	int      num;  /* number of characters in PermittedAlphabet */
	void     *pa;  /* pointer to PermittedAlphabet char string */
	void     *ia;  /* pointer to inverted indices string */
};

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(pop, ossPacking)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack()
#elif defined(__BORLANDC__) && (defined(__WIN32__) || defined(__MSDOS__))
#pragma option -a.
#elif defined(__IBMC__)
#pragma pack()
#elif defined(__WATCOMC__)
#pragma pack(pop)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=reset
#endif

#ifdef __cplusplus
extern "C" {
#endif

extern void DLL_ENTRY _oss_append(struct ossGlobal *g, unsigned char *field, unsigned long length,
			int align);

extern void DLL_ENTRY _oss_penc_unconstr_int(struct ossGlobal *g,
	    LONG_LONG value);

extern void DLL_ENTRY _oss_penc_semicon_int(struct ossGlobal *g,
	    LONG_LONG value, LONG_LONG lower_bound);

extern void DLL_ENTRY _oss_penc_semicon_uint(struct ossGlobal *g,
	    ULONG_LONG value, ULONG_LONG lower_bound);

extern void DLL_ENTRY _oss_penc_nonneg_int(struct ossGlobal *g,
	    ULONG_LONG value, ULONG_LONG range);

extern void DLL_ENTRY _oss_penc_indeflen_int(struct ossGlobal *g,
	    ULONG_LONG value, ULONG_LONG range);

extern void DLL_ENTRY _oss_penc_small_int(struct ossGlobal *g, ULONG_LONG value);

extern void DLL_ENTRY _oss_penc_enum(struct ossGlobal *g, long data,
	 struct _enum_data *root,
	 struct _enum_data *extension);

extern void DLL_ENTRY _oss_penc_uenum(struct ossGlobal *g, unsigned long data,
	 struct _enum_data *root,
	 struct _enum_data *extension);

extern void DLL_ENTRY _oss_penc_real(struct ossGlobal *g, double value);
extern void DLL_ENTRY _oss_penc_creal(struct ossGlobal *g, char *value);
extern void DLL_ENTRY _oss_penc_mreal(struct ossGlobal *g, MixedReal value);

extern void DLL_ENTRY _oss_penc_constr_bpbit(struct ossGlobal *g, void *value,
	ULONG_LONG lb, ULONG_LONG ub, _Bool NamedBits,
	_Bool Ext);

extern void DLL_ENTRY _oss_penc_constr_pbit(struct ossGlobal *g, ULONG_LONG value,
	ULONG_LONG size, ULONG_LONG lb, ULONG_LONG ub, _Bool NamedBits,
	_Bool Ext);

extern void DLL_ENTRY _oss_penc_constr_bit(struct ossGlobal *g, unsigned char *value,
	ULONG_LONG length, ULONG_LONG lb, ULONG_LONG ub, _Bool NamedBits,
	_Bool Ext);

extern void DLL_ENTRY _oss_penc_unconstr_bit(struct ossGlobal *g, unsigned char *value,
	ULONG_LONG length, _Bool NamedBits);

extern void DLL_ENTRY _oss_penc_unconstr_pbit(struct ossGlobal *g, ULONG_LONG value,
	ULONG_LONG length, ULONG_LONG size, _Bool NamedBits);

extern unsigned long DLL_ENTRY _oss_penc_length(struct ossGlobal *g, ULONG_LONG length,
		  ULONG_LONG lb, ULONG_LONG ub, _Bool ext);

extern unsigned long DLL_ENTRY _oss_pdec_small_len(struct ossGlobal *g);
extern void          DLL_ENTRY _oss_penc_small_len(struct ossGlobal *g,
							ULONG_LONG length);

extern void DLL_ENTRY _oss_penc_unconstr_oct(struct ossGlobal *g, unsigned char *value,
	 ULONG_LONG length);

extern void DLL_ENTRY _oss_penc_constr_oct(struct ossGlobal *g, unsigned char *value,
	 ULONG_LONG length, ULONG_LONG lb, ULONG_LONG ub);

extern struct ossGlobal *DLL_ENTRY _oss_push_global(struct ossGlobal *g);
extern struct ossGlobal *DLL_ENTRY _oss_pop_global(struct ossGlobal *g);

extern void DLL_ENTRY _oss_penc_objids(struct ossGlobal *g, unsigned short *value,
   unsigned long length);
extern void DLL_ENTRY _oss_penc_objidi(struct ossGlobal *g, unsigned int *value,
   unsigned long length);
extern void DLL_ENTRY _oss_penc_objidl(struct ossGlobal *g, unsigned long *value,
   unsigned long length);
extern void DLL_ENTRY _oss_penc_link_objids(struct ossGlobal *g, void *value);
extern void DLL_ENTRY _oss_penc_link_objidi(struct ossGlobal *g, void *value);
extern void DLL_ENTRY _oss_penc_link_objidl(struct ossGlobal *g, void *value);

extern void DLL_ENTRY _oss_penc_opentype(struct ossGlobal *g, void *value);
extern void DLL_ENTRY _oss_penc_nkmstr(struct ossGlobal *g, char *value, ULONG_LONG length);
extern void DLL_ENTRY _oss_penc_kmstr(struct ossGlobal *g, char *value, ULONG_LONG length,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);
extern void DLL_ENTRY _oss_penc_bmpstr(struct ossGlobal *g, unsigned short *value,
     ULONG_LONG length, ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);
#if INT_MAX == 2147483647
extern void DLL_ENTRY _oss_penc_unistr(struct ossGlobal *g, int *value,
     ULONG_LONG length, ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);
#else
extern void DLL_ENTRY _oss_penc_unistr(struct ossGlobal *g, long *value,
     ULONG_LONG length, ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);
#endif

extern void DLL_ENTRY _oss_penc_gtime(struct ossGlobal *g, GeneralizedTime *time);
extern void DLL_ENTRY _oss_penc_utime(struct ossGlobal *g, UTCTime *time);

extern void DLL_ENTRY _oss_penc_uany(struct ossGlobal *g, void *data );

extern void DLL_ENTRY _oss_penc_unconstr_huge(struct ossGlobal *g, void *data );
extern void DLL_ENTRY _oss_penc_semicon_huge(struct ossGlobal *g,
    void *data, LONG_LONG lb );

extern void DLL_ENTRY _oss_penc_eobjid(struct ossGlobal *g, void *data,
    long size_c);

/* decoding functions */

extern unsigned char DLL_ENTRY _oss_get_bit(struct ossGlobal *g, int align);

extern void DLL_ENTRY _oss_get_bits(struct ossGlobal *g, unsigned char *field,
			unsigned long length, int align);

extern unsigned char DLL_ENTRY _oss_get_octet(struct ossGlobal *g, int align);

extern LONG_LONG DLL_ENTRY _oss_pdec_unconstr_int(struct ossGlobal *g);

extern LONG_LONG DLL_ENTRY _oss_pdec_semicon_int(struct ossGlobal *g,
	    LONG_LONG lower_bound);

extern ULONG_LONG DLL_ENTRY _oss_pdec_semicon_uint(struct ossGlobal *g,
	    ULONG_LONG lower_bound);

extern ULONG_LONG DLL_ENTRY _oss_pdec_nonneg_int(struct ossGlobal *g,
	    ULONG_LONG range);

extern ULONG_LONG DLL_ENTRY _oss_pdec_indeflen_int(struct ossGlobal *g,
	    ULONG_LONG range);

extern ULONG_LONG DLL_ENTRY _oss_pdec_small_int(struct ossGlobal *g);

extern long DLL_ENTRY _oss_pdec_enum(struct ossGlobal *g,
	 struct _enum_data *root,
	 struct _enum_data *extension);

extern unsigned long DLL_ENTRY _oss_pdec_uenum(struct ossGlobal *g,
	 struct _enum_data *root,
	 struct _enum_data *extension);


extern double DLL_ENTRY _oss_pdec_binreal(struct ossGlobal *g, unsigned char s, long len);
extern void DLL_ENTRY _oss_pdec_chrreal(struct ossGlobal *g, unsigned char s, long len,
     double *num_out, unsigned char *str_out);

extern float     DLL_ENTRY _oss_pdec_freal(struct ossGlobal *g);
extern double    DLL_ENTRY _oss_pdec_real(struct ossGlobal *g);
extern char *    DLL_ENTRY _oss_pdec_creal(struct ossGlobal *g);
extern MixedReal DLL_ENTRY _oss_pdec_mreal(struct ossGlobal *g);

extern void DLL_ENTRY _oss_pdec_length(struct ossGlobal *g, unsigned long *length,
		  ULONG_LONG lb, ULONG_LONG ub, _Bool *last);

extern void DLL_ENTRY _oss_pdec_unconstr_ubit(struct ossGlobal *g, void *length,
	 unsigned char **value, int lengthsize);

extern void DLL_ENTRY _oss_pdec_unconstr_vbit_ptr(struct ossGlobal *g, void **ptr,
	 int lengthsize);

extern void DLL_ENTRY _oss_pdec_unconstr_vbit(struct ossGlobal *g, void *length,
	 unsigned char *value, int lengthsize, ULONG_LONG datasize);

extern void DLL_ENTRY _oss_pdec_unconstr_pbit(struct ossGlobal *g, void *value,
	int size);

extern void DLL_ENTRY _oss_pdec_unconstr_bpbit(struct ossGlobal *g, unsigned char *value,
	long size);

extern void DLL_ENTRY _oss_pdec_constr_ubit(struct ossGlobal *g, void *length,
	 unsigned char **value, int lengthsize,
	 ULONG_LONG lb, ULONG_LONG ub);

extern void DLL_ENTRY _oss_pdec_constr_vbit(struct ossGlobal *g, void *length,
	unsigned char  *value, int lengthsize,
	ULONG_LONG lb, ULONG_LONG ub);

extern void DLL_ENTRY _oss_pdec_constr_vbit_ptr(struct ossGlobal *g, void **ptr,
	 int lengthsize, ULONG_LONG lb, ULONG_LONG ub);

extern void DLL_ENTRY _oss_pdec_constr_pbit(struct ossGlobal *g, void *value,
	int size, ULONG_LONG lb, ULONG_LONG ub);

extern void DLL_ENTRY _oss_pdec_constr_bpbit(struct ossGlobal *g, unsigned char *value,
	int size, ULONG_LONG lb, ULONG_LONG ub);

extern void DLL_ENTRY _oss_pdec_unconstr_uoct(struct ossGlobal *g, void *length,
	 unsigned char **value, int lengthsize);

extern void DLL_ENTRY _oss_pdec_unconstr_voct_ptr(struct ossGlobal *g, void **ptr,
	 int lengthsize);

extern void DLL_ENTRY _oss_pdec_constr_voct_ptr(struct ossGlobal *g, void **ptr,
	 int lengthsize, ULONG_LONG lb, ULONG_LONG ub);

extern void DLL_ENTRY _oss_pdec_constr_uoct(struct ossGlobal *g, void *length,
	unsigned char **value, int lengthsize, ULONG_LONG lb, ULONG_LONG ub);

extern void DLL_ENTRY _oss_pdec_constr_voct(struct ossGlobal *g, void *length,
	unsigned char  *value, int lengthsize, ULONG_LONG lb, ULONG_LONG ub);

extern void DLL_ENTRY _oss_pdec_unconstr_voct(struct ossGlobal *g, void *length,
	unsigned char  *value, int lengthsize, ULONG_LONG ub);

extern struct ossGlobal * DLL_ENTRY _oss_pdec_push(struct ossGlobal *g);
extern struct ossGlobal * DLL_ENTRY _oss_pdec_pop(struct ossGlobal *g);

extern unsigned long DLL_ENTRY _oss_pdec_eap(struct ossGlobal *g, unsigned char **ext);
extern void DLL_ENTRY _oss_pdec_eas(struct ossGlobal *g, unsigned char *ext,
	 unsigned long count, unsigned long ea_num);

extern void DLL_ENTRY _oss_pdec_lsof(struct ossGlobal *g, unsigned long *count,
    ULONG_LONG lb, ULONG_LONG ub, unsigned char ext,
    _Bool *last);

extern void DLL_ENTRY _oss_pdec_usof(struct ossGlobal *g, unsigned long *count,
    unsigned char **value, int lengthsize, long itemsize,
    ULONG_LONG lb, ULONG_LONG ub, unsigned char ext,
    _Bool *last);

extern void DLL_ENTRY _oss_pdec_asof(struct ossGlobal *g, unsigned long *count,
    int lengthsize,
    ULONG_LONG lb, ULONG_LONG ub, unsigned char ext,
    _Bool *last);

extern void DLL_ENTRY _oss_pdec_asof_ptr(struct ossGlobal *g, void **ptr,
    int lengthsize, long itemsize, long prefixsize,
    _Bool *last);

extern void DLL_ENTRY _oss_pdec_aobjids(struct ossGlobal *g, unsigned short *value,
    unsigned short *count, unsigned short array_size);

extern void DLL_ENTRY _oss_pdec_aobjidi(struct ossGlobal *g, unsigned int   *value,
    unsigned short *count, unsigned short array_size);

extern void DLL_ENTRY _oss_pdec_aobjidl(struct ossGlobal *g, unsigned long  *value,
    unsigned short *count, unsigned short array_size);

extern void DLL_ENTRY _oss_pdec_aobjids_ptr(struct ossGlobal *g, void **ptr);
extern void DLL_ENTRY _oss_pdec_aobjidi_ptr(struct ossGlobal *g, void **ptr);
extern void DLL_ENTRY _oss_pdec_aobjidl_ptr(struct ossGlobal *g, void **ptr);

extern void DLL_ENTRY _oss_pdec_uobjids(struct ossGlobal *g, unsigned short **value,
	 unsigned short *count);
extern void DLL_ENTRY _oss_pdec_uobjidi(struct ossGlobal *g, unsigned int **value,
	 unsigned short *count);
extern void DLL_ENTRY _oss_pdec_uobjidl(struct ossGlobal *g, unsigned long **value,
	 unsigned short *count);

extern void DLL_ENTRY _oss_pdec_link_objids(struct ossGlobal *g, void **ptr);
extern void DLL_ENTRY _oss_pdec_link_objidi(struct ossGlobal *g, void **ptr);
extern void DLL_ENTRY _oss_pdec_link_objidl(struct ossGlobal *g, void **ptr);

extern void DLL_ENTRY _oss_pdec_ntp_kmstr(struct ossGlobal *g, char **ptr,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);

extern void DLL_ENTRY _oss_pdec_nt_kmstr(struct ossGlobal *g, void *ptr,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);

extern void DLL_ENTRY _oss_pdec_vap_kmstr(struct ossGlobal *g, void **ptr, int lengthsize,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);

extern void DLL_ENTRY _oss_pdec_va_kmstr(struct ossGlobal *g, void *length, char *value,
     int lengthsize,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);

extern void DLL_ENTRY _oss_pdec_ub_kmstr(struct ossGlobal *g, void *length, char **ptr,
     int lengthsize,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);

extern void DLL_ENTRY _oss_pdec_bmpstr(struct ossGlobal *g, void *length, unsigned short **ptr,
     int lengthsize,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);

#if INT_MAX == 2147483647
extern void DLL_ENTRY _oss_pdec_unistr(struct ossGlobal *g, void *length, int **ptr,
     int lengthsize,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);
#else
extern void DLL_ENTRY _oss_pdec_unistr(struct ossGlobal *g, void *length, long **ptr,
     int lengthsize,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);
#endif

extern void DLL_ENTRY _oss_pdec_ntp_nkmstr(struct ossGlobal *g, char **ptr);
extern void DLL_ENTRY _oss_pdec_nt_nkmstr(struct ossGlobal *g, char *value, unsigned long ub);
extern void DLL_ENTRY _oss_pdec_vap_nkmstr(struct ossGlobal *g, void **ptr, int lengthsize);
extern void DLL_ENTRY _oss_pdec_va_nkmstr(struct ossGlobal *g, void *length, char *value,
	 int lengthsize, unsigned long ub);
extern void DLL_ENTRY _oss_pdec_ub_nkmstr(struct ossGlobal *g, void *length, char **ptr,
     int lengthsize);

extern void DLL_ENTRY _oss_pdec_pad_kmstr(struct ossGlobal *g, void *ptr,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);

extern void DLL_ENTRY _oss_pdec_pad_kmstr_ptr(struct ossGlobal *g, char **ptr,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);

extern void DLL_ENTRY _oss_pdec_opentype(struct ossGlobal *g, void *data );
extern void DLL_ENTRY _oss_pdec_uany(struct ossGlobal *g, void *data );

extern void DLL_ENTRY _oss_pdec_gtime(struct ossGlobal *g, GeneralizedTime *data);
extern void DLL_ENTRY _oss_pdec_utime(struct ossGlobal *g, UTCTime *data);

extern struct _char_data *_oss_get_char_data(struct ossGlobal *g, int index);

extern void DLL_ENTRY _oss_pdec_unconstr_huge(struct ossGlobal *g, void *data );
extern void DLL_ENTRY _oss_pdec_semicon_huge(struct ossGlobal *g,
    void *data, LONG_LONG lb );

extern void DLL_ENTRY _oss_pdec_eobjid(struct ossGlobal *g, void *data,
	 long size_c);

extern void DLL_ENTRY _oss_pdec_sot(struct ossGlobal *g);

#ifdef __cplusplus
}
#endif /* __cplusplus */

	/*
	 * The following macros must be #defined if you compile the ASN.1
	 * compiler generated files (.c files) and link-edit with the import
	 * library ossapit.lib, i.e the OSS DLLs ossapit.dll, apit.dll,
	 * and toedber.dll/toedper.dll are used.  The following must not
	 * be #defined if you link-edit with the static library toedcode.lib.
	 */
#if defined(_DLL) || defined(OS2_DLL) ||\
   (defined(_WINDOWS) && !defined(_WIN32))
#define _oss_penc_unconstr_int   (*_g->ft.perTbl->_oss_penc_unconstr_intp)
#define _oss_pdec_unconstr_int   (*_g->ft.perTbl->_oss_pdec_unconstr_intp)
#define _oss_penc_kmstr          (*_g->ft.perTbl->_oss_penc_kmstrp)
#define _oss_pdec_ub_kmstr       (*_g->ft.perTbl->_oss_pdec_ub_kmstrp)
#define _oss_pdec_ntp_kmstr      (*_g->ft.perTbl->_oss_pdec_ntp_kmstrp)
#define _oss_append              (*_g->ft.perTbl->_oss_appendp)
#define _oss_penc_unconstr_bit   (*_g->ft.perTbl->_oss_penc_unconstr_bitp)
#define _oss_penc_constr_bit     (*_g->ft.perTbl->_oss_penc_constr_bitp)
#define _oss_penc_unconstr_oct   (*_g->ft.perTbl->_oss_penc_unconstr_octp)
#define _oss_penc_constr_oct     (*_g->ft.perTbl->_oss_penc_constr_octp)
#define _oss_penc_link_objids    (*_g->ft.perTbl->_oss_penc_link_objidsp)
#define _oss_penc_objids         (*_g->ft.perTbl->_oss_penc_objidsp)
#define _oss_penc_link_objidl    (*_g->ft.perTbl->_oss_penc_link_objidlp)
#define _oss_penc_objidl         (*_g->ft.perTbl->_oss_penc_objidlp)
#define _oss_penc_link_objidi    (*_g->ft.perTbl->_oss_penc_link_objidip)
#define _oss_penc_objidi         (*_g->ft.perTbl->_oss_penc_objidip)
#define _oss_penc_nkmstr         (*_g->ft.perTbl->_oss_penc_nkmstrp)
#define _oss_penc_opentype       (*_g->ft.perTbl->_oss_penc_opentypep)
#define _oss_penc_nonneg_int     (*_g->ft.perTbl->_oss_penc_nonneg_intp)
#define _oss_penc_real           (*_g->ft.perTbl->_oss_penc_realp)
#define _oss_penc_uenum          (*_g->ft.perTbl->_oss_penc_uenump)
#define _oss_penc_length         (*_g->ft.perTbl->_oss_penc_lengthp)
#define _oss_penc_gtime          (*_g->ft.perTbl->_oss_penc_gtimep)
#define _oss_penc_utime          (*_g->ft.perTbl->_oss_penc_utimep)
#define _oss_get_bit             (*_g->ft.perTbl->_oss_get_bitp)
#define _oss_pdec_unconstr_ubit  (*_g->ft.perTbl->_oss_pdec_unconstr_ubitp)
#define _oss_pdec_constr_ubit    (*_g->ft.perTbl->_oss_pdec_constr_ubitp)
#define _oss_pdec_constr_pbit    (*_g->ft.perTbl->_oss_pdec_constr_pbitp)
#define _oss_pdec_constr_bpbit   (*_g->ft.perTbl->_oss_pdec_constr_bpbitp)
#define _oss_pdec_unconstr_vbit_ptr (*_g->ft.perTbl->_oss_pdec_unconstr_vbit_ptrp)
#define _oss_pdec_unconstr_vbit  (*_g->ft.perTbl->_oss_pdec_unconstr_vbitp)
#define _oss_pdec_unconstr_uoct  (*_g->ft.perTbl->_oss_pdec_unconstr_uoctp)
#define _oss_pdec_constr_voct    (*_g->ft.perTbl->_oss_pdec_constr_voctp)
#define _oss_pdec_constr_voct_ptr (*_g->ft.perTbl->_oss_pdec_constr_voct_ptrp)
#define _oss_pdec_unconstr_voct_ptr (*_g->ft.perTbl->_oss_pdec_unconstr_voct_ptrp)
#define _oss_pdec_constr_uoct    (*_g->ft.perTbl->_oss_pdec_constr_uoctp)
#define _oss_pdec_constr_vbit    (*_g->ft.perTbl->_oss_pdec_constr_vbitp)
#define _oss_pdec_constr_vbit_ptr (*_g->ft.perTbl->_oss_pdec_constr_vbit_ptrp)
#define _oss_pdec_link_objids    (*_g->ft.perTbl->_oss_pdec_link_objidsp)
#define _oss_pdec_link_objidl    (*_g->ft.perTbl->_oss_pdec_link_objidlp)
#define _oss_pdec_link_objidi    (*_g->ft.perTbl->_oss_pdec_link_objidip)
#define _oss_pdec_uobjids        (*_g->ft.perTbl->_oss_pdec_uobjidsp)
#define _oss_pdec_uobjidl        (*_g->ft.perTbl->_oss_pdec_uobjidlp)
#define _oss_pdec_uobjidi        (*_g->ft.perTbl->_oss_pdec_uobjidip)
#define _oss_pdec_aobjids        (*_g->ft.perTbl->_oss_pdec_aobjidsp)
#define _oss_pdec_aobjidl        (*_g->ft.perTbl->_oss_pdec_aobjidlp)
#define _oss_pdec_aobjidi        (*_g->ft.perTbl->_oss_pdec_aobjidip)
#define _oss_pdec_aobjids_ptr    (*_g->ft.perTbl->_oss_pdec_aobjids_ptrp)
#define _oss_pdec_aobjidl_ptr    (*_g->ft.perTbl->_oss_pdec_aobjidl_ptrp)
#define _oss_pdec_aobjidi_ptr    (*_g->ft.perTbl->_oss_pdec_aobjidi_ptrp)
#define _oss_pdec_ntp_nkmstr     (*_g->ft.perTbl->_oss_pdec_ntp_nkmstrp)
#define _oss_pdec_nt_nkmstr      (*_g->ft.perTbl->_oss_pdec_nt_nkmstrp)
#define _oss_pdec_opentype       (*_g->ft.perTbl->_oss_pdec_opentypep)
#define _oss_pdec_nonneg_int     (*_g->ft.perTbl->_oss_pdec_nonneg_intp)
#define _oss_get_bits            (*_g->ft.perTbl->_oss_get_bitsp)
#define _oss_pdec_freal          (*_g->ft.perTbl->_oss_pdec_frealp)
#define _oss_pdec_real           (*_g->ft.perTbl->_oss_pdec_realp)
#define _oss_pdec_uenum          (*_g->ft.perTbl->_oss_pdec_uenump)
#define _oss_pdec_asof           (*_g->ft.perTbl->_oss_pdec_asofp)
#define _oss_pdec_usof           (*_g->ft.perTbl->_oss_pdec_usofp)
#define _oss_pdec_lsof           (*_g->ft.perTbl->_oss_pdec_lsofp)
#define _oss_pdec_utime          (*_g->ft.perTbl->_oss_pdec_utimep)
#define _oss_pdec_gtime          (*_g->ft.perTbl->_oss_pdec_gtimep)
#define _oss_pdec_asof_ptr       (*_g->ft.perTbl->_oss_pdec_asof_ptrp)
#define _oss_pdec_nt_kmstr       (*_g->ft.perTbl->_oss_pdec_nt_kmstrp)
#define _oss_pdec_va_kmstr       (*_g->ft.perTbl->_oss_pdec_va_kmstrp)
#define _oss_pdec_vap_kmstr      (*_g->ft.perTbl->_oss_pdec_vap_kmstrp)
#define _oss_pdec_pad_kmstr      (*_g->ft.perTbl->_oss_pdec_pad_kmstrp)
#define _oss_pdec_pad_kmstr_ptr  (*_g->ft.perTbl->_oss_pdec_pad_kmstr_ptrp)
#define _oss_pdec_binreal        (*_g->ft.perTbl->_oss_pdec_binrealp)
#define _oss_pdec_eap            (*_g->ft.perTbl->_oss_pdec_eapp)
#define _oss_pdec_eas            (*_g->ft.perTbl->_oss_pdec_easp)
#define _oss_pdec_chrreal        (*_g->ft.perTbl->_oss_pdec_chrrealp)
#define _oss_pdec_enum           (*_g->ft.perTbl->_oss_pdec_enump)
#define _oss_pdec_indeflen_int   (*_g->ft.perTbl->_oss_pdec_indeflen_intp)
#define _oss_penc_indeflen_int   (*_g->ft.perTbl->_oss_penc_indeflen_intp)
#define _oss_pdec_bmpstr         (*_g->ft.perTbl->_oss_pdec_bmpstrp)
#define _oss_pdec_creal          (*_g->ft.perTbl->_oss_pdec_crealp)
#define _oss_pdec_mreal          (*_g->ft.perTbl->_oss_pdec_mrealp)
#define _oss_penc_mreal          (*_g->ft.perTbl->_oss_penc_mrealp)
#define _oss_pdec_length         (*_g->ft.perTbl->_oss_pdec_lengthp)
#define _oss_pdec_pop            (*_g->ft.perTbl->_oss_pdec_popp)
#define _oss_pdec_push           (*_g->ft.perTbl->_oss_pdec_pushp)
#define _oss_pdec_uany           (*_g->ft.perTbl->_oss_pdec_uanyp)
#define _oss_penc_uany           (*_g->ft.perTbl->_oss_penc_uanyp)
#define _oss_pdec_unistr         (*_g->ft.perTbl->_oss_pdec_unistrp)
#define _oss_penc_unistr         (*_g->ft.perTbl->_oss_penc_unistrp)
#define _oss_pdec_semicon_int    (*_g->ft.perTbl->_oss_pdec_semicon_intp)
#define _oss_penc_semicon_int    (*_g->ft.perTbl->_oss_penc_semicon_intp)
#define _oss_pdec_semicon_uint   (*_g->ft.perTbl->_oss_pdec_semicon_uintp)
#define _oss_penc_semicon_uint   (*_g->ft.perTbl->_oss_penc_semicon_uintp)
#define _oss_pdec_small_int      (*_g->ft.perTbl->_oss_pdec_small_intp)
#define _oss_penc_small_int      (*_g->ft.perTbl->_oss_penc_small_intp)
#define _oss_pdec_small_len      (*_g->ft.perTbl->_oss_pdec_small_lenp)
#define _oss_penc_small_len      (*_g->ft.perTbl->_oss_penc_small_lenp)
#define _oss_pdec_subid          (*_g->ft.perTbl->_oss_pdec_subidp)
#define _oss_penc_subid          (*_g->ft.perTbl->_oss_penc_subidp)
#define _oss_pdec_ub_nkmstr      (*_g->ft.perTbl->_oss_pdec_ub_nkmstrp)
#define _oss_pdec_unconstr_bpbit (*_g->ft.perTbl->_oss_pdec_unconstr_bpbitp)
#define _oss_pdec_unconstr_pbit  (*_g->ft.perTbl->_oss_pdec_unconstr_pbitp)
#define _oss_penc_unconstr_pbit  (*_g->ft.perTbl->_oss_penc_unconstr_pbitp)
#define _oss_pdec_unconstr_huge  (*_g->ft.perTbl->_oss_pdec_unconstr_hugep)
#define _oss_penc_unconstr_huge  (*_g->ft.perTbl->_oss_penc_unconstr_hugep)
#define _oss_pdec_vap_nkmstr     (*_g->ft.perTbl->_oss_pdec_vap_nkmstrp)
#define _oss_pdec_va_nkmstr      (*_g->ft.perTbl->_oss_pdec_va_nkmstrp)
#define _oss_penc_constr_bpbit   (*_g->ft.perTbl->_oss_penc_constr_bpbitp)
#define _oss_penc_constr_pbit    (*_g->ft.perTbl->_oss_penc_constr_pbitp)
#define _oss_penc_creal          (*_g->ft.perTbl->_oss_penc_crealp)
#define _oss_penc_enum           (*_g->ft.perTbl->_oss_penc_enump)
#define _oss_pop_global          (*_g->ft.perTbl->_oss_pop_globalp)
#define _oss_push_global         (*_g->ft.perTbl->_oss_push_globalp)
#define _oss_get_octet           (*_g->ft.perTbl->_oss_get_octetp)
#define _oss_penc_eobjid         (*_g->ft.perTbl->_oss_penc_eobjidp)
#define _oss_pdec_eobjid         (*_g->ft.perTbl->_oss_pdec_eobjidp)
#define _oss_penc_semicon_huge   (*_g->ft.perTbl->_oss_penc_semicon_hugep)
#define _oss_pdec_semicon_huge   (*_g->ft.perTbl->_oss_pdec_semicon_hugep)
#define _oss_pdec_sot            (*_g->ft.perTbl->_oss_pdec_sot)
#undef _oss_enc_error
#undef _oss_free_creal
#define _oss_enc_error           (*_g->ft.perTbl->_oss_enc_errorp)
#define _oss_free_creal          (*_g->ft.perTbl->_oss_free_crealp)
#endif /* _DLL || OS2_DLL || (_WINDOWS && !_WIN32) */

#endif /* ossper_hdr_file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\osstrace.h ===
/*****************************************************************************/
/* Copyright (C) 1992-1999 Open Systems Solutions, Inc.  All rights reserved.*/
/*****************************************************************************/

/* THIS FILE IS PROPRIETARY MATERIAL OF OPEN SYSTEMS SOLUTIONS, INC. AND
 * MAY BE USED ONLY BY DIRECT LICENSEES OF OPEN SYSTEMS SOLUTIONS, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED. */

/*****************************************************************************/
/*  FILE: @(#)osstrace.h	5.4.1.1  97/06/08              */
/*                                                                           */
/*  When tracing is in effect in the OSS ASN.1 Tools encoder/decoder the     */
/*  user user-replaceable trace routine, osstrace(), is called to trace      */
/*  the value that is being encoded/decoded.  This header file describes     */
/*  the parameters passed to osstrace().                                     */
/*                                                                           */
/*  Detailed descriptions appear after the declarations.                     */
/*****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#include "ossdll.h"

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(push, ossPacking, 4)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack(1)
#elif defined(__BORLANDC__) && defined(__MSDOS__)
#ifdef _BC31
#pragma option -a-
#else
#pragma option -a1
#endif /* _BC31 */
#elif defined(__BORLANDC__) && defined(__WIN32__)
#pragma option -a4
#elif defined(__IBMC__)
#pragma pack(4)
#elif defined(__WATCOMC__) && defined(__NT__)
#pragma pack(push, 4)
#elif defined(__WATCOMC__) && (defined(__WINDOWS__) || defined(__DOS__))
#pragma pack(push, 1)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=mac68k
#endif

/* traceKind: describes the type of TraceRecord */

enum traceKind
{
	endOfContentsTrace = 0, /* end-of-contents octets */
	valueTrace,             /* traceRecord contains a traced value */
	skippedFieldTrace,      /* a value whose type is not recognized
				 * is being skipped */
	messageTrace            /* error message is in the field "value" */
};


/* fieldKind: describes the contents of "fieldNumber".  "fieldKind" is
 *            meaningful only if "fieldNumber" is not 0
 */

enum fieldKind
{
	setOrSequenceField = 0, /* "fieldNumber" is the position of the
				 * component within a SET or SEQUENCE */
	pduNumber,              /* "fieldNumber" is a PDU number */
	setOrSequenceOfElement, /* "fieldNumber" is the position of the
				 * component within a SET OF or SEQUENCE OF
				 * components */
	stringElement           /* "fieldNumber" is the position of the
				 * substring within a constructed STRING */
};

enum prtType
{
	seqsetType = 0,		/* SEQUENCE and SET uses [fieldcount =  n] */
	seqofType,		/* SEQUENCE OF and SET OF use [length = n] */
	choiceType,		/* CHOICE type uses format [index = n] 	   */
	pseudoType,		/* No length info is printed or [not encoded] */
	primeType,		/* All other types use the format	   */
				/* [length = [(not encoded)] nbytes.nbits] */
				/* fragmentation is printed for OCTET	   */
				/* STRING and BIT STRING.		   */
	closeType		/* Trace message at the end of encoding.   */
};

/* tag_length: specifies the tag and length of a value. */

struct tag_length
{
	unsigned long int length;  /* length of type, if definite */
	unsigned short int tag;    /* 16 bits of the form CCTTTTTTTTTTTTTT,
				    * with "CC" the class number, and "T...T"
				    * the tag. (If tag is 0, then "length",
				    * "primitive" and "definite" are
				    * not significant). */
	unsigned int      definite: 1;  /* 1: definite-length encoding */
};

/* traceRecord: OSS ASN.1 Tools trace record */

struct traceRecord
{
	enum traceKind   kind;          /* kind of trace record */
	void             *p;            /* reserved for OSS */
	char             *identifier,   /* SET/SEQUENCE/CHOICE component name*/
			 *typeReference,/* defined type name                 */
			 *builtinTypeName;  /* ASN.1 builtin type defined in *
					     * ISO 8824 or "Character String"*/

	void             *valueName;    /* reserved for future use */

	unsigned         taggingCount;  /* number of entries in the tag&length
					 * or content-end-octet array */

	union            /* tag&length or end-of-contents-octets array. */
	{
		struct tag_length *tag_length;
		int               *depth;
	}                 tagging;

	enum prtType      prtType;	/* Refer to prtType above for details */
	char           	  lenEncoded;	/* Indicate whether length is encoded */
	long              length;	/* Length in bits for all prime types */
					/* fieldcount for SET and SEQUENCE    */
					/* length of components for SET OF    */
					/* choice index for type CHOICE	      */
	int               fragment;	/* Fragment for OCTET STRING and BIT  */
					/* STRING, PER fragment when too long */

	enum fieldKind    fieldKind;   /* kind of value in "fieldNumber" */
	unsigned int      fieldNumber; /* component number, 0 if not
					*  applicable */

	unsigned int      depth;    /* the depth of this value, from 0 on up */

	unsigned int      primitive: 1; /* indicates structure of encoding */

	char              value[1];     /* the formatted value for simple
					 * type and ANY. If the first byte
					 * is 0, no value is present. */
};


extern void DLL_ENTRY osstrace(struct ossGlobal *g, struct traceRecord *p, size_t traceRecordLen);

/* osstrace(): User-replaceable trace routine.
 *
 * Parameters:
 *   g      - Reserved.  This is always set to NULL for now.
 *   p      - traceRecord, described below.
 *   traceRecordLen - True length of traceRecord, including first \0 in "value"
 *
 * osstrace() is called:
 *
 *      - once for each builtin ASN.1 type, regardless of tagging, with the
 *        field "kind" set to valueTrace.  So given a PDU of value "fooBar":
 *
 *           Sample DEFINITIONS EXPLICIT TAGS ::= BEGIN
 *               fooBar Foo ::= {age 6, living TRUE}
 *               Foo ::= SET {age INTEGER, living [1] [2] Alive}
 *               Alive ::= BOOLEAN
 *           END
 *
 *        it is called called three times with "kind" set to valueTrace - once
 *        for the SET, once for the INTEGER, and once for the BOOLEAN.
 *
 *        When the traceRecord "kind" field is set to valueTrace ...
 *
 *        The field "identifier" contains the component identifier of
 *        the type if one is present in the ASN.1 definition.  So in
 *        the above example, "identifier" will be empty on the call for
 *        the SET, while on the call for the INTEGER it will contain "age",
 *        and "living" on the call for the BOOLEAN.
 *
 *        The field "typeReference" contains the name of the associated ASN.1
 *        typereference, if any.  So in the above example, "typeReference"
 *        will contain "Foo" on the call for the SET, "Alive" on the call
 *        for the BOOLEAN, and will be empty on the call for the INTEGER.
 *
 *        The field "builtinTypeName" contains the name of the ASN.1 builtin
 *        type.  So in the above example, "builtinTypeName" will contain
 *        "SET", "INTEGER", and "BOOLEAN" on the calls as appropriate.
 *        Note that for all character string types "builtinTypeName" is
 *        set to "Character String".  This will be changed in the near future
 *        to reflect the true character string type.
 *
 *        The field "taggingCount" contains the number of entries in the array
 *        of tag_length structs pointed to by tagging.tag_length, and reflects
 *        the number of tags present in the encoding.  Note that an entry
 *        exists in the tag_length array for each ANY and CHOICE value as
 *        though they had tags defined for them in the ASN.1 Standard.  So in
 *        the above example, "taggingCount" is 1 on the calls for the SET and
 *        INTEGER, and on the call for the BOOLEAN "taggingCount" is 3 since
 *        EXPLICIT TAGS is in effect.
 *
 *        The field "tagging.tag_length" points to an array of tag_length
 *        structs.
 *
 *              The field "tagging.tag_length->tag" is the BER tag represented
 *              in the form CCTTTTTTTTTTTTTT with "CC" the class number, and
 *              "TTTTTTTTTTTTTT" the tag number.  Since the ANY and CHOICE
 *              types do not have tags of their own, the last entry in the
 *              tag_length array for these types always has 0 as the value of
 *              the "tag" field.  So in the above example, "tag" is 0x11 on the
 *              call for the the SET.
 *
 *              The field "tagging.tag_length->length" is the length of the
 *              encoded value if the length is of definite form (i.e.,
 *              "definite" is 1).
 *
 *              The field "tagging.tag_length->definite" indicates when the
 *              length is definite or indefinite.  This field is significant
 *              only if "tag" is non-zero.
 *
 *        The field "fieldKind" indicates whether the number in "field" is:
 *        -- the position of a component within a SET or SEQUENCE, or
 *        -- the PDU number assigned by the ASN.1 compiler, or
 *        -- the position of a component within a SET OF or SEQUENCE OF, or
 *        -- the position of a substring within a constructed string.
 *        "fieldKind" is significant only if "field" is non-zero.  So in
 *        the example above, "fieldKind" has a value of pduNumber on the
 *        call for the SET, and a value of setOrSequenceField on the calls for
 *        the INTEGER and BOOLEAN.
 *
 *        The field "fieldNumber" is a ordinal number indicating the position
 *        of a component within a SET, SEQUENCE, SET OF, SEQUENCE OF, or
 *        constructed string, or the PDU number assigned by the ASN.1 compiler.
 *        So in the above example, "fieldNumber" is 1 (the PDU number) on the
 *        call for the SET, 1 (the position of the component "age") on the
 *        call for the INTEGER, and 2 (the position of the component "living"
 *        on the call for the BOOLEAN.
 *
 *        The field "depth" is the level of nesting of the value relative to
 *        the outermost type, which has a "depth" value of 0.  So in the above
 *        example, "depth" is 0 on the call for the SET, and 1 on the calls
 *        for the INTEGER and BOOLEAN.
 *
 *        The field "primitive" is set to 1 if the builtin ASN.1 type is
 *        simple (i.e., the primitive/constructed bit in the identifier
 *        octet is set to 0), so it is 0 for SET, SEQUENCE, SET OF, SEQUENCE
 *        OF, and CHOICE because they are structured. It is also set to 0 if
 *        the type is an ANY.  It is 1 for all other builtin types.
 *
 *        The field "value" contains formatted data if the builtin type
 *        is simple or ANY, regardless of tagging.  Hence, in the above
 *        example the call for SET will not contain any data in "value"
 *        (because the builtin type is a constructed type), while for the
 *        INTEGER and BOOLEAN types "value" will contain formatted data.
 *        The maximum number of bytes of formatted data placed into "value"
 *        is controlled by the external variable "asn1chop".  If "asn1chop"
 *        is set to 0 the maximum length of the traced value is determined
 *        by the maximum internal buffer size variable, "ossblock".
 *
 *      - once for each end-of-contents octets pair that is generated/
 *        encountered while encoding/decoding a constructed value whose
 *        length is of the indefinite-length form.  A call with a "valueTrace"
 *        record is always made to osstrace() before one is made with an
 *        "endOfContentsTrace" record.
 *
 *        A single "endOfContentsTrace" call is made to osstrace() for each
 *        builtin type that is processed if the indefinite-length form of
 *        encoding is used.  If the builtin type is a structured type (CHOICE,
 *        SET, SEQUENCE, SET OF, SEQUENCE OF) then there may be multiple
 *        "valueTrace" and possible "endOfContentsTrace" calls made to
 *        osstrace() before the matching "endOfContentsTrace" call is made.
 *
 *        When the traceRecord "kind" field is set to endOfContentsTrace ...
 *
 *        The field "taggingCount" contains the number of entries in the array
 *        of "depth" indicators pointed to by tagging.depth, and reflects
 *        the nesting of each pair of end-of-contents-octets associated with
 *        the builtin type being encoded/decoded.  So in the above example,
 *        if indefinite-length encoding is being used, "taggingCount" will
 *        be 1 on the call for the SET (since it has a single constructed
 *        tag), and 2 on the call for the BOOLEAN (since it has two explicit
 *        tags, for which the "constructed" bit in the encoding must be set).
 *
 *        The field "tagging.depth" points to an array of "depth" indicators
 *        that reflect the nesting of each pair of end-of-contents-octets
 *        associated with a builtin type.  So in the above example, if
 *        indefinite-length encoding is being used, "tagging.depth" will point
 *        to a single 0 on the call for the SET since it has a single tag for
 *        which the constructed bit is set; while on the call for the BOOLEAN
 *        "tagging.depth" will point to an array whose two entries are 1 and 2
 *        since there are two explicit tags on the BOOLEAN.
 *
 *        All other fields in the traceRecord are insignificant for an
 *        endOfContentsTrace record.
 *
 *      - once for each value that is skipped while decoding, with a "kind"
 *        value of skippedFieldTrace.  The skippedFieldTrace "kind" is just
 *        means of indicating that an unexpected value was encountered in the
 *        message and is being skipped.  This is not an error if the type is
 *        extensible.
 *
 *        When the traceRecord "kind" field is set to skippedFieldTrace ...
 *
 *        The field of the traceRecord are the same as when "kind" is set to
 *        valueTrace, except that:
 *        -- the skipped value is always reported as having one tag, hence
 *        -- there is only one entry in the tag_length array.
 *        -- the content of the field "value" is always "<skipped>", and
 *        -- "typeReference" is always NULL.
 *
 *      - once for each error message issued, in which case the "kind" field
 *        is set to messageTrace.
 *
 *        When the traceRecord "kind" field is set to messageTrace the "value"
 *        field contains the error message, and other fields are
 *        insignificant.
 */


/* tag_length: describes the tag and length of a value.
 *
 *            "tag" is 0 if the value is an ANY or CHOICE value, in which
 *             case "definite" is not significant since ANY and CHOICE do
 *             not have a tag of their own.
 *
 *             If "tag" is not 0, "definite" indicates whether the value
 *             is encoded using definite- or indefinite-length form.
 *
 *             If "definite" is 1, "length" is the length of the value, else
 *             it is not significant (indefinite-length encoding was used).
 */


/* tagging: tag&length or end-of-contents-octets array.
 *
 *      The tag and length array, tag_length, is present if this
 *      is a valueTrace or skippedFieldTrace record.  There is one array
 *      entry for each tag present in the encoding of a given value, so
 *      "[1] EXPLICIT [2] EXPLICIT INTEGER" gets three tag_length
 *      array entries, where each entry describes the tag and length
 *      information that precedes the value.
 *
 *      The depth array, "depth", is present only if this is a
 *      endOfContentsTrace record.  There is one array entry for each
 *      indefinite length present in the encoding of a value, so
 *      "[1] EXPLICIT [2] EXPLICIT INTEGER" gets two "depth" entries
 *      corresponding to the two explicit tags, where the value of each
 *      tag indicates the depth of the tagged value relative to outmost type
 *      that contains the INTEGER (e.g., relative to the containing SET).
 */

/* Odds and ends:
 *
 * - When the value of a field is not significant the field is set to 0.
 */


/* Augmenting for Packed Encoding Rule (PER) tracing.
 *
 * PER does not encode tag for any ASN.1 type. For some types, length
 * may or may not be encoded. PER does not always use octet aligned
 * encoding, therefore, the length should be in unit of bit.
 *
 * We classified ASN.1 types in to the following:
 *
 * (1). For all primitive types (including ANY), the prtType in traceRecord
 * 	is set to primeType, length is the total length of the content
 *	in bits. The file osstrace.c prints length in the format
 *	length = nbytes.nbits, and the total length should be 8*nbytes+nbits.
 *	If the length is not encoded, "(not encoded)" will be added to the
 *	output string. For BIT STRING with length longer than 64K (bits), and
 *	for OCTET STRING longer that 16K (bytes), fragmentation is needed
 *	and this is indicated by the string "fragment = n" after the length.
 *	The fragmentation index is field fragment in traceRecord.
 * (2). For SEQUENCE and SET, prtType is seqsetType. In this case, the length
 *	in traceRecord is the fieldcount of the SEQUENCE or SET.
 * (3). For SEQUENCE OF and SET OF, prtType is seqofType, and the length
 *	in traceRecord is the count of components in the SEQUENCE OF (SET OF).
 * (4). For CHOICE, prtType is choiceType, and the length field in
 *	traceRecord indicates the choice index.
 * (5). Total number of bits for the entire encoding is reported at the end
 *	of encoding and decoding. The prtType for this trace is closeType.
 */

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(pop, ossPacking)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack()
#elif defined(__BORLANDC__) && (defined(__WIN32__) || defined(__MSDOS__))
#pragma option -a.
#elif defined(__IBMC__)
#pragma pack()
#elif defined(__WATCOMC__)
#pragma pack(pop)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=reset
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\plan16.h ===
/*****************************************************************************\
* Copyright (C) Microsoft Corporation, 1990-1999
* PLAN16.H - PORTABILITY MAPPING HEADER FILE FOR LANMAN API
*
* This file provides macros to map portable lanman code to its 16 bit form.
\*****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

/*-----------------------------------LANMAN----------------------------------*/

/* LANMAN MACROS: */

#define COPYTOARRAY(pDest, pSource)     strcpy(pDest, pSource)

/* LANMAN API: */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\parttype.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    parttype.h

Abstract:

    Header file for routines used to determine the correct
    partition type to use for a partition.

Author:

    Ted Miller (tedm) 5 Feb 1997

Revision History:

--*/

#if _MSC_VER > 1000
#pragma once
#endif


//
// Define classes of partitions meaningful to partition type APIs.
//
typedef enum {
    GenPartitionClassExtended,      // container partition (type 5 or f)
    GenPartitionClassFat12Or16,     // fat (types 1,4,6,e)
    GenPartitionClassFat32,         // fat32 (types b,c)
    GenPartitionClassNonFat,        // type 7
    GenPartitionClassMax
} GenPartitionClass;

//
// Flags for partition type APIs.
//
#define GENPARTTYPE_DISALLOW_XINT13     0x00000002
#define GENPARTTYPE_FORCE_XINT13        0x00000004


#ifdef __cplusplus
extern "C" {
#endif

//
// Routines.
//
NTSTATUS
GeneratePartitionType(
    IN  LPCWSTR NtDevicePath,               OPTIONAL
    IN  HANDLE DeviceHandle,                OPTIONAL
    IN  ULONGLONG StartSector,
    IN  ULONGLONG SectorCount,
    IN  GenPartitionClass PartitionClass,
    IN  ULONG Flags,
    IN  ULONG Reserved,
    OUT PUCHAR Type
    );


//
// Helper macros.
//
// (TedM) The mechanism for determining whether extended int13 is actually
// available on a drive is TBD. It is believed that the DISK_GEOMETRY structure
// will change to add an extra field or two to provide this information.
// Also, currently the disk drivers will increase the cylinder count if
// the drive reports more sectors than int13 function 8 reported. So for now
// we just see whether the partition ends on a cylinder > 1023. Both of these
// macros will need to be changed when the code to detect and report xint13 stuff
// becomes available in the system.

// (NorbertK) The right way to determine whether or not to use XINT13 is to just
// check where the partition lies.  We should continue to use the old int13 for
// partitions that are contained in the first 1024 cylinders.
//
#define XINT13_DESIRED(geom,endsect)                                                \
                                                                                    \
    (((endsect) / ((geom)->TracksPerCylinder * (geom)->SectorsPerTrack)) > 1023)

#define XINT13_AVAILABLE(geom)  TRUE

__inline
NTSTATUS
GeneratePartitionTypeWorker(
    IN  ULONGLONG StartSector,
    IN  ULONGLONG SectorCount,
    IN  GenPartitionClass PartitionClass,
    IN  ULONG Flags,
    IN  PDISK_GEOMETRY Geometry,
    OUT PUCHAR Type
    )

/*++

Routine Description:

    Worker routine for GeneratePartitionType and RegeneratePartitionType.

Arguments:

    StartSector - supplies start sector for partition

    SectorCount - supplies number of sectors in the partition

    PartitionClass - supplies class indicating intended use for the
        partition.

    Flags - supplies flags controlling operation.

    Geometry - supplies disk geometry information for the disk.

    Type - if successful, receives the type to be used.

Return Value:

    NT Status code indicating outcome.

--*/

{
    BOOLEAN UseXInt13;

    if(!StartSector || !SectorCount) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Figure out whether extended int13 is desired for this drive.
    //
    if(Flags & GENPARTTYPE_DISALLOW_XINT13) {
        UseXInt13 = FALSE;
    } else {
        if(Flags & GENPARTTYPE_FORCE_XINT13) {
            UseXInt13 = TRUE;
        } else {
            //
            // Need to figure it out.
            //
            UseXInt13 = FALSE;
            if(XINT13_DESIRED(Geometry,StartSector+SectorCount-1) && XINT13_AVAILABLE(Geometry)) {
                UseXInt13 = TRUE;
            }
        }
    }

    switch(PartitionClass) {

    case GenPartitionClassExtended:

        *Type = UseXInt13 ? PARTITION_XINT13_EXTENDED : PARTITION_EXTENDED;
        break;

    case GenPartitionClassFat12Or16:

        if(UseXInt13) {
            *Type = PARTITION_XINT13;
        } else {
            //
            // Need to figure out which of the 3 FAT types to use.
            //
            if(SectorCount < 32680) {
                *Type = PARTITION_FAT_12;
            } else {
                *Type = (SectorCount < 65536) ? PARTITION_FAT_16 : PARTITION_HUGE;
            }
        }
        break;

    case GenPartitionClassFat32:

        *Type = UseXInt13 ? PARTITION_FAT32_XINT13 : PARTITION_FAT32;
        break;

    case GenPartitionClassNonFat:

        *Type = PARTITION_IFS;
        break;

    default:
        return(STATUS_INVALID_PARAMETER);
    }

    return(STATUS_SUCCESS);
}

__inline
NTSTATUS
pOpenDevice(
    IN  LPCWSTR NtPath,
    OUT PHANDLE DeviceHandle
    )

/*++

Routine Description:

    Open an NT-style path, which is assumed to be for a disk device
    or a partition. The open is share read/share write, for synch i/o
    and read access.

Arguments:

    NtPath - supplies nt-style pathname to open.

    DeviceHandle - if successful, receives NT handle of open device.

Return Value:

    NT Status code indicating outcome.

--*/

{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    RtlInitUnicodeString(&UnicodeString,NtPath);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateFile(
                DeviceHandle,
                STANDARD_RIGHTS_READ | FILE_READ_DATA | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_ALERT,
                NULL,
                0
                );

    return(Status);
}

__inline
NTSTATUS
RegeneratePartitionType(
    IN  LPCWSTR NtPartitionPath,            OPTIONAL
    IN  HANDLE PartitionHandle,             OPTIONAL
    IN  GenPartitionClass PartitionClass,
    IN  ULONG Flags,
    IN  ULONG Reserved,
    OUT PUCHAR Type
    )

/*++

Routine Description:

    This routine determines the proper partition type to be used for an
    existing partition, for example if the partition is being reformatted.

Arguments:

    NtPartitionPath - supplies the NT-style path of the partition
        whose type is to be recalculated, such as \Device\Harddisk1\Partition2.
        This routine should not be called for partition0. If not specified,
        PartitionHandle must be.

    PartitionHandle - Supplies a handle to the partition whose type is to be
        recalculated. The caller should have opened the partition for at least
        FILE_READ_DATA and FILE_READ_ATTRIBUTES access. Ignored if
        NtPartitionPath is specified.

    PartitionClass - supplies a value indicating the intended use of the
        partition.

        GenPartitionClassExtended - inavalid with this routine.

        GenPartitionClassFat12Or16 - indicates that the partition will be
            used for a 12 or 16 bit FAT volume. The returned type will be
            PARTITION_FAT_12 (1), PARTITION_FAT_16 (4), PARTITION_HUGE (6),
            or PARTITION_XINT13 (e), depending on size and placement of the
            partition, availability of extended int13 for the drive,
            and the Flags parameter.

        GenPartitionClassFat32 - indicates that the partition will be used
            for a FAT32 volume. The returned type will be PARTITION_FAT32 (b)
            or PARTITION_FAT32_XINT13 (c), depending on placement of the
            partition, availability of extended int13 for the drive,
            and the Flags parameter.

        GenPartitionNonFat - indicates that the partition will be used for
            a non-FAT volume. The returned type will be PARTITION_IFS (7).
            It is advisable to call this routine even for type 7 partitions
            since in the future additional partition types could be returned
            in this case.

    Flags - Supplies flags that further control operation of this routine.

        GENPARTTYPE_DISALLOW_XINT13 - disallow extended int13 partition types.
            If this flag is set, PARTITION_FAT32_XINT13 (c),
            PARTITION_XINT13 (e), and PARTITION_XINT13_EXTENDED (f) will not
            be returned as the partition type to be used. Not valid with
            GENPARTTYPE_FORCE_XINT13.

        GENPARTTYPE_FORCE_XINT13 - forces use of extended int13 partition types
            even if not necessary for the partition being created. Not valid
            with GENPARTTYPE_DISALLOW_XINT13.

    Reserved - reserved, must be 0.

    Type - if this routine succeeds, this value receives the partition type
        to be used for the partition.

Return Value:

    NT Status code indicating outcome. If NO_ERROR, Type is filled in with
    the resulting partition type to be used.

--*/

{
    NTSTATUS Status;
    HANDLE DeviceHandle;
    DISK_GEOMETRY Geometry;
    IO_STATUS_BLOCK IoStatusBlock;
    PARTITION_INFORMATION_EX PartitionInfo;

    //
    // Validate parameters.
    //
    if((Flags & GENPARTTYPE_DISALLOW_XINT13) && (Flags & GENPARTTYPE_FORCE_XINT13)) {
        return(STATUS_INVALID_PARAMETER_3);
    }

    if((PartitionClass >= GenPartitionClassMax) || (PartitionClass == GenPartitionClassExtended)) {
        return(STATUS_INVALID_PARAMETER_2);
    }

    if(Reserved) {
        return(STATUS_INVALID_PARAMETER_4);
    }

    //
    // Open the device if the caller specified a name. Otherwise use
    // the handle the caller passed in.
    //
    if(NtPartitionPath) {
        Status = pOpenDevice(NtPartitionPath,&DeviceHandle);
        if(!NT_SUCCESS(Status)) {
            return(Status);
        }
    } else {
        DeviceHandle = PartitionHandle;
    }

    //
    // Get drive geometry for the device.
    //
    Status = NtDeviceIoControlFile(
                DeviceHandle,
                NULL,NULL,NULL,     // synchronous io
                &IoStatusBlock,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,0,             // no input buffer
                &Geometry,
                sizeof(DISK_GEOMETRY)
                );

    if(NT_SUCCESS(Status)) {
        //
        // Get partition info. We care about the start offset and size
        // of the partition.
        //
        Status = NtDeviceIoControlFile(
                    DeviceHandle,
                    NULL,NULL,NULL,     // synchronous io
                    &IoStatusBlock,
                    IOCTL_DISK_GET_PARTITION_INFO_EX,
                    NULL,0,             // no input buffer
                    &PartitionInfo,
                    sizeof(PartitionInfo)
                    );

        if (!NT_SUCCESS(Status)) {

            if (Status == STATUS_INVALID_DEVICE_REQUEST) {

                GET_LENGTH_INFORMATION  LengthInfo;

                Status = NtDeviceIoControlFile(DeviceHandle, 0, NULL, NULL,
                                               &IoStatusBlock,
                                               IOCTL_DISK_GET_LENGTH_INFO,
                                               NULL, 0, &LengthInfo,
                                               sizeof(GET_LENGTH_INFORMATION));

                if (NT_SUCCESS(Status)) {
                    //
                    // GET_PARTITION_INFO_EX will fail outright on an EFI Dynamic
                    // Volume.  In this case, just make up the starting offset
                    // so that FORMAT can proceed normally.
                    //

                    PartitionInfo.StartingOffset.QuadPart = 0x7E00;
                    PartitionInfo.PartitionLength.QuadPart = LengthInfo.Length.QuadPart;
                }
            }
        }

        if(NT_SUCCESS(Status)) {
            //
            // Call the worker routine to do the work.
            //
            Status = GeneratePartitionTypeWorker(
                        PartitionInfo.StartingOffset.QuadPart / Geometry.BytesPerSector,
                        PartitionInfo.PartitionLength.QuadPart / Geometry.BytesPerSector,
                        PartitionClass,
                        Flags,
                        &Geometry,
                        Type
                        );
        }
    }

    if(NtPartitionPath) {
        NtClose(DeviceHandle);
    }
    return(Status);
}



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ptypes16.h ===
/*****************************************************************************\
* Copyright (C) Microsoft Corporation, 1990-1999
* PTYPES16.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides typedefs for portable 16/32 bit code.
\*****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

/* TEMPORARY FIXES: */

#ifndef CCHDEVICENAME
#include <drivinit.h>
#endif

#define ERROR_GETADDR_FAILED     0x8001
#define ERROR_ALLOCATION_FAILURE 0x8002

#define INITWINDOWS()

/* TYPES: */

#ifndef WIN31

typedef  unsigned int   UINT           ;
typedef  WORD           WPARAM         ;
typedef  LONG           LPARAM         ;
typedef  int            HFILE          ;
typedef  HANDLE         HINSTANCE      ;
typedef  HANDLE         HMODULE        ;

#endif /* !WIN31 */

typedef  int            INT            ;
typedef  signed char    SCHAR          ;
typedef  WORD           WORD2DWORD     ;
typedef  char           TCHAR          ;
typedef  char           CHARPARM       ;
typedef  char           CHAR           ;
typedef  int            SHORTPARM      ;
typedef  int            SHORT          ;
typedef  WORD           VERSION        ;
typedef  HANDLE         HMETAFILE      ;
typedef  WORD           PDLLMEM        ;
typedef  char           CHAR2ULONG     ;
typedef  unsigned short USHORT2ULONG   ;
typedef  short          SHORT2ULONG    ;
typedef  int            INT2DWORD      ;
typedef  int            INT2WORD       ;
typedef  char           BYTE2WORD      ;
typedef  POINT          MPOINT         ;

#define  WNDPROC        FARPROC
#define  PROC           FARPROC
#define  APIENTRY       FAR PASCAL
#define  HUGE_T         huge

#define HFILE2INT(h, flags)     (INT)(h)
#define INT2HFILE(i)            (HFILE)(i)
#define DUPHFILE(h)             (HFILE)dup((INT)(h))
#define MGLOBALPTR(p)           HIWORD((LONG)p)

/* PRAGMAS */

#define _LOADDS _loadds
#define _EXPORT _export
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\port1632.h ===
/***************************************************************************\
* Module Name: 1632PORT.H
*
* Copyright (c) 1985-1999, Microsoft Corporation
*
* Master include file for Portable Windows applications.
*
* History:
*  sanfords    1/10/91        Created
*
\***************************************************************************/

/*
 * This file maps a Meta-API for Windows to specific 16-bit or 32-bit forms
 * allowing a single portable C source for windows to work on multiple
 * versions of Windows.
 */

#ifndef _PORT1632_
#define _PORT1632_

#if _MSC_VER > 1000
#pragma once
#endif

#if defined(WIN16)
/* ---------------- Maps to windows 3.0 and 3.1 16-bit APIs ----------------*/
#include "ptypes16.h"
#include "pwin16.h"
#include "plan16.h"
/* -------------------------------------------------------------------------*/

#elif defined(WIN32)
/* ---------------- Maps to windows 3.2 and 4.0 32-bit APIs ----------------*/
#include "ptypes32.h"
#include "pcrt32.h"
#include "pwin32.h"
#include "plan32.h"
/* -------------------------------------------------------------------------*/
#else
#error You must define either WIN32 or WIN16
#endif /* WIN32 or WIN16 */
#endif /* ndef _PORT1632_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\pdh.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PDH.H

Abstract:

    Header file for the Performance Data Helper (PDH) DLL functions.

--*/
#ifndef _PDH_H_
#define _PDH_H_

#if _MSC_VER > 1000
#pragma once
#endif

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4201)

// system include files required for datatype and constant definitions
#include <windows.h>    // necessary for data types used in this file
#include <winperf.h>    // necessary for the Detail Level definitions

#ifdef __cplusplus
extern "C" {
#endif

typedef LONG            PDH_STATUS;

#define PDH_FUNCTION    PDH_STATUS __stdcall

// version info
#define PDH_CVERSION_WIN40  ((DWORD)(0x0400))
#define PDH_CVERSION_WIN50  ((DWORD)(0x0500))
// v1.1 revision of PDH -- basic log functions
// v1.2 of the PDH -- adds variable instance counters
// v1.3 of the PDH -- adds log service control & stubs for NT5/PDH v2 fn's
// v2.0 of the PDH -- is the NT v 5.0 B2 version
#define PDH_VERSION         ((DWORD)((PDH_CVERSION_WIN50) + 0x0003))

// define severity masks
#define IsSuccessSeverity(ErrorCode)    \
    ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x00000000L) ? TRUE : FALSE)
#define IsInformationalSeverity(ErrorCode)    \
    ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x40000000L) ? TRUE : FALSE)
#define IsWarningSeverity(ErrorCode)    \
    ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x80000000L) ? TRUE : FALSE)
#define IsErrorSeverity(ErrorCode)      \
    ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0xC0000000L) ? TRUE : FALSE)

#define MAX_COUNTER_PATH    256         // Maximum counter path length

// data type definitions

typedef HANDLE  HCOUNTER;
typedef HANDLE  HQUERY;
typedef HANDLE  HLOG;

#ifdef INVALID_HANDLE_VALUE
#undef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE  ((HANDLE)((LONG_PTR)-1))
#endif

#define H_REALTIME_DATASOURCE NULL
#define H_WBEM_DATASOURCE     INVALID_HANDLE_VALUE


typedef struct _PDH_RAW_COUNTER {
    DWORD       CStatus;
    FILETIME    TimeStamp;
    LONGLONG    FirstValue;
    LONGLONG    SecondValue;
    DWORD       MultiCount;
} PDH_RAW_COUNTER, *PPDH_RAW_COUNTER;

typedef struct _PDH_RAW_COUNTER_ITEM_A {
    LPSTR           szName;
    PDH_RAW_COUNTER RawValue;
} PDH_RAW_COUNTER_ITEM_A, *PPDH_RAW_COUNTER_ITEM_A;

typedef struct _PDH_RAW_COUNTER_ITEM_W {
    LPWSTR          szName;
    PDH_RAW_COUNTER RawValue;
} PDH_RAW_COUNTER_ITEM_W, *PPDH_RAW_COUNTER_ITEM_W;

typedef struct _PDH_FMT_COUNTERVALUE {
    DWORD    CStatus;
    union {
        LONG        longValue;
        double      doubleValue;
        LONGLONG    largeValue;
        LPCSTR      AnsiStringValue;
        LPCWSTR     WideStringValue;
    };
} PDH_FMT_COUNTERVALUE, *PPDH_FMT_COUNTERVALUE;

typedef struct _PDH_FMT_COUNTERVALUE_ITEM_A {
    LPSTR                   szName;
    PDH_FMT_COUNTERVALUE    FmtValue;
} PDH_FMT_COUNTERVALUE_ITEM_A, *PPDH_FMT_COUNTERVALUE_ITEM_A;

typedef struct _PDH_FMT_COUNTERVALUE_ITEM_W {
    LPWSTR                  szName;
    PDH_FMT_COUNTERVALUE    FmtValue;
} PDH_FMT_COUNTERVALUE_ITEM_W, *PPDH_FMT_COUNTERVALUE_ITEM_W;

typedef struct _PDH_STATISTICS {
    DWORD                   dwFormat;
    DWORD                   count;
    PDH_FMT_COUNTERVALUE    min;
    PDH_FMT_COUNTERVALUE    max;
    PDH_FMT_COUNTERVALUE    mean;
} PDH_STATISTICS, *PPDH_STATISTICS;

typedef struct _PDH_COUNTER_PATH_ELEMENTS_A {
    LPSTR   szMachineName;
    LPSTR   szObjectName;
    LPSTR   szInstanceName;
    LPSTR   szParentInstance;
    DWORD   dwInstanceIndex;
    LPSTR   szCounterName;
} PDH_COUNTER_PATH_ELEMENTS_A, *PPDH_COUNTER_PATH_ELEMENTS_A;

typedef struct _PDH_COUNTER_PATH_ELEMENTS_W {
    LPWSTR  szMachineName;
    LPWSTR  szObjectName;
    LPWSTR  szInstanceName;
    LPWSTR  szParentInstance;
    DWORD   dwInstanceIndex;
    LPWSTR  szCounterName;
} PDH_COUNTER_PATH_ELEMENTS_W, *PPDH_COUNTER_PATH_ELEMENTS_W;

typedef struct _PDH_DATA_ITEM_PATH_ELEMENTS_A {
    LPSTR   szMachineName;
    GUID    ObjectGUID;
    DWORD   dwItemId;
    LPSTR   szInstanceName;
} PDH_DATA_ITEM_PATH_ELEMENTS_A, * PPDH_DATA_ITEM_PATH_ELEMENTS_A;

typedef struct _PDH_DATA_ITEM_PATH_ELEMENTS_W {
    LPWSTR  szMachineName;
    GUID    ObjectGUID;
    DWORD   dwItemId;
    LPWSTR  szInstanceName;
} PDH_DATA_ITEM_PATH_ELEMENTS_W, * PPDH_DATA_ITEM_PATH_ELEMENTS_W;

typedef struct _PDH_COUNTER_INFO_A {
    DWORD   dwLength;
    DWORD   dwType;
    DWORD   CVersion;
    DWORD   CStatus;
    LONG    lScale;
    LONG    lDefaultScale;
    DWORD_PTR   dwUserData;
    DWORD_PTR   dwQueryUserData;
    LPSTR   szFullPath;
    union   {
        PDH_DATA_ITEM_PATH_ELEMENTS_A DataItemPath;
        PDH_COUNTER_PATH_ELEMENTS_A CounterPath;
        struct {
            LPSTR   szMachineName;
            LPSTR   szObjectName;
            LPSTR   szInstanceName;
            LPSTR   szParentInstance;
            DWORD   dwInstanceIndex;
            LPSTR   szCounterName;
        };
    };
    LPSTR   szExplainText;
    DWORD   DataBuffer[1];
} PDH_COUNTER_INFO_A, *PPDH_COUNTER_INFO_A;

typedef struct _PDH_COUNTER_INFO_W {
    DWORD   dwLength;
    DWORD   dwType;
    DWORD   CVersion;
    DWORD   CStatus;
    LONG    lScale;
    LONG    lDefaultScale;
    DWORD_PTR   dwUserData;
    DWORD_PTR   dwQueryUserData;
    LPWSTR  szFullPath;
    union   {
        PDH_DATA_ITEM_PATH_ELEMENTS_W DataItemPath;
        PDH_COUNTER_PATH_ELEMENTS_W CounterPath;
        struct {
            LPWSTR   szMachineName;
            LPWSTR   szObjectName;
            LPWSTR   szInstanceName;
            LPWSTR   szParentInstance;
            DWORD    dwInstanceIndex;
            LPWSTR   szCounterName;
        };
    };
    LPWSTR  szExplainText;
    DWORD   DataBuffer[1];
} PDH_COUNTER_INFO_W, *PPDH_COUNTER_INFO_W;

typedef struct _PDH_TIME_INFO {
    LONGLONG    StartTime;
    LONGLONG    EndTime;
    DWORD       SampleCount;
} PDH_TIME_INFO, *PPDH_TIME_INFO;

typedef struct _PDH_RAW_LOG_RECORD {
    DWORD       dwStructureSize;
    DWORD       dwRecordType;
    DWORD       dwItems;
    UCHAR       RawBytes[1];
} PDH_RAW_LOG_RECORD, *PPDH_RAW_LOG_RECORD;

typedef struct _PDH_LOG_SERVICE_QUERY_INFO_A {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwLogQuota;
    LPSTR   szLogFileCaption;
    LPSTR   szDefaultDir;
    LPSTR   szBaseFileName;
    DWORD   dwFileType;
    DWORD   dwReserved;
    union {
        struct {
            DWORD   PdlAutoNameInterval;
            DWORD   PdlAutoNameUnits;
            LPSTR   PdlCommandFilename;
            LPSTR   PdlCounterList;
            DWORD   PdlAutoNameFormat;
            DWORD   PdlSampleInterval;
            FILETIME    PdlLogStartTime;
            FILETIME    PdlLogEndTime;
        };
        struct {
            DWORD   TlNumberOfBuffers;
            DWORD   TlMinimumBuffers;
            DWORD   TlMaximumBuffers;
            DWORD   TlFreeBuffers;
            DWORD   TlBufferSize;
            DWORD   TlEventsLost;
            DWORD   TlLoggerThreadId;
            DWORD   TlBuffersWritten;
            DWORD   TlLogHandle;
            LPSTR   TlLogFileName;
        };
    };
} PDH_LOG_SERVICE_QUERY_INFO_A, *PPDH_LOG_SERVICE_QUERY_INFO_A;

typedef struct _PDH_LOG_SERVICE_QUERY_INFO_W {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwLogQuota;
    LPWSTR  szLogFileCaption;
    LPWSTR  szDefaultDir;
    LPWSTR  szBaseFileName;
    DWORD   dwFileType;
    DWORD   dwReserved;
    union {
        struct {
            DWORD   PdlAutoNameInterval;
            DWORD   PdlAutoNameUnits;
            LPWSTR  PdlCommandFilename;
            LPWSTR  PdlCounterList;
            DWORD   PdlAutoNameFormat;
            DWORD   PdlSampleInterval;
            FILETIME    PdlLogStartTime;
            FILETIME    PdlLogEndTime;
        };
        struct {
            DWORD   TlNumberOfBuffers;
            DWORD   TlMinimumBuffers;
            DWORD   TlMaximumBuffers;
            DWORD   TlFreeBuffers;
            DWORD   TlBufferSize;
            DWORD   TlEventsLost;
            DWORD   TlLoggerThreadId;
            DWORD   TlBuffersWritten;
            DWORD   TlLogHandle;
            LPWSTR  TlLogFileName;
        };
    };
} PDH_LOG_SERVICE_QUERY_INFO_W, *PPDH_LOG_SERVICE_QUERY_INFO_W;

//
//  Time value constants
//
#define MAX_TIME_VALUE      ((LONGLONG)0x7FFFFFFFFFFFFFFF)
#define MIN_TIME_VALUE      ((LONGLONG)0)

// function definitions

PDH_FUNCTION
PdhGetDllVersion(
    IN  LPDWORD lpdwVersion
);

//
//  Query Functions
//

PDH_FUNCTION
PdhOpenQueryW (
    IN      LPCWSTR     szDataSource,
    IN      DWORD_PTR   dwUserData,
    IN      HQUERY      *phQuery
);

PDH_FUNCTION
PdhOpenQueryA (
    IN      LPCSTR      szDataSource,
    IN      DWORD_PTR   dwUserData,
    IN      HQUERY      *phQuery
);

PDH_FUNCTION
PdhAddCounterW (
    IN      HQUERY      hQuery,
    IN      LPCWSTR     szFullCounterPath,
    IN      DWORD_PTR   dwUserData,
    IN      HCOUNTER    *phCounter
);

PDH_FUNCTION
PdhAddCounterA (
    IN      HQUERY      hQuery,
    IN      LPCSTR      szFullCounterPath,
    IN      DWORD_PTR   dwUserData,
    IN      HCOUNTER    *phCounter
);

PDH_FUNCTION
PdhRemoveCounter (
    IN      HCOUNTER    hCounter
);

PDH_FUNCTION
PdhCollectQueryData (
    IN      HQUERY      hQuery
);

PDH_FUNCTION
PdhCloseQuery (
    IN      HQUERY      hQuery
);

//
//  Counter Functions
//

PDH_FUNCTION
PdhGetFormattedCounterValue (
    IN      HCOUNTER                hCounter,
    IN      DWORD                   dwFormat,
    IN      LPDWORD                 lpdwType,
    IN      PPDH_FMT_COUNTERVALUE   pValue
);

PDH_FUNCTION
PdhGetFormattedCounterArrayA (
    IN      HCOUNTER                hCounter,
    IN      DWORD                   dwFormat,
    IN      LPDWORD                 lpdwBufferSize,
    IN      LPDWORD                 lpdwItemCount,
    IN      PPDH_FMT_COUNTERVALUE_ITEM_A    ItemBuffer
);

PDH_FUNCTION
PdhGetFormattedCounterArrayW (
    IN      HCOUNTER                hCounter,
    IN      DWORD                   dwFormat,
    IN      LPDWORD                 lpdwBufferSize,
    IN      LPDWORD                 lpdwItemCount,
    IN      PPDH_FMT_COUNTERVALUE_ITEM_W    ItemBuffer
);


// dwFormat flag values
//
#define PDH_FMT_RAW     ((DWORD)0x00000010)
#define PDH_FMT_ANSI    ((DWORD)0x00000020)
#define PDH_FMT_UNICODE ((DWORD)0x00000040)
#define PDH_FMT_LONG    ((DWORD)0x00000100)
#define PDH_FMT_DOUBLE  ((DWORD)0x00000200)
#define PDH_FMT_LARGE   ((DWORD)0x00000400)
#define PDH_FMT_NOSCALE ((DWORD)0x00001000)
#define PDH_FMT_1000    ((DWORD)0x00002000)
#define PDH_FMT_NODATA  ((DWORD)0x00004000)
#define PDH_FMT_NOCAP100 ((DWORD)0x00008000)

#define PERF_DETAIL_COSTLY   ((DWORD)0x00010000)
#define PERF_DETAIL_STANDARD ((DWORD)0x0000FFFF)

PDH_FUNCTION
PdhGetRawCounterValue (
    IN      HCOUNTER            hCounter,
    IN      LPDWORD             lpdwType,
    IN      PPDH_RAW_COUNTER    pValue
);

PDH_FUNCTION
PdhGetRawCounterArrayA (
    IN      HCOUNTER                hCounter,
    IN      LPDWORD                 lpdwBufferSize,
    IN      LPDWORD                 lpdwItemCount,
    IN      PPDH_RAW_COUNTER_ITEM_A ItemBuffer
);

PDH_FUNCTION
PdhGetRawCounterArrayW (
    IN      HCOUNTER                hCounter,
    IN      LPDWORD                 lpdwBufferSize,
    IN      LPDWORD                 lpdwItemCount,
    IN      PPDH_RAW_COUNTER_ITEM_W ItemBuffer
);

PDH_FUNCTION
PdhCalculateCounterFromRawValue (
    IN      HCOUNTER                hCounter,
    IN      DWORD                   dwFormat,
    IN      PPDH_RAW_COUNTER        rawValue1,
    IN      PPDH_RAW_COUNTER        rawValue2,
    IN      PPDH_FMT_COUNTERVALUE   fmtValue
);

PDH_FUNCTION
PdhComputeCounterStatistics (
    IN      HCOUNTER            hCounter,
    IN      DWORD               dwFormat,
    IN      DWORD               dwFirstEntry,
    IN      DWORD               dwNumEntries,
    IN      PPDH_RAW_COUNTER    lpRawValueArray,
    IN      PPDH_STATISTICS     data
);

PDH_FUNCTION
PdhGetCounterInfoW (
    IN      HCOUNTER            hCounter,
    IN      BOOLEAN             bRetrieveExplainText,
    IN      LPDWORD             pdwBufferSize,
    IN      PPDH_COUNTER_INFO_W lpBuffer
);

PDH_FUNCTION
PdhGetCounterInfoA (
    IN      HCOUNTER            hCounter,
    IN      BOOLEAN             bRetrieveExplainText,
    IN      LPDWORD             pdwBufferSize,
    IN      PPDH_COUNTER_INFO_A lpBuffer
);

#define PDH_MAX_SCALE    (7L)
#define PDH_MIN_SCALE   (-7L)

PDH_FUNCTION
PdhSetCounterScaleFactor (
    IN      HCOUNTER    hCounter,
    IN      LONG        lFactor
);
//
//   Browsing and enumeration functions
//
PDH_FUNCTION
PdhConnectMachineW (
    IN      LPCWSTR  szMachineName
);

PDH_FUNCTION
PdhConnectMachineA (
    IN      LPCSTR  szMachineName
);

PDH_FUNCTION
PdhEnumMachinesW (
    IN      LPCWSTR szDataSource,
    IN      LPWSTR  mszMachineList,
    IN      LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhEnumMachinesA (
    IN      LPCSTR   szDataSource,
    IN      LPSTR    mszMachineList,
    IN      LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhEnumObjectsW (
    IN      LPCWSTR szDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPWSTR  mszObjectList,
    IN      LPDWORD pcchBufferSize,
    IN      DWORD   dwDetailLevel,
    IN      BOOL    bRefresh
);

PDH_FUNCTION
PdhEnumObjectsA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szMachineName,
    IN      LPSTR   mszObjectList,
    IN      LPDWORD pcchBufferSize,
    IN      DWORD   dwDetailLevel,
    IN      BOOL    bRefresh
);

PDH_FUNCTION
PdhEnumObjectItemsW (
    IN      LPCWSTR szDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPCWSTR szObjectName,
    IN      LPWSTR  mszCounterList,
    IN      LPDWORD pcchCounterListLength,
    IN      LPWSTR  mszInstanceList,
    IN      LPDWORD pcchInstanceListLength,
    IN      DWORD   dwDetailLevel,
    IN      DWORD   dwFlags
);

PDH_FUNCTION
PdhEnumObjectItemsA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szMachineName,
    IN      LPCSTR  szObjectName,
    IN      LPSTR   mszCounterList,
    IN      LPDWORD pcchCounterListLength,
    IN      LPSTR   mszInstanceList,
    IN      LPDWORD pcchInstanceListLength,
    IN      DWORD   dwDetailLevel,
    IN      DWORD   dwFlags
);

#define PDH_OBJECT_HAS_INSTANCES    ((DWORD) 0x00000001)

PDH_FUNCTION
PdhObjectHasInstancesW (
    IN      LPCWSTR szDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPCWSTR szObjectName,
    IN OUT  LPDWORD pdwFlags
);

PDH_FUNCTION
PdhObjectHasInstancesA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szMachineName,
    IN      LPCSTR  szObjectName,
    IN OUT  LPDWORD pdwFlags
);

PDH_FUNCTION
PdhMakeCounterPathW (
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements,
    IN      LPWSTR                      szFullPathBuffer,
    IN      LPDWORD                     pcchBufferSize,
    IN      DWORD                       dwFlags
);

PDH_FUNCTION
PdhMakeCounterPathA (
    IN      PDH_COUNTER_PATH_ELEMENTS_A *pCounterPathElements,
    IN      LPSTR                       szFullPathBuffer,
    IN      LPDWORD                     pcchBufferSize,
    IN      DWORD                       dwFlags
);

PDH_FUNCTION
PdhParseCounterPathW (
    IN      LPCWSTR                     szFullPathBuffer,
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements,
    IN      LPDWORD                     pdwBufferSize,
    IN      DWORD                       dwFlags
);

PDH_FUNCTION
PdhParseCounterPathA (
    IN      LPCSTR                      szFullPathBuffer,
    IN      PDH_COUNTER_PATH_ELEMENTS_A *pCounterPathElements,
    IN      LPDWORD                     pdwBufferSize,
    IN      DWORD                       dwFlags
);

#define PDH_PATH_WBEM_RESULT        ((DWORD)0x00000001)
#define PDH_PATH_WBEM_INPUT         ((DWORD)0x00000002)

#define PDH_PATH_LANG_FLAGS(LangId, Flags)  ((DWORD)(((LangId & 0x0000FFFF) << 16) | (Flags & 0x0000FFFF)))

PDH_FUNCTION
PdhParseInstanceNameW (
    IN      LPCWSTR szInstanceString,
    IN      LPWSTR  szInstanceName,
    IN      LPDWORD pcchInstanceNameLength,
    IN      LPWSTR  szParentName,
    IN      LPDWORD pcchParentNameLength,
    IN      LPDWORD lpIndex
);

PDH_FUNCTION
PdhParseInstanceNameA (
    IN      LPCSTR  szInstanceString,
    IN      LPSTR   szInstanceName,
    IN      LPDWORD pcchInstanceNameLength,
    IN      LPSTR   szParentName,
    IN      LPDWORD pcchParentNameLength,
    IN      LPDWORD lpIndex
);

PDH_FUNCTION
PdhValidatePathW (
    IN      LPCWSTR szFullPathBuffer
);

PDH_FUNCTION
PdhValidatePathA (
    IN      LPCSTR  szFullPathBuffer
);

PDH_FUNCTION
PdhGetDefaultPerfObjectW (
    IN      LPCWSTR szDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPWSTR  szDefaultObjectName,
    IN      LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfObjectA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szMachineName,
    IN      LPSTR   szDefaultObjectName,
    IN      LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterW (
    IN      LPCWSTR szDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPCWSTR szObjectName,
    IN      LPWSTR  szDefaultCounterName,
    IN      LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szMachineName,
    IN      LPCSTR  szObjectName,
    IN      LPSTR   szDefaultCounterName,
    IN      LPDWORD pcchBufferSize
);

typedef PDH_STATUS (__stdcall *CounterPathCallBack)(DWORD_PTR);

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4214 )  // Disable warning messages
typedef struct _BrowseDlgConfig_HW {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    HLOG                hDataSource;
    LPWSTR              szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPWSTR              szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_HW, *PPDH_BROWSE_DLG_CONFIG_HW;

typedef struct _BrowseDlgConfig_HA {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    HLOG                hDataSource;
    LPSTR               szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPSTR               szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_HA, *PPDH_BROWSE_DLG_CONFIG_HA;

typedef struct _BrowseDlgConfig_W {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    LPWSTR              szDataSource;
    LPWSTR              szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPWSTR              szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_W, *PPDH_BROWSE_DLG_CONFIG_W;

typedef struct _BrowseDlgConfig_A {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    LPSTR               szDataSource;
    LPSTR               szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPSTR               szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_A, *PPDH_BROWSE_DLG_CONFIG_A;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning ( default : 4214 )
#endif

PDH_FUNCTION
PdhBrowseCountersW (
    IN      PPDH_BROWSE_DLG_CONFIG_W    pBrowseDlgData
);

PDH_FUNCTION
PdhBrowseCountersA (
    IN      PPDH_BROWSE_DLG_CONFIG_A    pBrowseDlgData
);

PDH_FUNCTION
PdhExpandCounterPathW (
    IN      LPCWSTR     szWildCardPath,
    IN      LPWSTR      mszExpandedPathList,
    IN      LPDWORD     pcchPathListLength
);

PDH_FUNCTION
PdhExpandCounterPathA (
    IN      LPCSTR      szWildCardPath,
    IN      LPSTR       mszExpandedPathList,
    IN      LPDWORD     pcchPathListLength
);

//
//  v2.0 functions
//
PDH_FUNCTION
PdhLookupPerfNameByIndexW (
    LPCWSTR szMachineName,
    DWORD   dwNameIndex,
    LPWSTR  szNameBuffer,
    LPDWORD pcchNameBufferSize
);

PDH_FUNCTION
PdhLookupPerfNameByIndexA (
    LPCSTR  szMachineName,
    DWORD   dwNameIndex,
    LPSTR   szNameBuffer,
    LPDWORD pcchNameBufferSize
);

PDH_FUNCTION
PdhLookupPerfIndexByNameW (
    LPCWSTR szMachineName,
    LPCWSTR szNameBuffer,
    LPDWORD pdwIndex
);

PDH_FUNCTION
PdhLookupPerfIndexByNameA (
    LPCSTR  szMachineName,
    LPCSTR  szNameBuffer,
    LPDWORD pdwIndex
);

#define     PDH_NOEXPANDCOUNTERS    1
#define     PDH_NOEXPANDINSTANCES   2

PDH_FUNCTION
PdhExpandWildCardPathA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szWildCardPath,
    IN      LPSTR   mszExpandedPathList,
    IN      LPDWORD pcchPathListLength,
    IN      DWORD   dwFlags
);

PDH_FUNCTION
PdhExpandWildCardPathW (
    IN      LPCWSTR  szDataSource,
    IN      LPCWSTR  szWildCardPath,
    IN      LPWSTR  mszExpandedPathList,
    IN      LPDWORD pcchPathListLength,
    IN      DWORD   dwFlags
);

//
//   Logging Functions
//

#define PDH_LOG_READ_ACCESS     ((DWORD)0x00010000)
#define PDH_LOG_WRITE_ACCESS    ((DWORD)0x00020000)
#define PDH_LOG_UPDATE_ACCESS   ((DWORD)0x00040000)
#define PDH_LOG_ACCESS_MASK     ((DWORD)0x000F0000)

#define PDH_LOG_CREATE_NEW      ((DWORD)0x00000001)
#define PDH_LOG_CREATE_ALWAYS   ((DWORD)0x00000002)
#define PDH_LOG_OPEN_ALWAYS     ((DWORD)0x00000003)
#define PDH_LOG_OPEN_EXISTING   ((DWORD)0x00000004)
#define PDH_LOG_CREATE_MASK     ((DWORD)0x0000000F)

#define PDH_LOG_OPT_USER_STRING  ((DWORD)0x01000000)
#define PDH_LOG_OPT_CIRCULAR     ((DWORD)0x02000000)
#define PDH_LOG_OPT_MAX_IS_BYTES ((DWORD)0x04000000)
#define PDH_LOG_OPT_APPEND       ((DWORD)0x08000000)
#define PDH_LOG_OPT_MASK         ((DWORD)0x0F000000)

#define PDH_LOG_TYPE_UNDEFINED      0
#define PDH_LOG_TYPE_CSV            1
#define PDH_LOG_TYPE_TSV            2
//#define PDH_LOG_TYPE_BINARY         3 // this is the retired binary format
#define PDH_LOG_TYPE_TRACE_KERNEL   4
#define PDH_LOG_TYPE_TRACE_GENERIC  5
#define PDH_LOG_TYPE_PERFMON        6
#define PDH_LOG_TYPE_SQL            7
#define PDH_LOG_TYPE_BINARY         8

PDH_FUNCTION
PdhOpenLogW (
    IN      LPCWSTR szLogFileName,
    IN      DWORD   dwAccessFlags,
    IN      LPDWORD lpdwLogType,
    IN      HQUERY  hQuery,
    IN      DWORD   dwMaxSize,
    IN      LPCWSTR szUserCaption,
    IN      HLOG    *phLog
);

PDH_FUNCTION
PdhOpenLogA (
    IN      LPCSTR  szLogFileName,
    IN      DWORD   dwAccessFlags,
    IN      LPDWORD lpdwLogType,
    IN      HQUERY  hQuery,
    IN      DWORD   dwMaxSize,
    IN      LPCSTR  szUserCaption,
    IN      HLOG    *phLog
);

PDH_FUNCTION
PdhUpdateLogW (
    IN      HLOG    hLog,
    IN      LPCWSTR szUserString
);

PDH_FUNCTION
PdhUpdateLogA (
    IN      HLOG    hLog,
    IN      LPCSTR  szUserString
);

PDH_FUNCTION
PdhUpdateLogFileCatalog (
    IN      HLOG    hLog
);

PDH_FUNCTION
PdhGetLogFileSize (
    IN  HLOG        hLog,
    IN  LONGLONG    *llSize
);

PDH_FUNCTION
PdhCloseLog(
    IN  HLOG        hLog,
    IN  DWORD       dwFlags
);

#define PDH_FLAGS_CLOSE_QUERY   ((DWORD)0x00000001)
//
//  Data source selection dialog
//
#define PDH_FLAGS_FILE_BROWSER_ONLY ((DWORD)0x00000001)

PDH_FUNCTION
PdhSelectDataSourceW (
    IN  HWND    hWndOwner,
    IN  DWORD   dwFlags,
    IN  LPWSTR  szDataSource,
    IN  LPDWORD pcchBufferLength
);

PDH_FUNCTION
PdhSelectDataSourceA (
    IN  HWND    hWndOwner,
    IN  DWORD   dwFlags,
    IN  LPSTR   szDataSource,
    IN  LPDWORD pcchBufferLength
);

BOOL
PdhIsRealTimeQuery (
    IN  HQUERY  hQuery
);

PDH_FUNCTION
PdhSetQueryTimeRange (
    IN      HQUERY          hQuery,
    IN      PPDH_TIME_INFO  pInfo
);

PDH_FUNCTION
PdhGetDataSourceTimeRangeW (
    IN      LPCWSTR         szDataSource,
    IN      LPDWORD         pdwNumEntries,
    IN      PPDH_TIME_INFO  pInfo,
    IN      LPDWORD         pdwBufferSize
);

PDH_FUNCTION
PdhGetDataSourceTimeRangeA (
    IN      LPCSTR          szDataSource,
    IN      LPDWORD         pdwNumEntries,
    IN      PPDH_TIME_INFO  pInfo,
    IN      LPDWORD         dwBufferSize
);

PDH_FUNCTION
PdhCollectQueryDataEx (
    IN      HQUERY      hQuery,
    IN      DWORD       dwIntervalTime,
    IN      HANDLE      hNewDataEvent
);

PDH_FUNCTION
PdhFormatFromRawValue (
    IN      DWORD               dwCounterType,
    IN      DWORD               dwFormat,
    IN      LONGLONG            *pTimeBase,
    IN      PPDH_RAW_COUNTER    pRawValue1,
    IN      PPDH_RAW_COUNTER    pRawValue2,
    IN      PPDH_FMT_COUNTERVALUE   pFmtValue
);

PDH_FUNCTION
PdhGetCounterTimeBase (
    IN  HCOUNTER    hCounter,
    IN  LONGLONG    *pTimeBase
);

PDH_FUNCTION
PdhReadRawLogRecord (
    IN  HLOG                    hLog,
    IN  FILETIME                ftRecord,
    IN  PPDH_RAW_LOG_RECORD     pRawLogRecord,
    IN  LPDWORD                 pdwBufferLength
);


#define DATA_SOURCE_REGISTRY    ((DWORD)0x00000001)
#define DATA_SOURCE_LOGFILE     ((DWORD)0x00000002)
#define DATA_SOURCE_WBEM        ((DWORD)0x00000004)

PDH_FUNCTION
PdhSetDefaultRealTimeDataSource (
    IN  DWORD   dwDataSourceId
);

// flags for the log service api's
#define PDH_LOGSVC_NO_WAIT          ((DWORD)0x80000000)
#define PDH_LOGSVC_ALL_QUERIES      ((DWORD)0x00000001)
#define PDH_LOGSVC_TRACE_LOG        ((DWORD)0x00000002)

#define PDH_LOGSVC_CMD_START        ((DWORD)0x00000010)
#define PDH_LOGSVC_CMD_STOP         ((DWORD)0x00000020)

#define PDH_LOGSVC_CTRL_ADD         ((DWORD)0x00000100)
#define PDH_LOGSVC_CTRL_REMOVE      ((DWORD)0x00000200)
#define PDH_LOGSVC_CTRL_INFO        ((DWORD)0x00000400)

#define PDH_LOGSVC_STATUS_RUNNING   ((DWORD)0x00001000)
#define PDH_LOGSVC_STATUS_STOPPED   ((DWORD)0x00002000)
#define PDH_LOGSVC_STATUS_PAUSED    ((DWORD)0x00004000)
#define PDH_LOGSVC_STATUS_ERROR     ((DWORD)0x00008000)
#define PDH_LOGSVC_STATUS_PENDING   ((DWORD)0x00010000)

#define PDH_LOGSVC_NAME_UNDEFINED  ((DWORD)-1)
#define PDH_LOGSVC_NAME_MMDDHH     ((DWORD)0)
#define PDH_LOGSVC_NAME_NNNNNN     ((DWORD)1)
#define PDH_LOGSVC_NAME_YYDDD      ((DWORD)2)
#define PDH_LOGSVC_NAME_YYMM       ((DWORD)3)
#define PDH_LOGSVC_NAME_YYMMDD     ((DWORD)4)
#define PDH_LOGSVC_NAME_YYMMDDHH   ((DWORD)5)

#define PDH_LOGSVC_RENAME_UNDEFINED ((DWORD)-1)
#define PDH_LOGSVC_RENAME_HOURS    ((DWORD)0)
#define PDH_LOGSVC_RENAME_DAYS     ((DWORD)1)
#define PDH_LOGSVC_RENAME_MONTHS   ((DWORD)2)
#define PDH_LOGSVC_RENAME_KBYTES   ((DWORD)3)
#define PDH_LOGSVC_RENAME_MBYTES   ((DWORD)4)

PDH_FUNCTION
PdhLogServiceCommandA (
    IN  LPCSTR          szMachineName,
    IN  LPCSTR          szQueryName,
    IN  DWORD           dwFlags,
    IN  LPDWORD         pdwStatus
);

PDH_FUNCTION
PdhLogServiceCommandW (
    IN  LPCWSTR         szMachineName,
    IN  LPCWSTR         szQueryName,
    IN  DWORD           dwFlags,
    IN  LPDWORD         pdwStatus
);

PDH_FUNCTION
PdhLogServiceControlA (
    IN  LPCSTR          szMachineName,
    IN  LPCSTR          szQueryName,
    IN  DWORD           dwFlags,
    IN  PPDH_LOG_SERVICE_QUERY_INFO_A pInfoBuffer,
    IN  LPDWORD         pdwBufferSize
);

PDH_FUNCTION
PdhLogServiceControlW (
    IN  LPCWSTR         szMachineName,
    IN  LPCWSTR         szQueryName,
    IN  DWORD           dwFlags,
    IN  PPDH_LOG_SERVICE_QUERY_INFO_W pInfoBuffer,
    IN  LPDWORD         pdwBufferSize
);

// Extended API for WMI event trace logfile format
//
PDH_FUNCTION
PdhBindInputDataSourceW (
    IN HLOG    * phDataSource,
    IN LPCWSTR   LogFileNameList
);

PDH_FUNCTION
PdhBindInputDataSourceA (
    IN HLOG   * phDataSource,
    IN LPCSTR   LogFileNameList
);

PDH_FUNCTION
PdhOpenQueryH (
    IN HLOG        hDataSource,
    IN DWORD_PTR   dwUserData,
    IN HQUERY    * phQuery
);

PDH_FUNCTION
PdhEnumMachinesHW (
    IN HLOG        hDataSource,
    IN LPWSTR      mszMachineList,
    IN LPDWORD     pcchBufferSize
);

PDH_FUNCTION
PdhEnumMachinesHA (
    IN HLOG        hDataSource,
    IN LPSTR       mszMachineList,
    IN LPDWORD     pcchBufferSize
);

PDH_FUNCTION
PdhEnumObjectsHW (
    IN HLOG        hDataSource,
    IN LPCWSTR     szMachineName,
    IN LPWSTR      mszObjectList,
    IN LPDWORD     pcchBufferSize,
    IN DWORD       dwDetailLevel,
    IN BOOL        bRefresh
);

PDH_FUNCTION
PdhEnumObjectsHA (
    IN HLOG        hDataSource,
    IN LPCSTR      szMachineName,
    IN LPSTR       mszObjectList,
    IN LPDWORD     pcchBufferSize,
    IN DWORD       dwDetailLevel,
    IN BOOL        bRefresh
);

PDH_FUNCTION
PdhEnumObjectItemsHW (
    IN HLOG        hDataSource,
    IN LPCWSTR     szMachineName,
    IN LPCWSTR     szObjectName,
    IN LPWSTR      mszCounterList,
    IN LPDWORD     pcchCounterListLength,
    IN LPWSTR      mszInstanceList,
    IN LPDWORD     pcchInstanceListLength,
    IN DWORD       dwDetailLevel,
    IN DWORD       dwFlags
);

PDH_FUNCTION
PdhEnumObjectItemsHA (
    IN HLOG        hDataSource,
    IN LPCSTR      szMachineName,
    IN LPCSTR      szObjectName,
    IN LPSTR       mszCounterList,
    IN LPDWORD     pcchCounterListLength,
    IN LPSTR       mszInstanceList,
    IN LPDWORD     pcchInstanceListLength,
    IN DWORD       dwDetailLevel,
    IN DWORD       dwFlags
);

PDH_FUNCTION
PdhExpandWildCardPathHW (
    IN HLOG        hDataSource,
    IN LPCWSTR     szWildCardPath,
    IN LPWSTR      mszExpandedPathList,
    IN LPDWORD     pcchPathListLength,
    IN DWORD       dwFlags
);

PDH_FUNCTION
PdhExpandWildCardPathHA (
    IN HLOG        hDataSource,
    IN LPCSTR      szWildCardPath,
    IN LPSTR       mszExpandedPathList,
    IN LPDWORD     pcchPathListLength,
    IN DWORD       dwFlags
);

PDH_FUNCTION
PdhGetDataSourceTimeRangeH (
    IN HLOG            hDataSource,
    IN LPDWORD         pdwNumEntries,
    IN PPDH_TIME_INFO  pInfo,
    IN LPDWORD         pdwBufferSize
);

PDH_FUNCTION
PdhObjectHasInstancesHW (
    IN     HLOG    hDataSource,
    IN     LPCWSTR szMachineName,
    IN     LPCWSTR szObjectName,
    IN OUT LPDWORD pdwFlags
);

PDH_FUNCTION
PdhObjectHasInstancesHA (
    IN     HLOG    hDataSource,
    IN     LPCSTR  szMachineName,
    IN     LPCSTR  szObjectName,
    IN OUT LPDWORD pdwFlags
);

PDH_FUNCTION
PdhGetDefaultPerfObjectHW (
    IN HLOG    hDataSource,
    IN LPCWSTR szMachineName,
    IN LPWSTR  szDefaultObjectName,
    IN LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfObjectHA (
    IN HLOG    hDataSource,
    IN LPCSTR  szMachineName,
    IN LPSTR   szDefaultObjectName,
    IN LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterHW (
    IN HLOG    hDataSource,
    IN LPCWSTR szMachineName,
    IN LPCWSTR szObjectName,
    IN LPWSTR  szDefaultCounterName,
    IN LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterHA (
    IN HLOG    hDataSource,
    IN LPCSTR  szMachineName,
    IN LPCSTR  szObjectName,
    IN LPSTR   szDefaultCounterName,
    IN LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhBrowseCountersHW (
    IN PPDH_BROWSE_DLG_CONFIG_HW pBrowseDlgData
);

PDH_FUNCTION
PdhBrowseCountersHA (
    IN PPDH_BROWSE_DLG_CONFIG_HA pBrowseDlgData
);

//Check that a DSN points to a database that contains the correct Perfmon tables.
PDH_FUNCTION
PdhVerifySQLDBW (
	IN	LPCWSTR			szDataSource
);

PDH_FUNCTION
PdhVerifySQLDBA (
	IN	LPCSTR			szDataSource
);


//Create the correct perfmon tables in the database pointed to by a DSN.
PDH_FUNCTION
PdhCreateSQLTablesW (
	IN	LPCWSTR			szDataSource
);  

PDH_FUNCTION
PdhCreateSQLTablesA (
	IN	LPCSTR			szDataSource
);     

//Return the list of Log set names in the database pointed to by the DSN.
PDH_FUNCTION
PdhEnumLogSetNamesW (
	IN	LPCWSTR			szDataSource,
	IN	LPWSTR			mszDataSetNameList,
	IN	LPDWORD			pcchBufferLength
);

PDH_FUNCTION
PdhEnumLogSetNamesA (
	IN	LPCSTR			szDataSource,
	IN	LPSTR			mszDataSetNameList,
	IN	LPDWORD			pcchBufferLength
);

//Retrieve the GUID for an open Log Set
PDH_FUNCTION
PdhGetLogSetGUID (
	IN	HLOG			hLog,             
	IN	GUID			*pGuid,
	IN	int		        *pRunId
);

//Set the RunID for an open Log Set
PDH_FUNCTION
PdhSetLogSetRunID (
	IN	HLOG                    hLog,             
	IN	int                     RunId
);

PDH_FUNCTION
PdhListLogFileHeaderW (
    IN  LPCWSTR     szFileName,
    IN  LPWSTR      mszHeaderList,
    IN  LPDWORD     pcchHeaderListSize
);

PDH_FUNCTION
PdhListLogFileHeaderA (
    IN  LPCSTR     szFileName,
    IN  LPSTR      mszHeaderList,
    IN  LPDWORD     pcchHeaderListSize
);
//
//   Unicode/ANSI compatibility section
//
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE
#endif
#endif

#ifdef UNICODE
// start of UNICODE definitions
#define PdhOpenQuery                PdhOpenQueryW
#define PdhAddCounter               PdhAddCounterW
#define PdhGetCounterInfo           PdhGetCounterInfoW
#define PDH_COUNTER_INFO            PDH_COUNTER_INFO_W
#define PPDH_COUNTER_INFO           PPDH_COUNTER_INFO_W
#define PdhConnectMachine           PdhConnectMachineW
#define PdhEnumMachines             PdhEnumMachinesW
#define PdhEnumObjects              PdhEnumObjectsW
#define PdhEnumObjectItems          PdhEnumObjectItemsW
#define PdhMakeCounterPath          PdhMakeCounterPathW
#define PDH_COUNTER_PATH_ELEMENTS   PDH_COUNTER_PATH_ELEMENTS_W
#define PPDH_COUNTER_PATH_ELEMENTS  PPDH_COUNTER_PATH_ELEMENTS_W
#define PdhParseCounterPath         PdhParseCounterPathW
#define PdhParseInstanceName        PdhParseInstanceNameW
#define PdhValidatePath             PdhValidatePathW
#define PdhGetDefaultPerfObject     PdhGetDefaultPerfObjectW
#define PdhGetDefaultPerfCounter    PdhGetDefaultPerfCounterW
#define PdhBrowseCounters           PdhBrowseCountersW
#define PdhBrowseCountersH          PdhBrowseCountersHW
#define PDH_BROWSE_DLG_CONFIG       PDH_BROWSE_DLG_CONFIG_W
#define PPDH_BROWSE_DLG_CONFIG      PPDH_BROWSE_DLG_CONFIG_W
#define PDH_BROWSE_DLG_CONFIG_H     PDH_BROWSE_DLG_CONFIG_HW
#define PPDH_BROWSE_DLG_CONFIG_H    PPDH_BROWSE_DLG_CONFIG_HW
#define PdhExpandCounterPath        PdhExpandCounterPathW
// v2.0 functions
#define PDH_FMT_COUNTERVALUE_ITEM   PDH_FMT_COUNTERVALUE_ITEM_W
#define PPDH_FMT_COUNTERVALUE_ITEM  PPDH_FMT_COUNTERVALUE_ITEM_W
#define PDH_RAW_COUNTER_ITEM        PDH_RAW_COUNTER_ITEM_W
#define PPDH_RAW_COUNTER_ITEM       PPDH_RAW_COUNTER_ITEM_W
#define PdhGetFormattedCounterArray PdhGetFormattedCounterArrayW
#define PdhGetRawCounterArray       PdhGetRawCounterArrayW
#define PdhLookupPerfNameByIndex    PdhLookupPerfNameByIndexW
#define PdhLookupIndexByPerfName    PdhLookupIndexByPerfNameW
#define PdhOpenLog                  PdhOpenLogW
#define PdhUpdateLog                PdhUpdateLogW
#define PdhSelectDataSource         PdhSelectDataSourceW
#define PdhGetDataSourceTimeRange   PdhGetDataSourceTimeRangeW
#define PDH_LOG_SERVICE_QUERY_INFO  PDH_LOG_SERVICE_QUERY_INFO_W
#define PPDH_LOG_SERVICE_QUERY_INFO PPDH_LOG_SERVICE_QUERY_INFO_W
#define PdhLogServiceControl        PdhLogServiceControlW
#define PdhLogServiceQuery          PdhLogServiceQueryW
#define PdhExpandWildCardPath       PdhExpandWildCardPathW
#define PdhObjectHasInstances       PdhObjectHasInstancesW

#define PdhBindInputDataSource      PdhBindInputDataSourceW
#define PdhEnumMachinesH            PdhEnumMachinesHW
#define PdhEnumObjectsH             PdhEnumObjectsHW
#define PdhEnumObjectItemsH         PdhEnumObjectItemsHW
#define PdhExpandWildCardPathH      PdhExpandWildCardPathHW
#define PdhObjectHasInstancesH      PdhObjectHasInstancesHW
#define PdhGetDefaultPerfObjectH    PdhGetDefaultPerfObjectHW
#define PdhGetDefaultPerfCounterH   PdhGetDefaultPerfCounterHW
#define PdhEnumLogSetNames	    PdhEnumLogSetNamesW
#define PdhCreateSQLTables	    PdhCreateSQLTablesW
#define	PdhVerifySQLDB		    PdhVerifySQLDBW
#define PdhListLogFileHeader	    PdhListLogFileHeaderW

// end of UNICODE definitions
#else
// start of ANSI definitions
#define PdhOpenQuery                PdhOpenQueryA
#define PdhAddCounter               PdhAddCounterA
#define PdhGetCounterInfo           PdhGetCounterInfoA
#define PDH_COUNTER_INFO            PDH_COUNTER_INFO_A
#define PPDH_COUNTER_INFO           PPDH_COUNTER_INFO_A
#define PdhConnectMachine           PdhConnectMachineA
#define PdhEnumMachines             PdhEnumMachinesA
#define PdhEnumObjects              PdhEnumObjectsA
#define PdhEnumObjectItems          PdhEnumObjectItemsA
#define PdhMakeCounterPath          PdhMakeCounterPathA
#define PDH_COUNTER_PATH_ELEMENTS   PDH_COUNTER_PATH_ELEMENTS_A
#define PPDH_COUNTER_PATH_ELEMENTS  PPDH_COUNTER_PATH_ELEMENTS_A
#define PdhParseCounterPath         PdhParseCounterPathA
#define PdhParseInstanceName        PdhParseInstanceNameA
#define PdhValidatePath             PdhValidatePathA
#define PdhGetDefaultPerfObject     PdhGetDefaultPerfObjectA
#define PdhGetDefaultPerfCounter    PdhGetDefaultPerfCounterA
#define PdhBrowseCounters           PdhBrowseCountersA
#define PdhBrowseCountersH          PdhBrowseCountersHA
#define PDH_BROWSE_DLG_CONFIG       PDH_BROWSE_DLG_CONFIG_A
#define PPDH_BROWSE_DLG_CONFIG      PPDH_BROWSE_DLG_CONFIG_A
#define PDH_BROWSE_DLG_CONFIG_H     PDH_BROWSE_DLG_CONFIG_HA
#define PPDH_BROWSE_DLG_CONFIG_H    PPDH_BROWSE_DLG_CONFIG_HA
#define PdhExpandCounterPath        PdhExpandCounterPathA
// v2.0 functions
#define PDH_FMT_COUNTERVALUE_ITEM   PDH_FMT_COUNTERVALUE_ITEM_A
#define PPDH_FMT_COUNTERVALUE_ITEM  PPDH_FMT_COUNTERVALUE_ITEM_A
#define PDH_RAW_COUNTER_ITEM        PDH_RAW_COUNTER_ITEM_A
#define PPDH_RAW_COUNTER_ITEM       PPDH_RAW_COUNTER_ITEM_A
#define PdhGetFormattedCounterArray PdhGetFormattedCounterArrayA
#define PdhGetRawCounterArray       PdhGetRawCounterArrayA
#define PdhLookupPerfNameByIndex    PdhLookupPerfNameByIndexA
#define PdhLookupIndexByPerfName    PdhLookupIndexByPerfNameA
#define PdhOpenLog                  PdhOpenLogA
#define PdhUpdateLog                PdhUpdateLogA
#define PdhSelectDataSource         PdhSelectDataSourceA
#define PdhGetDataSourceTimeRange   PdhGetDataSourceTimeRangeA
#define PDH_LOG_SERVICE_QUERY_INFO  PDH_LOG_SERVICE_QUERY_INFO_A
#define PPDH_LOG_SERVICE_QUERY_INFO PPDH_LOG_SERVICE_QUERY_INFO_A
#define PdhLogServiceControl        PdhLogServiceControlA
#define PdhLogServiceQuery          PdhLogServiceQueryA
#define PdhExpandWildCardPath       PdhExpandWildCardPathA
#define PdhObjectHasInstances       PdhObjectHasInstancesA

#define PdhBindInputDataSource      PdhBindInputDataSourceA
#define PdhEnumMachinesH            PdhEnumMachinesHA
#define PdhEnumObjectsH             PdhEnumObjectsHA
#define PdhEnumObjectItemsH         PdhEnumObjectItemsHA
#define PdhExpandWildCardPathH      PdhExpandWildCardPathHA
#define PdhObjectHasInstancesH      PdhObjectHasInstancesHA
#define PdhGetDefaultPerfObjectH    PdhGetDefaultPerfObjectHA
#define PdhGetDefaultPerfCounterH   PdhGetDefaultPerfCounterHA
#define PdhEnumLogSetNames	    PdhEnumLogSetNamesA
#define PdhCreateSQLTables	    PdhCreateSQLTablesA
#define PdhVerifySQLDB	            PdhVerifySQLDBA
#define PdhListLogFileHeader	    PdhListLogFileHeaderA

// end of ANSI definitions
#endif  // UNICODE

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning ( default : 4201 )
#endif


#ifdef __cplusplus
}
#endif

#endif //_PDH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ptypes32.h ===
/*****************************************************************************\
* Copyright (C) Microsoft Corporation, 1990-1999
* PTYPES32.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides types for 16/32 bit portable code.
\*****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#include <setjmp.h>

/* TYPES: */

#define    HUGE_T
typedef    DWORD        WORD2DWORD     ;
typedef    DWORD        CHARPARM       ;
typedef    DWORD        SHORTPARM      ;
typedef    DWORD        VERSION        ;
typedef    LPSTR        PDLLMEM        ;
typedef    unsigned long  CHAR2ULONG   ;
typedef    unsigned long  USHORT2ULONG ;
typedef    unsigned long  SHORT2ULONG  ;
typedef    unsigned long  INT2DWORD    ;
typedef    unsigned short BYTE2WORD    ;
typedef    POINTS       MPOINT         ;
typedef    WORD         INT2WORD       ;
typedef    jmp_buf      MCATCHBUF      ;
typedef    MCATCHBUF    *LPMCATCHBUF   ;

#define HFILE2INT(h, flags)     (INT)_open_osfhandle((long)(h), (int)(flags))
#define INT2HFILE(i)            (HFILE)_get_osfhandle((int)(i))
#define DUPHFILE(h)             MDupHandle(h)
#define MGLOBALPTR(p)           (LPSTR)(p)

/* PRAGMAS */

#define _LOADDS
#define _EXPORT

#define ERROR_GETADDR_FAILED    0x8001

#define INITWINDOWS()

#define WF_PMODE        0x0001      /* from winkrnl.h */
#define WF_CPU286       0x0002
#define WF_CPU386       0x0004
#define WF_CPU486       0x0008
#define WF_STANDARD     0x0010
#define WF_WIN286       0x0010
#define WF_ENHANCED     0x0020
#define WF_WIN386       0x0020
#define WF_CPU086       0x0040
#define WF_CPU186       0x0080
#define WF_LARGEFRAME   0x0100
#define WF_SMALLFRAME   0x0200
#define WF_80x87        0x0400


/* DEFINITIONS */


#define TF_FORCEDRIVE       (BYTE)0x80
#define DLLMEM_MOVEABLE     0
#define DLLMEM_ZEROINIT     GMEM_ZEROINIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\propset.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993-1999
//
// File:	propset.h
//
// Contents:	OLE Appendix B property set structure definitions
//
// History:	15-Jul-94       brianb    created
//		15-Aug-94       SethuR    revised
//              22-Feb-96       MikeHill  Changed cb in tagENTRY to cch.
//              28-May-96       MikeHill  Changed OSVER_* to OSKIND_*.
//
//---------------------------------------------------------------------------

#ifndef _PROPSET_H_
#define _PROPSET_H_

#if _MSC_VER > 1000
#pragma once
#endif

// CBMAXPROPSETSTREAM must be a power of 2.
#define CBMAXPROPSETSTREAM	(256 * 1024)

#define IsIndirectVarType(vt)			\
	    ((vt) == VT_STREAM ||		\
	     (vt) == VT_STREAMED_OBJECT ||	\
	     (vt) == VT_STORAGE ||		\
	     (vt) == VT_STORED_OBJECT ||        \
             (vt) == VT_VERSIONED_STREAM)


// Defines for the high order WORD of dwOSVer:

#define OSKIND_WINDOWS      0x0000
#define OSKIND_MACINTOSH    0x0001
#define OSKIND_WIN32        0x0002


typedef struct tagFORMATIDOFFSET	// fo
{
    FMTID	fmtid;
    DWORD	dwOffset;
} FORMATIDOFFSET;

#define CB_FORMATIDOFFSET	sizeof(FORMATIDOFFSET)


typedef struct tagPROPERTYSETHEADER	// ph
{
    WORD        wByteOrder;	// Always 0xfffe
    WORD        wFormat;	// Always 0
    DWORD       dwOSVer;	// System version
    CLSID       clsid;		// Application CLSID
    DWORD       reserved;	// reserved (must be at least 1)
} PROPERTYSETHEADER;

#define CB_PROPERTYSETHEADER	sizeof(PROPERTYSETHEADER)
#define PROPSET_BYTEORDER       0xFFFE


typedef struct tagPROPERTYIDOFFSET	// po
{
    DWORD       propid;
    DWORD       dwOffset;
} PROPERTYIDOFFSET;

#define CB_PROPERTYIDOFFSET	sizeof(PROPERTYIDOFFSET)


typedef struct tagPROPERTYSECTIONHEADER	// sh
{
    DWORD       cbSection;
    DWORD       cProperties;
    PROPERTYIDOFFSET rgprop[1];
} PROPERTYSECTIONHEADER;

#define CB_PROPERTYSECTIONHEADER FIELD_OFFSET(PROPERTYSECTIONHEADER, rgprop)


typedef struct tagSERIALIZEDPROPERTYVALUE		// prop
{
    DWORD	dwType;
    BYTE	rgb[1];
} SERIALIZEDPROPERTYVALUE;

#define CB_SERIALIZEDPROPERTYVALUE  FIELD_OFFSET(SERIALIZEDPROPERTYVALUE, rgb)


typedef struct tagENTRY			// ent
{
    DWORD propid;
    DWORD cch;			// Includes trailing '\0' or L'\0'
    char  sz[1];		// WCHAR if UNICODE CodePage
} ENTRY;

#define CB_DICTIONARY_ENTRY             FIELD_OFFSET(ENTRY, sz)


typedef struct tagDICTIONARY		// dy
{
    DWORD	cEntries;
    ENTRY	rgEntry[1];
} DICTIONARY;

#define CB_DICTIONARY		FIELD_OFFSET(DICTIONARY, rgEntry)

#endif // _PROPSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\propapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       propapi.h
//
//  Contents:   Stuff needed to make properties build for Nashville and
//              NT... definitions of Nt property api.
//
//
//  History:    07-Aug-95   BillMo      Created.
//              22-Feb-96   MikeHill    Fixed the non-WINNT version of
//                                      PROPASSERTMSG.
//              09-May-96   MikeHill    Update define to allow PropSet names
//                                      to be 255 characters (from 127).
//              31-May-96   MikeHill    Add OSVersion to RtlCreatePropSet.
//              18-Jun-96   MikeHill    Add OleAut32 wrappers to Unicode callouts.
//              15-Jul-96   MikeHill    - Remvd Win32 SEH exception-related code.
//                                      - WCHAR=>OLECHAR where applicable.
//                                      - Added RtlOnMappedStreamEvent
//                                      - Added Mac versions of PROPASSERT
//
//--------------------------------------------------------------------------


#ifndef _PROPAPI_H_
#define _PROPAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// typedef the function prototypes necessary
// for the UNICODECALLOUTS structure.
//

typedef UINT (WINAPI FNGETACP)(VOID);

typedef int (WINAPI FNMULTIBYTETOWIDECHAR)(
    IN UINT CodePage,
    IN DWORD dwFlags,
    IN LPCSTR lpMultiByteStr,
    IN int cchMultiByte,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar);

typedef int (WINAPI FNWIDECHARTOMULTIBYTE)(
    IN UINT CodePage,
    IN DWORD dwFlags,
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpMultiByteStr,
    IN int cchMultiByte,
    IN LPCSTR lpDefaultChar,
    IN LPBOOL lpUsedDefaultChar);

typedef BSTR FNSYSALLOCSTRING(
    OLECHAR FAR* pwsz);

typedef VOID FNSYSFREESTRING(
    BSTR pwsz);

//
// The UNICODECALLOUTS structure holds function
// pointers for routines needed by the property
// set routines in NTDLL.
//

typedef struct _UNICODECALLOUTS
{
    FNGETACP              *pfnGetACP;
    FNMULTIBYTETOWIDECHAR *pfnMultiByteToWideChar;
    FNWIDECHARTOMULTIBYTE *pfnWideCharToMultiByte;
    FNSYSALLOCSTRING      *pfnSysAllocString;
    FNSYSFREESTRING       *pfnSysFreeString;
} UNICODECALLOUTS;


//
// Define the default UNICODECALLOUTS
// values.
//

STDAPI_(BSTR)
PropSysAllocString(OLECHAR FAR* pwsz);

STDAPI_(VOID)
PropSysFreeString(BSTR bstr);

#define WIN32_UNICODECALLOUTS \
    GetACP,                   \
    MultiByteToWideChar,      \
    WideCharToMultiByte,      \
    PropSysAllocString,       \
    PropSysFreeString


// Is this pure NT (the IProp DLL needs to run on Win95)?
#if defined(WINNT) && !defined(IPROPERTY_DLL)

    // Set the function modifiers
#   define PROPSYSAPI NTSYSAPI
#   define PROPAPI NTAPI

    // How do we free mem allocated in the low-level propset routines?
#   define PropFreeHeap(h, z, p) RtlFreeHeap(h, z, p)

    // Assert implementations
#   define PROPASSERT ASSERT
#   define PROPASSERTMSG ASSERTMSG

    // Generate the default non-simple property stream/storage name
#   define PROPGENPROPERTYNAME(s,n) swprintf ((s), L"prop%lu", (n))

    // Ansi sprintf implementations
#   define PropSprintfA sprintf
#   define PropVsprintfA vsprintf

// Otherwise this is either the IProp DLL (NT, Win95, Mac),
// or it's the Win95 OLE32build.

#else // #if defined(WINNT) && !defined(IPROPERTY_DLL)

    // Set the function modifiers
#   define PROPSYSAPI
#   define PROPAPI

    // How do we free mem allocated in low-level propset routines?
#   define PropFreeHeap(h, z, p) CoTaskMemFree(p)

    // Assert implementations
#   if DBG==1
#       ifdef _MAC_NODOC
#           define PROPASSERT(f)                { if (!(f)) FnAssert(#f, NULL, __FILE__, __LINE__); }
#           define PROPASSERTMSG(szReason, f)   { if (!(f)) FnAssert(#f, szReason, __FILE__, __LINE__); }
#       else
#           define PROPASSERT(f) PROPASSERTMSG(NULL,f)
#           define PROPASSERTMSG(szReason,f) { if(!(f)) PropAssertFailed(#f,__FILE__,__LINE__,szReason); }
#       endif
#   else
#       define PROPASSERT(f)
#       define PROPASSERTMSG(szReason, f)
#   endif // #if DBG==1

    // Generate the default non-simple property stream/storage name
#   define PROPGENPROPERTYNAME(s,n) \
    { \
        memcpy ((s), OLESTR("prop"), sizeof (OLESTR("prop"))); \
        ULTOO  ((n), &(s)[sizeof("prop") - 1], 10); \
    }

    // Ansi sprintf implementations
#   ifdef IPROPERTY_DLL
#       define PropSprintfA sprintf
#       define PropVsprintfA vsprintf
#   else
#       define PropSprintfA wsprintfA
#       define PropVsprintfA wvsprintfA
#   endif	// #ifdef _MAC_NODOC

#endif // #if defined(WINNT) && !defined(IPROPERTY_DLL) ... #else



#define WC_PROPSET0     ((WCHAR)   0x0005) //(L'#'))
#define OC_PROPSET0     ((OLECHAR) 0x0005) //OLESTR('#'))

#define CBIT_BYTE       8
#define CBIT_GUID       (CBIT_BYTE * sizeof(GUID))
#define CBIT_CHARMASK   5

// The wFormat field in the header indicates what features
// are supported.

#define PROPSET_WFORMAT_ORIGINAL         0

#define PROPSET_WFORMAT_VERSTREAM        1
#define PROPSET_WFORMAT_CASE_SENSITIVE   1
#define PROPSET_WFORMAT_BEHAVIOR         1
#define PROPSET_WFORMAT_LONG_NAMES       1
#define PROPSET_WFORMAT_EXPANDED_VTS     1

// Allow for OC_PROPSET0 and a GUID mapped to a 32 character alphabet
#define CCH_PROPSET        (1 + (CBIT_GUID + CBIT_CHARMASK-1)/CBIT_CHARMASK)
#define CCH_PROPSETSZ      (CCH_PROPSET + 1)            // allow null
#define CCH_PROPSETCOLONSZ (1 + CCH_PROPSET + 1)        // allow colon and null

// Define the max property name in units of characters
// (and synonomously in wchars).

#define CCH_MAXPROPNAME    255                          // Matches Shell & Office
#define CCH_MAXPROPNAMESZ  (CCH_MAXPROPNAME + 1)        // allow null
#define CWC_MAXPROPNAME    CCH_MAXPROPNAME
#define CWC_MAXPROPNAMESZ  CCH_MAXPROPNAMESZ

#define MAX_DOCFILE_ENTRY_NAME  31

//+--------------------------------------------------------------------------
// Property Access APIs:
//---------------------------------------------------------------------------

typedef VOID *NTPROP;
typedef VOID *NTMAPPEDSTREAM;
typedef VOID *NTMEMORYALLOCATOR;


VOID PROPSYSAPI PROPAPI
RtlSetUnicodeCallouts(
    IN UNICODECALLOUTS *pUnicodeCallouts);

ULONG PROPSYSAPI PROPAPI
RtlGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[]);

NTSTATUS PROPSYSAPI PROPAPI
RtlPropertySetNameToGuid(
    IN ULONG cwcname,
    IN OLECHAR const aocname[],
    OUT GUID *pguid);

VOID
PrSetUnicodeCallouts(
    IN UNICODECALLOUTS *pUnicodeCallouts);

ULONG
PrGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[]);

NTSTATUS
PrPropertySetNameToGuid(
    IN ULONG cwcname,
    IN OLECHAR const aocname[],
    OUT GUID *pguid);


// RtlCreatePropertySet Flags:

#define CREATEPROP_READ         0x0000 // request read access (must exist)
#define CREATEPROP_WRITE        0x0001 // request write access (must exist)
#define CREATEPROP_CREATE       0x0002 // create (overwrite if exists)
#define CREATEPROP_CREATEIF     0x0003 // create (open existing if exists)
#define CREATEPROP_DELETE       0x0004 // delete
#define CREATEPROP_UNKNOWN      0x0008 // read/write state is unknown
#define CREATEPROP_MODEMASK     0x000f // open mode mask

#define CREATEPROP_NONSIMPLE    0x0010 // Is non-simple propset (in a storage)


// RtlCreateMappedStream Flags:

#define CMS_READONLY      0x00000000    // Opened for read-only
#define CMS_WRITE         0x00000001    // Opened for write access
#define CMS_TRANSACTED    0x00000002    // Is transacted


NTSTATUS PROPSYSAPI PROPAPI
RtlCreatePropertySet(
    IN NTMAPPEDSTREAM ms,       // Nt mapped stream
    IN USHORT Flags,	// NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE
    OPTIONAL IN GUID const *pguid, // property set guid (create only)
    OPTIONAL IN GUID const *pclsid,// CLASSID of propset code (create only)
    IN NTMEMORYALLOCATOR ma,	// caller's memory allocator
    IN ULONG LocaleId,		// Locale Id (create only)
    OPTIONAL OUT ULONG *pOSVersion,// OS Version field in header.
    IN OUT USHORT *pCodePage,   // IN: CodePage of property set (create only)
                                // OUT: CodePage of property set (always)
    OUT NTPROP *pnp);           // Nt property set context

NTSTATUS PROPSYSAPI PROPAPI
RtlClosePropertySet(
    IN NTPROP np);              // property set context

NTSTATUS
PrCreatePropertySet(
    IN NTMAPPEDSTREAM ms,       // Nt mapped stream
    IN USHORT Flags,	// NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE
    OPTIONAL IN GUID const *pguid, // property set guid (create only)
    OPTIONAL IN GUID const *pclsid,// CLASSID of propset code (create only)
    IN NTMEMORYALLOCATOR ma,	// caller's memory allocator
    IN ULONG LocaleId,		// Locale Id (create only)
    OPTIONAL OUT ULONG *pOSVersion,// OS Version field in header.
    IN OUT USHORT *pCodePage,   // IN: CodePage of property set (create only)
                                // OUT: CodePage of property set (always)
    IN OUT DWORD *pgrfBehavior,    // IN: Behavior of property set (create only)
                                    // OUT:  Behavior of property set (always)
    OUT NTPROP *pnp);           // Nt property set context

NTSTATUS
PrClosePropertySet(
    IN NTPROP np);              // property set context

// *NOTE* RtlOnMappedStreamEvent assumes that the caller has
// already taken the CPropertySetStream::Lock.
#define CBSTM_UNKNOWN   ((ULONG) -1)
NTSTATUS PROPSYSAPI PROPAPI
RtlOnMappedStreamEvent(
    IN VOID *pv,               // property set context (NTPROP)
    IN VOID *pbuf,             // property set buffer
    IN ULONG cbstm );          // size of underlying stream, or CBSTM_UNKNOWN
NTSTATUS
PrOnMappedStreamEvent(
    IN VOID *pv,               // property set context (NTPROP)
    IN VOID *pbuf,             // property set buffer
    IN ULONG cbstm );          // size of underlying stream, or CBSTM_UNKNOWN

NTSTATUS PROPSYSAPI PROPAPI
RtlFlushPropertySet(
    IN NTPROP np);              // property set context
NTSTATUS
PrFlushPropertySet(
    IN NTPROP np);              // property set context

typedef struct _INDIRECTPROPERTY        // ip
{
    ULONG       Index;          // Index into Variant and PropId arrays
    LPOLESTR    poszName;       // Old indirect name, RtlSetProperties() only
} INDIRECTPROPERTY;

NTSTATUS PROPSYSAPI PROPAPI
RtlSetProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID pidNameFirst,     // first PROPID for new named properties
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    OPTIONAL IN PROPVARIANT const avar[]);// array of properties with values
NTSTATUS
PrSetProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID pidNameFirst,     // first PROPID for new named properties
    IN PROPSPEC const aprs[],   // array of property specifiers
    OUT USHORT *pCodePage,      // updated code page
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    OPTIONAL IN PROPVARIANT const avar[]);// array of properties with values

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    IN OUT PROPVARIANT *avar,   // IN: array of uninitialized PROPVARIANTs,
                                // OUT: may contain pointers to alloc'd memory
    OUT ULONG *pcpropFound);    // count of property values retrieved
NTSTATUS
PrQueryProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    IN OUT PROPVARIANT *avar,   // IN: array of uninitialized PROPVARIANTs,
                                // OUT: may contain pointers to alloc'd memory
    OUT ULONG *pcpropFound);    // count of property values retrieved



#define ENUMPROP_NONAMES        0x00000001      // return property IDs only

NTSTATUS PROPSYSAPI PROPAPI
RtlEnumerateProperties(
    IN NTPROP np,               // property set context
    IN ULONG Flags,             // flags: No Names (propids only), etc.
    IN OUT ULONG *pkey,         // bookmark; caller set to 0 before 1st call
    IN OUT ULONG *pcprop,       // pointer to property count
    OPTIONAL OUT PROPSPEC aprs[],// IN: array of uninitialized PROPSPECs
                                // OUT: may contain pointers to alloc'd strings
    OPTIONAL OUT STATPROPSTG asps[]);
                                // IN: array of uninitialized STATPROPSTGs
                                // OUT: may contain pointers to alloc'd strings

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    OUT OLECHAR *aposz[]        // OUT pointers to allocated strings
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlSetPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    IN OLECHAR const * const aposz[] // pointers to property names
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlSetPropertySetClassId(
    IN NTPROP np,               // property set context
    IN GUID const *pclsid       // new CLASSID of propset code
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryPropertySet(
    IN NTPROP np,               // property set context
    OUT STATPROPSETSTG *pspss   // buffer for property set stat information
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlEnumeratePropertySets(
    IN HANDLE hstg,             // structured storage handle
    IN BOOLEAN fRestart,        // restart scan
    IN OUT ULONG *pcspss,       // pointer to count of STATPROPSETSTGs
    IN OUT GUID *pkey,          // bookmark
    OUT STATPROPSETSTG *pspss   // array of STATPROPSETSTGs
    );





NTSTATUS
PrEnumerateProperties(
    IN NTPROP np,               // property set context
    IN ULONG Flags,             // flags: No Names (propids only), etc.
    IN OUT ULONG *pkey,         // bookmark; caller set to 0 before 1st call
    IN OUT ULONG *pcprop,       // pointer to property count
    OPTIONAL OUT PROPSPEC aprs[],// IN: array of uninitialized PROPSPECs
                                // OUT: may contain pointers to alloc'd strings
    OPTIONAL OUT STATPROPSTG asps[]);
                                // IN: array of uninitialized STATPROPSTGs
                                // OUT: may contain pointers to alloc'd strings

NTSTATUS
PrQueryPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    OUT OLECHAR *aposz[]        // OUT pointers to allocated strings
    );

NTSTATUS
PrSetPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    IN OLECHAR const * const aposz[] // pointers to property names
    );

NTSTATUS
PrSetPropertySetClassId(
    IN NTPROP np,               // property set context
    IN GUID const *pclsid       // new CLASSID of propset code
    );

NTSTATUS
PrQueryPropertySet(
    IN NTPROP np,               // property set context
    OUT STATPROPSETSTG *pspss   // buffer for property set stat information
    );

NTSTATUS
PrEnumeratePropertySets(
    IN HANDLE hstg,             // structured storage handle
    IN BOOLEAN fRestart,        // restart scan
    IN OUT ULONG *pcspss,       // pointer to count of STATPROPSETSTGs
    IN OUT GUID *pkey,          // bookmark
    OUT STATPROPSETSTG *pspss   // array of STATPROPSETSTGs
    );



#ifdef __cplusplus
}
#endif

#endif // ifndef _PROPAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\reconcil.h ===
/*
 * Copyright (C) Microsoft Corporation, 1990-1999
 * reconcil.h - OLE reconciliation interface definitions.
 */


#ifndef __RECONCIL_H__
#define __RECONCIL_H__

#if _MSC_VER > 1000
#pragma once
#endif

/* Headers
 **********/

#include <recguids.h>


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Constants
 ************/

/* for use in IStorage::SetStateBits() */

#define STATEBITS_FLAT                 (0x0001)

/* reconciliation SCODEs */

#define REC_S_IDIDTHEUPDATES           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1000)
#define REC_S_NOTCOMPLETE              MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1001)
#define REC_S_NOTCOMPLETEBUTPROPAGATE  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1002)

#define REC_E_ABORTED                  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1000)
#define REC_E_NOCALLBACK               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1001)
#define REC_E_NORESIDUES               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1002)
#define REC_E_TOODIFFERENT             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1003)
#define REC_E_INEEDTODOTHEUPDATES      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1004)


/* Interfaces
 *************/

#undef  INTERFACE
#define INTERFACE INotifyReplica

DECLARE_INTERFACE_(INotifyReplica, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* INotifyReplica methods */

   STDMETHOD(YouAreAReplica)(THIS_
                             ULONG ulcOtherReplicas,
                             IMoniker **rgpmkOtherReplicas) PURE;
};

#undef  INTERFACE
#define INTERFACE IReconcileInitiator

DECLARE_INTERFACE_(IReconcileInitiator, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IReconcileInitiator methods */

   STDMETHOD(SetAbortCallback)(THIS_
                               IUnknown *punkForAbort) PURE;

   STDMETHOD(SetProgressFeedback)(THIS_
                                  ULONG ulProgress,
                                  ULONG ulProgressMax) PURE;
};

/* IReconcilableObject::Reconcile() flags */

typedef enum _reconcilef
{
   /* interaction with the user is allowed */

   RECONCILEF_MAYBOTHERUSER         = 0x0001,

   /*
    * hwndProgressFeedback may be used to provide reconciliation progress
    * feedback to the user.
    */

   RECONCILEF_FEEDBACKWINDOWVALID   = 0x0002,

   /* residue support not required */

   RECONCILEF_NORESIDUESOK          = 0x0004,

   /* caller not interested in callee's residues */

   RECONCILEF_OMITSELFRESIDUE       = 0x0008,

   /*
    * Reconcile() call resuming after a previous Reconcile() call returned
    * REC_E_NOTCOMPLETE
    */

   RECONCILEF_RESUMERECONCILIATION  = 0x0010,

   /* Object may perform all updates. */

   RECONCILEF_YOUMAYDOTHEUPDATES    = 0x0020,

   /* Only this object has been changed. */

   RECONCILEF_ONLYYOUWERECHANGED    = 0x0040,

   /* flag combinations */

   ALL_RECONCILE_FLAGS              = (RECONCILEF_MAYBOTHERUSER |
                                       RECONCILEF_FEEDBACKWINDOWVALID |
                                       RECONCILEF_NORESIDUESOK |
                                       RECONCILEF_OMITSELFRESIDUE |
                                       RECONCILEF_RESUMERECONCILIATION |
                                       RECONCILEF_YOUMAYDOTHEUPDATES |
                                       RECONCILEF_ONLYYOUWERECHANGED)
}
RECONCILEF;

#undef  INTERFACE
#define INTERFACE IReconcilableObject

DECLARE_INTERFACE_(IReconcilableObject, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IReconcilableObject methods */

   STDMETHOD(Reconcile)(THIS_
                        IReconcileInitiator *pInitiator,
                        DWORD dwFlags,
                        HWND hwndOwner,
                        HWND hwndProgressFeedback,
                        ULONG ulcInput,
                        IMoniker **rgpmkOtherInput,
                        PLONG plOutIndex,
                        IStorage *pstgNewResidues,
                        PVOID pvReserved) PURE;

   STDMETHOD(GetProgressFeedbackMaxEstimate)(THIS_
                                             PULONG pulProgressMax) PURE;
};

#undef  INTERFACE
#define INTERFACE IBriefcaseInitiator

DECLARE_INTERFACE_(IBriefcaseInitiator, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IBriefcaseInitiator methods */

   STDMETHOD(IsMonikerInBriefcase)(THIS_
                                   IMoniker *pmk) PURE;
};


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */


#endif   /* ! __RECONCIL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\recguids.h ===
// Copyright (C) Microsoft Corporation, 1990-1999
#if _MSC_VER > 1000
#pragma once
#endif

/*
 * recguids.h - OLE reconciliation interface GUID definitions.
 */


/* GUIDs
 ********/

DEFINE_GUID(IID_IReconcileInitiator, 0x99180161L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_IReconcilableObject, 0x99180162L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_INotifyReplica,      0x99180163L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_IBriefcaseInitiator, 0x99180164L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ppcinst.h ===
/*++

Copyright (c) 1993  IBM Corporation

Module Name:

    ppcinst.h

Abstract:

    PowerPC instruction and floating constant definitions.

Author:

    Rick Simpson   30 July 1993

Revision History:

--*/

#ifndef _PPCINST_
#define _PPCINST_
#if _MSC_VER > 1000
#pragma once
#endif


//
//     POWERPC INSTRUCTION FORMAT STRUCTURES
//

typedef union _PPC_INSTRUCTION {
    ULONG Long;
    UCHAR Byte[4];

    struct {
        ULONG bit31   :  1;
        ULONG bit30   :  1;
	 LONG bit6_29 : 24;
	ULONG bit0_5  :  6;
    } i_f;

#define Primary_Op  i_f.bit0_5

#define Iform_LI  i_f.bit6_29
#define Iform_AA  i_f.bit30
#define Iform_LK  i_f.bit31

    struct {
        ULONG bit31    :  1;
        ULONG bit30    :  1;
	 LONG bit16_29 : 14;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
        ULONG bit0_5   :  6;
    } b_f;

#define Bform_BO  b_f.bit6_10
#define Bform_BI  b_f.bit11_15
#define Bform_BD  b_f.bit16_29
#define Bform_AA  b_f.bit30
#define Bform_LK  b_f.bit31

    struct {
	ULONG bit31    :  1;
	ULONG bit30    :  1;
	ULONG bit6_29  : 24;
	ULONG bit0_5   :  6;
    } sc_f;

#define SCform_XO  sc_f.bit30

    struct {
	 LONG bit16_31 : 16;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } d_f1;
    struct {
	ULONG bit16_31 : 16;
	ULONG bit11_15 :  5;
	ULONG bit10    :  1;
	ULONG bit9     :  1;
	ULONG bit6_8   :  3;
	ULONG bit0_5   :  6;
    } d_f2;

#define Dform_RT   d_f1.bit6_10
#define Dform_RS   d_f1.bit6_10
#define Dform_TO   d_f1.bit6_10
#define Dform_FRT  d_f1.bit6_10
#define Dform_FRS  d_f1.bit6_10
#define Dform_BF   d_f2.bit6_8
#define Dform_L    d_f2.bit10
#define Dform_RA   d_f1.bit11_15
#define Dform_D    d_f1.bit16_31
#define Dform_SI   d_f1.bit16_31
#define Dform_UI   d_f2.bit16_31

    struct {
	ULONG bit30_31 :  2;
	 LONG bit16_29 : 14;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } ds_f;

#define DSform_RT  ds_f.bit6_10
#define DSform_RS  ds_f.bit6_10
#define DSform_RA  ds_f.bit11_15
#define DSform_DS  ds_f.bit16_29
#define DSform_XO  ds_f.bit30_31

    struct {
	ULONG bit31    :  1;
	ULONG bit21_30 : 10;
	ULONG bit16_20 :  5;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } x_f1;
    struct {
	ULONG bit20_31 : 12;
	ULONG bit16_19 :  4;
	ULONG bit14_15 :  2;
	ULONG bit11_13 :  3;
	ULONG bit10    :  1;
	ULONG bit9     :  1;
	ULONG bit6_8   :  3;
	ULONG bit0_5   :  6;
    } x_f2;
    struct {
	ULONG bit16_31 : 16;
	ULONG bit12_15 :  4;
	ULONG bit0_11  : 12;
    } x_f3;

#define Xform_RT   x_f1.bit6_10
#define Xform_RS   x_f1.bit6_10
#define Xform_TO   x_f1.bit6_10
#define Xform_FRT  x_f1.bit6_10
#define Xform_FRS  x_f1.bit6_10
#define Xform_BT   x_f1.bit6_10
#define Xform_BF   x_f2.bit6_8
#define Xform_L    x_f2.bit10
#define Xform_RA   x_f1.bit11_15
#define Xform_FRA  x_f1.bit11_15
#define Xform_BFA  x_f2.bit11_13
#define Xform_SR   x_f3.bit12_15
#define Xform_RB   x_f1.bit16_20
#define Xform_NB   x_f1.bit16_20
#define Xform_SH   x_f1.bit16_20
#define Xform_FRB  x_f1.bit16_20
#define Xform_U    x_f2.bit16_19
#define Xform_XO   x_f1.bit21_30
#define Xform_RC   x_f1.bit31

    struct {
	ULONG bit31    :  1;
	ULONG bit21_30 : 10;
	ULONG bit16_20 :  5;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } xl_f1;
    struct {
	ULONG bit14_31 : 18;
	ULONG bit11_13 :  3;
	ULONG bit9_10  :  2;
	ULONG bit6_8   :  3;
	ULONG bit0_5   :  6;
    } xl_f2;

#define XLform_LK   xl_f1.bit31
#define XLform_XO   xl_f1.bit21_30
#define XLform_BB   xl_f1.bit16_20
#define XLform_BA   xl_f1.bit11_15
#define XLform_BI   xl_f1.bit11_15
#define XLform_BFA  xl_f2.bit11_13
#define XLform_BT   xl_f1.bit6_10
#define XLform_BO   xl_f1.bit6_10
#define XLform_BF   xl_f2.bit6_8

    struct {
	ULONG bit31    :  1;
	ULONG bit21_30 : 10;
	ULONG bit11_20 : 10;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } xfx_f1;
    struct {
	ULONG bit20_31 : 12;
	ULONG bit12_19 :  8;
	ULONG bit6_11  :  6;
	ULONG bit0_5   :  6;
    } xfx_f2;

#define XFXform_RT  xfx_f1.bit6_10
#define XFXform_RS  xfx_f1.bit6_10
#define XFXform_spr xfx_f1.bit11_20
#define XFXform_tbr xfx_f1.bit11_20
#define XFXform_spr xfx_f1.bit11_20
#define XFXform_FXM xfx_f2.bit12_19
#define XFXform_XO  xfx_f1.bit21_30

    struct {
	ULONG bit31    :  1;
	ULONG bit21_30 : 10;
	ULONG bit16_20 :  5;
	ULONG bit15    :  1;
	ULONG bit7_14  :  8;
	ULONG bit6     :  1;
	ULONG bit0_5   :  6;
    } xfl_f;

#define XFLform_FLM xfl_f.bit7_14
#define XFLform_FRB xfl_f.bit16_20
#define XFLform_XO  xfl_f.bit21_30
#define XFLform_RC  xfl_f.bit31

    struct {
	ULONG bit31    :  1;
	ULONG bit30    :  1;
	ULONG bit21_29 :  9;
	ULONG bit16_20 :  5;
	ULONG bit10_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } xs_f;

#define XSform_RS  xs_f.bit6_10
#define XSform_RA  xs_f.bit11_15
#define XSform_sh1 xs_f.bit16_20
#define XSform_XO  xs_f.bit21_29
#define XSform_sh2 xs_f.bit30
#define XSform_RC  xs_f.bit31

    struct {
	ULONG bit31    :  1;
	ULONG bit22_30 :  9;
	ULONG bit21    :  1;
	ULONG bit16_20 :  5;
	ULONG bit10_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } xo_f;

#define XOform_RT  xo_f.bit6_10
#define XOform_RA  xo_f.bit11_15
#define XOform_RB  xo_f.bit16_20
#define XOform_OE  xo_f.bit21
#define XOform_XO  xo_f.bit22_30
#define XOform_RC  xo_f.bit31

    struct {
	ULONG bit31    :  1;
	ULONG bit26_30 :  5;
	ULONG bit21_25 :  5;
	ULONG bit16_20 :  5;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } a_f;

#define Aform_FRT  a_f.bit6_10
#define Aform_FRA  a_f.bit11_15
#define Aform_FRB  a_f.bit16_20
#define Aform_FRC  a_f.bit21_25
#define Aform_XO   a_f.bit26_30
#define Aform_RC   a_f.bit31

    struct {
	ULONG bit31    :  1;
	ULONG bit26_30 :  5;
	ULONG bit21_25 :  5;
	ULONG bit16_20 :  5;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } m_f;

#define Mform_RS  m_f.bit6_10
#define Mform_RA  m_f.bit11_15
#define Mform_RB  m_f.bit16_20
#define Mform_SH  m_f.bit16_20
#define Mform_MB  m_f.bit21_25
#define Mform_ME  m_f.bit26_30
#define Mform_RC  m_f.bit31

    struct {
	ULONG bit31    :  1;
	ULONG bit30    :  1;
	ULONG bit27_29 :  3;
	ULONG bit21_26 :  6;
	ULONG bit16_20 :  5;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } md_f;

#define MDform_RS   md_f.bit6_10
#define MDform_RA   md_f.bit11_15
#define MDform_sh1  md_f.bit16_20
#define MDform_mb   md_f.bit21_26
#define MDform_me   md_f.bit21_26
#define MDform_XO   md_f.bit27_29
#define MDform_sh2  md_f.bit30
#define MDform_RC   md_f.bit31

    struct {
	ULONG bit31    :  1;
	ULONG bit27_30 :  4;
	ULONG bit21_26 :  6;
	ULONG bit16_20 :  5;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } mds_f;

#define MDSform_RS  mds_f.bit6_10
#define MDSform_RA  mds_f.bit11_15
#define MDSform_RB  mds_f.bit16_20
#define MDSform_mb  mds_f.bit21_26
#define MDSform_me  mds_f.bit21_26
#define MDSform_XO  mds_f.bit27_30
#define MDSform_RC  mds_f.bit31

} PPC_INSTRUCTION, *PPPC_INSTRUCTION;

//
//     POWERPC PRIMARY AND SECONDARY (EXTENDED) OPCODES
//

#define TDI_OP       2
#define TWI_OP       3
#define MULLI_OP     7
#define SUBFIC_OP    8
#define CMPLI_OP    10
#define CMPI_OP     11
#define ADDIC_OP    12
#define ADDIC_RC_OP 13
#define ADDI_OP     14
#define ADDIS_OP    15
#define BC_OP       16
#define SC_OP       17
#define B_OP        18

#define X19_OP      19    // Extended ops for primary code 19:
#define   MCRF_OP       0
#define   BCLR_OP      16
#define   CRNOR_OP     33
#define   RFI_OP       50
#define   CRANDC_OP   129
#define   ISYNC_OP    150
#define   CRXOR_OP    193
#define	  CRNAND_OP   225
#define	  CRAND_OP    257
#define	  CREQV_OP    289
#define	  CRORC_OP    417
#define	  CROR_OP     449
#define	  BCCTR_OP    528

#define RLWIMI_OP   20
#define RLWINM_OP   21
#define RLWNM_OP    23
#define ORI_OP      24
#define	ORIS_OP	    25
#define XORI_OP	    26
#define	XORIS_OP    27
#define	ANDI_RC_OP  28
#define ANDIS_RC_OP 29

#define X30_OP	    30    // Extended ops for primary code 30:
#define   RLDICL_OP     0
#define   RLDICR_OP	1
#define	  RLDIC_OP	2
#define	  RLDIMI_OP	3
#define   RLDCL_OP	8
#define   RLDCR_OP	9

#define X31_OP      31    // Extended ops for primary code 31:
#define   CMP_OP	0
#define	  TW_OP		4
#define	  SUBFC_OP	8
#define	  MULHDU_OP	9
#define	  ADDC_OP      10
#define	  MULHWU_OP    11
#define	  MFCR_OP      19
#define	  LWARX_OP     20
#define	  LDX_OP       21
#define	  LWZX_OP      23
#define	  SLW_OP       24
#define	  CNTLZW_OP    26
#define	  SLD_OP       27
#define	  AND_OP       28
#define	  CMPL_OP      32
#define	  SUBF_OP      40
#define	  LDUX_OP      53
#define	  DCBST_OP     54
#define	  LWZUX_OP     55
#define	  CNTLZD_OP    58
#define	  ANDC_OP      60
#define	  TD_OP	       68
#define	  MULHD_OP     73
#define	  MULHW_OP     75
#define	  MFMSR_OP     83
#define	  LDARX_OP     84
#define	  DCBF_OP      86
#define	  LBZX_OP      87
#define	  NEG_OP      104
#define	  LBZUX_OP    119
#define	  NOR_OP      124
#define	  SUBFE_OP    136
#define	  ADDE_OP     138
#define	  MTCRF_OP    144
#define	  MTMSR_OP    146
#define	  STDX_OP     149
#define	  STWCX_RC_OP 150	
#define	  STWX_OP     151
#define	  STDUX_OP    181
#define	  STWUX_OP    183
#define	  SUBFZE_OP   200
#define	  ADDZE_OP    202
#define	  MTSR_OP     210
#define	  STDCX_RC_OP 214
#define	  STBX_OP     215
#define	  SUBFME_OP   232
#define	  MULLD_OP    233
#define	  ADDME_OP    234
#define	  MULLW_OP    235
#define	  MTSRIN_OP   242
#define	  DCBTST_OP   246
#define	  STBUX_OP    247
#define	  ADD_OP      266
#define	  DCBT_OP     278
#define	  LHZX_OP     279
#define	  EQV_OP      284
#define	  TLBIE_OP    306
#define	  ECIWX_OP    310
#define	  LHZUX_OP    311
#define	  XOR_OP      316
#define	  MFSPR_OP    339
#define	  LWAX_OP     341
#define	  LHAX_OP     343
#define	  TLBIA_OP    370
#define	  MFTB_OP     371
#define	  LWAUX_OP    373
#define	  LHAUX_OP    375
#define	  STHX_OP     407
#define	  ORC_OP      412
#define	  SRADI_OP    413
#define	  SLBIE_OP    434
#define	  ECOWX_OP    438
#define	  STHUX_OP    439
#define	  OR_OP	      444
#define	  DIVDU_OP    457
#define	  DIVWU_OP    459
#define	  MTSPR_OP    467
#define	  DCBI_OP     470
#define	  NAND_OP     476
#define	  DIVD_OP     489
#define	  DIVW_OP     491
#define	  SLBIA_OP    498
#define	  MCRXR_OP    512
#define	  LSWX_OP     533
#define	  LWBRX_OP    534
#define	  LFSX_OP     535
#define	  SRW_OP      536
#define	  SRD_OP      539
#define	  TLBSYNC_OP  566
#define	  LFSUX_OP    567
#define	  MFSR_OP     595
#define	  LSWI_OP     597
#define	  SYNC_OP     598
#define	  LFDX_OP     599
#define	  LFDUX_OP    631
#define	  MFSRIN_OP   659
#define	  STSWX_OP    661
#define	  STWBRX_OP   662
#define	  STFSX_OP    663
#define	  STFSUX_OP   695
#define	  STSWI_OP    725
#define	  STFDX_OP    727
#define	  STFDUX_OP   759
#define	  LHBRX_OP    790
#define	  SRAW_OP     792
#define	  SRAD_OP     794
#define	  SRAWI_OP    824
#define	  EIEIO_OP    854
#define	  STHBRX_OP   918
#define	  EXTSH_OP    922
#define	  EXTSB_OP    954
#define	  ICBI_OP     982
#define	  STFIWX_OP   983
#define	  EXTSW_OP    986
#define	  DCBZ_OP    1014

#define LWZ_OP      32
#define LWZU_OP	    33
#define	LBZ_OP	    34
#define	LBZU_OP	    35
#define	STW_OP	    36
#define	STWU_OP	    37
#define	STB_OP	    38
#define	STBU_OP	    39
#define	LHZ_OP	    40
#define	LHZU_OP	    41
#define	LHA_OP	    42
#define	LHAU_OP	    43
#define	STH_OP	    44
#define	STHU_OP	    45
#define	LFS_OP	    48
#define	LFSU_OP	    49
#define	LFD_OP	    50
#define	LFDU_OP	    51
#define STFS_OP	    52
#define	STFSU_OP    53
#define	STFD_OP	    54
#define	STFDU_OP    55

#define X58_OP      58    // Extended ops for primary code 58:
#define   LD_OP	        0
#define	  LDU_OP	1
#define	  LWA_OP	2

#define X59_OP      59    // Extended ops for primary code 59:
#define	  FDIVS_OP     18
#define	  FSUBS_OP     20
#define	  FADDS_OP     21
#define	  FSQRTS_OP    22
#define	  FRES_OP      24
#define	  FMULS_OP     25
#define	  FMSUBS_OP    28
#define   FMADDS_OP    29
#define	  FNMSUBS_OP   30
#define	  FNMADDS_OP   31

#define X62_OP      62    // Extended ops for primary code 62:
#define   STD_OP        0
#define   STDU_OP       1

#define X63_OP	    63	  // Extended ops for primary code 63:
#define   FCMPU_OP      0
#define	  FRSP_OP      12
#define	  FCTIW_OP     14
#define	  FCTIWZ_OP    15
#define	  FDIV_OP      18
#define	  FSUB_OP      20
#define	  FADD_OP      21
#define	  FSQRT_OP     22
#define	  FSEL_OP      23
#define	  FMUL_OP      25
#define	  FSQRTE_OP    26
#define	  FMSUB_OP     28
#define   FMADD_OP     29
#define	  FNMSUB_OP    30
#define	  FNMADD_OP    31
#define	  FCMPO_OP     32
#define	  MTFSB1_OP    38
#define	  FNEG_OP      40
#define	  MCRFS_OP     64
#define	  MTFSB0_OP    70
#define	  FMR_OP       72
#define	  MTFSFI_OP   134
#define	  FNABS_OP    136
#define	  FABS_OP     264
#define	  MFFS_OP     583
#define	  MTFSF_OP    711
#define	  FCTID_OP    814
#define	  FCTIDZ_OP   815
#define	  FCFID_OP    846

//
// Define certain specific instructions
//

#define SYSTEM_CALL_INSTR  0x44000002L  // sc
#define RETURN_INSTR       0x4E800020L  // blr
#define BREAK_INSTR        0x0FE00000L  // break <number>
#define TRAP_INSTR         0x0C000000L  // trap word immediate
#define NO_OP_INSTR	       0x60000000L  // ori r.0, r.0, 0
#define INVALID_INSTR	   0x00000000L  // all 0's => invalid

//
// Define specific values for the TO field of the TRAP_INSTR
//

#define TO_BREAKPOINT                   0x03E00000L  // Unconditional breakpoint
#define TO_DIVIDE_BY_ZERO               0x00C00000L  // Integer divide by zero
#define TO_UNCONDITIONAL_DIVIDE_BY_ZERO 0x00E00000L  // Unconditional divide
                                                     // by zero

//
//     IEEE FLOATING POINT VALUE REPRESENTATION
//

//
// Define maximum and minimum single and double exponent values.
//

#define DOUBLE_MAXIMUM_EXPONENT  2047
#define DOUBLE_MINIMUM_EXPONENT  0
#define SINGLE_MAXIMUM_EXPONENT  255
#define SINGLE_MINIMUM_EXPONENT  0

//
// Define single and double exponent bias values.
//

#define SINGLE_EXPONENT_BIAS  127
#define DOUBLE_EXPONENT_BIAS  1023

//
// Define the largest single and double values;
//

#define DOUBLE_MAXIMUM_VALUE_LOW   0xffffffff
#define DOUBLE_MAXIMUM_VALUE_HIGH  0x7fefffff
#define SINGLE_MAXIMUM_VALUE       0x7f7fffff

//
// Define single and double quite and signaling Nan values.
//

#define DOUBLE_NAN_LOW     0xffffffff
#define DOUBLE_QUIET_NAN   0x7ff7ffff
#define DOUBLE_SIGNAL_NAN  0x7fffffff
#define SINGLE_QUIET_NAN   0x7fbfffff
#define SINGLE_SIGNAL_NAN  0x7fffffff

//
// Define positive single and double infinity values.
//

#define DOUBLE_INFINITY_VALUE_LOW   0x0
#define DOUBLE_INFINITY_VALUE_HIGH  0x7ff00000
#define SINGLE_INFINITY_VALUE       0x7f800000

//
// Define rounding modes.
//

#define ROUND_TO_NEAREST         0
#define ROUND_TO_ZERO            1
#define ROUND_TO_PLUS_INFINITY   2
#define ROUND_TO_MINUS_INFINITY  3

#endif // _PPCINST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\penwin.h ===
/****************************************************************************\
*                                                                            *
* PENWIN.H -  Pen Windows functions, types, and definitions                  *
*                                                                            *
*             Version 2.0                                                    *
*                                                                            *
*             Copyright (c) 1992-1999 Microsoft Corp. All rights reserved.   *
*                                                                            *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file;
* (indented identifiers are included by the previous main identifier):
*
* #define:         To prevent inclusion of:
*
* PENVER           Pen Windows version number (0x0200).  To exclude
*                   definitions introduced in version 2.0 (or above)
*                   #define PENVER 0x0100 before #including <penwin.h>
*
* NOJAPAN          JAPAN-specific code
* NOPENALC         Alphabet Code definitions and macros
* NOPENAPPS        Pen Applications: Screen Keyboard
* NOPENCTL         H/BEDIT, IEDIT, and pen-enabled USER controls, including:
*   NOPENBEDIT      : Boxed Edit Control
*   NOPENIEDIT      : Ink Edit Control
*   NOPENHEDIT      : (H)Edit control
* NOPENDATA        PenData APIs and definitions
* NOPENDICT        Dictionary support
* NOPENDRIVER      Pen Driver definitions, incl OEM
* NOPENHRC         Handwriting Recognizer APIs and definitions
* NOPENINKPUT      Inking and Input APIs and definitions
* NOPENMISC        Miscellaneous Info and Utility APIs and definitions
* NOPENMSGS        Pen Messages and definitions
* NOPENNLS         National Language Support
* NOPENRC1         Recognition Context APIs and definitions (1.0)
* NOPENRES         Pen resources, including:
*   NOPENBMP        : Pen-related bitmaps
*   NOPENCURS       : Pen-related cursors
* NOPENTARGET      Targeting APIs and definitions
* NOPENVIRTEVENT   Virtual Event layer APIs
*
* _WIN32           non-Win32 components, subincludes:
*                   : NOPENAPPS, NOPENDICT, NOPENRC1, NOPENVIRTEVENT
*
* "FBC" in the comments means that the feature exists only for
* backward compatibility. It should not be used by new applications.
\****************************************************************************/

#ifndef _INC_PENWIN
#define _INC_PENWIN

#if _MSC_VER > 1000
#pragma once
#endif

///////////////////////////////////////////////////
#ifndef NOJAPAN   // unless expressly overridden...
#ifndef JAPAN
#define JAPAN     // This is the Japanese version!
#endif //!JAPAN
#endif //!NOJAPAN
///////////////////////////////////////////////////

#include <windows.h>

#ifndef _WIN32
#ifndef RC_INVOKED
#pragma pack(1)
#endif /* RC_INVOKED */
#endif //!_WIN32

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifndef PENVER      /* may be pre-defined; otherwise assume version 2.0 */
    #define PENVER  0x0200
#endif //!PENVER

#ifdef _WIN32
    #define NOPENAPPS
    #define NOPENDICT
    #define NOPENRC1
    #define NOPENVIRTEVENT
    #define NOPENAPIFUN
#endif //_WIN32

#ifndef NOPENAPPS   // not available in WIN32
#ifndef RC_INVOKED
    #include <skbapi.h>
#endif /* !RC_INVOKED */
#endif /*!NOPENAPPS */

// other subsets:

#ifdef NOPENCTL
    #define NOPENBEDIT
    #define NOPENIEDIT
#endif /* NOPENCTL */

#ifdef NOPENRES
    #define NOPENBMP
    #define NOPENCURS
#endif /* NOPENRES */

//////////////////////////////////////////////////////////////////////////////
/****** Definitions 1: for everything including RC compiler *****************/

//---------------------------------------------------------------------------
#ifndef NOPENALC

// Enabled Alphabet:
#define ALC_DEFAULT          0x00000000L // nothing
#define ALC_LCALPHA          0x00000001L // a..z
#define ALC_UCALPHA          0x00000002L // A..Z
#define ALC_NUMERIC          0x00000004L // 0..9
#define ALC_PUNC             0x00000008L // !-;`"?()&.,; and backslash
#define ALC_MATH             0x00000010L // %^*()-+={}<>,/.
#define ALC_MONETARY         0x00000020L // ,.$ or local
#define ALC_OTHER            0x00000040L // @#|_~[]
#define ALC_ASCII            0x00000080L // restrict to 7-bit chars 20..7f
#define ALC_WHITE            0x00000100L // white space
#define ALC_NONPRINT         0x00000200L // sp tab ret ctrl glyphs
#define ALC_DBCS             0x00000400L // allow DBCS variety of SBCS
#define ALC_JIS1             0x00000800L // kanji JPN, ShiftJIS 1 only
#define ALC_GESTURE          0x00004000L // gestures
#define ALC_USEBITMAP        0x00008000L // use rc.rgbfAlc to enable chars
#define ALC_HIRAGANA         0x00010000L // hiragana JPN
#define ALC_KATAKANA         0x00020000L // katakana JPN
#define ALC_KANJI            0x00040000L // kanji JPN, ShiftJIS 1+2+3
#define ALC_GLOBALPRIORITY   0x10000000L
#define ALC_OEM              0x0FF80000L // OEM recognizer-specific
#define ALC_RESERVED         0xE0003000L // avail for future use
#define ALC_NOPRIORITY       0x00000000L // for alcPriority == none

#define ALC_ALPHA\
    (ALC_LCALPHA | ALC_UCALPHA)                                // 0x00000003L

#define ALC_ALPHANUMERIC\
    (ALC_ALPHA | ALC_NUMERIC)                                  // 0x00000007L

#define ALC_SYSMINIMUM\
    (ALC_ALPHANUMERIC | ALC_PUNC | ALC_WHITE | ALC_GESTURE)    // 0x0000410FL

#define ALC_ALL\
    (ALC_SYSMINIMUM | ALC_MATH | ALC_MONETARY\
    | ALC_OTHER | ALC_NONPRINT)                                // 0x0000437FL

#define ALC_KANJISYSMINIMUM\
    (ALC_SYSMINIMUM | ALC_HIRAGANA | ALC_KATAKANA | ALC_JIS1)  // 0x0003490FL

#define ALC_KANJIALL\
    (ALC_ALL | ALC_HIRAGANA | ALC_KATAKANA | ALC_KANJI)        // 0x0007437FL

#endif /*!NOPENALC */

//---------------------------------------------------------------------------
#ifndef NOPENBEDIT
// box edit styles:
#define BXS_NONE             0x0000U // none
#define BXS_RECT             0x0001U // use rectangle instead of cusp
#define BXS_BOXCROSS         0x0004U // use cross at box center
#ifdef JAPAN
#define BXS_NOWRITING        0x0008U // no pen input into control
#else
#endif //JAPAN

#endif /*!NOPENBEDIT */

//---------------------------------------------------------------------------
#ifndef NOPENBMP

// Public Bitmaps :
#define OBM_SKBBTNUP            32767
#define OBM_SKBBTNDOWN          32766
#define OBM_SKBBTNDISABLED      32765

#define OBM_ZENBTNUP            32764
#define OBM_ZENBTNDOWN          32763
#define OBM_ZENBTNDISABLED      32762

#define OBM_HANBTNUP            32761
#define OBM_HANBTNDOWN          32760
#define OBM_HANBTNDISABLED      32759

#define OBM_KKCBTNUP            32758
#define OBM_KKCBTNDOWN          32757
#define OBM_KKCBTNDISABLED      32756

#define OBM_SIPBTNUP            32755
#define OBM_SIPBTNDOWN          32754
#define OBM_SIPBTNDISABLED      32753

#define OBM_PTYBTNUP            32752
#define OBM_PTYBTNDOWN          32751
#define OBM_PTYBTNDISABLED      32750

#endif /*!NOPENBMP */

//---------------------------------------------------------------------------
#ifndef NOPENCURS
// Default pen cursor to indicate writing, points northwest
#define IDC_PEN         MAKEINTRESOURCE(32631)

// alternate select cursor: upsidedown standard arrow, points southeast
#define IDC_ALTSELECT   MAKEINTRESOURCE(32501)

#endif /*!NOPENCURS */

//---------------------------------------------------------------------------
#ifndef NOPENHRC
// special SYV values:
#define SYV_NULL                0x00000000L
#define SYV_UNKNOWN             0x00000001L
#define SYV_EMPTY               0x00000003L
#define SYV_BEGINOR             0x00000010L
#define SYV_ENDOR               0x00000011L
#define SYV_OR                  0x00000012L
#define SYV_SOFTNEWLINE         0x00000020L
#define SYV_SPACENULL           0x00010000L   // SyvCharacterToSymbol('\0')

// SYV values for gestures:
#define SYV_SELECTFIRST         0x0002FFC0L   // . means circle in following
#define SYV_LASSO               0x0002FFC1L   // lasso o-tap
#define SYV_SELECTLEFT          0x0002FFC2L   // no glyph
#define SYV_SELECTRIGHT         0x0002FFC3L   // no glyph
#define SYV_SELECTLAST          0x0002FFCFL   // 16 SYVs reserved for selection

#define SYV_CLEARCHAR           0x0002FFD2L   // d.
#define SYV_HELP                0x0002FFD3L   // no glyph
#define SYV_KKCONVERT           0x0002FFD4L   // k.
#define SYV_CLEAR               0x0002FFD5L   // d.
#define SYV_INSERT              0x0002FFD6L   // ^.
#define SYV_CONTEXT             0x0002FFD7L   // m.
#define SYV_EXTENDSELECT        0x0002FFD8L   // no glyph
#define SYV_UNDO                0x0002FFD9L   // u.
#define SYV_COPY                0x0002FFDAL   // c.
#define SYV_CUT                 0x0002FFDBL   // x.
#define SYV_PASTE               0x0002FFDCL   // p.
#define SYV_CLEARWORD           0x0002FFDDL   // no glyph
#define SYV_USER                0x0002FFDEL   // reserved
#define SYV_CORRECT             0x0002FFDFL   // check.

#define SYV_BACKSPACE           0x00020008L   // no glyph
#define SYV_TAB                 0x00020009L   // t.
#define SYV_RETURN              0x0002000DL   // n.
#define SYV_SPACE               0x00020020L   // s.

// Application specific gestures, Circle a-z and Circle A-Z:
#define SYV_APPGESTUREMASK      0x00020000L
#define SYV_CIRCLEUPA           0x000224B6L   // map into Unicode space
#define SYV_CIRCLEUPZ           0x000224CFL   //  for circled letters
#define SYV_CIRCLELOA           0x000224D0L
#define SYV_CIRCLELOZ           0x000224E9L

// SYV definitions for shapes:
#define SYV_SHAPELINE           0x00040001L
#define SYV_SHAPEELLIPSE        0x00040002L
#define SYV_SHAPERECT           0x00040003L
#define SYV_SHAPEMIN            SYV_SHAPELINE // alias
#define SYV_SHAPEMAX            SYV_SHAPERECT // alias

// SYV classes:
#define SYVHI_SPECIAL           0
#define SYVHI_ANSI              1
#define SYVHI_GESTURE           2
#define SYVHI_KANJI             3
#define SYVHI_SHAPE             4
#define SYVHI_UNICODE           5
#define SYVHI_VKEY              6
#endif //!NOPENHRC

//---------------------------------------------------------------------------
#ifndef NOPENIEDIT

// IEdit Pop-up Menu Command Items
#define IEM_UNDO                1          // Undo
#define IEM_CUT                 2          // Cut
#define IEM_COPY                3          // Copy
#define IEM_PASTE               4          // Paste
#define IEM_CLEAR               5          // Clear
#define IEM_SELECTALL           6          // Select All Strokes
#define IEM_ERASE               7          // Use Eraser
#define IEM_PROPERTIES          8          // DoProperties
#define IEM_LASSO               9          // Use Lasso
#define IEM_RESIZE              10         // Resize

#define IEM_USER                    100    // first menu item# available to app

// IEdit Style Attributes
#define IES_BORDER              0x0001   // ctl has a border
#define IES_HSCROLL             0x0002   // ctl is horizontally scrollable
#define IES_VSCROLL             0x0004   // ctl is vertically scrollable
#define IES_OWNERDRAW           0x0008   // ctl will be drawn by parent window

#endif /*!NOPENIEDIT */

#ifndef RC_INVOKED  // ... rest of file of no interest to rc compiler
//////////////////////////////////////////////////////////////////////////////

/****** Definitions 2: RC compiler excluded ********************************/

//---------------------------------------------------------------------------
#ifndef NOPENDATA

// PenData API constants:

// ANIMATEINFO callback options:
#define AI_CBSTROKE             0xFFFF  // Animate callback after every stroke

// ANIMATEINFO options:
#define AI_SKIPUPSTROKES        0x0001  // ignore upstrokes in animation

// CompressPenData() API options:
#define CMPD_COMPRESS           0x0001
#define CMPD_DECOMPRESS         0x0002

// CreatePenDataRegion types:
#define CPDR_BOX                1       // bounding box
#define CPDR_LASSO              2       // lasso

// CreatePenData (CPD) and Pen Hardware (PHW) Flags;
// The order of PHW flags is important:
#define CPD_DEFAULT             0x047F  // CPD_TIME | PHW_ALL
#define CPD_USERBYTE            0x0100  // alloc 8 bits/stroke
#define CPD_USERWORD            0x0200  // alloc 16 bits/stroke
#define CPD_USERDWORD           0x0300  // alloc 32 bits/stroke
#define CPD_TIME                0x0400  // maintain abs time info per stroke

// DrawPenDataEx() flags/options:
#define DPD_HDCPEN              0x0001  // use pen selected in HDC
#define DPD_DRAWSEL             0x0002  // draw the selection

// ExtractPenDataPoints options (EPDP_xx):
#define EPDP_REMOVE             0x0001  // Remove points from the pendata

// ExtractPenDataStrokes options and modifiers (EPDS_xx):
#define EPDS_SELECT             1       // selected strokes
#define EPDS_STROKEINDEX        2       // index
#define EPDS_USER               3       // user-specific value
#define EPDS_PENTIP             4       // complete pentip
#define EPDS_TIPCOLOR           5       // pentip color
#define EPDS_TIPWIDTH           6       // pentip width
#define EPDS_TIPNIB             7       // pentip nib style
#define EPDS_INKSET             8       // inkset match

#define EPDS_EQ                 0x0000  // default: same as
#define EPDS_LT                 0x0010  // all strokes less than
#define EPDS_GT                 0x0020  // all strokes greater than
#define EPDS_NOT                0x0040  // all strokes not matching
#define EPDS_NE                 0x0040  // alias
#define EPDS_GTE                0x0050  // alias for NOT LT
#define EPDS_LTE                0x0060  // alias for NOT GT

#define EPDS_REMOVE             0x8000  // remove matching strokes from source

// GetPenDataAttributes options (GPA_xx):
#define GPA_MAXLEN              1   // length of longest stroke
#define GPA_POINTS              2   // total number of points
#define GPA_PDTS                3   // PDTS_xx bits
#define GPA_RATE                4   // get sampling rate
#define GPA_RECTBOUND           5   // bounding rect of all points
#define GPA_RECTBOUNDINK        6   // ditto, adj for fat ink
#define GPA_SIZE                7   // size of pendata in bytes
#define GPA_STROKES             8   // total number of strokes
#define GPA_TIME                9   // absolute time at creation of pendata
#define GPA_USER                10  // number of user bytes available: 0, 1, 2, 4
#define GPA_VERSION             11  // version number of pendata

// GetStrokeAttributes options (GSA_xx):
#define GSA_PENTIP              1   // get stroke pentip (color, width, nib)
#define GSA_PENTIPCLASS         2   // same as GSA_PENTIP
#define GSA_USER                3   // get stroke user value
#define GSA_USERCLASS           4   // get stroke's class user value
#define GSA_TIME                5   // get time of stroke
#define GSA_SIZE                6   // get size of stroke in points and bytes
#define GSA_SELECT              7   // get selection status of stroke
#define GSA_DOWN                8   // get up/down state of stroke
#define GSA_RECTBOUND           9   // get the bounding rectangle of the stroke

// GetStrokeTableAttributes options (GSA_xx):
#define GSA_PENTIPTABLE         10  // get table-indexed pentip
#define GSA_SIZETABLE           11  // get count of Stroke Class Table entries
#define GSA_USERTABLE           12  // get table-indexed user value

#ifndef IX_END
#define IX_END                  0xFFFF  // to or past last available index
#endif //!IX_END

// PenTip:
#define PENTIP_NIBDEFAULT       ((BYTE)0)       // default pen tip nib style
#define PENTIP_HEIGHTDEFAULT    ((BYTE)0)       // default pen tip nib height
#define PENTIP_OPAQUE           ((BYTE)0xFF)    // default opaque ink
#define PENTIP_HILITE           ((BYTE)0x80)
#define PENTIP_TRANSPARENT      ((BYTE)0)

// General PenData API return values (PDR_xx):
#define PDR_NOHIT               3       // hit test failed
#define PDR_HIT                 2       // hit test succeeded
#define PDR_OK                  1       // success
#define PDR_CANCEL              0       // callback cancel or impasse

#define PDR_ERROR               (-1)    // parameter or unspecified error
#define PDR_PNDTERR             (-2)    // bad pendata
#define PDR_VERSIONERR          (-3)    // pendata version error
#define PDR_COMPRESSED          (-4)    // pendata is compressed
#define PDR_STRKINDEXERR        (-5)    // stroke index error
#define PDR_PNTINDEXERR         (-6)    // point index error
#define PDR_MEMERR              (-7)    // memory error
#define PDR_INKSETERR           (-8)    // bad inkset
#define PDR_ABORT               (-9)    // pendata has become invalid, e.g.
#define PDR_NA                  (-10)   // option not available (pw kernel)

#define PDR_USERDATAERR         (-16)   // user data error
#define PDR_SCALINGERR          (-17)   // scale error
#define PDR_TIMESTAMPERR        (-18)   // timestamp error
#define PDR_OEMDATAERR          (-19)   // OEM data error
#define PDR_SCTERR              (-20)   // SCT error (full)

// PenData Scaling (PDTS):
#define PDTS_LOMETRIC           0       // 0.01mm
#define PDTS_HIMETRIC           1       // 0.001mm
#define PDTS_HIENGLISH          2       // 0.001"
#define PDTS_STANDARDSCALE      2       // PDTS_HIENGLISH   alias
#define PDTS_DISPLAY            3       // display pixel
#define PDTS_ARBITRARY          4       // app-specific scaling
#define PDTS_SCALEMASK          0x000F  // scaling values in low nibble

// CompactPenData() API trim options:
#define PDTT_DEFAULT            0x0000
#define PDTT_PENINFO            0x0100
#define PDTT_UPPOINTS           0x0200
#define PDTT_OEMDATA            0x0400
#define PDTT_COLLINEAR          0x0800
#define PDTT_COLINEAR           0x0800  // alt sp alias
#define PDTT_DECOMPRESS         0x4000  // decompress the data
#define PDTT_COMPRESS           0x8000
#define PDTT_ALL                0x0F00  // PENINFO|UPPOINTS|OEMDATA|COLLINEAR

#define PHW_NONE                0x0000  // no OEMdata
#define PHW_PRESSURE            0x0001  // report pressure in OEMdata if avail
#define PHW_HEIGHT              0x0002  // ditto height
#define PHW_ANGLEXY             0x0004  // ditto xy angle
#define PHW_ANGLEZ              0x0008  // ditto z angle
#define PHW_BARRELROTATION      0x0010  // ditto barrel rotation
#define PHW_OEMSPECIFIC         0x0020  // ditto OEM-specific value
#define PHW_PDK                 0x0040  // report per-point PDK_xx in OEM data
#define PHW_ALL                 0x007F  // report everything

// compact pen data trim options: matches PDTT_values (see above)
#define PDTS_COMPRESS2NDDERIV   0x0010  // compress using 2nd deriv
#define PDTS_COMPRESSMETHOD     0x00F0  // sum of compress method flags
#define PDTS_NOPENINFO          0x0100  // removes PENINFO struct from header
#define PDTS_NOUPPOINTS         0x0200  // remove up pts
#define PDTS_NOOEMDATA          0x0400  // remove OEM data
#define PDTS_NOCOLLINEAR        0x0800  // remove successive identical pts
#define PDTS_NOCOLINEAR         0x0800  // alt sp alias
#define PDTS_NOTICK             0x1000  // remove timing info (2.0)
#define PDTS_NOUSER             0x2000  // remove user info (2.0)
#define PDTS_NOEMPTYSTROKES     0x4000  // remove empty strokes (2.0)
#define PDTS_COMPRESSED         0x8000  // perform lossless compression

// SetStrokeAttributes options (SSA_xx):
#define SSA_PENTIP              1       // set stroke tip (color, width, nib)
#define SSA_PENTIPCLASS         2       // set stroke's class pentip
#define SSA_USER                3       // set stroke user value
#define SSA_USERCLASS           4       // set stroke's class user value
#define SSA_TIME                5       // set time of stroke
#define SSA_SELECT              6       // set selection status of stroke
#define SSA_DOWN                7       // set up/down state of stroke

// SetStrokeTableAttributes options (SSA_xx):
#define SSA_PENTIPTABLE         8       // set table-indexed pentip
#define SSA_USERTABLE           9       // set table-indexed user value

// PenTip flag bits:
#define TIP_ERASECOLOR          1       // erase specific color pentip.rgb

// TrimPenData() API options:
#define TPD_RECALCSIZE          0x0000  // no trim, used for resize calc
#define TPD_USER                0x0080  // per-stroke user info
#define TPD_TIME                0x0100  // per-stroke timing info
#define TPD_UPPOINTS            0x0200  // x-y data up points
#define TPD_COLLINEAR           0x0400  // colinear and coincident points
#define TPD_COLINEAR            0x0400  // alt sp alias
#define TPD_PENINFO             0x0800  // PenInfo struct and all OEM
#define TPD_PHW                 0x1000  // OEM & pdk except stroke tick or user
#define TPD_OEMDATA             0x1000  // ditto
#define TPD_EMPTYSTROKES        0x2000  // strokes with zero points
#define TPD_EVERYTHING          0x3FFF  // everything (incl PHW_xx) except down pts

#endif /*!NOPENDATA */

//---------------------------------------------------------------------------
#ifndef NOPENDICT   // not available in WIN32

// Dictionary:
#define cbDictPathMax           255
#define DIRQ_QUERY              1
#define DIRQ_DESCRIPTION        2
#define DIRQ_CONFIGURE          3
#define DIRQ_OPEN               4
#define DIRQ_CLOSE              5
#define DIRQ_SETWORDLISTS       6
#define DIRQ_STRING             7
#define DIRQ_SUGGEST            8
#define DIRQ_ADD                9
#define DIRQ_DELETE             10
#define DIRQ_FLUSH              11
#define DIRQ_RCCHANGE           12
#define DIRQ_SYMBOLGRAPH        13
#define DIRQ_INIT               14
#define DIRQ_CLEANUP            15
#define DIRQ_COPYRIGHT          16
#define DIRQ_USER               4096
#endif /*!NOPENDICT */

//---------------------------------------------------------------------------
#ifndef NOPENDRIVER

// Pen driver:
#define BITPENUP                0x8000

// Pen Driver messages:
#define DRV_SetPenDriverEntryPoints     DRV_RESERVED+1
#define DRV_SetEntryPoints              DRV_RESERVED+1  // alias
#define DRV_RemovePenDriverEntryPoints  DRV_RESERVED+2
#define DRV_RemoveEntryPoints           DRV_RESERVED+2  // alias
#define DRV_SetPenSamplingRate          DRV_RESERVED+3
#define DRV_SetPenSamplingDist          DRV_RESERVED+4
#define DRV_GetName                     DRV_RESERVED+5
#define DRV_GetVersion                  DRV_RESERVED+6
#define DRV_GetPenInfo                  DRV_RESERVED+7
#define DRV_PenPlayStart                DRV_RESERVED+8
#define DRV_PenPlayBack                 DRV_RESERVED+9
#define DRV_PenPlayStop                 DRV_RESERVED+10
#define DRV_GetCalibration              DRV_RESERVED+11
#define DRV_SetCalibration              DRV_RESERVED+12
#define DRV_Reserved1                   DRV_RESERVED+13
#define DRV_Reserved2                   DRV_RESERVED+14
#define DRV_Query                       DRV_RESERVED+15
#define DRV_GetPenSamplingRate          DRV_RESERVED+16
#define DRV_Calibrate                   DRV_RESERVED+17

// Pen Driver Playback constants:
#define PLAY_VERSION_10_DATA 0
#define PLAY_VERSION_20_DATA 1

// Pen Driver return values:
#define DRV_FAILURE             0x00000000
#define DRV_SUCCESS             0x00000001
#define DRV_BADPARAM1           0xFFFFFFFF
#define DRV_BADPARAM2           0xFFFFFFFE
#define DRV_BADSTRUCT           0xFFFFFFFD

// Pen Driver register messages flags:
#define PENREG_DEFAULT          0x00000002
#define PENREG_WILLHANDLEMOUSE  0x00000001

#define MAXOEMDATAWORDS         6             // rgwOemData[MAXOEMDATAWORDS]

// Pen Collection Mode termination conditions:
// (note update doc for PCMINFO struct if change these)
#define PCM_PENUP               0x00000001L   // stop on penup
#define PCM_RANGE               0x00000002L   // stop on leaving range
#define PCM_INVERT              0x00000020L   // stop on tap of opposite end
#define PCM_RECTEXCLUDE         0x00002000L   // click in exclude rect
#define PCM_RECTBOUND           0x00004000L   // click outside bounds rect
#define PCM_TIMEOUT             0x00008000L   // no activity for timeout ms
// new for 2.0:
#define PCM_RGNBOUND            0x00010000L   // click outside bounding region
#define PCM_RGNEXCLUDE          0x00020000L   // click in exclude region
#define PCM_DOPOLLING           0x00040000L   // polling mode
#define PCM_TAPNHOLD            0x00080000L   // check for Tap And Hold
#define PCM_ADDDEFAULTS         RC_LDEFAULTFLAGS /* 0x80000000L */

// Pen Device Capabilities:
#define PDC_INTEGRATED          0x00000001L   // display==digitizer
#define PDC_PROXIMITY           0x00000002L   // detect non-contacting pen
#define PDC_RANGE               0x00000004L   // event on out-of-range
#define PDC_INVERT              0x00000008L   // pen opposite end detect
#define PDC_RELATIVE            0x00000010L   // pen driver coords
#define PDC_BARREL1             0x00000020L   // barrel button 1 present
#define PDC_BARREL2             0x00000040L   // ditto 2
#define PDC_BARREL3             0x00000080L   // ditto 3

// Pen Driver Kit states:
#define PDK_NULL                0x0000  // default to no flags set
#define PDK_UP                  0x0000  // PDK_NULL alias
#define PDK_DOWN                0x0001  // pentip switch ON due to contact
#define PDK_BARREL1             0x0002  // barrel1 switch depressed
#define PDK_BARREL2             0x0004  // ditto 2
#define PDK_BARREL3             0x0008  // ditto 3
#define PDK_SWITCHES            0x000f  // sum of down + barrels 1,2,3
#define PDK_TRANSITION          0x0010  // set by GetPenHwData
#define PDK_UNUSED10            0x0020
#define PDK_UNUSED20            0x0040
#define PDK_INVERTED            0x0080  // other end of pen used as tip
#define PDK_PENIDMASK           0x0F00  // bits 8..11 physical pen id (0..15)
#define PDK_UNUSED1000          0x1000
#define PDK_INKSTOPPED          0x2000  // Inking stopped
#define PDK_OUTOFRANGE          0x4000  // pen left range (OEM data invalid)
#define PDK_DRIVER              0x8000  // pen (not mouse) event

#define PDK_TIPMASK             0x0001  // mask for testing PDK_DOWN

// OEM-specific values for Pen Driver:
#define PDT_NULL                0
#define PDT_PRESSURE            1       // pressure supported
#define PDT_HEIGHT              2       // height above tablet
#define PDT_ANGLEXY             3       // xy (horiz) angle supported
#define PDT_ANGLEZ              4       // z (vert) angle supported
#define PDT_BARRELROTATION      5       // barrel is rotated
#define PDT_OEMSPECIFIC         16      // max

// Denotes the ID of the current packet
#define PID_CURRENT             (UINT)(-1)

// Recognition and GetPenHwData Returns:
#define REC_OEM                 (-1024) // first recognizer-specific debug val
#define REC_LANGUAGE            (-48)   // unsupported language field
#define REC_GUIDE               (-47)   // invalid GUIDE struct
#define REC_PARAMERROR          (-46)   // bad param
#define REC_INVALIDREF          (-45)   // invalid data ref param
#define REC_RECTEXCLUDE         (-44)   // invalid rect
#define REC_RECTBOUND           (-43)   // invalid rect
#define REC_PCM                 (-42)   // invalid lPcm parameter
#define REC_RESULTMODE          (-41)
#define REC_HWND                (-40)   // invalid window to send results to
#define REC_ALC                 (-39)   // invalid enabled alphabet
#define REC_ERRORLEVEL          (-38)   // invalid errorlevel
#define REC_CLVERIFY            (-37)   // invalid verification level
#define REC_DICT                (-36)   // invalid dict params
#define REC_HREC                (-35)   // invalid recognition handle
#define REC_BADEVENTREF         (-33)   // invalid wEventRef
#define REC_NOCOLLECTION        (-32)   // collection mode not set
#define REC_DEBUG               (-32)   // beginning of debug values
#define REC_POINTEREVENT        (-31)   // tap or tap&hold event
#define REC_BADHPENDATA         (-9)    // invalid hpendata header or locking
#define REC_OOM                 (-8)    // out of memory error
#define REC_NOINPUT             (-7)    // no data collected before termination
#define REC_NOTABLET            (-6)    // tablet not physically present
#define REC_BUSY                (-5)    // another task is using recognizer
#define REC_BUFFERTOOSMALL      (-4)    // ret by GetPenHwEventData()
#define REC_ABORT               (-3)    // recog stopped by EndPenCollection()
#define REC_NA                  (-2)    // function not available
#define REC_OVERFLOW            (-1)    // data overflow
#define REC_OK                  0       // interrim completion
#define REC_TERMBOUND           1       // hit outside bounding rect
#define REC_TERMEX              2       // hit inside exclusion rect
#define REC_TERMPENUP           3       // pen up
#define REC_TERMRANGE           4       // pen left proximity
#define REC_TERMTIMEOUT         5       // no writing for timeout ms
#define REC_DONE                6       // normal completion
#define REC_TERMOEM             512     // first recognizer-specific retval

#endif /*!NOPENDRIVER */

//---------------------------------------------------------------------------
#ifndef NOPENHRC

// Handwriting Recognizer:

// GetResultsHRC options:
#define GRH_ALL                 0       // get all results
#define GRH_GESTURE             1       // get only gesture results
#define GRH_NONGESTURE          2       // get all but gesture results

// Gesture sets for EnableGestureSetHRC (bit flags):
#ifdef JAPAN
#define GST_SEL                 0x00000001L   // sel & lasso
#define GST_CLIP                0x00000002L   // cut copy paste
#define GST_WHITE               0x00000004L   // sp tab ret
#define GST_KKCONVERT           0x00000008L   // kkconvert
#define GST_EDIT                0x00000010L   // insert correct undo clear
#define GST_SYS                 0x0000001FL   // all of the above
#define GST_CIRCLELO            0x00000100L   // lowercase circle
#define GST_CIRCLEUP            0x00000200L   // uppercase circle
#define GST_CIRCLE              0x00000300L   // all circle
#define GST_ALL                 0x0000031FL   // all of the above
#else
#define GST_SEL                 0x00000001L   // sel & lasso
#define GST_CLIP                0x00000002L   // cut copy paste
#define GST_WHITE               0x00000004L   // sp tab ret
#define GST_EDIT                0x00000010L   // insert correct undo clear
#define GST_SYS                 0x00000017L   // all of the above
#define GST_CIRCLELO            0x00000100L   // lowercase circle
#define GST_CIRCLEUP            0x00000200L   // uppercase circle
#define GST_CIRCLE              0x00000300L   // all circle
#define GST_ALL                 0x00000317L   // all of the above
#endif

// General HRC API return values (HRCR_xx):
#define HRCR_NORESULTS          4       // No possible results  to be found
#define HRCR_COMPLETE           3       // finished recognition
#define HRCR_GESTURE            2       // recognized gesture
#define HRCR_OK                 1       // success
#define HRCR_INCOMPLETE         0       // recognizer is processing input
#define HRCR_ERROR              (-1)    // invalid param or unspecified error
#define HRCR_MEMERR             (-2)    // memory error
#define HRCR_INVALIDGUIDE       (-3)    // invalid GUIDE struct
#define HRCR_INVALIDPNDT        (-4)    // invalid pendata
#define HRCR_UNSUPPORTED        (-5)    // recognizer does not support feature
#define HRCR_CONFLICT           (-6)    // training conflict
#define HRCR_HOOKED             (-8)    // hookasaurus ate the result

// system wordlist for AddWordsHWL:
#define HWL_SYSTEM              ((HWL)1)   // magic value means system wordlist

// inkset returns:
#define ISR_ERROR               (-1)    // Memory or other error
#define ISR_BADINKSET           (-2)    // bad source inkset
#define ISR_BADINDEX            (-3)    // bad inkset index

#ifndef IX_END
#define IX_END                  0xFFFF  // to or past last available index
#endif //!IX_END

#define MAXHOTSPOT              8       // max number of hotspots possible

// ProcessHRC time constants:
#define PH_MAX                  0xFFFFFFFFL   // recognize rest of ink
#define PH_DEFAULT              0xFFFFFFFEL   // reasonable time
#define PH_MIN                  0xFFFFFFFDL   // minimum time

// ResultsHookHRC options:
#define RHH_STD                 0       // GetResultsHRC
#define RHH_BOX                 1       // GetBoxResultsHRC

// SetWordlistCoercionHRC options:
#define SCH_NONE                0       // turn off coercion
#define SCH_ADVISE              1       // macro is hint only
#define SCH_FORCE               2       // some result is forced from macro

// Symbol Context Insert Modes
#define SCIM_INSERT             0       // insert
#define SCIM_OVERWRITE          1       // overwrite

// SetResultsHookHREC options:
#define SRH_HOOKALL             (HREC)1 // hook all recognizers

// SetInternationalHRC options:
#define SSH_RD                  1       // to right and down (English)
#define SSH_RU                  2       // to right and up
#define SSH_LD                  3       // to left and down (Hebrew)
#define SSH_LU                  4       // to left and up
#define SSH_DL                  5       // down and to the left (Chinese)
#define SSH_DR                  6       // down and to the right (Chinese)
#define SSH_UL                  7       // up and to the left
#define SSH_UR                  8       // up and to the right

#define SIH_ALLANSICHAR         1       // use all ANSI

// TrainHREC options:
#define TH_QUERY                0       // query the user if conflict
#define TH_FORCE                1       // ditto no query
#define TH_SUGGEST              2       // abandon training if conflict

// Return values for WCR_TRAIN Function
#define TRAIN_NONE              0x0000
#define TRAIN_DEFAULT           0x0001
#define TRAIN_CUSTOM            0x0002
#define TRAIN_BOTH              (TRAIN_DEFAULT | TRAIN_CUSTOM)

// Control values for TRAINSAVE
#define TRAIN_SAVE              0       // save changes that have been made
#define TRAIN_REVERT            1       // discard changes that have been made
#define TRAIN_RESET             2       // use factory settings

// ConfigRecognizer and ConfigHREC options:
#define WCR_RECOGNAME           0       // ConfigRecognizer 1.0
#define WCR_QUERY               1
#define WCR_CONFIGDIALOG        2
#define WCR_DEFAULT             3
#define WCR_RCCHANGE            4
#define WCR_VERSION             5
#define WCR_TRAIN               6
#define WCR_TRAINSAVE           7
#define WCR_TRAINMAX            8
#define WCR_TRAINDIRTY          9
#define WCR_TRAINCUSTOM         10
#define WCR_QUERYLANGUAGE       11
#define WCR_USERCHANGE          12

// ConfigHREC options:
#define WCR_PWVERSION           13      // ver of PenWin recognizer supports
#define WCR_GETALCPRIORITY      14      // get recognizer's ALC priority
#define WCR_SETALCPRIORITY      15      // set recognizer's ALC priority
#define WCR_GETANSISTATE        16      // get ALLANSICHAR state
#define WCR_SETANSISTATE        17      // set ALLANSICHAR if T
#define WCR_GETHAND             18      // get writing hand
#define WCR_SETHAND             19      // set writing hand
#define WCR_GETDIRECTION        20      // get writing direction
#define WCR_SETDIRECTION        21      // set writing direction
#define WCR_INITRECOGNIZER      22      // init recognizer and set user name
#define WCR_CLOSERECOGNIZER     23      // close recognizer

#define WCR_PRIVATE             1024

// sub-functions of WCR_USERCHANGE
#define CRUC_NOTIFY             0       // user name change
#define CRUC_REMOVE             1       // user name deleted

// Word List Types:
#define WLT_STRING              0       // one string
#define WLT_STRINGTABLE         1       // array of strings
#define WLT_EMPTY               2       // empty wordlist
#define WLT_WORDLIST            3       // handle to a wordlist

#endif /*!NOPENHRC */

//---------------------------------------------------------------------------
#ifndef NOPENIEDIT

// IEdit Background Options
#define IEB_DEFAULT             0       // default (use COLOR_WINDOW)
#define IEB_BRUSH               1       // paint background with brush
#define IEB_BIT_UL              2       // bitmap, upper-left aligned
#define IEB_BIT_CENTER          3       // bitmap, centered in control
#define IEB_BIT_TILE            4       // bitmap, tiled repeatedly in ctl
#define IEB_BIT_STRETCH         5       // bitmap, stretched to fit ctl
#define IEB_OWNERDRAW           6       // parent window will draw background

// IEdit Drawing Options
#define IEDO_NONE               0x0000  // no drawing
#define IEDO_FAST               0x0001  // ink drawn as fast as possible (def)
#define IEDO_SAVEUPSTROKES      0x0002  // save upstrokes
#define IEDO_RESERVED           0xFFFC  // reserved bits

// IEdit Input Options
#define IEI_MOVE                0x0001  // move ink into ctl
#define IEI_RESIZE              0x0002  // resize ink to fit within ctl
#define IEI_CROP                0x0004  // discard ink outside of ctl
#define IEI_DISCARD             0x0008  // discard all ink if any outside ctl
#define IEI_RESERVED            0xFFF0  // reserved

// IEdit IE_GETINK options
#define IEGI_ALL                0x0000  // get all ink from control
#define IEGI_SELECTION          0x0001  // get selected ink from control

// IEdit IE_SETMODE/IE_GETMODE (mode) options
#define IEMODE_READY            0       // default inking, moving, sizing mode
#define IEMODE_ERASE            1       // erasing Mode
#define IEMODE_LASSO            2       // lasso selection mode

// IEdit    Notification Bits
#define IEN_NULL                0x0000  // null notification
#define IEN_PDEVENT             0x0001  // notify about pointing device events
#define IEN_PAINT               0x0002  // send painting-related notifications
#define IEN_FOCUS               0x0004  // send focus-related notifications
#define IEN_SCROLL              0x0008  // send scrolling notifications
#define IEN_EDIT                0x0010  // send editing/change notifications
#define IEN_PROPERTIES          0x0020  // send properties dialog notification
#define IEN_RESERVED            0xFF80  // reserved

// IEdit Return Values
#define IER_OK                  0       // success
#define IER_NO                  0       // ctl cannot do request
#define IER_YES                 1       // ctl can do request
#define IER_ERROR               (-1)    // unspecified error; operation failed
#define IER_PARAMERR            (-2)    // bogus lParam value, bad handle, etc
#define IER_OWNERDRAW           (-3)    // can't set drawopts in ownerdraw ctl
#define IER_SECURITY            (-4)    // security protection disallows action
#define IER_SELECTION           (-5)    // nothing selected in control
#define IER_SCALE               (-6)    // merge:  incompatible scaling factors
#define IER_MEMERR              (-7)    // memory error
#define IER_NOCOMMAND           (-8)    // tried IE_GETCOMMAND w/no command
#define IER_NOGESTURE           (-9)    // tried IE_GETGESTURE w/no gesture
#define IER_NOPDEVENT           (-10)   // tried IE_GETPDEVENT but no event
#define IER_NOTINPAINT          (-11)   // tried IE_GETPAINTSTRUCT but no paint
#define IER_PENDATA             (-12)   // can't do request with NULL hpd in ctl

// IEdit Recognition Options
#define IEREC_NONE              0x0000  // No recognition
#define IEREC_GESTURE           0x0001  // Gesture recognition
#define IEREC_ALL               (IEREC_GESTURE)
#define IEREC_RESERVED          0xFFFE  // Reserved

// IEdit Security Options
#define IESEC_NOCOPY            0x0001  // copying disallowed
#define IESEC_NOCUT             0x0002  // cutting disallowed
#define IESEC_NOPASTE           0x0004  // pasting disallowed
#define IESEC_NOUNDO            0x0008  // undoing disallowed
#define IESEC_NOINK             0x0010  // inking  disallowed
#define IESEC_NOERASE           0x0020  // erasing disallowed
#define IESEC_NOGET             0x0040  // IE_GETINK message verboten
#define IESEC_NOSET             0x0080  // IE_SETINK message verboten
#define IESEC_RESERVED          0xFF00  // reserved

// IEdit IE_SETFORMAT/IE_GETFORMAT options
#define IESF_ALL                0x0001  // set/get stk fmt of all ink
#define IESF_SELECTION          0x0002  // set/get stk fmt of selected ink
#define IESF_STROKE             0x0004  // set/get stk fmt of specified stroke
//
#define IESF_TIPCOLOR           0x0008  // set color
#define IESF_TIPWIDTH           0x0010  // set width
#define IESF_PENTIP             (IESF_TIPCOLOR|IESF_TIPWIDTH)
//

// IEdit IE_SETINK options
#define IESI_REPLACE            0x0000  // replace ink in control
#define IESI_APPEND             0x0001  // append ink to existing control ink

// Ink Edit Control (IEdit) definitions
// IEdit Notifications
#define IN_PDEVENT      ((IEN_PDEVENT<<8)|0)   // pointing device event occurred
#define IN_ERASEBKGND   ((IEN_NULL<<8)|1)      // control needs bkgnd erased
#define IN_PREPAINT     ((IEN_PAINT<<8)|2)     // before control paints its ink
#define IN_PAINT        ((IEN_NULL<<8)|3)      // control needs to be painted
#define IN_POSTPAINT    ((IEN_PAINT<<8)|4)     // after control has painted
#define IN_MODECHANGED  ((IEN_EDIT<<8)|5)      // mode changed
#define IN_CHANGE       ((IEN_EDIT<<8)|6)      // contents changed & painted
#define IN_UPDATE       ((IEN_EDIT<<8)|7)      // contents changed & !painted
#define IN_SETFOCUS     ((IEN_FOCUS<<8)|8)     // IEdit is getting focus
#define IN_KILLFOCUS    ((IEN_FOCUS<<8)|9)     // IEdit is losing focus
#define IN_MEMERR       ((IEN_NULL<<8)|10)     // memory error
#define IN_HSCROLL      ((IEN_SCROLL<<8)|11)   // horz scrolled, not painted
#define IN_VSCROLL      ((IEN_SCROLL<<8)|12)   // vert scrolled, not painted
#define IN_GESTURE      ((IEN_EDIT<<8)|13)     // user has gestured on control
#define IN_COMMAND      ((IEN_EDIT<<8)|14)     // command selected from menu
#define IN_CLOSE        ((IEN_NULL<<8)|15)     // I-Edit is being closed
#define IN_PROPERTIES   ((IEN_PROPERTIES<<8)|16) // properties dialog

#endif /*!NOPENIEDIT */

//---------------------------------------------------------------------------
#ifndef NOPENINKPUT

// PenIn[k]put API constants

// Default Processing
#define LRET_DONE               1L
#define LRET_ABORT              (-1L)
#define LRET_HRC                (-2L)
#define LRET_HPENDATA           (-3L)
#define LRET_PRIVATE            (-4L)

// Inkput:
#define PCMR_OK                 0
#define PCMR_ALREADYCOLLECTING  (-1)
#define PCMR_INVALIDCOLLECTION  (-2)
#define PCMR_EVENTLOCK          (-3)
#define PCMR_INVALID_PACKETID   (-4)
#define PCMR_TERMTIMEOUT        (-5)
#define PCMR_TERMRANGE          (-6)
#define PCMR_TERMPENUP          (-7)
#define PCMR_TERMEX             (-8)
#define PCMR_TERMBOUND          (-9)
#define PCMR_APPTERMINATED      (-10)
#define PCMR_TAP                (-11)   // alias PCMR_TAPNHOLD_LAST
#define PCMR_SELECT             (-12)   // ret because of tap & hold
#define PCMR_OVERFLOW           (-13)
#define PCMR_ERROR              (-14)   // parameter or unspecified error
#define PCMR_DISPLAYERR         (-15)   // inking only
#define PCMR_TERMINVERT         (-16)   // termination due to tapping opposite end of pen

#define PII_INKCLIPRECT         0x0001
#define PII_INKSTOPRECT         0x0002
#define PII_INKCLIPRGN          0x0004
#define PII_INKSTOPRGN          0x0008
#define PII_INKPENTIP           0x0010
#define PII_SAVEBACKGROUND      0x0020
#define PII_CLIPSTOP            0x0040

#define PIT_RGNBOUND            0x0001
#define PIT_RGNEXCLUDE          0x0002
#define PIT_TIMEOUT             0x0004
#define PIT_TAPNHOLD            0x0008

#endif /*!NOPENINKPUT */

//---------------------------------------------------------------------------
#ifndef NOPENMISC

// Misc RC Definitions:
#define CL_NULL                 0
#define CL_MINIMUM              1       // minimum confidence level
#define CL_MAXIMUM              100     // max (require perfect recog)
#define cwRcReservedMax         8       // rc.rgwReserved[cwRcReservedMax]
#define ENUM_MINIMUM            1
#define ENUM_MAXIMUM            4096

#define HKP_SETHOOK             0       // SetRecogHook()
#define HKP_UNHOOK              0xFFFF

#define HWR_RESULTS             0
#define HWR_APPWIDE             1

#define iSycNull                (-1)
#define LPDFNULL                ((LPDF)NULL)
#define MAXDICTIONARIES         16      // rc.rglpdf[MAXDICTIONARIES]
#define wPntAll                 (UINT)0xFFFF
#define cbRcLanguageMax         44      // rc.lpLanguage[cbRcLanguageMax]
#define cbRcUserMax             32      // rc.lpUser[cbRcUserMax]
#define cbRcrgbfAlcMax          32      // rc.rgbfAlc[cbRcrgbfAlcMax]
#define RC_WDEFAULT             0xffff
#define RC_LDEFAULT             0xffffffffL
#define RC_WDEFAULTFLAGS        0x8000
#define RC_LDEFAULTFLAGS        0x80000000L

// CorrectWriting() API constants:
// LOWORD values:
#define CWR_REPLACECR           0x0001  // replace carriage ret (\r) with space
#define CWR_STRIPCR             CWR_REPLACECR  // alias for backward compatibility
#define CWR_STRIPLF             0x0002  // strip linefeed (\n)
#define CWR_REPLACETAB          0x0004  // replace tab with space (\t)
#define CWR_STRIPTAB            CWR_REPLACETAB // alias for backward compatibility
#define CWR_SINGLELINEEDIT      (CWR_REPLACECR|CWR_STRIPLF|CWR_REPLACETAB)  // all of the above
#define CWR_INSERT              0x0008  // use "Insert Text" instead of "Edit Text" in the title
#define CWR_TITLE               0x0010  // interpret dwParam as title string
#define CWR_SIMPLE              0x0040  // simple dialog (lens)
#define CWR_HEDIT               0x0080  // HEDIT CorrectWriting
#define CWR_KEYBOARD            0x0100  // keyboard lens
#define CWR_BOXES               0x0200  // bedit lens

// HIWORD values: keyboard types
#define CWRK_DEFAULT            0       // default keyboard type
#define CWRK_BASIC              1       // basic keyboard
#define CWRK_FULL               2       // full keyboard
#define CWRK_NUMPAD             3       // numeric keyboard
#define CWRK_TELPAD             4       // Telephone type keyboard

#ifdef JAPAN
// CorrectWritingEx constants:
#define CBCAPTIONCWX            256 // size of caption buffer
#define CKBCWX                  6   // number of keyboards
#define XCWX                    20  // default position and size
#define YCWX                    20
#define CXCWX                   300
#define CYCWX                   200

// CorrectWritingEx flags:
#define CWX_TOPMOST             0x00000001L
#define CWX_NOTOOLTIPS          0x00000002L
#define CWX_EPERIOD             0x00000004L
#define CWX_ECOMMA              0x00000008L
#define CWX_DEFAULT             0x00000000L

// CorrectWritingEx apply flags - if these bits are set, corresp field used:
#define CWXA_CONTEXT            0x0001 // use cwx.dwFlags
#define CWXA_KBD                0x0002 // use cwx.ixkb
#define CWXA_STATE              0x0004 // use cwx.rgState[]
#define CWXA_PTUL               0x0008 // use cwx.ptUL
#define CWXA_SIZE               0x0010 // use cwx.sizeHW
#define CWXA_NOUPDATEMRU        0x0020 // do not update Most Recently Used

// CorrectWritingEx keyboards:
#define CWXK_HW                 0 // handwriting input
#define CWXK_FIRST              0x0100 // First keyboard, for ordinality
#define CWXK_50                 0x0100 // 50-On kbd
#define CWXK_QWERTY             0x0101 // QWERTY kbd
#define CWXK_NUM                0x0102 // Tel/Num kbd
#define CWXK_KANJI              0x0103 // Kanji kbd
#define CWXK_CODE               0x0104 // Code finder kbd
#define CWXK_YOMI               0x0105 // Yomi ("reading") kbd

// CorrectWritingEx keyboard states:
#define CWXKS_DEFAULT           0xffff   // use existing kbd state
#define CWXKS_ZEN               0
#define CWXKS_HAN               1
#define CWXKS_ROMAZEN           2
#define CWXKS_ROMAHAN           3
#define CWXKS_HIRAZEN           4
#define CWXKS_KATAZEN           5
#define CWXKS_KATAHAN           6

// CorrectWritingEx returns:
#define CWXR_ERROR              -1 // error return
#define CWXR_UNMODIFIED         0  // user pressed cancel button or no change
#define CWXR_MODIFIED           1  // user pressed changed text and OK button
#endif //JAPAN

#ifdef JAPAN
#define GPMI_OK                 0L
#define GPMI_INVALIDPMI         0x8000L
#endif // JAPAN

// inkwidth limits
#define INKWIDTH_MINIMUM        0           // 0 invisible, 1..15 pixel widths
#define INKWIDTH_MAXIMUM        15          // max width in pixels

// Get/SetPenMiscInfo:
// PMI_RCCHANGE is for WM_GLOBALRCCHANGE compatability only:
#define PMI_RCCHANGE            0       // invalid for Get/SetPenMiscInfo

#define PMI_BEDIT               1       // boxed edit info
#ifdef JAPAN
#endif //JAPAN
#define PMI_CXTABLET            3       // tablet width
#define PMI_CYTABLET            4       // tablet height
#define PMI_PENTIP              6       // pen tip: color, width, nib
#define PMI_ENABLEFLAGS         7       // PWE_xx enablements
#define PMI_TIMEOUT             8       // handwriting timeout
#define PMI_TIMEOUTGEST         9       // gesture timeout
#define PMI_TIMEOUTSEL          10      // select (press&hold) timeout
#define PMI_SYSFLAGS            11      // component load configuration
#define PMI_INDEXFROMRGB        12      // color table index from RGB
#define PMI_RGBFROMINDEX        13      // RGB from color table index
#define PMI_SYSREC              14      // handle to system recognizer
#define PMI_TICKREF             15      // reference absolute time

#define PMI_SAVE                0x1000  // save setting to file

#ifdef JAPAN
// GetPenResource options:
#define GPR_CURSPEN             1       // standard pen cursor
#define GPR_CURSCOPY            2       // copy cursor
#define GPR_CURSUNKNOWN         3       // unknown cursor
#define GPR_CURSERASE           4       // erase cursor

#define GPR_BMCRMONO            5       // monochrome Return bitmap
#define GPR_BMLFMONO            6       // monochrome LineFeed bitmap
#define GPR_BMTABMONO           7       // monochrome Tab bitmap
#define GPR_BMDELETE            8       // delete bitmap
#define GPR_BMLENSBTN           9       // lens buttonface bitmap

#ifdef JAPAN
#define GPR_BMHSPMONO           10      // hankaku space bitmap
#define GPR_BMZSPMONO           11      // zenkaku space bitmap
#endif //JAPAN

#endif //JAPAN

// Set/GetPenMiscInfo/PMI_ENABLEFLAGS flags:
#define PWE_AUTOWRITE           0x0001  // pen functionality where IBeam
#define PWE_ACTIONHANDLES       0x0002  // action handles in controls
#define PWE_INPUTCURSOR         0x0004  // show cursor while writing
#define PWE_LENS                0x0008  // allow lens popup

// GetPenMiscInfo/PMI_SYSFLAGS flags:
#define PWF_RC1                 0x0001  // Windows for Pen 1.0 RC support
#define PWF_PEN                 0x0004  // pen drv loaded & hdwe init'd
#define PWF_INKDISPLAY          0x0008  // ink-compatible display drv loaded
#define PWF_RECOGNIZER          0x0010  // system recognizer installed
#define PWF_BEDIT               0x0100  // boxed edit support
#define PWF_HEDIT               0x0200  // free input edit support
#define PWF_IEDIT               0x0400  // ink edit support
#define PWF_ENHANCED            0x1000  // enh features (gest, 1ms timing)
#define PWF_FULL\
	PWF_RC1|PWF_PEN|PWF_INKDISPLAY|PWF_RECOGNIZER|\
	PWF_BEDIT|PWF_HEDIT |PWF_IEDIT|PWF_ENHANCED

// SetPenAppFlags() / RegisterPenApp() API constants:
#define RPA_DEFAULT             0x0001  // == RPA_HEDIT
#define RPA_HEDIT               0x0001  // convert EDIT to HEDIT
#define RPA_KANJIFIXEDBEDIT     0x0002
#define RPA_DBCSPRIORITY        0x0004  // assume DBCS has priority (Japan)
#define RPA_SBCSPRIORITY        0x0008  // assume SBCS has priority (Japan)

#define PMIR_OK                 0L
#define PMIR_INDEX              (-1L)
#define PMIR_VALUE              (-2L)
#define PMIR_INVALIDBOXEDITINFO (-3L)
#define PMIR_INIERROR           (-4L)
#define PMIR_ERROR              (-5L)
#define PMIR_NA                 (-6L)

#ifdef JAPAN
#define SPMI_OK                 0L
#define SPMI_INVALIDBOXEDITINFO 1L
#define SPMI_INIERROR           2L
#define SPMI_INVALIDPMI         0x8000L
#endif //JAPAN

#endif /*!NOPENMISC */

//---------------------------------------------------------------------------
#ifndef NOPENRC1    // not available in WIN32

// RC Options and Flags:
// GetGlobalRC() API return codes:
#define GGRC_OK                 0       // no err
#define GGRC_DICTBUFTOOSMALL    1       // lpDefDict buffer too small for path
#define GGRC_PARAMERROR         2       // invalid params: call ignored
#define GGRC_NA                 3       // function not available

// RC Direction:
#define RCD_DEFAULT             0       // def none
#define RCD_LR                  1       // left to right like English
#define RCD_RL                  2       // right to left like Arabic
#define RCD_TB                  3       // top to bottom like Japanese
#define RCD_BT                  4       // bottom to top like some Chinese

// RC International Preferences:
#define RCIP_ALLANSICHAR        0x0001  // all ANSI chars
#define RCIP_MASK               0x0001

// RC Options:
#define RCO_NOPOINTEREVENT      0x00000001L   // no recog tap, tap/hold
#define RCO_SAVEALLDATA         0x00000002L   // save pen data like upstrokes
#define RCO_SAVEHPENDATA        0x00000004L   // save pen data for app
#define RCO_NOFLASHUNKNOWN      0x00000008L   // no ? cursor on unknown
#define RCO_TABLETCOORD         0x00000010L   // tablet coords used in RC
#define RCO_NOSPACEBREAK        0x00000020L   // no space break recog -> dict
#define RCO_NOHIDECURSOR        0x00000040L   // display cursor during inking
#define RCO_NOHOOK              0x00000080L   // disallow ink hook (passwords)
#define RCO_BOXED               0x00000100L   // valid rc.guide provided
#define RCO_SUGGEST             0x00000200L   // for dict suggest
#define RCO_DISABLEGESMAP       0x00000400L   // disable gesture mapping
#define RCO_NOFLASHCURSOR       0x00000800L   // no cursor feedback
#define RCO_BOXCROSS            0x00001000L   // show + at boxedit center
#define RCO_COLDRECOG           0x00008000L   // result is from cold recog
#define RCO_SAVEBACKGROUND      0x00010000L   // Save background from ink
#define RCO_DODEFAULT           0x00020000L   // do default gesture processing

// RC Orientation of Tablet:
#define RCOR_NORMAL             1       // tablet not rotated
#define RCOR_RIGHT              2       // rotated 90 deg anticlockwise
#define RCOR_UPSIDEDOWN         3       // rotated 180 deg
#define RCOR_LEFT               4       // rotated 90 deg clockwise

// RC Preferences:
#define RCP_LEFTHAND            0x0001  // left handed input
#define RCP_MAPCHAR             0x0004  // fill in syg.lpsyc (ink) for training

// RCRESULT wResultsType values:
#define RCRT_DEFAULT            0x0000  // normal ret
#define RCRT_UNIDENTIFIED       0x0001  // result contains unidentified results
#define RCRT_GESTURE            0x0002  // result is a gesture
#define RCRT_NOSYMBOLMATCH      0x0004  // nothing recognized (no ink match)
#define RCRT_PRIVATE            0x4000  // recognizer-specific symbol
#define RCRT_NORECOG            0x8000  // no recog attempted, only data ret
#define RCRT_ALREADYPROCESSED   0x0008  // GestMgr hooked it
#define RCRT_GESTURETRANSLATED  0x0010  // GestMgr translated it to ANSI value
#define RCRT_GESTURETOKEYS      0x0020  // ditto to set of virtual keys

// RC Result Return Mode specification:
#define RRM_STROKE              0       // return results after each stroke
#define RRM_SYMBOL              1       // per symbol (e.g. boxed edits)
#define RRM_WORD                2       // on recog of a word
#define RRM_NEWLINE             3       // on recog of a line break
#define RRM_COMPLETE            16      // on PCM_xx specified completion

// SetGlobalRC() API return code flags:
#define SGRC_OK                 0x0000  // no err
#define SGRC_USER               0x0001  // invalid User name
#define SGRC_PARAMERROR         0x0002  // param error: call ignored
#define SGRC_RC                 0x0004  // supplied RC has errors
#define SGRC_RECOGNIZER         0x0008  // DefRecog name invalid
#define SGRC_DICTIONARY         0x0010  // lpDefDict path invalid
#define SGRC_INIFILE            0x0020  // error saving to penwin.ini
#define SGRC_NA                 0x8000  // function not available

#endif /*!NOPENRC1 */

//---------------------------------------------------------------------------

#ifndef NOPENTARGET

#define TPT_CLOSEST             0x0001   // Assign to the closest target
#define TPT_INTERSECTINK        0x0002   // target with intersecting ink
#define TPT_TEXTUAL             0x0004   // apply textual heuristics
#define TPT_DEFAULT             (TPT_TEXTUAL | TPT_INTERSECTINK | TPT_CLOSEST)

#endif /*!NOPENTARGET */

//---------------------------------------------------------------------------
#ifndef NOPENVIRTEVENT

// Virtual Event Layer:
#define VWM_MOUSEMOVE           0x0001
#define VWM_MOUSELEFTDOWN       0x0002
#define VWM_MOUSELEFTUP         0x0004
#define VWM_MOUSERIGHTDOWN      0x0008
#define VWM_MOUSERIGHTUP        0x0010
#endif /*!NOPENVIRTEVENT */

#endif /* RC_INVOKED */  // ... all the way back from definitions:2

/****** Messages and Defines ************************************************/

// Windows Messages WM_PENWINFIRST (0x0380) and WM_PENWINLAST (0x038F)
// are defined in WINDOWS.H and WINMIN.H

//---------------------------------------------------------------------------
#ifndef NOPENMSGS

#ifndef NOPENRC1    // not available in WIN32
#define WM_RCRESULT             (WM_PENWINFIRST+1)  // 0x381
#define WM_HOOKRCRESULT         (WM_PENWINFIRST+2)  // 0x382
#endif /*!NOPENRC1*/

#define WM_PENMISCINFO          (WM_PENWINFIRST+3)  // 0x383
#define WM_GLOBALRCCHANGE       (WM_PENWINFIRST+3)  // alias

#ifndef NOPENAPPS   // not available in WIN32
#define WM_SKB                  (WM_PENWINFIRST+4)  // 0x384
#endif /*!NOPENAPPS */

#define WM_PENCTL               (WM_PENWINFIRST+5)  // 0x385
#define WM_HEDITCTL             (WM_PENWINFIRST+5)  // FBC: alias

// WM_HEDITCTL (WM_PENCTL) wParam options:
#ifndef _WIN32
#define HE_GETRC                3       // FBC: get RC from HEDIT/BEDIT control
#define HE_SETRC                4       // FBC: ditto set
#define HE_GETINFLATE           5       // FBC: get inflate rect
#define HE_SETINFLATE           6       // FBC: ditto set
#endif //!_WIN32
#define HE_GETUNDERLINE         7       // get underline mode
#define HE_SETUNDERLINE         8       // ditto set
#define HE_GETINKHANDLE         9       // get handle to captured ink
#define HE_SETINKMODE           10      // begin HEDIT cold recog mode
#define HE_STOPINKMODE          11      // end cold recog mode
#ifndef _WIN32
#define HE_GETRCRESULTCODE      12      // FBC: result of recog after HN_ENDREC
#endif //!_WIN32
#define HE_DEFAULTFONT          13      // switch BEDIT to def font
#define HE_CHARPOSITION         14      // BEDIT byte offset -> char position
#define HE_CHAROFFSET           15      // BEDIT char position -> byte offset
#define HE_GETBOXLAYOUT         20      // get BEDIT layout
#define HE_SETBOXLAYOUT         21      // ditto set
#ifndef _WIN32
#define HE_GETRCRESULT          22      // FBC: get RCRESULT after HN_RCRESULT
#endif //!_WIN32
#ifdef JAPAN
#define HE_KKCONVERT            30      // JPN start kana-kanji conversion
#define HE_GETKKCONVERT         31      // JPN get KK state
#define HE_CANCELKKCONVERT      32      // JPN cancel KK conversion
#define HE_FIXKKCONVERT         33      // JPN force KK result
#define HE_GETKKSTATUS          34      // JPN get KK UI state
#define HE_SETCONVERTRANGE      35      // JPN set a range of DCS
#define HE_GETCONVERTRANGE      36      // JPN get a range of DCS
#define HE_PUTCONVERTCHAR       37      // JPN put a char of DCS
#endif //JAPAN
#define HE_ENABLEALTLIST        40      // en/disable dropdown recog alt's
#define HE_SHOWALTLIST          41      // show dropdown (assume enabled)
#define HE_HIDEALTLIST          42      // hide dropdown alternatives
#ifndef JAPAN
#define HE_GETLENSTYPE          43      // get lens type: CWR_ and CWRK_ flags
#define HE_SETLENSTYPE          44      // set lens type: CWR_ and CWRK_ flags
#endif //!JAPAN

#ifdef JAPAN
//------------------------------
// JPN Kana-to-Kanji conversion subfunctions:
#define HEKK_DEFAULT            0       // def
#define HEKK_CONVERT            1       // convert in place
#define HEKK_CANDIDATE          2       // start conversion dialog
#define HEKK_DBCSCHAR           3       // convert to DBCS
#define HEKK_SBCSCHAR           4       // convert to SBCS
#define HEKK_HIRAGANA           5       // convert to hiragana
#define HEKK_KATAKANA           6       // convert to katakana

//------------------------------
// JPN Return value of HE_GETKKSTATUS
#define HEKKR_NOCONVERT         0       // in no  conversion mode
#define HEKKR_PRECONVERT        1       // in pre conversion mode
#define HEKKR_CONVERT           2       // in mid conversion mode
#endif //JAPAN

// HE_STOPINKMODE (stop cold recog) options:
#define HEP_NORECOG             0       // don't recog ink
#define HEP_RECOG               1       // recog ink
#define HEP_WAITFORTAP          2       // recog after tap in window

// WM_PENCTL notifications:
#define HN_ENDREC               4       // recog complete
#define HN_DELAYEDRECOGFAIL     5       // HE_STOPINKMODE (cold recog) failed
#define HN_RESULT               20      // HEDIT/BEDIT has received new ink/recognition result
#ifndef _WIN32
#define HN_RCRESULT             HN_RESULT
#endif //!_WIN32
#ifdef JAPAN
#define HN_ENDKKCONVERT         30      // JPN KK conversion complete
#endif //JAPAN
#define HN_BEGINDIALOG          40      // Lens/EditText/garbage detection dialog
					//  is about to come up on this hedit/bedit
#define HN_ENDDIALOG            41      // Lens/EditText/garbage detection dialog
					//  has just been destroyed

//------------------------------
#ifndef NOPENIEDIT

// Messages common with other controls:
#define IE_GETMODIFY          (EM_GETMODIFY)    // gets the mod'n (dirty) bit
#define IE_SETMODIFY          (EM_SETMODIFY)    // sets the mod'n (dirty) bit
#define IE_CANUNDO            (EM_CANUNDO)      // queries whether can undo
#define IE_UNDO               (EM_UNDO)         // undo
#define IE_EMPTYUNDOBUFFER    (EM_EMPTYUNDOBUFFER) // clears IEDIT undo buffer

#define IE_MSGFIRST           (WM_USER+150)     // 0x496 == 1174

// IEdit common messages:
#define IE_GETINK             (IE_MSGFIRST+0)   // gets ink from the control
#define IE_SETINK             (IE_MSGFIRST+1)   // sets ink into the control
#define IE_GETPENTIP          (IE_MSGFIRST+2)   // gets the cur def ink pentip
#define IE_SETPENTIP          (IE_MSGFIRST+3)   // sets the cur def ink pentip
#define IE_GETERASERTIP       (IE_MSGFIRST+4)   // gets the cur eraser pentip
#define IE_SETERASERTIP       (IE_MSGFIRST+5)   // sets the cur eraser pentip
#define IE_GETBKGND           (IE_MSGFIRST+6)   // gets the bkgnd options
#define IE_SETBKGND           (IE_MSGFIRST+7)   // sets the bkgnd options
#define IE_GETGRIDORIGIN      (IE_MSGFIRST+8)   // gets the bkgnd grid origin
#define IE_SETGRIDORIGIN      (IE_MSGFIRST+9)   // sets the bkgnd grid origin
#define IE_GETGRIDPEN         (IE_MSGFIRST+10)  // gets the bkgnd grid pen
#define IE_SETGRIDPEN         (IE_MSGFIRST+11)  // sets the bkgnd grid pen
#define IE_GETGRIDSIZE        (IE_MSGFIRST+12)  // gets the bkgnd grid size
#define IE_SETGRIDSIZE        (IE_MSGFIRST+13)  // sets the bkgnd grid size
#define IE_GETMODE            (IE_MSGFIRST+14)  // gets the current pen mode
#define IE_SETMODE            (IE_MSGFIRST+15)  // sets the current pen mode
#define IE_GETINKRECT         (IE_MSGFIRST+16)  // gets the rectbound of the ink

// IEdit-specific messages:
#define IE_GETAPPDATA         (IE_MSGFIRST+34)  // gets the user-defined datum
#define IE_SETAPPDATA         (IE_MSGFIRST+35)  // sets the user-defined data
#define IE_GETDRAWOPTS        (IE_MSGFIRST+36)  // gets the ink draw options
#define IE_SETDRAWOPTS        (IE_MSGFIRST+37)  // sets the ink options
#define IE_GETFORMAT          (IE_MSGFIRST+38)  // gets format of stroke(s)
#define IE_SETFORMAT          (IE_MSGFIRST+39)  // sets format of stroke(s)
#define IE_GETINKINPUT        (IE_MSGFIRST+40)  // gets the ink input option
#define IE_SETINKINPUT        (IE_MSGFIRST+41)  // sets the ink input option
#define IE_GETNOTIFY          (IE_MSGFIRST+42)  // gets the notification bits
#define IE_SETNOTIFY          (IE_MSGFIRST+43)  // sets the notification bits
#define IE_GETRECOG           (IE_MSGFIRST+44)  // gets recognition options
#define IE_SETRECOG           (IE_MSGFIRST+45)  // sets recognition options
#define IE_GETSECURITY        (IE_MSGFIRST+46)  // gets the security options
#define IE_SETSECURITY        (IE_MSGFIRST+47)  // sets the security options
#define IE_GETSEL             (IE_MSGFIRST+48)  // gets sel status of a stroke
#define IE_SETSEL             (IE_MSGFIRST+49)  // sets sel status of a stroke
#define IE_DOCOMMAND          (IE_MSGFIRST+50)  // send command to IEdit
#define IE_GETCOMMAND         (IE_MSGFIRST+51)  // gets user command
#define IE_GETCOUNT           (IE_MSGFIRST+52)  // gets count of strks in I-Edit
#define IE_GETGESTURE         (IE_MSGFIRST+53)  // gets details on user gesture
#define IE_GETMENU            (IE_MSGFIRST+54)  // gets handle to pop-up menu
#define IE_GETPAINTDC         (IE_MSGFIRST+55)  // gets the HDC for painting
#define IE_GETPDEVENT         (IE_MSGFIRST+56)  // gets details of last pd event
#define IE_GETSELCOUNT        (IE_MSGFIRST+57)  // gets count of selected strks
#define IE_GETSELITEMS        (IE_MSGFIRST+58)  // gets indices of all sel strks
#define IE_GETSTYLE           (IE_MSGFIRST+59)  // gets IEdit control styles

#endif /*!NOPENIEDIT */

//------------------------------
#ifndef NOPENHEDIT

// (H)Edit Control:
// CTLINITHEDIT.dwFlags values
#define CIH_NOGDMSG           0x0001  // disable garbage detection message box for this edit
#define CIH_NOACTIONHANDLE    0x0002  // disable action handles for this edit
#define CIH_NOEDITTEXT        0x0004  // disable Lens/Edit/Insert text for this edit
#define CIH_NOFLASHCURSOR     0x0008  // don't flash cursor on tap-n-hold in this (h)edit

#endif /* !NOPENHEDIT */

//------------------------------
#ifndef NOPENBEDIT

// Boxed Edit Control:
// box edit alternative list:
#define HEAL_DEFAULT            -1L     // AltList def value for lParam

// box edit Info:
#define BEI_FACESIZE            32      // max size of font name, = LF_FACESIZE
#define BEIF_BOXCROSS           0x0001

// box edit size:
#define BESC_DEFAULT            0
#define BESC_ROMANFIXED         1
#define BESC_KANJIFIXED         2
#define BESC_USERDEFINED        3

// CTLINITBEDIT.wFlags values
#define CIB_NOGDMSG           0x0001  // disable garbage detection message box for this bedit
#define CIB_NOACTIONHANDLE    0x0002  // disable action handles for this bedit
#define CIB_NOFLASHCURSOR     0x0004  // don't flash cursor on tap-n-hold in this bedit
#ifdef JAPAN
#define CIB_NOWRITING         0x0010  // disallow pen input into control
#endif // JAPAN

#define BXD_CELLWIDTH           12
#define BXD_CELLHEIGHT          16
#define BXD_BASEHEIGHT          13
#define BXD_BASEHORZ            0
#define BXD_MIDFROMBASE         0
#define BXD_CUSPHEIGHT          2
#define BXD_ENDCUSPHEIGHT       4

#define BXDK_CELLWIDTH          32
#define BXDK_CELLHEIGHT         32
#define BXDK_BASEHEIGHT         28
#define BXDK_BASEHORZ           0
#define BXDK_MIDFROMBASE        0
#define BXDK_CUSPHEIGHT         28
#define BXDK_ENDCUSPHEIGHT      10

#endif /*!NOPENBEDIT */

#define WM_PENMISC              (WM_PENWINFIRST+6)  // 0x386

// WM_PENMISC message constants:
#define PMSC_BEDITCHANGE        1       // broadcast when BEDIT changes
#ifndef _WIN32
//#define PMSC_PENUICHANGE      2       // JPN broadcast when PENUI changes
//#define PMSC_SUBINPCHANGE     3       // JPN broadcast when SUBINPUT changes
//#define PMSC_KKCTLENABLE      4       // JPN
#endif //!_WIN32
#define PMSC_GETPCMINFO         5       // query the window's PCMINFO
#define PMSC_SETPCMINFO         6       // set the window's PCMINFO
#define PMSC_GETINKINGINFO      7       // query the window's INKINGINFO
#define PMSC_SETINKINGINFO      8       // set the window's INKINGINFO
#define PMSC_GETHRC             9       // query the window's HRC
#define PMSC_SETHRC             10      // set the window's HRC
#define PMSC_GETSYMBOLCOUNT     11      // count of symbols in result recd by window
#define PMSC_GETSYMBOLS         12      // ditto symbols
#define PMSC_SETSYMBOLS         13      // ditto set symbols
#define PMSC_LOADPW             15      // broadcast load state on penwin
#define PMSC_INKSTOP            16

// PMSCL_xx lParam values for PMSC_LOADPW:
#define PMSCL_UNLOADED          0L      // penwin just unloaded
#define PMSCL_LOADED            1L      // penwin just loaded
#define PMSCL_UNLOADING         2L      // penwin about to unload

#define WM_CTLINIT              (WM_PENWINFIRST+7)  // 0x387

// WM_CTLINIT message constants:
#define CTLINIT_HEDIT           1
#define CTLINIT_BEDIT           7
#define CTLINIT_IEDIT           9
#define CTLINIT_MAX             10

#define WM_PENEVENT             (WM_PENWINFIRST+8)  // 0x388

// WM_PENEVENT message values for wParam:
#define PE_PENDOWN              1       // pen tip down
#define PE_PENUP                2       // pen tip went from down to up
#define PE_PENMOVE              3       // pen moved without a tip transition
#define PE_TERMINATING          4       // Peninput about to terminate
#define PE_TERMINATED           5       // Peninput terminated
#define PE_BUFFERWARNING        6       // Buffer half full.
#define PE_BEGININPUT           7       // begin default input
#define PE_SETTARGETS           8       // set target data structure (TARGINFO)
#define PE_BEGINDATA            9       // init message to all targets
#define PE_MOREDATA             10      // target gets more data
#define PE_ENDDATA              11      // termination message to all targets
#define PE_GETPCMINFO           12      // get input collection info
#define PE_GETINKINGINFO        13      // get inking info
#define PE_ENDINPUT             14      // Input termination message to window
					//  starting default input
#define PE_RESULT               15      // sent after ProcessHRC but before GetResultsHRC

#endif /*!NOPENMSGS */

/****** Definitions 3: RC compiler excluded ********************************/

#ifndef RC_INVOKED  // ... rest of file of no interest to rc compiler

//////////////////////////////////////////////////////////////////////////////
/****** Macros **************************************************************/

// misc macros:
//---------------------------------------------------------------------------
#ifndef NOPENDRIVER

#define FPenUpX(x)              ((BOOL)(((x) & BITPENUP) != 0))
#define GetWEventRef()          (LOWORD(GetMessageExtraInfo()))
#endif /*!NOPENDRIVER */

//---------------------------------------------------------------------------
#ifndef NOPENALC

// ALC macros:

#define MpAlcB(lprc,i)          ((lprc)->rgbfAlc[((i) & 0xff) >> 3])
#define MpIbf(i)                ((BYTE)(1 << ((i) & 7)))
#define SetAlcBitAnsi(lprc,i)   do {MpAlcB(lprc,i) |= MpIbf(i);} while (0)
#define ResetAlcBitAnsi(lprc,i) do {MpAlcB(lprc,i) &= ~MpIbf(i);} while (0)
#define IsAlcBitAnsi(lprc, i)   ((MpAlcB(lprc,i) & MpIbf(i)) != 0)
#endif /*!NOPENALC */

//---------------------------------------------------------------------------
#ifndef NOPENDATA

// draw 2.0 pendata using internal stroke formats:
#define DrawPenDataFmt(hdc, lprect, hpndt)\
    DrawPenDataEx(hdc, lprect, hpndt, 0, IX_END, 0, IX_END, NULL, NULL, 0)

#endif /*!NOPENDATA */

//---------------------------------------------------------------------------
#ifndef NOPENHRC

// Handwriting Recognizer:

// Intervals:
// difference of two absolute times (at2 > at1 for positive result):
#define dwDiffAT(at1, at2)\
    (1000L*((at2).sec - (at1).sec) - (DWORD)(at1).ms + (DWORD)(at2).ms)

// comparison of two absolute times (TRUE if at1 < at2):
#define FLTAbsTime(at1, at2)\
    ((at1).sec < (at2).sec || ((at1).sec == (at2).sec && (at1).ms < (at2).ms))

#define FLTEAbsTime(at1, at2)\
    ((at1).sec < (at2).sec || ((at1).sec == (at2).sec && (at1).ms <= (at2).ms))

#define FEQAbsTime(at1, at2)\
    ((at1).sec == (at2).sec && (at1).ms == (at2).ms)

// test if abstime is within an interval:
#define FAbsTimeInInterval(at, lpi)\
    (FLTEAbsTime((lpi)->atBegin, at) && FLTEAbsTime(at, (lpi)->atEnd))

// test if interval (lpiT) is within an another interval (lpiS):
#define FIntervalInInterval(lpiT, lpiS)\
    (FLTEAbsTime((lpiS)->atBegin, (lpiT)->atBegin)\
    && FLTEAbsTime((lpiT)->atEnd, (lpiS)->atEnd))

// test if interval (lpiT) intersects another interval (lpiS):
#define FIntervalXInterval(lpiT, lpiS)\
    (!(FLTAbsTime((lpiT)->atEnd, (lpiS)->atBegin)\
    || FLTAbsTime((lpiS)->atEnd, (lpiT)->atBegin)))

// duration of an LPINTERVAL in ms:
#define dwDurInterval(lpi)  dwDiffAT((lpi)->atBegin, (lpi)->atEnd)

// fill a pointer to an ABSTIME structure from a count of seconds and ms:
#define MakeAbsTime(lpat, sec, ms) do {\
    (lpat)->sec = sec + ((ms) / 1000);\
    (lpat)->ms = (ms) % 1000;\
    } while (0)

// SYV macros:
#define FIsSpecial(syv)         (HIWORD((syv))==SYVHI_SPECIAL)
#define FIsAnsi(syv)            (HIWORD((syv))==SYVHI_ANSI)
#define FIsGesture(syv)         (HIWORD((syv))==SYVHI_GESTURE)
#define FIsKanji(syv)           (HIWORD((syv))==SYVHI_KANJI)
#define FIsShape(syv)           (HIWORD((syv))==SYVHI_SHAPE)
#define FIsUniCode(syv)         (HIWORD((syv))==SYVHI_UNICODE)
#define FIsVKey(syv)            (HIWORD((syv))==SYVHI_VKEY)

#define ChSyvToAnsi(syv)        ((BYTE) (LOBYTE(LOWORD((syv)))))
#define WSyvToKanji(syv)        ((WORD) (LOWORD((syv))))
#define SyvCharacterToSymbol(c) ((LONG)(unsigned char)(c) | 0x00010000)
#define SyvKanjiToSymbol(c)     ((LONG)(UINT)(c) | 0x00030000)

#define FIsSelectGesture(syv)   \
   ((syv) >= SYVSELECTFIRST && (syv) <= SYVSELECTLAST)

#define FIsStdGesture(syv)      \
   (                            \
   FIsSelectGesture(syv)        \
   || (syv)==SYV_CLEAR          \
   || (syv)==SYV_HELP           \
   || (syv)==SYV_EXTENDSELECT   \
   || (syv)==SYV_UNDO           \
   || (syv)==SYV_COPY           \
   || (syv)==SYV_CUT            \
   || (syv)==SYV_PASTE          \
   || (syv)==SYV_CLEARWORD      \
   || (syv)==SYV_KKCONVERT      \
   || (syv)==SYV_USER           \
   || (syv)==SYV_CORRECT        \
   )

#define FIsAnsiGesture(syv) \
   (                            \
   (syv) == SYV_BACKSPACE       \
   || (syv) == SYV_TAB          \
   || (syv) == SYV_RETURN       \
   || (syv) == SYV_SPACE        \
   )

#endif /*!NOPENHRC */

//---------------------------------------------------------------------------
#ifndef NOPENINKPUT

#define SubPenMsgFromWpLp(wp, lp)       (LOWORD(wp))
#ifdef _WIN32
#define EventRefFromWpLp(wp, lp)        (HIWORD(wp))
#define TerminationFromWpLp(wp, lp)     ((int)HIWORD(wp))
#define HpcmFromWpLp(wp, lp)            ((HPCM)(lp))
#else
#define EventRefFromWpLp(wp, lp)        (LOWORD(lp))
#define TerminationFromWpLp(wp, lp)     ((int)LOWORD(lp))
#define HpcmFromWpLp(wp, lp)            ((HPCM)HIWORD(lp))
#endif //_WIN32

#endif   /*!NOPENINKPUT*/

//---------------------------------------------------------------------------
#ifndef NOPENTARGET
#define HwndFromHtrg(htrg)      ((HWND)(DWORD)(htrg))
#define HtrgFromHwnd(hwnd)      ((HTRG)(UINT)(hwnd))
#endif /*!NOPENTARGET*/

//////////////////////////////////////////////////////////////////////////////
/****** Typedefs ************************************************************/

// Simple:
typedef LONG                    ALC;    // Enabled Alphabet
typedef int                     CL;     // Confidence Level
typedef UINT                    HKP;    // Hook Parameter
typedef int                     REC;    // recognition result
typedef LONG                    SYV;    // Symbol Value

#ifndef DECLARE_HANDLE32
#define DECLARE_HANDLE32(name)\
    struct name##__ { int unused; };\
    typedef const struct name##__ FAR* name
#endif //!DECLARE_HANDLE32

DECLARE_HANDLE32(HTRG);                 // Handle to target
DECLARE_HANDLE(HPCM);                   // Handle to Pen Collection Info
DECLARE_HANDLE(HPENDATA);               // handle to ink
DECLARE_HANDLE(HREC);                   // handle to recognizer

// Pointer Types:
typedef ALC FAR*                LPALC;        // ptr to ALC
typedef LPVOID                  LPOEM;        // alias
typedef SYV FAR*                LPSYV;        // ptr to SYV
typedef HPENDATA FAR*           LPHPENDATA;   // ptr to HPENDATA

// Function Prototypes:
typedef int         (CALLBACK *ENUMPROC)(LPSYV, int, VOID FAR*);
typedef int         (CALLBACK *LPDF)(int, LPVOID, LPVOID, int, DWORD, DWORD);
typedef BOOL        (CALLBACK *RCYIELDPROC)(VOID);

// Structures:

typedef struct tagABSTIME       // 2.0 absolute date/time
   {
   DWORD sec;      // number of seconds since 1/1/1970, ret by CRTlib time() fn
   UINT ms;        // additional offset in ms, 0..999
   }
   ABSTIME, FAR *LPABSTIME;

//---------------------------------------------------------------------------
#ifndef NOPENHEDIT

typedef struct tagCTLINITHEDIT  // 2.0 init struct for (h)edit
   {
   DWORD cbSize;                // sizeof(CTLINITHEDIT)
   HWND hwnd;                   // (h)edit window handle
   int id;                      // its id
   DWORD dwFlags;               // CIE_xx
   DWORD dwReserved;            // for future use
   }
   CTLINITHEDIT, FAR *LPCTLINITHEDIT;
#endif /* !NOPENHEDIT */

//---------------------------------------------------------------------------
#ifndef NOPENBEDIT

typedef struct tagBOXLAYOUT     // 1.0 box edit layout
   {
   int cyCusp;                  // pixel height of box (BXS_RECT) or cusp
   int cyEndCusp;               // pixel height of cusps at extreme ends
   UINT style;                  // BXS_xx style
   DWORD dwReserved1;           // reserved
   DWORD dwReserved2;           // reserved
   DWORD dwReserved3;           // reserved
   }
   BOXLAYOUT, FAR *LPBOXLAYOUT;

typedef struct tagCTLINITBEDIT  // 2.0 init struct for box edit
   {
   DWORD cbSize;                // sizeof(CTLINITBEDIT)
   HWND hwnd;                   // box edit window handle
   int id;                      // its id
   WORD wSizeCategory;          // BESC_xx
   WORD wFlags;                 // CIB_xx
   DWORD dwReserved;            // for future use
   }
   CTLINITBEDIT, FAR *LPCTLINITBEDIT;

typedef struct tagBOXEDITINFO   // 1.1 box edit Size Info
   {
   int cxBox;                   // width of a single box
   int cyBox;                   // ditto height
   int cxBase;                  // in-box x-margin to guideline
   int cyBase;                  // in-box y offset from top to baseline
   int cyMid;                   // 0 or distance from baseline to midline
   BOXLAYOUT boxlayout;         // embedded BOXLAYOUT structure
   UINT wFlags;                 // BEIF_xx
   BYTE szFaceName[BEI_FACESIZE];   // font face name
   UINT wFontHeight;            // font height
   UINT rgwReserved[8];         // for future use
   }
   BOXEDITINFO, FAR *LPBOXEDITINFO;
#endif /*!NOPENBEDIT */

//---------------------------------------------------------------------------
#ifndef NOPENCTL

typedef struct tagRECTOFS       // 1.0 rectangle offset for nonisometric inflation
   {
   int dLeft;                   // inflation leftwards from left side
   int dTop;                    // ditto upwards from top
   int dRight;                  // ditto rightwards from right
   int dBottom;                 // ditto downwards from bottom
   }
   RECTOFS, FAR *LPRECTOFS;
#endif /*!NOPENCTL */

//---------------------------------------------------------------------------
#ifndef NOPENDATA

typedef struct tagPENDATAHEADER // 1.0 main pen data header
   {
   UINT wVersion;               // pen data format version
   UINT cbSizeUsed;             // size of pendata mem block in bytes
   UINT cStrokes;               // number of strokes (incl up-strokes)
   UINT cPnt;                   // count of all points
   UINT cPntStrokeMax;          // length (in points) of longest stroke
   RECT rectBound;              // bounding rect of all down points
   UINT wPndts;                 // PDTS_xx bits
   int  nInkWidth;              // ink width in pixels
   DWORD rgbInk;                // ink color
   }
   PENDATAHEADER, FAR *LPPENDATAHEADER, FAR *LPPENDATA;

typedef struct tagSTROKEINFO    // 1.0 stroke header
   {
   UINT cPnt;                   // count of points in stroke
   UINT cbPnts;                 // size of stroke in bytes
   UINT wPdk;                   // state of stroke
   DWORD dwTick;                // time at beginning of stroke
   }
   STROKEINFO, FAR *LPSTROKEINFO;

typedef struct tagPENTIP        // 2.0 Pen Tip characteristics
    {
    DWORD cbSize;               // sizeof(PENTIP)
    BYTE btype;                 // pen type/nib (calligraphic nib, etc.)
    BYTE bwidth;                // width of Nib (typically == nInkWidth)
    BYTE bheight;               // height of Nib
    BYTE bOpacity;              // 0=transparent, 0x80=hilite, 0xFF=opaque
    COLORREF rgb;               // pen color
    DWORD dwFlags;              // TIP_xx flags
    DWORD dwReserved;           // for future expansion
    }
    PENTIP, FAR *LPPENTIP;

typedef BOOL (CALLBACK *ANIMATEPROC)(HPENDATA, UINT, UINT, UINT FAR*, LPARAM);

typedef struct tagANIMATEINFO   // 2.0 Animation parameters
    {
    DWORD cbSize;               // sizeof(ANIMATEINFO)
    UINT uSpeedPct;             // speed percent to animate at
    UINT uPeriodCB;             // time between calls to callback in ms
    UINT fuFlags;               // animation flags
    LPARAM lParam;              // value to pass to callback
    DWORD dwReserved;           // reserved
    }
    ANIMATEINFO, FAR *LPANIMATEINFO;
#endif /*!NOPENDATA */

//---------------------------------------------------------------------------
#ifndef NOPENDRIVER

typedef struct tagOEMPENINFO    // 1.0 OEM pen/tablet hdwe info
   {
   UINT wPdt;                   // pen data type
   UINT wValueMax;              // largest val ret by device
   UINT wDistinct;              // number of distinct readings possible
   }
   OEMPENINFO, FAR *LPOEMPENINFO;

typedef struct tagPENPACKET     // 1.0 pen packet
   {
   UINT wTabletX;               // x in raw coords
   UINT wTabletY;               // ditto y
   UINT wPDK;                   // state bits
   UINT rgwOemData[MAXOEMDATAWORDS]; // OEM-specific data
   }
   PENPACKET, FAR *LPPENPACKET;

typedef struct tagOEM_PENPACKET // 2.0
   {
   UINT wTabletX;               // x in raw coords
   UINT wTabletY;               // ditto y
   UINT wPDK;                   // state bits
   UINT rgwOemData[MAXOEMDATAWORDS];  // OEM-specific data
   DWORD dwTime;
   }
    OEM_PENPACKET, FAR *LPOEM_PENPACKET;

typedef struct tagPENINFO       // 1.0 pen/tablet hdwe info
   {
   UINT cxRawWidth;             // max x coord and tablet width in 0.001"
   UINT cyRawHeight;            // ditto y, height
   UINT wDistinctWidth;         // number of distinct x values tablet ret
   UINT wDistinctHeight;        // ditto y
   int nSamplingRate;           // samples / second
   int nSamplingDist;           // min distance to move before generating event
   LONG lPdc;                   // Pen Device Capabilities
   int cPens;                   // number of pens supported
   int cbOemData;               // width of OEM data packet
   OEMPENINFO rgoempeninfo[MAXOEMDATAWORDS]; // supported OEM data types
   UINT rgwReserved[7];         // for internal use
   UINT fuOEM;                  // which OEM data, timing, PDK_xx to report
   }
   PENINFO, FAR *LPPENINFO;

typedef struct tagCALBSTRUCT    // 1.0 pen calibration
   {
   int wOffsetX;
   int wOffsetY;
   int wDistinctWidth;
   int wDistinctHeight;
   }
   CALBSTRUCT, FAR *LPCALBSTRUCT;

typedef BOOL (CALLBACK *LPFNRAWHOOK)(LPPENPACKET);
#endif /*!NOPENDRIVER */

//---------------------------------------------------------------------------
#ifndef NOPENHRC

// Handwriting Recognizer:

DECLARE_HANDLE32(HRC);          // Handwriting Recognition Context
DECLARE_HANDLE32(HRCRESULT);    // HRC result
DECLARE_HANDLE32(HWL);          // Handwriting wordlist
DECLARE_HANDLE32(HRECHOOK);     // Recognition Result hook handle

typedef HRC                     FAR *LPHRC;
typedef HRCRESULT               FAR *LPHRCRESULT;
typedef HWL                     FAR *LPHWL;

typedef BOOL (CALLBACK *HRCRESULTHOOKPROC)
    (HREC, HRC, UINT, UINT, UINT, LPVOID);

// Inksets:
DECLARE_HANDLE(HINKSET);        // handle to an inkset
typedef HINKSET                 FAR* LPHINKSET; // ptr to HINKSET

typedef struct tagINTERVAL      // 2.0 interval structure for inksets
    {
    ABSTIME atBegin;            // begining of 1-ms granularity interval
    ABSTIME atEnd;              // 1 ms past end of interval
    }
    INTERVAL, FAR *LPINTERVAL;

typedef struct tagBOXRESULTS    // 2.0
    {
    UINT indxBox;
    HINKSET hinksetBox;
    SYV rgSyv[1];
    }
    BOXRESULTS, FAR *LPBOXRESULTS;

typedef struct tagGUIDE         // 1.0 guide structure
   {
   int xOrigin;                 // left edge of first box (screen coord))
   int yOrigin;                 // ditto top edge
   int cxBox;                   // width of a single box
   int cyBox;                   // ditto height
   int cxBase;                  // in-box x-margin to guideline
   int cyBase;                  // in-box y offset from top to baseline
   int cHorzBox;                // count of boxed columns
   int cVertBox;                // ditto rows
   int cyMid;                   // 0 or distance from baseline to midline
   }
   GUIDE, FAR *LPGUIDE;

#endif /*!NOPENHRC */

//---------------------------------------------------------------------------
#ifndef NOPENIEDIT

typedef struct tagCTLINITIEDIT  // 2.0 init struct for Ink Edit
    {
    DWORD cbSize;               // sizeof(CTLINITIEDIT)
    HWND hwnd;                  // IEdit window handle
    int id;                     // its ID
    WORD ieb;                   // IEB_* (background) bits
    WORD iedo;                  // IEDO_* (draw options) bits
    WORD iei;                   // IEI_* (ink input) bits
    WORD ien;                   // IEN_* (notification) bits
    WORD ierec;                 // IEREC_* (recognition) bits
    WORD ies;                   // IES_* (style) bits
    WORD iesec;                 // IESEC_* (security) bits
    WORD pdts;                  // initial pendata scale factor (PDTS_*)
    HPENDATA hpndt;             // initial pendata (or NULL if none)
    HGDIOBJ hgdiobj;            // background brush or bitmap handle
    HPEN hpenGrid;              // pen to use in drawing grid
    POINT ptOrgGrid;            // grid lines point of origin
    WORD wVGrid;                // vertical gridline spacing
    WORD wHGrid;                // horizontal gridline spacing
    DWORD dwApp;                // application-defined data
    DWORD dwReserved;           // reserved for future use
    }
    CTLINITIEDIT, FAR *LPCTLINITIEDIT;

typedef struct tagPDEVENT       // 2.0
    {
    DWORD cbSize;               // sizeof(PDEVENT)
    HWND hwnd;                  // window handle of I-Edit
    UINT wm;                    // WM_* (window message) of event
    WPARAM wParam;              // wParam of message
    LPARAM lParam;              // lParam of message
    POINT pt;                   // event pt in I-Edit client co-ords
    BOOL fPen;                  // TRUE if pen (or other inking device)
    LONG lExInfo;               // GetMessageExtraInfo() return value
    DWORD dwReserved;           // for future use
    }
    PDEVENT, FAR *LPPDEVENT;

typedef struct tagSTRKFMT       // 2.0
    {
    DWORD cbSize;               // sizeof(STRKFMT)
    UINT iesf;                  // stroke format flags and return bits
    UINT iStrk;                 // stroke index if IESF_STROKE
    PENTIP tip;                 // ink tip attributes
    DWORD dwUser;               // user data for strokes
    DWORD dwReserved;           // for future use
    }
    STRKFMT, FAR *LPSTRKFMT;
#endif /*!NOPENIEDIT */

//---------------------------------------------------------------------------
#ifndef NOPENINKPUT

typedef struct tagPCMINFO       // 2.0 Pen Collection Mode Information
   {
   DWORD cbSize;                // sizeof(PCMINFO)
   DWORD dwPcm;                 // PCM_xxx flags
   RECT rectBound;              // if finish on pendown outside this rect
   RECT rectExclude;            // if finish on pendown inside this rect
   HRGN hrgnBound;              // if finish on pendown outside this region
   HRGN hrgnExclude;            // if finish on pendown inside this region
   DWORD dwTimeout;             // if finish after timeout, this many ms
   }
    PCMINFO, FAR *LPPCMINFO;

typedef struct tagINKINGINFO    // 2.0 Pen Inking Information
   {
   DWORD cbSize;                // sizeof(INKINGINFO)
   UINT wFlags;                 // One of the PII_xx flags
   PENTIP tip;                  // Pen type, size and color
   RECT rectClip;               // Clipping rect for the ink
   RECT rectInkStop;            // Rect in which a pen down stops inking
   HRGN hrgnClip;               // Clipping region for the ink
   HRGN hrgnInkStop;            // Region in which a pen down stops inking
   }
    INKINGINFO, FAR *LPINKINGINFO;
#endif /*!NOPENINKPUT */

//---------------------------------------------------------------------------
#ifndef NOPENRC1    // not available in WIN32

typedef struct tagSYC           // 1.0 Symbol Correspondence for Ink
   {
   UINT wStrokeFirst;           // first stroke, inclusive
   UINT wPntFirst;              // first point in first stroke, inclusive
   UINT wStrokeLast;            // last stroke, inclusive
   UINT wPntLast;               // last point in last stroke, inclusive
   BOOL fLastSyc;               // T: no more SYCs follow for current SYE
   }
   SYC, FAR *LPSYC;

typedef struct tagSYE           // 1.0 Symbol Element
   {
   SYV syv;                     // symbol value
   LONG lRecogVal;              // for internal use by recognizer
   CL cl;                       // confidence level
   int iSyc;                    // SYC index
   }
   SYE, FAR *LPSYE;

typedef struct tagSYG           // 1.0 Symbol Graph
   {
   POINT rgpntHotSpots[MAXHOTSPOT]; // hot spots (max 8)
   int cHotSpot;                // number of valid hot spots in rgpntHotSpots
   int nFirstBox;               // row-major index to box of 1st char in result
   LONG lRecogVal;              // reserved for use by recoognizer
   LPSYE lpsye;                 // nodes of symbol graph
   int cSye;                    // number of SYEs in symbol graph
   LPSYC lpsyc;                 // ptr to corresp symbol ink
   int cSyc;                    // ditto count
   }
   SYG, FAR *LPSYG;

typedef struct tagRC            // 1.0 Recognition Context (RC)
   {
   HREC hrec;                   // handle of recognizer to use
   HWND hwnd;                   // window to send results to
   UINT wEventRef;              // index into ink buffer
   UINT wRcPreferences;         // flags: RCP_xx Preferences
   LONG lRcOptions;             // RCO_xx options
   RCYIELDPROC lpfnYield;       // procedure called during Yield()
   BYTE lpUser[cbRcUserMax];    // current writer
   UINT wCountry;               // country code
   UINT wIntlPreferences;       // flags: RCIP_xx
   char lpLanguage[cbRcLanguageMax]; // language strings
   LPDF rglpdf[MAXDICTIONARIES];   // list of dictionary functions
   UINT wTryDictionary;         // max enumerations to search
   CL clErrorLevel;             // level where recognizer should reject input
   ALC alc;                     // enabled alphabet
   ALC alcPriority;             // prioritizes the ALC_ codes
   BYTE rgbfAlc[cbRcrgbfAlcMax];   // bit field for enabled characters
   UINT wResultMode;            // RRM_xx when to send (asap or when complete)
   UINT wTimeOut;               // recognition timeout in ms
   LONG lPcm;                   // flags: PCM_xx for ending recognition
   RECT rectBound;              // bounding rect for inking (def:screen coords)
   RECT rectExclude;            // pen down inside this terminates recognition
   GUIDE guide;                 // struct: defines guidelines for recognizer
   UINT wRcOrient;              // RCOR_xx orientation of writing wrt tablet
   UINT wRcDirect;              // RCD_xx direction of writing
   int nInkWidth;               // ink width 0 (none) or 1..15 pixels
   COLORREF rgbInk;             // ink color
   DWORD dwAppParam;            // for application use
   DWORD dwDictParam;           // for app use to be passed on to dictionaries
   DWORD dwRecognizer;          // for app use to be passed on to recognizer
   UINT rgwReserved[cwRcReservedMax]; // reserved for future use by Windows
   }
   RC, FAR *LPRC;

typedef struct tagRCRESULT      // 1.0 Recognition Result
   {
   SYG syg;                     // symbol graph
   UINT wResultsType;           // see RCRT_xx
   int cSyv;                    // count of symbol values
   LPSYV lpsyv;                 // NULL-term ptr to recog's best guess
   HANDLE hSyv;                 // globally-shared handle to lpsyv mem
   int nBaseLine;               // 0 or baseline of input writing
   int nMidLine;                // ditto midline
   HPENDATA hpendata;           // pen data mem
   RECT rectBoundInk;           // ink data bounds
   POINT pntEnd;                // pt that terminated recog
   LPRC lprc;                   // recog context used
   }
   RCRESULT, FAR *LPRCRESULT;

typedef int         (CALLBACK *LPFUNCRESULTS)(LPRCRESULT, REC);

#endif /*!NOPENRC1 */

//---------------------------------------------------------------------------
#ifndef NOPENTARGET

#ifndef _WIN32
#if (WINVER < 0x0400)
#ifndef _OLE2_H_
typedef struct tagRECTL
{
   LONG     left;
   LONG     top;
   LONG     right;
   LONG     bottom;
} RECTL;
typedef RECTL*       PRECTL;
typedef RECTL NEAR*  NPRECTL;
typedef RECTL FAR*   LPRECTL;
typedef const RECTL FAR* LPCRECTL;
#endif // !_OLE2_H_
#endif // WINVER
#endif // !WIN32

typedef struct tagTARGET        // 2.0 Geometry for a single target.
   {
   DWORD dwFlags;               // individual target flags
   DWORD idTarget;              // TARGINFO.rgTarget[] index
   HTRG  htrgTarget;            // HANDLE32 equiv
   RECTL rectBound;             // Bounding rect of the target
   DWORD dwData;                // data collection info per target
   RECTL rectBoundInk;          // Reserved for internal use, must be zero
   RECTL rectBoundLastInk;      // Reserved for internal use, must be zero
   }
   TARGET, FAR *LPTARGET;

typedef struct tagTARGINFO      // 2.0 A set of targets
   {
   DWORD cbSize;                // sizeof(TARGINFO)
   DWORD dwFlags;               // flags
   HTRG htrgOwner;              // HANDLE32 equiv
   WORD cTargets;               // count of targets
   WORD iTargetLast;            // last target, used by TargetPoints API
				// if TPT_TEXTUAL flag is set
   TARGET rgTarget[1];          // variable-length array of targets
   }
   TARGINFO, FAR *LPTARGINFO;

typedef struct tagINPPARAMS     // 2.0
   {
   DWORD cbSize;                // sizeof(INPPARAMS)
   DWORD dwFlags;
   HPENDATA hpndt;
   TARGET target;               // target structure
   }
    INPPARAMS, FAR *LPINPPARAMS;
#endif /*!NOPENTARGET */

#ifdef JAPAN
typedef struct tagCWX           // 2.0
   {
   DWORD cbSize;                // sizeof(CWXSTRUCT): required entry
   WORD wApplyFlags;            // CWXA_xx apply flags (else use MRU settings)
   HWND hwndText;               // text window if different [NULL=use owner]
   HRC hrc;                     // recognition context [def NULL]
   char szCaption[CBCAPTIONCWX];// caption [def {0}]
   DWORD dwEditStyle;           // style for edit control [def 0]
   DWORD dwSel;                 // selection [def 0]

   // these use Most Recent settings unless corresp [wApplyFlags] bit set:
   DWORD dwFlags;               // CWX_xx context flags [CWXA_CONTEXT]
   WORD ixkb;                   // CWXK_xx keyboard [CWXA_KBD]
   WORD rgState[CKBCWX];        // array of keyboard states [CWXA_STATE]
   POINT ptUL;                  // dlg u.l. corner, screen coords [CWXA_PTUL]
   SIZE sizeHW;                 // dlg HW tab size, screen coords [CWXA_SIZE]
   }
   CWX, FAR *LPCWX;

#endif //JAPAN

//////////////////////////////////////////////////////////////////////////////
/****** APIs and Prototypes *************************************************/

LRESULT CALLBACK    DefPenWindowProc(HWND, UINT, WPARAM, LPARAM);

//---------------------------------------------------------------------------
#ifndef NOPENAPPS   // not available in WIN32

// Pen System Applications:
BOOL      WINAPI ShowKeyboard(HWND, UINT, LPPOINT, LPSKBINFO);

#endif /*!NOPENAPPS */

//---------------------------------------------------------------------------
#ifndef NOPENDATA   // these APIs are implemented in PKPD.DLL

// PenData:
#ifndef NOPENAPIFUN
LPPENDATA WINAPI BeginEnumStrokes(HPENDATA);
LPPENDATA WINAPI EndEnumStrokes(HPENDATA);
HPENDATA  WINAPI CompactPenData(HPENDATA, UINT);
HPENDATA  WINAPI CreatePenData(LPPENINFO, int, UINT, UINT);
VOID      WINAPI DrawPenData(HDC, LPRECT, HPENDATA);
BOOL      WINAPI GetPenDataStroke(LPPENDATA, UINT, LPPOINT FAR*,
				  LPVOID FAR*, LPSTROKEINFO);
#endif //!NOPENAPIFUN
HPENDATA  WINAPI AddPointsPenData(HPENDATA, LPPOINT, LPVOID, LPSTROKEINFO);
int       WINAPI CompressPenData(HPENDATA, UINT, DWORD);
HPENDATA  WINAPI CreatePenDataEx(LPPENINFO, UINT, UINT, UINT);
HRGN      WINAPI CreatePenDataRegion(HPENDATA, UINT);
BOOL      WINAPI DestroyPenData(HPENDATA);
int       WINAPI DrawPenDataEx(HDC, LPRECT, HPENDATA, UINT, UINT, UINT, UINT,
			       ANIMATEPROC, LPANIMATEINFO, UINT);
HPENDATA  WINAPI DuplicatePenData(HPENDATA, UINT);
int       WINAPI ExtractPenDataPoints(HPENDATA, UINT, UINT, UINT, LPPOINT,
				      LPVOID, UINT);
int       WINAPI ExtractPenDataStrokes(HPENDATA, UINT, LPARAM,
				       LPHPENDATA, UINT);
int       WINAPI GetPenDataAttributes(HPENDATA, LPVOID, UINT);
BOOL      WINAPI GetPenDataInfo(HPENDATA, LPPENDATAHEADER, LPPENINFO, DWORD);
BOOL      WINAPI GetPointsFromPenData(HPENDATA, UINT, UINT, UINT, LPPOINT);
int       WINAPI GetStrokeAttributes(HPENDATA, UINT, LPVOID, UINT);
int       WINAPI GetStrokeTableAttributes(HPENDATA, UINT, LPVOID, UINT);
int       WINAPI HitTestPenData(HPENDATA, LPPOINT, UINT, UINT FAR*, UINT FAR*);
int       WINAPI InsertPenData(HPENDATA, HPENDATA, UINT);
int       WINAPI InsertPenDataPoints(HPENDATA, UINT, UINT, UINT,
				     LPPOINT, LPVOID);
int       WINAPI InsertPenDataStroke(HPENDATA, UINT, LPPOINT, LPVOID,
				     LPSTROKEINFO);
BOOL      WINAPI MetricScalePenData(HPENDATA, UINT);
BOOL      WINAPI OffsetPenData(HPENDATA, int, int);
LONG      WINAPI PenDataFromBuffer(LPHPENDATA, UINT, LPBYTE, LONG, LPDWORD);
LONG      WINAPI PenDataToBuffer(HPENDATA, LPBYTE, LONG, LPDWORD);
BOOL      WINAPI RedisplayPenData(HDC, HPENDATA, LPPOINT, LPPOINT,
				  int, DWORD);
int       WINAPI RemovePenDataStrokes(HPENDATA, UINT, UINT);
BOOL      WINAPI ResizePenData(HPENDATA, LPRECT);
int       WINAPI SetStrokeAttributes(HPENDATA, UINT, LPARAM, UINT);
int       WINAPI SetStrokeTableAttributes(HPENDATA, UINT, LPARAM, UINT);
int       WINAPI TrimPenData(HPENDATA, DWORD, DWORD);

#endif /*!NOPENDATA */

//---------------------------------------------------------------------------
#ifndef NOPENDICT   // not available in WIN32

// Dictionary:
BOOL      WINAPI DictionarySearch(LPRC, LPSYE, int, LPSYV, int);
#endif /*!NOPENDICT */

//---------------------------------------------------------------------------
#ifndef NOPENDRIVER

// Pen Hardware/Driver:
#ifndef NOPENAPIFUN
BOOL      WINAPI EndPenCollection(REC);
REC       WINAPI GetPenHwData(LPPOINT, LPVOID, int, UINT, LPSTROKEINFO);
REC       WINAPI GetPenHwEventData(UINT, UINT, LPPOINT, LPVOID,
				   int, LPSTROKEINFO);
BOOL      WINAPI SetPenHook(HKP, LPFNRAWHOOK);
VOID      WINAPI UpdatePenInfo(LPPENINFO);
#endif //!NOPENAPIFUN
BOOL      WINAPI GetPenAsyncState(UINT);
BOOL      WINAPI IsPenEvent(UINT, LONG);
#endif /*!NOPENDRIVER */

//---------------------------------------------------------------------------
#ifndef NOPENHRC

// Handwriting Recognizer:
int       WINAPI AddPenDataHRC(HRC, HPENDATA);
int       WINAPI AddPenInputHRC(HRC, LPPOINT, LPVOID, UINT, LPSTROKEINFO);
int       WINAPI AddWordsHWL(HWL, LPSTR, UINT);
int       WINAPI ConfigHREC(HREC, UINT, WPARAM, LPARAM);
HRC       WINAPI CreateCompatibleHRC(HRC, HREC);
HWL       WINAPI CreateHWL(HREC, LPSTR, UINT, DWORD);
HINKSET   WINAPI CreateInksetHRCRESULT(HRCRESULT, UINT, UINT);
HPENDATA  WINAPI CreatePenDataHRC(HRC);
int       WINAPI DestroyHRC(HRC);
int       WINAPI DestroyHRCRESULT(HRCRESULT);
int       WINAPI DestroyHWL(HWL);
int       WINAPI EnableGestureSetHRC(HRC, SYV, BOOL);
int       WINAPI EnableSystemDictionaryHRC(HRC, BOOL);
int       WINAPI EndPenInputHRC(HRC);
int       WINAPI GetAlphabetHRC(HRC, LPALC, LPBYTE);
int       WINAPI GetAlphabetPriorityHRC(HRC, LPALC, LPBYTE);
int       WINAPI GetAlternateWordsHRCRESULT(HRCRESULT, UINT, UINT,
					    LPHRCRESULT, UINT);
int       WINAPI GetBoxMappingHRCRESULT(HRCRESULT, UINT, UINT, UINT FAR*);
int       WINAPI GetBoxResultsHRC(HRC, UINT, UINT, UINT, LPBOXRESULTS, BOOL);
int       WINAPI GetGuideHRC(HRC, LPGUIDE, UINT FAR*);
int       WINAPI GetHotspotsHRCRESULT(HRCRESULT, UINT, LPPOINT, UINT);
HREC      WINAPI GetHRECFromHRC(HRC);
int       WINAPI GetInternationalHRC(HRC, UINT FAR*, LPSTR, UINT FAR*,
				     UINT FAR*);
int       WINAPI GetMaxResultsHRC(HRC);
int       WINAPI GetResultsHRC(HRC, UINT, LPHRCRESULT, UINT);
int       WINAPI GetSymbolCountHRCRESULT(HRCRESULT);
int       WINAPI GetSymbolsHRCRESULT(HRCRESULT, UINT, LPSYV, UINT);
int       WINAPI GetWordlistHRC(HRC, LPHWL);
int       WINAPI GetWordlistCoercionHRC(HRC);
int       WINAPI ProcessHRC(HRC, DWORD);
int       WINAPI ReadHWL(HWL, HFILE);
int       WINAPI SetAlphabetHRC(HRC, ALC, LPBYTE);
int       WINAPI SetAlphabetPriorityHRC(HRC, ALC, LPBYTE);
int       WINAPI SetBoxAlphabetHRC(HRC, LPALC, UINT);
int       WINAPI SetGuideHRC(HRC, LPGUIDE, UINT);
int       WINAPI SetInternationalHRC(HRC, UINT, LPCSTR, UINT, UINT);
int       WINAPI SetMaxResultsHRC(HRC, UINT);
HRECHOOK  WINAPI SetResultsHookHREC(HREC, HRCRESULTHOOKPROC);
int       WINAPI SetWordlistCoercionHRC(HRC, UINT);
int       WINAPI SetWordlistHRC(HRC, HWL);
int       WINAPI TrainHREC(HREC, LPSYV, UINT, HPENDATA, UINT);
int       WINAPI UnhookResultsHookHREC(HREC, HRECHOOK);
int       WINAPI WriteHWL(HWL, HFILE);

// Recognizer Installation:
HREC      WINAPI InstallRecognizer(LPSTR);
VOID      WINAPI UninstallRecognizer(HREC);

// Inksets:
BOOL      WINAPI AddInksetInterval(HINKSET, LPINTERVAL);
HINKSET   WINAPI CreateInkset(UINT);
BOOL      WINAPI DestroyInkset(HINKSET);
int       WINAPI GetInksetInterval(HINKSET, UINT, LPINTERVAL);
int       WINAPI GetInksetIntervalCount(HINKSET);

// Symbol Values:
int       WINAPI CharacterToSymbol(LPSTR, int, LPSYV);
BOOL      WINAPI SymbolToCharacter(LPSYV, int, LPSTR, LPINT);
#endif /*!NOPENHRC */

//---------------------------------------------------------------------------
#ifndef NOPENINKPUT

// Pen Input/Inking:
int       WINAPI DoDefaultPenInput(HWND, UINT);
int       WINAPI GetPenInput(HPCM, LPPOINT, LPVOID, UINT, UINT, LPSTROKEINFO);
int       WINAPI PeekPenInput(HPCM, UINT, LPPOINT, LPVOID, UINT);
int       WINAPI StartInking(HPCM, UINT, LPINKINGINFO);
HPCM      WINAPI StartPenInput(HWND, UINT, LPPCMINFO, LPINT);
int       WINAPI StopInking(HPCM);
int       WINAPI StopPenInput(HPCM, UINT, int);
#endif /*!NOPENINKPUT */

//---------------------------------------------------------------------------
#ifndef NOPENMISC

// Miscellaneous/Utilities:
VOID      WINAPI BoundingRectFromPoints(LPPOINT, UINT, LPRECT);
BOOL      WINAPI DPtoTP(LPPOINT, int);
UINT      WINAPI GetPenAppFlags(VOID);
VOID      WINAPI SetPenAppFlags(UINT, UINT);
LONG      WINAPI GetPenMiscInfo(WPARAM, LPARAM);
UINT      WINAPI GetVersionPenWin(VOID);
LONG      WINAPI SetPenMiscInfo(WPARAM, LPARAM);
BOOL      WINAPI TPtoDP(LPPOINT, int);
BOOL      WINAPI CorrectWriting(HWND, LPSTR, UINT, LPVOID, DWORD, DWORD);
#ifdef JAPAN
int       WINAPI CorrectWritingEx(HWND, LPSTR, UINT, LPCWX);
#endif //JAPAN
#ifdef JAPAN
HANDLE    WINAPI GetPenResource(WPARAM);
#endif //JAPAN
#ifndef _WIN32
UINT      WINAPI IsPenAware(VOID);
VOID      WINAPI RegisterPenApp(UINT, UINT);
#endif //!_WIN32

#endif /*!NOPENMISC */

//---------------------------------------------------------------------------
#ifndef NOPENRC1    // not available in WIN32

// RC1:
VOID      WINAPI EmulatePen(BOOL);
UINT      WINAPI EnumSymbols(LPSYG, UINT, ENUMPROC, LPVOID);
BOOL      WINAPI ExecuteGesture(HWND, SYV, LPRCRESULT);
VOID      WINAPI FirstSymbolFromGraph(LPSYG, LPSYV, int, LPINT);
UINT      WINAPI GetGlobalRC(LPRC, LPSTR, LPSTR, int);
int       WINAPI GetSymbolCount(LPSYG);
int       WINAPI GetSymbolMaxLength(LPSYG);
VOID      WINAPI InitRC(HWND, LPRC);
REC       WINAPI ProcessWriting(HWND, LPRC);
REC       WINAPI Recognize(LPRC);
REC       WINAPI RecognizeData(LPRC, HPENDATA);
UINT      WINAPI SetGlobalRC(LPRC, LPSTR, LPSTR);
BOOL      WINAPI SetRecogHook(UINT, UINT, HWND);
BOOL      WINAPI TrainContext(LPRCRESULT, LPSYE, int, LPSYC, int);
BOOL      WINAPI TrainInk(LPRC, HPENDATA, LPSYV);

// Custom Recognizer functions - not PenWin APIs (formerly in penwoem.h):
VOID      WINAPI CloseRecognizer(VOID);
UINT      WINAPI ConfigRecognizer(UINT, WPARAM, LPARAM);
BOOL      WINAPI InitRecognizer(LPRC);
REC       WINAPI RecognizeDataInternal(LPRC, HPENDATA, LPFUNCRESULTS);
REC       WINAPI RecognizeInternal(LPRC, LPFUNCRESULTS);
BOOL      WINAPI TrainContextInternal(LPRCRESULT, LPSYE, int, LPSYC, int);
BOOL      WINAPI TrainInkInternal(LPRC, HPENDATA, LPSYV);
#endif /*!NOPENRC1 */

//---------------------------------------------------------------------------
#ifndef NOPENTARGET

// Ink Targeting:
int       WINAPI TargetPoints(LPTARGINFO, LPPOINT, DWORD, UINT, LPSTROKEINFO);

#endif /*!NOPENTARGET */

//---------------------------------------------------------------------------
#ifndef NOPENVIRTEVENT

// Virtual Event Layer:
VOID      WINAPI AtomicVirtualEvent(BOOL);
VOID      WINAPI PostVirtualKeyEvent(UINT, BOOL);
VOID      WINAPI PostVirtualMouseEvent(UINT, int, int);
#endif /*!NOPENVIRTEVENT */

//---------------------------------------------------------------------------

#ifdef  JAPAN
// Kanji
BOOL      WINAPI KKConvert(HWND hwndConvert, HWND hwndCaller,
			   LPSTR lpBuf, UINT cbBuf, LPPOINT lpPnt);

#endif //  JAPAN

#endif /* RC_INVOKED */ // ... all the way back from definitions:3

/****** End of Header Info *************************************************/

#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifndef _WIN32
#ifndef RC_INVOKED
#pragma pack()
#endif /* RC_INVOKED */
#endif //!_WIN32

#endif /* #define _INC_PENWIN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\replapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993-1999.
//
//  File:       ReplAPI.h
//
//  Contents:   Public Replication APIs and Structures.
//
//  History:    15-jul-93  PeterCo     created
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifndef _REPLAPI_H_
#define _REPLAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

EXPORTDEF STDAPI ReplCreateObject(
    const WCHAR *pwszMachine,
    const WCHAR *pwszOraRelativeName,
    const CLSID& clsid,
    REFIID itf,
    PSECURITY_ATTRIBUTES psa,
    void** ppitf);

EXPORTDEF STDAPI ReplDeleteObject(
    const WCHAR *pwszMachine,
    const WCHAR *pwszOraRelativeName);

#define REPL_REPLICATE_NONE             (0x00)
#define REPL_REPLICATE_ASYNC            (0x01)  // replicate asynchronously
#define REPL_REPLICATE_META_DATA_ONLY   (0x02)  // replicate meta data only
                                                // until all urgent changes
                                                // have been applied.

#define REPL_REPLICATE_ALL_FLAGS ( REPL_REPLICATE_ASYNC | \
                                   REPL_REPLICATE_META_DATA_ONLY )

EXPORTDEF STDAPI ReplReplicate(
    const WCHAR *pwszMachine,
    const WCHAR *pwszOraRelativeReplicaConnection,
    DWORD       options);

EXPORTDEF STDAPI ReplReplicateSingleObject(
    const WCHAR *pDfsPathOraMachine,
    const WCHAR *pDfsPathSrcObj,
    const WCHAR *pDfsPathSrcMachine,
    const WCHAR *pDfsPathDstObject,
    const WCHAR *pDfsPathDstMachine,
    BOOL         bCreateDstIfRequired);

EXPORTDEF STDAPI ReplMetaDataReplicate(
    const WCHAR *pwszMachine,                   // ORA to pull to
    const WCHAR *pwszSource,                    // ORA to pull from
    const WCHAR *pwszOraRelativeReplicaSet);

#define REPL_URGENT_NONE              (0x00)    // no flags
#define REPL_URGENT_NO_HYSTERESIS     (0x01)    // exclude from hysteresis calc.
#define REPL_URGENT_TRIGGER_IMMEDIATE (0x02)    // force immediate urgent cycle

#define REPL_URGENT_ALL_FLAGS ( REPL_URGENT_NONE |                   \
                                REPL_URGENT_NO_HYSTERESIS |          \
                                REPL_URGENT_TRIGGER_IMMEDIATE )

EXPORTDEF STDAPI ReplUrgentChangeNotify(
    REFCLSID     clsid,                     // should match CLSID on root IStg
    DWORD        flags,                     // ORing of URGENT_NOTIFY_*
    PVOID        reserved,                  // must be NULL
    IStorage     *pRootStorage);            // must have STGM_READWRITE access

EXPORTDEF STDAPI ReplValidatePath(
    const WCHAR *pDfsPathMachine,   // in
    const WCHAR *pLocalWin32Path,   // in
    WCHAR       **ppDfsPath,        // out - Dfs path to stuff into replica
                                    // object's "root" field
    HRESULT     *phr);              // out - S_OK indicates path is valid,
                                    // FAILED(*phr) identifies why if invalid

EXPORTDEF STDAPI ReplPropagateMetaData(
    const WCHAR *pDfsPathMachine,   // in - which ORA is to do the propagating
                                    // i.e. machine where changes were made
    const WCHAR *pwszRSet);         // in - name of replica set where changes
                                    // were made - NULL means check all RSets

#ifdef __cplusplus
}
#endif

#endif  // _REPLAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\regia64.h ===
/**
***  Copyright  (C) 1996-99 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

#if defined(__assembler)

//
// Define standard integer registers.
//

        zero        = r0                        // always 0
        gp          = r1                        // global pointer
        v0          = r8                        // return value
        sp          = r12                       // stack pointer
        s0          = r4                        // saved (preserved) integer registers
        s1          = r5
        s2          = r6
        s3          = r7

//
// temporary (volatile) integer registers
//

        t0          = r2
        t1          = r3
        t2          = r9
        t3          = r10
        t4          = r11
        t5          = r14
        t6          = r15
        t7          = r16
        t8          = r17
        t9          = r18
        t10         = r19
        t11         = r20
        t12         = r21
        t13         = r22
        t14         = r23
        t15         = r24
        t16         = r25
        t17         = r26
        t18         = r27
        t19         = r28
        t20         = r29
        t21         = r30
        t22         = r31

//
// Floating point saved (preserved) registers
//

        fs0         = f2
        fs1         = f3
        fs2         = f4
        fs3         = f5
        fs4         = f16
        fs5         = f17
        fs6         = f18
        fs7         = f19
        fs8         = f20
        fs9         = f21
        fs10        = f22
        fs11        = f23
        fs12        = f24
        fs13        = f25
        fs14        = f26
        fs15        = f27
        fs16        = f28
        fs17        = f29
        fs18        = f30
        fs19        = f31

//
// Low floating point temporary (volatile) registers
//

        ft0         = f6
        ft1         = f7
        ft2         = f8
        ft3         = f9
        ft4         = f10
        ft5         = f11
        ft6         = f12
        ft7         = f13
        ft8         = f14
        ft9         = f15

//
// input arguments
// Should be:
// a0  = in0
// a1  = in1
// a2  = in2
// a3  = in3
// a4  = in4
// a5  = in5
// a6  = in6
// a7  = in7
//

        a0          = r32
        a1          = r33
        a2          = r34
        a3          = r35
        a4          = r36
        a5          = r37
        a6          = r38
        a7          = r39

//
// branch return pointer (b0)
//

        brp         = rp

//
// branch saved (preserved)
//

        bs0         = b1
        bs1         = b2
        bs2         = b3
        bs3         = b4
        bs4         = b5

//
// branch temporary (volatile) registers
//

        bt0         = b6
        bt1         = b7

//
// predicate registers
//
// p0 predicate register always 1
//

        ps0         = p1                        // saved (preserved) predicate registers
        ps1         = p2
        ps2         = p3
        ps3         = p4
        ps4         = p5
        ps5         = p16                       // Predicates p16-p63 are also preserved
        ps6         = p17
        ps7         = p18
        ps8         = p19
        ps9         = p20

        pt0         = p6                        // temporary (volatile) predicate registers
        pt1         = p7
        pt2         = p8
        pt3         = p9
        pt4         = p10
        pt5         = p11
        pt6         = p12
        pt7         = p13
        pt8         = p14
        pt9         = p15

//
// Kernel registers
//

        k0          = ar.k0
        k1          = ar.k1
        k2          = ar.k2
        k3          = ar.k3
        k4          = ar.k4
        k5          = ar.k5
        k6          = ar.k6
        k7          = ar.k7

        ia32dr67    = ar.k5                    // dr6/dr7 for iA32

        ia32fcr     = ar21                     // FCR for iA32
        ia32eflag   = ar24                     // EFLAG for iA32
        ia32csd     = ar25                     // CSD for iA32
        ia32ssd     = ar26                     // SSD for iA32
        ia32cflag   = ar27                     // CFLG (cr0/cr4) for iA32
        ia32fsr     = ar28                     // FSR for iA32
        ia32fir     = ar29                     // FIR for iA32
        ia32fdr     = ar30                     // FDR for iA32

//
// Define iA32 constants, to be used by ISA transition code
//
        _DataSelector       ==  0x23
        _CodeSelector       ==  0x1b
        _FsSelector         ==  0x3b
        _LdtSelector        ==  0x4b

//
// Define the IA-32 registers
//
        rEax        =   r8             // v0
        rEcx        =   r9             // t2
        rEdx        =   r10            // t3
        rEbx        =   r11            // t4
        rEsp        =   r12            // sp
        rEbp        =   r13            // teb
        rEsi        =   r14            // t5
        rEdi        =   r15            // t6


//
//  Define iA-32 Segment Registers mapping
//
        rDSESFSGS     =   r16     // ES selector register (t7)
        rCSSSLDTTSS     =   r17     // CS selector register (t8)
        rEFLAG      =   ar24        // Eflag register
        rESD        =   r24     // ES Descriptor register (t15)
        rCSD        =   ar25        // CS Descriptor register
        rSSD        =   ar26        // SS Descriptor register
        rDSD        =   r27     // DS Descriptor register (t18)
        rFSD        =   r28     // FS Descriptor register (t19)
        rGSD        =   r29     // GS Descriptor register (t20)
        rLDTD       =   r30     // LDT Descriptor register (t21)
        rGDTD       =   r31     // GDT Descriptor register (t22)

//
// pointer to thread environment block
//

        teb         = r13        // per s/w convention
        kteb        = ar.k3      // known "true" value (changed only by kernel)

//
// kernel bank shadow (hidden) registers
//

        h16         = r16
        h17         = r17
        h18         = r18
        h19         = r19
        h20         = r20
        h21         = r21
        h22         = r22
        h23         = r23
        h24         = r24
        h25         = r25
        h26         = r26
        h27         = r27
        h28         = r28
        h29         = r29
        h30         = r30
        h31         = r31

// Standard register aliases for procedure entry/exit

// Should be:
// savedpfs = loc0
// savedbrp = loc1

#define savedpfs    loc0
#define savedbrp    loc1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\richole.h ===
#ifndef _RICHOLE_
#define _RICHOLE_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 *	RICHOLE.H
 *
 *	Purpose:
 *		OLE Extensions to the Rich Text Editor
 *
 *	Copyright (c) 1985-1999, Microsoft Corporation
 */

// Structure passed to GetObject and InsertObject
typedef struct _reobject
{
	DWORD			cbStruct;			// Size of structure
	LONG			cp;					// Character position of object
	CLSID			clsid;				// Class ID of object
	LPOLEOBJECT		poleobj;			// OLE object interface
	LPSTORAGE		pstg;				// Associated storage interface
	LPOLECLIENTSITE	polesite;			// Associated client site interface
	SIZEL			sizel;				// Size of object (may be 0,0)
	DWORD			dvaspect;			// Display aspect to use
	DWORD			dwFlags;			// Object status flags
	DWORD			dwUser;				// Dword for user's use
} REOBJECT;

// Flags to specify which interfaces should be returned in the structure above
#define REO_GETOBJ_NO_INTERFACES	(0x00000000L)
#define REO_GETOBJ_POLEOBJ			(0x00000001L)
#define REO_GETOBJ_PSTG				(0x00000002L)
#define REO_GETOBJ_POLESITE			(0x00000004L)
#define REO_GETOBJ_ALL_INTERFACES	(0x00000007L)

// Place object at selection
#define REO_CP_SELECTION ((ULONG) -1L)

// Use character position to specify object instead of index
#define REO_IOB_SELECTION ((ULONG) -1L)
#define REO_IOB_USE_CP ((ULONG) -2L)

// Object flags
#define REO_NULL			(0x00000000L)	// No flags
#define REO_READWRITEMASK	(0x0000003FL)	// Mask out RO bits
#define REO_DONTNEEDPALETTE	(0x00000020L)	// Object doesn't need palette
#define REO_BLANK			(0x00000010L)	// Object is blank
#define REO_DYNAMICSIZE		(0x00000008L)	// Object defines size always
#define REO_INVERTEDSELECT	(0x00000004L)	// Object drawn all inverted if sel
#define REO_BELOWBASELINE	(0x00000002L)	// Object sits below the baseline
#define REO_RESIZABLE		(0x00000001L)	// Object may be resized
#define REO_LINK			(0x80000000L)	// Object is a link (RO)
#define REO_STATIC			(0x40000000L)	// Object is static (RO)
#define REO_SELECTED		(0x08000000L)	// Object selected (RO)
#define REO_OPEN			(0x04000000L)	// Object open in its server (RO)
#define REO_INPLACEACTIVE	(0x02000000L)	// Object in place active (RO)
#define REO_HILITED			(0x01000000L)	// Object is to be hilited (RO)
#define REO_LINKAVAILABLE	(0x00800000L)	// Link believed available (RO)
#define REO_GETMETAFILE		(0x00400000L)	// Object requires metafile (RO)

// flags for IRichEditOle::GetClipboardData(),
// IRichEditOleCallback::GetClipboardData() and
// IRichEditOleCallback::QueryAcceptData()
#define RECO_PASTE			(0x00000000L)	// paste from clipboard
#define RECO_DROP			(0x00000001L)	// drop
#define RECO_COPY			(0x00000002L)	// copy to the clipboard
#define RECO_CUT			(0x00000003L)	// cut to the clipboard
#define RECO_DRAG			(0x00000004L)	// drag

/*
 *	IRichEditOle
 *
 *	Purpose:
 *		Interface used by the client of RichEdit to perform OLE-related
 *		operations.
 *
 *	//$ REVIEW:
 *		The methods herein may just want to be regular Windows messages.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOle

DECLARE_INTERFACE_(IRichEditOle, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOle methods ***
    STDMETHOD(GetClientSite) (THIS_ LPOLECLIENTSITE FAR * lplpolesite) PURE;
	STDMETHOD_(LONG,GetObjectCount) (THIS) PURE;
	STDMETHOD_(LONG,GetLinkCount) (THIS) PURE;
	STDMETHOD(GetObject) (THIS_ LONG iob, REOBJECT FAR * lpreobject,
						  DWORD dwFlags) PURE;
    STDMETHOD(InsertObject) (THIS_ REOBJECT FAR * lpreobject) PURE;
	STDMETHOD(ConvertObject) (THIS_ LONG iob, REFCLSID rclsidNew,
							  LPCSTR lpstrUserTypeNew) PURE;
	STDMETHOD(ActivateAs) (THIS_ REFCLSID rclsid, REFCLSID rclsidAs) PURE;
	STDMETHOD(SetHostNames) (THIS_ LPCSTR lpstrContainerApp,
							 LPCSTR lpstrContainerObj) PURE;
	STDMETHOD(SetLinkAvailable) (THIS_ LONG iob, BOOL fAvailable) PURE;
	STDMETHOD(SetDvaspect) (THIS_ LONG iob, DWORD dvaspect) PURE;
	STDMETHOD(HandsOffStorage) (THIS_ LONG iob) PURE;
	STDMETHOD(SaveCompleted) (THIS_ LONG iob, LPSTORAGE lpstg) PURE;
	STDMETHOD(InPlaceDeactivate) (THIS) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(ImportDataObject) (THIS_ LPDATAOBJECT lpdataobj,
									CLIPFORMAT cf, HGLOBAL hMetaPict) PURE;
};
typedef         IRichEditOle FAR * LPRICHEDITOLE;

/*
 *	IRichEditOleCallback
 *
 *	Purpose:
 *		Interface used by the RichEdit to get OLE-related stuff from the
 *		application using RichEdit.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOleCallback

DECLARE_INTERFACE_(IRichEditOleCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOleCallback methods ***
	STDMETHOD(GetNewStorage) (THIS_ LPSTORAGE FAR * lplpstg) PURE;
    STDMETHOD(GetInPlaceContext) (THIS_ LPOLEINPLACEFRAME FAR * lplpFrame,
								  LPOLEINPLACEUIWINDOW FAR * lplpDoc,
								  LPOLEINPLACEFRAMEINFO lpFrameInfo) PURE;
	STDMETHOD(ShowContainerUI) (THIS_ BOOL fShow) PURE;
	STDMETHOD(QueryInsertObject) (THIS_ LPCLSID lpclsid, LPSTORAGE lpstg,
									LONG cp) PURE;
	STDMETHOD(DeleteObject) (THIS_ LPOLEOBJECT lpoleobj) PURE;
	STDMETHOD(QueryAcceptData) (THIS_ LPDATAOBJECT lpdataobj,
								CLIPFORMAT FAR * lpcfFormat, DWORD reco,
								BOOL fReally, HGLOBAL hMetaPict) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(GetDragDropEffect) (THIS_ BOOL fDrag, DWORD grfKeyState,
									LPDWORD pdwEffect) PURE;
	STDMETHOD(GetContextMenu) (THIS_ WORD seltype, LPOLEOBJECT lpoleobj,
									CHARRANGE FAR * lpchrg,
									HMENU FAR * lphmenu) PURE;
};
typedef         IRichEditOleCallback FAR * LPRICHEDITOLECALLBACK;

#ifndef MAC
// RichEdit interface GUIDs
DEFINE_GUID(IID_IRichEditOle,         0x00020D00, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRichEditOleCallback, 0x00020D03, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
#endif // !MAC

#endif // _RICHOLE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\safeboot.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    safeboot.h

Abstract:

    This module contains all safe boot code.

Author:

    Wesley Witt (wesw) 01/05/1998


Revision History:


--*/

#ifndef _SAFEBOOT_
#define _SAFEBOOT_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// define the safeboot options
//

#define SAFEBOOT_MINIMAL                1
#define SAFEBOOT_NETWORK                2
#define SAFEBOOT_DSREPAIR               3

#define SAFEBOOT_LOAD_OPTION_W          L"SAFEBOOT:"
#define SAFEBOOT_MINIMAL_STR_W          L"MINIMAL"
#define SAFEBOOT_NETWORK_STR_W          L"NETWORK"
#define SAFEBOOT_DSREPAIR_STR_W         L"DSREPAIR"
#define SAFEBOOT_ALTERNATESHELL_STR_W   L"(ALTERNATESHELL)"

#define SAFEBOOT_LOAD_OPTION_A          "SAFEBOOT:"
#define SAFEBOOT_MINIMAL_STR_A          "MINIMAL"
#define SAFEBOOT_NETWORK_STR_A          "NETWORK"
#define SAFEBOOT_DSREPAIR_STR_A         "DSREPAIR"
#define SAFEBOOT_ALTERNATESHELL_STR_A   "(ALTERNATESHELL)"

#define BOOTLOG_STRSIZE     256

#ifdef __cplusplus
}
#endif

#endif // _NTPNPAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\sceattch.h ===
/*--

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    sceattch.h

Abstract:

    Clipboard formats & constants for SCE Attachments

Revision History:

--*/

#ifndef _sceattch_
#define _sceattch_

#if _MSC_VER > 1000
#pragma once
#endif

#define SCE_MODE_UNKNOWN 0
#define SCE_MODE_COMPUTER_MANAGEMENT 1
#define SCE_MODE_DC_MANAGEMENT 2
#define SCE_MODE_LOCAL_USER 3
#define SCE_MODE_LOCAL_COMPUTER 4
#define SCE_MODE_DOMAIN_USER 5
#define SCE_MODE_DOMAIN_COMPUTER 6
#define SCE_MODE_OU_USER 7
#define SCE_MODE_OU_COMPUTER 8
#define SCE_MODE_STANDALONE 9
#define SCE_MODE_VIEWER 10
#define SCE_MODE_EDITOR 11
#define SCE_MODE_REMOTE_USER 12
#define SCE_MODE_REMOTE_COMPUTER  13
#define SCE_MODE_LOCALSEC 14
#define SCE_MODE_RSOP_USER 15
#define SCE_MODE_RSOP_COMPUTER 16

// {668A49ED-8888-11d1-AB72-00C04FB6C6FA}
#define struuidNodetypeSceTemplate      "{668A49ED-8888-11d1-AB72-00C04FB6C6FA}"
#define lstruuidNodetypeSceTemplate      L"{668A49ED-8888-11d1-AB72-00C04FB6C6FA}"

const GUID cNodetypeSceTemplate =
{ 0x668a49ed, 0x8888, 0x11d1, { 0xab, 0x72, 0x0, 0xc0, 0x4f, 0xb6, 0xc6, 0xfa } };

// Clipboard format for SCE's mode DWORD
#define CCF_SCE_MODE_TYPE L"CCF_SCE_MODE_TYPE"
// Clipboard format for GPT's IUnknown interface
#define CCF_SCE_GPT_UNKNOWN L"CCF_SCE_GPT_UNKNOWN"
// Clipboard format for RSOP's IUnknown interface
#define CCF_SCE_RSOP_UNKNOWN L"CCF_SCE_RSOP_UNKNOWN"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\schedule.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    schedule.h

Abstract:

    This file defines a common schedule structure for use by various NT
    components.

--*/

#ifndef _SCHEDULE_H_
#define _SCHEDULE_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// The DS and FRS use the same structure to represent different schedules.
// The DS uses a 15-minute polling schedule. FRS uses a 60-minute
// start/stop schedule. Hence, the schedule for the system volume is
// a special case because we only have the DS schedule to work from.
// We will work around this problem by treating the 15
// -minute polling schedule as a 60-minute start/stop schedule.
// Replication is enabled for any hour that has any of the four
// 15-minute bits set.
//
// When the ReplicationSchedule is not present the default is
// "always replicate."
//

//
// Only the interval schedule is currently implemented. Others are ignored.
//
#define SCHEDULE_INTERVAL       0 // schedule as understood by NT5
#define SCHEDULE_BANDWIDTH      1 // bandwidth as understood by NT5
#define SCHEDULE_PRIORITY       2 // priority as understood by NT5

//
// Schedule Header
//
// Each schedule blob begins with n array of schedule headers that
// specify the number and type of schedules contained in the blob.
//
typedef struct _SCHEDULE_HEADER {
    ULONG   Type;       // one of the SCHEDULE_ ordinals
    ULONG   Offset;     // offset from start of schedule structure
} SCHEDULE_HEADER, *PSCHEDULE_HEADER;

//
// Schedule
//
typedef struct _SCHEDULE {
    ULONG           Size;           // inclusive size in bytes
    ULONG           Bandwidth;
    ULONG           NumberOfSchedules;
    SCHEDULE_HEADER Schedules[1];
} SCHEDULE, *PSCHEDULE;
// The above structure is followed by the Data buffer and the
// SCHEDULE_HEADER contains offsets to refer to the appropriate
// parts in the data buffer.

#define SCHEDULE_DATA_ENTRIES   (7 * 24)    // 7 days X 24 hours

#ifdef __cplusplus
}
#endif

#endif // _SCHEDULE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\scode.h ===
/*++

Copyright (c) 1992-1999 Microsoft Corporation

Module Name:

    scode.h

Abstract:

    Obsolete SCODE header file.  Use WINERROR.H

--*/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef  _WINERROR_
#include <winerror.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\secobjs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999
//
//  File:   secobjs.h
//
//  Contents:   Security object-related defintions
//
//  History:    27-Dec-93       MikeSe  Created
//
//  Notes:  This file contains constant definitions used in properties
//      of security objects, which cannot (yet) be defined directly
//      in the TDL for the property sets.
//
//      This file is never included directly. It is included from
//      security.h by defining SECURITY_OBJECTS.
//
//----------------------------------------------------------------------------

#ifndef __SECOBJS_H__
#define __SECOBJS_H__

#if _MSC_VER > 1000
#pragma once
#endif

// Account attributes, in PSLoginParameters::AccountAttrs

#define ACCOUNT_DISABLED        0x00000001
#define ACCOUNT_PASSWORD_NOT_REQUIRED   0x00000002
#define ACCOUNT_PASSWORD_CANNOT_CHANGE  0x00000004
#define ACCOUNT_DONT_EXPIRE_PASSWORD    0x00000008

#endif  // of ifndef __SECOBJS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\pwin32.h ===
#ifndef __PWIN32_H__
#define __PWIN32_H__

#if _MSC_VER > 1000
#pragma once
#endif

#include <dde.h>

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

/*****************************************************************************\
* Copyright (C) Microsoft Corporation, 1990-1999
* PWIN32.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides macros to map portable windows code to its 32 bit form.
\*****************************************************************************/

/*-----------------------------------USER------------------------------------*/

/* HELPER MACROS */

#define MAPVALUE(v16, v32)              (v32)
#define MAPTYPE(v16, v32)               v32
#define MAKEMPOINT(l)                   (*((MPOINT *)&(l)))
#define MPOINT2POINT(mpt,pt)            ((pt).x = (mpt).x, (pt).y = (mpt).y)
#define POINT2MPOINT(pt, mpt)           ((mpt).x = (SHORT)(pt).x, (mpt).y = (SHORT)(pt).y)
#define LONG2POINT(l, pt)               ((pt).x = (SHORT)LOWORD(l), (pt).y = (SHORT)HIWORD(l))

#define SETWINDOWUINT(hwnd, index, ui)  (UINT)SetWindowLong(hwnd, index, (LONG)(ui))
#define GETWINDOWUINT(hwnd, index)      (UINT)GetWindowLong(hwnd, index)
#define SETCLASSUINT(hwnd, index, ui)   (UINT)SetClassLong(hwnd, index, (LONG)(ui))
#define GETCLASSUINT(hwnd, index)       (UINT)GetClassLong(hwnd, index)

#define GETCBCLSEXTRA(hwnd)             GETCLASSUINT(hwnd, GCL_CBCLSEXTRA)
#define SETCBCLSEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCL_CBCLSEXTRA, cb)
#define GETCBWNDEXTRA(hwnd)             GETCLASSUINT(hwnd, GCL_CBWNDEXTRA)
#define SETCBWNDEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCL_CBWNDEXTRA, cb)
#define GETCLASSBRBACKGROUND(hwnd)      (HBRUSH)GetClassLongPtr((hwnd), GCLP_HBRBACKGROUND)
#define SETCLASSBRBACKGROUND(hwnd, h)   (HBRUSH)SetClassLongPtr((hwnd), GCLP_HBRBACKGROUND, (LONG_PTR)(h))
#define GETCLASSCURSOR(hwnd)            (HCURSOR)GetClassLongPtr((hwnd), GCLP_HCURSOR)
#define SETCLASSCURSOR(hwnd, h)         (HCURSOR)SetClassLongPtr((hwnd), GCLP_HCURSOR, (LONG_PTR)(h))
#define GETCLASSHMODULE(hwnd)           (HMODULE)GetClassLongPtr((hwnd), GCLP_HMODULE)
#define SETCLASSHMODULE(hwnd, h)        (HMODULE)SetClassLongPtr((hwnd), GCLP_HMODULE, (LONG_PTR)(h))
#define GETCLASSICON(hwnd)              (HICON)GetClassLongPtr((hwnd), GCLP_HICON)
#define SETCLASSICON(hwnd, h)           (HICON)SetClassLongPtr((hwnd), GCLP_HICON, (LONG_PTR)(h))
#define GETCLASSSTYLE(hwnd)             GETCLASSUINT((hwnd), GCL_STYLE)
#define SETCLASSSTYLE(hwnd, style)      SETCLASSUINT((hwnd), GCL_STYLE, style)
#define GETHWNDINSTANCE(hwnd)           (HINSTANCE)GetWindowLongPtr((hwnd), GWLP_HINSTANCE)
#define SETHWNDINSTANCE(hwnd, h)        (HINSTANCE)SetWindowLongPtr((hwnd), GWLP_HINSTANCE, (LONG_PTR)(h))
#define GETHWNDPARENT(hwnd)             (HWND)GetWindowLongPtr((hwnd), GWLP_HWNDPARENT)
#define SETHWNDPARENT(hwnd, h)          (HWND)SetWindowLongPtr((hwnd), GWLP_HWNDPARENT, (LONG_PTR)(h))
#define GETWINDOWID(hwnd)               GETWINDOWUINT((hwnd), GWL_ID)
#define SETWINDOWID(hwnd, id)           SETWINDOWUINT((hwnd), GWL_ID, id)

/* USER API */

#define MDlgDirSelect(hDlg, lpstr, nLength, nIDListBox) \
    DlgDirSelectEx(hDlg, lpstr, nLength, nIDListBox)

#define MDlgDirSelectCOMBOBOX(hDlg, lpstr, nLength, nIDComboBox) \
    DlgDirSelectComboBoxEx(hDlg, lpstr, nLength, nIDComboBox)

#define MGetLastError                    GetLastError

#define MMain(hInst, hPrevInst, lpCmdLine, nCmdShow) \
   INT WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, \
   INT nCmdShow) {  \
   INT _argc;       \
   CHAR **_argv;

__inline LPSTR MGetCmdLine()
{
    LPSTR lpCmdLine, lpT;

    lpCmdLine = GetCommandLineA();

    // on NT, lpCmdLine's first string includes its own name, remove this
    // to make it exactly like the windows command line.

    if (*lpCmdLine) {
        lpT = strchr(lpCmdLine, ' ');   // skip self name
        if (lpT) {
            lpCmdLine = lpT;
            while (*lpCmdLine == ' ') {
                lpCmdLine++;            // skip spaces to end or first cmd
            }
        } else {
            lpCmdLine += strlen(lpCmdLine);   // point to NULL
        }
    }
    return(lpCmdLine);
}

__inline DWORD APIENTRY MSendMsgEM_GETSEL(HWND hDlg, WORD2DWORD * piStart, WORD2DWORD * piEnd)
{
    DWORD   dw;

    dw = (DWORD)SendMessage(hDlg, EM_GETSEL, 0, 0);
    if (piEnd != NULL)
        *piEnd   = (WORD2DWORD) HIWORD(dw);
    if (piStart != NULL)
        *piStart = (WORD2DWORD) LOWORD(dw);

    return(dw);
}


/* USER MESSAGES: */

#define GET_WPARAM(wp, lp)                      (wp)
#define GET_LPARAM(wp, lp)                      (lp)

#define GET_WM_ACTIVATE_STATE(wp, lp)           LOWORD(wp)
#define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)      (BOOL)HIWORD(wp)
#define GET_WM_ACTIVATE_HWND(wp, lp)            (HWND)(lp)
#define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)   \
        (WPARAM)MAKELONG((s), (fmin)), (LPARAM)(hwnd)

#define GET_WM_CHARTOITEM_CHAR(wp, lp)          (TCHAR)LOWORD(wp)
#define GET_WM_CHARTOITEM_POS(wp, lp)           HIWORD(wp)
#define GET_WM_CHARTOITEM_HWND(wp, lp)          (HWND)(lp)
#define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd) \
        (WPARAM)MAKELONG((pos), (ch)), (LPARAM)(hwnd)

#define GET_WM_COMMAND_ID(wp, lp)               LOWORD(wp)
#define GET_WM_COMMAND_HWND(wp, lp)             (HWND)(lp)
#define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(wp)
#define GET_WM_COMMAND_MPS(id, hwnd, cmd)    \
        (WPARAM)MAKELONG(id, cmd), (LPARAM)(hwnd)

#define WM_CTLCOLOR                             0x0019

#define GET_WM_CTLCOLOR_HDC(wp, lp, msg)        (HDC)(wp)
#define GET_WM_CTLCOLOR_HWND(wp, lp, msg)       (HWND)(lp)
#define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)       (WORD)(msg - WM_CTLCOLORMSGBOX)
#define GET_WM_CTLCOLOR_MSG(type)               (WORD)(WM_CTLCOLORMSGBOX+(type))
#define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type) \
        (WPARAM)(hdc), (LPARAM)(hwnd)


#define GET_WM_MENUSELECT_CMD(wp, lp)               LOWORD(wp)
#define GET_WM_MENUSELECT_FLAGS(wp, lp)             (UINT)(int)(short)HIWORD(wp)
#define GET_WM_MENUSELECT_HMENU(wp, lp)             (HMENU)(lp)
#define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)  \
        (WPARAM)MAKELONG(cmd, f), (LPARAM)(hmenu)

// Note: the following are for interpreting MDIclient to MDI child messages.
#define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (lp == (LPARAM)hwnd)
#define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)(wp)
#define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)(lp)
// Note: the following is for sending to the MDI client window.
#define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA)\
        (WPARAM)(hwndA), 0

#define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW) (WPARAM)hmenuF, (LPARAM)hmenuW

#define GET_WM_MENUCHAR_CHAR(wp, lp)                (TCHAR)LOWORD(wp)
#define GET_WM_MENUCHAR_HMENU(wp, lp)               (HMENU)(lp)
#define GET_WM_MENUCHAR_FMENU(wp, lp)               (BOOL)HIWORD(wp)
#define GET_WM_MENUCHAR_MPS(ch, hmenu, f)    \
        (WPARAM)MAKELONG(ch, f), (LPARAM)(hmenu)

#define GET_WM_PARENTNOTIFY_MSG(wp, lp)             LOWORD(wp)
#define GET_WM_PARENTNOTIFY_ID(wp, lp)              HIWORD(wp)
#define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)       (HWND)(lp)
#define GET_WM_PARENTNOTIFY_X(wp, lp)               (INT)LOWORD(lp)
#define GET_WM_PARENTNOTIFY_Y(wp, lp)               (INT)HIWORD(lp)
#define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd) \
        (WPARAM)MAKELONG(id, msg), (LPARAM)(hwnd)
#define GET_WM_PARENTNOTIFY2_MPS(msg, x, y) \
        (WPARAM)MAKELONG(0, msg), MAKELONG(x, y)

#define GET_WM_VKEYTOITEM_CODE(wp, lp)              (INT)LOWORD(wp)
#define GET_WM_VKEYTOITEM_ITEM(wp, lp)              HIWORD(wp)
#define GET_WM_VKEYTOITEM_HWND(wp, lp)              (HWND)(lp)
#define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) \
        (WPARAM)MAKELONG(item, code), (LPARAM)(hwnd)

#define GET_EM_SETSEL_START(wp, lp)                 (INT)(wp)
#define GET_EM_SETSEL_END(wp, lp)                   (lp)
#define GET_EM_SETSEL_MPS(iStart, iEnd) \
        (WPARAM)(iStart), (LONG)(iEnd)

#define GET_EM_LINESCROLL_MPS(vert, horz)     \
        (WPARAM)horz, (LONG)vert

#define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)       (HWND)(lp)

#define GET_WM_HSCROLL_CODE(wp, lp)                 LOWORD(wp)
#define GET_WM_HSCROLL_POS(wp, lp)                  HIWORD(wp)
#define GET_WM_HSCROLL_HWND(wp, lp)                 (HWND)(lp)
#define GET_WM_HSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)MAKELONG(code, pos), (LPARAM)(hwnd)

#define GET_WM_VSCROLL_CODE(wp, lp)                 LOWORD(wp)
#define GET_WM_VSCROLL_POS(wp, lp)                  HIWORD(wp)
#define GET_WM_VSCROLL_HWND(wp, lp)                 (HWND)(lp)
#define GET_WM_VSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)MAKELONG(code, pos), (LPARAM)(hwnd)

/* DDE macros */

__inline UINT_PTR APIENTRY MGetDDElParamLo(UINT msg,LPARAM lParam)
{
    UINT_PTR uiLo;

    if (UnpackDDElParam(msg, lParam, &uiLo, NULL))
        return uiLo;
    else
        return 0;
}
__inline UINT_PTR APIENTRY MGetDDElParamHi(UINT msg,LPARAM lParam)
{
    UINT_PTR uiHi;

    if (UnpackDDElParam(msg, lParam, NULL, &uiHi))
        return uiHi;
    else
        return 0;
}

__inline BOOL APIENTRY MPostDDEMsg(HWND hwndTo,UINT msg,HWND hwndFrom,UINT_PTR uiLo,UINT_PTR uiHi)
{
    LPARAM lParam;

    lParam = PackDDElParam(msg, uiLo, uiHi);
    if (lParam) {
        if (PostMessage(hwndTo, msg, (WPARAM)hwndFrom, lParam)) {
            return(TRUE);
        }
        FreeDDElParam(msg, lParam);
    }
    return(FALSE);
}

#define DDEFREE(msg, lp)                            FreeDDElParam(msg, lp)

#define GET_WM_DDE_ACK_STATUS(wp, lp)               ((WORD)MGetDDElParamLo(WM_DDE_ACK, lp))
#define GET_WM_DDE_ACK_ITEM(wp, lp)                 ((ATOM)MGetDDElParamHi(WM_DDE_ACK, lp))
#define MPostWM_DDE_ACK(hTo, hFrom, wStatus, aItem) \
        MPostDDEMsg(hTo, WM_DDE_ACK, hFrom, (UINT_PTR)wStatus, (UINT_PTR)aItem)

#define GET_WM_DDE_ADVISE_HOPTIONS(wp, lp)          ((HANDLE)MGetDDElParamLo(WM_DDE_ADVISE, lp))
#define GET_WM_DDE_ADVISE_ITEM(wp, lp)              ((ATOM)MGetDDElParamHi(WM_DDE_ADVISE, lp))
#define MPostWM_DDE_ADVISE(hTo, hFrom, hOptions, aItem) \
        MPostDDEMsg(hTo, WM_DDE_ADVISE, hFrom, (UINT_PTR)hOptions, (UINT_PTR)aItem)

#define GET_WM_DDE_DATA_HDATA(wp, lp)               ((HANDLE)MGetDDElParamLo(WM_DDE_DATA, lp))
#define GET_WM_DDE_DATA_ITEM(wp, lp)                ((ATOM)MGetDDElParamHi(WM_DDE_DATA, lp))
#define MPostWM_DDE_DATA(hTo, hFrom, hData, aItem) \
        MPostDDEMsg(hTo, WM_DDE_DATA, hFrom, (UINT_PTR)hData, (UINT_PTR)aItem)

#define GET_WM_DDE_EXECUTE_HDATA(wp, lp)            ((HANDLE)lp)
#define MPostWM_DDE_EXECUTE(hTo, hFrom, hDataExec) \
        PostMessage(hTo, WM_DDE_EXECUTE, (WPARAM)hFrom, (LPARAM)hDataExec)

#define GET_WM_DDE_POKE_HDATA(wp, lp)               ((HANDLE)MGetDDElParamLo(WM_DDE_POKE, lp))
#define GET_WM_DDE_POKE_ITEM(wp, lp)                ((ATOM)MGetDDElParamHi(WM_DDE_POKE, lp))
#define MPostWM_DDE_POKE(hTo, hFrom, hData, aItem) \
        MPostDDEMsg(hTo, WM_DDE_POKE, hFrom, (UINT_PTR)hData, (UINT_PTR)aItem)

#define GET_WM_DDE_EXECACK_STATUS(wp, lp)           ((WORD)MGetDDElParamLo(WM_DDE_ACK, lp))
#define GET_WM_DDE_EXECACK_HDATA(wp, lp)            ((HANDLE)MGetDDElParamHi(WM_DDE_ACK, lp))
#define MPostWM_DDE_EXECACK(hTo, hFrom, wStatus, hCommands) \
        MPostDDEMsg(hTo, WM_DDE_ACK, hFrom, (UINT_PTR)wStatus, (UINT_PTR)hCommands)

#define GET_WM_DDE_REQUEST_FORMAT(wp, lp)           ((ATOM)LOWORD(lp))
#define GET_WM_DDE_REQUEST_ITEM(wp, lp)             ((ATOM)HIWORD(lp))
#define MPostWM_DDE_REQUEST(hTo, hFrom, fmt, aItem) \
        MPostDDEMsg(hTo, WM_DDE_REQUEST, hFrom, (UINT_PTR)fmt, (UINT_PTR)aItem)

#define GET_WM_DDE_UNADVISE_FORMAT(wp, lp)          ((ATOM)LOWORD(lp))
#define GET_WM_DDE_UNADVISE_ITEM(wp, lp)            ((ATOM)HIWORD(lp))
#define MPostWM_DDE_UNADVISE(hTo, hFrom, fmt, aItem) \
        MPostDDEMsg(hTo, WM_DDE_UNADVISE, hFrom, (UINT_PTR)fmt, (UINT_PTR)aItem)

#define MPostWM_DDE_TERMINATE(hTo, hFrom) \
        PostMessage(hTo, WM_DDE_TERMINATE, (WPARAM)hFrom, 0L)


/*-----------------------------------GDI-------------------------------------*/

__inline BOOL APIENTRY MGetAspectRatioFilter(HDC hdc, INT * pcx, INT * pcy)
{
    SIZE Size;
    BOOL fSuccess;

    fSuccess = GetAspectRatioFilterEx(hdc, & Size);
    if (pcx != NULL)
        *pcx  = (INT)Size.cx;
    if (pcy != NULL)
        *pcy = (INT)Size.cy;

    return(fSuccess);
}

__inline BOOL APIENTRY MGetBitmapDimension(HANDLE hBitmap, INT * pcx, INT * pcy)
{

    SIZE Size;
    BOOL fSuccess;

    fSuccess = GetBitmapDimensionEx((HBITMAP)hBitmap, & Size);
    if (pcx != NULL)
        *pcx  = (INT)Size.cx;
    if (pcy != NULL)
        *pcy = (INT)Size.cy;

    return(fSuccess);

}

__inline BOOL APIENTRY MGetBrushOrg(HDC hdc, INT * px, INT * py)
{
    POINT   Point;
    BOOL fSuccess;

    fSuccess = GetBrushOrgEx(hdc, & Point);
    if (px != NULL)
        *px = Point.x;
    if (py != NULL)
        *py = Point.y;

    return(fSuccess);

}

__inline BOOL APIENTRY MGetCurrentPosition(HDC hdc, INT * px, INT * py)
{

    POINT   Point;
    BOOL fSuccess;

    fSuccess = GetCurrentPositionEx(hdc, & Point);
    if (px != NULL)
        *px = Point.x;
    if (py != NULL)
        *py = Point.y;

    return(fSuccess);

}

__inline BOOL APIENTRY MGetTextExtent(HDC hdc, LPSTR lpstr, INT cnt, INT * pcx, INT * pcy)
{
    SIZE Size;
    BOOL fSuccess;

    fSuccess = GetTextExtentPointA(hdc, lpstr, (DWORD)cnt, & Size);
    if (pcx != NULL)
        *pcx = (INT)Size.cx;
    if (pcy != NULL)
        *pcy = (INT)Size.cy;

    return(fSuccess);
}

__inline BOOL APIENTRY MGetViewportExt(HDC hdc, INT * pcx, INT * pcy)
{
    SIZE Size;
    BOOL fSuccess;

    fSuccess = GetViewportExtEx(hdc, & Size);
    if (pcx != NULL)
        *pcx = (INT)Size.cx;
    if (pcy != NULL)
        *pcy = (INT)Size.cy;

    return(fSuccess);
}

__inline BOOL APIENTRY MGetViewportOrg(HDC hdc, INT * px, INT * py)
{
    POINT   Point;
    BOOL    fSuccess;

    fSuccess = GetViewportOrgEx(hdc, & Point);
    if (px != NULL)
        *px = Point.x;
    if (py != NULL)
        *py = Point.y;

    return(fSuccess);
}

__inline BOOL APIENTRY MGetWindowExt(HDC hdc, INT * pcx, INT * pcy)
{
    SIZE Size;
    BOOL fSuccess;

    fSuccess = GetWindowExtEx(hdc, & Size);
    if (pcx != NULL)
        *pcx = (INT)Size.cx;
    if (pcy != NULL)
        *pcy = (INT)Size.cy;

    return(fSuccess);
}

__inline BOOL APIENTRY MGetWindowOrg(HDC hdc, INT * px, INT * py)
{
    POINT   Point;
    BOOL    fSuccess;

    fSuccess = GetWindowOrgEx(hdc, & Point);
    if (px != NULL)
        *px = Point.x;
    if (py != NULL)
        *py = Point.y;

    return(fSuccess);
}

__inline HANDLE APIENTRY MGetMetaFileBits(HMETAFILE hmf)
{
    HANDLE h;
    DWORD dwSize;

    h = GlobalAlloc(0, dwSize = GetMetaFileBitsEx(hmf, 0, NULL));
    if (h) {
        GetMetaFileBitsEx(hmf, dwSize, GlobalLock(h));
        GlobalUnlock(h);
        DeleteMetaFile(hmf);
    }
    return(h);
}

__inline HMETAFILE APIENTRY MSetMetaFileBits(HANDLE h)
{
    HMETAFILE hmf;

    hmf = SetMetaFileBitsEx((UINT) GlobalSize(h), (CONST BYTE *)GlobalLock(h));
    GlobalUnlock(h);
    GlobalFree(h);
    return(hmf);
}


#define MCreateDiscardableBitmap(h, x, y) CreateCompatibleBitmap(h, (DWORD)(x), (DWORD)(y))
#define MMoveTo(hdc, x, y)               MoveToEx(hdc, x, y, NULL)
#define MOffsetViewportOrg(hdc, x, y)    OffsetViewportOrgEx(hdc, x, y, NULL)
#define MOffsetWindowOrg(hdc, x, y)      OffsetWindowOrgEx(hdc, x, y, NULL)
#define MScaleViewportExt(hdc, x, y, xd, yd) ScaleViewportExtEx(hdc, x, y, xd, yd, NULL)
#define MScaleWindowExt(hdc, x, y, xd, yd)   ScaleWindowExtEx(hdc, x, y, xd, yd, NULL)
#define MSetBitmapDimension(hbm, x, y)   SetBitmapDimensionEx(hbm, (DWORD)(x), (DWORD)(y), NULL)
#define MSetBrushOrg(hbm, x, y)          SetBrushOrgEx(hbm, x, y, NULL)
#define MSetViewportExt(hdc, x, y)       SetViewportExtEx(hdc, x, y, NULL)
#define MSetViewportOrg(hdc, x, y)       SetViewportOrgEx(hdc, x, y, NULL)
#define MSetWindowExt(hdc, x, y)         SetWindowExtEx(hdc, x, y, NULL)
#define MSetWindowOrg(hdc, x, y)         SetWindowOrgEx(hdc, x, y, NULL)

/* Removed APIs */

#define MUnrealizeObject(h)          ((h), TRUE)

/*-----------------------------------KERNEL----------------------------------*/

__inline HFILE APIENTRY MDupHandle(HFILE h)
{
    HANDLE hDup;
      if (DuplicateHandle(GetCurrentProcess(), LongToHandle(h), GetCurrentProcess(),
            &hDup, 0, FALSE, DUPLICATE_SAME_ACCESS)) {
        return((HFILE)((ULONG_PTR)hDup));
    }
    return((HFILE)-1);
}

__inline BOOL APIENTRY MFreeDOSEnvironment(LPSTR lpEnv)
{
    return(GlobalFree(GlobalHandle(lpEnv)) == NULL);
}


__inline LPSTR APIENTRY MGetDOSEnvironment(VOID)
{
    // no way to make this work on NT.  TO BE CANNED!!

    // For now, just use an empty string.
    static char szNULL[] = "";

    return(szNULL);
}

__inline HANDLE APIENTRY MGetInstHandle()
{
    return GetModuleHandle( NULL );
}
__inline WORD APIENTRY MGetDriveType(INT nDrive)
{
  CHAR lpPath[] = "A:\\";

  lpPath[0] = (char)(nDrive + 'A');
  return((WORD)GetDriveTypeA((LPSTR)lpPath));
}

__inline BYTE APIENTRY MGetTempDrive(BYTE cDriveLtr)
{
    DWORD  dwReturnLength;
    CHAR   lpBuffer[MAX_PATH];

    if (cDriveLtr == 0) {
        dwReturnLength = GetCurrentDirectoryA(sizeof(lpBuffer), lpBuffer);
    } else {
        dwReturnLength = GetTempPathA(sizeof(lpBuffer), lpBuffer);
    }

    if (dwReturnLength && lpBuffer[0] != '\\') {
        return(lpBuffer[0]);
    } else {
        return('\0');
    }
}

__inline INT APIENTRY MGetTempFileName(BYTE cDriveLtr, LPSTR lpstrPrefix, WORD wUnique,LPSTR lpTempFileName)
{
    DWORD  cb;
    CHAR   lpTempPath[MAX_PATH];

    lpTempPath[0] = '\0';
    if (cDriveLtr & TF_FORCEDRIVE) {
        cb = GetCurrentDirectoryA(sizeof(lpTempPath), lpTempPath);
        if (cb) {
            if (lpTempPath[0] != (cDriveLtr & ~TF_FORCEDRIVE)) {
                lpTempPath[2] = '\\';
                lpTempPath[3] = '\0';
            }
        }
    } else {
        cb = GetTempPathA(sizeof(lpTempPath), lpTempPath);
    }
    return((INT)GetTempFileNameA(lpTempPath, lpstrPrefix, wUnique,
        lpTempFileName));
}

__inline INT APIENTRY MReadComm(HFILE nCid,LPSTR lpBuf,INT nSize)
{
    DWORD cbRead;

    if (!ReadFile(LongToHandle(nCid), lpBuf, nSize, &cbRead, 0))
        return(-(INT)cbRead);
    return((INT)cbRead);
}

__inline INT APIENTRY MWriteComm(HFILE nCid,LPSTR lpBuf,INT nSize)
{
    DWORD cbWritten;

    if (!WriteFile(LongToHandle(nCid), lpBuf, nSize, &cbWritten, 0))
        return(-(INT)cbWritten);
    return((INT)cbWritten);
}


#define GETMAJORVERSION(x)                  ((x)&0xff)
#define GETMINORVERSION(x)                  (((x)>>8)&0xff)

/* FUNCTION MAPPINGS */

#define GetInstanceData(hPrevInst, pbuf, cb) (cb)
#define MOpenComm(lpstr, wqin, wqout) (wqin), (wqout), CreateFile(lpstr,       \
                                           GENERIC_READ | GENERIC_WRITE, 0,    \
                                           NULL,                               \
                                           OPEN_EXISTING | TRUNCATE_EXISTING,  \
                                           FILE_FLAG_WRITE_THROUGH, 0)

#define MSetCommState(h, lpDCB)             SetCommState((HANDLE)h, lpDCB)
#define MCloseComm(h)                       (INT)!CloseHandle((HANDLE)h)
#define MDllSharedAlloc(dwFlags, dwBytes)   GlobalAlloc(GMEM_DDESHARE | dwFlags, dwBytes)
#define MDllSharedFlags(hMem)               GlobalFlags(hMem)
#define MDllSharedFree                      GlobalFree
#define MDllSharedHandle                    GlobalHandle
#define MDllSharedLock                      GlobalLock
#define MDllSharedRealloc(hMem, dwBytes, dwFlags) \
        GlobalReAlloc(hMem, dwBytes, dwFlags)
#define MDllSharedSize                      GlobalSize
#define MDllSharedUnlock                    GlobalUnlock
#define MGetCurrentTask                     GetCurrentThreadId
#define MGetModuleUsage(h)                  ((h), 1)
#define MGetWinFlags()                      WF_PMODE
#define MLoadLibrary(lpsz)                  LoadLibrary(lpsz)
#define MLocalInit(w, p1, p2)               ((w),(p1),(p2),TRUE)
#define MLockData(dummy)
#define MUnlockData(dummy)
#define M_lclose(fh)                        _lclose((HFILE)fh)
#define M_lcreat                            (HFILE)_lcreat
#define MOpenFile                           (HFILE)OpenFile
#define M_llseek(fh, lOff, iOrg)            SetFilePointer(LongToPtr(fh), lOff, NULL, (DWORD)iOrg)
#define MDeleteFile                         DeleteFile
#define M_lopen                             (HFILE)_lopen
#define M_lread(fh, lpBuf, cb)              _lread((HFILE)fh, lpBuf, cb)
#define M_lwrite(fh, lpBuf, cb)             _lwrite((HFILE)fh, lpBuf, cb)

#define MCatch                              setjmp
#define MThrow                              longjmp

#ifdef __cplusplus
}
#endif

#endif      // __PWIN32_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\setupxrc.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    setupxrc.h

Abstract:

    This file contains resource IDs for any program that is run from
    within Setup and wishes to set the current instruction text.

    The IDs are for entries in the setup support dll string table.

Author:

    Ted Miller (tedm) 7-August-1990

Revision History:

--*/

#if _MSC_VER > 1000
#pragma once
#endif


/*
    Send the following message to Setup's main window to set
    instruction text.  wParam is the ID of a string in the
    string table resource of setupdll.dll.  lParam is unused.

    [Note: see also uilstf.h (part of Setup).]
*/

#define     STF_SET_INSTRUCTION_TEXT_RC         (WM_USER + 0x8104)

// IMPORTANT: keep FIRST_EXTERNAL_ID equate (see below) up to date!

// resource IDs for Print Manager Setup instruction text

#define     IDS_PRINTMAN1       1001
#define     IDS_PRINTMAN2       1002
#define     IDS_PRINTMAN3       1003
#define     IDS_PRINTMAN4       1004
#define     IDS_PRINTMAN5       1005
#define     IDS_PRINTMAN6       1006
#define     IDS_PRINTMAN7       1007
#define     IDS_PRINTMAN8       1008
#define     IDS_PRINTMAN9       1009
#define     IDS_PRINTMAN10      1010

// IMPORTANT: keep this equate up to date!
#define     FIRST_EXTERNAL_ID   IDS_PRINTMAN1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\sifmt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       sifmt.h
//
//  Declarations of the SummaryInformation Property Set Format IDs.
//
//--------------------------------------------------------------------------

#ifndef __SIFMT_H__
#define __SIFMT_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

extern const FMTID FMTID_SummaryInformation;
extern const FMTID FMTID_DocSummaryInformation;
extern const FMTID FMTID_UserDefinedProperties;

#ifdef __cplusplus
}
#endif


#endif // __SIFMT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\sisbkup.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

	sisbackup.h

Abstract:

	External interface for the SIS Backup dll.


Revision History:

--*/

#ifndef __SISBKUP_H__
#define __SISBKUP_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef	__cplusplus
extern "C" {
#endif	// __cplusplus

BOOL __stdcall
SisCreateBackupStructure(
	IN PWCHAR						volumeRoot,
	OUT PVOID						*sisBackupStructure,
	OUT PWCHAR						*commonStoreRootPathname,
	OUT PULONG						countOfCommonStoreFilesToBackup,
	OUT PWCHAR						**commonStoreFilesToBackup);


BOOL __stdcall
SisCSFilesToBackupForLink(
	IN PVOID						sisBackupStructure,
	IN PVOID						reparseData,
	IN ULONG						reparseDataSize,
	IN PVOID						thisFileContext						OPTIONAL,
	OUT PVOID						*matchingFileContext 				OPTIONAL,
	OUT PULONG						countOfCommonStoreFilesToBackup,
	OUT PWCHAR						**commonStoreFilesToBackup);

BOOL __stdcall
SisFreeBackupStructure(
	IN PVOID						sisBackupStructure);

BOOL __stdcall
SisCreateRestoreStructure(
	IN PWCHAR						volumeRoot,
	OUT PVOID						*sisRestoreStructure,
	OUT PWCHAR						*commonStoreRootPathname,
	OUT PULONG						countOfCommonStoreFilesToRestore,
	OUT PWCHAR						**commonStoreFilesToRestore);

BOOL __stdcall
SisRestoredLink(
	IN PVOID						sisRestoreStructure,
	IN PWCHAR						restoredFileName,
	IN PVOID						reparseData,
	IN ULONG						reparseDataSize,
	OUT PULONG						countOfCommonStoreFilesToRestore,
	OUT PWCHAR						**commonStoreFilesToRestore);

BOOL __stdcall
SisRestoredCommonStoreFile(
	IN PVOID						sisRestoreStructure,
	IN PWCHAR						commonStoreFileName);

BOOL __stdcall
SisFreeRestoreStructure(
	IN PVOID						sisRestoreStructure);

VOID __stdcall
SisFreeAllocatedMemory(
	IN PVOID						allocatedSpace);


//
// SIS entry function typedefs
//
typedef BOOL ( FAR __stdcall *PF_SISCREATEBACKUPSTRUCTURE )( PWCHAR, PVOID *, PWCHAR *, PULONG, PWCHAR ** );
typedef BOOL ( FAR __stdcall *PF_SISCSFILESTOBACKUPFORLINK )  (PVOID, PVOID, ULONG, PVOID, PVOID *, PULONG, PWCHAR ** ) ;
typedef BOOL ( FAR __stdcall *PF_SISFREEBACKUPSTRUCTURE )  ( PVOID ) ;

typedef BOOL ( FAR __stdcall *PF_SISCREATERESTORESTRUCTURE)  ( PWCHAR, PVOID *, PWCHAR *, PULONG, PWCHAR ** );
typedef BOOL ( FAR __stdcall *PF_SISRESTOREDLINK )  ( PVOID, PWCHAR, PVOID, ULONG, PULONG, PWCHAR ** ) ;
typedef BOOL ( FAR __stdcall *PF_SISRESTOREDCOMMONSTORFILE) ( PVOID, PWCHAR ) ;

typedef BOOL ( FAR __stdcall *PF_SISFREERESTORESTRUCTURE )( PVOID ) ;
typedef BOOL ( FAR __stdcall *PF_SISFREEALLOCATEDMEMORY )( PVOID ) ;

#ifdef	__cplusplus
}
#endif	// __cplusplus

#endif  // __SISBKUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\pstore.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    pstore.h

Abstract:

    This module defines the Protected Storage COM interface and associated
    data structures.

Author:

    Scott Field (sfield)    13-Mar-97

--*/

#ifndef __PSTORE_H__
#define __PSTORE_H__

#if _MSC_VER > 1000
#pragma once
#endif

/*
    Typedefs, values
*/

// provider flags

// provider capabilities
typedef DWORD PST_PROVIDERCAPABILITIES;

#define PST_PC_PFX              0x00000001
#define PST_PC_HARDWARE         0x00000002
#define PST_PC_SMARTCARD        0x00000004
#define PST_PC_PCMCIA           0x00000008
#define PST_PC_MULTIPLE_REPOSITORIES    0x00000010
#define PST_PC_ROAMABLE         0x00000020


// NYI (not yet implemented)
typedef DWORD PST_REPOSITORYCAPABILITIES;

#define PST_RC_REMOVABLE        0x80000000


// provider storage area
typedef DWORD PST_KEY;

#define PST_KEY_CURRENT_USER    0x00000000
#define PST_KEY_LOCAL_MACHINE   0x00000001



/*
    dwDefaultConfirmationStyle flags
*/

//
// allows user to choose confirmation style
//
#define     PST_CF_DEFAULT              0x00000000

//
// forces silent item creation
//
#define     PST_CF_NONE                 0x00000001



/*
    dwPromptFlags
*/

//
// app forces confirmation to be shown
//
#define     PST_PF_ALWAYS_SHOW          0x00000001


//
// RSABase rqmt: determine if item has ui attached
//
#define     PST_PF_NEVER_SHOW           0x00000002

/*
    dwFlags values
*/

//
// Allows caller to specify creation not overwrite
// of item during WriteItem call
//
#define     PST_NO_OVERWRITE            0x00000002

//
// specifies insecure data stream to be written/read
// there is no protection or guarantees for this data
// flag only valid during item read/write calls
// default: item calls are secure
//
#define     PST_UNRESTRICTED_ITEMDATA   0x00000004


//
// on ReadItem call
// return value on success without UI on item is PST_E_OK
// return value on success with UI on item is PST_E_ITEM_EXISTS
// return value on failure is a different error code
//
#define     PST_PROMPT_QUERY            0x00000008

//
// on ReadItem, DeleteItem, for data migration purposes:
// Avoid displaying UI on ReadItem unless a custom password is required (highsecurity).
// Avoid displaying UI on DeleteItem, period.
//
#define     PST_NO_UI_MIGRATION         0x00000010



/*
    Security masks, rule modifiers
*/

//
// models access after NT access mask
//

// read, write
typedef DWORD PST_ACCESSMODE;

#define     PST_READ                0x0001
#define     PST_WRITE               0x0002


// PST_ACCESSCLAUSETYPE

// memhash, diskhash, authenticode, etc
typedef DWORD PST_ACCESSCLAUSETYPE;

//
// pbClauseData points to PST_AUTHENTICODEDATA structure.
//
#define     PST_AUTHENTICODE            1

//
// pbClauseData points to PST_BINARYCHECKDATA structure.
//
#define     PST_BINARY_CHECK            2

//
// pbClauseData points to valid Windows NT security descriptor.
// note that performance is improved on Set operations if the security
// descriptor is in self-relative format, with valid owner and group Sids
// (non-NULL).
//
#define     PST_SECURITY_DESCRIPTOR     4

//
// pbClauseData is in self-relative format
// (for internal use only)
//
#define     PST_SELF_RELATIVE_CLAUSE    0x80000000L

//
// currently access clause modifiers - NOT to be or'd together
//


//
// specified image is the immediate caller, and is an application (.exe)
//

#define     PST_AC_SINGLE_CALLER        0

//
// specified image is not necessary the immediate caller, and is an
// application (.exe)
//

#define     PST_AC_TOP_LEVEL_CALLER     1

//
// specified image is the immediate caller.  May be
// an application (.exe) or a .dll
//

#define     PST_AC_IMMEDIATE_CALLER     2


/*
    Provider Parameters
*/
//
// flush the internal cache of passwords -- temporary?
//
#define     PST_PP_FLUSH_PW_CACHE       0x1




/*
    Provider Defns
*/

//
// Microsoft Base Provider (MS_BASE_PSTPROVIDER...)
//
#define MS_BASE_PSTPROVIDER_NAME            L"System Protected Storage"

// {8A078C30-3755-11d0-A0BD-00AA0061426A}
#define MS_BASE_PSTPROVIDER_ID              { 0x8a078c30, 0x3755, 0x11d0, { 0xa0, 0xbd, 0x0, 0xaa, 0x0, 0x61, 0x42, 0x6a } }
#define MS_BASE_PSTPROVIDER_SZID            L"8A078C30-3755-11d0-A0BD-00AA0061426A"

//
// Microsoft PFX Provider (MS_PFX_PSTPROVIDER...)
//
#define MS_PFX_PSTPROVIDER_NAME             L"PFX Storage Provider"

// {3ca94f30-7ac1-11d0-8c42-00c04fc299eb}
#define MS_PFX_PSTPROVIDER_ID               { 0x3ca94f30, 0x7ac1, 0x11d0, {0x8c, 0x42, 0x00, 0xc0, 0x4f, 0xc2, 0x99, 0xeb} }
#define MS_PFX_PSTPROVIDER_SZID             L"3ca94f30-7ac1-11d0-8c42-00c04fc299eb"



/*
    Globally registered Type/Subtype guid/name pairs
*/

#define PST_CONFIGDATA_TYPE_STRING              L"Configuration Data"
// 8ec99652-8909-11d0-8c4d-00c04fc297eb
#define PST_CONFIGDATA_TYPE_GUID                        \
{   0x8ec99652,                                         \
    0x8909,                                             \
    0x11d0,                                             \
    {0x8c, 0x4d, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}

#define PST_PROTECTEDSTORAGE_SUBTYPE_STRING     L"Protected Storage"
// d3121b8e-8a7d-11d0-8c4f-00c04fc297eb
#define PST_PROTECTEDSTORAGE_SUBTYPE_GUID               \
{   0xd3121b8e,                                         \
    0x8a7d,                                             \
    0x11d0,                                             \
    {0x8c, 0x4f, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}


#define PST_PSTORE_PROVIDERS_SUBTYPE_STRING     L"Protected Storage Provider List"
// 8ed17a64-91d0-11d0-8c43-00c04fc2c621
#define PST_PSTORE_PROVIDERS_SUBTYPE_GUID               \
{                                                       \
    0x8ed17a64,                                         \
    0x91d0,                                             \
    0x11d0,                                             \
    {0x8c, 0x43, 0x00, 0xc0, 0x4f, 0xc2, 0xc6, 0x21}    \
}


//
// error codes
//


#ifndef PST_E_OK
#define PST_E_OK                        _HRESULT_TYPEDEF_(0x00000000L)


#define PST_E_FAIL                      _HRESULT_TYPEDEF_(0x800C0001L)
#define PST_E_PROV_DLL_NOT_FOUND        _HRESULT_TYPEDEF_(0x800C0002L)
#define PST_E_INVALID_HANDLE            _HRESULT_TYPEDEF_(0x800C0003L)
#define PST_E_TYPE_EXISTS               _HRESULT_TYPEDEF_(0x800C0004L)
#define PST_E_TYPE_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0005L)
#define PST_E_INVALID_RULESET           _HRESULT_TYPEDEF_(0x800C0006L)
#define PST_E_NO_PERMISSIONS            _HRESULT_TYPEDEF_(0x800C0007L)
#define PST_E_STORAGE_ERROR             _HRESULT_TYPEDEF_(0x800C0008L)
#define PST_E_CALLER_NOT_VERIFIED       _HRESULT_TYPEDEF_(0x800C0009L)
#define PST_E_WRONG_PASSWORD            _HRESULT_TYPEDEF_(0x800C000AL)
#define PST_E_DISK_IMAGE_MISMATCH       _HRESULT_TYPEDEF_(0x800C000BL)
// 000C pending
#define PST_E_UNKNOWN_EXCEPTION         _HRESULT_TYPEDEF_(0x800C000DL)
#define PST_E_BAD_FLAGS                 _HRESULT_TYPEDEF_(0x800C000EL)
#define PST_E_ITEM_EXISTS               _HRESULT_TYPEDEF_(0x800C000FL)
#define PST_E_ITEM_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0010L)
#define PST_E_SERVICE_UNAVAILABLE       _HRESULT_TYPEDEF_(0x800C0011L)
#define PST_E_NOTEMPTY                  _HRESULT_TYPEDEF_(0x800C0012L)
#define PST_E_INVALID_STRING            _HRESULT_TYPEDEF_(0x800C0013L)
#define PST_E_STATE_INVALID             _HRESULT_TYPEDEF_(0x800C0014L)
#define PST_E_NOT_OPEN                  _HRESULT_TYPEDEF_(0x800C0015L)
#define PST_E_ALREADY_OPEN              _HRESULT_TYPEDEF_(0x800C0016L)
#define PST_E_NYI                       _HRESULT_TYPEDEF_(0x800C0F00L)


#define MIN_PST_ERROR                   0x800C0001
#define MAX_PST_ERROR                   0x800C0F00

#endif  // !PST_OK



/* this ALWAYS GENERATED file contains the definitions for the interfaces */

//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

/* header files for imported files */
#include "wtypes.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Wed Apr 23 23:56:10 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


typedef DWORD PST_PROVIDERCAPABILITIES;

typedef DWORD PST_REPOSITORYCAPABILITIES;

typedef DWORD PST_KEY;

typedef DWORD PST_ACCESSMODE;

typedef DWORD PST_ACCESSCLAUSETYPE;

typedef GUID UUID;

typedef ULARGE_INTEGER PST_PROVIDER_HANDLE;

typedef GUID PST_PROVIDERID;

typedef PST_PROVIDERID __RPC_FAR *PPST_PROVIDERID;

typedef struct  _PST_PROVIDERINFO
    {
    DWORD cbSize;
    PST_PROVIDERID ID;
    PST_PROVIDERCAPABILITIES Capabilities;
    LPWSTR szProviderName;
    }   PST_PROVIDERINFO;

typedef struct _PST_PROVIDERINFO __RPC_FAR *PPST_PROVIDERINFO;

typedef struct  _PST_TYPEINFO
    {
    DWORD cbSize;
    LPWSTR szDisplayName;
    }   PST_TYPEINFO;

typedef struct _PST_TYPEINFO __RPC_FAR *PPST_TYPEINFO;

typedef struct  _PST_PROMPTINFO
    {
    DWORD cbSize;
    DWORD dwPromptFlags;
    HWND  hwndApp;
    LPCWSTR szPrompt;
    }   PST_PROMPTINFO;

typedef struct _PST_PROMPTINFO __RPC_FAR *PPST_PROMPTINFO;

typedef struct  _PST_ACCESSCLAUSE
    {
    DWORD cbSize;
    PST_ACCESSCLAUSETYPE ClauseType;
    DWORD cbClauseData;
    /* [size_is] */ VOID __RPC_FAR *pbClauseData;
    }   PST_ACCESSCLAUSE;

typedef struct _PST_ACCESSCLAUSE __RPC_FAR *PPST_ACCESSCLAUSE;

typedef struct  _PST_ACCESSRULE
    {
    DWORD cbSize;
    PST_ACCESSMODE AccessModeFlags;
    DWORD cClauses;
    /* [size_is] */ PST_ACCESSCLAUSE __RPC_FAR *rgClauses;
    }   PST_ACCESSRULE;

typedef struct _PST_ACCESSRULE __RPC_FAR *PPST_ACCESSRULE;

typedef struct  _PST_ACCESSRULESET
    {
    DWORD cbSize;
    DWORD cRules;
    /* [size_is] */ PST_ACCESSRULE __RPC_FAR *rgRules;
    }   PST_ACCESSRULESET;

typedef struct _PST_ACCESSRULESET __RPC_FAR *PPST_ACCESSRULESET;

typedef struct  _PST_AUTHENTICODEDATA
    {
    DWORD cbSize;
    DWORD dwModifiers;
    LPCWSTR szRootCA;
    LPCWSTR szIssuer;
    LPCWSTR szPublisher;
    LPCWSTR szProgramName;
    }   PST_AUTHENTICODEDATA;

typedef struct _PST_AUTHENTICODEDATA __RPC_FAR *PPST_AUTHENTICODEDATA;

typedef struct _PST_AUTHENTICODEDATA __RPC_FAR *LPPST_AUTHENTICODEDATA;

typedef struct  _PST_BINARYCHECKDATA
    {
    DWORD cbSize;
    DWORD dwModifiers;
    LPCWSTR szFilePath;
    }   PST_BINARYCHECKDATA;

typedef struct _PST_BINARYCHECKDATA __RPC_FAR *PPST_BINARYCHECKDATA;

typedef struct _PST_BINARYCHECKDATA __RPC_FAR *LPPST_BINARYCHECKDATA;



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif



/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Wed Apr 23 23:56:14 1997
 */
/* Compiler settings for pstorec.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

#ifndef __IEnumPStoreItems_FWD_DEFINED__
#define __IEnumPStoreItems_FWD_DEFINED__
typedef interface IEnumPStoreItems IEnumPStoreItems;
#endif  /* __IEnumPStoreItems_FWD_DEFINED__ */


#ifndef __IEnumPStoreTypes_FWD_DEFINED__
#define __IEnumPStoreTypes_FWD_DEFINED__
typedef interface IEnumPStoreTypes IEnumPStoreTypes;
#endif  /* __IEnumPStoreTypes_FWD_DEFINED__ */


#ifndef __IPStore_FWD_DEFINED__
#define __IPStore_FWD_DEFINED__
typedef interface IPStore IPStore;
#endif  /* __IPStore_FWD_DEFINED__ */


#ifndef __IEnumPStoreProviders_FWD_DEFINED__
#define __IEnumPStoreProviders_FWD_DEFINED__
typedef interface IEnumPStoreProviders IEnumPStoreProviders;
#endif  /* __IEnumPStoreProviders_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

#ifndef __IEnumPStoreItems_INTERFACE_DEFINED__
#define __IEnumPStoreItems_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreItems
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreItems;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreItems : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out] */ LPWSTR __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreItemsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreItems __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreItems __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out] */ LPWSTR __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreItems __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreItemsVtbl;

    interface IEnumPStoreItems
    {
        CONST_VTBL struct IEnumPStoreItemsVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreItems_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreItems_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreItems_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreItems_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreItems_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreItems_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreItems_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Next_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out] */ LPWSTR __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreItems_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Skip_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreItems_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Reset_Proxy(
    IEnumPStoreItems __RPC_FAR * This);


void __RPC_STUB IEnumPStoreItems_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Clone_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreItems_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreItems_INTERFACE_DEFINED__ */


#ifndef __IEnumPStoreTypes_INTERFACE_DEFINED__
#define __IEnumPStoreTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreTypes
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreTypes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out][size_is] */ GUID __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreTypesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreTypes __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreTypes __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out][size_is] */ GUID __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreTypes __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreTypesVtbl;

    interface IEnumPStoreTypes
    {
        CONST_VTBL struct IEnumPStoreTypesVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreTypes_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreTypes_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreTypes_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreTypes_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreTypes_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreTypes_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreTypes_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Next_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ GUID __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreTypes_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Skip_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreTypes_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Reset_Proxy(
    IEnumPStoreTypes __RPC_FAR * This);


void __RPC_STUB IEnumPStoreTypes_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Clone_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreTypes_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreTypes_INTERFACE_DEFINED__ */


#ifndef __IPStore_INTERFACE_DEFINED__
#define __IPStore_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPStore
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IPStore;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IPStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo(
            /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetProvParam(
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetProvParam(
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CreateType(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteType(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CreateSubtype(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetSubtypeInfo(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteSubtype(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ReadAccessRuleset(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE WriteAccessRuleset(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumTypes(
            /* [in] */ PST_KEY Key,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumSubtypes(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ReadItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE WriteItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwDefaultConfirmationStyle,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE OpenItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PST_ACCESSMODE ModeFlags,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CloseItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumItems(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IPStoreVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IPStore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IPStore __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IPStore __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )(
            IPStore __RPC_FAR * This,
            /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProvParam )(
            IPStore __RPC_FAR * This,
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProvParam )(
            IPStore __RPC_FAR * This,
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateType )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteType )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSubtype )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubtypeInfo )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteSubtype )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadAccessRuleset )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteAccessRuleset )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumTypes )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumSubtypes )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwDefaultConfirmationStyle,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PST_ACCESSMODE ModeFlags,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumItems )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IPStoreVtbl;

    interface IPStore
    {
        CONST_VTBL struct IPStoreVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IPStore_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPStore_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IPStore_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IPStore_GetInfo(This,ppProperties)  \
    (This)->lpVtbl -> GetInfo(This,ppProperties)

#define IPStore_GetProvParam(This,dwParam,pcbData,ppbData,dwFlags)  \
    (This)->lpVtbl -> GetProvParam(This,dwParam,pcbData,ppbData,dwFlags)

#define IPStore_SetProvParam(This,dwParam,cbData,pbData,dwFlags)    \
    (This)->lpVtbl -> SetProvParam(This,dwParam,cbData,pbData,dwFlags)

#define IPStore_CreateType(This,Key,pType,pInfo,dwFlags)    \
    (This)->lpVtbl -> CreateType(This,Key,pType,pInfo,dwFlags)

#define IPStore_GetTypeInfo(This,Key,pType,ppInfo,dwFlags)  \
    (This)->lpVtbl -> GetTypeInfo(This,Key,pType,ppInfo,dwFlags)

#define IPStore_DeleteType(This,Key,pType,dwFlags)  \
    (This)->lpVtbl -> DeleteType(This,Key,pType,dwFlags)

#define IPStore_CreateSubtype(This,Key,pType,pSubtype,pInfo,pRules,dwFlags) \
    (This)->lpVtbl -> CreateSubtype(This,Key,pType,pSubtype,pInfo,pRules,dwFlags)

#define IPStore_GetSubtypeInfo(This,Key,pType,pSubtype,ppInfo,dwFlags)  \
    (This)->lpVtbl -> GetSubtypeInfo(This,Key,pType,pSubtype,ppInfo,dwFlags)

#define IPStore_DeleteSubtype(This,Key,pType,pSubtype,dwFlags)  \
    (This)->lpVtbl -> DeleteSubtype(This,Key,pType,pSubtype,dwFlags)

#define IPStore_ReadAccessRuleset(This,Key,pType,pSubtype,ppRules,dwFlags)  \
    (This)->lpVtbl -> ReadAccessRuleset(This,Key,pType,pSubtype,ppRules,dwFlags)

#define IPStore_WriteAccessRuleset(This,Key,pType,pSubtype,pRules,dwFlags)  \
    (This)->lpVtbl -> WriteAccessRuleset(This,Key,pType,pSubtype,pRules,dwFlags)

#define IPStore_EnumTypes(This,Key,dwFlags,ppenum)  \
    (This)->lpVtbl -> EnumTypes(This,Key,dwFlags,ppenum)

#define IPStore_EnumSubtypes(This,Key,pType,dwFlags,ppenum) \
    (This)->lpVtbl -> EnumSubtypes(This,Key,pType,dwFlags,ppenum)

#define IPStore_DeleteItem(This,Key,pItemType,pItemSubtype,szItemName,pPromptInfo,dwFlags)  \
    (This)->lpVtbl -> DeleteItem(This,Key,pItemType,pItemSubtype,szItemName,pPromptInfo,dwFlags)

#define IPStore_ReadItem(This,Key,pItemType,pItemSubtype,szItemName,pcbData,ppbData,pPromptInfo,dwFlags)    \
    (This)->lpVtbl -> ReadItem(This,Key,pItemType,pItemSubtype,szItemName,pcbData,ppbData,pPromptInfo,dwFlags)

#define IPStore_WriteItem(This,Key,pItemType,pItemSubtype,szItemName,cbData,pbData,pPromptInfo,dwDefaultConfirmationStyle,dwFlags)  \
    (This)->lpVtbl -> WriteItem(This,Key,pItemType,pItemSubtype,szItemName,cbData,pbData,pPromptInfo,dwDefaultConfirmationStyle,dwFlags)

#define IPStore_OpenItem(This,Key,pItemType,pItemSubtype,szItemName,ModeFlags,pPromptInfo,dwFlags)  \
    (This)->lpVtbl -> OpenItem(This,Key,pItemType,pItemSubtype,szItemName,ModeFlags,pPromptInfo,dwFlags)

#define IPStore_CloseItem(This,Key,pItemType,pItemSubtype,szItemName,dwFlags)   \
    (This)->lpVtbl -> CloseItem(This,Key,pItemType,pItemSubtype,szItemName,dwFlags)

#define IPStore_EnumItems(This,Key,pItemType,pItemSubtype,dwFlags,ppenum)   \
    (This)->lpVtbl -> EnumItems(This,Key,pItemType,pItemSubtype,dwFlags,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IPStore_GetInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties);


void __RPC_STUB IPStore_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetProvParam_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ DWORD dwParam,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetProvParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_SetProvParam_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ DWORD dwParam,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_SetProvParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CreateType_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CreateType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetTypeInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteType_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CreateSubtype_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CreateSubtype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetSubtypeInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetSubtypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteSubtype_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteSubtype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_ReadAccessRuleset_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_ReadAccessRuleset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_WriteAccessRuleset_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_WriteAccessRuleset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumTypes_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumSubtypes_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumSubtypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_ReadItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_ReadItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_WriteItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwDefaultConfirmationStyle,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_WriteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_OpenItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PST_ACCESSMODE ModeFlags,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_OpenItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CloseItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CloseItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumItems_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IPStore_INTERFACE_DEFINED__ */


#ifndef __IEnumPStoreProviders_INTERFACE_DEFINED__
#define __IEnumPStoreProviders_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreProviders
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreProviders;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreProviders : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreProvidersVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreProviders __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreProviders __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreProviders __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreProvidersVtbl;

    interface IEnumPStoreProviders
    {
        CONST_VTBL struct IEnumPStoreProvidersVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreProviders_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreProviders_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreProviders_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreProviders_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreProviders_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreProviders_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreProviders_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Next_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreProviders_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Skip_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreProviders_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Reset_Proxy(
    IEnumPStoreProviders __RPC_FAR * This);


void __RPC_STUB IEnumPStoreProviders_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Clone_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreProviders_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreProviders_INTERFACE_DEFINED__ */



#ifndef __PSTORECLib_LIBRARY_DEFINED__
#define __PSTORECLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: PSTORECLib
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [helpstring][version][uuid] */



EXTERN_C const IID LIBID_PSTORECLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CPStore;

class CPStore;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CEnumTypes;

class CEnumTypes;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CEnumItems;

class CEnumItems;
#endif
#endif /* __PSTORECLib_LIBRARY_DEFINED__ */

/****************************************
 * Generated header for interface: __MIDL__intf_0080
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


HRESULT __stdcall PStoreCreateInstance(
    IPStore __RPC_FAR *__RPC_FAR *ppProvider,
    PST_PROVIDERID __RPC_FAR *pProviderID,
    void __RPC_FAR *pReserved,
    DWORD dwFlags);

HRESULT __stdcall PStoreEnumProviders(
    DWORD dwFlags,
    IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);



extern RPC_IF_HANDLE __MIDL__intf_0080_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0080_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif // PSTORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\pwin16.h ===
/*****************************************************************************\
* Copyright (C) Microsoft Corporation, 1990-1999
* PWIN16.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides macros to map portable windows code to its 16 bit form.
\*****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

/*-----------------------------------USER------------------------------------*/

DWORD FAR PASCAL     MGetLastError(VOID);
DWORD FAR PASCAL     MSendMsgEM_GETSEL(HWND hDlg, INT FAR *piStart, INT FAR *piEnd);

/* HELPER MACROS */

#define MAPVALUE(v16, v32)              (v16)
#define MAPTYPE(v16, v32)               v16
#define MAKEMPOINT(l)                   (*((MPOINT FAR *)&(l)))
#define MPOINT2POINT(mpt, pt)           (pt = *(POINT FAR *)&(mpt))
#define POINT2MPOINT(pt, mpt)           (mpt = *(MPOINT FAR *)&(pt))
#define LONG2POINT(l, pt)               ((pt).x = (INT)LOWORD(l), (pt).y = (INT)HIWORD(l))

#define GETWINDOWUINT(hwnd, index)      (UINT)GetWindowWord(hwnd, index)
#define SETWINDOWUINT(hwnd, index, ui)  (UINT)SetWindowWord(hwnd, index, (WORD)(ui))
#define SETCLASSUINT(hwnd, index, ui)   (UINT)SetClassWord(hwnd, index, (WORD)(ui))
#define GETCLASSUINT(hwnd, index)       (UINT)GetClassWord(hwnd, index)

#define GETCBCLSEXTRA(hwnd)             GETCLASSUINT(hwnd, GCW_CBCLSEXTRA)
#define SETCBCLSEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCW_CBCLSEXTRA, cb)
#define GETCBWNDEXTRA(hwnd)             GETCLASSUINT(hwnd, GCW_CBWNDEXTRA)
#define SETCBWNDEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCW_CBWNDEXTRA, cb)
#define GETCLASSBRBACKGROUND(hwnd)      (HBRUSH)GETCLASSUINT(hwnd, GCW_HBRBACKGROUND)
#define SETCLASSBRBACKGROUND(hwnd, h)   (HBRUSH)SETCLASSUINT(hwnd, GCW_HBRBACKGROUND, h)
#define GETCLASSCURSOR(hwnd)            (HCURSOR)GETCLASSUINT(hwnd, GCW_HCURSOR)
#define SETCLASSCURSOR(hwnd, h)         (HCURSOR)SETCLASSUINT(hwnd, GCW_HCURSOR, h)
#define GETCLASSHMODULE(hwnd)           (HMODULE)GETCLASSUINT(hwnd, GCW_HMODULE)
#define SETCLASSHMODULE(hwnd, h)        (HMODULE)SETCLASSUINT(hwnd, GCW_HMODULE, h)
#define GETCLASSICON(hwnd)              (HICON)GETCLASSUINT((hwnd), GCW_HICON)
#define SETCLASSICON(hwnd, h)           (HICON)SETCLASSUINT((hwnd), GCW_HICON, h)
#define GETCLASSSTYLE(hwnd)             GETCLASSUINT((hwnd), GCW_STYLE)
#define SETCLASSSTYLE(hwnd, style)      SETCLASSUINT((hwnd), GCW_STYLE, style)
#define GETHWNDINSTANCE(hwnd)           (HMODULE)GETWINDOWUINT((hwnd), GWW_HINSTANCE)
#define SETHWNDINSTANCE(hwnd, h)        (HMODULE)SETWINDOWUINT((hwnd), GWW_HINSTANCE, h)
#define GETHWNDPARENT(hwnd)             (HWND)GETWINDOWUINT((hwnd), GWW_HWNDPARENT)
#define SETHWNDPARENT(hwnd, h)          (HWND)SETWINDOWUINT((hwnd), GWW_HWNDPARENT, h)
#define GETWINDOWID(hwnd)               GETWINDOWUINT((hwnd), GWW_ID)
#define SETWINDOWID(hwnd, id)           SETWINDOWUINT((hwnd), GWW_ID, id)

/* USER API */

#define MDlgDirSelect(hDlg, lpstr, nLength, nIDListBox) \
            DlgDirSelect(hDlg, lpstr, nIDListBox)

#define MDlgDirSelectCOMBOBOX(hDlg, lpstr, nLength, nIDComboBox) \
            DlgDirSelectComboBox(hDlg, lpstr, nIDComboBox)

#define MMain(hInst, hPrevInst, lpCmdLine, nCmdShow) \
   INT PASCAL WinMain(HANDLE hInst, HANDLE hPrevInst, LPSTR lpCmdLine, \
   INT nCmdShow) {  \
   INT _argc;       \
   CHAR **_argv;

/* USER MESSAGES: */

#define GET_WPARAM(wp, lp)                      (wp)
#define GET_LPARAM(wp, lp)                      (lp)

#define WM_CTLCOLORMSGBOX       0x0132
#define WM_CTLCOLOREDIT         0x0133
#define WM_CTLCOLORLISTBOX      0x0134
#define WM_CTLCOLORBTN          0x0135
#define WM_CTLCOLORDLG          0x0136
#define WM_CTLCOLORSCROLLBAR    0x0137
#define WM_CTLCOLORSTATIC       0x0138

#define GET_WM_ACTIVATE_STATE(wp, lp)               (wp)
#define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)          (BOOL)HIWORD(lp)
#define GET_WM_ACTIVATE_HWND(wp, lp)                (HWND)LOWORD(lp)
#define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)   \
        (WPARAM)(s), MAKELONG(hwnd, fmin)

#define GET_WM_CHARTOITEM_CHAR(wp, lp)              (CHAR)(wp)
#define GET_WM_CHARTOITEM_POS(wp, lp)               HIWORD(lp)
#define GET_WM_CHARTOITEM_HWND(wp, lp)              (HWND)LOWORD(lp)
#define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd) \
        (WPARAM)(ch), MAKELONG(hwnd, pos)

#define GET_WM_COMMAND_ID(wp, lp)                   (wp)
#define GET_WM_COMMAND_HWND(wp, lp)                 (HWND)LOWORD(lp)
#define GET_WM_COMMAND_CMD(wp, lp)                  HIWORD(lp)
#define GET_WM_COMMAND_MPS(id, hwnd, cmd)    \
        (WPARAM)(id), MAKELONG(hwnd, cmd)

#define GET_WM_CTLCOLOR_HDC(wp, lp, msg)            (HDC)(wp)
#define GET_WM_CTLCOLOR_HWND(wp, lp, msg)           (HWND)LOWORD(lp)
#define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)           HIWORD(lp)
#define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type) \
        (WPARAM)(hdc), MAKELONG(hwnd, type)

#define GET_WM_MENUSELECT_CMD(wp, lp)               (wp)
#define GET_WM_MENUSELECT_FLAGS(wp, lp)             LOWORD(lp)
#define GET_WM_MENUSELECT_HMENU(wp, lp)             (HMENU)HIWORD(lp)
#define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)  \
        (WPARAM)(cmd), MAKELONG(f, hmenu)

// Note: the following are for interpreting MDIclient to MDI child messages.
#define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (BOOL)(wp)
#define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
#define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)
// Note: the following is for sending to the MDI client window.
#define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA)\
        (WPARAM)(hwndA), 0

#define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW) 0, MAKELONG(hmenuF, hmenuW)

#define GET_WM_MENUCHAR_CHAR(wp, lp)                (CHAR)(wp)
#define GET_WM_MENUCHAR_HMENU(wp, lp)               (HMENU)LOWORD(lp)
#define GET_WM_MENUCHAR_FMENU(wp, lp)               (BOOL)HIWORD(lp)
#define GET_WM_MENUCHAR_MPS(ch, hmenu, f)    \
        (WPARAM)(ch), MAKELONG(hmenu, f)

#define GET_WM_PARENTNOTIFY_MSG(wp, lp)             (wp)
#define GET_WM_PARENTNOTIFY_ID(wp, lp)              HIWORD(lp)
#define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)       (HWND)LOWORD(lp)
#define GET_WM_PARENTNOTIFY_X(wp, lp)               (INT)LOWORD(lp)
#define GET_WM_PARENTNOTIFY_Y(wp, lp)               (INT)HIWORD(lp)
#define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd) \
        (WPARAM)(msg), MAKELONG(hwnd, id)
#define GET_WM_PARENTNOTIFY2_MPS(msg, x, y) \
        (WPARAM)(msg), MAKELONG(x, y)

#define GET_WM_VKEYTOITEM_CODE(wp, lp)              (wp)
#define GET_WM_VKEYTOITEM_ITEM(wp, lp)              (INT)HIWORD(lp)
#define GET_WM_VKEYTOITEM_HWND(wp, lp)              (HWND)LOWORD(lp)
#define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) \
        (WPARAM)(code), MAKELONG(hwnd, item)

#define GET_EM_SETSEL_START(wp, lp)                 LOWORD(lp)
#define GET_EM_SETSEL_END(wp, lp)                   HIWORD(lp)
#define GET_EM_SETSEL_MPS(iStart, iEnd) \
        0, MAKELONG(iStart, iEnd)

#define GET_EM_LINESCROLL_MPS(vert, horz)     \
        0, MAKELONG(vert, horz)

#define GET_WM_HSCROLL_CODE(wp, lp)                 (wp)
#define GET_WM_HSCROLL_POS(wp, lp)                  LOWORD(lp)
#define GET_WM_HSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
#define GET_WM_HSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)(code), MAKELONG(pos, hwnd)

#define GET_WM_VSCROLL_CODE(wp, lp)                 (wp)
#define GET_WM_VSCROLL_POS(wp, lp)                  LOWORD(lp)
#define GET_WM_VSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
#define GET_WM_VSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)(code), MAKELONG(pos, hwnd)

#define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)       (HWND)LOWORD(lp)

#define DDEFREE(msg, lp)

#define GET_WM_DDE_ACK_STATUS(wp, lp)               LOWORD(lp)
#define GET_WM_DDE_ACK_ITEM(wp, lp)                 (ATOM)HIWORD(lp)
#define MPostWM_DDE_ACK(hTo, hFrom, wStatus, aItem) \
        PostMessage(hTo, WM_DDE_ACK, (WPARAM)hFrom, MAKELONG(wStatus, aItem))

#define GET_WM_DDE_ADVISE_HOPTIONS(wp, lp)          (HANDLE)LOWORD(lp)
#define GET_WM_DDE_ADVISE_ITEM(wp, lp)              (ATOM)HIWORD(lp)
#define MPostWM_DDE_ADVISE(hTo, hFrom, hOptions, aItem) \
        PostMessage(hTo, WM_DDE_ADVISE, (WPARAM)hFrom, MAKELONG(hOptions, aItem))

#define GET_WM_DDE_DATA_HDATA(wp, lp)               (HANDLE)LOWORD(lp)
#define GET_WM_DDE_DATA_ITEM(wp, lp)                (ATOM)HIWORD(lp)
#define MPostWM_DDE_DATA(hTo, hFrom, hData, aItem) \
        PostMessage(hTo, WM_DDE_DATA, (WPARAM)hFrom, MAKELONG(hData, aItem))

#define GET_WM_DDE_EXECUTE_HDATA(wp, lp)            (HANDLE)HIWORD(lp)
#define MPostWM_DDE_EXECUTE(hTo, hFrom, hDataExec) \
        PostMessage(hTo, WM_DDE_EXECUTE, (WPARAM)hFrom, MAKELONG(0, hDataExec))

#define GET_WM_DDE_POKE_HDATA(wp, lp)               (HANDLE)LOWORD(lp)
#define GET_WM_DDE_POKE_ITEM(wp, lp)                (ATOM)HIWORD(lp)
#define MPostWM_DDE_POKE(hTo, hFrom, hData, aItem) \
        PostMessage(hTo, WM_DDE_POKE, (WPARAM)hFrom, MAKELONG(hData, aItem))

#define GET_WM_DDE_EXECACK_STATUS(wp, lp)           (WORD)LOWORD(lp)
#define GET_WM_DDE_EXECACK_HDATA(wp, lp)            (HANDLE)HIWORD(lp)
#define MPostWM_DDE_EXECACK(hTo, hFrom, hCommands, wStatus) \
        PostMessage(hTo, WM_DDE_ACK, (WPARAM)hFrom, MAKELONG(wStatus, hCommands))

#define GET_WM_DDE_REQUEST_FORMAT(wp, lp)           (ATOM)LOWORD(lp)
#define GET_WM_DDE_REQUEST_ITEM(wp, lp)             (ATOM)HIWORD(lp)
#define MPostWM_DDE_REQUEST(hTo, hFrom, fmt, aItem) \
        PostMessage(hTo, WM_DDE_REQUEST, (WPARAM)hFrom, MAKELONG(fmt, aItem))

#define GET_WM_DDE_UNADVISE_FORMAT(wp, lp)          (ATOM)LOWORD(lp)
#define GET_WM_DDE_UNADVISE_ITEM(wp, lp)            (ATOM)HIWORD(lp)
#define MPostWM_DDE_UNADVISE(hTo, hFrom, fmt, aItem) \
        PostMessage(hTo, WM_DDE_UNADVISE, (WPARAM)hFrom, MAKELONG(fmt, aItem))

#define MPostWM_DDE_TERMINATE(hTo, hFrom) \
        PostMessage(hTo, WM_DDE_TERMINATE, (WPARAM)hFrom, 0)

/*-----------------------------------GDI-------------------------------------*/

BOOL  FAR PASCAL     MGetAspectRatioFilter(HDC hdc, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetBitmapDimension(HANDLE hBitmap, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetBrushOrg(HDC hdc, INT FAR * px, INT FAR * py);
BOOL  FAR PASCAL     MGetCurrentPosition(HDC hdc, INT FAR * px, INT FAR * py);
BOOL  FAR PASCAL     MGetTextExtent(HDC hdc, LPSTR lpstr, INT cnt, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetViewportExt(HDC hdc, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetViewportOrg(HDC hdc, INT FAR * px, INT FAR * py);
BOOL  FAR PASCAL     MGetWindowExt(HDC hdc, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetWindowOrg(HDC hdc, INT FAR * px, INT FAR * py);

#define MCreateDiscardableBitmap CreateDiscardableBitmap
#define MMoveTo                  (VOID)MoveTo
#define MOffsetViewportOrg       (VOID)OffsetViewportOrg
#define MOffsetWindowOrg         (VOID)OffsetWindowOrg
#define MScaleViewportExt        (VOID)ScaleViewportExt
#define MScaleWindowExt          (VOID)ScaleWindowExt
#define MSetBitmapDimension      (VOID)SetBitmapDimension
#define MSetBrushOrg             (VOID)SetBrushOrg
#define MSetViewportExt          (VOID)SetViewportExt
#define MSetViewportOrg          (VOID)SetViewportOrg
#define MSetWindowExt            (VOID)SetWindowExt
#define MSetWindowOrg            (VOID)SetWindowOrg
#define MUnrealizeObject         UnrealizeObject


/*-------------------------------------DEV-----------------------------------*/

DWORD FAR PASCAL     MDeviceCapabilities(LPSTR lpDriverName,
    LPSTR lpDeviceName, LPSTR lpPort, WORD2DWORD nIndex, LPSTR lpOutput,
    LPDEVMODE lpDevMode);
BOOL  FAR PASCAL     MDeviceMode(HWND hWnd, LPSTR lpDriverName,
    LPSTR lpDeviceName, LPSTR lpOutput);
WORD2DWORD FAR PASCAL    MExtDeviceMode(HWND hWnd,LPSTR lpDriverName,
    LPDEVMODE lpDevModeOutput, LPSTR lpDeviceName, LPSTR lpPort,
    LPDEVMODE lpDevModeInput, LPSTR lpProfile, WORD2DWORD flMode);

/*-----------------------------------KERNEL----------------------------------*/

HANDLE FAR PASCAL   MLoadLibrary(LPSTR lpszFilename);
BOOL FAR PASCAL MDeleteFile(LPSTR lpPathName);

#define DLLMEM_MOVEABLE         LMEM_MOVEABLE
#define DLLMEM_ZEROINIT         LMEM_ZEROINIT
#define GETMAJORVERSION(x)      LOBYTE(x)
#define GETMINORVERSION(x)      HIBYTE(x)

#define MCATCHBUF               CATCHBUF
#define LPMCATCHBUF             LPCATCHBUF

/* FUNCTION MAPPINGS */

#define MLocalInit               LocalInit
#define MLockData(dummy)         LockData(dummy)
#define MUnlockData(dummy)       UnlockData(dummy)
#define MDllSharedAlloc          LocalAlloc
#define MDllSharedFlags          LocalFlags
#define MDllSharedFree           LocalFree
#define MDllSharedHandle         LocalHandle
#define MDllSharedLock           LocalLock
#define MDllSharedRealloc        LocalReAlloc
#define MDllSharedSize           LocalSize
#define MDllSharedUnlock         LocalUnlock
#define MFreeDOSEnvironment(p)   TRUE
#define MGetCurrentTask          GetCurrentTask
#define MGetDOSEnvironment       GetDOSEnvironment
#define MGetDriveType            GetDriveType
#define MGetModuleUsage          GetModuleUsage
#define MGetTempDrive            GetTempDrive
#define MGetTempFileName         GetTempFileName
#define MGetWinFlags             GetWinFlags
#define MOpenComm                (HFILE)OpenComm
#define MSetCommState(fh, lpDCB) SetCommState(lpDCB)
#define MReadComm                ReadComm
#define MWriteComm               WriteComm
#define MCloseComm               CloseComm
#define MOpenFile                (HFILE)OpenFile
#define MThrow                   Throw
#define MCatch                   Catch
#define M_lclose                 _lclose
#define M_lcreat                 (HFILE)_lcreat
#define M_llseek                 _llseek
#define M_lopen                  (HFILE)_lopen
#define M_lread                  _lread
#define M_lwrite                 _lwrite
#define MGetMetaFileBits         GetMetaFileBits
#define MSetMetaFileBits         SetMetaFileBits
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\rrascfg.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Fri Nov 20 18:57:15 1998
 */
/* Compiler settings for rrascfg.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rrascfg_h__
#define __rrascfg_h__

/* Forward Declarations */ 

#ifndef __IRouterProtocolConfig_FWD_DEFINED__
#define __IRouterProtocolConfig_FWD_DEFINED__
typedef interface IRouterProtocolConfig IRouterProtocolConfig;
#endif 	/* __IRouterProtocolConfig_FWD_DEFINED__ */


#ifndef __IAuthenticationProviderConfig_FWD_DEFINED__
#define __IAuthenticationProviderConfig_FWD_DEFINED__
typedef interface IAuthenticationProviderConfig IAuthenticationProviderConfig;
#endif 	/* __IAuthenticationProviderConfig_FWD_DEFINED__ */


#ifndef __IAccountingProviderConfig_FWD_DEFINED__
#define __IAccountingProviderConfig_FWD_DEFINED__
typedef interface IAccountingProviderConfig IAccountingProviderConfig;
#endif 	/* __IAccountingProviderConfig_FWD_DEFINED__ */


#ifndef __IEAPProviderConfig_FWD_DEFINED__
#define __IEAPProviderConfig_FWD_DEFINED__
typedef interface IEAPProviderConfig IEAPProviderConfig;
#endif 	/* __IEAPProviderConfig_FWD_DEFINED__ */


/* header files for imported files */
#include "basetsd.h"
#include "wtypes.h"
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_rrascfg_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// RRasCfg.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
 
typedef BYTE __RPC_FAR *PBYTE;



extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0000_v0_0_s_ifspec;

#ifndef __IRouterProtocolConfig_INTERFACE_DEFINED__
#define __IRouterProtocolConfig_INTERFACE_DEFINED__

/* interface IRouterProtocolConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IRouterProtocolConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB16-D706-11D0-A37B-00C04FC9DA04")
    IRouterProtocolConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddProtocol( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *pRouter,
            /* [in] */ ULONG_PTR uReserved1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProtocol( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *pRouter,
            /* [in] */ ULONG_PTR uReserved1) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRouterProtocolConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRouterProtocolConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRouterProtocolConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRouterProtocolConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddProtocol )( 
            IRouterProtocolConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *pRouter,
            /* [in] */ ULONG_PTR uReserved1);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveProtocol )( 
            IRouterProtocolConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *pRouter,
            /* [in] */ ULONG_PTR uReserved1);
        
        END_INTERFACE
    } IRouterProtocolConfigVtbl;

    interface IRouterProtocolConfig
    {
        CONST_VTBL struct IRouterProtocolConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRouterProtocolConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRouterProtocolConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRouterProtocolConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRouterProtocolConfig_AddProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,uReserved1)	\
    (This)->lpVtbl -> AddProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,uReserved1)

#define IRouterProtocolConfig_RemoveProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,uReserved1)	\
    (This)->lpVtbl -> RemoveProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,uReserved1)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRouterProtocolConfig_AddProtocol_Proxy( 
    IRouterProtocolConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [in] */ DWORD dwTransportId,
    /* [in] */ DWORD dwProtocolId,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown __RPC_FAR *pRouter,
    /* [in] */ ULONG_PTR uReserved1);


void __RPC_STUB IRouterProtocolConfig_AddProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRouterProtocolConfig_RemoveProtocol_Proxy( 
    IRouterProtocolConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [in] */ DWORD dwTransportId,
    /* [in] */ DWORD dwProtocolId,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown __RPC_FAR *pRouter,
    /* [in] */ ULONG_PTR uReserved1);


void __RPC_STUB IRouterProtocolConfig_RemoveProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRouterProtocolConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rrascfg_0011 */
/* [local] */ 

#define DeclareIRouterProtocolConfigMembers(IPURE) \
	STDMETHOD(AddProtocol)(THIS_ LPCOLESTR pszMachineName,\
					   DWORD dwTransportId,\
					   DWORD dwProtocolId,\
					   HWND hWnd,\
					   DWORD dwFlags,\
					   IUnknown *pRouter,\
					   ULONG_PTR uReserved1) IPURE;\
	STDMETHOD(RemoveProtocol)(THIS_ LPCOLESTR pszMachineName,\
						 DWORD dwTransportId,\
						 DWORD dwProtocolId,\
						 HWND hWnd,\
						 DWORD dwFlags,\
						 IUnknown *pRouter,\
						 ULONG_PTR uReserved2) IPURE;\
 


extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0011_v0_0_s_ifspec;

#ifndef __IAuthenticationProviderConfig_INTERFACE_DEFINED__
#define __IAuthenticationProviderConfig_INTERFACE_DEFINED__

/* interface IAuthenticationProviderConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IAuthenticationProviderConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB17-D706-11D0-A37B-00C04FC9DA04")
    IAuthenticationProviderConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Uninitialize( 
            /* [in] */ ULONG_PTR uConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAuthenticationProviderConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAuthenticationProviderConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAuthenticationProviderConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        END_INTERFACE
    } IAuthenticationProviderConfigVtbl;

    interface IAuthenticationProviderConfig
    {
        CONST_VTBL struct IAuthenticationProviderConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAuthenticationProviderConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAuthenticationProviderConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAuthenticationProviderConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAuthenticationProviderConfig_Initialize(This,pszMachineName,puConnectionParam)	\
    (This)->lpVtbl -> Initialize(This,pszMachineName,puConnectionParam)

#define IAuthenticationProviderConfig_Uninitialize(This,uConnectionParam)	\
    (This)->lpVtbl -> Uninitialize(This,uConnectionParam)

#define IAuthenticationProviderConfig_Configure(This,uConnectionParam,hWnd,dwFlags,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Configure(This,uConnectionParam,hWnd,dwFlags,uReserved1,uReserved2)

#define IAuthenticationProviderConfig_Activate(This,uConnectionParam,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Activate(This,uConnectionParam,uReserved1,uReserved2)

#define IAuthenticationProviderConfig_Deactivate(This,uConnectionParam,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Deactivate(This,uConnectionParam,uReserved1,uReserved2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Initialize_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);


void __RPC_STUB IAuthenticationProviderConfig_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Uninitialize_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam);


void __RPC_STUB IAuthenticationProviderConfig_Uninitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Configure_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAuthenticationProviderConfig_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Activate_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAuthenticationProviderConfig_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Deactivate_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAuthenticationProviderConfig_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAuthenticationProviderConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rrascfg_0013 */
/* [local] */ 

#define DeclareIAuthenticationProviderConfigMembers(IPURE) \
	STDMETHOD(Initialize)(THIS_ \
							LPCOLESTR pszMachineName, \
							ULONG_PTR *puConnectionParam) IPURE; \
	STDMETHOD(Uninitialize)(THIS_ \
							ULONG_PTR uConnectionParam) IPURE; \
	 \
	STDMETHOD(Configure)(THIS_ \
							ULONG_PTR uConnectionParam, \
							HWND hWnd, \
						  DWORD dwFlags, \
						  ULONG_PTR uReserved1, \
						  ULONG_PTR uReserved2) IPURE; \
 \
	STDMETHOD(Activate)(THIS_ \
						ULONG_PTR uConnectionParam, \
						 ULONG_PTR uReserved1, \
						 ULONG_PTR uReserved2) IPURE; \
 \
	STDMETHOD(Deactivate)(THIS_ \
						ULONG_PTR uConnectionParam, \
						   ULONG_PTR uReserved1, \
						   ULONG_PTR uReserved2) IPURE; \
 


extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0013_v0_0_s_ifspec;

#ifndef __IAccountingProviderConfig_INTERFACE_DEFINED__
#define __IAccountingProviderConfig_INTERFACE_DEFINED__

/* interface IAccountingProviderConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IAccountingProviderConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB18-D706-11D0-A37B-00C04FC9DA04")
    IAccountingProviderConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Uninitialize( 
            /* [in] */ ULONG_PTR uConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccountingProviderConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAccountingProviderConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAccountingProviderConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        END_INTERFACE
    } IAccountingProviderConfigVtbl;

    interface IAccountingProviderConfig
    {
        CONST_VTBL struct IAccountingProviderConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccountingProviderConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccountingProviderConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAccountingProviderConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAccountingProviderConfig_Initialize(This,pszMachineName,puConnectionParam)	\
    (This)->lpVtbl -> Initialize(This,pszMachineName,puConnectionParam)

#define IAccountingProviderConfig_Uninitialize(This,uConnectionParam)	\
    (This)->lpVtbl -> Uninitialize(This,uConnectionParam)

#define IAccountingProviderConfig_Configure(This,uConnectionParam,hWnd,dwFlags,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Configure(This,uConnectionParam,hWnd,dwFlags,uReserved1,uReserved2)

#define IAccountingProviderConfig_Activate(This,uConnectionParam,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Activate(This,uConnectionParam,uReserved1,uReserved2)

#define IAccountingProviderConfig_Deactivate(This,uConnectionParam,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Deactivate(This,uConnectionParam,uReserved1,uReserved2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Initialize_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);


void __RPC_STUB IAccountingProviderConfig_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Uninitialize_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam);


void __RPC_STUB IAccountingProviderConfig_Uninitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Configure_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAccountingProviderConfig_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Activate_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAccountingProviderConfig_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Deactivate_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAccountingProviderConfig_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAccountingProviderConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rrascfg_0015 */
/* [local] */ 

#define DeclareIAccountingProviderConfigMembers(IPURE) \
	STDMETHOD(Initialize)(THIS_ \
							LPCOLESTR pszMachineName, \
							ULONG_PTR *puConnectionParam) IPURE; \
	STDMETHOD(Uninitialize)(THIS_ \
							ULONG_PTR uConnectionParam) IPURE; \
	STDMETHOD(Configure)(THIS_ \
						ULONG_PTR uConnectionParam, \
						HWND hWnd, \
						  DWORD dwFlags, \
						  ULONG_PTR uReserved1, \
						  ULONG_PTR uReserved2) IPURE; \
 \
	STDMETHOD(Activate)(THIS_ \
						ULONG_PTR uConnectionParam, \
						 ULONG_PTR uReserved1, \
						 ULONG_PTR uReserved2) IPURE; \
 \
	STDMETHOD(Deactivate)(THIS_ \
						ULONG_PTR uConnectionParam, \
						   ULONG_PTR uReserved1, \
						   ULONG_PTR uReserved2) IPURE; \
 


extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0015_v0_0_s_ifspec;

#ifndef __IEAPProviderConfig_INTERFACE_DEFINED__
#define __IEAPProviderConfig_INTERFACE_DEFINED__

/* interface IEAPProviderConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IEAPProviderConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB19-D706-11D0-A37B-00C04FC9DA04")
    IEAPProviderConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwEapTypeId,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Uninitialize( 
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ServerInvokeConfigUI( 
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RouterInvokeConfigUI( 
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
            /* [in] */ DWORD dwSizeOfConnectionDataIn,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppConnectionDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwSizeOfConnectionDataOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RouterInvokeCredentialsUI( 
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
            /* [in] */ DWORD dwSizeOfConnectionDataIn,
            /* [size_is][in] */ BYTE __RPC_FAR *pUserDataIn,
            /* [in] */ DWORD dwSizeOfUserDataIn,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppUserDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwSizeOfUserDataOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEAPProviderConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEAPProviderConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEAPProviderConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwEapTypeId,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ServerInvokeConfigUI )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RouterInvokeConfigUI )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
            /* [in] */ DWORD dwSizeOfConnectionDataIn,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppConnectionDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwSizeOfConnectionDataOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RouterInvokeCredentialsUI )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
            /* [in] */ DWORD dwSizeOfConnectionDataIn,
            /* [size_is][in] */ BYTE __RPC_FAR *pUserDataIn,
            /* [in] */ DWORD dwSizeOfUserDataIn,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppUserDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwSizeOfUserDataOut);
        
        END_INTERFACE
    } IEAPProviderConfigVtbl;

    interface IEAPProviderConfig
    {
        CONST_VTBL struct IEAPProviderConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEAPProviderConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEAPProviderConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEAPProviderConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEAPProviderConfig_Initialize(This,pszMachineName,dwEapTypeId,puConnectionParam)	\
    (This)->lpVtbl -> Initialize(This,pszMachineName,dwEapTypeId,puConnectionParam)

#define IEAPProviderConfig_Uninitialize(This,dwEapTypeId,uConnectionParam)	\
    (This)->lpVtbl -> Uninitialize(This,dwEapTypeId,uConnectionParam)

#define IEAPProviderConfig_ServerInvokeConfigUI(This,dwEapTypeId,uConnectionParam,hWnd,uReserved1,uReserved2)	\
    (This)->lpVtbl -> ServerInvokeConfigUI(This,dwEapTypeId,uConnectionParam,hWnd,uReserved1,uReserved2)

#define IEAPProviderConfig_RouterInvokeConfigUI(This,dwEapTypeId,uConnectionParam,hwndParent,dwFlags,pConnectionDataIn,dwSizeOfConnectionDataIn,ppConnectionDataOut,pdwSizeOfConnectionDataOut)	\
    (This)->lpVtbl -> RouterInvokeConfigUI(This,dwEapTypeId,uConnectionParam,hwndParent,dwFlags,pConnectionDataIn,dwSizeOfConnectionDataIn,ppConnectionDataOut,pdwSizeOfConnectionDataOut)

#define IEAPProviderConfig_RouterInvokeCredentialsUI(This,dwEapTypeId,uConnectionParam,hwndParent,dwFlags,pConnectionDataIn,dwSizeOfConnectionDataIn,pUserDataIn,dwSizeOfUserDataIn,ppUserDataOut,pdwSizeOfUserDataOut)	\
    (This)->lpVtbl -> RouterInvokeCredentialsUI(This,dwEapTypeId,uConnectionParam,hwndParent,dwFlags,pConnectionDataIn,dwSizeOfConnectionDataIn,pUserDataIn,dwSizeOfUserDataIn,ppUserDataOut,pdwSizeOfUserDataOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEAPProviderConfig_Initialize_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [in] */ DWORD dwEapTypeId,
    /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);


void __RPC_STUB IEAPProviderConfig_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEAPProviderConfig_Uninitialize_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwEapTypeId,
    /* [in] */ ULONG_PTR uConnectionParam);


void __RPC_STUB IEAPProviderConfig_Uninitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEAPProviderConfig_ServerInvokeConfigUI_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwEapTypeId,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hWnd,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IEAPProviderConfig_ServerInvokeConfigUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEAPProviderConfig_RouterInvokeConfigUI_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwEapTypeId,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hwndParent,
    /* [in] */ DWORD dwFlags,
    /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
    /* [in] */ DWORD dwSizeOfConnectionDataIn,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppConnectionDataOut,
    /* [out] */ DWORD __RPC_FAR *pdwSizeOfConnectionDataOut);


void __RPC_STUB IEAPProviderConfig_RouterInvokeConfigUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEAPProviderConfig_RouterInvokeCredentialsUI_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwEapTypeId,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hwndParent,
    /* [in] */ DWORD dwFlags,
    /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
    /* [in] */ DWORD dwSizeOfConnectionDataIn,
    /* [size_is][in] */ BYTE __RPC_FAR *pUserDataIn,
    /* [in] */ DWORD dwSizeOfUserDataIn,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppUserDataOut,
    /* [out] */ DWORD __RPC_FAR *pdwSizeOfUserDataOut);


void __RPC_STUB IEAPProviderConfig_RouterInvokeCredentialsUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEAPProviderConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rrascfg_0017 */
/* [local] */ 

#define DeclareIEAPProviderConfigMembers(IPURE) \
	STDMETHOD(Initialize)(THIS_ \
		LPCOLESTR 	pszMachineName, \
 	DWORD       dwEapTypeId, \
		ULONG_PTR*	puConnectionParam) IPURE; \
	STDMETHOD(Uninitialize)(THIS_ \
 	DWORD       dwEapTypeId, \
		ULONG_PTR 	uConnectionParam) IPURE; \
	STDMETHOD(ServerInvokeConfigUI)(THIS_ \
 	DWORD       dwEapTypeId, \
		ULONG_PTR 	uConnectionParam, \
		HWND 		hWnd, \
		ULONG_PTR 	dwRes1, \
		ULONG_PTR 	dwRes2) IPURE; \
 STDMETHOD(RouterInvokeConfigUI)(THIS_ \
 	DWORD       dwEapTypeId, \
		ULONG_PTR 	uConnectionParam, \
 	HWND        hwndParent, \
 	DWORD       dwFlags, \
 	BYTE* 		pConnectionDataIn, \
 	DWORD		dwSizeOfConnectionDataIn, \
 	BYTE**		ppConnectionDataOut, \
 	DWORD*		pdwSizeOfConnectionDataOut) IPURE; \
 STDMETHOD(RouterInvokeCredentialsUI)(THIS_  \
 	DWORD   	dwEapTypeId, \
		ULONG_PTR 	uConnectionParam, \
 	HWND    	hwndParent, \
 	DWORD   	dwFlags, \
 	BYTE*   	pConnectionDataIn, \
 	DWORD   	dwSizeOfConnectionDataIn, \
 	BYTE*   	pUserDataIn, \
 	DWORD   	dwSizeOfUserDataIn, \
 	BYTE**  	ppUserDataOut, \
 	DWORD*  	pdwSizeOfUserDataOut) IPURE; \
 


extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0017_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\regapix.h ===
//
//  REGAPIX.H
//
//  Copyright (C) Microsoft Corporation, 1995-1999
//
//  Public definitions for the VMM registry library (all modes).
//

#ifndef _REGAPIX_
#define _REGAPIX_

#if _MSC_VER > 1000
#pragma once
#endif

/*XLATOFF*/
#ifdef __cplusplus
extern "C" {
#endif
/*XLATON*/

/*XLATOFF*/
#if defined(_INC_WINDOWS) && !defined(VXD) && !defined(REALMODE)
#define REGAPI                      WINAPI
#else
#if defined(IS_32)
#ifndef FAR
#define FAR
#endif
#define REGAPI                      __cdecl
#else
#ifndef FAR
#define FAR                         _far
#endif
#define REGAPI                      _far _cdecl
#endif // defined(IS_32)
#endif // defined(_INC_WINDOWS) && !defined(VXD) && !defined(REALMODE)
/*XLATON*/

#ifndef _REGPRIV_
#ifndef _INC_WINDOWS
typedef DWORD HKEY;
#endif
#endif
typedef HKEY FAR* LPHKEY;

//
//  Predefined key handles.
//

#ifndef HKEY_LOCAL_MACHINE
#define HKEY_CLASSES_ROOT           ((HKEY) 0x80000000)
#define HKEY_CURRENT_USER           ((HKEY) 0x80000001)
#define HKEY_LOCAL_MACHINE          ((HKEY) 0x80000002)
#define HKEY_USERS                  ((HKEY) 0x80000003)
#define HKEY_PERFORMANCE_DATA       ((HKEY) 0x80000004)
#define HKEY_CURRENT_CONFIG         ((HKEY) 0x80000005)
#define HKEY_DYN_DATA               ((HKEY) 0x80000006)
#define HKEY_PREDEF_KEYS            7
#endif

//
//  Maximum size of registry data elements.
//

#define MAXIMUM_SUB_KEY_LENGTH      256
#define MAXIMUM_VALUE_NAME_LENGTH   256
#define MAXIMUM_DATA_LENGTH         16384

//
//  Standard data types.
//

#ifndef REG_SZ
#define REG_SZ                      1
#endif

#ifndef REG_BINARY
#define REG_BINARY                  3
#endif

#ifndef REG_DWORD
#define REG_DWORD                   4
#endif

//
//  Registry error codes.
//

#ifndef ERROR_SUCCESS
#define ERROR_SUCCESS               0
#endif

#ifndef ERROR_INVALID_FUNCTION
#define ERROR_INVALID_FUNCTION      1
#endif

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND        2
#endif

#ifndef ERROR_ACCESS_DENIED
#define ERROR_ACCESS_DENIED         5
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY           14
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER     87
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED           167
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA             234
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS         259
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                 1009
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY                1010
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN              1011
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD              1012
#endif

#ifndef ERROR_CANTWRITE
#define ERROR_CANTWRITE             1013
#endif

#ifndef ERROR_REGISTRY_IO_FAILED
#define ERROR_REGISTRY_IO_FAILED    1016
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED           1018
#endif

//  Internal registry error codes.  Not exposed to most clients.
#if defined(VXD)
#define ERROR_CANTOPEN16_FILENOTFOUND32 ((ERROR_CANTOPEN << 16) | ERROR_FILE_NOT_FOUND)
#define ERROR_CANTREAD16_FILENOTFOUND32 ((ERROR_CANTREAD << 16) | ERROR_FILE_NOT_FOUND)
#else
#if defined(WIN32)
#define ERROR_CANTOPEN16_FILENOTFOUND32 ERROR_FILE_NOT_FOUND
#define ERROR_CANTREAD16_FILENOTFOUND32 ERROR_FILE_NOT_FOUND
#else
#define ERROR_CANTOPEN16_FILENOTFOUND32 ERROR_CANTOPEN
#define ERROR_CANTREAD16_FILENOTFOUND32 ERROR_CANTREAD
#endif
#endif

//
//  Registry application interfaces.
//

/*XLATOFF*/

LONG
REGAPI
VMMRegLibAttach(
    UINT Flags
    );

VOID
REGAPI
VMMRegLibDetach(
    VOID
    );

/*XLATON*/
#define GRFT_SYSTEM                 0       //  SYSTEM.DAT
#define GRFT_USER                   1       //  USER.DAT
/*XLATOFF*/

BOOL
REGAPI
VMMRegGetRegistryFile(
    char FAR* lpBuffer,
    UINT BufferSize,
    UINT FileType
    );

//  Creates a new registry file.  Fails if the specified file already exists.
#define MPKF_CREATENEW              0x0001

//  If MPKF_VERSION20 is specified, create the file using compact keynodes.
//  Such a file will only be readable by users of this library, not Win95
//  clients.  Use only for system registries (SYSTEM.DAT, USER.DAT).
#define MPKF_VERSION20              0x0002

LONG
REGAPI
VMMRegMapPredefKeyToFile(
    HKEY hKey,
    const char FAR* lpFileName,
    UINT Flags
    );

LONG
REGAPI
VMMRegMapPredefKeyToKey(
    HKEY hSourceKey,
    HKEY hPredefKey
    );

LONG
REGAPI
VMMRegCreateKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    LPHKEY lphSubKey
    );

LONG
REGAPI
VMMRegOpenKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    LPHKEY lphSubKey
    );

LONG
REGAPI
VMMRegCloseKey(
    HKEY hKey
    );

LONG
REGAPI
VMMRegFlushKey(
    HKEY hKey
    );

LONG
REGAPI
VMMRegQueryValue(
    HKEY hKey,
    const char FAR* lpSubKey,
    BYTE FAR* lpData,
    DWORD FAR* lpcbData
    );

LONG
REGAPI
VMMRegQueryValueEx(
    HKEY hKey,
    const char FAR* lpValueName,
    DWORD FAR* lpReserved,
    DWORD FAR* lpType,
    BYTE FAR* lpData,
    DWORD FAR* lpcbData
    );

LONG
REGAPI
VMMRegQueryMultipleValues(
    HKEY hKey,
    void FAR* val_list,
    DWORD num_vals,
    char FAR* lpValueBuffer,
    DWORD FAR* lpdwTotalSize
    );

LONG
REGAPI
VMMRegSetValue(
    HKEY hKey,
    const char FAR* lpSubKey,
    DWORD Type,
    BYTE FAR* lpData,
    DWORD cbData
    );

LONG
REGAPI
VMMRegSetValueEx(
    HKEY hKey,
    const char FAR* lpValueName,
    DWORD Reserved,
    DWORD Type,
    BYTE FAR* lpData,
    DWORD cbData
    );

LONG
REGAPI
VMMRegDeleteKey(
    HKEY hKey,
    const char FAR* lpSubKey
    );

LONG
REGAPI
VMMRegDeleteValue(
    HKEY hKey,
    const char FAR* lpValueName
    );

LONG
REGAPI
VMMRegEnumKey(
    HKEY hKey,
    DWORD Index,
    char FAR* lpKeyName,
    DWORD cbKeyName
    );

LONG
REGAPI
VMMRegEnumValue(
    HKEY hKey,
    DWORD Index,
    char FAR* lpValueName,
    DWORD FAR* lpcbValueName,
    DWORD FAR* lpReserved,
    DWORD FAR* lpType,
    BYTE FAR* lpData,
    DWORD FAR* lpcbData
    );

#ifdef VXD
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    DWORD FAR* lpcSubKeys,
    DWORD FAR* lpcbMaxSubKeyLen,
    DWORD FAR* lpcValues,
    DWORD FAR* lpcbMaxValueName,
    DWORD FAR* lpcbMaxValueData
    );
#else
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    char FAR* lpClass,
    DWORD FAR* lpcbClass,
    DWORD FAR* lpReserved,
    DWORD FAR* lpcSubKeys,
    DWORD FAR* lpcbMaxSubKeyLen,
    DWORD FAR* lpcbMaxClassLen,
    DWORD FAR* lpcValues,
    DWORD FAR* lpcbMaxValueName,
    DWORD FAR* lpcbMaxValueData,
    void FAR* lpcbSecurityDescriptor,
    void FAR* lpftLastWriteTime
    );
#endif

LONG
REGAPI
VMMRegLoadKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    const char FAR* lpFileName
    );

LONG
REGAPI
VMMRegUnLoadKey(
    HKEY hKey,
    const char FAR* lpSubKey
    );

LONG
REGAPI
VMMRegSaveKey(
    HKEY hKey,
    const char FAR* lpFileName,
    void FAR* lpSecurityAttributes
    );

LONG
REGAPI
VMMRegReplaceKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    const char FAR* lpNewFileName,
    const char FAR* lpOldFileName
    );

//
//  Optional macros for callers (typically 16-bit) that map the registry APIs
//  to the equivalent Win32 API name.
//

#if defined(IS_16) || defined(WANTREGAPIMACROS)
#if !defined(NOREGAPIMACROS) && !defined(SETUPX_INC)
#define RegCreateKey                VMMRegCreateKey
#define RegOpenKey                  VMMRegOpenKey
#define RegCloseKey                 VMMRegCloseKey
#define RegFlushKey                 VMMRegFlushKey
#define RegQueryValue               VMMRegQueryValue
#define RegQueryValueEx             VMMRegQueryValueEx
#define RegQueryMultipleValues      VMMRegQueryMultipleValues
#define RegSetValue                 VMMRegSetValue
#define RegSetValueEx               VMMRegSetValueEx
#define RegDeleteKey                VMMRegDeleteKey
#define RegDeleteValue              VMMRegDeleteValue
#define RegEnumKey                  VMMRegEnumKey
#define RegEnumValue                VMMRegEnumValue
#define RegQueryInfoKey             VMMRegQueryInfoKey
#define RegLoadKey                  VMMRegLoadKey
#define RegUnLoadKey                VMMRegUnLoadKey
#define RegSaveKey                  VMMRegSaveKey
#define RegReplaceKey               VMMRegReplaceKey
#endif
#endif

/*XLATON*/

//
//  Registry services available via VMM's interrupt 2Fh handler.
//

#define RegOpenKey_Idx              0x0100
#define RegCreateKey_Idx            0x0101
#define RegCloseKey_Idx             0x0102
#define RegDeleteKey_Idx            0x0103
#define RegSetValue_Idx             0x0104
#define RegQueryValue_Idx           0x0105
#define RegEnumKey_Idx              0x0106
#define RegDeleteValue_Idx          0x0107
#define RegEnumValue_Idx            0x0108
#define RegQueryValueEx_Idx         0x0109
#define RegSetValueEx_Idx           0x010A
#define RegFlushKey_Idx             0x010B
#define RegLoadKey_Idx              0x010C
#define RegUnLoadKey_Idx            0x010D
#define RegSaveKey_Idx              0x010E
#define RegRestore_Idx              0x010F
#define RegRemapPreDefKey_Idx       0x0110

/*XLATOFF*/
#ifdef __cplusplus
}
#endif
/*XLATON*/

#endif // _REGAPIX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\sslsp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       sslsp.h
//
//  Contents:   Public Definitions for SCHANNEL Security Provider
//
//  Classes:
//
//  Functions:
//
//  History
//
//          11 Jun 96   Merged SSL and PCT headers
//
//----------------------------------------------------------------------------

#ifndef __SSLSP_H__
#define __SSLSP_H__

#if _MSC_VER > 1000
#pragma once
#endif

#define SSLSP_NAME_A    "Microsoft SSL"
#define SSLSP_NAME_W    L"Microsoft SSL"

#ifdef UNICODE
#define SSLSP_NAME  SSLSP_NAME_W
#else
#define SSLSP_NAME  SSLSP_NAME_A
#endif

#define SSLSP_RPC_ID    12


typedef struct _SSL_CREDENTIAL_CERTIFICATE {
    DWORD   cbPrivateKey;
    PBYTE   pPrivateKey;
    DWORD   cbCertificate;
    PBYTE   pCertificate;
    PSTR    pszPassword;
} SSL_CREDENTIAL_CERTIFICATE, * PSSL_CREDENTIAL_CERTIFICATE;

#define NETWORK_DREP    0x00000000



#ifndef __SCHN_CERTIFICATE_DEFINED
#define __SCHN_CERTIFICATE_DEFINED

typedef struct _X509Certificate {
    DWORD           Version;
    DWORD           SerialNumber[4];
    ALG_ID          SignatureAlgorithm;
    FILETIME        ValidFrom;
    FILETIME        ValidUntil;
    PSTR            pszIssuer;
    PSTR            pszSubject;
    PVOID           pPublicKey;
} X509Certificate, * PX509Certificate;


#endif

typedef struct _CtPublicPublicKey {
    DWORD   Type;
    DWORD   cbKey;
    DWORD   magic;
    DWORD   keylen;
    DWORD   bitlen;
} CtPublicPublicKey, * LPPUBLIC_KEY;

#define SERIALNUMBER_LENGTH 16

#define CF_VERIFY_SIG           1
#define CF_CERT_FROM_FILE       2

#define CERT_HEADER_LEN         17


#ifdef __cplusplus
extern "C" {
#endif

BOOL
WINAPI
SslGenerateKeyPair(
    PSSL_CREDENTIAL_CERTIFICATE pCerts,
    PSTR pszDN,
    PSTR pszPassword,
    DWORD Bits );


VOID
WINAPI
SslGenerateRandomBits(
    PUCHAR      pRandomData,
    LONG        cRandomData
    );


BOOL
WINAPI
SslLoadCertificate(
    PUCHAR      pbCertificate,
    DWORD       cbCertificate,
    BOOL        AddToWellKnownKeys);

BOOL
WINAPI
SslCrackCertificate(
    PUCHAR              pbCertificate,
    DWORD               cbCertificate,
    DWORD               dwFlags,
    PX509Certificate *  ppCertificate);

VOID
WINAPI
SslFreeCertificate(
    PX509Certificate    pCertificate);

DWORD
WINAPI
SslGetMaximumKeySize(
    DWORD   Reserved );

#ifdef __cplusplus
}
#endif

//
// PCT Provider Information
//

#define PCTSP_NAME_A    "Microsoft PCT"
#define PCTSP_NAME_W    L"Microsoft PCT"

#ifdef UNICODE
#define PCTSP_NAME  PCTSP_NAME_W
#else
#define PCTSP_NAME  PCTSP_NAME_A
#endif

#define PCTSP_RPC_ID    13


typedef struct _PCT_CREDENTIAL_CERTIFICATE {
    DWORD   cbPrivateKey;
    PBYTE   pPrivateKey;
    DWORD   cbCertificate;
    PBYTE   pCertificate;
    PCHAR   pszPassword;
} PCT_CREDENTIAL_CERTIFICATE, * PPCT_CREDENTIAL_CERTIFICATE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\stgint.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:	stgint.h
//
//  Contents:	Internal storage APIs, collected here because
//              they are declared and used across projects
//              These APIs are not publicized and are not
//              for general use
//
//  History:	23-Jul-93	DrewB	 Created
//              12-May-95   HenryLee Add DfOpenDocfile
//
//  Notes:      All handles are NT handles
//
//----------------------------------------------------------------------------

#ifndef __STGINT_H__
#define __STGINT_H__

#if _MSC_VER > 1000
#pragma once
#endif

STDAPI
StgOpenStorageOnHandle( IN HANDLE hStream,
                        IN DWORD grfMode,
                        IN void *reserved1,
                        IN void *reserved2,
                        IN REFIID riid,
                        OUT void **ppObjectOpen );
/*

Don't export until it's needed.
STDAPI
StgCreateStorageOnHandle( IN HANDLE hStream,
                          IN DWORD grfMode,
                          IN DWORD stgfmt,
                          IN void *reserved1,
                          IN void *reserved2,
                          IN REFIID riid,
                          OUT void **ppObjectOpen );
*/

STDAPI DfIsDocfile(HANDLE h);

// Summary catalog entry points
STDAPI ScCreateStorage(HANDLE hParent,
                       WCHAR const *pwcsName,
                       HANDLE h,
                       DWORD grfMode,
                       LPSECURITY_ATTRIBUTES pssSecurity,
                       IStorage **ppstg);
STDAPI ScOpenStorage(HANDLE hParent,
                     WCHAR const *pwcsName,
                     HANDLE h,
                     IStorage *pstgPriority,
                     DWORD grfMode,
                     SNB snbExclude,
                     IStorage **ppstg);

DEFINE_GUID (IID_IStorageReplica,
            0x521a28f3,0xe40b,0x11ce,0xb2,0xc9,0x00,0xaa,0x00,0x68,0x09,0x37);

DECLARE_INTERFACE_(IStorageReplica, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    //IStorageReplica
    STDMETHOD(GetServerInfo) (THIS_
                              LPWSTR lpServerName,
                              LPDWORD lpcbServerName,
                              LPWSTR lpReplSpecificPath,
                              LPDWORD lpcbReplSpecificPath) PURE;

};

#endif // #ifndef __STGINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\scrnsave.h ===
/*****************************************************************************\
*                                                                             *
* scrnsave.h    Windows NT 3.1 screensaver defines and definitions.           *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*  Windows NT NOTE:   (Differences from Win 3.1 Screensavers)                 *
*                                                                             *
*               All Screensavers are required to have a Description string    *
*               of no more than 25 chars for display by the Control Panel's   *
*               Desktop applet.  This is string 1 in the resource string      *
*               table of the Windows 32-bit screen saver .SCR (.EXE) file.    *
*                                                                             *
*               Passwords for Windows NT Screen Savers are handled by the     *
*               Winlogon process.  If the registry value:                     *
*                                                                             *
*               HKEY_CURRENT_USER\Control Panel\Desktop\ScreenSaverIsSecure   *
*                                                                             *
*               is nonzero, Winlogon will ask for the User's login password   *
*               before allowing the Screen Saver to exit.  All password data  *
*               and dialogs have been removed from individual Screensavers.   *
*                                                                             *
*                                                                             *
*          Copyright (c) 1992-1999, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SCRNSAVE
#define _INC_SCRNSAVE

#if _MSC_VER > 1000
#pragma once
#endif

#include <pshpack1.h>   /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */


/* MANDATORY string required in .RC file
 * This string should contain a less than 25 char name/description of the
 * screen saver.  This string is what will be seen by the user in the Control
 * Panel's Desktop applet screen saver listbox.
 */

#define IDS_DESCRIPTION      1

/* Icon resource ID.
 *
 * This should be the first icon used and must have this resource number.
 * This is needed as the first icon in the file will be grabbed
 */
#define ID_APP      100
#define DLG_SCRNSAVECONFIGURE   2003

#define idsIsPassword           1000
#define idsIniFile              1001
#define idsScreenSaver          1002
#define idsPassword             1003
#define idsDifferentPW          1004
#define idsChangePW             1005
#define idsBadOldPW             1006
#define idsAppName              1007
#define idsNoHelpMemory         1008
#define idsHelpFile             1009
#define idsDefKeyword           1010

/* This function is the Window Procedure for the screen saver.  It is
 * up to the programmer to handle any of the messages that wish to be
 * interpretted.  Any unused messages are then passed back to
 * DefScreenSaverProc if desired which will take default action on any
 * unprocessed message...
 */
#ifdef UNICODE
LRESULT WINAPI ScreenSaverProcW (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
#   define  ScreenSaverProc ScreenSaverProcW
#else
LRESULT WINAPI ScreenSaverProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
#endif

/* This function performs default message processing.  Currently handles
 * the following messages:
 *
 * WM_SYSCOMMAND:   return FALSE if wParam is SC_SCREENSAVE or SC_CLOSE
 *
 * WM_DESTROY:      PostQuitMessage(0)
 *
 * WM_SETCURSOR:    By default, this will set the cursor to a null cursor,
 *                  thereby removing it from the screen.
 *
 * WM_LBUTTONDOWN:
 * WM_MBUTTONDOWN:
 * WM_RBUTTONDOWN:
 * WM_KEYDOWN:
 * WM_KEYUP:
 * WM_MOUSEMOVE:    By default, these will cause the program to terminate.
 *                  Unless the password option is enabled.  In that case
 *                  the DlgGetPassword() dialog box is brought up.
 *
 * WM_NCACTIVATE:
 * WM_ACTIVATEAPP:
 * WM_ACTIVATE:     By default, if the wParam parameter is FALSE (signifying
 *                  that transfer is being taken away from the application),
 *                  then the program will terminate.  Termination is
 *                  accomplished by generating a WM_CLOSE message.  This way,
 *                  if the user sets something up in the WM_CREATE, a
 *                  WM_DESTROY will be generated and it can be destroyed
 *                  properly.
 *                  This message is ignored, however is the password option
 *                  is enabled.
 */
LRESULT WINAPI DefScreenSaverProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

/* A function is also needed for configuring the screen saver.  The function
 * should be exactly like it is below and must be exported such that the
 * program can use MAKEPROCINSTANCE on it and call up a dialog box. Further-
 * more, the template used for the dialog must be called
 * ScreenSaverConfigure to allow the main function to access it...
 */
BOOL WINAPI ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

/* To allow the programmer the ability to register child control windows, this
 * function is called prior to the creation of the dialog box.  Any
 * registering that is required should be done here, or return TRUE if none
 * is needed...
 */
BOOL WINAPI RegisterDialogClasses (HANDLE hInst);

/* The following functions are called by DefScreenSaverProc and must
 * be exported by all screensavers using this model.
 */

/*
 * There are only three other points that should be of notice:
 * 1) The screen saver must have a string declared as 'szAppName' contaning the
 *     name of the screen saver, and it must be declared as a global.
 * 2) The screen saver EXE file should be renamed to a file with a SCR
 *     extension so that the screen saver dialog from the control panel can
 *     find it when is searches for screen savers.
 */
#define WS_GT   (WS_GROUP | WS_TABSTOP)

#define MAXFILELEN         13
#define TITLEBARNAMELEN    40
#define APPNAMEBUFFERLEN   40
#define BUFFLEN           255

/* The following globals are defined in scrnsave.lib */
extern HINSTANCE hMainInstance;
extern HWND   hMainWindow;
extern BOOL   fChildPreview;
extern TCHAR  szName[TITLEBARNAMELEN];
extern TCHAR  szAppName[APPNAMEBUFFERLEN];
extern TCHAR  szIniFile[MAXFILELEN];
extern TCHAR  szScreenSaver[22];
extern TCHAR  szHelpFile[MAXFILELEN];
extern TCHAR  szNoHelpMemory[BUFFLEN];
extern UINT   MyHelpMessage;

/* OPTIONAL - Win95 Only */

#define SCRM_VERIFYPW   WM_APP
/*
 * This message is sent to the main screen saver window when password
 * protection is enabled and the user is trying to close the screen saver.  You
 * can process this message and provide your own validation technology.  If you
 * process this message, you should also support the ScreenSaverChangePassword
 * function, described below.  Return zero from this message if the password
 * check failed.  Return nonzero for success.  If you run out of memory or
 * encounter a similar class of error, return non-zero so the user isn't left
 * out in the cold.  The default action is to call the Windows Master
 * Password Router to validate the user's password.
 */

void WINAPI ScreenSaverChangePassword( HWND hParent );
/*
 * You supply this if you provide your own authentication.  Windows will call
 * it when the user wants to change the password.  An implementation of this
 * function should present password change UI to the user.
 * You should only supply this function if you also hook the SCRM_VERIFYPW
 * message to validate passwords.
 * The default action is to call the Windows Master Password Router.
 */


#ifdef __cplusplus
}
#endif	/* __cplusplus */

#include <poppack.h>

#endif  /* !_INC_SCRNSAVE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\stgprop.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1993-1999.
//
//  File:       stgprop.h
//
//  Contents:   Standard storage provider property definitions;
//
//  History:    Jul-9-93       robertfe
//
//----------------------------------------------------------------------------

#ifndef _STGPROP_H_
#define _STGPROP_H_

#if _MSC_VER > 1000
#pragma once
#endif

#define PSGUID_STORAGE  { 0xb725f130,           \
                          0x47ef, 0x101a,       \
                          { 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac } }

//#define PID_STG_DICTIONARY            ((PROPID) 0x00000000) //reserved
//#define PID_STG_CODEPAGE              ((PROPID) 0x00000001) //reserved

#define PID_STG_DIRECTORY               ((PROPID) 0x00000002)

#define PID_STG_CLASSID                 ((PROPID) 0x00000003)
#define PID_STG_STORAGETYPE             ((PROPID) 0x00000004)

#define PID_STG_VOLUME_ID               ((PROPID) 0x00000005)
#define PID_STG_PARENT_WORKID           ((PROPID) 0x00000006)
#define PID_STG_SECONDARYSTORE          ((PROPID) 0x00000007)

#define PID_STG_FILEINDEX               ((PROPID) 0x00000008)
#define PID_STG_LASTCHANGEUSN           ((PROPID) 0x00000009)
#define PID_STG_NAME                    ((PROPID) 0x0000000a)
#define PID_STG_PATH                    ((PROPID) 0x0000000b)

#define PID_STG_SIZE                    ((PROPID) 0x0000000c)
#define PID_STG_ATTRIBUTES              ((PROPID) 0x0000000d)
#define PID_STG_WRITETIME               ((PROPID) 0x0000000e)
#define PID_STG_CREATETIME              ((PROPID) 0x0000000f)
#define PID_STG_ACCESSTIME              ((PROPID) 0x00000010)
#define PID_STG_CHANGETIME              ((PROPID) 0x00000011)

#define PID_STG_CONTENTS                ((PROPID) 0x00000013)
#define PID_STG_SHORTNAME               ((PROPID) 0x00000014)

#define PID_STG_MAX                     PID_STG_SHORTNAME

#define CSTORAGEPROPERTY            0x15

#endif _STGPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\sedapi.h ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		                         **/
/**		Copyright(c) Microsoft Corp., 1990-1999	                     **/
/**********************************************************************/

/*
    SEDAPI.h

    This File contains the prototypes and descriptions for the interface to
    the generic security editor dialogs for NT objects.

    FILE HISTORY:
	Johnl	02-Aug-1991	Created
	Johnl	27-Dec-1991	Updated to reflect reality
	JohnL	25-Feb-1992	Nuked NewObjValidMask (new obj use generic/stan.
                                only, Added GENERIC_MAPPING param.
        Johnl   15-Jan-1993     Added CantRead flags, cleaned up comments

*/

#ifndef _SEDAPI_H_
#define _SEDAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// The following are status codes indicating the state of the permissions on
// the resource we are setting permissions for.
//
#define SED_STATUS_MODIFIED		(1)
#define SED_STATUS_NOT_MODIFIED 	(2)
#define SED_STATUS_NOT_ALL_MODIFIED	(3)
#define SED_STATUS_FAILED_TO_MODIFY	(4)

//
// Current Security editor revision level.
//
#define SED_REVISION	    (1)

#define SED_REVISION1	    (1)

//
// The following structure is for user help in the various dialogs.  Each
// use of the security editor (whether for files/directories, Registry, Printer
// stuff etc.) will have its own set of permission names/capabilities, thus
// each will require its own help file.  This structure allows the client
// of the security editor to specify which help files and which help
// contexts should be used for each dialog.
//
typedef struct _SED_HELP_INFO
{
    //
    // The name of the ".hlp" file to be passed to the help engine APIs.
    //
    LPWSTR			pszHelpFileName ;

    //
    // An array of help contexts corresponding to each dialog.
    // Use the HC_ manifiests defined below to fill this array.  The
    // manifests correspond to the following dialogs:
    //
    //	  HC_MAIN_DLG - First dialog brought up by the ACL editor
    //	  HC_SPECIAL_ACCESS_DLG - Container/object special access dialog
    //	  HC_NEW_ITEM_SPECIAL_ACCESS_DLG - New item special access dialog
    //		(not needed for containers that do not support new item
    //		permissions).
    //	  HC_ADD_USER_DLG - The "Add" dialog (brought up when the "Add..."
    //          button is pressed).
    //    HC_ADD_USER_MEMBERS_LG_DLG - The Local Group members dialog (brought
    //          up from the "Members" button in the "Add" dialog)
    //    HC_ADD_USER_MEMBERS_GG_DLG - The Global Group members dialog (brought
    //          up from the "Members" button in the "Add" dialog).
    //
    ULONG                       aulHelpContext[7] ;
} SED_HELP_INFO, *PSED_HELP_INFO ;

#define HC_MAIN_DLG			 0
#define HC_SPECIAL_ACCESS_DLG		 1
#define HC_NEW_ITEM_SPECIAL_ACCESS_DLG	 2
#define HC_ADD_USER_DLG                  3
#define HC_ADD_USER_MEMBERS_LG_DLG       4  // Members Local Group Dialog
#define HC_ADD_USER_MEMBERS_GG_DLG       5  // Members Global Group Dialog
#define HC_ADD_USER_SEARCH_DLG           6  // Search Dialog

//
// This data type defines information related to a single class of object.
// For example, a FILE object, or PRINT_QUEUE object would have a structure
// like this defined.
//

typedef struct _SED_OBJECT_TYPE_DESCRIPTOR
{
    //
    // The current revision level being used by the client.  This is for
    // support in case structure definitions change.  It should contain
    // the current revision supported.
    //
    UCHAR			Revision ;

    //
    // Defines whether the object is a container or not.
    // TRUE indicates the object may contain other objects.  Means the
    // user can Tree apply the permissions if desired.
    //
    BOOLEAN			IsContainer;

    //
    // Defines whether "New Object" permissions can be assigned (i.e.,
    // a "New Object" is an object that will be created in the future).
    //
    // This field is ignored when editting Auditting information
    //
    BOOLEAN			AllowNewObjectPerms ;

    //
    // This flag, if set to TRUE, will make the ACL editor map all specific
    // permissions in the security descriptor to the corresponding generic
    // permissions (using the passed generic mapping) and clear the mapped
    // specific bits.
    //
    // * Note that specific bits for Generic All will always    *
    // * be mapped regardless of this flag (due to Full Control *
    // * in the special access dialogs).                        *
    //
    // Clients who only expose the Generic and Standard permissions will
    // generally set this flag to TRUE.  If you are exposing the specific
    // bits (note you should not expose both specific and generic except for
    // Generic All) then this flag should be FALSE.
    //
    BOOLEAN			MapSpecificPermsToGeneric ;

    //
    // The generic mapping for the container or object permissions.
    //
    // This is used for mapping the specific permissions to the generic
    // flags.
    //
    PGENERIC_MAPPING		GenericMapping ;

    //
    // The generic mapping for the New Object permissions.
    //
    // This is used for mapping the specific permissions to the generic
    // flags for new object permissions (not used if AllowNewObjectPerms
    // is FALSE).
    //
    PGENERIC_MAPPING		GenericMappingNewObjects ;

    //
    // The (localized) name of the object type.
    // For example, "File",  "Print Job" or "Directory".
    //
    LPWSTR			ObjectTypeName;

    //
    // The help information suitable for the type of object the Security
    // Editor will be operating on.
    //
    PSED_HELP_INFO		HelpInfo ;

    //
    // The (localized) title to display if protection/auditting can be applied
    // to sub-objects/sub-containers.  This is the Tree apply
    // checkbox title.
    //
    // This string will be presented with a checkbox before it.
    // If this box is checked, then the callback entry point
    // will be called with the ApplyToSubContainers flag set to TRUE.
    //
    // This field is ignored if the IsContainer field is FALSE.
    //
    // As an example of how this field is used, the File Manager may
    // specify the following string in the DIRECTORY object's
    // descriptor:
    //
    //          "R&eplace Permissions on Subdirectories"
    //
    LPWSTR	       ApplyToSubContainerTitle;

    //
    // The (localized) title to display if protection/auditting can be applied
    // to sub-objects.
    //
    // This string will be presented with a checkbox before it.
    // If this box is checked, then the callback entry point
    // will be called with the ApplyTuSubObjects flag set to TRUE.
    //
    // This field is ignored if the IsContainer flag is FALSE or the
    // AllowNewObjectPerms flag is FALSE.
    //
    // As an example of how this field is used, the File Manager may
    // specify the following string in the DIRECTORY object's
    // descriptor:
    //
    //          "Replace Permissions on Existing &Files"
    //
    LPWSTR             ApplyToObjectsTitle;

    //
    // The (localized) text is presented in a confirmation message box
    // that is displayed to the user after the user has checked the
    // "ApplyToSubContainer" checkbox.
    //
    // This field is ignored if the IsContainer field is FALSE.
    //
    // For directories, this text might be:
    //
    //		"Do you want to replace the permissions on all existing
    //		 files and subdirectories within %1?"
    //
    // %1 will be substituted by the Acl Editor with the object name
    // field (i.e., "C:\MyDirectory")
    //
    LPWSTR	       ApplyToSubContainerConfirmation ;

    //
    // The (localized) title to display in the "Type of Access" combo
    // that brings up the Special access dialog.  This same title is
    // used for the title of this dialog except the "..." is stripped
    // from the end.
    //
    // This field is ignored if the System Acl editor was invoked.
    //
    // As an example of how this field is used, the File Manager may
    // specify the following string in the DIRECTORY object's
    // descriptor:
    //
    //		"Special Directory Access..."
    //
    LPWSTR	       SpecialObjectAccessTitle ;

    //
    // The (localized) title to display in the "Type of Access" combo
    // that brings up the Special new object access dialog.  This same title
    // is used for the title of this dialog except the "..." is stripped
    // from the end.
    //
    // This item is required if AllowNewObjectPerms is TRUE, it is ignored
    // if AllowNewObjectPerms is FALSE or we are editting a SACL.
    //
    // As an example of how this field is used, the file browser may
    // specify the following string in the DIRECTORY object's
    // descriptor:
    //
    //          "Special File Access..."
    //
    LPWSTR	       SpecialNewObjectAccessTitle ;

} SED_OBJECT_TYPE_DESCRIPTOR, *PSED_OBJECT_TYPE_DESCRIPTOR;


//
// It is desirable to display access names that are
// meaningful in the context of the type of object whose ACL
// is being worked on.  For example, for a PRINT_QUEUE object type,
// it may be desirable to display an access type named "Submit Print Jobs".
// The following structures are used for defining these application defined
// access groupings that appear in the "Type of access" combobox and the
// Special Access dialogs.
//

//
// The following are the different permission description types that the user
// will manipulate for setting permissions.
//
// SED_DESC_TYPE_RESOURCE - The SED_APPLICATION_ACCESS structure is describing
//	an object or container permission that will be displayed in the main
//	permissions listbox.  These should be the permissions that the
//	user will use all the time and will generally be a conglomeration
//	of permissions (for example, "Edit" which would include Read, Write
//	and possibly delete).
//
// SED_DESC_TYPE_CONT_AND_NEW_OBJECT - The structure is describing a container
//	and new object permission that will be shown in the main permissions
//	listbox.  The Container permission is contained in AccessMask1 and
//	the New Object resource is in AccessMask2.  When the permission name
//	is selected by the user, the container access permissions *and* the
//	new object access permissions will be set to the corresponding access
//	mask.  This is useful when inherittance can be used to set the New
//	Object Access permissions.
//
// SED_DESC_TYPE_RESOURCE_SPECIAL - The structure is describing an object
//	or container permissions that will be displayed in the Special
//	access dialog.	These are generally generic/standard permissions (such as
//	Read, Write, Execute, Set Permissions etc.).  The permission names
//	will appear next to checkboxes, thus they should have the "&"
//	accelerator next to the appropriate letter.
//
// SED_DESC_TYPE_NEW_OBJECT_SPECIAL - The structure is describing a new object
//	permission that will be shown in the Special New Object access
//	dialog.  This is used the same way the SED_DESC_TYPE_RESOURCE_SPECIAL
//	type is used, that is, the permissions should be the primitive, per
//	bit permissions.  The permission names
//	will appear next to checkboxes, thus they should have the "&"
//	accelerator next to the appropriate letter.
//
// SED_DESC_TYPE_AUDIT - The structure is describing an Audit access mask.
//	AccessMask1 contains the audit mask to be associated with the
//	permission title string.  The title string will appear next to
//	a checkbox, thus they should have the "&" accelerator next to
//	the appropriate letter in the title string.
//
// Note that they cannot be freely intermixed, use the following table
// as a guide for which ones to use where:
//
//  IsContainer  AllowNewObjectPerms
//     False	      False	     RESOURCE, RESOURCE_SPECIAL
//     True	      False	     RESOURCE, RESOURCE_SPECIAL
//     True	      True	     RESOURCE_SPECIAL, CONT_AND_NEW_OBJECT,
//				     NEW_OBJECT_SPECIAL
//     True	      False	     SED_DESC_TYPE_AUDIT
//
//  Note that in the third case (IsContainer && AllowNewObjectPerms) you
//  *cannot* use the RESOURCE permission description type, you must always
//  associate the permission on the resource with new object permissions.
//
#define SED_DESC_TYPE_RESOURCE			(1)
#define SED_DESC_TYPE_RESOURCE_SPECIAL		(2)

#define SED_DESC_TYPE_CONT_AND_NEW_OBJECT	(3)
#define SED_DESC_TYPE_NEW_OBJECT_SPECIAL	(4)

#define SED_DESC_TYPE_AUDIT			(5)


//
// To describe the permissions to the ACL Editor, build an array consisting
// of SED_APPLICATION_ACCESS structures.  The use of each field is as follows:
//
// Type - Contains one of the SED_DESC_TYPE_* manifests, determines what the
//	rest of the fields in this structure mean.  Specifically, if Type
//	equals:
//
//				    AccessMask1   AccessMask2	PermissionTitle
//				   ============================================
//SED_DESC_TYPE_RESOURCE	       Perm	   Not Used    Name of this Perm
//SED_DESC_TYPE_RESOURCE_SPECIAL    Special Perm   Not Used    Name of this Perm
//SED_DESC_TYPE_CONT_AND_NEW_OBJECT    Perm	  Special Perm Name of this Perm
//SED_DESC_TYPE_NEW_OBJECT_SPECIAL  Special Perm   Not Used    Name of this Perm
//SED_DESC_TYPE_AUDIT		     Audit Mask    Not Used    Name of this Audit mask
//
// AccessMask1 - Access mask to be associated with the PermissionTitle string,
//	see the table under Type for what this field contains.
//
// AccessMask2 - Either used for Special permissions or ignored.
//
// PermissionTitle - Title string this permission set is being associated with.
typedef struct _SED_APPLICATION_ACCESS
{
    UINT			Type ;
    ACCESS_MASK 		AccessMask1 ;
    ACCESS_MASK 		AccessMask2 ;
    LPWSTR			PermissionTitle ;

} SED_APPLICATION_ACCESS, *PSED_APPLICATION_ACCESS;

//
// This can be used for AccessMask2 when dealing with containers that support
// new object permissions and you need a SED_DESC_TYPE_CONT_AND_NEW_OBJECT
// that doesn't have a new object permission.
//
#define ACCESS_MASK_NEW_OBJ_NOT_SPECIFIED    (0xffffffff)


typedef struct _SED_APPLICATION_ACCESSES
{
    //
    // The count field indicates how many application defined access groupings
    // are defined by this data structure.  The AccessGroup[] array then
    // contains that number of elements.
    //

    ULONG                       Count;
    PSED_APPLICATION_ACCESS	AccessGroup ;

    //
    // The default permission that should be selected in in the
    // "Type of Access" combobox of the "Add" dialog.  Should be one of
    // the SED_DESC_TYPE_RESOURCE permissions (i.e., what is shown in the
    // main dialog).
    //
    // The default permission for "Files" & "Directories" for example might
    // be:
    //
    //		    "Read"
    //

    LPWSTR			DefaultPermName ;

} SED_APPLICATION_ACCESSES, *PSED_APPLICATION_ACCESSES ;

/*++

Routine Description:

    This routine is provided by a caller of the graphical ACL editor.

    It is called by the ACL editor to apply security/auditting info to
    target object(s) when requested by the user.

    All error notification should be performed in this call.  To dismiss
    the ACL Editor, return 0, otherwise return a non-zero error code.

Parameters:

    hwndParent - Parent window handle to use for message boxes or subsequent
	dialogs.

    hInstance - Instance handle suitable for retrieving resources from the
	applications .exe or .dll.

    CallbackContext - This is the value passed as the CallbackContext argument
	to the SedDiscretionaryAclEditor() or SedSystemAclEditor api when
	the graphical editor was invoked.

    SecDesc - This parameter points to a security descriptor
	that should be applied to this object/container and optionally
        sub-containers if the user selects the apply to tree option.

    SecDescNewObjects - This parameter is used only when operating on a
	resource that is a container and supports new objects (for
	example, directories).	If the user chooses the apply to tree option,
	then this security descriptor will have all of the "New Object"
	permission ACEs contained in the primary container and the inherit
	bits will be set appropriately.

    ApplyToSubContainers - When TRUE, indicates that Dacl/Sacl is to be applied
	to sub-containers of the target container as well as the target container.
        This will only be TRUE if the target object is a container object.

    ApplyToSubObjects - When TRUE, indicates the Dacl/Sacl is to be applied to
        sub-objects of the target object.
	The SecDescNewObjects should be used for applying the permissions
	in this instance.

    StatusReturn - This status flag indicates what condition the
	resources permissions were left in after an error occurred.

	    SED_STATUS_MODIFIED - This (success) status code indicates the
		protection has successfully been modified.

	    SED_STATUS_NOT_ALL_MODIFIED - This (warning) status code
		indicates an attempt to modify the resource permissions
		has only partially succeeded.

	    SED_STATUS_FAILED_TO_MODIFY - This (error) status code indicates
		an attempt to modify the permissions has failed completely.

Return Status:

    The return code is a standard Win32 error code.  All errors that occur
    must be reported inside this function.  If the return code is NO_ERROR,
    then the security editor will dismiss itself.  If you do not wish the
    security editor dismissed, return a non-zero value (the actual value is
    ignored).

--*/
typedef DWORD (WINAPI *PSED_FUNC_APPLY_SEC_CALLBACK)(
				       HWND	hwndParent,
				       HANDLE	hInstance,
				       ULONG_PTR            CallbackContext,
				       PSECURITY_DESCRIPTOR SecDesc,
				       PSECURITY_DESCRIPTOR SecDescNewObjects,
				       BOOLEAN	ApplyToSubContainers,
				       BOOLEAN	ApplyToSubObjects,
				       LPDWORD	StatusReturn
					     ) ;

/*++

Routine Description:

    This routine invokes the graphical Discretionary ACL editor DLL.  The
    graphical DACL editor may be used to modify or create:

            - A default Discretionary ACL

            - A Discretionary ACL for a particular type of object.

            - A Discretionary ACL for a particular named instance of an
              object.

    Additionally, in the case where the ACl is that of a named object
    instance, and that object may contain other object instances, the
    user will be presented with the opportunity to apply the protection
    to the entire sub-tree of objects.

    If an error occurs, the user will be properly notified by the ACL
    editor.


Parameters:

    Owner - Handle of the owner window the security editor should use for
	dialog creation and error messages.  This will lock down the passed
	window.

    Instance - Instance handle of the application.  This will be passed
	to the security editor callback where it can be used for retrieving
	any necessary resources such as message strings, dialog boxes etc.

    Server - The server name in the form "\\server" that the resource resides
	on.  This is used for adding users, groups and aliases to the
	DACL and SACL.	NULL indicates the local machine.

    ObjectType - This parameter is used to specify information
        about the type of object whose security is being edited.

    ApplicationAccesses - This parameter is used to specify
	groupings of access types when operating
        on security for the specified object type.  For example, it may be
        useful to define an access type called "Submit Print Job" for a
	PRINT_QUEUE class of object.

    ObjectName - This optional parameter is used to pass the name of the
        object whose security is being edited.

    ApplySecurityCallbackRoutine - This parameter is used to provide the
        address of a routine to be called to apply security to either the
        object specified, or, in the case that the object is a container,
        to sub-containers or sub-non-containers of that object.

    CallbackContext - This value is opaque to the DACL editor.  Its only
        purpose is so that a context value may be passed back to the
        application via the ApplySecurityCallbackRoutine when that routine
        is invoked.  This may be used by the application to re-locate
        context related to the edit session.  For example, it may be a
        handle to the object whose security is being edited.

    SecurityDescriptor - This parameter points to a security descriptor
        containing the current discretionary ACL of the object.  This
        security descriptor may, but does not have to, contain the owner
        and group of that object as well.  Note that the security descriptor's
        DaclPresent flag may be FALSE, indicating either that the object
	had no protection, or that the user couldn't read the protection.
        This security descriptor will not be modified by the ACL editor.
        This may be NULL, in which case, the user will be presented with
        an empty permission list.

    CouldntReadDacl - This boolean flag is used to indicate that the
        user does not have read access to the target object's discretionary
        acl.  In this case, a warning
        to the user will be presented along with the option to continue
        or cancel.

    CantWriteDacl - This boolean flag is used to indicate that the user
        does not have write acces to the target object's discretionary
        acl (but does have read access).  This invokes the editor in a
        read only mode that allows the user to view the security but not
        change it.

        Note that SACL access is determined by the SeSecurity privilege.
        If you have the privilege, then you can both read *and* write the
        SACL, if you do not have the privilege, you cannot read or write the
        SACL.

    SEDStatusReturn - This status flag indicates what condition the
	resources permissions were left in after the ACL editor was
	dismissed.  It may be one of:

	    SED_STATUS_MODIFIED - This (success) status code indicates the
		editor has been exited and protection has successfully been
		modified.

	    SED_STATUS_NOT_MODIFIED -  This (success) status code indicates
		the editor has been exited without attempting to modify the
		protection.

	    SED_STATUS_NOT_ALL_MODIFIED - This (warning) status code indicates
		the user requested the protection to be modified, but an attempt
		to do so only partially succeeded.  The user has been notified
		of this situation.

	    SED_STATUS_FAILED_TO_MODIFY - This (error) status code indicates
		the user requested the protection to be modified, but an
		attempt to do so has failed.  The user has been notified of
		this situation.

    Flags - Should be zero.

Return Code:

    A standard windows error return such as ERROR_NOT_ENOUGH_MEMORY.  This
    means the ACL editor was never displayed.  The user will be notified
    of the error before this procedure returns.

--*/

DWORD WINAPI
SedDiscretionaryAclEditor(
	HWND			             Owner,
	HANDLE			             Instance,
	LPWSTR			             Server,
	PSED_OBJECT_TYPE_DESCRIPTOR  ObjectType,
	PSED_APPLICATION_ACCESSES    ApplicationAccesses,
	LPWSTR			             ObjectName,
	PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
	ULONG_PTR			         CallbackContext,
	PSECURITY_DESCRIPTOR	     SecurityDescriptor,
    BOOLEAN                      CouldntReadDacl,
    BOOLEAN                      CantWriteDacl,
    LPDWORD                      SEDStatusReturn,
    DWORD                        Flags
	) ;

//
// The parameters for the SACL editor are exactly the same except where
// noted as that of the SedDiscretionaryAclEditor.
//

DWORD WINAPI
SedSystemAclEditor(
	HWND			     Owner,
	HANDLE			     Instance,
	LPWSTR			     Server,
	PSED_OBJECT_TYPE_DESCRIPTOR  ObjectType,
	PSED_APPLICATION_ACCESSES    ApplicationAccesses,
	LPWSTR			     ObjectName,
	PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
	ULONG_PTR    			     CallbackContext,
	PSECURITY_DESCRIPTOR	     SecurityDescriptor,
        BOOLEAN                      CouldntEditSacl,
        LPDWORD                      SEDStatusReturn,
        DWORD                        Flags
	) ;

/*++

Routine Description:

    This routine invokes the take ownership dialog which is used
    to view and/or set the owner of a security descriptor.  The current owner
    is displayed along with an optional button for the currently logged
    on user to take ownership.

    If an error occurs, the user will be properly notified by the API.

Parameters:

    Owner - Handle of the owner window the security editor should use for
	dialog creation and error messages.  This will lock down the passed
	window.

    Instance - Instance handle of the application.  This will be passed
	to the security editor callback where it can be used for retrieving
	any necessary resources such as message strings, dialog boxes etc.

    Server - The server name in the form "\\server" that the resource resides
        on. NULL indicates the local machine.

    ObjectTypeName - NT Resource type of object the user wants to look
	at the owner of.
	Examples for this parameter would be "File", "Directory"
	or "Files/Directories".

    ObjectName - This parameter is used to pass the name of the
	object whose security is being edited.	This might be
	"C:\status.doc" or some other qualified name.

    CountOfObjects - The number of objects the user wants to change permissions
	on.  If this number is greater then one, then the ObjectName is
	ignored and a message of the form "%d ObjectTypeName Selected".

    ApplySecurityCallbackRoutine - This parameter is used to provide the
	address of a routine to be called to apply the new security
	descriptor.  The flags in the PSED_FUNC_APPLY_SEC_CALLBACK
	type are not used.

    CallbackContext - This value is opaque to this API.  Its only
        purpose is so that a context value may be passed back to the
        application via the ApplySecurityCallbackRoutine when that routine
        is invoked.  This may be used by the application to re-locate
        context related to the edit session.  For example, it may be a
        handle to the object whose security is being edited.

    SecurityDescriptor - This parameter points to a security descriptor
        containing the current owner and group.  May be NULL.

    CouldntReadOwner - This boolean flag may be used to indicate that the
        user does not have read access to the target object's owner/group
        SID.  In this case, a warning
        to the user will be presented along with the option to continue
        or cancel.

    CantWriteOwner - The boolean flag may be used to indicate that the user
        does not have write access to the target object's owner/group SID.

    SEDStatusReturn - This status flag indicates what condition the
	resources security descriptor were left in after the take ownership
	dialog was dismissed.  It may be one of:

	    SED_STATUS_MODIFIED - This (success) status code indicates the
		dialog has been exited and the new owner has successfully been
		modified.

	    SED_STATUS_NOT_MODIFIED -  This (success) status code indicates
		the dialog has been exited without attempting to modify the
		owner.

	    SED_STATUS_NOT_ALL_MODIFIED - This (warning) status code indicates
		the user requested the owner to be modified, but an attempt
		to do so only partially succeeded.  The user has been notified
		of this situation.

	    SED_STATUS_FAILED_TO_MODIFY - This (error) status code indicates
		the user requested the owner to be modified, but an
		attempt to do so has failed.  The user has been notified of
		this situation.

    Flags - Should be zero.
Return Code:

    A standard windows error return such as ERROR_NOT_ENOUGH_MEMORY.  This
    means the dialog was never displayed.  The user will be notified
    of the error before this procedure returns.

--*/

DWORD WINAPI
SedTakeOwnership(
	HWND			     Owner,
	HANDLE			     Instance,
	LPWSTR			     Server,
	LPWSTR			     ObjectTypeName,
	LPWSTR			     ObjectName,
	UINT			     CountOfObjects,
	PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
	ULONG_PTR			     CallbackContext,
	PSECURITY_DESCRIPTOR	     SecurityDescriptor,
        BOOLEAN                      CouldntReadOwner,
        BOOLEAN                      CantWriteOwner,
	LPDWORD 		     SEDStatusReturn,
        PSED_HELP_INFO               HelpInfo,
        DWORD                        Flags
	);

#ifdef __cplusplus
}
#endif

#endif //_SEDAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\tcerror.h ===
/* Copyright (c) 1997-1999, Microsoft Corporation, all rights reserved
**
** tcerror.h
** Traffic Control external API
** TC specific error codes
*/

#ifndef _TCERROR_H_
#define _TCERROR_H_

#if _MSC_VER > 1000
#pragma once
#endif

#define TCBASE 7500


//
// Incompatible TC version number
//
#define ERROR_INCOMPATIBLE_TCI_VERSION			(TCBASE+1)

//
// Unspecified or bad intserv service type
//
#define ERROR_INVALID_SERVICE_TYPE			(TCBASE+2)

//
// Unspecified or bad TokenRate
//
#define ERROR_INVALID_TOKEN_RATE			(TCBASE+3)
	
//
// Bad PeakBandwidth
//
#define ERROR_INVALID_PEAK_RATE				(TCBASE+4)
	
//
// Invalid ShapeDiscardMode
//
#define ERROR_INVALID_SD_MODE				(TCBASE+5)
	
//
// Invalid priority value
//
#define ERROR_INVALID_QOS_PRIORITY			(TCBASE+6)
	
//
// Invalid traffic class value
//
#define ERROR_INVALID_TRAFFIC_CLASS			(TCBASE+7)
	
//
// Invalid address type
//
#define ERROR_INVALID_ADDRESS_TYPE			(TCBASE+8)
	
//
// Attempt to install identical filter on same flow
//
#define ERROR_DUPLICATE_FILTER				(TCBASE+9)
	
//
// Attempt to install conflicting filter
//
#define ERROR_FILTER_CONFLICT				(TCBASE+10)
	
//
// This address type is not supported
//
#define ERROR_ADDRESS_TYPE_NOT_SUPPORTED	(TCBASE+11)

//
// This object can not be deleted since its suporting opened objects
//
#define ERROR_TC_SUPPORTED_OBJECTS_EXIST	(TCBASE+12)

//
// Incompatable QoS parameters
//
#define ERROR_INCOMPATABLE_QOS				(TCBASE+13)

//
// Traffic Control is not supported in the system
//
#define ERROR_TC_NOT_SUPPORTED				(TCBASE+14)

//
// TcObjectsLength is inconsistent with CfInfoSize
//
#define ERROR_TC_OBJECT_LENGTH_INVALID      (TCBASE+15)

//
// Adding an Intserv flow in Diffserv mode or vice versa
//
#define ERROR_INVALID_FLOW_MODE             (TCBASE+16)

//
// Invalid Diffserv flow
//
#define ERROR_INVALID_DIFFSERV_FLOW         (TCBASE+17)

//
// DS codepoint already exists
//
#define ERROR_DS_MAPPING_EXISTS             (TCBASE+18)

//
// Invalid Shape Rate specified
//
#define ERROR_INVALID_SHAPE_RATE            (TCBASE+19)

// 
// Invalid DCLASS
// 
#define ERROR_INVALID_DS_CLASS              (TCBASE+20)

// 
// Too many GPC clients
// 
#define ERROR_TOO_MANY_CLIENTS              (TCBASE+21)

#endif // _TCERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\triage.h ===
/*++

Copyright(c) 1999 Microsoft Corporation

Module Name:

    triage.h

Abstract:

    The triage dump is a small crashdump that has been saved to the system
    pagefile. The boot loader loads this triage dump in an attempt to find
    out why the system crashed and (hopefully) prevent it from crashing
    again.

Author:

    Matthew D Hendel (math) 20-Jan-1999

--*/

#ifndef __TRIAGE_H__
#define __TRIAGE_H__

#if _MSC_VER > 1000
#pragma once
#endif

//
// The representation of a module in the triage dump.
//

typedef struct _TRIAGE_DUMP_MODULE {
    LIST_ENTRY InLoadOrderLinks;
    UINT_PTR BaseAddress;
    UINT_PTR EntryPointAddress;
    ULONG SizeOfImage;
    UNICODE_STRING ImageName;
    WCHAR _ImageNameBuffer [ 260 ];
    PVOID LdrEntry;
    ULONG CheckSum;
    ULONG TimeDateStamp;
} TRIAGE_DUMP_MODULE, * PTRIAGE_DUMP_MODULE;


NTSTATUS
TriageGetVersion(
    IN PVOID TriageDumpBlock,
    OUT ULONG * MajorVersion,
    OUT ULONG * MinorVersion,
    OUT ULONG * BuildNumber
    );

NTSTATUS
TriageGetDriverCount(
    IN PVOID TriageDumpBlock,
    OUT ULONG * DriverCount
    );

NTSTATUS
TriageGetContext(
    IN PVOID TriageDumpBlock,
    OUT PVOID * Context
    );

NTSTATUS
TriageGetExceptionRecord(
    IN PVOID TriageDumpBlock,
    OUT PEXCEPTION_RECORD * ExceptionRecord
    );

NTSTATUS
TriageGetBugcheckData(
    IN PVOID TriageDumpBlock,
    OUT ULONG * BugCheckCode,
    OUT UINT_PTR * BugCheckParam1,
    OUT UINT_PTR * BugCheckParam2,
    OUT UINT_PTR * BugCheckParam3,
    OUT UINT_PTR * BugCheckParam4
    );

NTSTATUS
TriageGetDriverEntry(
    IN PVOID TriageDumpBlock,
    IN ULONG ModuleIndex,
    OUT TRIAGE_DUMP_MODULE * Module,
    OUT BOOLEAN * BrokenModuleFlag
    );


NTSTATUS
TriageGetStack(
    IN PVOID TriageDumpBlock,
    OUT UINT_PTR * BaseOfStack,
    OUT ULONG * SizeOfStack,
    OUT PVOID * StackData
    );

NTSTATUS
TriageGetThread(
    IN PVOID TriageDumpBlock,
    OUT PVOID * Thread,
    OUT ULONG * ThreadSize
    );

NTSTATUS
TriageGetProcessor(
    IN PVOID TriageDumpBlock,
    OUT PVOID * Processor,
    OUT ULONG * ProcessorSize
    );

NTSTATUS
TriageGetProcess(
    IN PVOID TriageDumpBlock,
    OUT PVOID * Process,
    OUT ULONG * ProcessSize
    );

#endif // __TRIAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\tuneprefix.h ===
/*++ 

    Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

Module Name:

    TunePrefix.h

Abstract:

    This module includes tuning macros intended for use with PREfix.

Author:

    Tim Fleehart    [timf]  20000215

--*/


#ifndef _TUNEPREFIX_H_INCLUDED_
#  define _TUNEPREFIX_H_INCLUDED_

#  ifdef _PREFIX_

//
// The PREfix parser defines _PREFIX_, this allows us to create some tuning
// macros.
//
// PREfixExit will be hooked by the PREfix simulator as an "exit_function"
// so we won't continue simulation on a path past this function.
//

__inline
void
PREfixExit(
 void
)
{
    ;
}

//
// reason should be a quoted string that explains why the condition can't
// happen as an aid to code-reading.
//

#    define PREFIX_ASSUME(condition, reason) \
        { if (!(condition)) { PREfixExit(); } }

#    define PREFIX_NOT_REACHED(reason) PREfixExit()

#  else

     // PREFIX_* tuning macros should have no effect when _PREFIX_ isn't
     // already defined.

#    define PREFIX_ASSUME(condition, reason)
#    define PREFIX_NOT_REACHED(reason)

#  endif

#endif // _TUNEPREFIX_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\spseal.h ===
/*++

Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    spseal.h

Abstract:

    This is a private header file defining function prototypes for security
    provider encryption routines.

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.
    Requires security.h or sspi.h be included.

Revision History:

--*/

#ifndef _SPSEAL_
#define _SPSEAL_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef SECURITY_DOS
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4147)
#endif

#ifdef __cplusplus
extern "C" {
#endif

SECURITY_STATUS SEC_ENTRY
SealMessage(    PCtxtHandle         phContext,
                unsigned long       fQOP,
                PSecBufferDesc      pMessage,
                unsigned long       MessageSeqNo);

typedef SECURITY_STATUS
(SEC_ENTRY * SEAL_MESSAGE_FN)(
    PCtxtHandle, unsigned long, PSecBufferDesc, unsigned long);


SECURITY_STATUS SEC_ENTRY
UnsealMessage(  PCtxtHandle         phContext,
                PSecBufferDesc      pMessage,
                unsigned long       MessageSeqNo,
                unsigned long *     pfQOP);


typedef SECURITY_STATUS
(SEC_ENTRY * UNSEAL_MESSAGE_FN)(
    PCtxtHandle, PSecBufferDesc, unsigned long,
    unsigned long SEC_FAR *);

#ifdef __cplusplus
}       // extern "C"
#endif

#ifdef SECURITY_DOS
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4147)
#endif
#endif

#endif // _SPSEAL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\snmp.h ===
/*++

Copyright (C) 1992-1999 Microsoft Corporation

Module Name:

    snmp.h

Abstract:

    Definitions for SNMP development.

--*/

#ifndef _INC_SNMP
#define _INC_SNMP

#if _MSC_VER > 1000
#pragma once
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Additional Header Files                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Type Definitions                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <pshpack4.h>

typedef struct {
    BYTE * stream;
    UINT   length;
    BOOL   dynamic;
} AsnOctetString;

typedef struct {
    UINT   idLength;
    UINT * ids;
} AsnObjectIdentifier;

typedef LONG                    AsnInteger32;
typedef ULONG                   AsnUnsigned32;
typedef ULARGE_INTEGER          AsnCounter64;
typedef AsnUnsigned32           AsnCounter32;
typedef AsnUnsigned32           AsnGauge32;
typedef AsnUnsigned32           AsnTimeticks;
typedef AsnOctetString          AsnBits;
typedef AsnOctetString          AsnSequence;
typedef AsnOctetString          AsnImplicitSequence;
typedef AsnOctetString          AsnIPAddress;
typedef AsnOctetString          AsnNetworkAddress;
typedef AsnOctetString          AsnDisplayString;
typedef AsnOctetString          AsnOpaque;

typedef struct {
    BYTE asnType;
    union {
        AsnInteger32            number;     // ASN_INTEGER
                                            // ASN_INTEGER32
        AsnUnsigned32           unsigned32; // ASN_UNSIGNED32
        AsnCounter64            counter64;  // ASN_COUNTER64
        AsnOctetString          string;     // ASN_OCTETSTRING
        AsnBits                 bits;       // ASN_BITS
        AsnObjectIdentifier     object;     // ASN_OBJECTIDENTIFIER
        AsnSequence             sequence;   // ASN_SEQUENCE
        AsnIPAddress            address;    // ASN_IPADDRESS
        AsnCounter32            counter;    // ASN_COUNTER32
        AsnGauge32              gauge;      // ASN_GAUGE32
        AsnTimeticks            ticks;      // ASN_TIMETICKS
        AsnOpaque               arbitrary;  // ASN_OPAQUE
    } asnValue;
} AsnAny;

typedef AsnObjectIdentifier     AsnObjectName;
typedef AsnAny                  AsnObjectSyntax;

typedef struct {
    AsnObjectName    name;
    AsnObjectSyntax  value;
} SnmpVarBind;

typedef struct {
    SnmpVarBind * list;
    UINT          len;
} SnmpVarBindList;

#include <poppack.h>

#ifndef _INC_WINSNMP

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ASN/BER Base Types                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ASN_UNIVERSAL                   0x00
#define ASN_APPLICATION                 0x40
#define ASN_CONTEXT                     0x80
#define ASN_PRIVATE                     0xC0

#define ASN_PRIMITIVE                   0x00
#define ASN_CONSTRUCTOR                 0x20

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// PDU Type Values                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_PDU_GET                (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x0)
#define SNMP_PDU_GETNEXT            (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x1)
#define SNMP_PDU_RESPONSE           (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x2)
#define SNMP_PDU_SET                (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x3)
#define SNMP_PDU_V1TRAP             (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x4)
#define SNMP_PDU_GETBULK            (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x5)
#define SNMP_PDU_INFORM             (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x6)
#define SNMP_PDU_TRAP               (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x7)

#endif // _INC_WINSNMP

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Simple Syntax Values                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ASN_INTEGER                 (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x02)
#define ASN_BITS                    (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x03)
#define ASN_OCTETSTRING             (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x04)
#define ASN_NULL                    (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x05)
#define ASN_OBJECTIDENTIFIER        (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x06)
#define ASN_INTEGER32               ASN_INTEGER

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Constructor Syntax Values                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ASN_SEQUENCE                (ASN_UNIVERSAL | ASN_CONSTRUCTOR | 0x10)
#define ASN_SEQUENCEOF              ASN_SEQUENCE

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Application Syntax Values                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ASN_IPADDRESS               (ASN_APPLICATION | ASN_PRIMITIVE | 0x00)
#define ASN_COUNTER32               (ASN_APPLICATION | ASN_PRIMITIVE | 0x01)
#define ASN_GAUGE32                 (ASN_APPLICATION | ASN_PRIMITIVE | 0x02)
#define ASN_TIMETICKS               (ASN_APPLICATION | ASN_PRIMITIVE | 0x03)
#define ASN_OPAQUE                  (ASN_APPLICATION | ASN_PRIMITIVE | 0x04)
#define ASN_COUNTER64               (ASN_APPLICATION | ASN_PRIMITIVE | 0x06)
#define ASN_UNSIGNED32              (ASN_APPLICATION | ASN_PRIMITIVE | 0x07)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Exception Conditions                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_EXCEPTION_NOSUCHOBJECT     (ASN_CONTEXT | ASN_PRIMITIVE | 0x00)
#define SNMP_EXCEPTION_NOSUCHINSTANCE   (ASN_CONTEXT | ASN_PRIMITIVE | 0x01)
#define SNMP_EXCEPTION_ENDOFMIBVIEW     (ASN_CONTEXT | ASN_PRIMITIVE | 0x02)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Request Types (used in SnmpExtensionQueryEx)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_EXTENSION_GET          SNMP_PDU_GET
#define SNMP_EXTENSION_GET_NEXT     SNMP_PDU_GETNEXT
#define SNMP_EXTENSION_GET_BULK     SNMP_PDU_GETBULK
#define SNMP_EXTENSION_SET_TEST     (ASN_PRIVATE | ASN_CONSTRUCTOR | 0x0)
#define SNMP_EXTENSION_SET_COMMIT   SNMP_PDU_SET
#define SNMP_EXTENSION_SET_UNDO     (ASN_PRIVATE | ASN_CONSTRUCTOR | 0x1)
#define SNMP_EXTENSION_SET_CLEANUP  (ASN_PRIVATE | ASN_CONSTRUCTOR | 0x2)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Error Codes                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_ERRORSTATUS_NOERROR                0
#define SNMP_ERRORSTATUS_TOOBIG                 1
#define SNMP_ERRORSTATUS_NOSUCHNAME             2
#define SNMP_ERRORSTATUS_BADVALUE               3
#define SNMP_ERRORSTATUS_READONLY               4
#define SNMP_ERRORSTATUS_GENERR                 5
#define SNMP_ERRORSTATUS_NOACCESS               6
#define SNMP_ERRORSTATUS_WRONGTYPE              7
#define SNMP_ERRORSTATUS_WRONGLENGTH            8
#define SNMP_ERRORSTATUS_WRONGENCODING          9
#define SNMP_ERRORSTATUS_WRONGVALUE             10
#define SNMP_ERRORSTATUS_NOCREATION             11
#define SNMP_ERRORSTATUS_INCONSISTENTVALUE      12
#define SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE    13
#define SNMP_ERRORSTATUS_COMMITFAILED           14
#define SNMP_ERRORSTATUS_UNDOFAILED             15
#define SNMP_ERRORSTATUS_AUTHORIZATIONERROR     16
#define SNMP_ERRORSTATUS_NOTWRITABLE            17
#define SNMP_ERRORSTATUS_INCONSISTENTNAME       18

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMPv1 Trap Types                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_GENERICTRAP_COLDSTART              0
#define SNMP_GENERICTRAP_WARMSTART              1
#define SNMP_GENERICTRAP_LINKDOWN               2
#define SNMP_GENERICTRAP_LINKUP                 3
#define SNMP_GENERICTRAP_AUTHFAILURE            4
#define SNMP_GENERICTRAP_EGPNEIGHLOSS           5
#define SNMP_GENERICTRAP_ENTERSPECIFIC          6

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Access Types                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_ACCESS_NONE                        0
#define SNMP_ACCESS_NOTIFY                      1
#define SNMP_ACCESS_READ_ONLY                   2
#define SNMP_ACCESS_READ_WRITE                  3
#define SNMP_ACCESS_READ_CREATE                 4

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP API Return Code Definitions                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMPAPI                                 INT
#define SNMP_FUNC_TYPE                          WINAPI

#define SNMPAPI_NOERROR                         TRUE
#define SNMPAPI_ERROR                           FALSE

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Extension API Prototypes                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
SNMP_FUNC_TYPE
SnmpExtensionInit(
    DWORD                 dwUptimeReference,
    HANDLE *              phSubagentTrapEvent,
    AsnObjectIdentifier * pFirstSupportedRegion
    );

BOOL
SNMP_FUNC_TYPE
SnmpExtensionInitEx(
    AsnObjectIdentifier * pNextSupportedRegion
    );

BOOL
SNMP_FUNC_TYPE
SnmpExtensionMonitor(
    LPVOID            pAgentMgmtData
    );

BOOL
SNMP_FUNC_TYPE
SnmpExtensionQuery(
    BYTE              bPduType,
    SnmpVarBindList * pVarBindList,
    AsnInteger32 *    pErrorStatus,
    AsnInteger32 *    pErrorIndex
    );

BOOL
SNMP_FUNC_TYPE
SnmpExtensionQueryEx(
    UINT              nRequestType,
    UINT              nTransactionId,
    SnmpVarBindList * pVarBindList,
    AsnOctetString *  pContextInfo,
    AsnInteger32 *    pErrorStatus,
    AsnInteger32 *    pErrorIndex
    );

BOOL
SNMP_FUNC_TYPE
SnmpExtensionTrap(
    AsnObjectIdentifier * pEnterpriseOid,
    AsnInteger32 *        pGenericTrapId,
    AsnInteger32 *        pSpecificTrapId,
    AsnTimeticks *        pTimeStamp,
    SnmpVarBindList *     pVarBindList
    );

VOID
SNMP_FUNC_TYPE
SnmpExtensionClose(
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Extension API Type Definitions                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONINIT)(
    DWORD                 dwUpTimeReference,
    HANDLE *              phSubagentTrapEvent,
    AsnObjectIdentifier * pFirstSupportedRegion
    );

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONINITEX)(
    AsnObjectIdentifier * pNextSupportedRegion
    );

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONMONITOR)(
    LPVOID            pAgentMgmtData
    );

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONQUERY)(
    BYTE              bPduType,
    SnmpVarBindList * pVarBindList,
    AsnInteger32 *    pErrorStatus,
    AsnInteger32 *    pErrorIndex
    );

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONQUERYEX)(
    UINT              nRequestType,
    UINT              nTransactionId,
    SnmpVarBindList * pVarBindList,
    AsnOctetString *  pContextInfo,
    AsnInteger32 *    pErrorStatus,
    AsnInteger32 *    pErrorIndex
    );

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONTRAP)(
    AsnObjectIdentifier * pEnterpriseOid,
    AsnInteger32 *        pGenericTrapId,
    AsnInteger32 *        pSpecificTrapId,
    AsnTimeticks *        pTimeStamp,
    SnmpVarBindList *     pVarBindList
    );

typedef VOID (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONCLOSE)(
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP API Prototypes                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOidCpy(
    AsnObjectIdentifier * pOidDst,
    AsnObjectIdentifier * pOidSrc
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOidAppend(
    AsnObjectIdentifier * pOidDst,
    AsnObjectIdentifier * pOidSrc
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOidNCmp(
    AsnObjectIdentifier * pOid1,
    AsnObjectIdentifier * pOid2,
    UINT                  nSubIds
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOidCmp(
    AsnObjectIdentifier * pOid1,
    AsnObjectIdentifier * pOid2
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilOidFree(
    AsnObjectIdentifier * pOid
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOctetsCmp(
    AsnOctetString * pOctets1,
    AsnOctetString * pOctets2
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOctetsNCmp(
    AsnOctetString * pOctets1,
    AsnOctetString * pOctets2,
    UINT             nChars
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOctetsCpy(
    AsnOctetString * pOctetsDst,
    AsnOctetString * pOctetsSrc
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilOctetsFree(
    AsnOctetString * pOctets
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilAsnAnyCpy(
    AsnAny * pAnyDst,
    AsnAny * pAnySrc
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilAsnAnyFree(
    AsnAny * pAny
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilVarBindCpy(
    SnmpVarBind * pVbDst,
    SnmpVarBind * pVbSrc
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilVarBindFree(
    SnmpVarBind * pVb
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilVarBindListCpy(
    SnmpVarBindList * pVblDst,
    SnmpVarBindList * pVblSrc
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilVarBindListFree(
    SnmpVarBindList * pVbl
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilMemFree(
    LPVOID pMem
    );

LPVOID
SNMP_FUNC_TYPE
SnmpUtilMemAlloc(
    UINT nBytes
    );

LPVOID
SNMP_FUNC_TYPE
SnmpUtilMemReAlloc(
    LPVOID pMem,
    UINT   nBytes
    );

LPSTR
SNMP_FUNC_TYPE
SnmpUtilOidToA(
    IN AsnObjectIdentifier *Oid
    );

LPSTR
SNMP_FUNC_TYPE
SnmpUtilIdsToA(
    IN UINT *Ids,
    IN UINT IdLength
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilPrintOid(
    IN AsnObjectIdentifier *Oid
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilPrintAsnAny(
    AsnAny * pAny
    );

DWORD
SNMP_FUNC_TYPE
SnmpSvcGetUptime(
    );

VOID
SNMP_FUNC_TYPE
SnmpSvcSetLogLevel(
    INT nLogLevel
    );

VOID
SNMP_FUNC_TYPE
SnmpSvcSetLogType(
    INT nLogType
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Debugging Definitions                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_LOG_SILENT                 0x0
#define SNMP_LOG_FATAL                  0x1
#define SNMP_LOG_ERROR                  0x2
#define SNMP_LOG_WARNING                0x3
#define SNMP_LOG_TRACE                  0x4
#define SNMP_LOG_VERBOSE                0x5

#define SNMP_OUTPUT_TO_CONSOLE          0x1
#define SNMP_OUTPUT_TO_LOGFILE          0x2
#define SNMP_OUTPUT_TO_EVENTLOG         0x4  // no longer supported
#define SNMP_OUTPUT_TO_DEBUGGER         0x8

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Debugging Prototypes                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
SNMP_FUNC_TYPE
SnmpUtilDbgPrint(
    IN INT nLogLevel,   // see log levels above...
    IN LPSTR szFormat,
    IN ...
    );

#if DBG
#define SNMPDBG(_x_)                    SnmpUtilDbgPrint _x_
#else
#define SNMPDBG(_x_)
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Miscellaneous definitions                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define DEFINE_SIZEOF(Array)        (sizeof(Array)/sizeof((Array)[0]))
#define DEFINE_OID(SubIdArray)      {DEFINE_SIZEOF(SubIdArray),(SubIdArray)}
#define DEFINE_NULLOID()            {0,NULL}
#define DEFINE_NULLOCTETS()         {NULL,0,FALSE}

#define DEFAULT_SNMP_PORT_UDP       161
#define DEFAULT_SNMP_PORT_IPX       36879
#define DEFAULT_SNMPTRAP_PORT_UDP   162
#define DEFAULT_SNMPTRAP_PORT_IPX   36880

#define SNMP_MAX_OID_LEN            128

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// API Error Code Definitions                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_MEM_ALLOC_ERROR            1
#define SNMP_BERAPI_INVALID_LENGTH      10
#define SNMP_BERAPI_INVALID_TAG         11
#define SNMP_BERAPI_OVERFLOW            12
#define SNMP_BERAPI_SHORT_BUFFER        13
#define SNMP_BERAPI_INVALID_OBJELEM     14
#define SNMP_PDUAPI_UNRECOGNIZED_PDU    20
#define SNMP_PDUAPI_INVALID_ES          21
#define SNMP_PDUAPI_INVALID_GT          22
#define SNMP_AUTHAPI_INVALID_VERSION    30
#define SNMP_AUTHAPI_INVALID_MSG_TYPE   31
#define SNMP_AUTHAPI_TRIV_AUTH_FAILED   32

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Support for old definitions (support disabled via SNMPSTRICT)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifndef SNMPSTRICT

#define SNMP_oidcpy                     SnmpUtilOidCpy
#define SNMP_oidappend                  SnmpUtilOidAppend
#define SNMP_oidncmp                    SnmpUtilOidNCmp
#define SNMP_oidcmp                     SnmpUtilOidCmp
#define SNMP_oidfree                    SnmpUtilOidFree

#define SNMP_CopyVarBindList            SnmpUtilVarBindListCpy
#define SNMP_FreeVarBindList            SnmpUtilVarBindListFree
#define SNMP_CopyVarBind                SnmpUtilVarBindCpy
#define SNMP_FreeVarBind                SnmpUtilVarBindFree

#define SNMP_printany                   SnmpUtilPrintAsnAny

#define SNMP_free                       SnmpUtilMemFree
#define SNMP_malloc                     SnmpUtilMemAlloc
#define SNMP_realloc                    SnmpUtilMemReAlloc

#define SNMP_DBG_free                   SnmpUtilMemFree
#define SNMP_DBG_malloc                 SnmpUtilMemAlloc
#define SNMP_DBG_realloc                SnmpUtilMemReAlloc

#define ASN_RFC1155_IPADDRESS           ASN_IPADDRESS
#define ASN_RFC1155_COUNTER             ASN_COUNTER32
#define ASN_RFC1155_GAUGE               ASN_GAUGE32
#define ASN_RFC1155_TIMETICKS           ASN_TIMETICKS
#define ASN_RFC1155_OPAQUE              ASN_OPAQUE
#define ASN_RFC1213_DISPSTRING          ASN_OCTETSTRING

#define ASN_RFC1157_GETREQUEST          SNMP_PDU_GET
#define ASN_RFC1157_GETNEXTREQUEST      SNMP_PDU_GETNEXT
#define ASN_RFC1157_GETRESPONSE         SNMP_PDU_RESPONSE
#define ASN_RFC1157_SETREQUEST          SNMP_PDU_SET
#define ASN_RFC1157_TRAP                SNMP_PDU_V1TRAP

#define ASN_CONTEXTSPECIFIC             ASN_CONTEXT
#define ASN_PRIMATIVE                   ASN_PRIMITIVE

#define RFC1157VarBindList              SnmpVarBindList
#define RFC1157VarBind                  SnmpVarBind
#define AsnInteger                      AsnInteger32
#define AsnCounter                      AsnCounter32
#define AsnGauge                        AsnGauge32

#endif // SNMPSTRICT

#ifdef __cplusplus
}
#endif

#endif // _INC_SNMP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\stralign.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    stralign.h

Abstract:

    This module contains macros and prototypes to expose the unaligned wide
    character interfaces.

    Public interfaces created or declared here include:

    ua_CharUpper()
    ua_CharUpperW()
    ua_lstrcmp()
    ua_lstrcmpW()
    ua_lstrcmpi()
    ua_lstrcmpiW()
    ua_lstrlen()
    ua_lstrlenW()
    ua_tcscpy()
    ua_wcschr()
    ua_wcscpy()
    ua_wcslen()
    ua_wcsrchr()

    STRUC_ALIGNED_STACK_COPY()
    TSTR_ALIGNED()
    TSTR_ALIGNED_STACK_COPY()
    WSTR_ALIGNED()
    WSTR_ALIGNED_STACK_COPY()

Author:


Revision History:

--*/

#if !defined(__STRALIGN_H_) && !defined(MIDL_PASS)
#define __STRALIGN_H_

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_X86_)

//
// Alignment of unicode strings is not necessary on X86.
//

#define WSTR_ALIGNED(s) TRUE

#define ua_CharUpperW CharUpperW
#define ua_lstrcmpiW  lstrcmpiW
#define ua_lstrcmpW   lstrcmpW
#define ua_lstrlenW   lstrlenW
#define ua_wcschr     wcschr
#define ua_wcscpy     wcscpy
#define ua_wcslen     wcslen
#define ua_wcsrchr    wcsrchr

#else

//
// The C runtime libraries expect aligned string pointers.  Following are the
// prototypes for our own, slower worker functions that accept unaligned
// UNICODE strings.
//

//
// Macro to determine whether a pointer to a unicode character is naturally
// aligned.
//

#define WSTR_ALIGNED(s) (((DWORD_PTR)(s) & (sizeof(WCHAR)-1)) == 0)

//
// Platform-specific prototypes for worker functions exported from kernel32.
// Do not call these directly, they do not exist on all platforms.  Instead
// use the equivalent ua_xxx() routines.
//

LPUWSTR
WINAPI
uaw_CharUpperW(
    IN OUT LPUWSTR String
    );

int
APIENTRY
uaw_lstrcmpW(
    IN PCUWSTR String1,
    IN PCUWSTR String2
    );

int
APIENTRY
uaw_lstrcmpiW(
    IN PCUWSTR String1,
    IN PCUWSTR String2
    );

int
WINAPI
uaw_lstrlenW(
    IN LPCUWSTR String
    );

PUWSTR
__cdecl
uaw_wcschr(
    IN PCUWSTR String,
    IN WCHAR   Character
    );

PUWSTR
_cdecl
uaw_wcscpy(
    IN PUWSTR Destination,
    IN PCUWSTR Source
    );

size_t
__cdecl
uaw_wcslen(
    IN PCUWSTR String
    );

PUWSTR
__cdecl
uaw_wcsrchr(
    IN PCUWSTR String,
    IN WCHAR   Character
    );

//
// Following are the inline wrappers that determine the optimal worker function
// to call based on the alignment of the UNICODE string arguments.  Their
// behavior is otherwise identical to the corresponding standard run-time
// routiunes.
//

#if defined(CharUpper)
__inline
LPUWSTR
static
ua_CharUpperW(
    LPUWSTR String
    )
{
    if (WSTR_ALIGNED(String)) {
        return CharUpperW( (PWSTR)String );
    } else {
        return uaw_CharUpperW( String );
    }
}
#endif

#if defined(lstrcmp)
__inline
int
static
ua_lstrcmpW(
    IN LPCUWSTR String1,
    IN LPCUWSTR String2
    )
{
    if (WSTR_ALIGNED(String1) && WSTR_ALIGNED(String2)) {
        return lstrcmpW( (LPCWSTR)String1, (LPCWSTR)String2);
    } else {
        return uaw_lstrcmpW( String1, String2 );
    }
}
#endif

#if defined(lstrcmpi)
__inline
int
static
ua_lstrcmpiW(
    IN LPCUWSTR String1,
    IN LPCUWSTR String2
    )
{
    if (WSTR_ALIGNED(String1) && WSTR_ALIGNED(String2)) {
        return lstrcmpiW( (LPCWSTR)String1, (LPCWSTR)String2 );
    } else {
        return uaw_lstrcmpiW( String1, String2 );
    }
}
#endif

#if defined(lstrlen)
__inline
int
static
ua_lstrlenW(
    IN LPCUWSTR String
    )
{
    if (WSTR_ALIGNED(String)) {
        return lstrlenW( (PCWSTR)String );
    } else {
        return uaw_lstrlenW( String );
    }
}
#endif

#if defined(_WSTRING_DEFINED)

//
// Certain run-time string functions are overloaded in C++, to avoid
// inadvertent stripping of the const attribute.
//
// The functions of interest here include: wcschr and wcsrchr.
//
// There are three flavors of these functions:
//
// Flavor  Returns    Parameter
//
// 1       PWSTR      PCWSTR
// 2       PCWSTR     PCWSTR
// 3       PWSTR      PWSTR
//
// string.h declares flavor 1 whether for C or C++.  This is the non-ANSI,
// backward compatible mode.
//
// wchar.h declares flavor 1 if C, or flavors 2 and 3 if C++.  This is the
// ANSI method.
//
// Our corresponding functions need to match what was declared.  The way
// we can tell is by looking at _WConst_return... if it is defined then
// we want to match the prototypes in wchar.h, otherwise we'll match
// the prototypes in string.h.
//

#if defined(_WConst_return) 
typedef _WConst_return WCHAR UNALIGNED *PUWSTR_C;
#else
typedef WCHAR UNALIGNED *PUWSTR_C;
#endif

//
// Here is flavor 1 or 2
//

__inline
PUWSTR_C
static
ua_wcschr(
    IN PCUWSTR String,
    IN WCHAR   Character
    )
{
    if (WSTR_ALIGNED(String)) {
        return wcschr((PCWSTR)String, Character);
    } else {
        return (PUWSTR_C)uaw_wcschr(String, Character);
    }
}

__inline
PUWSTR_C
static
ua_wcsrchr(
    IN PCUWSTR String,
    IN WCHAR   Character
    )
{
    if (WSTR_ALIGNED(String)) {
        return wcsrchr((PCWSTR)String, Character);
    } else {
        return (PUWSTR_C)uaw_wcsrchr(String, Character);
    }
}

#if defined(__cplusplus) && defined(_WConst_Return)

//
// Here is flavor 3
//

__inline
PUWSTR
static
ua_wcschr(
    IN PUWSTR String,
    IN WCHAR  Character
    )
{
    if (WSTR_ALIGNED(String)) {
        return wcschr(String, Character);
    } else {
        return uaw_wcschr((PCUWSTR)String, Character);
    }
}

__inline
PUWSTR
static
ua_wcsrchr(
    IN PUWSTR String,
    IN WCHAR  Character
    )
{
    if (WSTR_ALIGNED(String)) {
        return wcsrchr(String, Character);
    } else {
        return uaw_wcsrchr((PCUWSTR)String, Character);
    }
}

#endif  // __cplusplus && _WConst_Return

__inline
PUWSTR
static
ua_wcscpy(
    IN PUWSTR  Destination,
    IN PCUWSTR Source
    )
{
    if (WSTR_ALIGNED(Source) && WSTR_ALIGNED(Destination)) {
        return wcscpy( (PWSTR)Destination, (PCWSTR)Source );
    } else {
        return uaw_wcscpy( Destination, Source );
    }
}

__inline
size_t
static
ua_wcslen(
    IN PCUWSTR String
    )
{
    if (WSTR_ALIGNED(String)) {
        return wcslen( (PCWSTR)String );
    } else {
        return uaw_wcslen( String );
    }
}

#endif  // _WSTRING_DEFINED

#endif  // _X86_

//++
//
// VOID
// WSTR_ALIGNED_STACK_COPY (
//    OUT PCWSTR *TargetString,
//    IN  PCUWSTR SourceString OPTIONAL
//    )
//
// VOID
// TSTR_ALIGNED_STACK_COPY (
//    OUT PCTSTR *TargetString,
//    IN  PCUTSTR SourceString OPTIONAL
//    )
//
// Routine Description:
//
//    These macros set TargetString to an aligned pointer to the string
//    represented by SourceString.  If necessary, an aligned copy of
//    SourceString is copied onto the stack.
//
// Arguments:
//
//    TargetString - Supplies a pointer to a pointer to the resultant
//                   string.  This may be the same as SourceString if
//                   that argument is aligned.
//
//    SourceString - Supplies a pointer to the possibly unaligned UNICODE
//                   string.
//
// Return Value:
//
//    None.
//
// Note:
//
//    These macros may allocate memory on the stack via the CRT function
//    _alloca().  This memory is "freed" when the calling function exits.
//    As a result, do not use these macros inside of a loop that may execute
//    a large number of times - instead, use a wrapper function, or use
//    an explicit buffer like this:
//
//    TCHAR AlignedStringBuffer[ MAX_FOOSTR_CHARS ];
//    PTSTR AlignedString;
//
//    while (a < b) {
//        ...
//        if (TSTR_ALIGNED(s) {
//            AlignedString = s;
//        } else {
//            AlignedString = (PTSTR)ua_tcscpy(AlignedStringBuffer,s);
//        }
//        SomeSystemFunction(AlignedString);
//        ...
//    }
//        
//        
//--

//
// __UA_WSTRSIZE returns the number of bytes required to store the
// supplied null-terminated UNICODE string.
//        
// __UA_LOCALCOPY accepts a pointer to unaligned data and a size.  It
// allocates an aligned buffer on the stack and copies the data into
// it, returning a pointer to the buffer.
//

#if !defined(__UA_WCSLEN)
#define __UA_WCSLEN ua_wcslen
#endif

#define __UA_WSTRSIZE(s)    ((__UA_WCSLEN(s)+1)*sizeof(WCHAR))
#define __UA_STACKCOPY(p,s) memcpy(_alloca(s),p,s)

//
// Note that NULL is aligned.
//

#if defined(_X86_)

#define WSTR_ALIGNED_STACK_COPY(d,s) (*(d) = (PCWSTR)(s))

#else

//
// Use of an inline function here is not possible, as the results of
// the _alloca() will not be preserved upon return from the function.
//

#define WSTR_ALIGNED_STACK_COPY(d,s)                                \
    {                                                               \
        PCUWSTR __ua_src;                                           \
        ULONG   __ua_size;                                          \
        PWSTR  __ua_dst;                                            \
                                                                    \
        __ua_src = (s);                                             \
        if (WSTR_ALIGNED(__ua_src)) {                               \
            __ua_dst = (PWSTR)__ua_src;                             \
        } else {                                                    \
            __ua_size = __UA_WSTRSIZE(__ua_src);                    \
            __ua_dst = (PWSTR)_alloca(__ua_size);                   \
            memcpy(__ua_dst,__ua_src,__ua_size);                    \
        }                                                           \
        *(d) = (PCWSTR)__ua_dst;                                    \
    }

#endif

#define ASTR_ALIGNED_STACK_COPY(d,s) (*(d) = (PCSTR)(s))

//++
//
// <type> CONST *
// STRUC_ALIGNED_STACK_COPY (
//     IN <type name>,
//     IN PVOID Struc OPTIONAL
//     )
// 
// Routine Description:
//
//    This macro returns an aligned pointer to Struc, creating a local
//    copy on the stack if necessary.
//
//    This should be used only for relatively small structures, and efforts
//    should be made to align the structure properly in the first place.  Use
//    this macro only as a last resort.
//
// Arguments:
//
//    <type> - The type specifier of Struc
//
//    Struc - Supplies a pointer to the structure in question.
//
// Return Value:
//
//    Returns a const pointer to Struc if it is properly aligned, or a pointer 
//    to a stack-allocated copy of Struc if it is not.
//
//--

#if !defined(_X86_)

#define __UA_STRUC_ALIGNED(t,s) \
    (((DWORD_PTR)(s) & (TYPE_ALIGNMENT(t)-1)) == 0)

#define STRUC_ALIGNED_STACK_COPY(t,s) \
    __UA_STRUC_ALIGNED(t,s) ?   \
        ((t const *)(s)) :      \
        ((t const *)__UA_STACKCOPY((s),sizeof(t)))

#else

#define STRUC_ALIGNED_STACK_COPY(t,s) ((CONST t *)(s))

#endif

#if defined(UNICODE)

#define TSTR_ALIGNED_STACK_COPY(d,s)    WSTR_ALIGNED_STACK_COPY(d,s)
#define TSTR_ALIGNED(x)                 WSTR_ALIGNED(x)
#define ua_CharUpper                    ua_CharUpperW
#define ua_lstrcmp                      ua_lstrcmpW
#define ua_lstrcmpi                     ua_lstrcmpiW
#define ua_lstrlen                      ua_lstrlenW
#define ua_tcscpy                       ua_wcscpy

#else

#define TSTR_ALIGNED_STACK_COPY(d,s)    ASTR_ALIGNED_STACK_COPY(d,s)
#define TSTR_ALIGNED(x)                 TRUE
#define ua_CharUpper                    CharUpperA
#define ua_lstrcmp                      lstrcmpA
#define ua_lstrcmpi                     lstrcmpiA
#define ua_lstrlen                      lstrlenA
#define ua_tcscpy                       strcpy

#endif  // UNICODE

#ifdef __cplusplus
}
#endif


#endif  // __STRALIGN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\tnef.h ===
/*
 *	T N E F . H
 *
 *
 *	This file contains structure and function definitions for the
 *	MAPI implementation of the Transport Neutral Encapsilation Format
 *	used by MAPI providers for the neutral serialization of a MAPI
 *	message.  This implementation sits on top of the IStream object as
 *	documented in the OLE 2 Specs.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef TNEF_H
#define TNEF_H

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/* ------------------------------------ */
/* TNEF Problem and TNEF Problem Arrays */
/* ------------------------------------ */

typedef struct _STnefProblem
{
	ULONG	ulComponent;
	ULONG	ulAttribute;
	ULONG	ulPropTag;
	SCODE	scode;
} STnefProblem;

typedef struct _STnefProblemArray
{
	ULONG			cProblem;
	STnefProblem	aProblem[MAPI_DIM];
} STnefProblemArray, FAR * LPSTnefProblemArray;

#define CbNewSTnefProblemArray(_cprob) \
	(offsetof(STnefProblemArray,aProblem) + (_cprob)*sizeof(STnefProblem))
#define CbSTnefProblemArray(_lparray) \
	(offsetof(STnefProblemArray,aProblem) + \
	(UINT) ((_lparray)->cProblem*sizeof(STnefProblem)))

/* Pointers to TNEF Interface ---------------------------------------- */

DECLARE_MAPI_INTERFACE_PTR(ITnef, LPITNEF);

/*	OpenTNEFStream */

#define	TNEF_DECODE					((ULONG) 0)
#define TNEF_ENCODE					((ULONG) 2)

#define TNEF_PURE					((ULONG) 0x00010000)
#define TNEF_COMPATIBILITY			((ULONG) 0x00020000)
#define TNEF_BEST_DATA				((ULONG) 0x00040000)
#define TNEF_COMPONENT_ENCODING		((ULONG) 0x80000000)

/*	AddProps, ExtractProps */

#define TNEF_PROP_INCLUDE			((ULONG) 0x00000001)
#define TNEF_PROP_EXCLUDE			((ULONG) 0x00000002)
#define	TNEF_PROP_CONTAINED			((ULONG) 0x00000004)
#define	TNEF_PROP_MESSAGE_ONLY		((ULONG) 0x00000008)
#define TNEF_PROP_ATTACHMENTS_ONLY	((ULONG) 0x00000010)
#define	TNEF_PROP_CONTAINED_TNEF	((ULONG) 0x00000040)

/*	FinishComponent */

#define TNEF_COMPONENT_MESSAGE		((ULONG) 0x00001000)
#define TNEF_COMPONENT_ATTACHMENT	((ULONG) 0x00002000)

#define MAPI_ITNEF_METHODS(IPURE)										\
	MAPIMETHOD(AddProps)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						ulElemID,					\
				LPVOID						lpvData,					\
				LPSPropTagArray				lpPropList) IPURE;			\
	MAPIMETHOD(ExtractProps)											\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray				lpPropList,					\
				LPSTnefProblemArray FAR *	lpProblems) IPURE;			\
	MAPIMETHOD(Finish)													\
		(THIS_	ULONG						ulFlags,					\
				WORD FAR *					lpKey,						\
				LPSTnefProblemArray FAR *	lpProblems) IPURE;			\
	MAPIMETHOD(OpenTaggedBody)											\
		(THIS_	LPMESSAGE					lpMessage,					\
				ULONG						ulFlags,					\
				LPSTREAM FAR *				lppStream) IPURE;			\
	MAPIMETHOD(SetProps)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						ulElemID,					\
				ULONG						cValues,					\
				LPSPropValue				lpProps) IPURE;				\
	MAPIMETHOD(EncodeRecips)											\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE					lpRecipientTable) IPURE;	\
	MAPIMETHOD(FinishComponent)											\
		(THIS_	ULONG						ulFlags,					\
				ULONG						ulComponentID,				\
				LPSPropTagArray				lpCustomPropList,			\
				LPSPropValue				lpCustomProps,				\
				LPSPropTagArray				lpPropList,					\
				LPSTnefProblemArray FAR *	lpProblems) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  ITnef
DECLARE_MAPI_INTERFACE_(ITnef, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_ITNEF_METHODS(PURE)
};

STDMETHODIMP OpenTnefStream(
	LPVOID				lpvSupport,
	LPSTREAM			lpStream,
	LPTSTR				lpszStreamName,
	ULONG				ulFlags,
	LPMESSAGE			lpMessage,
	WORD				wKeyVal,
	LPITNEF FAR *		lppTNEF);

typedef HRESULT (STDMETHODCALLTYPE FAR * LPOPENTNEFSTREAM) (
	LPVOID				lpvSupport,
	LPSTREAM			lpStream,
	LPTSTR				lpszStreamName,
	ULONG				ulFlags,
	LPMESSAGE			lpMessage,
	WORD				wKeyVal,
	LPITNEF FAR *		lppTNEF);

STDMETHODIMP OpenTnefStreamEx(
	LPVOID				lpvSupport,
	LPSTREAM			lpStream,
	LPTSTR				lpszStreamName,
	ULONG				ulFlags,
	LPMESSAGE			lpMessage,
	WORD				wKeyVal,
	LPADRBOOK			lpAdressBook,
	LPITNEF FAR *		lppTNEF);

typedef HRESULT (STDMETHODCALLTYPE FAR * LPOPENTNEFSTREAMEX) (
	LPVOID				lpvSupport,
	LPSTREAM			lpStream,
	LPTSTR				lpszStreamName,
	ULONG				ulFlags,
	LPMESSAGE			lpMessage,
	WORD				wKeyVal,
	LPADRBOOK			lpAdressBook,
	LPITNEF FAR *		lppTNEF);

STDMETHODIMP GetTnefStreamCodepage (
	LPSTREAM			lpStream,
	ULONG FAR *			lpulCodepage,
	ULONG FAR *			lpulSubCodepage);

typedef HRESULT (STDMETHODCALLTYPE FAR * LPGETTNEFSTREAMCODEPAGE) (
	LPSTREAM			lpStream,
	ULONG FAR *			lpulCodepage,
	ULONG FAR *			lpulSubCodepage);

#define OPENTNEFSTREAM "OpenTnefStream"
#define OPENTNEFSTREAMEX "OpenTnefStreamEx"
#define GETTNEFSTREAMCODEPAGE "GetTnefStreamCodePage"

/* -------------------------- */
/* TNEF Signature and Version */
/* -------------------------- */

#define MAKE_TNEF_VERSION(_mj,_mn)	(((ULONG)(0x0000FFFF & _mj) << 16) | (ULONG)(0x0000FFFF & _mn))
#define TNEF_SIGNATURE	((ULONG) 0x223E9F78)
#define TNEF_VERSION	((ULONG) MAKE_TNEF_VERSION(1,0))


/* ------------------------------------------- */
/* TNEF Down-level Attachment Types/Structures */
/* ------------------------------------------- */

typedef WORD ATYP;
enum { atypNull, atypFile, atypOle, atypPicture, atypMax };

#define MAC_BINARY	((DWORD) 0x00000001)

#include <pshpack1.h>
typedef struct _renddata
{
	ATYP	atyp;
	ULONG	ulPosition;
	WORD	dxWidth;
	WORD	dyHeight;
	DWORD	dwFlags;

} RENDDATA, *PRENDDATA;
#include <poppack.h>


/* ----------------------------------- */
/* TNEF Down-level Date/Time Structure */
/* ----------------------------------- */

#include <pshpack1.h>
typedef struct _dtr
{
	WORD	wYear;
	WORD	wMonth;
	WORD	wDay;
	WORD	wHour;
	WORD	wMinute;
	WORD	wSecond;
	WORD	wDayOfWeek;

} DTR;
#include <poppack.h>


/* ----------------------------- */
/* TNEF Down-level Message Flags */
/* ----------------------------- */

#define fmsNull			((BYTE) 0x00)
#define fmsModified		((BYTE) 0x01)
#define fmsLocal		((BYTE) 0x02)
#define fmsSubmitted	((BYTE) 0x04)
#define fmsRead			((BYTE) 0x20)
#define fmsHasAttach	((BYTE) 0x80)


/* ----------------------------------------- */
/* TNEF Down-level Triple Address Structures */
/* ----------------------------------------- */

#define	trpidNull					((WORD) 0x0000)
#define	trpidUnresolved				((WORD) 0x0001)
#define	trpidResolvedNSID			((WORD) 0x0002)
#define	trpidResolvedAddress		((WORD) 0x0003)
#define	trpidOneOff					((WORD) 0x0004)
#define	trpidGroupNSID				((WORD) 0x0005)
#define	trpidOffline				((WORD) 0x0006)
#define	trpidIgnore					((WORD) 0x0007)
#define	trpidClassEntry				((WORD) 0x0008)
#define	trpidResolvedGroupAddress	((WORD) 0x0009)
typedef struct _trp
{
	WORD	trpid;
	WORD	cbgrtrp;
	WORD	cch;
	WORD	cbRgb;

} TRP, *PTRP, *PGRTRP, FAR * LPTRP;
#define CbOfTrp(_p)		(sizeof(TRP) + (_p)->cch + (_p)->cbRgb)
#define LpszOfTrp(_p)	((LPSTR)(((LPTRP) (_p)) + 1))
#define LpbOfTrp(_p)	(((LPBYTE)(((LPTRP)(_p)) + 1)) + (_p)->cch)
#define LptrpNext(_p)	((LPTRP)((LPBYTE)(_p) + CbOfTrp(_p)))

typedef DWORD XTYPE;
#define xtypeUnknown	((XTYPE) 0)
#define xtypeInternet	((XTYPE) 6)

#define cbDisplayName	41
#define cbEmailName		11
#define cbSeverName		12
typedef struct _ADDR_ALIAS
{
	char	rgchName[cbDisplayName];
	char	rgchEName[cbEmailName];
	char	rgchSrvr[cbSeverName];
	ULONG	dibDetail;
	WORD	type;

} ADDRALIAS, FAR * LPADDRALIAS;
#define cbALIAS sizeof(ALIAS)

#define cbTYPE				16
#define cbMaxIdData			200
typedef struct _NSID
{
	DWORD	dwSize;
	unsigned char	uchType[cbTYPE];
	XTYPE	xtype;
	LONG	lTime;

	union
	{
		ADDRALIAS	alias;
		char		rgchInterNet[1];

	} address;

} NSID, * LPNSID;
#define cbNSID sizeof(NSID)


/* -------------------------- */
/* TNEF Down-level Priorities */
/* -------------------------- */

#define prioLow		3
#define prioNorm	2
#define prioHigh	1


/* ------------------------------------- */
/* TNEF Down-level Attributes/Properties */
/* ------------------------------------- */

#define atpTriples		((WORD) 0x0000)
#define	atpString		((WORD) 0x0001)
#define	atpText			((WORD) 0x0002)
#define	atpDate			((WORD) 0x0003)
#define	atpShort		((WORD) 0x0004)
#define	atpLong			((WORD) 0x0005)
#define	atpByte			((WORD) 0x0006)
#define	atpWord			((WORD) 0x0007)
#define	atpDword		((WORD) 0x0008)
#define atpMax			((WORD) 0x0009)

#define LVL_MESSAGE		((BYTE) 0x01)
#define LVL_ATTACHMENT	((BYTE) 0x02)

#define ATT_ID(_att)				((WORD) ((_att) & 0x0000FFFF))
#define ATT_TYPE(_att)				((WORD) (((_att) >> 16) & 0x0000FFFF))
#define ATT(_atp, _id)				((((DWORD) (_atp)) << 16) | ((WORD) (_id)))

#define attNull						ATT( 0,				0x0000)
#define attFrom						ATT( atpTriples,	0x8000)	/* PR_ORIGINATOR_RETURN_ADDRESS */
#define attSubject					ATT( atpString,		0x8004) /* PR_SUBJECT */
#define attDateSent					ATT( atpDate,		0x8005) /* PR_CLIENT_SUBMIT_TIME */
#define attDateRecd					ATT( atpDate,		0x8006)	/* PR_MESSAGE_DELIVERY_TIME */
#define attMessageStatus			ATT( atpByte,		0x8007) /* PR_MESSAGE_FLAGS */
#define attMessageClass				ATT( atpWord,		0x8008) /* PR_MESSAGE_CLASS */
#define attMessageID				ATT( atpString,		0x8009) /* PR_MESSAGE_ID */
#define attParentID					ATT( atpString,		0x800A)	/* PR_PARENT_ID */
#define attConversationID			ATT( atpString,		0x800B) /* PR_CONVERSATION_ID */
#define attBody						ATT( atpText,		0x800C) /* PR_BODY */
#define attPriority					ATT( atpShort,		0x800D)	/* PR_IMPORTANCE */
#define attAttachData				ATT( atpByte,		0x800F)	/* PR_ATTACH_DATA_xxx */
#define attAttachTitle				ATT( atpString,		0x8010) /* PR_ATTACH_FILENAME */
#define attAttachMetaFile			ATT( atpByte,		0x8011)	/* PR_ATTACH_RENDERING */
#define attAttachCreateDate			ATT( atpDate,		0x8012) /* PR_CREATION_TIME */
#define attAttachModifyDate			ATT( atpDate,		0x8013) /* PR_LAST_MODIFICATION_TIME */
#define attDateModified				ATT( atpDate,		0x8020) /* PR_LAST_MODIFICATION_TIME */
#define attAttachTransportFilename	ATT( atpByte,		0x9001) /* PR_ATTACH_TRANSPORT_NAME */
#define attAttachRenddata			ATT( atpByte,		0x9002)
#define attMAPIProps				ATT( atpByte,		0x9003)
#define attRecipTable				ATT( atpByte,		0x9004) /* PR_MESSAGE_RECIPIENTS */
#define attAttachment				ATT( atpByte,		0x9005)
#define attTnefVersion				ATT( atpDword,		0x9006)
#define attOemCodepage				ATT( atpByte,		0x9007)
#define attOriginalMessageClass		ATT( atpWord,		0x0006) /* PR_ORIG_MESSAGE_CLASS */

#define attOwner					ATT( atpByte,		0x0000) /* PR_RCVD_REPRESENTING_xxx  or
														           PR_SENT_REPRESENTING_xxx */
#define attSentFor					ATT( atpByte,		0x0001) /* PR_SENT_REPRESENTING_xxx */
#define attDelegate					ATT( atpByte,		0x0002)	/* PR_RCVD_REPRESENTING_xxx */
#define attDateStart				ATT( atpDate,		0x0006) /* PR_DATE_START */
#define attDateEnd					ATT( atpDate,		0x0007) /* PR_DATE_END */
#define attAidOwner					ATT( atpLong,		0x0008) /* PR_OWNER_APPT_ID */
#define attRequestRes				ATT( atpShort,		0x0009) /* PR_RESPONSE_REQUESTED */

#ifdef __cplusplus
}
#endif

#endif	/*	defined TNEF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ssc.h ===
/*++
    INTEL CORPORATION PROPRIETARY INFORMATION

    This software is supplied under the terms of a license
    agreement or nondisclosure agreement with Intel Corporation
    and may not be copied or disclosed except in accordance with
    the terms of that agreement.

    Copyright (c) 1992-1999  Intel Corporation.

Module Name:

    ssc.h

Abstract:

    This module is used by the NT device drivers for doing Gambit
    Simulation System Calls (SSC).  It defines the SSC calls and
    the related data structures.

Author:

    Ayelet Edrey (aedrey) 1-Jun-1995

Environment:

    IA-64 NT running on Gambit

Revision History:

--*/


#ifndef _SSC_H
#define _SSC_H

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef WINNT
# ifdef CDECL
# undef CDECL
# endif
#define CDECL __cdecl
#else
#define CDECL
#endif

#define MAX_SSC_STRING     512

/* NOTE : all pointers are 64 bit addresses to physical memory */

/* Structures and Enums */
typedef unsigned int   SSC_HANDLE;
typedef int            SSC_BOOL;
typedef void           *LARGE_POINTER;
typedef unsigned short GB_U16;
typedef unsigned long  GB_U32;
typedef unsigned int   U32;
typedef LONGLONG       LARGE_RET_VAL;


/* Disk */
#define SSC_ACCESS_READ   0x1  /* for OpenVolume */
#define SSC_ACCESS_WRITE  0x2  /* for OpenVolume */

#define SSC_MAX_VOLUMES       128
#define SSC_MAX_VOLUME_NAME   512
#define SSC_IO_BLOCK_SIZE     512

#define SSC_INVALID_HANDLE  SSC_MAX_VOLUMES

/* Disk Request */
typedef struct _SSC_DISK_REQUEST {
    LARGE_POINTER    DiskBufferAddress;
    GB_U32            DiskByteCount;
    GB_U32            PaddingWord;
} *PSSC_DISK_REQUEST, SSC_DISK_REQUEST;

/* Disk Completion */
typedef struct _SSC_DISK_COMPLETION {
    SSC_HANDLE VolumeHandle;
    GB_U32      XferBytes;
} *PSSC_DISK_COMPLETION, SSC_DISK_COMPLETION;

/* interrupt */
typedef enum {
    SSC_INTERRUPT_NONE=0,
    SSC_DISK_INTERRUPT,
    SSC_MOUSE_INTERRUPT,
    SSC_KEYBOARD_INTERRUPT,
    SSC_CLOCK_TIMER_INTERRUPT,
    SSC_PROFILE_TIMER_INTERRUPT,
    SSC_APC_INTERRUPT,
    SSC_DPC_INTERRUPT,
    SSC_SERIAL_INTERRUPT,
    SSC_PERFMON_INTERRUPT,
    SSC_INTERRUPT_LAST
} SSC_INTERRUPT;

/* timer */
typedef struct _SSC_TIME_FIELDS {
    GB_U32  Year;
    GB_U32  Month;
    GB_U32  Day;
    GB_U32  Hour;
    GB_U32  Minute;
    GB_U32  Second;
    GB_U32  Milliseconds;
    GB_U32  WeekDay;
} SSC_TIME_FIELDS, *PSSC_TIME_FIELDS;

/* TAL VM */
typedef struct _SSC_TAL_VM_INFO {
    LARGE_INTEGER     PageSize;
    LARGE_INTEGER     NumberOfDataTr;
    LARGE_INTEGER     NumberOfInstructionTr;
    LARGE_INTEGER     NumberOfDataTc;
    LARGE_INTEGER     NumberOfInstructionTc;
    LARGE_INTEGER     UnifiedTlb;
    LARGE_INTEGER     ProtectionKeySize;
    LARGE_INTEGER     RegionIdSize;
    LARGE_INTEGER     HardwareMissHandler;
    LARGE_INTEGER     NumberOfProtectionId;
    LARGE_INTEGER     VirtualAddressSize;
    LARGE_INTEGER     PhysicalAddressSize;
} SSC_TAL_VM_INFO,*PSSC_TAL_VM_INFO;

/* TAL CACHE SUMMARY */
typedef struct _SSC_TAL_CACHE_SUMMARY {
    LARGE_INTEGER     CacheLevel;
    LARGE_INTEGER     UniqueCache;
    LARGE_INTEGER     Snoop;
} SSC_TAL_CACHE_SUMMARY,*PSSC_TAL_CACHE_SUMMARY;

/* TAL CACHE INFO */
typedef struct _SSC_TAL_CACHE {
    LARGE_INTEGER     LineSize;
    LARGE_INTEGER     Stride;
    LARGE_INTEGER     AliasBoundary;
    LARGE_INTEGER     Hint;
    LARGE_INTEGER     MemoryAttribute;
    LARGE_INTEGER     CacheSize;
    LARGE_INTEGER     LoadPenalty;
    LARGE_INTEGER     StorePenalty;
    LARGE_INTEGER     Associativity;
    LARGE_INTEGER     Unified;
} SSC_TAL_CACHE;

typedef struct _SSC_TAL_CACHE_INFO {
    SSC_TAL_CACHE    DataLevel0;
    SSC_TAL_CACHE    DataLevel1;
    SSC_TAL_CACHE    DataLevel2;
    SSC_TAL_CACHE    InstLevel0;
    SSC_TAL_CACHE    InstLevel1;
    SSC_TAL_CACHE    InstLevel2;
} SSC_TAL_CACHE_INFO, *PSSC_CACHE_INFO;

typedef LARGE_INTEGER SSC_TAL_MEM_ATTRIB;
typedef LARGE_POINTER SSC_TAL_FIXED_ADDR;

/* TAL PROC ID */
typedef struct _SSC_TAL_PROC_ID {
    LARGE_INTEGER     ArchitectureRevision;
    LARGE_INTEGER     ProcessorModel;
    LARGE_INTEGER     ProcessorRevision;
    LARGE_INTEGER     Gr;
    char              Vendor[32];
    char              Name[32];
} SSC_TAL_PROC_ID, *PSSC_TAL_PROC_ID;

/* TAL DEBUG */
typedef struct _SSC_TAL_DEBUG_INFO {
    LARGE_INTEGER     IRegister;
    LARGE_INTEGER     DRegister;
} SSC_TAL_DEBUG_INFO, *PSSC_TAL_DEBUG_INFO;

/* Config TAL */
typedef struct _SSC_TAL {
    SSC_TAL_VM_INFO       VmInfo;
    SSC_TAL_CACHE_SUMMARY CacheSummary;
    SSC_TAL_CACHE_INFO    CacheInfo;
    SSC_TAL_MEM_ATTRIB    MemoryAttrib;
    SSC_TAL_FIXED_ADDR    FixedAddress;
    SSC_TAL_PROC_ID       ProcessorId;
    SSC_TAL_DEBUG_INFO    DebugInfo;
} SSC_TAL, *PSSC_TAL;

/* Config Mem */
typedef enum {
    SSC_MEM_TYPE_RAM = 0,
    SSC_MEM_TYPE_ROM,
    SSC_MEM_TYPE_IO
} SSC_MEM_TYPE, *PSSC_MEM_TYPE;

typedef struct _SSC_MEM {
    LARGE_POINTER     StartAddress;
    LARGE_INTEGER     Size;
    SSC_MEM_TYPE      Type;
    char              InitValue;
    char              PaddingByte1;
    char              PaddingByte2;
    char              PaddingByte3;
} SSC_MEM, *PSSC_MEM;

/* VGA size */
typedef enum {
    SSC_SCREEN_SIZE_NONE = 0,
    SSC_SCREEN_SIZE_800x600,
    SSC_SCREEN_SIZE_640x480,
    SSC_SCREEN_SIZE_25x80, /* text mode */
    SSC_SCREEN_SIZE_LAST
} SSC_SCREEN_SIZE;

/* Keyboard */
#define SSC_KBD_GET_SUCCESS      1
#define SSC_KBD_GET_NODATA       0
#define SSC_KBD_EXTENDED_KEY_VAL 0xE000
#define SSC_KBD_UP_KEY_VAL       0x80

typedef struct _SSC_KBD_LOCK {
    U32 KbdNumLock:1 ,           /* Num lock is ON */
        KbdCapsLock:1,           /* Caps lock is ON */
        KbdScrollLock:1,         /* Scroll lock is ON */
        KbdFillers:29;
} SSC_KBD_LOCK;

/* Mouse */
typedef U32 SSC_MOUSEBUTTONS;

/* SscMouseGetKeyEvent returns this structure. the prototype of the
   function returns int instead, for compilation reasons. */
typedef struct _SSC_MOUSEDATA {
    U32 MouseXLocation : 12,
        MouseYLocation : 12,
        MouseButtonLeft : 1,
        MouseButtonRight : 1,
        MouseButtonMiddle : 1,
        MouseValid :1,
        MouseFillers : 4;
} SSC_MOUSEDATA;


/* Kernel debug */

#define SSC_KD_SUCCESS 0
#define SSC_KD_ERROR  -1

typedef struct _SSC_DEBUG_PARAMETERS {
    U32 CommunicationPort;
    U32 BaudRate;
} SSC_DEBUG_PARAMETERS, *PSSC_DEBUG_PARAMETERS;

#define MAX_SSC_MEM 50
#define MAX_SSC_PARAMS 10

/* Network */

#define SSC_SERIAL_SUCCESS     1
#define SSC_SERIAL_FAILED      0
#define SSC_SERIAL_GET_SUCCESS 1   /* data was returned, there may be more data */
#define SSC_SERIAL_GET_NODATA  0
#define SSC_SERIAL_MAX_FIFO_SIZE 512

typedef struct _SSC_INTERRUPT_INFO {
    SSC_HANDLE    SerialHandle;
    GB_U32         CommEvent;
    GB_U32         ModemControl;
    GB_U32         ErrorFlags;
    U32           NumberOfChars;
} *PSSC_INTERRUPT_INFO, SSC_INTERRUPT_INFO;

/* CommEvent decodings */
#define SSC_EV_RXCHAR   0x0001  /* A character was received and placed
                                   in the input buffer */
#define SSC_EV_RXFLAG   0x0002  /* The event character was received and placed
                                   in the input buffer */
#define SSC_EV_TXEMPTY  0x0004  /* The last character in the output buffer
                                   was sent */
#define SSC_EV_CTS      0x0008  /* The CTS (clear-to-send) signal changed state */
#define SSC_EV_DSR      0x0010  /* The DSR (data-set-ready) signal changed */
#define SSC_EV_RLSD     0x0020  /* (receive-line-signal-detect) signal changed */
#define SSC_EV_BREAK    0x0040  /* A break was detected on input */
#define SSC_EV_ERR      0x0080  /* A line-status error occurred */
#define SSC_EV_RING     0x0100  /* A ring indicator was detected */

/* Modem control is one of the following */

#define  SSC_MS_CTS_ON  0x0010  /* The CTS (clear-to-send) signal is on. */
#define  SSC_MS_DSR_ON  0x0020  /* The DSR (data-set-ready) signal is on.*/
#define  SSC_MS_RING_ON 0x0040  /* The ring indicator signal is on. */
#define  SSC_MS_RLSD_ON 0x0080  /* The RLSD (receive-line-signal-detect) 
                                   signal is on. */
/* Error Codes */

#define  SSC_CE_RXOVER   0x0001  /* An input buffer overflow has occurred.
                                    There is either no room in the input buffer,
                                    or a character was received after the
                                    end-of-file (EOF) character. */
#define  SSC_CE_OVERRUN  0x0002  /* A character-buffer overrun has occurred.
                                    The next character is lost. */
#define  SSC_CE_RXPARITY 0x0004  /* The hardware detected a parity error */
#define  SSC_CE_FRAME    0x0008  /* The hardware detected a framing error. */
#define  SSC_CE_BREAK    0x0010  /* The hardware detected a break condition. */
#define  SSC_CE_TXFULL   0x0100  /* The application tried to transmit a character,
                                    but the output buffer was full. */
#define  SSC_CE_IOE      0x0400  /* An I/O error occurred during communications
                                    with the device. */
#define  SSC_CE_MODE     0x8000  /* The requested mode is not supported,
                                    or the hFile parameter is invalid. If
                                    this value is specified, it is the
                                    only valid error. */

/* Config */
typedef struct _SSC_CONFIG {
    SSC_TAL       Tal;
    SSC_MEM       Memory[MAX_SSC_MEM];
    LARGE_INTEGER Params[MAX_SSC_PARAMS];
} SSC_CONFIG, *PSSC_CONFIG;

typedef struct _SSC_IMAGE_INFO {
    LARGE_POINTER LoadBase;  /* base address for image load */
    GB_U32        ImageSize;
    GB_U32        ImageType;
    LARGE_INTEGER ProcessID;
    GB_U32        LoadCount;
} SSC_IMAGE_INFO, *PSSC_IMAGE_INFO;


/* define types in Unix like style */
typedef SSC_CONFIG            Ssc_config_t; 
typedef SSC_TAL_DEBUG_INFO    Ssc_tal_debug_info_t;
typedef SSC_TAL               Ssc_tal_t;
typedef SSC_MEM               Ssc_mem_t;
typedef SSC_MEM_TYPE          Ssc_mem_type_t;
typedef SSC_TAL_PROC_ID       Ssc_tal_proc_id_t;
typedef SSC_TAL_MEM_ATTRIB    Ssc_tal_mem_attrib_t;
typedef SSC_TAL_FIXED_ADDR    Ssc_tal_fixed_addr_t;
typedef SSC_TAL_CACHE         Ssc_tal_cache_t;
typedef SSC_TAL_CACHE_SUMMARY Ssc_tal_cache_summary_t;
typedef SSC_TAL_CACHE_INFO    Ssc_tal_cache_info_t;
typedef SSC_TAL_VM_INFO       Ssc_tal_vm_info_t;
typedef SSC_TIME_FIELDS       Ssc_time_fields_t;
typedef SSC_DISK_COMPLETION   Ssc_disk_completion_t;
typedef SSC_DISK_REQUEST      Ssc_disk_request_t;
typedef SSC_INTERRUPT         Ssc_interrupt_t;
typedef SSC_SCREEN_SIZE       Ssc_screen_size_t;
typedef SSC_KBD_LOCK          Ssc_kbd_lock_t;
typedef SSC_MOUSEBUTTONS      Ssc_mousebuttons_t;
typedef SSC_MOUSEDATA         Ssc_mousedata_t;
typedef SSC_DEBUG_PARAMETERS  Ssc_debug_parameters_t;
typedef SSC_INTERRUPT_INFO    Ssc_interrupt_info_t;
typedef SSC_IMAGE_INFO        Ssc_image_info_t;

/* performance SSC return values */
#define SSC_SUCCESS                    0
#define SSC_VIRTUAL_ADDRESS_NOT_FOUND  1
#define SSC_ILLEGAL_NAME               2
#define SSC_ILLEGAL_HANDLE             3
#define SSC_PERMISSION_DENIED          4
#define SSC_VIRTUAL_ADDRESS_NOT_LOCKED 5

#define GE_SSC_ERR_FIRST                   6
#define GE_SSC_ERR_BUFF_TOO_SHORT          6     /* supplied buffer is too short for value */
#define GE_SSC_ERR_INVALID_HNDL            7     /* invalid object handl supplied */
#define GE_SSC_ERR_INVALID_TOOL            8     /* GE internal error */
#define GE_SSC_ERR_INVALID_GE_STAGE        9     /* GE internal error */
#define GE_SSC_ERR_NO_INIT                 10    /* GE internal error */
#define GE_SSC_ERR_NOT_OWNER               11    /* object can not be set */
#define GE_SSC_ERR_NOT_ITEM                12    /* operation can be done only on an item object (not a family of objects) */
#define GE_SSC_ERR_OBJ_CLOSED              13    /* object is not available for use due  to configuration */
#define GE_SSC_ERR_OBJ_NOT_OPENED          14    /* object is not available for use */
#define GE_SSC_ERR_OBJ_NOT_AVAILABLE       15    /* object not required for use in this session */
#define GE_SSC_ERR_OBJ_NOT_ACTIVE          16    /* object should be active befor used for this operation */
#define GE_SSC_ERR_OBJ_UNDER_TREATMENT     17    /* object is in use at the moment */
#define GE_SSC_ERR_WRONG_CLASS             18    /* specified class is invalid for this operation */
#define GE_SSC_ERR_WRONG_SIZE              19    /* specified wrong size */
#define GE_SSC_ERR_NO_OWNER                20    /* object is not available for use */
#define GE_SSC_ERR_OWNER_FAILURE           21    /* owner failed to handle the operation */
#define GE_SSC_ERR_UNKNOWN                 22    /* unrecognized error number detected */
#define GE_SSC_ERR_LAST                    22


/* SSC Functions */

/* Disk */
SSC_HANDLE CDECL
SscDiskOpenVolume(
    LARGE_POINTER VolumeName,
    GB_U32 AccessMode
    );

SSC_BOOL CDECL
SscDiskCloseVolume(
    SSC_HANDLE VolumeHandle
    );

int CDECL
SscDiskReadVolume(
    SSC_HANDLE VolumeHandle,
    GB_U32 NReq,
    LARGE_POINTER RequestPtr,
    LARGE_INTEGER VolumeOffset
    );

int CDECL
SscDiskWriteVolume(
    SSC_HANDLE VolumeHandle,
    GB_U32 NReq,
    LARGE_POINTER RequestPtr,
    LARGE_INTEGER VolumeOffset
    );

SSC_BOOL CDECL
SscDiskGetCompletion(
    LARGE_POINTER DiskCompletionPtr
    );

SSC_BOOL CDECL
SscDiskWaitIoCompletion(
    LARGE_POINTER DiskCompletionPtr
    );


/* the file SSC_HANDLE in low word, error code in high word */
LARGE_RET_VAL CDECL
SscOpenHostFile (LARGE_POINTER HostPathNameAddress
    );

/* the file SSC_HANDLE in low word, error code in high word.
   Does not create a new file if a host file does not exist. */
LARGE_RET_VAL CDECL
SscOpenHostFileNoCreate (LARGE_POINTER HostPathNameAddress
    );

U32 CDECL
SscWriteHostFile(
     SSC_HANDLE SscFileHandle,
     LARGE_POINTER TransferBufferAddress,
     LARGE_POINTER TransferBufferSizeAddress
   );

U32 CDECL
SscReadHostFile(
    SSC_HANDLE SscFileHandle,
    LARGE_POINTER TransferBufferAddress,
    LARGE_POINTER TransferBufferSizeAddress
  );


void CDECL
SscCloseHostFile(SSC_HANDLE HostFileHandle
  );



/* Kernel debug */
U32 CDECL
SscKdInitialize(
    LARGE_POINTER DebugParameters,
    SSC_BOOL Initialize
    );

U32 CDECL
SscKdPortGetByte(
    LARGE_POINTER InputPtr
    );

void CDECL
SscKdPortPutByte(
    unsigned char Output
    );

/* Video */
void CDECL
SscDisplayString(
    LARGE_POINTER CharacterString
    );

U32 CDECL
SscVideoSetPalette (
    U32 iStart,
    U32 cEntries,
    LARGE_POINTER lppe
    );

/* Keyboard */
int CDECL
SscKbdSynchronizeState(
    SSC_KBD_LOCK KbdLock
    );

GB_U32 CDECL
SscKbdGetKeyCode(
    LARGE_POINTER KeyCodeAddress
    );

/* Mouse */
SSC_MOUSEBUTTONS CDECL
SscMouseGetButtons();

int CDECL
SscMouseGetKeyEvent();

/* Network */

SSC_HANDLE CDECL
SscSerialOpen(
    GB_U32 SerialPortID
    );

GB_U32 CDECL
SscSerialGetInterruptInfo(
    LARGE_POINTER SerialInterruptInfoPtr,
    LARGE_POINTER SerialMessegePtr
    );

GB_U32 CDECL
SscSerialWriteChar(
    SSC_HANDLE    SerialHandle,
    LARGE_POINTER SerialCharPtr,
    GB_U32         NumChars
    );

GB_U32 CDECL
SscSerialClose(
    SSC_HANDLE SerialHandle
    );


/* Debug */
void CDECL
SscDbgPrintf(
    LARGE_POINTER CharacterString
    );

/* Interrupt */
void CDECL
SscConnectInterrupt(
    SSC_INTERRUPT InterruptSource,
    GB_U32 Vector
    );

void CDECL
SscGenerateInterrupt(
    SSC_INTERRUPT InterruptSource
    );

void CDECL
SscSetPeriodicInterruptInterval(
    GB_U32 InterruptSource,
    GB_U32 IntervalInNanoSeconds
    );

/* TAL */
void CDECL
SscTalInitTC();

void CDECL
SscTalHalt();

void CDECL
SscGetConfig(
    LARGE_POINTER ConfigInfoPtr
    );

/* Video */
void CDECL
SscVideoSetMode( 
    SSC_SCREEN_SIZE ScreenSize
    ); 

/* Performance */

void CDECL
SscCreateProcess(
    U32 ProcessID,
    U32 EProcess
    );

void CDECL
SscCreateProcess64(
    LARGE_INTEGER ProcessID,
    LARGE_POINTER EProcess
    );

void CDECL
SscCreateThread(
    U32 ProcessID,
    U32 ThreadID,
    U32 EThread
    );

void CDECL
SscCreateThread64(
    LARGE_INTEGER ProcessID,
    LARGE_INTEGER ThreadID,
    LARGE_POINTER EThread
    );

void CDECL
SscSwitchProcess64(
    LARGE_INTEGER NewProcessID,
    LARGE_POINTER NewEProcess
    );
void CDECL
SscSwitchThread(
    U32 NewThreadID,
    U32 NewEThread
    );

void CDECL
SscSwitchThread64(
    LARGE_INTEGER NewThreadID,
    LARGE_POINTER NewEThread
    );

void CDECL
SscDeleteProcess(
    U32 ProcessID
    );

void CDECL
SscDeleteProcess64(
    LARGE_INTEGER ProcessID
    );

void CDECL
SscDeleteThread(
    U32 ThreadID
    );

void CDECL
SscDeleteThread64(
    LARGE_INTEGER ThreadID
    );

/* image loading/unloading functions */
void
SscLoadImage(LARGE_POINTER FullPathName,
             U32 LoadBase,
             U32 ImageSize,
             U32 ImageType,
             U32 ProcessID,
             U32 LoadCount);

void
SscUnloadImage(U32 LoadBase,
               U32 ProcessID,
               U32 LoadCount);


GB_U32 CDECL
SscLoadImage64(
    LARGE_POINTER FullPathNamePhysicalAddress,
    LARGE_POINTER ImageInfoPhysicalAddress
    );

GB_U32 CDECL
SscUnloadImage64(
    LARGE_POINTER FullPathNamePhysicalAddress,
    LARGE_POINTER ImageInfoPhysicalAddress
    );


/* Performance Counter handoff call */

GB_U32 CDECL
SscPerfCounterAddress(
    LARGE_POINTER CounterNamePhysicalAddress,
    LARGE_POINTER CounterPhysicalAddress
    );


/* Trace Generation Control */

GB_U32 CDECL
SscPerfForm(
    U32 SwitchMode,
    LARGE_POINTER FormNamePhysicalAddress
    );


/* Generating and dispatching a send event.
   i.e. an application can put something in the trace pipe */

LARGE_RET_VAL CDECL
SscPerfEventHandle(
    LARGE_POINTER EventNamePhysicalAddress
    );

LARGE_RET_VAL CDECL
SscPerfHandleApp(
    LARGE_POINTER EventNameAddress
    );

GB_U32 CDECL
SscPerfFormActivate(
    LARGE_POINTER FormName
    );

GB_U32 CDECL
SscPerfFormDeActivate(
    LARGE_POINTER FormName
    );

GB_U32 CDECL
SscPerfSendEvent(
    U32 Handle
    );

/* Simulated code access to data items in the Gambit Environment */

LARGE_RET_VAL CDECL
SscPerfCounterHandle(
    LARGE_POINTER DataItemNamePhysicalAddress
    );

GB_U32 CDECL
SscPerfSetCounter32(
    U32 Handle,
    U32 Value
    );

GB_U32 CDECL
SscPerfGetNotifier32(
    U32 Handle
    );

GB_U32 CDECL
SscPerfSetNotifier32(
    U32 Handle,
    U32 Value
    );

GB_U32 CDECL
SscPerfSetCounter64(
    U32 Handle,
    LARGE_INTEGER Value
    );

GB_U32 CDECL
SscPerfSetCounterStr(
    U32 Handle,
    LARGE_POINTER StringValuePhysicalAddress
    );

LARGE_RET_VAL CDECL
SscPerfGetCounter32(
    U32 Handle
    );

LARGE_RET_VAL CDECL
SscPerfGetCounter64(
    U32 Handle
    );

/* Misc. */
void CDECL
SscTraceUserInfo(
    GB_U32 Mark
    );

void CDECL
SscMakeBeep(
    GB_U32 Frequency
    );

void CDECL
SscQueryRealTimeClock(
    LARGE_POINTER TimeFieldsPtr
    );

void CDECL
SscExit(
    int ExitCode
    );

/* KDI */

#ifdef SSC_KDI
/* GENERAL KDI INTERFACE to CALL any function in kernel */
typedef struct kdi_jmptable {
    int    KdiMagic;                  /* Some known magic value    */
    int    KdiVersion;                /* Some version value        */
    LARGE_INTEGER   *KdiActive;       /* for internal OS use       */
    LARGE_INTEGER   *KeiEnabled;      /* kdi can be used now       */
    LARGE_POINTER   *KdiBuffer;       /* pointer to buffer area of */
                                      /* size 4096 bytes           */
    LARGE_POINTER  (*KdiCallFunc)();  /* function to call func     */
    LARGE_POINTER   *KdiReserved[3];  /* reserved area             */

/* FUNCTIONS EXPORTED VIA KDI */

    LARGE_POINTER    (*KdiMemoryRead)();    /* function for mem read       */
    LARGE_POINTER    (*KdiMemoryWrite)();   /* function for mem write      */
    LARGE_POINTER    (*KdiCopy)();          /* function for mem read/write */
    LARGE_POINTER    (*KdiBootInfo)();      /* function to provide call back
                                               info                        */
    LARGE_POINTER    (*KdiVirtualToPhysical)();    /* virtual -> physical  */
    LARGE_POINTER    (*KdiPhysicalToVirtual)();    /* physical -> virtual  */
    LARGE_POINTER    (*KdiMapUser)();       /* function to map user        */
    LARGE_POINTER    (*KdiUnmapUser)();     /* function to unmap user      */
    LARGE_POINTER    (*KdiFiller[25])();    /* fillers                     */
} kdi_jmptable_t;

/* trap to the debugger with value to indicate an internal reason 
   the value is passed to gb_t.opt.info.kdi */
int CDECL
SscTrap(
    int Value
    );

typedef enum {
    SSC_KDI_STATUS_OK = 0,         /* KDI or KDI call is OK       */
    SSC_KDI_STATUS_DISABLED,       /* KDI not available right now */
    SSC_KDI_STATUS_BUSY,           /* KDI already in use          */
    SSC_KDI_STATUS_FAILED          /* KDI call failed             */
} SSC_kdi_status_t;

/* return from a previous call of gambit to the kernel k_callf function 
   return the return value of the function in ret_val and a status in 
   status */
int CDECL
SscReturn(
    int ReturnValue,
    Ssc_kdi_status_t Status
    );

#endif SSC_KDI

/* Statistics */

/* Instruction Counter Functions */


U32 CDECL
SscIcountGet(
    void
    );

/* Instruction Mix Collection */
typedef enum {
    SSC_COLLECT_START,
    SSC_COLLECT_STOP
} SSC_imix_index_t;

void CDECL
SscInstrMixCollect(
    SSC_imix_index_t Index
    );


typedef enum {
    Enable=0,
    Disable=1
} Ssc_event_enable_t;

/* CPROF requests */
typedef enum {
    SSC_CPROF_NONE = 0,
    SSC_CPROF_ON,
    SSC_CPROF_OFF,
    SSC_CPROF_RESET,
    SSC_CPROF_CLEAR,
    SSC_CPROF_PRINT
} SSC_cprof_request;

/* GEMSTONE requests */
typedef enum {
    SSC_GEMSTONE_NONE = 0,
    SSC_GEMSTONE_START,
    SSC_GEMSTONE_ON,
    SSC_GEMSTONE_OFF
} SSC_gemstone_request;

/* MP specific */

/* Set OS_RENDEZ address */
void CDECL
SscSetOSRendez(
    LARGE_POINTER OsRendezEntryPoint
    );

/* MP interrupt association */
void CDECL
SscConnectInterruptEx(
    SSC_INTERRUPT InterruptSource,
    GB_U32 Vector,
    GB_U16 LocalID
    );

/* Get number of CPUs in the MP system */
GB_U32 CDECL
SscGetNumberOfCPUs(
    void
    );

/* Get LIDs of CPUs in the MP system */
void CDECL
SscGetLIDs(
    LARGE_POINTER LIDs0,
    LARGE_POINTER LIDs1,
    LARGE_POINTER LIDs2,
    LARGE_POINTER LIDs3
    );

void CDECL
SscPlatformAssociateInterrupt(
        LARGE_POINTER VirtualAddr, 
        GB_U32 Device,
        GB_U32 Vector);

void CDECL
SscPlatformMemSync(
        LARGE_POINTER PhysicalAddress, /* Physical address of the block */
        GB_U32 Size,                   /* size of the block             */
        GB_U32 Operation);             /* 0 = Read, 1 = Write           */

void CDECL
SscDevMemSync(
        LARGE_POINTER PhysicalPageAddress /* Physical address of the page written by device */
        );

#endif /* _SSC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\tvout.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

*/

#ifndef __TVOUT__
#define __TVOUT__

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif

typedef struct _VIDEOPARAMETERS {
    GUID  Guid;                         // GUID for this structure
    ULONG dwOffset;                     // leave it 0 for now.
    ULONG dwCommand;                    // VP_COMMAND_*            SET or GET
    ULONG dwFlags;                      // bitfield, defined below SET or GET
    ULONG dwMode;                       // bitfield, defined below SET or GET
    ULONG dwTVStandard;                 // bitfield, defined below SET or GET
    ULONG dwAvailableModes;             // bitfield, defined below GET
    ULONG dwAvailableTVStandard;        // bitfield, defined below GET
    ULONG dwFlickerFilter;              // value                   SET or GET
    ULONG dwOverScanX;                  // value                   SET or GET
    ULONG dwOverScanY;                  //                         SET or GET
    ULONG dwMaxUnscaledX;               // value                   SET or GET
    ULONG dwMaxUnscaledY;               //                         SET or GET
    ULONG dwPositionX;                  // value                   SET or GET
    ULONG dwPositionY;                  //                         SET or GET
    ULONG dwBrightness;                 // value                   SET or GET
    ULONG dwContrast;                   // value                   SET or GET
    ULONG dwCPType;                     // copy protection type    SET or GET
    ULONG dwCPCommand;                  // VP_CP_CMD_
    ULONG dwCPStandard;                 // what TV standards CP is available on. GET
    ULONG dwCPKey;
    ULONG bCP_APSTriggerBits;           // (a dword for alignment) SET(bits 0 and 1 valid).
    UCHAR bOEMCopyProtection[256];      // oem specific copy protection data SET or GET
} VIDEOPARAMETERS, *PVIDEOPARAMETERS, *LPVIDEOPARAMETERS;

#define VP_COMMAND_GET          0x0001  // size set, return caps.
                                        // returned Flags = 0 if not supported.
#define VP_COMMAND_SET          0x0002  // size and params set.

#define VP_FLAGS_TV_MODE        0x0001
#define VP_FLAGS_TV_STANDARD    0x0002
#define VP_FLAGS_FLICKER        0x0004
#define VP_FLAGS_OVERSCAN       0x0008
#define VP_FLAGS_MAX_UNSCALED   0x0010  // do not use on SET
#define VP_FLAGS_POSITION       0x0020
#define VP_FLAGS_BRIGHTNESS     0x0040
#define VP_FLAGS_CONTRAST       0x0080
#define VP_FLAGS_COPYPROTECT    0x0100

#define VP_MODE_WIN_GRAPHICS    0x0001
#define VP_MODE_TV_PLAYBACK     0x0002  // optimize for TV video playback

#define VP_TV_STANDARD_NTSC_M   0x0001  //        75 IRE Setup
#define VP_TV_STANDARD_NTSC_M_J 0x0002  // Japan,  0 IRE Setup
#define VP_TV_STANDARD_PAL_B    0x0004
#define VP_TV_STANDARD_PAL_D    0x0008
#define VP_TV_STANDARD_PAL_H    0x0010
#define VP_TV_STANDARD_PAL_I    0x0020
#define VP_TV_STANDARD_PAL_M    0x0040
#define VP_TV_STANDARD_PAL_N    0x0080
#define VP_TV_STANDARD_SECAM_B  0x0100
#define VP_TV_STANDARD_SECAM_D  0x0200
#define VP_TV_STANDARD_SECAM_G  0x0400
#define VP_TV_STANDARD_SECAM_H  0x0800
#define VP_TV_STANDARD_SECAM_K  0x1000
#define VP_TV_STANDARD_SECAM_K1 0x2000
#define VP_TV_STANDARD_SECAM_L  0x4000
#define VP_TV_STANDARD_WIN_VGA  0x8000
// and the rest
#define VP_TV_STANDARD_NTSC_433 0x00010000
#define VP_TV_STANDARD_PAL_G    0x00020000
#define VP_TV_STANDARD_PAL_60   0x00040000
#define VP_TV_STANDARD_SECAM_L1 0x00080000

#define VP_CP_TYPE_APS_TRIGGER  0x0001  // DVD trigger bits only
#define VP_CP_TYPE_MACROVISION  0x0002  // full macrovision data available

#define VP_CP_CMD_ACTIVATE      0x0001  // CP command type
#define VP_CP_CMD_DEACTIVATE    0x0002
#define VP_CP_CMD_CHANGE        0x0004

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\stm.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    stm.h

Abstract:

    This module contains the definitions of the IPX Service Table Manger APIs

Author:


Revision History:


--*/

#ifndef __ROUTING_STM_H__
#define __ROUTING_STM_H__

#if _MSC_VER > 1000
#pragma once
#endif

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Supported functionality flags                                            //
//                                                                          //
// ROUTING                  Imports Routing Table Manager APIs              //
// SERVICES                 Exports Service Table Manager APIs              //
// DEMAND_UPDATE_ROUTES     IP and IPX RIP support for Autostatic           //
// DEMAND_UPDATE_SERVICES   IPX SAP, NLSP support for Autostatic            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define SERVICES                0x00000002
#define DEMAND_UPDATE_SERVICES  0x00000008

//
// Server Entry
//

typedef struct _IPX_SERVER_ENTRY
{
    USHORT	Type;
    UCHAR	Name[48];
    UCHAR	Network[4];
    UCHAR	Node[6];
    UCHAR	Socket[2];
    USHORT	HopCount;
} IPX_SERVER_ENTRY, *PIPX_SERVER_ENTRY;

typedef struct _IPX_SERVICE
{
    ULONG		        InterfaceIndex;
    ULONG	            Protocol;	// protocol from which knowledge of the service was obatined
    IPX_SERVER_ENTRY	Server;
} IPX_SERVICE, *PIPX_SERVICE;

// Function which returns TRUE if the service exists

typedef
BOOL
(WINAPI * PIS_SERVICE)(
      IN USHORT 	Type,
      IN PUCHAR 	Name,
      OUT PIPX_SERVICE	Service OPTIONAL
      );

// Exclusion flags.  Limit enumeration to only servers that
// have same values of the specified by flags parameter(s) as those of
// criterea service.

#define STM_ONLY_THIS_INTERFACE     0x00000001
#define STM_ONLY_THIS_PROTOCOL	    0x00000002
#define STM_ONLY_THIS_TYPE	        0x00000004
#define STM_ONLY_THIS_NAME	        0x00000008

// Ordering methods. Specify the order in which services should be
// retreived (methods are mutually exclusive).

#define STM_ORDER_BY_TYPE_AND_NAME		    0
#define STM_ORDER_BY_INTERFACE_TYPE_NAME	1


// Create handle to start enumeration of the services in the STM table.
// Returns handle to be used for enumerations or NULL if operation failed
//	GetLastError () returns the follwing error codes in case of failure:
//		ERROR_CAN_NOT_COMPLETE
//		ERROR_NOT_ENOUGH_MEMORY

typedef
HANDLE
(WINAPI * PCREATE_SERVICE_ENUMERATION_HANDLE)(
    IN  DWORD           ExclusionFlags, // Flags to limit enumeration to certain
                                        // types of servers
    IN	PIPX_SERVICE  CriteriaService	// Criteria for exclusion flags
    );

// Get next service in the enumeration started by CreateServiceEnumerationHandle
// Returns NO_ERROR if next service was placed in provided buffer or
// ERROR_NO_MORE_ITEMS when there are no more services to be
// returned in the enumeration; ERROR_CAN_NOT_COMPLETE will be
// returned if operation failed.

typedef
DWORD
(WINAPI * PENUMERATE_GET_NEXT_SERVICE)(
    IN  HANDLE          EnumerationHandle, // Handle that identifies this
                                           // enumeration
    OUT PIPX_SERVICE  Service		    // buffer to place parameters of next service entry
										// to be returned by enumeration
    );

// Frees resources associated with enumeration.
// Returns NO_ERROR if operation succeded, ERROR_CAN_NOT_COMPLETE
// otherwise

typedef
DWORD
(WINAPI * PCLOSE_SERVICE_ENUMERATION_HANDLE)(
    IN	HANDLE	       EnumerationHandle
    );

// Get total number of known services

typedef
ULONG
(WINAPI * PGET_SERVICE_COUNT)(
	VOID
	);

//	Add service of IPX_PROTOCOL_STATIC to the table

typedef
DWORD
(WINAPI * PCREATE_STATIC_SERVICE)(IN ULONG		InterfaceIndex,
		       IN PIPX_SERVER_ENTRY		ServerEntry);

//	Delete service of IPX_PROTOCOL_STATIC from the table

typedef
DWORD
(WINAPI * PDELETE_STATIC_SERVICE)(IN ULONG		InterfaceIndex,
		       IN PIPX_SERVER_ENTRY		ServerEntry);


//	Converts protocol of all services associated with given interface to
//	IPX_PROTOCOL_STATIC

typedef
DWORD
(WINAPI * PBLOCK_CONVERT_SERVICES_TO_STATIC) (
	IN ULONG		InterfaceIndex
	);

//	Delete all services of IPX_PROTOCOL_STATIC
//	associated with  given interface from the table

typedef
DWORD
(WINAPI * PBLOCK_DELETE_STATIC_SERVICES)(
	IN ULONG		InterfaceIndex
	);


// Find and return first service in the order specified by the ordering method.
// Search is limited only to ceratin types of services as specified by the
// exclusion flags end corresponding fields in Service parameter.
// Returns ERROR_NO_MORE_ITEMS if there are no services in the
// table that meet specified criteria.

typedef
DWORD
(WINAPI * PGET_FIRST_ORDERED_SERVICE)(
    IN  DWORD           OrderingMethod,     // What ordering to use
    IN  DWORD           ExclusionFlags,     // Flags to limit search to ceratin
                                            // types of servers
    IN OUT PIPX_SERVICE Service 	    // On input: criteria for exclusion
                                            //          flags
                                            // On output: first service entry
                                            //          in the specified order
    );

// Find and return next service in the order specified by the ordering method.
// Search starts from specified service and is limited only to ceratin types
// of services as specified by the exclusion flags and corresponding fields
// in Service parameter.
// Returns ERROR_NO_MORE_ITEMS if there are no services in table
// table that meet specified criteria.

typedef
DWORD
(WINAPI * PGET_NEXT_ORDERED_SERVICE)(
    IN  DWORD           OrderingMethod,     // What ordering to use
    IN  DWORD           ExclusionFlags,     // Flags to limit search to ceratin
                                            // types of servers
    IN OUT PIPX_SERVICE Service 	    // On input: service to start the
                                            //          search from and
                                            //          criteria for exclusion
                                            //          flags
                                            // On output: next service entry
                                            //          in the specified order
    );

typedef
DWORD
(WINAPI * PDO_UPDATE_SERVICES) (
    IN ULONG    InterfaceIndex
    );

typedef
BOOL
(WINAPI * PGET_SERVICE_ID)(
      IN USHORT 	Type,
      IN PUCHAR 	Name,
      OUT PULONG	ServiceID
      );

typedef
BOOL
(WINAPI * PGET_SERVICE_FROM_ID)(
      IN ULONG	        ServiceID,
      OUT PIPX_SERVICE  Service
      );

typedef
DWORD
(WINAPI * PGET_NEXT_SERVICE_FROM_ID)(
      IN ULONG	        ServiceID,
      OUT PIPX_SERVICE  NextService,
      OUT PULONG        NextServiceID
      );

typedef struct _MPR40_SERVICE_CHARACTERISTICS
{
    DWORD                               dwVersion;
    DWORD                               dwProtocolId;
    DWORD                               fSupportedFunctionality;
    PIS_SERVICE                         pfnIsService;
    PDO_UPDATE_SERVICES                 pfnUpdateServices;
    PCREATE_SERVICE_ENUMERATION_HANDLE  pfnCreateServiceEnumerationHandle;
    PENUMERATE_GET_NEXT_SERVICE         pfnEnumerateGetNextService;
    PCLOSE_SERVICE_ENUMERATION_HANDLE   pfnCloseServiceEnumerationHandle;
    PGET_SERVICE_COUNT                  pfnGetServiceCount;
    PCREATE_STATIC_SERVICE              pfnCreateStaticService;
    PDELETE_STATIC_SERVICE              pfnDeleteStaticService;
    PBLOCK_CONVERT_SERVICES_TO_STATIC   pfnBlockConvertServicesToStatic;
    PBLOCK_DELETE_STATIC_SERVICES       pfnBlockDeleteStaticServices;
    PGET_FIRST_ORDERED_SERVICE          pfnGetFirstOrderedService;
    PGET_NEXT_ORDERED_SERVICE           pfnGetNextOrderedService;
}MPR40_SERVICE_CHARACTERISTICS;

typedef struct _MPR50_SERVICE_CHARACTERISTICS
{

#ifdef __cplusplus
    MPR40_SERVICE_CHARACTERISTICS       mscMpr40ServiceChars;
#else
    MPR40_SERVICE_CHARACTERISTICS;
#endif

}MPR50_SERVICE_CHARACTERISTICS;

#if MPR50
    typedef MPR50_SERVICE_CHARACTERISTICS MPR_SERVICE_CHARACTERISTICS;
#else
    #if MPR40
    typedef MPR40_SERVICE_CHARACTERISTICS MPR_SERVICE_CHARACTERISTICS;
    #endif
#endif

typedef MPR_SERVICE_CHARACTERISTICS *PMPR_SERVICE_CHARACTERISTICS;

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\verinfo.h ===
#if _MSC_VER > 1000
#pragma once
#endif

#ifdef RC_INVOKED

#include <ver.h>

#define VER_FILEVERSION_STR      "2.01\0"
#define VER_FILEVERSION          2,01,0100,06

#define VER_PRODUCTNAME_STR      "Microsoft OLE 2.01 for Windows\0"
#define VER_COMPANYNAME_STR      "Microsoft Corporation\0"
#define VER_LEGALTRADEMARKS_STR  "Microsoft (R) is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation\0"
#define VER_LEGALCOPYRIGHT_STR   "Copyright (C) Microsoft Corp. 1992-1999\0"
#define VER_PRODUCTVERSION_STR   "2.01\0"
#define VER_PRODUCTVERSION       2,01,0100,06
#define VER_COMMENT_STR          "Windows OLE DLLs\0"
#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          0
#define VER_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK
#define VER_FILEFLAGS            0L
#define VER_FILEOS               VOS_DOS_WINDOWS16

#endif /* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\tuple.h ===
/*++

Copyright (c) 1994-1999  Microsoft Corporation

Module Name:

    82365sl.h

Abstract:

    This module defines the PCMCIA tuple structures.

Author(s):

    Bob Rinne   (BobRi) 2-Aug-1994
    prototype from Jeff McLeman (mcleman@zso.dec.com)

Revision History:
    Ravisankar Pudipeddi (ravisp) 1-Feb-1997
    Additional definitions, more macros to parse tuples etc.

Notes:

    Tuple codes and names derived from the "PCMCIA PC CARD STANDARD"
    Release 2.01 CARD METAFORMAT section (Basic Compatibility Layer 1)

Revisions:

--*/

#if _MSC_VER > 1000
#pragma once
#endif

//
// Tuple codes
//

#define CISTPL_NULL             0x00
#define CISTPL_DEVICE           0x01
#define CISTPL_INDIRECT         0x03
#define CISTPL_CONFIG_CB        0x04
#define CISTPL_CFTABLE_ENTRY_CB 0x05
#define CISTPL_LONGLINK_MFC     0x06
#define CISTPL_CHECKSUM         0x10
#define CISTPL_LONGLINK_A       0x11
#define CISTPL_LONGLINK_C       0x12
#define CISTPL_LINKTARGET       0x13
#define CISTPL_NO_LINK          0x14
#define CISTPL_VERS_1           0x15
#define CISTPL_ALTSTR           0x16
#define CISTPL_DEVICE_A         0x17
#define CISTPL_JEDEC_C          0x18
#define CISTPL_JEDEC_A          0x19
#define CISTPL_CONFIG           0x1a
#define CISTPL_CFTABLE_ENTRY    0x1b
#define CISTPL_DEVICE_OC        0x1c
#define CISTPL_DEVICE_OA        0x1d
#define CISTPL_GEODEVICE        0x1e
#define CISTPL_GEODEVICE_A      0x1f
#define CISTPL_MANFID           0x20
#define CISTPL_FUNCID           0x21
#define CISTPL_FUNCE            0x22
#define CISTPL_VERS_2           0x40
#define CISTPL_FORMAT           0x41
#define CISTPL_GEOMETRY         0x42
#define CISTPL_BYTEORDER        0x43
#define CISTPL_DATE             0x44
#define CISTPL_BATTERY          0x45
#define CISTPL_ORG              0x46
#define CISTPL_LONGLINK_CB      0x47
#define CISTPL_END              0xFF

//
// Tuple structures and offsets - used based on tuple code.

//
//
// UCHAR
// CodeByte(
//     IN PUCHAR TupleBase
//     );
//
// Routine Description:
//
//     This returns the contents of the tuple code byte for the tuple
//     pointer passed in.
//
// Arguments:
//
//     TupleBase - a pointer to the current tuple.
//
// Return Values:
//
//     The contents of the tupleCode byte in the tuple.
//

#define CodeByte(TUPLE_BASE)    (*(TUPLE_BASE))

//
// UCHAR
// LinkByte(
//     IN PUCHAR TupleBase
//     );
//
// Routine Description:
//
//     This returns the contents of the link byte for the tuple
//     pointer passed in.
//
// Arguments:
//
//     TupleBase - a pointer to the current tuple.
//
// Return Values:
//
//     The contents of the link byte in the tuple.
//

#define LinkByte(TUPLE_BASE)    (*(TUPLE_BASE + 1))

//
//
// PUCHAR
// TupleBody(
//     IN PUCHAR TupleBase
//     );
//
// Routine Description:
//
//     This returns the pointer to the tuple body for the tuple
//     pointer passed in
//
// Arguments:
//
//     TupleBase - a pointer to the current tuple.
//
// Return Values:
//
//     The pointer to the body of the tuple
//

#define TupleBody(TUPLE_BASE)    (TUPLE_BASE+2)

//
//
// PUCHAR
// NextTuple(
//     IN PUCHAR TupleBase
//     );
//
// Routine Description:
//
//     This macro locates the next tuple in a stream of bytes given a pointer
//     to the current tuple.  This is done by adding the appropriate
//     link value to the current pointer.
//
// Arguments:
//
//     TupleBase - a pointer to the current tuple.
//
// Return Values:
//
//     A pointer to the next tuple.
//

#define NextTuple(TUPLE_BASE)   (*TUPLE_BASE ?                            \
                                 /* there is a link pointer case */       \
                                 (TUPLE_BASE + LinkByte(TUPLE_BASE) + 2) :\
                                 /* this is a NULL tuple */               \
                                 (TUPLE_BASE + 1))



//
// Device Tuple information.
//

#define DSPEED_MASK     0x07
#define DeviceSpeedField(X)  (X & DSPEED_MASK)
#define WPS_MASK        0x08
#define DeviceWPS(X)         ((X & WPS_MASK) >> 3)
#define DTYPE_MASK      0xF0
#define DeviceTypeCode(X)    ((X & DTYPE_MASK) >> 4)

#define DTYPE_NULL      0x00
#define DTYPE_ROM       0x01
#define DTYPE_OTPROM    0x02
#define DTYPE_EPROM     0x03
#define DTYPE_EEPROM    0x04
#define DTYPE_FLASH     0x05
#define DTYPE_SRAM      0x06
#define DTYPE_DRAM      0x07
#define DTYPE_FUNCSPEC  0x0d
#define DTYPE_EXTEND    0x0e

#define DSPEED_NULL     0x00
#define DSPEED_250NS    0x01
#define DSPEED_200NS    0x02
#define DSPEED_150NS    0x03
#define DSPEED_100NS    0x04
#define DSPEED_RES1     0x05
#define DSPEED_RES2     0x06
#define DSPEED_EXT      0x07


//
// extended speed definitions
//

#define SPEED_MANTISSA_MASK 0x78
#define SpeedMantissa(X) ((X & SPEED_MANTISSA_MASK) > 3)
#define SPEED_EXPONENT_MASK 0x07
#define SpeedExponent(X) (X & SPEED_EXPONENT_MASK)
#define SPEED_EXT_MASK      0x80
#define SpeedEXT(X)      ((X & SPEED_EXT_MASK) > 7)

#define MANTISSA_RES1   0x00
#define MANTISSA_1_0    0x01
#define MANTISSA_1_2    0x02
#define MANTISSA_1_3    0x03
#define MANTISSA_1_5    0x04
#define MANTISSA_2_0    0x05
#define MANTISSA_2_5    0x06
#define MANTISSA_3_0    0x07
#define MANTISSA_3_5    0x08
#define MANTISSA_4_0    0x09
#define MANTISSA_4_5    0x0a
#define MANTISSA_5_0    0x0b
#define MANTISSA_5_5    0x0c
#define MANTISSA_6_0    0x0d
#define MANTISSA_7_0    0x0e
#define MANTISSA_8_0    0x0f

#define EXPONENT_1ns    0x00
#define EXPONENT_10ns   0x01
#define EXPONENT_100ns  0x02
#define EXPONENT_1us    0x03
#define EXPONENT_10us   0x04
#define EXPONENT_100us  0x05
#define EXPONENT_1ms    0x06
#define EXPONENT_10ms   0x07

//
// Configuration tuple
//

#define CCST_CIF                0xC0

#define TPCC_RFSZ_MASK  0xc0
#define TpccRfsz(X)     ((X & TPCC_RFSZ_MASK) >> 6)
#define TPCC_RMSZ_MASK  0x3c
#define TpccRmsz(X)     ((X & TPCC_RMSZ_MASK) >> 2)
#define TPCC_RASZ_MASK  0x03
#define TpccRasz(X)     (X & TPCC_RASZ_MASK)

//
// CFTABLE_ENTRY data items
//

#define IntFace(X)           ((X & 0x80) >> 7)
#define Default(X)           ((X & 0x40) >> 6)
#define ConfigEntryNumber(X) (X & 0x3f)

#define PowerInformation(X)    (X & 0x03)
#define TimingInformation(X)   ((X & 0x04) >> 2)
#define IoSpaceInformation(X)  ((X & 0x08) >> 3)
#define IRQInformation(X)      ((X & 0x10) >> 4)
#define MemSpaceInformation(X) ((X & 0x60) >> 5)
#define MiscInformation(X)     ((X & 0x80) >> 7)

//
// Power information (part of CISTPL_CFTABLE_ENTRY) defines.
//

#define EXTENSION_BYTE_FOLLOWS 0x80

//
// Io Space information (part of CISTPL_CFTABLE_ENTRY) defines.
//

#define IO_ADDRESS_LINES_MASK 0x1f
#define RANGE_MASK            0x0f

#define Is8BitAccess(X)         ((X & 0x20) >> 5)
#define Is16BitAccess(X)        ((X & 0x40) >> 6)
#define HasRanges(X)            ((X & 0x80) >> 7)

#define GetAddressSize(X)       ((X & 0x30) >> 4)
#define GetLengthSize(X)        ((X & 0xc0) >> 6)

//
// CISTPL_FUNCID function codes
//

#define PCCARD_TYPE_MULTIFUNCTION    0
#define PCCARD_TYPE_MEMORY           1
#define PCCARD_TYPE_SERIAL           2
#define PCCARD_TYPE_PARALLEL         3
#define PCCARD_TYPE_ATA              4
#define PCCARD_TYPE_VIDEO            5
#define PCCARD_TYPE_NETWORK          6
#define PCCARD_TYPE_AIMS             7
#define PCCARD_TYPE_SCSI_BRIDGE      8
#define PCCARD_TYPE_SECURITY         9

//LATER: definitions not in spec
#define PCCARD_TYPE_MULTIFUNCTION3  10
#define PCCARD_TYPE_FLASH_MEMORY    11
#define PCCARD_TYPE_MODEM           12

#define PCCARD_TYPE_RESERVED      0xff

/******************************************************************
 * Tuple Flags.
 ******************************************************************/

#define TPLF_COMMON        0x0001
#define TPLF_READ             0x0002    // Only passed to AccessCISMem
#define TPLF_INDIRECT      0x0004
#define TPLF_IND_LINK      0x0008

#define TPLF_NOTHING           0x0000   // 0 is an unused entry
#define TPLF_IMPLIED_LINK   0x0010
#define TPLF_NO_LINK           0x0020
#define TPLF_LINK_TO_A      0x0030
#define TPLF_LINK_TO_C      0x0040
#define TPLF_LINK_TO_CB     0x0050
#define TPLF_LINK_MASK      0x0070

#define TPLF_ASI              0x0700
#define TPLF_ASI_SHIFT      8

#define TPLF_RESERVED_BITS  0xF882

//
// Tuple attributes
//
#define TPLA_RET_LINKS            0x0001
#define TPLA_RESERVED_BITS        0xFFFE

#define TPLL_ADDR          0x2
#define TPLMFC_NUM         0x2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\wfext.h ===
/*****************************************************************************\
*                                                                             *
* wfext.h -     Windows File Manager Extensions definitions (Win32 variant)   *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1991-1999, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************/

#ifndef _INC_WFEXT
#define _INC_WFEXT            /* #defined if wfext.h has been included */

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus            /* Assume C declaration for C++ */
extern "C" {
#endif  /* __cplusplus */

#define MENU_TEXT_LEN           40

#define FMMENU_FIRST            1
#define FMMENU_LAST             99

#define FMEVENT_LOAD            100
#define FMEVENT_UNLOAD          101
#define FMEVENT_INITMENU        102
#define FMEVENT_USER_REFRESH    103
#define FMEVENT_SELCHANGE       104
#define FMEVENT_TOOLBARLOAD     105
#define FMEVENT_HELPSTRING      106
#define FMEVENT_HELPMENUITEM    107

#define FMFOCUS_DIR             1
#define FMFOCUS_TREE            2
#define FMFOCUS_DRIVES          3
#define FMFOCUS_SEARCH          4

#define FM_GETFOCUS           (WM_USER + 0x0200)
#define FM_GETSELCOUNT        (WM_USER + 0x0202)
#define FM_GETSELCOUNTLFN     (WM_USER + 0x0203)  /* LFN versions are odd */
#define FM_REFRESH_WINDOWS    (WM_USER + 0x0206)
#define FM_RELOAD_EXTENSIONS  (WM_USER + 0x0207)

#define FM_GETDRIVEINFOA      (WM_USER + 0x0201)
#define FM_GETFILESELA        (WM_USER + 0x0204)
#define FM_GETFILESELLFNA     (WM_USER + 0x0205)  /* LFN versions are odd */

#define FM_GETDRIVEINFOW      (WM_USER + 0x0211)
#define FM_GETFILESELW        (WM_USER + 0x0214)
#define FM_GETFILESELLFNW     (WM_USER + 0x0215)  /* LFN versions are odd */

#ifdef UNICODE
#define FM_GETDRIVEINFO    FM_GETDRIVEINFOW
#define FM_GETFILESEL      FM_GETFILESELW
#define FM_GETFILESELLFN   FM_GETFILESELLFNW
#else
#define FM_GETDRIVEINFO    FM_GETDRIVEINFOA
#define FM_GETFILESEL      FM_GETFILESELA
#define FM_GETFILESELLFN   FM_GETFILESELLFNA
#endif


typedef struct _FMS_GETFILESELA {
   FILETIME ftTime;
   DWORD dwSize;
   BYTE bAttr;
   CHAR szName[260];          // always fully qualified
} FMS_GETFILESELA, FAR *LPFMS_GETFILESELA;

typedef struct _FMS_GETFILESELW {
   FILETIME ftTime ;
   DWORD dwSize;
   BYTE bAttr;
   WCHAR szName[260];          // always fully qualified
} FMS_GETFILESELW, FAR *LPFMS_GETFILESELW;

#ifdef UNICODE
#define FMS_GETFILESEL   FMS_GETFILESELW
#define LPFMS_GETFILESEL LPFMS_GETFILESELW
#else
#define FMS_GETFILESEL   FMS_GETFILESELA
#define LPFMS_GETFILESEL LPFMS_GETFILESELA
#endif


typedef struct _FMS_GETDRIVEINFOA {      // for drive
   DWORD dwTotalSpace;
   DWORD dwFreeSpace;
   CHAR  szPath[260];                    // current directory
   CHAR  szVolume[14];                   // volume label
   CHAR  szShare[128];                   // if this is a net drive
} FMS_GETDRIVEINFOA, FAR *LPFMS_GETDRIVEINFOA;

typedef struct _FMS_GETDRIVEINFOW {      // for drive
   DWORD dwTotalSpace;
   DWORD dwFreeSpace;
   WCHAR szPath[260];                    // current directory
   WCHAR szVolume[14];                   // volume label
   WCHAR szShare[128];                   // if this is a net drive
} FMS_GETDRIVEINFOW, FAR *LPFMS_GETDRIVEINFOW;

#ifdef UNICODE
#define FMS_GETDRIVEINFO   FMS_GETDRIVEINFOW
#define LPFMS_GETDRIVEINFO LPFMS_GETDRIVEINFOW
#else
#define FMS_GETDRIVEINFO   FMS_GETDRIVEINFOA
#define LPFMS_GETDRIVEINFO LPFMS_GETDRIVEINFOA
#endif


typedef struct _FMS_LOADA {
   DWORD dwSize;                        // for version checks
   CHAR  szMenuName[MENU_TEXT_LEN];     // output
   HMENU hMenu;                         // output
   UINT  wMenuDelta;                    // input
} FMS_LOADA, FAR *LPFMS_LOADA;

typedef struct _FMS_LOADW {
   DWORD dwSize;                        // for version checks
   WCHAR szMenuName[MENU_TEXT_LEN];     // output
   HMENU hMenu;                         // output
   UINT  wMenuDelta;                    // input
} FMS_LOADW, FAR *LPFMS_LOADW;

#ifdef UNICODE
#define FMS_LOAD   FMS_LOADW
#define LPFMS_LOAD LPFMS_LOADW
#else
#define FMS_LOAD   FMS_LOADA
#define LPFMS_LOAD LPFMS_LOADA
#endif


// Toolbar definitions

typedef struct tagEXT_BUTTON {
   WORD idCommand;                 /* menu command to trigger */
   WORD idsHelp;                   /* help string ID */
   WORD fsStyle;                   /* button style */
} EXT_BUTTON, FAR *LPEXT_BUTTON;

typedef struct tagFMS_TOOLBARLOAD {
   DWORD dwSize;                   /* for version checks */
   LPEXT_BUTTON lpButtons;         /* output */
   WORD cButtons;                  /* output, 0==>no buttons */
   WORD cBitmaps;                  /* number of non-sep buttons */
   WORD idBitmap;                  /* output */
   HBITMAP hBitmap;                /* output if idBitmap==0 */
} FMS_TOOLBARLOAD, FAR *LPFMS_TOOLBARLOAD;

typedef struct tagFMS_HELPSTRINGA {
   INT   idCommand;       /* input, -1==>the menu was selected */
   HMENU hMenu;           /* input, the extensions menu */
   CHAR  szHelp[128];     /* output, the help string */
} FMS_HELPSTRINGA, FAR *LPFMS_HELPSTRINGA;

typedef struct tagFMS_HELPSTRINGW {
   INT   idCommand;       /* input, -1==>the menu was selected */
   HMENU hMenu;           /* input, the extensions menu */
   WCHAR szHelp[128];     /* output, the help string */
} FMS_HELPSTRINGW, FAR *LPFMS_HELPSTRINGW;

#ifdef UNICODE
#define FMS_HELPSTRING   FMS_HELPSTRINGW
#define LPFMS_HELPSTRING LPFMS_HELPSTRINGW
#else
#define FMS_HELPSTRING   FMS_HELPSTRINGA
#define LPFMS_HELPSTRING LPFMS_HELPSTRINGA
#endif


typedef DWORD (APIENTRY *FM_EXT_PROC)(HWND, WORD, LONG);
typedef DWORD (APIENTRY *FM_UNDELETE_PROC)(HWND, LPTSTR);

#ifdef UNICODE
LONG WINAPI FMExtensionProcW(HWND hwnd, WORD wEvent, LONG lParam);
#else
LONG WINAPI FMExtensionProc(HWND hwnd, WORD wEvent, LONG lParam);
#endif

#ifdef __cplusplus
}                  /* End of extern "C" { */
#endif             /* __cplusplus */

#endif             /* _INC_WFEXT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\unimodem.h ===
/*++

   Copyright (c) 1996-1999 Microsoft Corporation.


   Component

  		Unimodem TSP Public Header

   File

  		UNIMODEM.H

   History

  		10/25/1997  JosephJ Created, taking stuff from nt50\tsp\public.h
  		01/29/1998  JosephJ Revised, allowing multiple diagnostics objects,
                            as well as expanding the  LINEDIAGNOSTICS_PARSEREC
                            structure from 2 to 4 fields.

--*/

#ifndef  _UNIMODEM_H_
#define  _UNIMODEM_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <setupapi.h>

#ifdef __cplusplus
extern "C" {
#endif


//====================================================================
//      Supported TAPI Device Classes
//
//====================================================================
#define szUMDEVCLASS_COMM                    TEXT("comm")
#define szUMDEVCLASS_COMM_DATAMODEM          TEXT("comm/datamodem")
#define szUMDEVCLASS_COMM_DATAMODEM_PORTNAME TEXT("comm/datamodem/portname")
#define szUMDEVCLASS_TAPI_LINE_DIAGNOSTICS   TEXT("tapi/line/diagnostics")

//=========================================================================
//
//      "comm"
//
//
//      Supported APIS:
//              lineGet/SetDevConfig
//              lineConfigDialog
//              lineConfigDialogEdit
//
//      The associated configuration object is UMDEVCFG defined below...
//
//=========================================================================

// Device Setting Information
//
typedef struct  // UMDEVCFGHDR
{
    DWORD       dwSize;
    DWORD       dwVersion;        // Set to MDMCFG_VERSION
    WORD        fwOptions;        // One or more of the flags below...

    #define UMTERMINAL_NONE       0x00000000
    #define UMTERMINAL_PRE        0x00000001
    #define UMTERMINAL_POST       0x00000002
    #define UMMANUAL_DIAL         0x00000004
    #define UMLAUNCH_LIGHTS       0x00000008   // Not supported on NT5.

    WORD        wWaitBong;        // seconds to wait for the BONG character
                                  // for modems that do not support detection
                                  // of the BONG tone.

}   UMDEVCFGHDR, *PUMDEVCFGHDR;


typedef struct // UMDEVCFG
{
    UMDEVCFGHDR   dfgHdr;
    COMMCONFIG  commconfig;
}   UMDEVCFG, *PUMDEVCFG;

#define  UMDEVCFG_VERSION     0x00010003  // Version number of structure



// How much to wait for a credit-card-bong if modem doesn't support it.
// (TODO: move this somewhere else!)
//
#define  UMMIN_WAIT_BONG      0
#define  UMMAX_WAIT_BONG      60
#define  UMDEF_WAIT_BONG      8
#define  UMINC_WAIT_BONG      2

//=========================================================================
//
//      "comm/datamodem"
//
//  Supported APIS:
//         lineGetID   Returns the structure below.
//
//=========================================================================

//=========================================================================
//
//      "comm/datamodem/portname"
//
//  Supported APIS:
//         lineGetID The Varstring is of type ASCII string and
//                   contains the null-terminated name of the COMM port
//                   attached to the device, if there is one.
//
//=========================================================================


//=========================================================================
//
//      "tapi/line/diagnostics"
//
//  Supported APIS:
//         lineGet/SetDevConfig: LINEDIAGNOSTICSCONFIG is the associated
//                            configuration object...
//         lineGetID: LINEDIAGNOSTICS is the returned object.
//
//
//=========================================================================

//
// Many of the diagnostics-related structures and sub-structures defined
// below have a 4-DWORD header defined below:
//
//
typedef struct // LINEDIAGNOSTICSOBJECTHEADER
{
    DWORD dwSig;                // object-specific signature. All
                                // signatures defined here have
                                // prefix "LDSIG_", and are defined below:

    #define LDSIG_LINEDIAGNOSTICSCONFIG 0xb2f78d82 // LINEDIAGNOSTICSCONFIG sig
    #define LDSIG_LINEDIAGNOSTICS       0xf0c4d4e0 // LINEDIAGNOSTICS sig
    #define LDSIG_RAWDIAGNOSTICS        0xf78b949b // see LINEDIAGNOSTICS defn.
    #define LDSIG_PARSEDDIAGNOSTICS     0x16cf3208 // see LINEDIAGNOSTICS defn.


    DWORD dwNextObjectOffset;   // Offset from the start of this header to
                                // the next object if any (0 if none following).
                                // Depending on the type of object, this
                                // field may or may not be used.
    DWORD dwTotalSize;          // Total size of this object
    DWORD dwFlags;              // object-specific flags
    DWORD dwParam;              // object-specific data

} LINEDIAGNOSTICSOBJECTHEADER, *PLINEDIAGNOSTICSOBJECTHEADER;

//
// The following structure defines the diagnostics capabilities and
// curent settings of the device. It is accessed via
// lineGet/SetDevConfig("tapi/line/diagnostics");
//

typedef struct // LINEDIAGNOSTICSCONFIG
{
    LINEDIAGNOSTICSOBJECTHEADER hdr;
    //
    // hdr.dwSig must be set to LDSIG_LINEDIAGNOSTICSCONFIG
    // hdr.dwNextObjectOffset will point to the next configuration object,
    //          if any.
    // hdr.dwTotalSize must be set to the current size of this
    //          structure.
    // hdr.dwFlags contains read only diagnostics capabilities --- one
    //      of the constants defined below ...
    //      This field is ignored when the structure is passed
    //      in a call to lineSetDevConfig
    //
    #define fSTANDARD_CALL_DIAGNOSTICS 0x1

    // hdr.dwParam contains current diagnostics settings. One or more
    // constants defined above -- indicate that the
    // corresponding capability is enabled for
    // the device.

} LINEDIAGNOSTICSCONFIG, *PLINEDIAGNOSTICSCONFIG;


//
// Diagnostic information is accessed by lineGetID("tapi/line/diagnostics"),
// with CALLSELECT_CALL. On return, the supplied VARSTRING will be filled
// in with one or more LINEDIAGNOSTICS structures defined below, and.
// potentially other kinds of structures (all with header
// LINEDIAGNOSTICSOBJECTHEADER).
//
// Note that this information can only be obtained if (a) diagnostics
// have been enabled by a previous call to
// lineSetDevConfig("tapi/line/diagnostics) and (b) a valid call handle
// exists. Typically this information is obtained just before
// deallocating the call.
//
// The LINEDIAGNOSTICS structure includes the raw
// diagnostics information returned by the device as well as summary
// information and variable-length arrays containing parsed information.
//
// All the diagnostic information in a particular LINEDIAGNOSTICS object
// is "domain ID" specific. The dwDomainID field of the structure defines the
// domain, or name space, from which any constants are taken. The
// currently Domain IDs are defined below, and have prefix  "DOMAINID":
//

#define DOMAINID_MODEM     0x522aa7e1
#define DOMAINID_NULL      0x0


typedef struct // LINEDIAGNOSTICS
{
    //
    // The following 2 fields provide version and size informatio about
    // this structure, as well as identify the domain (name space) of the
    // diagnostics information applies to. All subsequent fields in the
    // structure are domainID-specific.
    //

    LINEDIAGNOSTICSOBJECTHEADER hdr;
    //
    //  hdr.dwSig must be set to constant LDSIG_LINEDIAGNOSTICS
    //  hdr.dwNextObjectOffset will point to the next diagnostic object,
    //          if any.
    //  hdr.dwTotalSize contains the total size of this structure,
    //          including variable portion
    //  hdr.dwFlags is reserved and must be ignored.
    //  hdr.dwParam is set to the current sizeof(LINEDIAGNOSTICS) --
    //          used for versioning of the LINEDIAGNOSICS structure.
    //          Note that this does NOT include the size of the
    //          variable length portion.

    DWORD dwDomainID;    // Identifies the name space from which the
                         // interpretation of any constants are taken.


    //
    // The following 5 DWORD fields provide summary diagnostic information,
    // obtained by analyzing all the diagnostic information.
    //

    DWORD dwResultCode; // dDomainID-specific LDRC_ constants defined below
    DWORD dwParam1;     // Params1-4 are dwResultCode-specific data items.
    DWORD dwParam2;
    DWORD dwParam3;
    DWORD dwParam4;


    //
    //  The remaining fields point to variable length objects containing
    //  parsed and unparsed (raw) diagnostics information.
    //
    //  Each variable length object starts with a
    //  LINEDIAGNOSTICSOBJECTHEADER structure, referred to as "ohdr" in
    //  the documentation below.
    //

    DWORD dwRawDiagnosticsOffset;
    //
    //          Offset from the start of this structure
    //          to the start of an object containing
    //          the raw diagnostics output.
    //
    //          ohdr.dwSig will be set to LDSIG_RAWDIAGNOSTICS
    //          ohdr.dwNextObjectOffset UNUSED and will be set to 0.
    //          ohdr.dwTotalSize is set to the total size of the
    //                       raw-diagnostics object.
    //          ohdr.dwFlags is undefined and should be ignored.
    //          ohdr.dwParam is set to the size, in bytes of raw
    //                      diagnostics data following ohdr.
    //
    //          Note that ohdr.dwTotalSize will be equal to
    //              (   sizeof(LINEDIAGNOSTICSOBJECTHEADER)
    //                + ohdr.dwParam)
    //
    //          The raw diagnostics bytes will be null terminated and
    //          the ohdr.dwParam includes the size of the terminating null.
    //          HOWEVER, the raw diagnostics may contain embedded nulls.
    //          For  DEVCLASSID_MODEM,  the bytestring will contain
    //          no embedded nulls and has the HTML-like tagged format
    //          defined in the AT#UD diagnostics specification.
    //
    // The following macros help extract and validate raw diagnostics
    // information...
    //
    #define RAWDIAGNOSTICS_HDR(_plinediagnostics)                           \
            ((LINEDIAGNOSTICSOBJECTHEADER*)                                 \
                 (  (BYTE*)(_plinediagnostics)                              \
                  + ((_plinediagnostics)->dwRawDiagnosticsOffset)))

    #define IS_VALID_RAWDIAGNOSTICS_HDR(_praw_diagnostics_hdr)              \
            ((_praw_diagnostics_hdr)->dwSig==LDSIG_RAWDIAGNOSTICS)

    #define RAWDIAGNOSTICS_DATA(_plinediagnostics)                          \
            (  (BYTE*)(_plinediagnostics)                                   \
             + ((_plinediagnostics)->dwRawDiagnosticsOffset)                \
             + sizeof(LINEDIAGNOSTICSOBJECTHEADER))

    #define RAWDIAGNOSTICS_DATA_SIZE(_praw_diagnostics_hdr)                 \
            ((_praw_diagnostics_hdr)->dwParam)

    DWORD dwParsedDiagnosticsOffset;
    //
    //          Offset from the start of this structure
    //          to the start of an object containing
    //          parsed diagnostics output.
    //
    //          ohdr.dwSig will be set to LDSIG_PARSEDDIAGNOSTICS
    //          ohdr.dwNextObjectOffset UNUSED and will be set to 0.
    //          ohdr.dwTotalSize is set to the total size of the
    //                       parsed-diagnostics object.
    //          ohdr.dwFlags is undefined and should be ignored.
    //          ohdr.dwParam is set to the number of contiguous
    //                      LINEDIAGNOSTICS_PARSEREC structures (defined below)
    //                      following ohdr.
    //          Note that ohdr.dwTotalSize will be equal to
    //              (   sizeof(LINEDIAGNOSTICSOBJECTHEADER)
    //                + ohdr.dwParam*sizeof(LINEDIAGNOSTICS_PARSEREC))
    //
    // The following macros help extract and validate parsed diagnostics
    // information...
    //
    #define PARSEDDIAGNOSTICS_HDR(_plinediagnostics)                        \
            ((LINEDIAGNOSTICSOBJECTHEADER*)                                 \
                 (  (BYTE*)(_plinediagnostics)                              \
                  + ((_plinediagnostics)->dwParsedDiagnosticsOffset)))

    #define PARSEDDIAGNOSTICS_DATA(_plinediagnostics)                       \
                            ((LINEDIAGNOSTICS_PARSEREC*)                    \
                            (  (BYTE*)(_plinediagnostics)                   \
                             + ((_plinediagnostics)->dwParsedDiagnosticsOffset)\
                             + sizeof(LINEDIAGNOSTICSOBJECTHEADER)))

    #define PARSEDDIAGNOSTICS_NUM_ITEMS(_pparsed_diagnostics_hdr)           \
            ((_pparsed_diagnostics_hdr)->dwParam)

    #define IS_VALID_PARSEDDIAGNOSTICS_HDR(_pparsed_diagnostics_hdr)        \
            ((_pparsed_diagnostics_hdr)->dwSig==LDSIG_PARSEDDIAGNOSTICS)


} LINEDIAGNOSTICS, *PLINEDIAGNOSTICS;


//
// The following structure defines a keyword-value pair of parsed-diagnostic
// information.
//
typedef struct // LINEDIAGNOSTICS_PARSEREC
{

    DWORD dwKeyType;
    //
    //  "Super key" -- identifying the type of key
    //

    DWORD dwKey;
    //
    //      This is domain-specific and key-type specific. For DEVCLASSID_MODEM,
    //      This will be one of the MODEMDIAGKEY_* constants
    //      defined below.

    DWORD dwFlags;
    //
    //      Help to identify the meaning of dwValue
    //      One or more of the following flags:
    //      (1st 4 are mutually exclusive)
    //
            #define fPARSEKEYVALUE_INTEGER                       (0x1<<0)
            //          value is an integer literal

            #define fPARSEKEYVALUE_LINEDIAGNOSTICSOBJECT         (0x1<<1)
            //          value is the offset in bytes to a LINEDIGAGNOSTICS
            //          object which contains the information associated
            //          with this entry. The byte offset is from the start
            //          of the object containing the parsed information,
            //          not from start of the containing LINEDIAGNOSTICS object.


            #define fPARSEKEYVALUE_ASCIIZ_STRING                 (0x1<<2)
            //          value is the offset in bytes to an ASCII
            //          null-terminated string. The byte offset is from the
            //          start of the object containing the parsed information,
            //          not from start of the containing LINEDIAGNOSTICS object.

            #define fPARSEKEYVALUE_UNICODEZ_STRING               (0x1<<3)
            //          value is the offset in bytes to a UNICODE
            //          null-terminated string. The byte offset is from the
            //          start of the object containing the parsed information,
            //          not from start of the containing LINEDIAGNOSTICS object.


    DWORD dwValue;
    //
    //      This is dwKey specific. The documentation
    //      associated with each MODEMDIAGKEY_* constant definition
    //      precicely describes the content of its corresponding dwValue.
    //      See also dwFlags above.
    //

} LINEDIAGNOSTICS_PARSEREC, *PLINEDIAGNOSTICS_PARSEREC;



// -----------------------------------------------------------------------------
// ANALOG MODEM SUMMARY DIAGNOSIC INFORMATION
// -----------------------------------------------------------------------------
//
// Diagnostics Result Codes (LDRC_*) for modems
//
#define LDRC_UNKNOWN    0
//      The result code is unknown. Raw diagnostics information may be present,
//      if so dwRawDiagnosticsOffset and dwRawDiagnosticsSize will be nonzero.
//      dwParam1-4: unused and will be set to zero.

// Other codes are TBD.


// -----------------------------------------------------------------------------
//  LINEDIAGNOSTICS_PARSEREC KeyType,
//  key and value definitions for domainID DOMAINID_MODEM
// -----------------------------------------------------------------------------

//
// KEYTYPE
//
#define MODEM_KEYTYPE_STANDARD_DIAGNOSTICS 0x2a4d3263

// All the modem-domain-id key constants have prefix "MODEMDIAGKEY_". Both
// keys and values are based on the AT#UD diagnostic specification.
//
// Most of the values corresponding to the keys defined below are DWORD-sized
// bitfields or counters. A few of the values are offsets (from the start
// of the LINEDIAGNOSTICS structure) to variable-sized values. The formats
// of all values are documented directly after the corresponding key definition,
// and have prefix "MODEMDIAG_". Where useful, macros are provided which
// extract individual bits or bitfields out of the dwValue field. For example,
// see the macros associated with the MODEMDIAGKEY_V34_INFO key, which contains
// information extracted from the V.34 INFO structure.


#define MODEMDIAGKEY_VERSION                    0x0

    // Value: DWORD. HiWord represents major version;
    //       LoWord represents minor version;
    // Following Macros may be used to extract the hi- and low- version numbers.
    // from the parserec's .dwValue field...
    //
    #define MODEMDIAG_MAJORVER(_ver) ((HIWORD) (_ver))
    #define MODEMDIAG_MINORVER(_ver) ((LOWORD) (_ver))

#define MODEMDIAGKEY_CALL_SETUP_RESULT          0x1

    // Value: Call Setup Result codes based on on Table 2 of the
    //           AT#UD specification....

    #define MODEMDIAG_CALLSETUPCODE_NO_PREVIOUS_CALL 0x0
                //
                // Modem log has be en cleared since any previous calls...
                //

    #define MODEMDIAG_CALLSETUPCODE_NO_DIAL_TONE            0x1
                //
                // No dial tone detected.
                //

    #define MODEMDIAG_CALLSETUPCODE_REORDER_SIGNAL          0x2
                //
                // Reorder signal detected, network busy.
                //

    #define MODEMDIAG_CALLSETUPCODE_BUSY_SIGNAL             0x3
                //
                // Busy signal detected
                //

    #define MODEMDIAG_CALLSETUPCODE_NO_SIGNAL               0x4
                //
                //  No recognized signal detected.
                //

    #define MODEMDIAG_CALLSETUPCODE_VOICE                   0x5
                //
                // Analog voice detected
                //

    #define MODEMDIAG_CALLSETUPCODE_TEXT_TELEPHONE_SIGNAL   0x6
                //
                // Text telephone signal detected (V.18)
                //

    #define MODEMDIAG_CALLSETUPCODE_DATA_ANSWERING_SIGNAL   0x7
                //
                // Data answering signal detected (e.g. V.25 ANS, V.8 ANSam)
                //

    #define MODEMDIAG_CALLSETUPCODE_DATA_CALLING_SIGNAL     0x8
                //
                // Data calling signal detected (e.g. V.25 CT, V.8 CI).
                //

    #define MODEMDIAG_CALLSETUPCODE_FAX_ANSWERING_SIGNAL    0x9
                //
                // Fax answering signal detected (e.g. T.30 CED, DIS).
                //

    #define MODEMDIAG_CALLSETUPCODE_FAX_CALLING_SIGNAL      0xa
                //
                // Fax calling signal detected (e.g. T.30 CNG)
                //

    #define MODEMDIAG_CALLSETUPCODE_V8BIS_SIGNAL            0xb
                //
                // V.8bis signal detected.
                //


#define MODEMDIAGKEY_MULTIMEDIA_MODE        0x2

    // Value: Multimedia mode, based on Table 3 of the AT#UD specification...

    #define MODEMDIAG_MMMODE_DATA_ONLY      0x0
    #define MODEMDIAG_MMMODE_FAX_ONLY       0x1
    #define MODEMDIAG_MMMODE_VOICE_ONLY     0x2
    #define MODEMDIAG_MMMODE_VOICEVIEW      0x3
    #define MODEMDIAG_MMMODE_ASVD_V61      0x4
    #define MODEMDIAG_MMMODE_ASVD_V34Q     0x5
    #define MODEMDIAG_MMMODE_DSVD_MT        0x6
    #define MODEMDIAG_MMMODE_DSVD_1_2       0x7
    #define MODEMDIAG_MMMODE_DSVD_70        0x8
    #define MODEMDIAG_MMMODE_H324           0x9
    #define MODEMDIAG_MMMODE_OTHER_V80      0xa




#define MODEMDIAGKEY_DTE_DCE_INTERFACE_MODE 0x3

    // Value: DTE-DCE interface mode, based on Table 4 of the AT#UD specication
    //          ...
    #define MODEMDIAG_DCEDTEMODE_ASYNC_DATA             0x0
    #define MODEMDIAG_DCEDTEMODE_V80_TRANSPARENT_SYNC  0x1
    #define MODEMDIAG_DCEDTEMODE_V80_FRAMED_SYNC       0x2

#define V8_CM_STRING                        0x4
    // Value: offset from the start of the LINEDIAGNOSTICS structure to
    // the V.8 CM octet string, same format as V.25ter Annex A.
    // The offset points to a contiguous region of memory who

// TODO: define parsed-versions of V.8 CM and V.8 JM octet strings, not
//       covered in the information returned in PARSEREC

#define  MODEMDIAGKEY_RECEIVED_SIGNAL_POWER     0x10
    // Value: Received signal power level, in -dBm.

#define  MODEMDIAGKEY_TRANSMIT_SIGNAL_POWER     0x11
    // Value: Transmit signal power level, in -dBm.

#define MODEMDIAGKEY_NOISE_LEVEL                0x12
    // Value: Estimated noise level, in -dBM.

#define MODEMDIAGKEY_NORMALIZED_MSE             0x13
    // Value: Normalized Mean Squared error. JosephJ: TODO: Of what?

#define MODEMDIAGKEY_NEAR_ECHO_LOSS             0x14
    // Value: Near echo loss, in units of dB

#define MODEMDIAGKEY_FAR_ECHO_LOSS              0x15
    // Value: Far echo loss, in units of dB

#define MODEMDIAGKEY_FAR_ECHO_DELAY             0x16
    // Value: Far echo delay, in units of ms.

#define MODEMDIAGKEY_ROUND_TRIP_DELAY           0x17
    // Value: Round trip delay, in units of ms.

#define MODEMDIAGKEY_V34_INFO                  0x18
    // Value: V.34 INFO bitmap, based on Table 5 of the AT#UD specifiction.
    // This DWORD value encodes 32 bits extracted from the V.34 INFO bitmap.
    // The following Macros extract specific V.34 INFO bit ranges out of
    // the 32-bit value:
    //
    // 10/30/1997 JosephJ: TODO what exactly are these? Also, what
    // does 20;0, 50;0 below mean?

    #define MODEMDIAG_V34_INFO0_20_0(_value)            (((_value)>>30) & 0x3)
        //
        // INFO0 bit 20;0
        //

    #define MODEMDIAG_V34_INFOc_79_88(_value)           (((_value)>>20) & 0x3ff)
        //
        // INFOc bit 79-88
        //

    #define MODEMDIAG_V34_INFOc_PRE_EMPHASIS(_value)    (((_value)>>16) & 0xf)
        //
        // Pre-emphasis field, selected by the symbol rate chosen.
        // INFOc bits 26-29 or 35-38 or 44-47 or 53-56 or 62-65 or 71-74
        //
    #define MODEMDIAG_V34_INFOa_26_29(_value)           (((_value)>>12) & 0xf)
        //
        // INFOa bits 26-29
        //

    #define MODEMDIAG_V34_INFO_MP_50_0(_value)          (((_value)>>10) & 0x3)
        //
        // MP bit 50;0
        //

    #define MODEMDIAG_V34_INFOa_40_49(_value)           (((_value)>>0) & 0x3ff)
        //
        // INFOa bits 40-49
        //

#define MODEMDIAGKEY_TRANSMIT_CARRIER_NEGOTIATION_RESULT    0x20
        //  Value: based on Table 6 of the AT#UD specification
        // TODO: fill out...


#define MODEMDIAGKEY_RECEIVE_CARRIER_NEGOTIATION_RESULT     0x21
        //  Value: based on Table 6 of the AT#UD specification
        // TODO: fill out...

#define MODEMDIAGKEY_TRANSMIT_CARRIER_SYMBOL_RATE           0x22
        //  Value: Transmit carrier symbol rate.


#define MODEMDIAGKEY_RECEIVE_CARRIER_SYMBOL_RATE            0x23
        //  Value: Receive carrier symbol rate.

#define MODEMDIAGKEY_TRANSMIT_CARRIER_FREQUENCY             0x24
        //  Value: Transmit carrier frequency TODO: units? Hz?

#define MODEMDIAGKEY_RECEIVE_CARRIER_FREQUENCY              0x25
        //  Value: Transmit carrier frequency TODO: units? Hz?

#define MODEMDIAGKEY_INITIAL_TRANSMIT_CARRIER_DATA_RATE     0x26
        // Value: Initial transmit carrier data rate. TODO: units? /sec?

#define MODEMDIAGKEY_INITIAL_RECEIVE_CARRIER_DATA_RATE      0x27
        // Value: Initial receive carrier data rate. TODO: units? /sec?

#define MODEMDIAGKEY_TEMPORARY_CARRIER_LOSS_EVENT_COUNT     0x30
        // Value: Temporary carrier loss event count

#define MODEMDIAGKEY_CARRIER_RATE_RENEGOTIATION_COUNT       0x31
        // Value: Carrier rate renegotiation event count

#define MODEMDIAGKEY_CARRIER_RETRAINS_REQUESTED             0x32
        // Value: Carrier retrains requested

#define MODEMDIAGKEY_CARRIER_RETRAINS_GRANTED               0x33
        // Value: Carrier retrains granted.

#define MODEMDIAGKEY_FINAL_TRANSMIT_CARRIER_RATE            0x34
        // Value: final carrier transmit rate   TODO: units? /sec?

#define MODEMDIAGKEY_FINAL_RECEIVE_CARRIER_RATE            0x35
        // Value: final carrier receive rate   TODO: units? /sec?

#define MODEMDIAGKEY_PROTOCOL_NEGOTIATION_RESULT           0x40
        // Value: Protocol negotiation result code, based on
        //      Table 7 of the AT#UD diagnostics specification...

#define MODEMDKAGKEY_ERROR_CONTROL_FRAME_SIZE              0x41
        // Value: Error control frame size. TODO: units? bytes?

#define MODEMDIAGKEY_ERROR_CONTROL_LINK_TIMEOUTS           0x42
        // Value: Error control link timeouts. TODO: time or count?

#define MODMEDIAGKEY_ERROR_CONTROL_NAKs                    0x43
        // Value: Error control NAKs

#define MODEMDIAGKEY_COMPRESSION_NEGOTIATION_RESULT        0x44
        // Value: Compression negotiation result, based on
        //        Table 8 of the AT#UD spec.
        //
        // TODO: add specific constant definitions here...

#define MODEMDIAGKEY_COMPRESSION_DICTIONARY_SIZE          0x45
        // Value: compression dictionary size. TODO: size? bytes?


#define MODEMDIAGKEY_TRANSMIT_FLOW_CONTROL               0x50
        // Value: Transmit flow control, defined by
        // one of the following constants:

        #define MODEMDIAG_FLOW_CONTROL_OFF      0x0
        //
        //  No flow control
        //

        #define MODEMDIAG_FLOW_CONTROL_DC1_DC3  0x2
        //
        //  DC1/DC3 (XON/XOFF) flow control
        //

        #define MODEMDIAG_FLOW_CONTROL_RTS_CTS  0x3
        //
        // RTS/CTS (V.24 ckt 106/133) flow control: TODO verify that latter
        // is the same as RTS/CTS.
        //

#define MODEMDIAGKEY_RECEIVE_FLOW_CONTROL               0x51
        // Value: Receive flow control, defined by the above
        //  (MODEMDiG_FLOW_CONTROL_*) constants.

#define MODEMDIAGKEY_DTE_TRANSMIT_CHARACTERS            0x52
        // Value: Transmit characters obtained from DTE

#define MODEMDIAGKEY_DTE_RECEIVED_CHARACTERS             0x53
        // Value: Received characters sent to DTE

#define MODEMDIAGKEY_DTE_TRANSMIT_CHARACTERS_LOST       0x54
        // Value: Transmit characters lost (data overrun errors from DTE)

#define MODEMDIAGKEY_DTE_RECEIVED_CHARACTERS_LOST       0x55
        // Value: Transmit characters lost (data overrun errors to DTE)

#define MODEMDIAGKEY_EC_TRANSMIT_FRAME_COUNT            0x56
        // Value: Error control protocol transmit frame count

#define MODEMDIAGKEY_EC_RECEIVED_FRAME_COUNT            0x57
        // Value: Error control protocol received frame count

#define MODEMDIAGKEY_EC_TRANSMIT_FRAME_ERROR_COUNT      0x58
        // Value: Error control protocol transmit frame error count

#define MODEMDIAGKEY_EC_RECEIVED_FRAME_ERROR_COUNT      0x59
        // Value: Error control protocol received frame error count

#define MODEMDIAGKEY_TERMINATION_CAUSE                  0x60
       // Value: Termination cause, based on Table 9-10 of the AT#UD
       //        specification.

#define MODEMDIAGKEY_CALL_WAINTING_EVENT_COUNT         0x61
       // Value: Call wainting event count.
       // TODO: Define specific  constants.


//
// KEYTYPE
//
#define MODEM_KEYTYPE_AT_COMMAND_RESPONSE  0x5259091c
//
// The values are responses to specific AT commands. This type is relevant
// only to AT ("Hayes(tm) compatible") modems.
// The key (one of the MODEMDIAGKEY_ATRESP_* constants ) identifies the
// command.
//

#define MODEMDIAGKEY_ATRESP_CONNECT         0x1
       // Value: Connect response string.
       // This will be a null-terminated ascii string.

// ========================================================================
//  UNIMODEM DEVICE-SPECIFIC returned for lineGetDevCaps

// The following structure is located at dwDevSpecificOffset into
// the  LINEDEVCAPS structure returned by lineGetDevCaps.
//
typedef struct // DEVCAPS_DEVSPECIFIC_UNIMODEM
{
    DWORD dwSig;
    //
    //  This will be set to 0x1;

    DWORD dwKeyOffset;
    //
    // This is the offset from the start of THIS structure, to
    // a null-terminated ASCI (not UNICODE) string giving
    // the device's driver key.
    //
    // WARNING: this is present for compatibility reasons. Applications
    // are STRONGLY discouraged to use this information, because the
    // location of the driver key could change on upgrade, so if
    // applications save away this key, the application could fail
    // on upgrade of the OS.
    //

} DEVCAPS_DEVSPECIFIC_UNIMODEM, *PDEVCAPS_DEVSPECIFIC_UNIMODEM;

// ========================================================================

typedef struct  // ISDN_STATIC_CONFIG
{
    DWORD dwSig;
    //
    //      Must be  set to dwSIG_ISDN_STATIC_CONFIGURATION
    //
    #define dwSIG_ISDN_STATIC_CONFIGURATION 0x877bfc9f

    DWORD dwTotalSize;
    //
    //  Total size of this structure, including variable portion, if any.
    //

    DWORD dwFlags;              // reserved
    DWORD dwNextHeaderOffset;   // reserved

    DWORD dwSwitchType;
    //
    //      One of the dwISDN_SWITCH_* values below.
    //
    #define dwISDN_SWITCH_ATT1      0   // AT&T 5ESS Customm
    #define dwISDN_SWITCH_ATT_PTMP  1   // AT&T Point to Multipoint
    #define dwISDN_SWITCH_NI1       2   // National ISDN 1
    #define dwISDN_SWITCH_DMS100    3   // North3ern Telecom DMS-100 NT1
    #define dwISDN_SWITCH_INS64     4   // NTT INS64 - (Japan)
    #define dwISDN_SWITCH_DSS1      5   // DSS1 (Euro-ISDN)
    #define dwISDN_SWITCH_1TR6      6   // 1TR6 (Germany)
    #define dwISDN_SWITCH_VN3       7   // VN3  (France)
    #define dwISDN_SWITCH_BELGIUM1  8   // Belgian National
    #define dwISDN_SWITCH_AUS1      9   // Australian National TPH 1962
    #define dwISDN_SWITCH_UNKNOWN  10   // Unknown

    DWORD dwSwitchProperties;
    //
    //      One or more fISDN_SWITCHPROP_* flags below
    //
    // Note the following three are exclusive, so only one can be
    // set at a time:
    #define fISDN_SWITCHPROP_US     (0x1<<0) // Uses DN/SPID
    #define fISDN_SWITCHPROP_MSN    (0x1<<1) // Uses MSN
    #define fISDN_SWITCHPROP_EAZ    (0x1<<2) // Uses EAX
    #define fISDN_SWITCHPROP_1CH    (0x1<<3) // Only one channel.

    DWORD dwNumEntries;
    //
    //      The number of channels OR MSNs.
    //      The numbers and possibly IDs are specified in the following
    //      two offsets.
    //

    DWORD dwNumberListOffset;
    //
    //      Offset in BYTES from the start of this structure to a
    //      UNICODE multi-sz set of strings representing numbers.
    //      There will dwNumChannels entries.
    //
    //      The interpretation of these numbers is switch-property-specific,
    //      and is as follows:
    //           US: Directory Number.
    //          MSN: MSN Number
    //          EAZ: EAZ Number.

    DWORD dwIDListOffset;
    //
    //      Offset in BYTES from the start of this structure to a
    //      UNICODE multi-sz set of strings representing IDs.
    //      There will dwNumChannels entries.
    //
    //      The interpretation of these IDs is switch-property-specific and
    //      is as follows:
    //           US: SPID.
    //          MSN: Not used and should be set to 0.
    //          EAZ: EAZ

    //
    //  variable length portion, if any, follows...
    //

} ISDN_STATIC_CONFIG;


typedef struct  // ISDN_STATIC_CAPS
{
    DWORD dwSig;
    //
    //      Must be  set to dwSIG_ISDN_STATIC_CAPS
    //
    #define dwSIG_ISDN_STATIC_CAPS 0xd11c5587
    DWORD dwTotalSize;
    //
    //  Total size of this structure, including variable portion, if any.
    //

    DWORD dwFlags;              // reserved
    DWORD dwNextHeaderOffset;   // reserved


    DWORD dwNumSwitchTypes;
    DWORD dwSwitchTypeOffset;
    //
    //  Offset to switch types, which is a DWORD array of types.
    //

    DWORD dwSwitchPropertiesOffset;
    //
    //  Offset to a DWORD array of properties of the corresponding switch.
    //

    DWORD dwNumChannels;
    //
    //  The number of channels supported.
    //

    DWORD dwNumMSNs;
    //
    //  The number of MSNs supported.
    //

    DWORD dwNumEAZ;
    //
    //  The number of EAZs supported.
    //

    //
    //  variable length portion, if any, follows...
    //

} ISDN_STATIC_CAPS;

typedef struct // MODEM_CONFIG_HEADER
{
    DWORD dwSig;
    DWORD dwTotalSize;
    DWORD dwNextHeaderOffset;
    DWORD dwFlags;

} MODEM_CONFIG_HEADER;

typedef struct // MODEM_PROTOCOL_CAPS
{

    MODEM_CONFIG_HEADER hdr;
    //
    //      hdr.dwSig must be  set to dwSIG_MODEM_PROTOCOL_CAPS
    //      hdr.dwFlags are reserved and should be ignored by app.
    //
    #define dwSIG_MODEM_PROTOCOL_CAPS 0x35ccd4b3

    DWORD dwNumProtocols;
    //
    //  The number of protocols supported.
    //

    DWORD dwProtocolListOffset;
    //
    //  Offset to a DWORD array of protocols supported.
    //

    //
    //  variable length portion, if any, follows...
    //

} MODEM_PROTOCOL_CAPS;

typedef struct _PROTOCOL_ITEM {
    DWORD     dwProtocol;                  //   Protocol Supported

    DWORD     dwProtocolNameOffset;        //  Offset from beggining of MODEM_PROTOCOL_CAPS structure
                                           //  to NULL terminated friendly name of the protocol.
} PROTOCOL_ITEM, *PPROTOCOL_ITEM;



//=========================================================================
//
//      Modem install wizard structures and flags
//
//=========================================================================

#define UM_MAX_BUF_SHORT               32
#define UM_LINE_LEN                   256

#define MIPF_NT4_UNATTEND       0x1
    // Take the information about what modem to install
    // from the unattended.txt file
#define MIPF_DRIVER_SELECTED    0x2
    // The modem driver is selected, just register
    // and install it


// Unattended install parameters
typedef struct _tagUMInstallParams
{
    DWORD   Flags;                  // Flags that specify the unattended mode
    WCHAR   szPort[UM_MAX_BUF_SHORT];  // Port on which to install the modem
    WCHAR   szInfName[MAX_PATH];    // for NT4 method, inf name
    WCHAR   szSection[UM_LINE_LEN];    // for NT4 method, section name


} UM_INSTALLPARAMS, *PUM_INSTALLPARAMS, *LPUM_INSTALLPARAMS;


// This structure is the private structure that may be
// specified in the SP_INSTALLWIZARD_DATA's PrivateData field.
typedef struct tagUM_INSTALL_WIZARD
{
    DWORD            cbSize;             // set to the size of the structure
    DWORD            Reserved1;          // reserved, must be 0
    DWORD            Reserved2;          // reserved, must be 0
    LPARAM           Reserved3;          // reserved, must be 0
    UM_INSTALLPARAMS InstallParams;    // parameters for the wizard

} UM_INSTALL_WIZARD, *PUM_INSTALL_WIZARD, *LPUM_INSTALL_WIZARD;



//=========================================================================
//
//      Modem properties defines
//
//=========================================================================

#define REGSTR_VAL_DEVICEEXTRAPAGES   TEXT("DeviceExtraPages")  // Property pages provided by the device manufacturer

typedef BOOL (APIENTRY *PFNADDEXTRAPAGES)(HDEVINFO,PSP_DEVINFO_DATA,LPFNADDPROPSHEETPAGE,LPARAM);


#ifdef __cplusplus
}
#endif

#endif //  _UNIMODEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\txcoord.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for txcoord.idl:
    Os, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __txcoord_h__
#define __txcoord_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITransactionResourceAsync_FWD_DEFINED__
#define __ITransactionResourceAsync_FWD_DEFINED__
typedef interface ITransactionResourceAsync ITransactionResourceAsync;
#endif 	/* __ITransactionResourceAsync_FWD_DEFINED__ */


#ifndef __ITransactionLastResourceAsync_FWD_DEFINED__
#define __ITransactionLastResourceAsync_FWD_DEFINED__
typedef interface ITransactionLastResourceAsync ITransactionLastResourceAsync;
#endif 	/* __ITransactionLastResourceAsync_FWD_DEFINED__ */


#ifndef __ITransactionResource_FWD_DEFINED__
#define __ITransactionResource_FWD_DEFINED__
typedef interface ITransactionResource ITransactionResource;
#endif 	/* __ITransactionResource_FWD_DEFINED__ */


#ifndef __ITransactionEnlistmentAsync_FWD_DEFINED__
#define __ITransactionEnlistmentAsync_FWD_DEFINED__
typedef interface ITransactionEnlistmentAsync ITransactionEnlistmentAsync;
#endif 	/* __ITransactionEnlistmentAsync_FWD_DEFINED__ */


#ifndef __ITransactionLastEnlistmentAsync_FWD_DEFINED__
#define __ITransactionLastEnlistmentAsync_FWD_DEFINED__
typedef interface ITransactionLastEnlistmentAsync ITransactionLastEnlistmentAsync;
#endif 	/* __ITransactionLastEnlistmentAsync_FWD_DEFINED__ */


#ifndef __ITransactionExportFactory_FWD_DEFINED__
#define __ITransactionExportFactory_FWD_DEFINED__
typedef interface ITransactionExportFactory ITransactionExportFactory;
#endif 	/* __ITransactionExportFactory_FWD_DEFINED__ */


#ifndef __ITransactionImportWhereabouts_FWD_DEFINED__
#define __ITransactionImportWhereabouts_FWD_DEFINED__
typedef interface ITransactionImportWhereabouts ITransactionImportWhereabouts;
#endif 	/* __ITransactionImportWhereabouts_FWD_DEFINED__ */


#ifndef __ITransactionExport_FWD_DEFINED__
#define __ITransactionExport_FWD_DEFINED__
typedef interface ITransactionExport ITransactionExport;
#endif 	/* __ITransactionExport_FWD_DEFINED__ */


#ifndef __ITransactionImport_FWD_DEFINED__
#define __ITransactionImport_FWD_DEFINED__
typedef interface ITransactionImport ITransactionImport;
#endif 	/* __ITransactionImport_FWD_DEFINED__ */


#ifndef __ITipTransaction_FWD_DEFINED__
#define __ITipTransaction_FWD_DEFINED__
typedef interface ITipTransaction ITipTransaction;
#endif 	/* __ITipTransaction_FWD_DEFINED__ */


#ifndef __ITipHelper_FWD_DEFINED__
#define __ITipHelper_FWD_DEFINED__
typedef interface ITipHelper ITipHelper;
#endif 	/* __ITipHelper_FWD_DEFINED__ */


#ifndef __ITipPullSink_FWD_DEFINED__
#define __ITipPullSink_FWD_DEFINED__
typedef interface ITipPullSink ITipPullSink;
#endif 	/* __ITipPullSink_FWD_DEFINED__ */


/* header files for imported files */
#include "transact.h"
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_txcoord_0000 */
/* [local] */ 














extern RPC_IF_HANDLE __MIDL_itf_txcoord_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txcoord_0000_v0_0_s_ifspec;

#ifndef __ITransactionResourceAsync_INTERFACE_DEFINED__
#define __ITransactionResourceAsync_INTERFACE_DEFINED__

/* interface ITransactionResourceAsync */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionResourceAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69E971F0-23CE-11cf-AD60-00AA00A74CCD")
    ITransactionResourceAsync : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PrepareRequest( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfRM,
            /* [in] */ BOOL fWantMoniker,
            /* [in] */ BOOL fSinglePhase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitRequest( 
            /* [in] */ DWORD grfRM,
            /* [unique][in] */ XACTUOW *pNewUOW) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortRequest( 
            /* [unique][in] */ BOID *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ XACTUOW *pNewUOW) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TMDown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionResourceAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionResourceAsync * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionResourceAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionResourceAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *PrepareRequest )( 
            ITransactionResourceAsync * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfRM,
            /* [in] */ BOOL fWantMoniker,
            /* [in] */ BOOL fSinglePhase);
        
        HRESULT ( STDMETHODCALLTYPE *CommitRequest )( 
            ITransactionResourceAsync * This,
            /* [in] */ DWORD grfRM,
            /* [unique][in] */ XACTUOW *pNewUOW);
        
        HRESULT ( STDMETHODCALLTYPE *AbortRequest )( 
            ITransactionResourceAsync * This,
            /* [unique][in] */ BOID *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ XACTUOW *pNewUOW);
        
        HRESULT ( STDMETHODCALLTYPE *TMDown )( 
            ITransactionResourceAsync * This);
        
        END_INTERFACE
    } ITransactionResourceAsyncVtbl;

    interface ITransactionResourceAsync
    {
        CONST_VTBL struct ITransactionResourceAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionResourceAsync_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionResourceAsync_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionResourceAsync_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionResourceAsync_PrepareRequest(This,fRetaining,grfRM,fWantMoniker,fSinglePhase)	\
    (This)->lpVtbl -> PrepareRequest(This,fRetaining,grfRM,fWantMoniker,fSinglePhase)

#define ITransactionResourceAsync_CommitRequest(This,grfRM,pNewUOW)	\
    (This)->lpVtbl -> CommitRequest(This,grfRM,pNewUOW)

#define ITransactionResourceAsync_AbortRequest(This,pboidReason,fRetaining,pNewUOW)	\
    (This)->lpVtbl -> AbortRequest(This,pboidReason,fRetaining,pNewUOW)

#define ITransactionResourceAsync_TMDown(This)	\
    (This)->lpVtbl -> TMDown(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionResourceAsync_PrepareRequest_Proxy( 
    ITransactionResourceAsync * This,
    /* [in] */ BOOL fRetaining,
    /* [in] */ DWORD grfRM,
    /* [in] */ BOOL fWantMoniker,
    /* [in] */ BOOL fSinglePhase);


void __RPC_STUB ITransactionResourceAsync_PrepareRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionResourceAsync_CommitRequest_Proxy( 
    ITransactionResourceAsync * This,
    /* [in] */ DWORD grfRM,
    /* [unique][in] */ XACTUOW *pNewUOW);


void __RPC_STUB ITransactionResourceAsync_CommitRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionResourceAsync_AbortRequest_Proxy( 
    ITransactionResourceAsync * This,
    /* [unique][in] */ BOID *pboidReason,
    /* [in] */ BOOL fRetaining,
    /* [unique][in] */ XACTUOW *pNewUOW);


void __RPC_STUB ITransactionResourceAsync_AbortRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionResourceAsync_TMDown_Proxy( 
    ITransactionResourceAsync * This);


void __RPC_STUB ITransactionResourceAsync_TMDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionResourceAsync_INTERFACE_DEFINED__ */


#ifndef __ITransactionLastResourceAsync_INTERFACE_DEFINED__
#define __ITransactionLastResourceAsync_INTERFACE_DEFINED__

/* interface ITransactionLastResourceAsync */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionLastResourceAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C82BD532-5B30-11d3-8A91-00C04F79EB6D")
    ITransactionLastResourceAsync : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DelegateCommit( 
            /* [in] */ DWORD grfRM) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForgetRequest( 
            /* [in] */ XACTUOW *pNewUOW) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionLastResourceAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionLastResourceAsync * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionLastResourceAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionLastResourceAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *DelegateCommit )( 
            ITransactionLastResourceAsync * This,
            /* [in] */ DWORD grfRM);
        
        HRESULT ( STDMETHODCALLTYPE *ForgetRequest )( 
            ITransactionLastResourceAsync * This,
            /* [in] */ XACTUOW *pNewUOW);
        
        END_INTERFACE
    } ITransactionLastResourceAsyncVtbl;

    interface ITransactionLastResourceAsync
    {
        CONST_VTBL struct ITransactionLastResourceAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionLastResourceAsync_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionLastResourceAsync_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionLastResourceAsync_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionLastResourceAsync_DelegateCommit(This,grfRM)	\
    (This)->lpVtbl -> DelegateCommit(This,grfRM)

#define ITransactionLastResourceAsync_ForgetRequest(This,pNewUOW)	\
    (This)->lpVtbl -> ForgetRequest(This,pNewUOW)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionLastResourceAsync_DelegateCommit_Proxy( 
    ITransactionLastResourceAsync * This,
    /* [in] */ DWORD grfRM);


void __RPC_STUB ITransactionLastResourceAsync_DelegateCommit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionLastResourceAsync_ForgetRequest_Proxy( 
    ITransactionLastResourceAsync * This,
    /* [in] */ XACTUOW *pNewUOW);


void __RPC_STUB ITransactionLastResourceAsync_ForgetRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionLastResourceAsync_INTERFACE_DEFINED__ */


#ifndef __ITransactionResource_INTERFACE_DEFINED__
#define __ITransactionResource_INTERFACE_DEFINED__

/* interface ITransactionResource */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE5FF7B3-4572-11d0-9452-00A0C905416E")
    ITransactionResource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PrepareRequest( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfRM,
            /* [in] */ BOOL fWantMoniker,
            /* [in] */ BOOL fSinglePhase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitRequest( 
            /* [in] */ DWORD grfRM,
            /* [unique][in] */ XACTUOW *pNewUOW) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortRequest( 
            /* [unique][in] */ BOID *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ XACTUOW *pNewUOW) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TMDown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionResource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *PrepareRequest )( 
            ITransactionResource * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfRM,
            /* [in] */ BOOL fWantMoniker,
            /* [in] */ BOOL fSinglePhase);
        
        HRESULT ( STDMETHODCALLTYPE *CommitRequest )( 
            ITransactionResource * This,
            /* [in] */ DWORD grfRM,
            /* [unique][in] */ XACTUOW *pNewUOW);
        
        HRESULT ( STDMETHODCALLTYPE *AbortRequest )( 
            ITransactionResource * This,
            /* [unique][in] */ BOID *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ XACTUOW *pNewUOW);
        
        HRESULT ( STDMETHODCALLTYPE *TMDown )( 
            ITransactionResource * This);
        
        END_INTERFACE
    } ITransactionResourceVtbl;

    interface ITransactionResource
    {
        CONST_VTBL struct ITransactionResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionResource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionResource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionResource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionResource_PrepareRequest(This,fRetaining,grfRM,fWantMoniker,fSinglePhase)	\
    (This)->lpVtbl -> PrepareRequest(This,fRetaining,grfRM,fWantMoniker,fSinglePhase)

#define ITransactionResource_CommitRequest(This,grfRM,pNewUOW)	\
    (This)->lpVtbl -> CommitRequest(This,grfRM,pNewUOW)

#define ITransactionResource_AbortRequest(This,pboidReason,fRetaining,pNewUOW)	\
    (This)->lpVtbl -> AbortRequest(This,pboidReason,fRetaining,pNewUOW)

#define ITransactionResource_TMDown(This)	\
    (This)->lpVtbl -> TMDown(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionResource_PrepareRequest_Proxy( 
    ITransactionResource * This,
    /* [in] */ BOOL fRetaining,
    /* [in] */ DWORD grfRM,
    /* [in] */ BOOL fWantMoniker,
    /* [in] */ BOOL fSinglePhase);


void __RPC_STUB ITransactionResource_PrepareRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionResource_CommitRequest_Proxy( 
    ITransactionResource * This,
    /* [in] */ DWORD grfRM,
    /* [unique][in] */ XACTUOW *pNewUOW);


void __RPC_STUB ITransactionResource_CommitRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionResource_AbortRequest_Proxy( 
    ITransactionResource * This,
    /* [unique][in] */ BOID *pboidReason,
    /* [in] */ BOOL fRetaining,
    /* [unique][in] */ XACTUOW *pNewUOW);


void __RPC_STUB ITransactionResource_AbortRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionResource_TMDown_Proxy( 
    ITransactionResource * This);


void __RPC_STUB ITransactionResource_TMDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionResource_INTERFACE_DEFINED__ */


#ifndef __ITransactionEnlistmentAsync_INTERFACE_DEFINED__
#define __ITransactionEnlistmentAsync_INTERFACE_DEFINED__

/* interface ITransactionEnlistmentAsync */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionEnlistmentAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0fb15081-af41-11ce-bd2b-204c4f4f5020")
    ITransactionEnlistmentAsync : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PrepareRequestDone( 
            /* [in] */ HRESULT hr,
            /* [unique][in] */ IMoniker *pmk,
            /* [unique][in] */ BOID *pboidReason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitRequestDone( 
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortRequestDone( 
            /* [in] */ HRESULT hr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionEnlistmentAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionEnlistmentAsync * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionEnlistmentAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionEnlistmentAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *PrepareRequestDone )( 
            ITransactionEnlistmentAsync * This,
            /* [in] */ HRESULT hr,
            /* [unique][in] */ IMoniker *pmk,
            /* [unique][in] */ BOID *pboidReason);
        
        HRESULT ( STDMETHODCALLTYPE *CommitRequestDone )( 
            ITransactionEnlistmentAsync * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *AbortRequestDone )( 
            ITransactionEnlistmentAsync * This,
            /* [in] */ HRESULT hr);
        
        END_INTERFACE
    } ITransactionEnlistmentAsyncVtbl;

    interface ITransactionEnlistmentAsync
    {
        CONST_VTBL struct ITransactionEnlistmentAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionEnlistmentAsync_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionEnlistmentAsync_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionEnlistmentAsync_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionEnlistmentAsync_PrepareRequestDone(This,hr,pmk,pboidReason)	\
    (This)->lpVtbl -> PrepareRequestDone(This,hr,pmk,pboidReason)

#define ITransactionEnlistmentAsync_CommitRequestDone(This,hr)	\
    (This)->lpVtbl -> CommitRequestDone(This,hr)

#define ITransactionEnlistmentAsync_AbortRequestDone(This,hr)	\
    (This)->lpVtbl -> AbortRequestDone(This,hr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionEnlistmentAsync_PrepareRequestDone_Proxy( 
    ITransactionEnlistmentAsync * This,
    /* [in] */ HRESULT hr,
    /* [unique][in] */ IMoniker *pmk,
    /* [unique][in] */ BOID *pboidReason);


void __RPC_STUB ITransactionEnlistmentAsync_PrepareRequestDone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionEnlistmentAsync_CommitRequestDone_Proxy( 
    ITransactionEnlistmentAsync * This,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionEnlistmentAsync_CommitRequestDone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionEnlistmentAsync_AbortRequestDone_Proxy( 
    ITransactionEnlistmentAsync * This,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionEnlistmentAsync_AbortRequestDone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionEnlistmentAsync_INTERFACE_DEFINED__ */


#ifndef __ITransactionLastEnlistmentAsync_INTERFACE_DEFINED__
#define __ITransactionLastEnlistmentAsync_INTERFACE_DEFINED__

/* interface ITransactionLastEnlistmentAsync */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionLastEnlistmentAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C82BD533-5B30-11d3-8A91-00C04F79EB6D")
    ITransactionLastEnlistmentAsync : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TransactionOutcome( 
            /* [in] */ XACTSTAT XactStat,
            /* [unique][in] */ BOID *pboidReason) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionLastEnlistmentAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionLastEnlistmentAsync * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionLastEnlistmentAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionLastEnlistmentAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *TransactionOutcome )( 
            ITransactionLastEnlistmentAsync * This,
            /* [in] */ XACTSTAT XactStat,
            /* [unique][in] */ BOID *pboidReason);
        
        END_INTERFACE
    } ITransactionLastEnlistmentAsyncVtbl;

    interface ITransactionLastEnlistmentAsync
    {
        CONST_VTBL struct ITransactionLastEnlistmentAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionLastEnlistmentAsync_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionLastEnlistmentAsync_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionLastEnlistmentAsync_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionLastEnlistmentAsync_TransactionOutcome(This,XactStat,pboidReason)	\
    (This)->lpVtbl -> TransactionOutcome(This,XactStat,pboidReason)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionLastEnlistmentAsync_TransactionOutcome_Proxy( 
    ITransactionLastEnlistmentAsync * This,
    /* [in] */ XACTSTAT XactStat,
    /* [unique][in] */ BOID *pboidReason);


void __RPC_STUB ITransactionLastEnlistmentAsync_TransactionOutcome_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionLastEnlistmentAsync_INTERFACE_DEFINED__ */


#ifndef __ITransactionExportFactory_INTERFACE_DEFINED__
#define __ITransactionExportFactory_INTERFACE_DEFINED__

/* interface ITransactionExportFactory */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionExportFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1CF9B53-8745-11ce-A9BA-00AA006C3706")
    ITransactionExportFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRemoteClassId( 
            /* [out] */ CLSID *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ ULONG cbWhereabouts,
            /* [size_is][in] */ byte *rgbWhereabouts,
            /* [out] */ ITransactionExport **ppExport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionExportFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionExportFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionExportFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionExportFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteClassId )( 
            ITransactionExportFactory * This,
            /* [out] */ CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            ITransactionExportFactory * This,
            /* [in] */ ULONG cbWhereabouts,
            /* [size_is][in] */ byte *rgbWhereabouts,
            /* [out] */ ITransactionExport **ppExport);
        
        END_INTERFACE
    } ITransactionExportFactoryVtbl;

    interface ITransactionExportFactory
    {
        CONST_VTBL struct ITransactionExportFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionExportFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionExportFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionExportFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionExportFactory_GetRemoteClassId(This,pclsid)	\
    (This)->lpVtbl -> GetRemoteClassId(This,pclsid)

#define ITransactionExportFactory_Create(This,cbWhereabouts,rgbWhereabouts,ppExport)	\
    (This)->lpVtbl -> Create(This,cbWhereabouts,rgbWhereabouts,ppExport)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionExportFactory_GetRemoteClassId_Proxy( 
    ITransactionExportFactory * This,
    /* [out] */ CLSID *pclsid);


void __RPC_STUB ITransactionExportFactory_GetRemoteClassId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionExportFactory_Create_Proxy( 
    ITransactionExportFactory * This,
    /* [in] */ ULONG cbWhereabouts,
    /* [size_is][in] */ byte *rgbWhereabouts,
    /* [out] */ ITransactionExport **ppExport);


void __RPC_STUB ITransactionExportFactory_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionExportFactory_INTERFACE_DEFINED__ */


#ifndef __ITransactionImportWhereabouts_INTERFACE_DEFINED__
#define __ITransactionImportWhereabouts_INTERFACE_DEFINED__

/* interface ITransactionImportWhereabouts */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionImportWhereabouts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0141fda4-8fc0-11ce-bd18-204c4f4f5020")
    ITransactionImportWhereabouts : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWhereaboutsSize( 
            /* [out] */ ULONG *pcbWhereabouts) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetWhereabouts( 
            /* [in] */ ULONG cbWhereabouts,
            /* [size_is][out] */ byte *rgbWhereabouts,
            /* [out] */ ULONG *pcbUsed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionImportWhereaboutsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionImportWhereabouts * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionImportWhereabouts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionImportWhereabouts * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWhereaboutsSize )( 
            ITransactionImportWhereabouts * This,
            /* [out] */ ULONG *pcbWhereabouts);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetWhereabouts )( 
            ITransactionImportWhereabouts * This,
            /* [in] */ ULONG cbWhereabouts,
            /* [size_is][out] */ byte *rgbWhereabouts,
            /* [out] */ ULONG *pcbUsed);
        
        END_INTERFACE
    } ITransactionImportWhereaboutsVtbl;

    interface ITransactionImportWhereabouts
    {
        CONST_VTBL struct ITransactionImportWhereaboutsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionImportWhereabouts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionImportWhereabouts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionImportWhereabouts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionImportWhereabouts_GetWhereaboutsSize(This,pcbWhereabouts)	\
    (This)->lpVtbl -> GetWhereaboutsSize(This,pcbWhereabouts)

#define ITransactionImportWhereabouts_GetWhereabouts(This,cbWhereabouts,rgbWhereabouts,pcbUsed)	\
    (This)->lpVtbl -> GetWhereabouts(This,cbWhereabouts,rgbWhereabouts,pcbUsed)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionImportWhereabouts_GetWhereaboutsSize_Proxy( 
    ITransactionImportWhereabouts * This,
    /* [out] */ ULONG *pcbWhereabouts);


void __RPC_STUB ITransactionImportWhereabouts_GetWhereaboutsSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionImportWhereabouts_RemoteGetWhereabouts_Proxy( 
    ITransactionImportWhereabouts * This,
    /* [out] */ ULONG *pcbUsed,
    /* [in] */ ULONG cbWhereabouts,
    /* [length_is][size_is][out] */ byte *rgbWhereabouts);


void __RPC_STUB ITransactionImportWhereabouts_RemoteGetWhereabouts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionImportWhereabouts_INTERFACE_DEFINED__ */


#ifndef __ITransactionExport_INTERFACE_DEFINED__
#define __ITransactionExport_INTERFACE_DEFINED__

/* interface ITransactionExport */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionExport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0141fda5-8fc0-11ce-bd18-204c4f4f5020")
    ITransactionExport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Export( 
            /* [in] */ IUnknown *punkTransaction,
            /* [out] */ ULONG *pcbTransactionCookie) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetTransactionCookie( 
            /* [in] */ IUnknown *punkTransaction,
            /* [in] */ ULONG cbTransactionCookie,
            /* [size_is][out] */ byte *rgbTransactionCookie,
            /* [out] */ ULONG *pcbUsed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionExportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionExport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionExport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionExport * This);
        
        HRESULT ( STDMETHODCALLTYPE *Export )( 
            ITransactionExport * This,
            /* [in] */ IUnknown *punkTransaction,
            /* [out] */ ULONG *pcbTransactionCookie);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetTransactionCookie )( 
            ITransactionExport * This,
            /* [in] */ IUnknown *punkTransaction,
            /* [in] */ ULONG cbTransactionCookie,
            /* [size_is][out] */ byte *rgbTransactionCookie,
            /* [out] */ ULONG *pcbUsed);
        
        END_INTERFACE
    } ITransactionExportVtbl;

    interface ITransactionExport
    {
        CONST_VTBL struct ITransactionExportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionExport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionExport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionExport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionExport_Export(This,punkTransaction,pcbTransactionCookie)	\
    (This)->lpVtbl -> Export(This,punkTransaction,pcbTransactionCookie)

#define ITransactionExport_GetTransactionCookie(This,punkTransaction,cbTransactionCookie,rgbTransactionCookie,pcbUsed)	\
    (This)->lpVtbl -> GetTransactionCookie(This,punkTransaction,cbTransactionCookie,rgbTransactionCookie,pcbUsed)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionExport_Export_Proxy( 
    ITransactionExport * This,
    /* [in] */ IUnknown *punkTransaction,
    /* [out] */ ULONG *pcbTransactionCookie);


void __RPC_STUB ITransactionExport_Export_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionExport_RemoteGetTransactionCookie_Proxy( 
    ITransactionExport * This,
    /* [in] */ IUnknown *punkTransaction,
    /* [out] */ ULONG *pcbUsed,
    /* [in] */ ULONG cbTransactionCookie,
    /* [length_is][size_is][out] */ byte *rgbTransactionCookie);


void __RPC_STUB ITransactionExport_RemoteGetTransactionCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionExport_INTERFACE_DEFINED__ */


#ifndef __ITransactionImport_INTERFACE_DEFINED__
#define __ITransactionImport_INTERFACE_DEFINED__

/* interface ITransactionImport */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1CF9B5A-8745-11ce-A9BA-00AA006C3706")
    ITransactionImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Import( 
            /* [in] */ ULONG cbTransactionCookie,
            /* [size_is][in] */ byte *rgbTransactionCookie,
            /* [in] */ IID *piid,
            /* [iid_is][out] */ void **ppvTransaction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionImportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionImport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionImport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionImport * This);
        
        HRESULT ( STDMETHODCALLTYPE *Import )( 
            ITransactionImport * This,
            /* [in] */ ULONG cbTransactionCookie,
            /* [size_is][in] */ byte *rgbTransactionCookie,
            /* [in] */ IID *piid,
            /* [iid_is][out] */ void **ppvTransaction);
        
        END_INTERFACE
    } ITransactionImportVtbl;

    interface ITransactionImport
    {
        CONST_VTBL struct ITransactionImportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionImport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionImport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionImport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionImport_Import(This,cbTransactionCookie,rgbTransactionCookie,piid,ppvTransaction)	\
    (This)->lpVtbl -> Import(This,cbTransactionCookie,rgbTransactionCookie,piid,ppvTransaction)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionImport_Import_Proxy( 
    ITransactionImport * This,
    /* [in] */ ULONG cbTransactionCookie,
    /* [size_is][in] */ byte *rgbTransactionCookie,
    /* [in] */ IID *piid,
    /* [iid_is][out] */ void **ppvTransaction);


void __RPC_STUB ITransactionImport_Import_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionImport_INTERFACE_DEFINED__ */


#ifndef __ITipTransaction_INTERFACE_DEFINED__
#define __ITipTransaction_INTERFACE_DEFINED__

/* interface ITipTransaction */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITipTransaction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17CF72D0-BAC5-11d1-B1BF-00C04FC2F3EF")
    ITipTransaction : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Push( 
            /* [in] */ char *i_pszRemoteTmUrl,
            /* [out] */ char **o_ppszRemoteTxUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransactionUrl( 
            /* [out] */ char **o_ppszLocalTxUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITipTransactionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITipTransaction * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITipTransaction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITipTransaction * This);
        
        HRESULT ( STDMETHODCALLTYPE *Push )( 
            ITipTransaction * This,
            /* [in] */ char *i_pszRemoteTmUrl,
            /* [out] */ char **o_ppszRemoteTxUrl);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransactionUrl )( 
            ITipTransaction * This,
            /* [out] */ char **o_ppszLocalTxUrl);
        
        END_INTERFACE
    } ITipTransactionVtbl;

    interface ITipTransaction
    {
        CONST_VTBL struct ITipTransactionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITipTransaction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITipTransaction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITipTransaction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITipTransaction_Push(This,i_pszRemoteTmUrl,o_ppszRemoteTxUrl)	\
    (This)->lpVtbl -> Push(This,i_pszRemoteTmUrl,o_ppszRemoteTxUrl)

#define ITipTransaction_GetTransactionUrl(This,o_ppszLocalTxUrl)	\
    (This)->lpVtbl -> GetTransactionUrl(This,o_ppszLocalTxUrl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITipTransaction_Push_Proxy( 
    ITipTransaction * This,
    /* [in] */ char *i_pszRemoteTmUrl,
    /* [out] */ char **o_ppszRemoteTxUrl);


void __RPC_STUB ITipTransaction_Push_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITipTransaction_GetTransactionUrl_Proxy( 
    ITipTransaction * This,
    /* [out] */ char **o_ppszLocalTxUrl);


void __RPC_STUB ITipTransaction_GetTransactionUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITipTransaction_INTERFACE_DEFINED__ */


#ifndef __ITipHelper_INTERFACE_DEFINED__
#define __ITipHelper_INTERFACE_DEFINED__

/* interface ITipHelper */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITipHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17CF72D1-BAC5-11d1-B1BF-00C04FC2F3EF")
    ITipHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Pull( 
            /* [in] */ char *i_pszTxUrl,
            /* [out] */ ITransaction **o_ppITransaction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PullAsync( 
            /* [in] */ char *i_pszTxUrl,
            /* [in] */ ITipPullSink *i_pTipPullSink,
            /* [out] */ ITransaction **o_ppITransaction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalTmUrl( 
            /* [out] */ char **o_ppszLocalTmUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITipHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITipHelper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITipHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITipHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pull )( 
            ITipHelper * This,
            /* [in] */ char *i_pszTxUrl,
            /* [out] */ ITransaction **o_ppITransaction);
        
        HRESULT ( STDMETHODCALLTYPE *PullAsync )( 
            ITipHelper * This,
            /* [in] */ char *i_pszTxUrl,
            /* [in] */ ITipPullSink *i_pTipPullSink,
            /* [out] */ ITransaction **o_ppITransaction);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalTmUrl )( 
            ITipHelper * This,
            /* [out] */ char **o_ppszLocalTmUrl);
        
        END_INTERFACE
    } ITipHelperVtbl;

    interface ITipHelper
    {
        CONST_VTBL struct ITipHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITipHelper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITipHelper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITipHelper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITipHelper_Pull(This,i_pszTxUrl,o_ppITransaction)	\
    (This)->lpVtbl -> Pull(This,i_pszTxUrl,o_ppITransaction)

#define ITipHelper_PullAsync(This,i_pszTxUrl,i_pTipPullSink,o_ppITransaction)	\
    (This)->lpVtbl -> PullAsync(This,i_pszTxUrl,i_pTipPullSink,o_ppITransaction)

#define ITipHelper_GetLocalTmUrl(This,o_ppszLocalTmUrl)	\
    (This)->lpVtbl -> GetLocalTmUrl(This,o_ppszLocalTmUrl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITipHelper_Pull_Proxy( 
    ITipHelper * This,
    /* [in] */ char *i_pszTxUrl,
    /* [out] */ ITransaction **o_ppITransaction);


void __RPC_STUB ITipHelper_Pull_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITipHelper_PullAsync_Proxy( 
    ITipHelper * This,
    /* [in] */ char *i_pszTxUrl,
    /* [in] */ ITipPullSink *i_pTipPullSink,
    /* [out] */ ITransaction **o_ppITransaction);


void __RPC_STUB ITipHelper_PullAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITipHelper_GetLocalTmUrl_Proxy( 
    ITipHelper * This,
    /* [out] */ char **o_ppszLocalTmUrl);


void __RPC_STUB ITipHelper_GetLocalTmUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITipHelper_INTERFACE_DEFINED__ */


#ifndef __ITipPullSink_INTERFACE_DEFINED__
#define __ITipPullSink_INTERFACE_DEFINED__

/* interface ITipPullSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITipPullSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17CF72D2-BAC5-11d1-B1BF-00C04FC2F3EF")
    ITipPullSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PullComplete( 
            /* [in] */ HRESULT i_hrPull) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITipPullSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITipPullSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITipPullSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITipPullSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *PullComplete )( 
            ITipPullSink * This,
            /* [in] */ HRESULT i_hrPull);
        
        END_INTERFACE
    } ITipPullSinkVtbl;

    interface ITipPullSink
    {
        CONST_VTBL struct ITipPullSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITipPullSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITipPullSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITipPullSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITipPullSink_PullComplete(This,i_hrPull)	\
    (This)->lpVtbl -> PullComplete(This,i_hrPull)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITipPullSink_PullComplete_Proxy( 
    ITipPullSink * This,
    /* [in] */ HRESULT i_hrPull);


void __RPC_STUB ITipPullSink_PullComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITipPullSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_txcoord_0104 */
/* [local] */ 



#if _MSC_VER < 1100 || !defined(__cplusplus)

DEFINE_GUID(IID_ITransactionResourceAsync,		0x69E971F0, 0x23CE, 0x11cf, 0xAD, 0x60, 0x00, 0xAA, 0x00, 0xA7, 0x4C, 0xCD);
DEFINE_GUID(IID_ITransactionLastResourceAsync,	0xC82BD532, 0x5B30, 0x11D3, 0x8A, 0x91, 0x00, 0xC0, 0x4F, 0x79, 0xEB, 0x6D);
DEFINE_GUID(IID_ITransactionResource,			0xEE5FF7B3, 0x4572, 0x11d0, 0x94, 0x52, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_ITransactionEnlistmentAsync,		0x0fb15081, 0xaf41, 0x11ce, 0xbd, 0x2b, 0x20, 0x4c, 0x4f, 0x4f, 0x50, 0x20);
DEFINE_GUID(IID_ITransactionLastEnlistmentAsync,	0xC82BD533, 0x5B30, 0x11D3, 0x8A, 0x91, 0x00, 0xC0, 0x4F, 0x79, 0xEB, 0x6D);
DEFINE_GUID(IID_ITransactionExportFactory,		0xE1CF9B53, 0x8745, 0x11ce, 0xA9, 0xBA, 0x00, 0xAA, 0x00, 0x6C, 0x37, 0x06);
DEFINE_GUID(IID_ITransactionImportWhereabouts,	0x0141fda4, 0x8fc0, 0x11ce, 0xbd, 0x18, 0x20, 0x4c, 0x4f, 0x4f, 0x50, 0x20);
DEFINE_GUID(IID_ITransactionExport,				0x0141fda5, 0x8fc0, 0x11ce, 0xbd, 0x18, 0x20, 0x4c, 0x4f, 0x4f, 0x50, 0x20);
DEFINE_GUID(IID_ITransactionImport,				0xE1CF9B5A, 0x8745, 0x11ce, 0xA9, 0xBA, 0x00, 0xAA, 0x00, 0x6C, 0x37, 0x06);
DEFINE_GUID(IID_ITipTransaction,					0x17cf72d0, 0xbac5, 0x11d1, 0xb1, 0xbf, 0x0, 0xc0, 0x4f, 0xc2, 0xf3, 0xef);
DEFINE_GUID(IID_ITipHelper,						0x17cf72d1, 0xbac5, 0x11d1, 0xb1, 0xbf, 0x0, 0xc0, 0x4f, 0xc2, 0xf3, 0xef);
DEFINE_GUID(IID_ITipPullSink,					0x17cf72d2, 0xbac5, 0x11d1, 0xb1, 0xbf, 0x0, 0xc0, 0x4f, 0xc2, 0xf3, 0xef);

#else

#define  IID_ITransactionResourceAsync               __uuidof(ITransactionResourceAsync)
#define  IID_ITransactionLastResourceAsync           __uuidof(ITransactionLastResourceAsync)
#define  IID_ITransactionResource                    __uuidof(ITransactionResource)
#define  IID_ITransactionEnlistmentAsync             __uuidof(ITransactionEnlistmentAsync)
#define  IID_ITransactionLastEnlistmentAsync             __uuidof(ITransactionLastEnlistmentAsync)
#define  IID_ITransactionExportFactory               __uuidof(ITransactionExportFactory)
#define  IID_ITransactionImportWhereabouts           __uuidof(ITransactionImportWhereabouts)
#define  IID_ITransactionExport                      __uuidof(ITransactionExport)
#define  IID_ITransactionImport                      __uuidof(ITransactionImport)
#define  IID_ITipTransaction                         __uuidof(ITipTransaction)
#define  IID_ITipHelper                              __uuidof(ITipHelper)
#define  IID_ITipPullSink                            __uuidof(ITipPullSink)

#endif


extern RPC_IF_HANDLE __MIDL_itf_txcoord_0104_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txcoord_0104_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE ITransactionImportWhereabouts_GetWhereabouts_Proxy( 
    ITransactionImportWhereabouts * This,
    /* [in] */ ULONG cbWhereabouts,
    /* [size_is][out] */ byte *rgbWhereabouts,
    /* [out] */ ULONG *pcbUsed);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionImportWhereabouts_GetWhereabouts_Stub( 
    ITransactionImportWhereabouts * This,
    /* [out] */ ULONG *pcbUsed,
    /* [in] */ ULONG cbWhereabouts,
    /* [length_is][size_is][out] */ byte *rgbWhereabouts);

/* [local] */ HRESULT STDMETHODCALLTYPE ITransactionExport_GetTransactionCookie_Proxy( 
    ITransactionExport * This,
    /* [in] */ IUnknown *punkTransaction,
    /* [in] */ ULONG cbTransactionCookie,
    /* [size_is][out] */ byte *rgbTransactionCookie,
    /* [out] */ ULONG *pcbUsed);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionExport_GetTransactionCookie_Stub( 
    ITransactionExport * This,
    /* [in] */ IUnknown *punkTransaction,
    /* [out] */ ULONG *pcbUsed,
    /* [in] */ ULONG cbTransactionCookie,
    /* [length_is][size_is][out] */ byte *rgbTransactionCookie);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vdmdbg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1985-1999, Microsoft Corporation

Module Name:

    vdmdbg.h

Abstract:

    Prodecure declarations, constant definitions, type definition and macros
    for the VDMDBG.DLL VDM Debugger interface.

--*/

#ifndef _VDMDBG_
#define _VDMDBG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <pshpack4.h>

#define STATUS_VDM_EVENT    STATUS_SEGMENT_NOTIFICATION

#ifndef DBG_SEGLOAD
#define DBG_SEGLOAD     0
#define DBG_SEGMOVE     1
#define DBG_SEGFREE     2
#define DBG_MODLOAD     3
#define DBG_MODFREE     4
#define DBG_SINGLESTEP  5
#define DBG_BREAK       6
#define DBG_GPFAULT     7
#define DBG_DIVOVERFLOW 8
#define DBG_INSTRFAULT  9
#define DBG_TASKSTART   10
#define DBG_TASKSTOP    11
#define DBG_DLLSTART    12
#define DBG_DLLSTOP     13
#define DBG_ATTACH      14
#define DBG_TOOLHELP    15
#define DBG_STACKFAULT  16
#define DBG_WOWINIT     17
#define DBG_TEMPBP      18
#define DBG_MODMOVE     19
#define DBG_INIT        20
#define DBG_GPFAULT2    21
#endif

//
// These flags are set in the same WORD as the DBG_ event id's (above).
//
#define VDMEVENT_NEEDS_INTERACTIVE  0x8000
#define VDMEVENT_VERBOSE            0x4000
#define VDMEVENT_PE                 0x2000
#define VDMEVENT_ALLFLAGS           0xe000
//
// These flags are set in the second WORD of the exception event
// parameters.
//
#define VDMEVENT_V86                0x0001
#define VDMEVENT_PM16               0x0002

//
// The following flags control the contents of the CONTEXT structure.
//

#define VDMCONTEXT_i386    0x00010000    // this assumes that i386 and
#define VDMCONTEXT_i486    0x00010000    // i486 have identical context records

#define VDMCONTEXT_CONTROL         (VDMCONTEXT_i386 | 0x00000001L) // SS:SP, CS:IP, FLAGS, BP
#define VDMCONTEXT_INTEGER         (VDMCONTEXT_i386 | 0x00000002L) // AX, BX, CX, DX, SI, DI
#define VDMCONTEXT_SEGMENTS        (VDMCONTEXT_i386 | 0x00000004L) // DS, ES, FS, GS
#define VDMCONTEXT_FLOATING_POINT  (VDMCONTEXT_i386 | 0x00000008L) // 387 state
#define VDMCONTEXT_DEBUG_REGISTERS (VDMCONTEXT_i386 | 0x00000010L) // DB 0-3,6,7
#define VDMCONTEXT_EXTENDED_REGISTERS  (VDMCONTEXT_i386 | 0x00000020L) // cpu specific extensions

#define VDMCONTEXT_FULL (VDMCONTEXT_CONTROL | VDMCONTEXT_INTEGER |\
                      VDMCONTEXT_SEGMENTS)


#ifdef _X86_

// On x86 machines, just copy the definition of the CONTEXT and LDT_ENTRY
// structures.
typedef struct _CONTEXT VDMCONTEXT;
typedef struct _LDT_ENTRY VDMLDT_ENTRY;

#else // _X86_

//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define SIZE_OF_80387_REGISTERS      80

typedef struct _FLOATING_SAVE_AREA {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   TagWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    UCHAR   RegisterArea[SIZE_OF_80387_REGISTERS];
    ULONG   Cr0NpxState;
} FLOATING_SAVE_AREA;

//
// Simulated context structure for the 16-bit environment
//

typedef struct _VDMCONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //
    // CONTEXT_FULL on some systems (MIPS namely) does not contain the
    // CONTEXT_SEGMENTS definition.  VDMDBG assumes that CONTEXT_INTEGER also
    // includes CONTEXT_SEGMENTS to account for this.
    //

    ULONG ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    ULONG   SegGs;
    ULONG   SegFs;
    ULONG   SegEs;
    ULONG   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    ULONG   Ebp;
    ULONG   Eip;
    ULONG   SegCs;              // MUST BE SANITIZED
    ULONG   EFlags;             // MUST BE SANITIZED
    ULONG   Esp;
    ULONG   SegSs;

} VDMCONTEXT;

//
//  LDT descriptor entry
//

typedef struct _VDMLDT_ENTRY {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} VDMLDT_ENTRY;

#endif // _X86_

typedef VDMCONTEXT *LPVDMCONTEXT;
typedef VDMLDT_ENTRY *LPVDMLDT_ENTRY;

#define VDMCONTEXT_TO_PROGRAM_COUNTER(Context) (PVOID)((Context)->Eip)

#define VDMCONTEXT_LENGTH  (sizeof(VDMCONTEXT))
#define VDMCONTEXT_ALIGN   (sizeof(ULONG))
#define VDMCONTEXT_ROUND   (VDMCONTEXT_ALIGN - 1)

#define V86FLAGS_CARRY      0x00001
#define V86FLAGS_PARITY     0x00004
#define V86FLAGS_AUXCARRY   0x00010
#define V86FLAGS_ZERO       0x00040
#define V86FLAGS_SIGN       0x00080
#define V86FLAGS_TRACE      0x00100
#define V86FLAGS_INTERRUPT  0x00200
#define V86FLAGS_DIRECTION  0x00400
#define V86FLAGS_OVERFLOW   0x00800
#define V86FLAGS_IOPL       0x03000
#define V86FLAGS_IOPL_BITS  0x12
#define V86FLAGS_RESUME     0x10000
#define V86FLAGS_V86        0x20000     // Used to detect RealMode v. ProtMode
#define V86FLAGS_ALIGNMENT  0x40000

#define MAX_MODULE_NAME  8 + 1
#define MAX_PATH16      255

typedef struct _SEGMENT_NOTE {
    WORD    Selector1;                      // Selector of operation
    WORD    Selector2;                      // Dest. Sel. for moving segments
    WORD    Segment;                        // Segment within Module
    CHAR    Module[MAX_MODULE_NAME+1];      // Module name
    CHAR    FileName[MAX_PATH16+1];         // PathName to executable image
    WORD    Type;                           // Code / Data, etc.
    DWORD   Length;                         // Length of image
} SEGMENT_NOTE;

typedef struct _IMAGE_NOTE {
    CHAR    Module[MAX_MODULE_NAME+1];      // Module
    CHAR    FileName[MAX_PATH16+1];         // Path to executable image
    WORD    hModule;                        // 16-bit hModule
    WORD    hTask;                          // 16-bit hTask
} IMAGE_NOTE;

typedef struct {
    DWORD   dwSize;
    char    szModule[MAX_MODULE_NAME+1];
    HANDLE  hModule;
    WORD    wcUsage;
    char    szExePath[MAX_PATH16+1];
    WORD    wNext;
} MODULEENTRY, *LPMODULEENTRY;


#define SN_CODE 0                           // Protect mode code segment
#define SN_DATA 1                           // Protect mode data segment
#define SN_V86  2                           // V86 mode segment

typedef struct _TEMP_BP_NOTE {
    WORD    Seg;                            // Dest. Segment or Selector
    DWORD   Offset;                         // Dest. Offset
    BOOL    bPM;                            // TRUE for PM, FALSE for V86
} TEMP_BP_NOTE;

typedef struct _VDM_SEGINFO {
    WORD    Selector;                       // Selector or RM segment
    WORD    SegNumber;                      // Logical segment number in executable
    DWORD   Length;                         // Length of segment
    WORD    Type;                           // Type (0=v86, 1=PM)
    CHAR    ModuleName[MAX_MODULE_NAME];    // Module
    CHAR    FileName[MAX_PATH16];           // Path to executable image
} VDM_SEGINFO;

/* GlobalFirst()/GlobalNext() flags */
#define GLOBAL_ALL      0
#define GLOBAL_LRU      1
#define GLOBAL_FREE     2

/* GLOBALENTRY.wType entries */
#define GT_UNKNOWN      0
#define GT_DGROUP       1
#define GT_DATA         2
#define GT_CODE         3
#define GT_TASK         4
#define GT_RESOURCE     5
#define GT_MODULE       6
#define GT_FREE         7
#define GT_INTERNAL     8
#define GT_SENTINEL     9
#define GT_BURGERMASTER 10

/* If GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData: */
#define GD_USERDEFINED      0
#define GD_CURSORCOMPONENT  1
#define GD_BITMAP           2
#define GD_ICONCOMPONENT    3
#define GD_MENU             4
#define GD_DIALOG           5
#define GD_STRING           6
#define GD_FONTDIR          7
#define GD_FONT             8
#define GD_ACCELERATORS     9
#define GD_RCDATA           10
#define GD_ERRTABLE         11
#define GD_CURSOR           12
#define GD_ICON             14
#define GD_NAMETABLE        15
#define GD_MAX_RESOURCE     15

typedef struct {
    DWORD   dwSize;
    DWORD   dwAddress;
    DWORD   dwBlockSize;
    HANDLE  hBlock;
    WORD    wcLock;
    WORD    wcPageLock;
    WORD    wFlags;
    BOOL    wHeapPresent;
    HANDLE  hOwner;
    WORD    wType;
    WORD    wData;
    DWORD   dwNext;
    DWORD   dwNextAlt;
} GLOBALENTRY, *LPGLOBALENTRY;

typedef DWORD (CALLBACK* DEBUGEVENTPROC)( LPDEBUG_EVENT, LPVOID );

// Macros to access VDM_EVENT parameters
#define W1(x) ((USHORT)(x.ExceptionInformation[0]))
#define W2(x) ((USHORT)(x.ExceptionInformation[0] >> 16))
#define W3(x) ((USHORT)(x.ExceptionInformation[1]))
#define W4(x) ((USHORT)(x.ExceptionInformation[1] >> 16))
#define DW3(x) (x.ExceptionInformation[2])
#define DW4(x) (x.ExceptionInformation[3])

#include <poppack.h>


BOOL
WINAPI
VDMProcessException(
    LPDEBUG_EVENT   lpDebugEvent
    );

BOOL
WINAPI
VDMGetThreadSelectorEntry(
    HANDLE          hProcess,
    HANDLE          hThread,
    WORD            wSelector,
    LPVDMLDT_ENTRY  lpSelectorEntry
    );

ULONG
WINAPI
VDMGetPointer(
    HANDLE          hProcess,
    HANDLE          hThread,
    WORD            wSelector,
    DWORD           dwOffset,
    BOOL            fProtMode
    );

// VDMGetThreadContext, VDMSetThreadContext are obselete
// Use VDMGetContext, VDMSetContext
BOOL
WINAPI
VDMGetContext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPVDMCONTEXT    lpVDMContext
);

BOOL
WINAPI
VDMSetContext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPVDMCONTEXT    lpVDMContext
);

BOOL
WINAPI
VDMGetSelectorModule(
    HANDLE          hProcess,
    HANDLE          hThread,
    WORD            wSelector,
    PUINT           lpSegmentNumber,
    LPSTR           lpModuleName,
    UINT            nNameSize,
    LPSTR           lpModulePath,
    UINT            nPathSize
);

BOOL
WINAPI
VDMGetModuleSelector(
    HANDLE          hProcess,
    HANDLE          hThread,
    UINT            wSegmentNumber,
    LPSTR           lpModuleName,
    LPWORD          lpSelector
);

BOOL
WINAPI
VDMModuleFirst(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPMODULEENTRY   lpModuleEntry,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

BOOL
WINAPI
VDMModuleNext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPMODULEENTRY   lpModuleEntry,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

BOOL
WINAPI
VDMGlobalFirst(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPGLOBALENTRY   lpGlobalEntry,
    WORD            wFlags,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

BOOL
WINAPI
VDMGlobalNext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPGLOBALENTRY   lpGlobalEntry,
    WORD            wFlags,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

typedef BOOL (WINAPI *PROCESSENUMPROC)( DWORD dwProcessId, DWORD dwAttributes, LPARAM lpUserDefined );
typedef BOOL (WINAPI *TASKENUMPROC)( DWORD dwThreadId, WORD hMod16, WORD hTask16, LPARAM lpUserDefined );
typedef BOOL (WINAPI *TASKENUMPROCEX)( DWORD dwThreadId, WORD hMod16, WORD hTask16,
                                       PSZ pszModName, PSZ pszFileName, LPARAM lpUserDefined );

#define WOW_SYSTEM  (DWORD)0x0001

INT
WINAPI
VDMEnumProcessWOW(
    PROCESSENUMPROC fp,
    LPARAM          lparam
);

INT
WINAPI
VDMEnumTaskWOW(
    DWORD           dwProcessId,
    TASKENUMPROC    fp,
    LPARAM          lparam
);

//
// VDMEnumTaskWOWEx is the same as VDMEnumTaskWOW except
// the callback procedure gets two more parameters,
// the module name of the EXE and the full path to the
// EXE.
//

INT
WINAPI
VDMEnumTaskWOWEx(
    DWORD           dwProcessId,
    TASKENUMPROCEX  fp,
    LPARAM          lparam
);

//
// VDMTerminateTaskWOW rudely terminates a 16-bit WOW task
// similar to the way TerminateProcess kills a Win32
// process.
//

BOOL
WINAPI
VDMTerminateTaskWOW(
    DWORD           dwProcessId,
    WORD            htask
);

//
// VDMStartTaskInWOW launches a Win16 task in a pre-existing
// WOW VDM.  Note that the caller is responsible for ensuring
// the program is a 16-bit Windows program.  If it is a DOS
// or Win32 program, it will still be launched from within
// the target WOW VDM.
//
// The supplied command line and show command are passed
// unchanged to the 16-bit WinExec API in the target WOW VDM.
//
// Note this routine is ANSI-only.
//

BOOL
WINAPI
VDMStartTaskInWOW(
    DWORD           dwProcessId,
    LPSTR           lpCommandLine,
    WORD            wShow
);

//
// VDMKillWOW is not implemented.
//

BOOL
WINAPI
VDMKillWOW(
    VOID
);

//
// VDMDetectWOW is not implemented.
//

BOOL
WINAPI
VDMDetectWOW(
    VOID
);

BOOL
WINAPI
VDMBreakThread(
    HANDLE          hProcess,
    HANDLE          hThread
);

DWORD
WINAPI
VDMGetDbgFlags(
    HANDLE          hProcess
    );

BOOL
WINAPI
VDMSetDbgFlags(
    HANDLE          hProcess,
    DWORD           dwFlags
    );

#define VDMDBG_BREAK_DOSTASK    0x00000001
#define VDMDBG_BREAK_WOWTASK    0x00000002
#define VDMDBG_BREAK_LOADDLL    0x00000004
#define VDMDBG_BREAK_EXCEPTIONS 0x00000008
#define VDMDBG_BREAK_DEBUGGER   0x00000010
#define VDMDBG_TRACE_HISTORY    0x00000080

//
// VDMIsModuleLoaded can be used to determine if the 16-bit
// executable referenced by the full path name parameter is
// loaded in ntvdm.
//
// Note that this function uses an internal table in vdmdbg.dll
// to determine a module's existence. One important usage of this
// function is to print a message when a particular module is
// loaded for the first time. To accomplish this, call this
// routine during a DBG_SEGLOAD notification BEFORE the entry
// point VDMProcessException has been called. If it returns FALSE,
// then the module has not yet been loaded.
//
BOOL
WINAPI
VDMIsModuleLoaded(
    LPSTR szPath
    );

BOOL
WINAPI
VDMGetSegmentInfo(
    WORD Selector,
    ULONG Offset,
    BOOL bProtectMode,
    VDM_SEGINFO *pSegInfo
    );

//
// VDMGetSymbol
//
// This routine reads the standard .SYM file format.
//
// szModule         - module name (max 9 chars)
// SegNumber        - logical segment number of segment (see VDM_SEGINFO)
// Offset           - offset in segment
// bProtectMode     - TRUE for PM, FALSE for V86 mode
// bNextSymbol      - FALSE to find nearest sym BEFORE offset, TRUE for AFTER
// szSymbolName     - receives symbol name (must point to 256 byte buffer)
// pDisplacement    - distance in bytes from nearest symbol
//

BOOL
WINAPI
VDMGetSymbol(
    LPSTR szModule,
    WORD SegNumber,
    DWORD Offset,
    BOOL bProtectMode,
    BOOL bNextSymbol,
    LPSTR szSymbolName,
    PDWORD pDisplacement
    );

BOOL
WINAPI
VDMGetAddrExpression(
    LPSTR  szModule,
    LPSTR  szSymbol,
    PWORD  Selector,
    PDWORD Offset,
    PWORD  Type
    );

#define VDMADDR_V86     2
#define VDMADDR_PM16    4
#define VDMADDR_PM32   16

//
// typedefs for main entry points
//

typedef BOOL  (WINAPI *VDMPROCESSEXCEPTIONPROC)(LPDEBUG_EVENT);
typedef BOOL  (WINAPI *VDMGETTHREADSELECTORENTRYPROC)(HANDLE,HANDLE,DWORD,LPVDMLDT_ENTRY);
typedef ULONG (WINAPI *VDMGETPOINTERPROC)(HANDLE,HANDLE,WORD,DWORD,BOOL);
typedef BOOL  (WINAPI *VDMGETCONTEXTPROC)(HANDLE,HANDLE,LPVDMCONTEXT);
typedef BOOL  (WINAPI *VDMSETCONTEXTPROC)(HANDLE,HANDLE,LPVDMCONTEXT);
typedef BOOL  (WINAPI *VDMKILLWOWPROC)(VOID);
typedef BOOL  (WINAPI *VDMDETECTWOWPROC)(VOID);
typedef BOOL  (WINAPI *VDMBREAKTHREADPROC)(HANDLE);
typedef BOOL  (WINAPI *VDMGETSELECTORMODULEPROC)(HANDLE,HANDLE,WORD,PUINT,LPSTR, UINT,LPSTR, UINT);
typedef BOOL  (WINAPI *VDMGETMODULESELECTORPROC)(HANDLE,HANDLE,UINT,LPSTR,LPWORD);
typedef BOOL  (WINAPI *VDMMODULEFIRSTPROC)(HANDLE,HANDLE,LPMODULEENTRY,DEBUGEVENTPROC,LPVOID);
typedef BOOL  (WINAPI *VDMMODULENEXTPROC)(HANDLE,HANDLE,LPMODULEENTRY,DEBUGEVENTPROC,LPVOID);
typedef BOOL  (WINAPI *VDMGLOBALFIRSTPROC)(HANDLE,HANDLE,LPGLOBALENTRY,WORD,DEBUGEVENTPROC,LPVOID);
typedef BOOL  (WINAPI *VDMGLOBALNEXTPROC)(HANDLE,HANDLE,LPGLOBALENTRY,WORD,DEBUGEVENTPROC,LPVOID);

typedef INT   (WINAPI *VDMENUMPROCESSWOWPROC)(PROCESSENUMPROC,LPARAM);
typedef INT   (WINAPI *VDMENUMTASKWOWPROC)(DWORD,TASKENUMPROC,LPARAM);
typedef INT   (WINAPI *VDMENUMTASKWOWEXPROC)(DWORD,TASKENUMPROCEX,LPARAM);
typedef BOOL  (WINAPI *VDMTERMINATETASKINWOWPROC)(DWORD,WORD);
typedef BOOL  (WINAPI *VDMSTARTTASKINWOWPROC)(DWORD,LPSTR,WORD);

typedef DWORD (WINAPI *VDMGETDBGFLAGSPROC)(HANDLE);
typedef BOOL  (WINAPI *VDMSETDBGFLAGSPROC)(HANDLE,DWORD);
typedef BOOL  (WINAPI *VDMISMODULELOADEDPROC)(LPSTR);
typedef BOOL  (WINAPI *VDMGETSEGMENTINFOPROC)(WORD,ULONG,BOOL,VDM_SEGINFO);
typedef BOOL  (WINAPI *VDMGETSYMBOLPROC)(LPSTR, WORD, DWORD, BOOL, BOOL, LPSTR, PDWORD);
typedef BOOL  (WINAPI *VDMGETADDREXPRESSIONPROC)(LPSTR, LPSTR, PWORD, PDWORD, PWORD);


#ifdef __cplusplus
}
#endif

#endif // _VDMDBG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\twain.h ===
/* ======================================================================== *\

  Copyright (C) 1991, 1992 TWAIN Working Group: Aldus, Caere, Eastman-Kodak,
  Hewlett-Packard and Logitech Corporations.  All rights reserved.

  Copyright (C) 1997 TWAIN Working Group: Bell+Howell, Canon, DocuMagix,
  Fujitsu, Genoa Technology, Hewlett-Packard, Kofax Imaging Products, and
  Ricoh Corporation.  All rights reserved.

  TWAIN.h -  This is the definitive include file for applications and
          data sources written to the TWAIN specification.
          It defines constants, data structures, messages etc.
          for the public interface to TWAIN.

  Revision History:
    version 1.0, March 6, 1992.  TWAIN 1.0.
    version 1.1, January 1993.   Tech Notes 1.1
    version 1.5, June 1993.      Specification Update 1.5
                                 Change DC to TW
                                 Change filename from DC.H to TWAIN.H
    version 1.5, July 1993.      Remove spaces from country identifiers

    version 1.7, July 1997       Added Capabilities and data structure for
                                 document imaging and digital cameras.
                                 KHL.
    version 1.7, July 1997       Inserted Borland compatibile structure packing
                                 directives provided by Mentor.  JMH
    version 1.7, Aug 1997        Expanded file tabs to spaces.
                                 NOTE: future authors should be sure to have
                                 their editors set to automatically expand tabs
                                 to spaces (original tab setting was 4 spaces).
    version 1.7, Sept 1997       Added job control values
                                 Added return codes
    version 1.7, Sept 1997       changed definition of pRGBRESPONSE to
                                 pTW_RGBRESPONSE
\* ======================================================================== */

#ifndef TWAIN
#define TWAIN

#if _MSC_VER > 1000
#pragma once
#endif

/*  SDH - 02/08/95 - TWUNK */
/*  Force 32-bit twain to use same packing of twain structures as existing */
/*  16-bit twain.  This allows 16/32-bit thunking.                         */
#ifdef  WIN32
    #ifdef __BORLANDC__ //(Mentor June 13, 1996) if we're using a Borland compiler
        #pragma option -a2  //(Mentor June 13, 1996) switch to word alignment
    #else   //(Mentor June 13, 1996) if we're using some other compiler
        #pragma pack (push, before_twain)
        #pragma pack (2)
    #endif  //(Mentor June 13, 1996)
#else   /* WIN32 */
#endif  /* WIN32 */

/****************************************************************************
 * TWAIN Version                                                            *
 ****************************************************************************/
#define TWON_PROTOCOLMINOR   7        /* Changed for Version 1.7            */
#define TWON_PROTOCOLMAJOR   1

/****************************************************************************
 * Platform Dependent Definitions and Typedefs                              *
 ****************************************************************************/

/* Define one of the following, depending on the platform */
/* #define _MAC_   */
/* #define _UNIX_  */
#define _MSWIN_

#ifdef  _MSWIN_
    typedef HANDLE         TW_HANDLE;
    typedef LPVOID         TW_MEMREF;

    /*  SDH - 05/05/95 - TWUNK */
    /*  For common code between 16 and 32 bits.  */
    #ifdef  WIN32
        #define TW_HUGE
    #else   /* WIN32 */
        #define TW_HUGE    huge
    #endif  /* WIN32 */
    typedef BYTE TW_HUGE * HPBYTE;
    typedef void TW_HUGE * HPVOID;
#endif  /* _MSWIN_ */

#ifdef  _MAC_
    #define PASCAL         pascal
    #define FAR
    typedef Handle         TW_HANDLE;
    typedef char          *TW_MEMREF;
#endif  /* _MAC_ */

#ifdef  _UNIX_
    #define PASCAL         pascal
    typedef unsigned char *TW_HANDLE;
    typedef unsigned char *TW_MEMREF;
#endif  /* _UNIX_ */

/****************************************************************************
 * Type Definitions                                                         *
 ****************************************************************************/

/* String types. These include room for the strings and a NULL char,     *
 * or, on the Mac, a length byte followed by the string.                 *
 * TW_STR255 must hold less than 256 chars so length fits in first byte. */
typedef char    TW_STR32[34],     FAR *pTW_STR32;
typedef char    TW_STR64[66],     FAR *pTW_STR64;
typedef char    TW_STR128[130],   FAR *pTW_STR128;
typedef char    TW_STR255[256],   FAR *pTW_STR255;

/* Numeric types. */
typedef char           TW_INT8,   FAR *pTW_INT8;
typedef short          TW_INT16,  FAR *pTW_INT16;
typedef long           TW_INT32,  FAR *pTW_INT32;
typedef unsigned char  TW_UINT8,  FAR *pTW_UINT8;
typedef unsigned short TW_UINT16, FAR *pTW_UINT16;
typedef unsigned long  TW_UINT32, FAR *pTW_UINT32;
typedef unsigned short TW_BOOL,   FAR *pTW_BOOL;

/* Fixed point structure type. */
typedef struct {
    TW_INT16     Whole;        /* maintains the sign */
    TW_UINT16    Frac;
} TW_FIX32,  FAR *pTW_FIX32;

/****************************************************************************
 * Structure Definitions                                                    *
 ****************************************************************************/

/* No DAT needed. */
typedef struct {
   TW_FIX32   X;
   TW_FIX32   Y;
   TW_FIX32   Z;
} TW_CIEPOINT, FAR * pTW_CIEPOINT;

/* No DAT needed. */
typedef struct {
   TW_FIX32   StartIn;
   TW_FIX32   BreakIn;
   TW_FIX32   EndIn;
   TW_FIX32   StartOut;
   TW_FIX32   BreakOut;
   TW_FIX32   EndOut;
   TW_FIX32   Gamma;
   TW_FIX32   SampleCount;  /* if =0 use the gamma */
} TW_DECODEFUNCTION, FAR * pTW_DECODEFUNCTION;

/* No DAT needed. */
typedef struct {
   TW_UINT8    Index;    /* Value used to index into the color table. */
   TW_UINT8    Channel1; /* First  tri-stimulus value (e.g Red)       */
   TW_UINT8    Channel2; /* Second tri-stimulus value (e.g Green)     */
   TW_UINT8    Channel3; /* Third  tri-stimulus value (e.g Blue)      */
} TW_ELEMENT8, FAR * pTW_ELEMENT8;

/* No DAT.  Defines a frame rectangle in ICAP_UNITS coordinates. */
typedef struct {
   TW_FIX32   Left;
   TW_FIX32   Top;
   TW_FIX32   Right;
   TW_FIX32   Bottom;
} TW_FRAME, FAR * pTW_FRAME;

/* No DAT needed.  Used to manage memory buffers. */
typedef struct {
   TW_UINT32  Flags;  /* Any combination of the TWMF_ constants.           */
   TW_UINT32  Length; /* Number of bytes stored in buffer TheMem.          */
   TW_MEMREF  TheMem; /* Pointer or handle to the allocated memory buffer. */
} TW_MEMORY, FAR * pTW_MEMORY;

/* No DAT needed. */
typedef struct {
   TW_DECODEFUNCTION   Decode[3];
   TW_FIX32            Mix[3][3];
} TW_TRANSFORMSTAGE, FAR * pTW_TRANSFORMSTAGE;

/* No DAT needed.  Describes version of software that's running. */
typedef struct {
   TW_UINT16  MajorNum;  /* Major revision number of the software. */
   TW_UINT16  MinorNum;  /* Incremental revision number of the software. */
   TW_UINT16  Language;  /* e.g. TWLG_SWISSFRENCH */
   TW_UINT16  Country;   /* e.g. TWCY_SWITZERLAND */
   TW_STR32   Info;      /* e.g. "1.0b3 Beta release" */
} TW_VERSION, FAR * pTW_VERSION;

/* TWON_ARRAY. Container for array of values (a simplified TW_ENUMERATION) */
typedef struct {
   TW_UINT16  ItemType;
   TW_UINT32  NumItems;    /* How many items in ItemList           */
   TW_UINT8   ItemList[1]; /* Array of ItemType values starts here */
} TW_ARRAY, FAR * pTW_ARRAY;

/* TWON_ENUMERATION. Container for a collection of values. */
typedef struct {
   TW_UINT16  ItemType;
   TW_UINT32  NumItems;     /* How many items in ItemList                 */
   TW_UINT32  CurrentIndex; /* Current value is in ItemList[CurrentIndex] */
   TW_UINT32  DefaultIndex; /* Powerup value is in ItemList[DefaultIndex] */
   TW_UINT8   ItemList[1];  /* Array of ItemType values starts here       */
} TW_ENUMERATION, FAR * pTW_ENUMERATION;

/* TWON_ONEVALUE. Container for one value. */
typedef struct {
   TW_UINT16  ItemType;
   TW_UINT32  Item;
} TW_ONEVALUE, FAR * pTW_ONEVALUE;

/* TWON_RANGE. Container for a range of values. */
typedef struct {
   TW_UINT16  ItemType;
   TW_UINT32  MinValue;     /* Starting value in the range.           */
   TW_UINT32  MaxValue;     /* Final value in the range.              */
   TW_UINT32  StepSize;     /* Increment from MinValue to MaxValue.   */
   TW_UINT32  DefaultValue; /* Power-up value.                        */
   TW_UINT32  CurrentValue; /* The value that is currently in effect. */
} TW_RANGE, FAR * pTW_RANGE;

/* DAT_CAPABILITY. Used by app to get/set capability from/in a data source. */
typedef struct {
   TW_UINT16  Cap; /* id of capability to set or get, e.g. CAP_BRIGHTNESS */
   TW_UINT16  ConType; /* TWON_ONEVALUE, _RANGE, _ENUMERATION or _ARRAY   */
   TW_HANDLE  hContainer; /* Handle to container of type Dat              */
} TW_CAPABILITY, FAR * pTW_CAPABILITY;

/* DAT_CIECOLOR. */
typedef struct {
   TW_UINT16           ColorSpace;
   TW_INT16            LowEndian;
   TW_INT16            DeviceDependent;
   TW_INT32            VersionNumber;
   TW_TRANSFORMSTAGE   StageABC;
   TW_TRANSFORMSTAGE   StageLMN;
   TW_CIEPOINT         WhitePoint;
   TW_CIEPOINT         BlackPoint;
   TW_CIEPOINT         WhitePaper;
   TW_CIEPOINT         BlackInk;
   TW_FIX32            Samples[1];
} TW_CIECOLOR, FAR * pTW_CIECOLOR;

/* DAT_EVENT. For passing events down from the app to the DS. */
typedef struct {
   TW_MEMREF  pEvent;    /* Windows pMSG or Mac pEvent.                 */
   TW_UINT16  TWMessage; /* TW msg from data source, e.g. MSG_XFERREADY */
} TW_EVENT, FAR * pTW_EVENT;

/* DAT_GRAYRESPONSE */
typedef struct {
   TW_ELEMENT8         Response[1];
} TW_GRAYRESPONSE, FAR * pTW_GRAYRESPONSE;

/* DAT_IDENTITY. Identifies the program/library/code resource. */
typedef struct {
   TW_UINT32  Id;              /* Unique number.  In Windows, app hWnd      */
   TW_VERSION Version;         /* Identifies the piece of code              */
   TW_UINT16  ProtocolMajor;   /* App and DS must set to TWON_PROTOCOLMAJOR */
   TW_UINT16  ProtocolMinor;   /* App and DS must set to TWON_PROTOCOLMINOR */
   TW_UINT32  SupportedGroups; /* Bit field OR combination of DG_ constants */
   TW_STR32   Manufacturer;    /* Manufacturer name, e.g. "Hewlett-Packard" */
   TW_STR32   ProductFamily;   /* Product family name, e.g. "ScanJet"       */
   TW_STR32   ProductName;     /* Product name, e.g. "ScanJet Plus"         */
} TW_IDENTITY, FAR * pTW_IDENTITY;

/* DAT_IMAGEINFO. App gets detailed image info from DS with this. */
typedef struct {
   TW_FIX32   XResolution;      /* Resolution in the horizontal             */
   TW_FIX32   YResolution;      /* Resolution in the vertical               */
   TW_INT32   ImageWidth;       /* Columns in the image, -1 if unknown by DS*/
   TW_INT32   ImageLength;      /* Rows in the image, -1 if unknown by DS   */
   TW_INT16   SamplesPerPixel;  /* Number of samples per pixel, 3 for RGB   */
   TW_INT16   BitsPerSample[8]; /* Number of bits for each sample           */
   TW_INT16   BitsPerPixel;     /* Number of bits for each padded pixel     */
   TW_BOOL    Planar;           /* True if Planar, False if chunky          */
   TW_INT16   PixelType;        /* How to interp data; photo interp (TWPT_) */
   TW_UINT16  Compression;      /* How the data is compressed (TWCP_xxxx)   */
} TW_IMAGEINFO, FAR * pTW_IMAGEINFO;

/* DAT_IMAGELAYOUT. Provides image layout information in current units. */
typedef struct {
   TW_FRAME   Frame;          /* Frame coords within larger document */
   TW_UINT32  DocumentNumber;
   TW_UINT32  PageNumber;     /* Reset when you go to next document  */
   TW_UINT32  FrameNumber;    /* Reset when you go to next page      */
} TW_IMAGELAYOUT, FAR * pTW_IMAGELAYOUT;

/* DAT_IMAGEMEMXFER. Used to pass image data (e.g. in strips) from DS to app.*/
typedef struct {
   TW_UINT16  Compression;  /* How the data is compressed                */
   TW_UINT32  BytesPerRow;  /* Number of bytes in a row of data          */
   TW_UINT32  Columns;      /* How many columns                          */
   TW_UINT32  Rows;         /* How many rows                             */
   TW_UINT32  XOffset;      /* How far from the side of the image        */
   TW_UINT32  YOffset;      /* How far from the top of the image         */
   TW_UINT32  BytesWritten; /* How many bytes written in Memory          */
   TW_MEMORY  Memory;       /* Mem struct used to pass actual image data */
} TW_IMAGEMEMXFER, FAR * pTW_IMAGEMEMXFER;

/* Changed in 1.1: QuantTable, HuffmanDC, HuffmanAC TW_MEMREF -> TW_MEMORY  */
/* DAT_JPEGCOMPRESSION. Based on JPEG Draft International Std, ver 10918-1. */
typedef struct {
   TW_UINT16   ColorSpace;       /* One of the TWPT_xxxx values                */
   TW_UINT32   SubSampling;      /* Two word "array" for subsampling values    */
   TW_UINT16   NumComponents;    /* Number of color components in image        */
   TW_UINT16   RestartFrequency; /* Frequency of restart marker codes in MDU's */
   TW_UINT16   QuantMap[4];      /* Mapping of components to QuantTables       */
   TW_MEMORY   QuantTable[4];    /* Quantization tables                        */
   TW_UINT16   HuffmanMap[4];    /* Mapping of components to Huffman tables    */
   TW_MEMORY   HuffmanDC[2];     /* DC Huffman tables                          */
   TW_MEMORY   HuffmanAC[2];     /* AC Huffman tables                          */
} TW_JPEGCOMPRESSION, FAR * pTW_JPEGCOMPRESSION;

/* DAT_PALETTE8. Color palette when TWPT_PALETTE pixels xfer'd in mem buf. */
typedef struct {
   TW_UINT16    NumColors;   /* Number of colors in the color table.  */
   TW_UINT16    PaletteType; /* TWPA_xxxx, specifies type of palette. */
   TW_ELEMENT8  Colors[256]; /* Array of palette values starts here.  */
} TW_PALETTE8, FAR * pTW_PALETTE8;

/* DAT_PENDINGXFERS. Used with MSG_ENDXFER to indicate additional data. */
typedef struct {
   TW_UINT16 Count;
   union {
      TW_UINT32 EOJ;
      TW_UINT32 Reserved;
   };
} TW_PENDINGXFERS, FAR *pTW_PENDINGXFERS;

/* DAT_RGBRESPONSE */
typedef struct {
   TW_ELEMENT8         Response[1];
} TW_RGBRESPONSE, FAR * pTW_RGBRESPONSE;

/* DAT_SETUPFILEXFER. Sets up DS to app data transfer via a file. */
typedef struct {
   TW_STR255 FileName;
   TW_UINT16 Format;   /* Any TWFF_ constant */
   TW_INT16  VRefNum;  /* Used for Mac only  */
} TW_SETUPFILEXFER, FAR * pTW_SETUPFILEXFER;

/* DAT_SETUPMEMXFER. Sets up DS to app data transfer via a memory buffer. */
typedef struct {
   TW_UINT32 MinBufSize;
   TW_UINT32 MaxBufSize;
   TW_UINT32 Preferred;
} TW_SETUPMEMXFER, FAR * pTW_SETUPMEMXFER;

/* DAT_STATUS. App gets detailed status info from a data source with this. */
typedef struct {
   TW_UINT16  ConditionCode; /* Any TWCC_ constant     */
   TW_UINT16  Reserved;      /* Future expansion space */
} TW_STATUS, FAR * pTW_STATUS;

/* DAT_USERINTERFACE. Coordinates UI between app and data source. */
typedef struct {
   TW_BOOL    ShowUI;  /* TRUE if DS should bring up its UI           */
   TW_BOOL    ModalUI; /* For Mac only - true if the DS's UI is modal */
   TW_HANDLE  hParent; /* For windows only - App window handle        */
} TW_USERINTERFACE, FAR * pTW_USERINTERFACE;

/* SDH - 03/21/95 - TWUNK */
/* DAT_TWUNKIDENTITY. Provides DS identity and 'other' information necessary */
/*                    across thunk link. */
typedef struct {
   TW_IDENTITY identity;        /* Identity of data source.                 */
   TW_STR255   dsPath;          /* Full path and file name of data source.  */
} TW_TWUNKIDENTITY, FAR * pTW_TWUNKIDENTITY;

/* SDH - 03/21/95 - TWUNK */
/* Provides DS_Entry parameters over thunk link. */
typedef struct
{
    TW_INT8     destFlag;       /* TRUE if dest is not NULL                 */
    TW_IDENTITY dest;           /* Identity of data source (if used)        */
    TW_INT32    dataGroup;      /* DSM_Entry dataGroup param