entContext,
    IN  ATQ_COMPLETION pfnCompletion,
    IN  DWORD          TimeOut,
    IN  HANDLE         hAsyncIO
    );


dllexp
VOID
AtqGetAcceptExAddrs(
    IN  PATQ_CONTEXT patqContext,
    OUT SOCKET *     pSock,
    OUT PVOID *      ppvBuff,
    OUT PVOID *      pEndpointContext,
    OUT SOCKADDR * * ppsockaddrLocal,
    OUT SOCKADDR * * ppsockaddrRemote
    );


/*++
  AtqCloseSocket()

  Routine Description:

    Closes the socket in this atq structure if it wasn't
    closed by transmitfile. This function should be called only
    if the embedded handle in AtqContext is a Socket.

  Arguments:

    patqContext - Context whose socket should be closed.
    fShutdown - If TRUE, means we call shutdown and always close the socket.
        Note that if TransmitFile closed the socket, it will have done the
        shutdown for us

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
dllexp
BOOL
AtqCloseSocket(
    PATQ_CONTEXT patqContext,
    BOOL         fShutdown
    );

/*++
  AtqCloseFileHandle()

  Routine Description:

    Closes the file handle in this atq structure.
    This function should be called only if the embedded handle
    in AtqContext is a file handle.

  Arguments:

  patqContext - Context whose file handle should be closed.

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
dllexp
BOOL
AtqCloseFileHandle(
    PATQ_CONTEXT patqContext
    );


/*++

   AtqFreeContext()

   Routine Description:

     Frees the context created in AtqAddAsyncHandle.
     Call this after the async handle has been closed and all outstanding
     IO operations have been completed. The context is invalid after this call.
     Call AtqFreeContext() for same context only ONCE.

   Arguments:

    patqContext - Context to free
    fReuseContext - TRUE if this can context can be reused in the context of
        the calling thread.  Should be FALSE if the calling thread will exit
        soon (i.e., isn't an AtqPoolThread).

   Returns:
    None
--*/
dllexp
VOID
AtqFreeContext(
    IN PATQ_CONTEXT   patqContext,
    BOOL              fReuseContext
    );




enum ATQ_CONTEXT_INFO
{
    ATQ_INFO_TIMEOUT = 0,       // Timeout rounded up to ATQ timeout interval
    ATQ_INFO_RESUME_IO,         // resumes IO as is after Timeout
    ATQ_INFO_COMPLETION,        // Completion routine
    ATQ_INFO_COMPLETION_CONTEXT,// Completion context
    ATQ_INFO_BANDWIDTH_INFO,    // Bandwidth Throttling Descriptor
    ATQ_INFO_ABORTIVE_CLOSE,    // do abortive close on closesocket
    ATQ_INFO_NEXT_TIMEOUT
};

enum ATQ_CONSUMER_TYPE
{
    AtqConsumerLDAP = 0,
    AtqConsumerOther,
    AtqConsumerAtq,
    AtqConsumerMax
};


/*++

  AtqContextSetInfo()

  Routine Description:

    Sets various bits of information for this context

  Arguments:

    patqContext - pointer to ATQ context
    atqInfo     - Data item to set
    data        - New value for item

  Return Value:

    The old value of the parameter

--*/

dllexp
DWORD_PTR
AtqContextSetInfo(
    IN PATQ_CONTEXT   patqContext,
    IN enum ATQ_CONTEXT_INFO  atqInfo,
    IN DWORD_PTR      data
    );

dllexp
DWORD_PTR
AtqContextSetInfo2(
    IN PATQ_CONTEXT   patqContext,
    IN enum ATQ_CONTEXT_INFO  atqInfo,
    IN DWORD_PTR      data
    );

VOID
AtqUpdatePerfStats(
    IN ATQ_CONSUMER_TYPE        ConsumerType,
    IN DWORD                    dwOperation,
    IN DWORD                    dwVal
    );

dllexp
DWORD_PTR
AtqEndpointSetInfo2(
    IN PVOID                Endpoint,
    IN ATQ_ENDPOINT_INFO    EndpointInfo,
    IN DWORD_PTR            dwInfo
    );

dllexp
DWORD_PTR
AtqSetInfo2(
    IN ATQ_INFO         atqInfo,
    IN DWORD_PTR        Data
    );


/*----------------------------------------------------------
  ATQ Context IO functions
-----------------------------------------------------------*/

/*++

Routine Description:

    Atq<Operation><Target>()

    <Operation> :=  Read | Write | Transmit
    <Target>    :=  File | Socket

    These functions just setup ATQ context and then call the corresponding
    Win32/WinSock function for submitting an asynchronous IO operation. By
    default the Socket functions support scatter/gather using WSABUF

    These functions are wrappers and should be called instead of the
     correpsonding Win32 API.  The one difference from the Win32 API is TRUE
     is returned if the error ERROR_IO_PENDING occurred, thus clients do not
     need to check for this case.

   The timeout time for the request is calculated by taking the maximum of
     the context's timeout time and bytes transferred based on 1k/second.

Arguments:

    patqContext - pointer to ATQ context
    Everything else as in the Win32 API/WinSock APIs

    NOTES: AtqTransmitFile takes an additional DWORD flags which may contain
        the winsock constants TF_DISCONNECT and TF_REUSE_SOCKET

    AtqReadFile and AtqWriteFile take an optional overlapped structure if
    clients want to have multiple outstanding reads or writes.  If the value
    is NULL, then the overlapped structure from the Atq context is used.

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)
    sets ERROR_NETWORK_BUSY as error when the request needs to be rejected.

--*/

dllexp
BOOL
AtqReadFile(
    IN  PATQ_CONTEXT patqContext,
    IN  LPVOID       lpBuffer,
    IN  DWORD        BytesToRead,
    IN  OVERLAPPED * lpo OPTIONAL
    );

dllexp
BOOL
AtqReadSocket(
    IN  PATQ_CONTEXT patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    IN  OVERLAPPED * lpo  OPTIONAL
    );

/*
 *  Code for reading into single buffer will look like the following.
 * {
 *   WSABUF wsaBuf = { (BytesToRead), (lpBuffer)};
 *   fRet = AtqReadSocket( patqContext, &wsaBuf, 1, lpo);
 * }
 */

dllexp
BOOL
AtqWriteFile(
    IN  PATQ_CONTEXT patqContext,
    IN  LPCVOID      lpBuffer,
    IN  DWORD        BytesToWrite,
    IN  OVERLAPPED * lpo OPTIONAL
    );

dllexp
BOOL
AtqWriteSocket(
    IN  PATQ_CONTEXT patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    IN  OVERLAPPED * lpo OPTIONAL
    );


dllexp
BOOL
AtqSyncWsaSend(
    IN PATQ_CONTEXT  patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    OUT LPDWORD      pcbWritten
    );

// Note: This API always causes the complete file to be sent.
// If you want to change the behaviour store the appropriate offsets
//   in the ATQ_CONTEXT::Overlapped object.
dllexp
BOOL
AtqTransmitFile(
    IN  PATQ_CONTEXT            patqContext,
    IN  HANDLE                  hFile,         // File data comes from
    IN  DWORD                   dwBytesInFile, // what is the size of file?
    IN  LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN  DWORD                   dwFlags      // TF_DISCONNECT, TF_REUSE_SOCKET
    );

dllexp
BOOL
AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    );

dllexp
BOOL
AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    );


/*----------------------------------------------------------
  ATQ Utility Functions
-----------------------------------------------------------*/

#define OPLOCK_BREAK_NO_OPLOCK  0x00000001
#define OPLOCK_BREAK_OPEN       0x00000007
#define OPLOCK_BREAK_CLOSE      0x00000008

typedef
VOID
(*ATQ_OPLOCK_COMPLETION)(
            IN PVOID        Context,
            IN DWORD        Status
            );

dllexp
HANDLE
AtqCreateFile(
    LPCSTR lpAFileName,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlagsAndAttributes,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR sd,
    ULONG Length,
    PULONG LengthNeeded,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
    );

dllexp
HANDLE
AtqCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlagsAndAttributes,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR sd,
    ULONG Length,
    PULONG LengthNeeded,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
    );

dllexp
BOOL
AtqOplockAcknowledge(
    IN HANDLE   FileHandle,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
);

dllexp
BOOL
AtqSpudInitialized(
    VOID
);

dllexp
BOOL
AtqReadDirChanges(PATQ_CONTEXT patqContext,
                  LPVOID       lpBuffer,
                  DWORD        BytesToRead,
                  BOOL         fWatchSubDir,
                  DWORD        dwNotifyFilter,
                  OVERLAPPED * lpo );



/*++

  AtqPostCompletionStatus()

  Routine Description:

    Posts a completion status on the completion port queue

    An IO pending error code is treated as a success error code

  Arguments:

    patqContext - pointer to ATQ context
    Everything else as in the Win32 API

    NOTES:

  Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/

dllexp
BOOL
AtqPostCompletionStatus(
    IN     PATQ_CONTEXT patqContext,
    IN     DWORD        BytesTransferred
    );




/*----------------------------------------------------------
  ATQ Utility Functions
-----------------------------------------------------------*/

/*++

   Bandwidth Throttling Support

   The following items are used in the support for bandwidth throttling
--*/

enum ATQ_BANDWIDTH_INFO
{
    ATQ_BW_BANDWIDTH_LEVEL = 0,
    ATQ_BW_MAX_BLOCKED,
    ATQ_BW_STATISTICS,
    ATQ_BW_DESCRIPTION,
};

/*++

  AtqCreateBandwidthInfo()

  Routine Description:

    Allocate and opaque bandwidth descriptor

  Arguments:

    None

  Return Value:

    Pointer to descriptor.  NULL if failed.

--*/
dllexp
PVOID
AtqCreateBandwidthInfo(
    VOID
    );

/*++

  AtqFreeBandwidthInfo()

  Routine Description:

    Triggers the destruction of a bandwidth descriptor

  Arguments:

    pvBandwidthInfo - pointer to valid descriptor

  Return Value:

    TRUE if successful, else FALSE

--*/
dllexp
BOOL
AtqFreeBandwidthInfo(
    IN     PVOID               pvBandwidthInfo
    );

/*++

  AtqBandwidthSetInfo()

  Routine Description:

    Set properties of bandwidth descriptor

  Arguments:

    pvBandwidthInfo - pointer to descriptor
    BWInfo - property to change
    Data - value of property

  Return Value:

    Old value of property

--*/
dllexp
DWORD_PTR
AtqBandwidthSetInfo(
    IN     PVOID               pvBandwidthInfo,
    IN     ATQ_BANDWIDTH_INFO  BwInfo,
    IN     DWORD_PTR           Data
    );

/*++

  AtqBandwidthGetInfo()

  Routine Description:

    Get properties of bandwidth descriptor

  Arguments:

    pvBandwidthInfo - pointer to descriptor
    BWInfo - property to change
    pdwData - filled in with value of property

  Return Value:

    TRUE if successful, else FALSE

--*/
dllexp
BOOL
AtqBandwidthGetInfo(
    IN     PVOID               pvBandwidthInfo,
    IN     ATQ_BANDWIDTH_INFO  BwInfo,
    OUT    DWORD_PTR *         pdwData
    );

#include "atq2.h"

#ifdef __cplusplus
}
#endif

#endif // !_ATQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\config.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    Config.h

Abstract:

    This header file defines the function prototypes of the temporary
    helper routines to get configuration information from the NT
    configuration files.

Author:

    Rita Wong (ritaw) 22-May-1991

Environment:

    Only runs under NT.

Notes:

    You must include the following before this file:

            windef.h OR windows.h  // Win32 type definitions

Revision History:

    22-May-1991 RitaW
        Created.
    27-Nov-1991 JohnRo
        Prepare for revised config handlers.  Added revision history.
    08-Jan-1992 JohnRo
        Added SECT_NT_REPLICATOR.
    13-Feb-1992 JohnRo
        Moved section name equates to <confname.h>.
        Include <netdebug.h> and <lmcons.h> here instead of everywhere else.
        Added NetpDbgDisplayConfigSection().
        Added NetpDeleteConfigKeyword() and NetpNumberOfConfigKeywords().
        Added Netp{Get,Set}Config{Bool,Dword}.
    14-Mar-1992 JohnRo
        Get rid of old config helper callers.
    23-Mar-1992 JohnRo
        Get rid of old config helpers.
    08-May-1992 JohnRo
        Add LPTSTR array routines.
    08-Jul-1992 JohnRo
        RAID 10503: srv mgr: repl dialog doesn't come up.
    25-Feb-1993 JohnRo
        RAID 12914: avoid double close and free mem in NetpCloseConfigData().
    07-Apr-1993 JohnRo
        RAID 5483: server manager: wrong path given in repl dialog.

--*/


#ifndef CONFIG_H
#define CONFIG_H


#include <lmcons.h>     // NET_API_STATUS.
#include <netdebug.h>   // LPDEBUG_STRING.
#include <strarray.h>   // LPTSTR_ARRAY.


//
// Opaque pointer for net config handles.  (The real structure is in ConfigP.h,
// and should only be used by NetLib routines.)
//
typedef LPVOID LPNET_CONFIG_HANDLE;


//
// Note that the routines in this file only accept the SECT_NT_ versions.
// See <confname.h> for more details.
//


// NetpOpenConfigData opens the Paramaters section of a given service.
NET_API_STATUS
NetpOpenConfigData(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN BOOL ReadOnly
    );

// NetpOpenConfigDataEx opens any area of a given service.
NET_API_STATUS
NetpOpenConfigDataEx(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN LPTSTR AreaUnderSection OPTIONAL,
    IN BOOL ReadOnly
    );

// NetpOpenConfigData opens the Paramaters section of a given service.
NET_API_STATUS
NetpOpenConfigDataWithPath(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN BOOL ReadOnly
    );

// NetpOpenConfigDataEx opens any area of a given service.
NET_API_STATUS
NetpOpenConfigDataWithPathEx(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN LPTSTR AreaUnderSection OPTIONAL,
    IN BOOL ReadOnly
    );

// Delete a keyword and its value.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpDeleteConfigKeyword (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword
    );

NET_API_STATUS
NetpExpandConfigString(
    IN  LPCTSTR  UncServerName OPTIONAL,
    IN  LPCTSTR  UnexpandedString,
    OUT LPTSTR * ValueBufferPtr         // Must be freed by NetApiBufferFree().
    );

// If NetpOpenConfigData fails, try calling NetpHandleConfigFailure to decide
// what to do about it.
NET_API_STATUS
NetpHandleConfigFailure(
    IN LPDEBUG_STRING DebugName,        // Name of routine.
    IN NET_API_STATUS ApiStatus,        // NetpOpenConfigData's error code.
    IN LPTSTR ServerNameValue OPTIONAL,
    OUT LPBOOL TryDownlevel
    );

// Get a boolean value.  Return ERROR_INVALID_DATA if value isn't boolean.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpGetConfigBool (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN BOOL DefaultValue,
    OUT LPBOOL ValueBuffer
    );

// Get an unsigned numeric value.  Return ERROR_INVALID_DATA if value isn't
// numeric.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpGetConfigDword (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN DWORD DefaultValue,
    OUT LPDWORD ValueBuffer
    );

// Return null-null array of strings.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpGetConfigTStrArray(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    OUT LPTSTR_ARRAY * ValueBuffer      // Must be freed by NetApiBufferFree().
    );

// Return string value for a given keyword.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpGetConfigValue (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    OUT LPTSTR * ValueBuffer            // Must be freed by NetApiBufferFree().
    );

NET_API_STATUS
NetpEnumConfigSectionValues(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    OUT LPTSTR * KeywordBuffer,         // Must be freed by NetApiBufferFree().
    OUT LPTSTR * ValueBuffer,           // Must be freed by NetApiBufferFree().
    IN BOOL FirstTime
    );

NET_API_STATUS
NetpNumberOfConfigKeywords (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    OUT LPDWORD Count
    );

NET_API_STATUS
NetpSetConfigValue(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN LPTSTR Value
    );

NET_API_STATUS
NetpCloseConfigData(
    IN OUT LPNET_CONFIG_HANDLE ConfigHandle
    );


#endif // ndef CONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\atq2.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1997           **/
/**********************************************************************/

/*
    atq.h

    This module contains async thread queue (atq) for async IO and thread
    pool sharing among various services.

    Brief Description of ATQ:
      For description, please see iis\spec\isatq.doc

*/

#ifndef _ATQ2_H_
#define _ATQ2_H_


dllexp
VOID
AtqGetDatagramAddrs(
    IN  PATQ_CONTEXT patqContext,
    OUT SOCKET *     pSock,
    OUT PVOID *      ppvBuff,
    OUT PVOID *      pEndpointContext,
    OUT SOCKADDR * * ppsockaddrRemote,
    OUT INT *        pcbsockaddrRemote
    );

dllexp
DWORD_PTR
AtqContextGetInfo(
    PATQ_CONTEXT           patqContext,
    enum ATQ_CONTEXT_INFO  atqInfo
    );

dllexp
BOOL
AtqWriteDatagramSocket(
    IN PATQ_CONTEXT  patqContext,
    IN LPWSABUF     pwsaBuffers,
    IN DWORD        dwBufferCount,
    IN OVERLAPPED *  lpo OPTIONAL
    );

#endif // !_ATQ2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\kerbcli.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1999
//
// File:        kerbcli.h
//
// Contents:    exported functions from kerbcli.lib
//
//
// History:     24-May-1999     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __KERBCLI_H__
#define __KERBCLI_H__

#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS
KerbChangePasswordUser(
    IN LPWSTR DomainName,
    IN LPWSTR UserName,
    IN LPWSTR OldPassword,
    IN LPWSTR NewPassword
    );


NTSTATUS
KerbSetPasswordUser(
    IN LPWSTR DomainName,
    IN LPWSTR UserName,
    IN LPWSTR NewPassword,
    IN OPTIONAL PCredHandle CredentialsHandle
    );

NTSTATUS
KerbSetPasswordUserEx(
    IN LPWSTR DomainName,
    IN LPWSTR UserName,
    IN LPWSTR NewPassword,
    IN OPTIONAL PCredHandle CredentialsHandle,
    IN OPTIONAL LPWSTR  KdcAddress
    );


#ifdef __cplusplus
}
#endif

#endif // __KERBCLI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\crc32.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    crc32.h

Abstract:

    CRC-32 alogorithm prototypes and constants

Author:

    MikeSw

Revision History:

    ChandanS  25-Jul-96      Stolen from net\svcdlls\ntlmssp\client\crc32.h
--*/



//////////////////////////////////////////////////////////////
//
// Function prototypes for CRC-32
//
//////////////////////////////////////////////////////////////


#ifdef __cplusplus
extern "C"
{
#endif

void
Crc32(  unsigned long crc,
        unsigned long cbBuffer,
        void * pvBuffer,
        unsigned long * pNewCrc);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\names.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    Names.h

Abstract:

    This module contains routines for dealing with network-related names.

Author:

    John Rogers (JohnRo) 15-Feb-1991

Revision History:

    19-Aug-1991 JohnRo
        Allow UNICODE use.
        Got rid of tabs in source file.
    20-Oct-1992 JohnRo
        RAID 9020: setup: PortUas fails ("prompt on conflicts" version).
    26-Jan-1993 JohnRo
        RAID 8683: PortUAS should set primary group from Mac parms.
    15-Apr-1993 JohnRo
        RAID 6167: avoid access violation or assert with WFW print server.

--*/

#ifndef _NAMES_
#define _NAMES_


#include <windef.h>             // BOOL, IN, LPTSTR, OUT, etc.


NET_API_STATUS
NetpGetPrimaryGroupFromMacField(
    IN  LPCTSTR   MacPrimaryField,      // name in "mGroup:" format.
    OUT LPCTSTR * GroupNamePtr          // alloc and set ptr.
    );

// This checks for "server" format (not "\\server").
BOOL
NetpIsComputerNameValid(
    IN LPTSTR ComputerName
    );

BOOL
NetpIsDomainNameValid(
    IN LPWSTR DomainName
    );

BOOL
NetpIsShareNameValid(
    IN LPTSTR ShareName
    );

BOOL
NetpIsGroupNameValid(
    IN LPTSTR GroupName
    );

// This checks for "mGroup:" format.
BOOL
NetpIsMacPrimaryGroupFieldValid(
    IN LPCTSTR MacPrimaryField
    );

BOOL
NetpIsPrintQueueNameValid(
    IN LPCTSTR QueueName
    );

// This checks for "\\server\share" format.
BOOL
NetpIsRemoteNameValid(
    IN LPTSTR RemoteName
    );

// This checks for "\\server" format.
BOOL
NetpIsUncComputerNameValid(
    IN LPTSTR ComputerName
    );

BOOL
NetpIsUserNameValid(
    IN LPTSTR UserName
    );

#endif // ndef _NAMES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\ldap.h ===
/******************************************************************/
/* Copyright (C) 1998 Microsoft Corporation.  All rights reserved.*/
/******************************************************************/
/* Abstract syntax: ldap */
/* Created: Tue Jan 27 10:27:59 1998 */
/* ASN.1 compiler version: 4.2 Beta B */
/* Target operating system: Windows NT 3.5 or later/Windows 95 */
/* Target machine type: Intel x86 */
/* C compiler options required: -Zp8 (Microsoft) or equivalent */
/* ASN.1 compiler options specified:
 * -noshortennames -nouniquepdu -c++ -noconstraints -ber -gendirectives
 * ldapnew.gen
 */

#ifndef OSS_ldap
#define OSS_ldap

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include "asn1hdr.h"
#include "asn1code.h"

#define          ObjectID_PDU 1
#define          DistinguishedName_PDU 2
#define          LDAPMsg_PDU 3
#define          Attribute_PDU 4
#define          PagedResultsSearchControlValue_PDU 5
#define          ReplicationSearchControlValue_PDU 6
#define          SecurityDescriptorSearchControlValue_PDU 7
#define          SearchResultFull_PDU 8
#define          ProtectedPassword_PDU 9
#define          StrongCredentials_PDU 10
#define          SortKeyList_PDU 11
#define          SortResult_PDU 12

typedef struct ObjectID_ {
    struct ObjectID_ *next;
    unsigned short  value;
} *ObjectID;

typedef struct TYPE_IDENTIFIER {
    struct ObjectID_ *id;
    unsigned short  Type;
} TYPE_IDENTIFIER;

typedef struct ObjectID_ *ID;

typedef struct UniqueIdentifier {
    unsigned int    length;  /* number of significant bits */
    unsigned char   *value;
} UniqueIdentifier;

typedef struct AlgorithmIdentifier {
    unsigned char   bit_mask;
#       define      parameters_present 0x80
    struct ObjectID_ *algorithm;
    OpenType        parameters;  /* optional */
} AlgorithmIdentifier;

typedef struct RDNSequence_ *DistinguishedName;

typedef struct Token {
    struct {
        AlgorithmIdentifier algorithm;
        struct RDNSequence_ *name;
        UTCTime         time;
        struct {
            unsigned int    length;  /* number of significant bits */
            unsigned char   *value;
        } random;
    } toBeSigned;
    AlgorithmIdentifier algorithmIdentifier;
    struct {
        unsigned int    length;  /* number of significant bits */
        unsigned char   *value;
    } encrypted;
} Token;

typedef int             Version;
#define                     v1 0
#define                     v2 1

typedef int             CertificateSerialNumber;

typedef struct Name {
    unsigned short  choice;
#       define      rdnSequence_chosen 1
    union _union {
        struct RDNSequence_ *rdnSequence;
    } u;
} Name;

typedef struct Validity {
    UTCTime         notBefore;
    UTCTime         notAfter;
} Validity;

typedef struct SubjectPublicKeyInfo {
    AlgorithmIdentifier algorithm;
    struct _bit1 {
        unsigned int    length;  /* number of significant bits */
        unsigned char   *value;
    } subjectPublicKey;
} SubjectPublicKeyInfo;

typedef struct Certificate {
    struct {
        unsigned char   bit_mask;
#           define      version_present 0x80
#           define      issuerUniqueIdentifier_present 0x40
#           define      subjectUniqueIdentifier_present 0x20
        Version         version;  /* default assumed if omitted */
        CertificateSerialNumber serialNumber;
        AlgorithmIdentifier signature;
        Name            issuer;
        Validity        validity;
        Name            subject;
        SubjectPublicKeyInfo subjectPublicKeyInfo;
        UniqueIdentifier issuerUniqueIdentifier;  /* optional */
        UniqueIdentifier subjectUniqueIdentifier;  /* optional */
    } toBeSigned;
    AlgorithmIdentifier algorithmIdentifier;
    struct {
        unsigned int    length;  /* number of significant bits */
        unsigned char   *value;
    } encrypted;
} Certificate;

typedef TYPE_IDENTIFIER ALGORITHM;

typedef struct CertificatePair {
    unsigned char   bit_mask;
#       define      forward_present 0x80
#       define      reverse_present 0x40
    Certificate     forward;  /* optional */
    Certificate     reverse;  /* optional */
} CertificatePair;

typedef struct CertificationPath {
    unsigned char   bit_mask;
#       define      theCACertificates_present 0x80
    Certificate     userCertificate;
    struct _seqof1 {
        struct _seqof1  *next;
        CertificatePair value;
    } *theCACertificates;  /* optional */
} CertificationPath;

typedef struct AttributeTypeAndValue {
    struct ObjectID_ *type;
    OpenType        value;
} AttributeTypeAndValue;

typedef struct RDNSequence_ {
    struct RDNSequence_ *next;
    struct RelativeDistinguishedName_ *value;
} *RDNSequence;

typedef struct RelativeDistinguishedName_ {
    struct RelativeDistinguishedName_ *next;
    AttributeTypeAndValue value;
} *RelativeDistinguishedName;

typedef enum AttributeUsage {
    userApplications = 0,
    directoryOperation = 1,
    distributedOperation = 2,
    dSAOperation = 3
} AttributeUsage;

typedef struct ATTRIBUTE {
    unsigned char   bit_mask;
#       define      Type_present 0x80
#       define      single_valued_present 0x40
#       define      collective_present 0x20
#       define      no_user_modification_present 0x10
#       define      usage_present 0x08
    struct ATTRIBUTE *derivation;  /* NULL for not present */
    unsigned short  Type;  /* optional */
    struct MATCHING_RULE *equality_match;  /* NULL for not present */
    struct MATCHING_RULE *ordering_match;  /* NULL for not present */
    struct MATCHING_RULE *substrings_match;  /* NULL for not present */
    ossBoolean      single_valued;  /* default assumed if omitted */
    ossBoolean      collective;  /* default assumed if omitted */
    ossBoolean      no_user_modification;  /* default assumed if omitted */
    AttributeUsage  usage;  /* default assumed if omitted */
    struct ObjectID_ *id;
} ATTRIBUTE;

typedef struct MATCHING_RULE {
    unsigned char   bit_mask;
#       define      AssertionType_present 0x80
    unsigned short  AssertionType;  /* optional */
    struct ObjectID_ *id;
} MATCHING_RULE;

typedef unsigned int    MessageID;

typedef struct LDAPString {
    unsigned int    length;
    unsigned char   *value;
} LDAPString;

typedef LDAPString      LDAPDN;

typedef struct SaslCredentials {
    LDAPString      mechanism;
    struct _octet1 {
        unsigned int    length;
        unsigned char   *value;
    } credentials;
} SaslCredentials;

typedef struct AuthenticationChoice {
    unsigned short  choice;
#       define      simple_chosen 1
#       define      sasl_chosen 2
#       define      sicilyNegotiate_chosen 3
#       define      sicilyInitial_chosen 4
#       define      sicilySubsequent_chosen 5
#       define      sasl_v3response_chosen 1001
    union _union {
        struct _octet2 {
            unsigned int    length;
            unsigned char   *value;
        } simple;
        SaslCredentials sasl;
        struct _octet1 {
            unsigned int    length;
            unsigned char   *value;
        } sicilyNegotiate;
        struct _octet2_2 {
            unsigned int    length;
            unsigned char   *value;
        } sicilyInitial;
        struct _octet3 {
            unsigned int    length;
            unsigned char   *value;
        } sicilySubsequent;
    } u;
} AuthenticationChoice;

typedef struct BindRequest {
    unsigned short  version;
    LDAPDN          name;
    AuthenticationChoice authentication;
} BindRequest;

typedef enum _enum1 {
    success = 0,
    operationsError = 1,
    protocolError = 2,
    timeLimitExceeded = 3,
    sizeLimitExceeded = 4,
    compareFalse = 5,
    compareTrue = 6,
    authMethodNotSupported = 7,
    strongAuthRequired = 8,
    referralv2 = 9,
    referral = 10,
    adminLimitExceeded = 11,
    unavailableCriticalExtension = 12,
    confidentialityRequired = 13,
    saslBindInProgress = 14,
    noSuchAttribute = 16,
    undefinedAttributeType = 17,
    inappropriateMatching = 18,
    constraintViolation = 19,
    attributeOrValueExists = 20,
    invalidAttributeSyntax = 21,
    noSuchObject = 32,
    aliasProblem = 33,
    invalidDNSyntax = 34,
    aliasDereferencingProblem = 36,
    inappropriateAuthentication = 48,
    invalidCredentials = 49,
    insufficientAccessRights = 50,
    busy = 51,
    unavailable = 52,
    unwillingToPerform = 53,
    loopDetect = 54,

    sortControlMissing = 60,
    indexRangeError = 61,

    namingViolation = 64,
    objectClassViolation = 65,
    notAllowedOnNonLeaf = 66,
    notAllowedOnRDN = 67,
    entryAlreadyExists = 68,
    objectClassModsProhibited = 69,
    resultsTooLarge = 70,
    affectsMultipleDSAs = 71,
    other = 80
} _enum1;

typedef struct BindResponse {
    unsigned char   bit_mask;
#       define      BindResponse_referral_present 0x80
#       define      serverCreds_present 0x40
#       define      BindResponse_ldapv3 0x20
    _enum1          resultCode;
    LDAPDN          matchedDN;
    LDAPString      errorMessage;
    struct Referral_ *BindResponse_referral;  /* optional */
    AuthenticationChoice serverCreds;  /* optional */
} BindResponse;

typedef Nulltype        UnbindRequest;

typedef LDAPString      AttributeDescription;

typedef struct AssertionValue {
    unsigned int    length;
    unsigned char   *value;
} AssertionValue;

typedef struct AttributeValueAssertion {
    AttributeDescription attributeDesc;
    AssertionValue  assertionValue;
} AttributeValueAssertion;

typedef struct SubstringFilter {
    AttributeDescription type;
    struct SubstringFilterList_ *substrings;
} SubstringFilter;

typedef LDAPString      AttributeType;

typedef LDAPString      MatchingRuleId;

typedef struct MatchingRuleAssertion {
    unsigned char   bit_mask;
#       define      matchingRule_present 0x80
#       define      type_present 0x40
#       define      dnAttributes_present 0x20
    MatchingRuleId  matchingRule;  /* optional */
    AttributeDescription type;  /* optional */
    AssertionValue  matchValue;
    ossBoolean      dnAttributes;  /* default assumed if omitted */
} MatchingRuleAssertion;

typedef struct Filter {
    unsigned short  choice;
#       define      and_chosen 1
#       define      or_chosen 2
#       define      not_chosen 3
#       define      equalityMatch_chosen 4
#       define      substrings_chosen 5
#       define      greaterOrEqual_chosen 6
#       define      lessOrEqual_chosen 7
#       define      present_chosen 8
#       define      approxMatch_chosen 9
#       define      extensibleMatch_chosen 10
    union _union {
        struct _setof3_ *and;
        struct _setof4_ *or;
        struct Filter   *not;
        AttributeValueAssertion equalityMatch;
        SubstringFilter substrings;
        AttributeValueAssertion greaterOrEqual;
        AttributeValueAssertion lessOrEqual;
        AttributeType   present;
        AttributeValueAssertion approxMatch;
        MatchingRuleAssertion extensibleMatch;
    } u;
} Filter;

typedef struct _setof3_ {
    struct _setof3_ *next;
    Filter          value;
} *_setof3;

typedef struct _setof4_ {
    struct _setof4_ *next;
    Filter          value;
} *_setof4;

typedef enum _enum2 {
    baseObject = 0,
    singleLevel = 1,
    wholeSubtree = 2
} _enum2;

typedef enum _enum3 {
    neverDerefAliases = 0,
    derefInSearching = 1,
    derefFindingBaseObj = 2,
    derefAlways = 3
} _enum3;

typedef struct SearchRequest {
    LDAPDN          baseObject;
    _enum2          scope;
    _enum3          derefAliases;
    unsigned int    sizeLimit;
    unsigned int    timeLimit;
    ossBoolean      typesOnly;
    Filter          filter;
    struct AttributeDescriptionList_ *attributes;
} SearchRequest;

typedef struct SearchResultEntry {
    LDAPDN          objectName;
    struct PartialAttributeList_ *attributes;
} SearchResultEntry;

typedef struct LDAPResult {
    unsigned char   bit_mask;
#       define      LDAPResult_referral_present 0x80
    _enum1          resultCode;
    LDAPDN          matchedDN;
    LDAPString      errorMessage;
    struct Referral_ *LDAPResult_referral;  /* optional */
} LDAPResult;

typedef LDAPResult      SearchResultDone;

typedef struct ModifyRequest {
    LDAPDN          object;
    struct ModificationList_ *modification;
} ModifyRequest;

typedef LDAPResult      ModifyResponse;

typedef struct AddRequest {
    LDAPDN          entry;
    struct AttributeList_ *attributes;
} AddRequest;

typedef LDAPResult      AddResponse;

typedef LDAPDN          DelRequest;

typedef LDAPResult      DelResponse;

typedef LDAPString      RelativeLDAPDN;

typedef struct ModifyDNRequest {
    unsigned char   bit_mask;
#       define      newSuperior_present 0x80
    LDAPDN          entry;
    RelativeLDAPDN  newrdn;
    ossBoolean      deleteoldrdn;
    LDAPDN          newSuperior;  /* optional */
} ModifyDNRequest;

typedef LDAPResult      ModifyDNResponse;

typedef struct CompareRequest {
    LDAPDN          entry;
    AttributeValueAssertion ava;
} CompareRequest;

typedef LDAPResult      CompareResponse;

typedef MessageID       AbandonRequest;

typedef struct LDAPOID {
    unsigned int    length;
    unsigned char   *value;
} LDAPOID;

typedef struct ExtendedRequest {
    LDAPOID         requestName;
    struct {
        unsigned int    length;
        unsigned char   *value;
    } requestValue;
} ExtendedRequest;

typedef struct ExtendedResponse {
    unsigned char   bit_mask;
#       define      ExtendedResponse_referral_present 0x80
#       define      responseName_present 0x40
#       define      response_present 0x20
    _enum1          resultCode;
    LDAPDN          matchedDN;
    LDAPString      errorMessage;
    struct Referral_ *ExtendedResponse_referral;  /* optional */
    LDAPOID         responseName;  /* optional */
    struct {
        unsigned int    length;
        unsigned char   *value;
    } response;  /* optional */
} ExtendedResponse;

typedef struct _choice1_1 {
    unsigned short  choice;
#       define      bindRequest_chosen 1
#       define      bindResponse_chosen 2
#       define      unbindRequest_chosen 3
#       define      searchRequest_chosen 4
#       define      searchResEntry_chosen 5
#       define      searchResDone_chosen 6
#       define      searchResRef_chosen 7
#       define      modifyRequest_chosen 8
#       define      modifyResponse_chosen 9
#       define      addRequest_chosen 10
#       define      addResponse_chosen 11
#       define      delRequest_chosen 12
#       define      delResponse_chosen 13
#       define      modDNRequest_chosen 14
#       define      modDNResponse_chosen 15
#       define      compareRequest_chosen 16
#       define      compareResponse_chosen 17
#       define      abandonRequest_chosen 18
#       define      extendedReq_chosen 19
#       define      extendedResp_chosen 20
    union _union {
        BindRequest     bindRequest;
        BindResponse    bindResponse;
        UnbindRequest   unbindRequest;
        SearchRequest   searchRequest;
        SearchResultEntry searchResEntry;
        SearchResultDone searchResDone;
        struct SearchResultReference_ *searchResRef;
        ModifyRequest   modifyRequest;
        ModifyResponse  modifyResponse;
        AddRequest      addRequest;
        AddResponse     addResponse;
        DelRequest      delRequest;
        DelResponse     delResponse;
        ModifyDNRequest modDNRequest;
        ModifyDNResponse modDNResponse;
        CompareRequest  compareRequest;
        CompareResponse compareResponse;
        AbandonRequest  abandonRequest;
        ExtendedRequest extendedReq;
        ExtendedResponse extendedResp;
    } u;
} _choice1_1;

typedef struct LDAPMsg {
    unsigned char   bit_mask;
#       define      controls_present 0x80
    MessageID       messageID;
    _choice1_1      protocolOp;
    struct Controls_ *controls;  /* optional */
} LDAPMsg;

typedef struct AttributeDescriptionList_ {
    struct AttributeDescriptionList_ *next;
    AttributeDescription value;
} *AttributeDescriptionList;

typedef struct AttributeValue {
    unsigned int    length;
    unsigned char   *value;
} AttributeValue;

typedef struct AttributeVals_ {
    struct AttributeVals_ *next;
    AttributeValue  value;
} *AttributeVals;

typedef struct Attribute {
    AttributeDescription type;
    struct AttributeVals_ *vals;
} Attribute;

typedef LDAPString      LDAPURL;

typedef struct Referral_ {
    struct Referral_ *next;
    LDAPURL         value;
} *Referral;

typedef struct Control {
    unsigned char   bit_mask;
#       define      criticality_present 0x80
    LDAPOID         controlType;
    ossBoolean      criticality;  /* default assumed if omitted */
    struct _octet4 {
        unsigned int    length;
        unsigned char   *value;
    } controlValue;
} Control;

typedef struct Controls_ {
    struct Controls_ *next;
    Control         value;
} *Controls;

typedef struct _choice1 {
    unsigned short  choice;
#       define      initial_chosen 1
#       define      any_chosen 2
#       define      final_chosen 3
    union _union {
        LDAPString      initial;
        LDAPString      any;
        LDAPString      final;
    } u;
} _choice1;

typedef struct SubstringFilterList_ {
    struct SubstringFilterList_ *next;
    _choice1        value;
} *SubstringFilterList;

typedef struct PagedResultsSearchControlValue {
    unsigned int    size;
    struct _octet4 {
        unsigned int    length;
        unsigned char   *value;
    } cookie;
} PagedResultsSearchControlValue;

typedef struct ReplicationSearchControlValue {
    unsigned int    flag;
    unsigned int    size;
    struct _octet4 {
        unsigned int    length;
        unsigned char   *value;
    } cookie;
} ReplicationSearchControlValue;

typedef struct SecurityDescriptorSearchControlValue {
    unsigned int    flags;
} SecurityDescriptorSearchControlValue;

typedef struct AttributeListElement {
    AttributeDescription type;
    struct AttributeVals_ *vals;
} AttributeListElement;

typedef struct PartialAttributeList_ {
    struct PartialAttributeList_ *next;
    AttributeListElement value;
} *PartialAttributeList;

typedef struct SearchResultReference_ {
    struct SearchResultReference_ *next;
    LDAPURL         value;
} *SearchResultReference;

typedef struct _choice3 {
    unsigned short  choice;
#       define      entry_chosen 1
#       define      reference_chosen 2
#       define      resultCode_chosen 3
    union _union {
        SearchResultEntry entry;
        struct SearchResultReference_ *reference;
        SearchResultDone resultCode;
    } u;
} _choice3;

typedef struct SearchResultFull_ {
    struct SearchResultFull_ *next;
    _choice3        value;
} *SearchResultFull;

typedef struct AttributeTypeAndValues {
    AttributeDescription type;
    struct _setof1 {
        struct _setof1  *next;
        AttributeValue  value;
    } *vals;
} AttributeTypeAndValues;

typedef enum _enum1_2 {
    add = 0,
    operation_delete = 1,
    replace = 2
} _enum1_2;

typedef struct ModificationList_ {
    struct ModificationList_ *next;
    struct {
        _enum1_2        operation;
        AttributeTypeAndValues modification;
    } value;
} *ModificationList;

typedef struct AttributeList_ {
    struct AttributeList_ *next;
    AttributeListElement value;
} *AttributeList;

typedef struct ProtectedPassword {
    unsigned char   bit_mask;
#       define      time1_present 0x80
#       define      time2_present 0x40
#       define      random1_present 0x20
#       define      random2_present 0x10
    UTCTime         time1;  /* optional */
    UTCTime         time2;  /* optional */
    struct {
        unsigned int    length;  /* number of significant bits */
        unsigned char   *value;
    } random1;  /* optional */
    struct {
        unsigned int    length;  /* number of significant bits */
        unsigned char   *value;
    } random2;  /* optional */
    LDAPOID         algorithmIdentifier;
    struct {
        unsigned int    length;  /* number of significant bits */
        unsigned char   *value;
    } encipheredPassword;
} ProtectedPassword;

typedef struct StrongCredentials {
    unsigned char   bit_mask;
#       define      certification_path_present 0x80
    CertificationPath certification_path;  /* optional */
    Token           bind_token;
} StrongCredentials;

typedef struct SortKeyList_ {
    struct SortKeyList_ *next;
    struct {
        unsigned char   bit_mask;
#           define      orderingRule_present 0x80
#           define      reverseOrder_present 0x40
        AttributeType   attributeType;
        MatchingRuleId  orderingRule;  /* optional */
        ossBoolean      reverseOrder;  /* default assumed if omitted */
    } value;
} *SortKeyList;

typedef enum _enum1_4 {
    sortSuccess = 0,
    sortOperationsError = 1,
    sortTimeLimitExceeded = 2,
    sortStrongAuthRequired = 8,
    sortAdminLimitExceeded = 11,
    sortNoSuchAttribute = 16,
    sortInappropriateMatching = 18,
    sortInsufficientAccessRights = 50,
    sortBusy = 51,
    sortUnwillingToPerform = 53,
    sortOther = 80
} _enum1_4;

typedef struct SortResult {
    unsigned char   bit_mask;
#       define      attributeType_present 0x80
    _enum1_4        sortResult;
    AttributeType   attributeType;  /* optional */
} SortResult;

extern ID ds;

extern ID attributeType;

extern ID matchingRule;

extern ID id_at;

extern ID id_mr;

extern ATTRIBUTE objectClass;

extern ATTRIBUTE aliasedEntryName;

extern MATCHING_RULE objectIdentifierMatch;

extern MATCHING_RULE distinguishedNameMatch;

extern ObjectID id_at_objectClass;

extern ObjectID id_at_aliasedEntryName;

extern ObjectID id_mr_objectIdentifierMatch;

extern ObjectID id_mr_distinguishedNameMatch;

extern int maxInt;


extern void *ldap;    /* encoder-decoder control table */
#ifdef __cplusplus
}	/* extern "C" */
#endif /* __cplusplus */
#endif /* OSS_ldap */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\cryptdll.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        cryptdll.h
//
// Contents:    How to use the crypt support dll
//
//
// History:     04 Jun 92   RichardW    Created
//
//------------------------------------------------------------------------

#ifndef __CRYPTDLL_H__
#define __CRYPTDLL_H__

typedef PVOID   PCRYPT_STATE_BUFFER;

typedef NTSTATUS (NTAPI * PCRYPT_INITIALIZE_FN)(
    PUCHAR,
    ULONG,
    ULONG,
    PCRYPT_STATE_BUFFER *
    );

typedef NTSTATUS (NTAPI * PCRYPT_ENCRYPT_FN)(
    PCRYPT_STATE_BUFFER StateBuffer,
    PUCHAR InputBuffer,
    ULONG InputBufferSize,
    PUCHAR OutputBuffer,
    PULONG OutputBufferSize
    );

typedef NTSTATUS (NTAPI * PCRYPT_DECRYPT_FN)(
    PCRYPT_STATE_BUFFER StateBuffer,
    PUCHAR InputBuffer,
    ULONG InputBufferSize,
    PUCHAR OutputBuffer,
    PULONG OutputBufferSize
    );

typedef NTSTATUS (NTAPI * PCRYPT_DISCARD_FN)(
    PCRYPT_STATE_BUFFER *
    );

typedef NTSTATUS (NTAPI * PCRYPT_HASH_STRING_FN)(
    PUNICODE_STRING String,
    PUCHAR Buffer
    );
typedef NTSTATUS (NTAPI * PCRYPT_RANDOM_KEY_FN)(
    OPTIONAL PUCHAR Seed,
    OPTIONAL ULONG SeedLength,
    PUCHAR Key
    );

typedef NTSTATUS (NTAPI * PCRYPT_CONTROL_FN)(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    );

//
// functions for CryptControl
#define CRYPT_CONTROL_SET_INIT_VECT     0x1


typedef struct _CRYPTO_SYSTEM {
    ULONG EncryptionType;
    ULONG BlockSize;
    ULONG ExportableEncryptionType;
    ULONG KeySize;
    ULONG HeaderSize;
    ULONG PreferredCheckSum;
    ULONG Attributes;
    PWSTR Name;
    PCRYPT_INITIALIZE_FN Initialize;
    PCRYPT_ENCRYPT_FN Encrypt;
    PCRYPT_DECRYPT_FN Decrypt;
    PCRYPT_DISCARD_FN Discard;
    PCRYPT_HASH_STRING_FN HashString;
    PCRYPT_RANDOM_KEY_FN RandomKey;
    PCRYPT_CONTROL_FN Control;
} CRYPTO_SYSTEM, *PCRYPTO_SYSTEM;

#define CSYSTEM_USE_PRINCIPAL_NAME      0x01
#define CSYSTEM_EXPORT_STRENGTH         0x02
#define CSYSTEM_INTEGRITY_PROTECTED     0x04

NTSTATUS NTAPI
CDRegisterCSystem(PCRYPTO_SYSTEM);

NTSTATUS NTAPI
CDBuildVect(
    PULONG EncryptionTypesAvailable,
    PULONG EncryptionTypes
    );

NTSTATUS NTAPI
CDBuildIntegrityVect(
    PULONG      pcCSystems,
    PULONG      pdwEtypes
    );


NTSTATUS NTAPI
CDLocateCSystem(
    ULONG EncryptionType,
    PCRYPTO_SYSTEM * CryptoSystem
    );


NTSTATUS NTAPI
CDFindCommonCSystem(
    ULONG EncryptionTypeCount,
    PULONG EncryptionTypes,
    PULONG CommonEncryptionType
    );

NTSTATUS NTAPI
CDFindCommonCSystemWithKey(
    IN ULONG EncryptionEntries,
    IN PULONG EncryptionTypes,
    IN ULONG KeyTypeCount,
    IN PULONG KeyTypes,
    OUT PULONG CommonEtype
    );



////////////////////////////////////////////////////////////////////

typedef PVOID PCHECKSUM_BUFFER;

typedef NTSTATUS (NTAPI * PCHECKSUM_INITIALIZE_FN)(ULONG, PCHECKSUM_BUFFER *);
typedef NTSTATUS (NTAPI * PCHECKSUM_INITIALIZEEX_FN)(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);
// add the ex2 function to allow the checksum to be passed in for verification
// this is passed in the 4th parameter
// this is necessary for checksums which use confounders, where the confounder must
// be pulled from the checksum in order to calculate a new checksum when verifying
typedef NTSTATUS (NTAPI * PCHECKSUM_INITIALIZEEX2_FN)(PUCHAR, ULONG, PUCHAR, ULONG, PCHECKSUM_BUFFER *);
typedef NTSTATUS (NTAPI * PCHECKSUM_SUM_FN)(PCHECKSUM_BUFFER, ULONG, PUCHAR);
typedef NTSTATUS (NTAPI * PCHECKSUM_FINALIZE_FN)(PCHECKSUM_BUFFER, PUCHAR);
typedef NTSTATUS (NTAPI * PCHECKSUM_FINISH_FN)(PCHECKSUM_BUFFER *);

typedef struct _CHECKSUM_FUNCTION {
    ULONG CheckSumType;
    ULONG CheckSumSize;
    ULONG Attributes;
    PCHECKSUM_INITIALIZE_FN Initialize;
    PCHECKSUM_SUM_FN Sum;
    PCHECKSUM_FINALIZE_FN Finalize;
    PCHECKSUM_FINISH_FN Finish;
    PCHECKSUM_INITIALIZEEX_FN InitializeEx;
    PCHECKSUM_INITIALIZEEX2_FN InitializeEx2;  // allows passing in the checksum on intialization for verification 
} CHECKSUM_FUNCTION, *PCHECKSUM_FUNCTION;

#define CKSUM_COLLISION     0x00000001
#define CKSUM_KEYED         0x00000002


#define CHECKSUM_SHA1       131

NTSTATUS NTAPI
CDRegisterCheckSum( PCHECKSUM_FUNCTION);


NTSTATUS NTAPI
CDLocateCheckSum( ULONG, PCHECKSUM_FUNCTION *);



//////////////////////////////////////////////////////////////



typedef BOOLEAN (NTAPI * PRANDOM_NUMBER_GENERATOR_FN)(PUCHAR, ULONG);


typedef struct _RANDOM_NUMBER_GENERATOR {
    ULONG GeneratorId;
    ULONG Attributes;
    ULONG Seed;
    PRANDOM_NUMBER_GENERATOR_FN GenerateBitstream;
} RANDOM_NUMBER_GENERATOR, *PRANDOM_NUMBER_GENERATOR;

#define RNG_PSEUDO_RANDOM   0x00000001  // Pseudo-random function
#define RNG_NOISE_CIRCUIT   0x00000002  // Noise circuit (ZNR diode, eg)
#define RNG_NATURAL_PHENOM  0x00000004  // Natural sampler (geiger counter)

BOOLEAN NTAPI
CDGenerateRandomBits(PUCHAR pBuffer,
                     ULONG  cbBuffer);

BOOLEAN NTAPI
CDRegisterRng(PRANDOM_NUMBER_GENERATOR    pRng);

BOOLEAN NTAPI
CDLocateRng(ULONG                       Id,
            PRANDOM_NUMBER_GENERATOR *    ppRng);

#define CD_BUILTIN_RNG  1


///////////////////////////////////////////////////////////
//
// Error codes
//
///////////////////////////////////////////////////////////


#define SEC_E_ETYPE_NOT_SUPP            0x80080341
#define SEC_E_CHECKSUM_NOT_SUPP         0x80080342
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\netlogp.h ===
/*++

Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    netlogp.h

Abstract:

    Private interfaces to the Netlogon service.

Author:

    Cliff Van Dyke (cliffv) 10-Oct-1996

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


#ifndef _NETLOGP_H_
#define _NETLOGP_H_

NTSTATUS
NetLogonSetServiceBits(
    IN LPWSTR ServerName,
    IN DWORD ServiceBitsOfInterest,
    IN DWORD ServiceBits
    );

NET_API_STATUS NET_API_FUNCTION
I_NetlogonGetTrustRid(
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR DomainName OPTIONAL,
    OUT PULONG Rid
    );

#define NL_DIGEST_SIZE 16

NET_API_STATUS NET_API_FUNCTION
I_NetlogonComputeServerDigest(
    IN LPWSTR ServerName OPTIONAL,
    IN ULONG Rid,
    IN LPBYTE Message,
    IN ULONG MessageSize,
    OUT CHAR NewMessageDigest[NL_DIGEST_SIZE],
    OUT CHAR OldMessageDigest[NL_DIGEST_SIZE]
    );

NET_API_STATUS NET_API_FUNCTION
I_NetlogonComputeClientDigest(
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR DomainName OPTIONAL,
    IN LPBYTE Message,
    IN ULONG MessageSize,
    OUT CHAR NewMessageDigest[NL_DIGEST_SIZE],
    OUT CHAR OldMessageDigest[NL_DIGEST_SIZE]
    );

NET_API_STATUS
NetLogonGetTimeServiceParentDomain(
    IN LPWSTR ServerName OPTIONAL,
    OUT LPWSTR *DomainName,
    OUT PBOOL PdcSameSite
    );

#endif // _NETLOGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\nds32.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Nds32.h

Abstract:

    This module defines functions to access and manage Novell NDS Directory
    objects and attributes using the Microsoft NT Netware redirector.


    ---- NDS Object functions ----

    NwNdsAddObject
    NwNdsCloseObject
    NwNdsGetEffectiveRights
    NwNdsListSubObjects
    NwNdsModifyObject
    NwNdsMoveObject
    NwNdsOpenObject
    NwNdsReadObject
    NwNdsRemoveObject
    NwNdsRenameObject


    ---- NDS Buffer functions ----

    NwNdsCreateBuffer
    NwNdsFreeBuffer


    ---- NDS Marshaling functions to prepare or read data buffers ----

    NwNdsGetAttrDefListFromBuffer
    NwNdsGetAttrListFromBuffer
    NwNdsGetClassDefListFromBuffer
    NwNdsGetObjectListFromBuffer
    NwNdsPutInBuffer


    ---- NDS Schema functions ----

    NwNdsAddAttributeToClass
    NwNdsDefineAttribute
    NwNdsDefineClass
    NwNdsDeleteAttrDef
    NwNdsDeleteClassDef
    NwNdsGetSyntaxID
    NwNdsReadAttrDef
    NwNdsReadClassDef


    ---- NDS Schema functions under investigation ----

    NwNdsListContainableClasses(IN ParentObjectHandle,OUT ListOfClassNames);


    ---- NDS Search functions ----

    NwNdsCreateQueryNode
    NwNdsDeleteQueryNode
    NwNdsDeleteQueryTree
    NwNdsSearch


    ---- NDS Special functions ----

    NwNdsChangeUserPassword


    ---- NDS File functions under investigation ----

    NwNdsAddTrusteeToFile
    NwNdsAllocateFileHandle
    NwNdsDeallocateFileHandle
    NwNdsGetEffectiveDirectoryRights
    NwNdsGetObjectEffectiveRights
    NwNdsRemoveTrusteeFromFile


Author:

    Glenn Curtis    [GlennC]    15-Dec-1995
    Glenn Curtis    [GlennC]    04-Apr-1996 - Added Schema APIs

--*/

#ifndef __NDSOBJ32_H
#define __NDSOBJ32_H

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include "ndssntx.h"
#include "ndsattr.h"
#include "ndsclass.h"


/* Netware NDS general definitions */

#define NDS_MAX_NAME_CHARS           256
#define NDS_MAX_NAME_SIZE            ( NDS_MAX_NAME_CHARS * 2 )
#define NDS_MAX_SCHEMA_NAME_CHARS    32
#define NDS_MAX_SCHEMA_NAME_BYTES    ( 2 * ( NDS_MAX_SCHEMA_NAME_CHARS + 1 ) )
#define NDS_MAX_TREE_NAME_LEN        32
#define NDS_MAX_ASN1_NAME_LEN        32
#define NDS_NO_MORE_ITERATIONS       0xFFFFFFFF
#define NDS_INITIAL_SEARCH           0xFFFFFFFF


/* Netware NDS create buffer operations */

#define NDS_OBJECT_ADD               0
#define NDS_OBJECT_MODIFY            1
#define NDS_OBJECT_READ              2
#define NDS_OBJECT_LIST_SUBORDINATES 3
#define NDS_SCHEMA_DEFINE_CLASS      4
#define NDS_SCHEMA_READ_ATTR_DEF     5
#define NDS_SCHEMA_READ_CLASS_DEF    6
#define NDS_SEARCH                   7


/* Netware NDS attribute modification operations */

#define NDS_ATTR_ADD              0 /* Add first value to an attribute,
                                       error if it already exists */
#define NDS_ATTR_REMOVE           1 /* Remove all values from an attribute,
                                       error if attribute doesn't exist */
#define NDS_ATTR_ADD_VALUE        2 /* Add first or additional value to
                                       an attribute, error if duplicate */
#define NDS_ATTR_REMOVE_VALUE     3 /* Remove a value from an attribute,
                                       error if it doesn't exist */
#define NDS_ATTR_ADDITIONAL_VALUE 4 /* Add additional value to an attribute,
                                       error if duplicate or first value */
#define NDS_ATTR_OVERWRITE_VALUE  5 /* Add first or additional value to an
                                       attribute, overwrite if duplicate */
#define NDS_ATTR_CLEAR            6 /* Remove all values from an attribute,
                                       no error if attribute doesn't exist */
#define NDS_ATTR_CLEAR_VALUE      7 /* Remove a value from an attribute,
                                       no error if it doesn't exist */


/* Netware NDS schema attribute definition flags */

#define NDS_SINGLE_VALUED_ATTR      0x0001
#define NDS_SIZED_ATTR              0x0002
#define NDS_NONREMOVABLE_ATTR       0x0004 // Only for NwNDSReadAttributeDef
#define NDS_READ_ONLY_ATTR          0x0008 // Only for NwNDSReadAttributeDef
#define NDS_HIDDEN_ATTR             0x0010 // Only for NwNDSReadAttributeDef
#define NDS_STRING_ATTR             0x0020 // Only for NwNDSReadAttributeDef
#define NDS_SYNC_IMMEDIATE          0x0040
#define NDS_PUBLIC_READ             0x0080
#define NDS_SERVER_READ             0x0100 // Only for NwNDSReadAttributeDef
#define NDS_WRITE_MANAGED           0x0200
#define NDS_PER_REPLICA             0x0400


/* Netware NDS schema class definition flags */

#define NDS_CONTAINER_CLASS               0x01
#define NDS_EFFECTIVE_CLASS               0x02
#define NDS_NONREMOVABLE_CLASS            0x04
#define NDS_AMBIGUOUS_NAMING              0x08
#define NDS_AMBIGUOUS_CONTAINMENT         0x10


/* Netware NDS information flags */

#define NDS_INFO_NAMES                     0 // Search and Read operations
#define NDS_INFO_ATTR_NAMES_VALUES         1 // Search operations
#define NDS_INFO_NAMES_DEFS                1 // Read operations
#define NDS_CLASS_INFO_EXPANDED_DEFS       2 // Schema class definition only


/* Netware NDS information flags - NOT YET SUPPORTED */

#define NDS_CLASS_INFO                     3 // Schema class definition only


/* Netware NDS attribute right definitions */

#define NDS_RIGHT_COMPARE_ATTR             0x00000001L
#define NDS_RIGHT_READ_ATTR                0x00000002L
#define NDS_RIGHT_WRITE_ATTR               0x00000004L
#define NDS_RIGHT_ADD_SELF_ATTR            0x00000008L
#define NDS_RIGHT_SUPERVISE_ATTR           0x00000020L


/* Netware NDS object right definitions */

#define NDS_RIGHT_BROWSE_OBJECT            0x00000001L
#define NDS_RIGHT_CREATE_OBJECT            0x00000002L
#define NDS_RIGHT_DELETE_OBJECT            0x00000004L
#define NDS_RIGHT_RENAME_OBJECT            0x00000008L
#define NDS_RIGHT_SUPERVISE_OBJECT         0x00000010L


/* Netware file right definitions */

#define NW_RIGHTS WORD

#define NW_RIGHT_NONE                     0x0000
#define NW_RIGHT_READ_FROM_FILE           0x0001
#define NW_RIGHT_WRITE_TO_FILE            0x0002
#define NW_RIGHT_CREATE_DIR_OR_FILE       0x0008
#define NW_RIGHT_ERASE_DIR_OR_FILE        0x0010
#define NW_RIGHT_ACCESS_CONTROL           0x0020
#define NW_RIGHT_FILE_SCAN                0x0040
#define NW_RIGHT_MODIFY_DIR_OR_FILE       0x0080
#define NW_RIGHT_SUPERVISOR               0x0100
#define NW_RIGHT_ALL                      NW_RIGHT_READ_FROM_FILE     | \
                                          NW_RIGHT_WRITE_TO_FILE      | \
                                          NW_RIGHT_CREATE_DIR_OR_FILE | \
                                          NW_RIGHT_ERASE_DIR_OR_FILE  | \
                                          NW_RIGHT_ACCESS_CONTROL     | \
                                          NW_RIGHT_FILE_SCAN          | \
                                          NW_RIGHT_MODIFY_DIR_OR_FILE


/* Netware NDS query node operations for building a search query */

#define NDS_QUERY_OR                       0x00000001L
#define NDS_QUERY_AND                      0x00000002L
#define NDS_QUERY_NOT                      0x00000003L
#define NDS_QUERY_EQUAL                    0x00000007L
#define NDS_QUERY_GE                       0x00000008L
#define NDS_QUERY_LE                       0x00000009L
#define NDS_QUERY_APPROX                   0x0000000AL
#define NDS_QUERY_PRESENT                  0x0000000FL


/* Netware NDS search query scopes */

#define NDS_SCOPE_ONE_LEVEL                0x00000000L
#define NDS_SCOPE_SUB_TREE                 0x00000001L
#define NDS_SCOPE_BASE_LEVEL               0x00000002L


/* Netware NDS function return codes */

#define NDS_ERR_SUCCESS                     0x00000000
#define NDS_ERR_NO_SUCH_ENTRY               0xFFFFFDA7
#define NDS_ERR_NO_SUCH_VALUE               0xFFFFFDA6
#define NDS_ERR_NO_SUCH_ATTRIBUTE           0xFFFFFDA5
#define NDS_ERR_NO_SUCH_CLASS               0xFFFFFDA4
#define NDS_ERR_NO_SUCH_PARTITION           0xFFFFFDA3
#define NDS_ERR_ENTRY_ALREADY_EXISTS        0xFFFFFDA2
#define NDS_ERR_NOT_EFFECTIVE_CLASS         0xFFFFFDA1
#define NDS_ERR_ILLEGAL_ATTRIBUTE           0xFFFFFDA0
#define NDS_ERR_MISSING_MANDATORY           0xFFFFFD9F
#define NDS_ERR_ILLEGAL_DS_NAME             0xFFFFFD9E
#define NDS_ERR_ILLEGAL_CONTAINMENT         0xFFFFFD9D
#define NDS_ERR_CANT_HAVE_MULTIPLE_VALUES   0xFFFFFD9C
#define NDS_ERR_SYNTAX_VIOLATION            0xFFFFFD9B
#define NDS_ERR_DUPLICATE_VALUE             0xFFFFFD9A
#define NDS_ERR_ATTRIBUTE_ALREADY_EXISTS    0xFFFFFD99
#define NDS_ERR_MAXIMUM_ENTRIES_EXIST       0xFFFFFD98
#define NDS_ERR_DATABASE_FORMAT             0xFFFFFD97
#define NDS_ERR_INCONSISTANT_DATABASE       0xFFFFFD96
#define NDS_ERR_INVALID_COMPARISON          0xFFFFFD95
#define NDS_ERR_COMPARISON_FAILED           0xFFFFFD94
#define NDS_ERR_TRANSACTIONS_DISABLED       0xFFFFFD93
#define NDS_ERR_INVALID_TRANSPORT           0xFFFFFD92
#define NDS_ERR_SYNTAX_INVALID_IN_NAME      0xFFFFFD91
#define NDS_ERR_REPLICA_ALREADY_EXISTS      0xFFFFFD90
#define NDS_ERR_TRANSPORT_FAILURE           0xFFFFFD8F
#define NDS_ERR_ALL_REFERRALS_FAILED        0xFFFFFD8E
#define NDS_ERR_CANT_REMOVE_NAMING_VALUE    0xFFFFFD8D
#define NDS_ERR_OBJECT_CLASS_VIOLATION      0xFFFFFD8C
#define NDS_ERR_ENTRY_IS_NOT_LEAF           0xFFFFFD8B
#define NDS_ERR_DIFFERENT_TREE              0xFFFFFD8A
#define NDS_ERR_ILLEGAL_REPLICA_TYPE        0xFFFFFD89
#define NDS_ERR_SYSTEM_FAILURE              0xFFFFFD88
#define NDS_ERR_INVALID_ENTRY_FOR_ROOT      0xFFFFFD87
#define NDS_ERR_NO_REFERRALS                0xFFFFFD86
#define NDS_ERR_REMOTE_FAILURE              0xFFFFFD85
#define NDS_ERR_PREVIOUS_MOVE_IN_PROGRESS   0xFFFFFD83
#define NDS_ERR_INVALID_REQUEST             0xFFFFFD7F
#define NDS_ERR_INVALID_ITERATION           0xFFFFFD7E
#define NDS_ERR_SCHEMA_IS_NONREMOVABLE      0xFFFFFD7D
#define NDS_ERR_SCHEMA_IS_IN_USE            0xFFFFFD7C
#define NDS_ERR_CLASS_ALREADY_EXISTS        0xFFFFFD7B
#define NDS_ERR_BAD_NAMING_ATTRIBUTES       0xFFFFFD7A
#define NDS_ERR_NOT_ROOT_PARTITION          0xFFFFFD79
#define NDS_ERR_INSUFFICIENT_STACK          0xFFFFFD78
#define NDS_ERR_INSUFFICIENT_BUFFER         0xFFFFFD77
#define NDS_ERR_AMBIGUOUS_CONTAINMENT       0xFFFFFD76
#define NDS_ERR_AMBIGUOUS_NAMING            0xFFFFFD75
#define NDS_ERR_DUPLICATE_MANDATORY         0xFFFFFD74
#define NDS_ERR_DUPLICATE_OPTIONAL          0xFFFFFD73
#define NDS_ERR_MULTIPLE_REPLICAS           0xFFFFFD71
#define NDS_ERR_CRUCIAL_REPLICA             0xFFFFFD70
#define NDS_ERR_SCHEMA_SYNC_IN_PROGRESS     0xFFFFFD6F
#define NDS_ERR_SKULK_IN_PROGRESS           0xFFFFFD6E
#define NDS_ERR_TIME_NOT_SYNCRONIZED        0xFFFFFD6D
#define NDS_ERR_RECORD_IN_USE               0xFFFFFD6C
#define NDS_ERR_DS_VOLUME_NOT_MOUNTED       0xFFFFFD6B
#define NDS_ERR_DS_VOLUME_IO_FAILURE        0xFFFFFD6A
#define NDS_ERR_DS_LOCKED                   0xFFFFFD69
#define NDS_ERR_OLD_EPOCH                   0xFFFFFD68
#define NDS_ERR_NEW_EPOCH                   0xFFFFFD67
#define NDS_ERR_PARTITION_ROOT              0xFFFFFD65
#define NDS_ERR_ENTRY_NOT_CONTAINER         0xFFFFFD64
#define NDS_ERR_FAILED_AUTHENTICATION       0xFFFFFD63
#define NDS_ERR_NO_SUCH_PARENT              0xFFFFFD61
#define NDS_ERR_NO_ACCESS                   0xFFFFFD60
#define NDS_ERR_REPLICA_NOT_ON              0xFFFFFD5F
#define NDS_ERR_DUPLICATE_ACL               0xFFFFFD5A
#define NDS_ERR_PARTITION_ALREADY_EXISTS    0xFFFFFD59
#define NDS_ERR_NOT_SUBREF                  0xFFFFFD58
#define NDS_ERR_ALIAS_OF_AN_ALIAS           0xFFFFFD57
#define NDS_ERR_AUDITING_FAILED             0xFFFFFD56
#define NDS_ERR_INVALID_API_VERSION         0xFFFFFD55
#define NDS_ERR_SECURE_NCP_VIOLATION        0xFFFFFD54
#define NDS_ERR_FATAL                       0xFFFFFD45


/* Structure definitions used */

typedef struct _WSTR_LIST_ELEM
{
    struct _WSTR_LIST_ELEM * Next;
    LPWSTR                   szString;

} WSTR_LIST_ELEM, * LPWSTR_LIST;

typedef struct
{
    DWORD length;
    BYTE  data[NDS_MAX_ASN1_NAME_LEN];

} ASN1_ID, * LPASN1_ID;

//
// NDS Attribute Definition structure
//
typedef struct
{
    LPWSTR  szAttributeName;
    DWORD   dwFlags;
    DWORD   dwSyntaxID;
    DWORD   dwLowerLimit;
    DWORD   dwUpperLimit;
    ASN1_ID asn1ID;

} NDS_ATTR_DEF, * LPNDS_ATTR_DEF;

//
// NDS Class Definition structure
//
typedef struct
{
    LPWSTR  szClassName;
    DWORD   dwFlags;
    ASN1_ID asn1ID;
    DWORD   dwNumberOfSuperClasses;
    LPWSTR_LIST lpSuperClasses;
    DWORD   dwNumberOfContainmentClasses;
    LPWSTR_LIST lpContainmentClasses;
    DWORD   dwNumberOfNamingAttributes;
    LPWSTR_LIST lpNamingAttributes;
    DWORD   dwNumberOfMandatoryAttributes;
    LPWSTR_LIST lpMandatoryAttributes;
    DWORD   dwNumberOfOptionalAttributes;
    LPWSTR_LIST lpOptionalAttributes;

} NDS_CLASS_DEF, * LPNDS_CLASS_DEF;

//
// If read results from NwNdsReadAttrDef, or NwNdsReadClassDef
// returned names only (no attribute or class definitions),
// then an array of these NDS_DEF_NAME_ONLY structures is returned.
//
typedef struct
{
    LPWSTR szName;

} NDS_NAME_ONLY, * LPNDS_NAME_ONLY;

//
// NDS Attribute Information structure
//
typedef struct
{
    LPWSTR szAttributeName;
    DWORD  dwSyntaxId;
    DWORD  dwNumberOfValues;
    LPBYTE lpValue;

} NDS_ATTR_INFO, * LPNDS_ATTR_INFO;

//
// NDS Object Information structure
//
typedef struct
{
    LPWSTR szObjectFullName;
    LPWSTR szObjectName;
    LPWSTR szObjectClass;
    DWORD  dwEntryId;
    DWORD  dwModificationTime;
    DWORD  dwSubordinateCount;
    DWORD  dwNumberOfAttributes; // Zero for NwNdsReadObject results.
    LPVOID lpAttribute;          // For NwNdsSearch results, cast this
                                 // to either LPNDS_ATTR_INFO or
                                 // LPNDS_NAME_ONLY, depending on value of
                                 // lpdwAttrInformationType from call to
                                 // NwNdsGetObjectListFromBuffer.

} NDS_OBJECT_INFO, * LPNDS_OBJECT_INFO;

//
// tommye MS bug 88021 / MCS 
//
//	Moved this structure here from nw/nwlib/nds32.c so it could be 
//	accessed by NwNdsObjectHandleToConnHandle() in nw/nwlib/nwapi32.c.
//  Renamed it from NDS_OBJECT to NDS_OBJECT_PRIV to avoid conflict
//	with other structure of the same name.
//

typedef struct
{
    DWORD      Signature;
    HANDLE     NdsTree;
    DWORD      ObjectId;
    DWORD      ResumeId;
    DWORD      NdsRawDataBuffer;
    DWORD      NdsRawDataSize;
    DWORD      NdsRawDataId;
    DWORD      NdsRawDataCount;
    WCHAR      szContainerName[NDS_MAX_NAME_CHARS];
    WCHAR      szRelativeName[NDS_MAX_NAME_CHARS];

} NDS_OBJECT_PRIV, * LPNDS_OBJECT_PRIV;

//
// List Subordinate Objects Search Filter structures
//
typedef struct
{
    LPWSTR szObjectClass;

} NDS_FILTER, * LPNDS_FILTER;

typedef struct
{
    DWORD      dwNumberOfFilters;
    NDS_FILTER Filters[1];

} NDS_FILTER_LIST, * LPNDS_FILTER_LIST;

//
// NDS Search Query Tree structure
//
typedef struct _QUERY_NODE
{
    DWORD dwOperation;
    DWORD dwSyntaxId;
    struct _QUERY_NODE * lpLVal;
    struct _QUERY_NODE * lpRVal;

} QUERY_NODE, * LPQUERY_NODE, * LPQUERY_TREE;

//
// Given an NDS object handle, provides the NDS object ID
//
#define NwNdsGetObjectId(hObject)  (((LPNDS_OBJECT_PRIV) hObject)->ObjectId)

/* API definitions */

DWORD
NwNdsAddObject(
    IN  HANDLE hParentObject,
    IN  LPWSTR szObjectName,
    IN  HANDLE hOperationData );
/*
   NwNdsAddObject()

   This function is used to add a leaf object to an NDS directory tree.

   Arguments:

       HANDLE           hParentObject - A handle to the parent object in
                        the directory tree to add a new leaf to. Handle is
                        obtained by calling NwNdsOpenObject.

       LPWSTR           szObjectName - The directory name that the new leaf
                        object will be known by.

       HANDLE           hOperationData - A buffer containing a list of
                        attributes and values to create the new object. This
                        buffer is manipulated by the following functions:
                            NwNdsCreateBuffer (NDS_OBJECT_ADD),
                            NwNdsPutInBuffer, and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsAddAttributeToClass(
    IN  HANDLE   hTree,
    IN  LPWSTR   szClassName,
    IN  LPWSTR   szAttributeName );
/*
   NwNdsAddAttributeToClass()

   This function is used to modify the schema definition of a class by adding
   an optional attribute to a particular class. Modification of existing NDS
   class defintions is limited to only adding additional optional attributes.

   NOTE: Currently this function only supports one attribute addition at a time.
         It is possible to provide a version of this function that can add more
         than one attribute at a time, although I don't think it will be
         neccessary. Schema manipulation is considered to be an uncommon event.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szClassName - The name of the class definition to be
                        modified.

       LPWSTR           szAttributeName - The name of the attribute to be added
                        as an optional attribute to the class defintion in the
                        schema.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsChangeUserPassword(
    IN  HANDLE hUserObject,
    IN  LPWSTR szOldPassword,
    IN  LPWSTR szNewPassword );
/*
   NwNdsChangeUserPassword()

   This function is used to change the password for a given user object
   in a NDS directory tree.

   Arguments:

       HANDLE           hUserObject - A handle to a specific user object in
                        the directory tree to change the password on. Handle
                        is obtained by calling NwNdsOpenObject.

       LPWSTR           szOldPassword - The current password set on the user
                        object hUserObject.

                          - OR -

                        If NwNdsChangeUserPassword is called from a client with
                        administrative priveleges to the specified user object
                        identified by hUserObject, then the szOldPassword
                        value can be blank (L""). This way resetting the user
                        password to szNewPassword.

       LPWSTR           szNewPassword - The new password to be set on the user
                        object hUserObject.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsCloseObject(
    IN  HANDLE hObject );
/*
   NwNdsCloseObject()

   This function is used to close the handle used to manipulate an object
   in an NDS directory tree. The handle must be one Opened by NwNdsOpenObject.

   Arguments:

       HANDLE           hObject - The handle of the object to be closed.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsCreateBuffer(
    IN  DWORD    dwOperation,
    OUT HANDLE * lphOperationData );
/*
   NwNdsCreateBuffer()

   This function is used to create a buffer used to describe object
   transactions to a specific object in an NDS directory tree. This routine
   allocates memory and is automatically resized as needed during calls
   to NwNdsPutInBuffer. This buffer must be freed with NwNdsFreeBuffer.

   Arguments:

       DWORD            dwOperation - Indicates how buffer is to be utilized.
                        Use defined values NDS_OBJECT_ADD, NDS_OBJECT_MODIFY,
                        NDS_OBJECT_READ, NDS_SCHEMA_DEFINE_CLASS,
                        NDS_SCHEMA_READ_ATTR_DEF, NDS_SCHEMA_READ_CLASS_DEF,
                        or NDS_SEARCH.

       HANDLE *         lphOperationData - Address of a HANDLE handle to
                        receive created buffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsCreateQueryNode(
    IN  DWORD          dwOperation,
    IN  LPVOID         lpLValue,
    IN  DWORD          dwSyntaxId,
    IN  LPVOID         lpRValue,
    OUT LPQUERY_NODE * lppQueryNode
);
/*
   NwNdsCreateQueryNode()

   This function is used to generate a tree node that is part of a query
   to be used with the function NwNdsSearch.

   Arguments:

       DWORD            dwOperation - Indicates the type of node to create
                        for a search query. Use one of the defined values
                        below:

                          NDS_QUERY_OR 
                          NDS_QUERY_AND :
                            These operations must have both lpLValue and
                            lpRValue pointing to a QUERY_NODE structure.
                            In this case the dwSyntaxId value is ignored.
                        
                          NDS_QUERY_NOT :
                            This operation must have lpLValue pointing to a
                            QUERY_NODE structure and lpRValue set to NULL.
                            In this case the dwSyntaxId value is ignored.

                          NDS_QUERY_EQUAL
                          NDS_QUERY_GE
                          NDS_QUERY_LE
                          NDS_QUERY_APPROX :
                            These operations must have lpLValue pointing to
                            a LPWSTR containing the name of an NDS attribute,
                            and lpRValue pointing to an ASN1 structure defined
                            in NdsSntx.h. dwSyntaxId must be set to the syntax
                            identifier of the ASN1 structure pointed to by
                            lpRValue.

                          NDS_QUERY_PRESENT :
                            This operation must have lpLValue pointing to a
                            LPWSTR containing the name of an NDS attribute,
                            and lpRValue set to NULL. In this case the
                            dwSyntaxId value is ignored.

       LPVOID           lpLValue - A pointer to either a QUERY_NODE structure
                        or a LPWSTR depending on the value for dwOperation.

       DWORD            dwSyntaxId - The syntax identifier of the ASN1
                        structure pointed to by lpRValue for the dwOperations
                        NDS_QUERY_EQUAL, NDS_QUERY_GE, NDS_QUERY_LE, or
                        NDS_QUERY_APPROX. For other dwOperation values, this
                        is ignored.

       LPVOID           lpRValue - A pointer to either a QUERY_NODE structure,
                        an ASN1 structure, or NULL, depending on the value for
                        dwOperation.

       LPQUERY_NODE *   lppQueryNode - Address of a LPQUERY_NODE to receive
                        a pointer to created node.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsDefineAttribute(
    IN  HANDLE   hTree,
    IN  LPWSTR   szAttributeName,
    IN  DWORD    dwFlags,
    IN  DWORD    dwSyntaxID,
    IN  DWORD    dwLowerLimit,
    IN  DWORD    dwUpperLimit,
    IN  ASN1_ID  asn1ID );
/*
   NwNdsDefineAttribute()

   This function is used to create an attribute definition in the schema of
   NDS tree hTree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szAttributeName - The name that the new attribute will
                        be referred to by.

       DWORD            dwFlags - Flags values to be set for new attribute
                        definition. Definitions for flag values are found at
                        the top of this file.

       DWORD            dwSyntaxID - The ID of the syntax structure to be use
                        for the new attribute. Syntax IDs and their associated
                        structures are defined in the file NdsSntx.h. According
                        to the NetWare NDS schema spec, there is and always will
                        be, only 28 (0..27) different syntaxes.

       DWORD            dwLowerLimit - The lower limit of a sized attribute
                        (dwFlags value set to NDS_SIZED_ATTR). Can be set to
                        zero if attribute is not sized.

       DWORD            dwUpperLimit - The upper limit of a sized attribute
                        (dwFlags value set to NDS_SIZED_ATTR). Can be set to
                        zero if attribute is not sized.

       ASN1_ID          asn1ID - The ASN.1 ID for the attribute. If no
                        attribute identifier has been registered, a
                        zero-length octet string is specified.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsDefineClass(
    IN  HANDLE   hTree,
    IN  LPWSTR   szClassName,
    IN  DWORD    dwFlags,
    IN  ASN1_ID  asn1ID,
    IN  HANDLE   hSuperClasses,
    IN  HANDLE   hContainmentClasses,
    IN  HANDLE   hNamingAttributes,
    IN  HANDLE   hMandatoryAttributes,
    IN  HANDLE   hOptionalAttributes );
/*
   NwNdsDefineClass()

   This function is used to create a class definition in the schema of
   NDS tree hTree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szClassName - The name that the new class will
                        be referred to by.

       DWORD            dwFlags - Flags values to be set for new class
                        definition. Definitions for flag values are found at
                        the top of this file.

       ASN1_ID          asn1ID - The ASN.1 ID for the class. If no
                        class identifier has been registered, a
                        zero-length octet string is specified.

       HANDLE(S)        hSuperClasses,
                        hContainmentClasses,
                        hNamingAttributes,
                        hMandatoryAttributes,
                        hOptionalAttributes -

                        Handle to buffers that contain class definition
                        information to create new class in schema.
                        These handles are manipulated by the following
                        functions:
                           NwNdsCreateBuffer (NDS_SCHEMA_DEFINE_CLASS),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                - OR -

                        Handles can be NULL to indicate that no list
                        is associated with the specific class defintion
                        item.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsDeleteAttrDef(
    IN  HANDLE   hTree,
    IN  LPWSTR   szAttributeName );
/*
   NwNdsDeleteAttrDef()

   This function is used to remove an attribute definition from the schema of
   NDS tree hTree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szAttributeName - The name of the attribute
                        defintion to remove.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsDeleteClassDef(
    IN  HANDLE   hTree,
    IN  LPWSTR   szClassName );
/*
   NwNdsDeleteClassDef()

   This function is used to remove a class definition from the schema of
   NDS tree hTree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szClassName - The name of the class defintion to remove.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


VOID
NwNdsDeleteQueryNode(
    IN  LPQUERY_NODE lpQueryNode
);
/*
   NwNdsDeleteQueryNode()

   This function is used to free a tree node that was part of a query
   used with the function NwNdsSearch.

   Arguments:

       LPQUERY_NODE     lpQueryNode - A pointer to a particular node of
                        a query tree that defines a search.

    Returns:

       Nothing
*/


DWORD
NwNdsDeleteQueryTree(
    IN  LPQUERY_TREE lpQueryTree
);
/*
   NwNdsDeleteQueryTree()

   This function is used to free a tree that describes a query that was
   used with the function NwNdsSearch.

   Arguments:

       LPQUERY_TREE     lpQueryTree - A pointer to the root of a query
                        tree that defines a search. The tree is created
                        manually by the user through the function
                        NwNdsCreateQueryNode.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsFreeBuffer(
    IN  HANDLE hOperationData );
/*
   NwNdsFreeBuffer()

   This function is used to free the buffer used to describe object
   operations to a specific object in an NDS directory tree. The buffer must
   be one created by NwNdsCreateBuffer, or returned by calling NwNdsReadObject.

   Arguments:

       HANDLE            hOperationData - Handle to buffer that is to be freed.

    Returns:

       NO_ERROR
       one of the error codes defined in the file winerror.h
*/


DWORD
NwNdsGetAttrDefListFromBuffer(
    IN  HANDLE   hOperationData,
    OUT LPDWORD  lpdwNumberOfEntries,
    OUT LPDWORD  lpdwInformationType,
    OUT LPVOID * lppEntries );
/*
   NwNdsGetAttrDefListFromBuffer()

   This function is used to retrieve an array of attribute definition entries
   for a schema that was read with a prior call to NwNdsReadAttrDef.

   Arguments:

       HANDLE           hOperationData - Buffer containing the read
                        response from calling NwNdsReadAttrDef.

       LPDWORD          lpdwNumberOfEntries - The address of a DWORD to
                        receive the number of array elements pointed to by
                        lppEntries.

       LPDWORD          lpdwInformationType - The address of a DWORD to
                        receive a value that indicates the type of information
                        returned by the call to NwNdsReadAttrDef.

       LPVOID *         lppEntries - The address of a pointer to the beginning
                        of an array of attribute schema structures. Each
                        structure contains the details of each attribute
                        definition read from a given schema by calling
                        NwNdsReadAttrDef. The lppEntries value should be
                        cast to either a LPNDS_ATTR_DEF or LPNDS_NAME_ONLY
                        structure depending on the value returned in
                        lpdwInformationType.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsGetAttrListFromBuffer(
    IN  HANDLE            hOperationData,
    OUT LPDWORD           lpdwNumberOfEntries,
    OUT LPNDS_ATTR_INFO * lppEntries );
/*
   NwNdsGetAttrListFromBuffer()

   This function is used to retrieve an array of attribute entries for an
   object that was read with a prior call to NwNdsReadObject.

   Arguments:

       HANDLE           hOperationData - Buffer containing the read
                        response from calling NwNdsReadObject.

       LPDWORD          lpdwNumberOfEntries - The address of a DWORD to
                        receive the number of array elements pointed to by
                        lppEntries.

       LPNDS_ATTR_INFO *
                        lppEntries - The address of a pointer to the beginning
                        of an array of NDS_ATTR_INFO structures. Each
                        structure contains the details of each attribute read
                        from a given object by calling NwNdsReadObject.
  
    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsGetClassDefListFromBuffer(
    IN  HANDLE   hOperationData,
    OUT LPDWORD  lpdwNumberOfEntries,
    OUT LPDWORD  lpdwInformationType,
    OUT LPVOID * lppEntries );
/*
   NwNdsGetClassDefListFromBuffer()

   This function is used to retrieve an array of class definition entries
   for a schema that was read with a prior call to NwNdsReadClassDef.

   Arguments:

       HANDLE           hOperationData - Buffer containing the read
                        response from calling NwNdsReadClassDef.

       LPDWORD          lpdwNumberOfEntries - The address of a DWORD to
                        receive the number of array elements pointed to by
                        lppEntries.

       LPDWORD          lpdwInformationType - The address of a DWORD to
                        receive a value that indicates the type of information
                        returned by the call to NwNdsReadClassDef.

       LPVOID *         lppEntries - The address of a pointer to the beginning
                        of an array of schema class structures. Each
                        structure contains the details of each class
                        definition read from a given schema by calling
                        NwNdsReadClassDef. The lppEntries value should be
                        cast to either a LPNDS_CLASS_DEF or LPNDS_NAME_ONLY
                        structure depending on the value returned in
                        lpdwInformationType.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsGetEffectiveRights(
    IN  HANDLE hObject,
    IN  LPWSTR szSubjectName,
    IN  LPWSTR szAttributeName,
    OUT LPDWORD lpdwRights );
/*
   NwNdsGetEffectiveRights()

   This function is used to determine the effective rights of a particular
   subject on a particular object in the NDS tree. The user needs to have
   appropriate priveleges to make the determination.

   Arguments:

       HANDLE           hObject - A handle to the object in the directory
                        tree to determine effective rights on. Handle is
                        obtained by calling NwNdsOpenObject.

       LPWSTR           szSubjectName - The distinguished name of user whose
                        rights we're interested in determining.

       LPWSTR           szAttributeName - Regular attribute name (i.e.
                        L"Surname" , L"CN" ) for reading a particular
                        attribute right, or L"[All Attributes Rights]" and
                        L"[Entry Rights]" can be used to determine the default
                        attribute rights and object rights respectively.

       LPDWORD          lpdwRights - A pointer to a DWORD to receive the
                        results. If the call is successful, lpdwRights will
                        contain a mask representing the subject's rights:

                           Attribute rights -  NDS_RIGHT_COMPARE_ATTR,
                              NDS_RIGHT_READ_ATTR, NDS_RIGHT_WRITE_ATTR,
                              NDS_RIGHT_ADD_SELF_ATTR, and
                              NDS_RIGHT_SUPERVISE_ATTR.

                           Object rights - NDS_RIGHT_BROWSE_OBJECT,
                              NDS_RIGHT_CREATE_OBJECT, NDS_RIGHT_DELETE_OBJECT,
                              NDS_RIGHT_RENAME_OBJECT, and
                              NDS_RIGHT_SUPERVISE_OBJECT.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsGetObjectListFromBuffer(
    IN  HANDLE              hOperationData,
    OUT LPDWORD             lpdwNumberOfEntries,
    OUT LPDWORD             lpdwAttrInformationType OPTIONAL,
    OUT LPNDS_OBJECT_INFO * lppEntries );
/*
   NwNdsGetObjectListFromBuffer()

   This function is used to retrieve an array of object entries for
   objects that were read with a prior call to either
   NwNdsListSubObjects or NwNdsSearch.

   Arguments:

       HANDLE           hOperationData - Buffer containing the read
                        response from calling NwNdsListSubObjects, or a
                        buffer containing the search results from a call
                        to NwNdsSearch.

       LPDWORD          lpdwNumberOfEntries - The address of a DWORD to
                        receive the number of array elements pointed to by
                        lppEntries.

       LPDWORD          lpdwAttrInformationType - The address of a DWORD to
                        receive a value that indicates the type of attribute
                        information returned by the call to NwNdsSearch.
                        This attribute information type determines which
                        buffer structure (LPNDS_ATTR_INFO or LPNDS_NAME_ONLY)
                        should be used for the lpAttribute field found in
                        each NDS_OBJECT_INFO structure below.

                        - or -

                        NULL to indicate that the callee is not interested,
                        especially when the object list is that from a call
                        to NwNdsListSubObjects.

       LPNDS_OBJECT_INFO *
                        lppEntries - The address of a pointer to the beginning
                        of an array of NDS_OBJECT_INFO structures. Each
                        structure contains the details of each object returned
                        from a call to NwNdsListSubObjects or NwNdsSearch.
  
    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsGetSyntaxID(
    IN  HANDLE  hTree,
    IN  LPWSTR  szAttributeName,
    OUT LPDWORD lpdwSyntaxID );
/*
   NwNdsGetObjListFromBuffer()

   This function is used to retrieve the Syntax ID of a given attribute name.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szAttributeName - The attribute name whose Syntax ID
                        is requested.

       LPDWORD          lpdwSyntaxID - The address of a DWORD to receive the
                        SyntaxID.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsListSubObjects(
    IN  HANDLE   hParentObject,
    IN  DWORD    dwEntriesRequested,
    OUT LPDWORD  lpdwEntriesReturned,
    IN  LPNDS_FILTER_LIST lpFilters OPTIONAL,
    OUT HANDLE * lphOperationData );
/*
   NwNdsListSubObjects()

   This function is used to enumerate the subordinate objects for a particular
   parent object. A filter can be passed in to restrict enumeration to a
   a specific class type or list of class types.

   Arguments:

       HANDLE           hParentObject - A handle to the object in the directory
                        tree whose subordinate objects (if any) will be
                        enumerated.

       DWORD            dwEntriesRequested - The number of subordinate objects
                        to list. A subsequent call to NwNdsListSubObjects will
                        continue enumeration following the last item returned.

       LPDWORD          lpdwEntriesReturned - A pointer to a DWORD that will 
                        contain the actual number of subobjects enumerated in 
                        the call.

       LPNDS_FILTER_LIST lpFilters - The caller can specify the object class
                         names for the kinds of objects that they would like
                         to enumerate. For example if just User and Group
                         object classes should be enumerated, then a filter
                         for class names NDS_CLASS_USER and NDS_CLASS_GROUP
                         should be pass in.

                                - or -

                         NULL to indicate that all objects should be returned
                         (no filter).

       HANDLE *         lphOperationData - Address of a HANDLE handle to
                        receive created buffer that contains the list of
                        subordinate objects read from the object
                        hParentObject. This handle is manipulated by the
                        following functions:
                           NwNdsGetObjListFromBuffer and NwNdsFreeBuffer.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsModifyObject(
    IN  HANDLE hObject,
    IN  HANDLE hOperationData );
/*
   NwNdsModifyObject()

   This function is used to modify a leaf object in an NDS directory tree.
   Modifying a leaf object means: changing, adding, removing, and clearing of
   specified attributes for a given object.

   Arguments:

       HANDLE           hObject - A handle to the object in the directory
                        tree to be manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       HANDLE           hOperationData - A handle to data containing a
                        list of attribute changes to be applied to the object.
                        This buffer is manipulated by the following functions:
                           NwNdsCreateBuffer (NDS_OBJECT_MODIFY),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsMoveObject(
    IN  HANDLE hObject,
    IN  LPWSTR szDestObjectParentDN );
/*
   NwNdsMoveObject()

   This function is used to move a leaf object in an NDS directory tree
   from one container to another.

   Arguments:

       HANDLE           hObject - A handle to the object in the directory
                        tree to be moved. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szDestObjectParentDN - The DN of the object's new
                        parent.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsOpenObject(
    IN  LPWSTR   szObjectDN,
    IN  LPWSTR   szUserName OPTIONAL,
    IN  LPWSTR   szPassword OPTIONAL,
    OUT HANDLE * lphObject,
    OUT LPWSTR   szObjectName OPTIONAL,
    OUT LPWSTR   szObjectFullName OPTIONAL,
    OUT LPWSTR   szObjectClassName OPTIONAL,
    OUT LPDWORD  lpdwModificationTime OPTIONAL,
    OUT LPDWORD  lpdwSubordinateCount OPTIONAL );
/*
   NwNdsOpenObject()

   Arguments:

       LPWSTR           szObjectDN - The distinguished name of the object
                        that we want resolved into an object handle.

       LPWSTR           szUserName - The name of the user account to create
                        connection to object with.
                            - OR -
                        NULL to use the base credentials of the callee's LUID.

       LPWSTR           szPassword - The password of the user account to create
                        connection to object with. If password is blank, callee
                        should pass "".
                            - OR -
                        NULL to use the base credentials of the callee's LUID.

       HANDLE *         lphObject - The address of a HANDLE to receive
                        the handle of the object specified by
                        szObjectDN.

       Optional arguments: ( Callee can pass NULL in for these parameters to
                             indicate ignore )

       LPWSTR           szObjectName - A LPWSTR buffer to receive
                        the object's relative NDS name, or NULL if not
                        interested. The buffer for this string must be
                        provided by the user. Buffer should be at least
                        NDS_MAX_NAME_SIZE

       LPWSTR           szObjectFullName - A LPWSTR buffer to receive
                        the object's full NDS name (DN). The buffer for this
                        string must be provided by the user. Buffer should
                        be at least: (NW_MAX_NDS_NAME_LEN + 1 ) * sizeof(WCHAR)

       LPWSTR           szObjectClassName - A LPWSTR buffer to receive
                        the class name of the object opened. The buffer for this
                        string must be provided by the user. Buffer should
                        be at least: (NW_MAX_NDS_NAME_LEN + 1 ) * sizeof(WCHAR)

       LPDWORD          lpdwModificationTime -  The address of a DWORD to
                        receive the last date/time the object was modified.

       LPDWORD          lpdwSubordinateCount -  The address of a DWORD to
                        receive the number of subordinate objects that may
                        be found under szObjectDN, if it is a container object.

                        If szObjectDN is not a container, then the value is set
                        to zero. Although a value of zero does not imply
                        that object is not a container, it could just be empty.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsPutInBuffer(
    IN     LPWSTR szAttributeName,
    IN     DWORD  dwSyntaxID,
    IN     LPVOID lpAttributeValues,
    IN     DWORD  dwValueCount,
    IN     DWORD  dwAttrModificationOperation,
    IN OUT HANDLE hOperationData );
/*
   NwNdsPutInBuffer()

   This function is used to add an entry to the buffer used to describe
   an object attribute or change to an object attribute. The buffer must
   be created using NwNdsCreateBuffer. If the buffer was created using the
   operations, NDS_OBJECT_ADD, NDS_SCHEMA_DEFINE_CLASS,
   NDS_SCHEMA_READ_ATTR_DEF, or NDS_SCHEMA_READ_CLASS_DEF, then
   dwAttrModificationOperation is ignored. If the buffer was created using
   either the operation NDS_OBJECT_READ or NDS_SEARCH, then
   dwAttrModificationOperation, puAttributeType, and lpAttributeValue are
   all ingnored.

   Arguments:
  
       LPWSTR           szAttributeName - A NULL terminated WCHAR string
                        that contains name of the attribute value to be
                        added to the buffer. It can be a user supplied
                        string, or one of the  many defined string macros
                        in NdsAttr.h.

       DWORD            dwSyntaxID - The ID of the syntax structure used to
                        represent the attribute value. Syntax IDs and their
                        associated structures are defined in the file
                        NdsSntx.h. According to the NetWare NDS schema spec,
                        there is and always will be, only 28 (0..27)
                        different syntaxes.

       LPVOID           lpAttributeValues - A pointer to the beginning of a
                        buffer containing the value(s) for a particular
                        object attribute with data syntax dwSyntaxID.

       DWORD            dwValueCount - The number of value entries found in
                        buffer pointed to by lpAttributeValues.

       DWORD            dwAttrModificationOperation - If the buffer was created
                        using the operation NDS_MODIFY_OBJECT, then this is
                        used to desribe which type of modification operation
                        to apply for a given attribute. These attribute 
                        modification operations are defined near the beginning
                        of this file.

       HANDLE           hOperationData - A handle to data created by
                        calling NwNdsCreateBuffer. The buffer stores the
                        attributes used to define transactions for
                        NwNdsAddObject, NwNdsModifyObject, NwNdsReadAttrDef,
                        NwNdsReadClassDef, NwNdsReadObject or NwNdsSearch.

    Returns:

       NO_ERROR
       ERROR_NOT_ENOUGH_MEMORY
       ERROR_INVALID_PARAMETER
*/
 

DWORD
NwNdsReadAttrDef(
    IN     HANDLE   hTree,
    IN     DWORD    dwInformationType, // NDS_INFO_NAMES
                                       // or NDS_INFO_NAMES_DEFS
    IN OUT HANDLE * lphOperationData OPTIONAL );
/*
   NwNdsReadAttrDef()

   This function is used to read attribute definitions in the schema of an
   NDS directory tree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       DWORD            dwInformationType - Indicates whether user chooses to
                        read only the defined attribute name(s) in the schema or
                        read both the attribute name(s) and definition(s)
                        from the schema.

       HANDLE *         lphOperationData - The address of a HANDLE to data
                        containing a list of attribute names to be read from
                        the schema. This handle is manipulated by the following
                        functions:
                           NwNdsCreateBuffer (NDS_SCHEMA_READ_ATTR_DEF),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                            - OR -

                        The address of a HANDLE set to NULL, which indicates
                        that all attributes should be read from the schema.

                        If these calls are successful, this handle will also
                        contain the read results from the call. In the later
                        case, a buffer will be created to contain the read
                        results. Attribute values can be retrieved from the
                        buffer with the functions:
                            NwNdsGetAttrDefListFromBuffer
                           
                        After the call to this function, this buffer is ONLY
                        manipulated by the functions: 
                        NwNdsGetAttrDefListFromBuffer and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsReadClassDef(
    IN     HANDLE   hTree,
    IN     DWORD    dwInformationType, // NDS_INFO_NAMES,
                                       // NDS_INFO_NAMES_DEFS,
                                       // NDS_CLASS_INFO_EXPANDED_DEFS,
                                       // or NDS_CLASS_INFO
    IN OUT HANDLE * lphOperationData OPTIONAL );
/*
   NwNdsReadClassDef()

   This function is used to read class definitions in the schema of an
   NDS directory tree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       DWORD            dwInformationType - Indicates whether user chooses to
                        read only the defined class name(s) in the schema or
                        read both the class name(s) and definition(s) 
                        from the schema.

       HANDLE *         lphOperationData - The address of a HANDLE to data
                        containing a list of class names to be read from
                        the schema. This handle is manipulated by the following
                        functions:
                           NwNdsCreateBuffer (NDS_SCHEMA_READ_CLASS_DEF),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                            - OR -

                        The address of a HANDLE set to NULL, which indicates
                        that all classes should be read from the schema.

                        If these calls are successful, this handle will also
                        contain the read results from the call. In the later
                        case, a buffer will be created to contain the read
                        results. Class read results can be retrieved from the
                        buffer with the functions:
                            NwNdsGetClassDefListFromBuffer
                           
                        After the call to this function, this buffer is ONLY
                        manipulated by the functions: 
                        NwNdsGetClassDefListFromBuffer and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsReadObject(
    IN     HANDLE   hObject,
    IN     DWORD    dwInformationType, // NDS_INFO_NAMES
                                       // or NDS_INFO_ATTR_NAMES_VALUES
    IN OUT HANDLE * lphOperationData );
/*
   NwNdsReadObject()

   This function is used to read attributes about an object of an NDS
   directory tree.

   Arguments:

       HANDLE           hObject - A handle to the object in the directory
                        tree to be manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       DWORD            dwInformationType - Indicates whether user chooses to
                        read only the attribute name(s) on the object or
                        read both the attribute name(s) and value(s)
                        from the object.

       HANDLE *         lphOperationData - The address of a HANDLE to data
                        containing a list of attributes to be read from the
                        object hObject. This handle is manipulated by the
                        following functions:
                           NwNdsCreateBuffer (NDS_OBJECT_READ),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                            - OR -

                        The address of a HANDLE set to NULL, which indicates
                        that all object attributes should be read from object
                        hObject.

                        If these calls are successful, this handle will also
                        contain the read results from the call. In the later
                        case, a buffer will be created to contain the read
                        results. Attribute values can be retrieved from the
                        buffer with the functions:
                           NwNdsGetAttrListFromBuffer.

                        After the call to this function, this buffer is ONLY
                        manipulated by the functions: 
                           NwNdsGetAttrListFromBuffer and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsRemoveObject(
    IN  HANDLE hParentObject,
    IN  LPWSTR szObjectName );
/*
   NwNdsRemoveObject()

   This function is used to remove a leaf object from an NDS directory tree.

   Arguments:

       HANDLE           hParentObject - A handle to the parent object container
                        in the directory tree to remove leaf object from.
                        Handle is obtained by calling NwNdsOpenObject.

       LPWSTR           szObjectName - The directory name of the leaf object
                        to be removed.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsRenameObject(
    IN  HANDLE hParentObject,
    IN  LPWSTR szObjectName,
    IN  LPWSTR szNewObjectName,
    IN  BOOL   fDeleteOldName );
/*
   NwNdsRenameObject()

   This function is used to rename an object in a NDS directory tree.

   Arguments:

       HANDLE           hParentObject - A handle to the parent object container
                        in the directory tree to rename leaf object in.
                        Handle is obtained by calling NwNdsOpenObject.

       LPWSTR           szObjectName - The directory name of the object to be
                        renamed.

       LPWSTR           szNewObjectName - The new directory name of the object.

       BOOL             fDeleteOldName - If true, the old name is discarded;
                        Otherwise, the old name is retained as an additional
                        attribute.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsSearch(
    IN     HANDLE       hStartFromObject,
    IN     DWORD        dwInformationType, // NDS_INFO_NAMES
                                           // or NDS_INFO_ATTR_NAMES_VALUES
    IN     DWORD        dwScope,
    IN     BOOL         fDerefAliases,
    IN     LPQUERY_TREE lpQueryTree,
    IN OUT LPDWORD      lpdwIterHandle,
    IN OUT HANDLE *     lphOperationData );
/*
   NwNdsSearch()

   This function is used to query an NDS directory tree to find objects of
   a certain object type that match a specified search filter.

   Arguments:

       HANDLE           hStartFromObject - A HANDLE to an object in the
                        directory tree to start search from. Handle is
                        obtained by calling NwNdsOpenObject.

       DWORD            dwScope -
                        NDS_SCOPE_ONE_LEVEL - Search subordinates from given
                                              object, one level only
                        NDS_SCOPE_SUB_TREE - Search from given object on down
                        NDS_SCOPE_BASE_LEVEL - Applies search to an object

       BOOL             fDerefAliases - If TRUE the search will dereference
                        aliased objects to the real objects and continue
                        to search in the aliased objects subtree. If FALSE
                        the search will not dereference aliases.

       LPQUERY_TREE     lpQueryTree - A pointer to the root of a search
                        tree which defines a query. This tree is manipulated
                        by the following functions:
                           NwNdsCreateQueryNode, NwNdsDeleteQueryNode,
                           and NwNdsDeleteQueryTree.

       LPDWORD          lpdwIterHandle - A pointer to a DWORD that has the
                        iteration handle value. On input, the handle value
                        is set to NDS_INITIAL_SEARCH or to a value previously
                        returned from a prior call to NwNdsSearch. On ouput,
                        the handle value is set to NDS_NO_MORE_ITERATIONS if
                        search is complete, or to some other value otherwise.

       HANDLE *         lphOperationData - The address of a HANDLE to data
                        containing a list of attributes to be read from the
                        objects that meet the search query. This handle is
                        manipulated by the following functions:
                           NwNdsCreateBuffer (NDS_SEARCH),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                            - OR -

                        The address of a HANDLE set to NULL, which indicates
                        that all object attributes should be read from the
                        search objects found.

                        If these calls are successful, this handle will also
                        contain the read results from the call. In the later
                        case, a buffer will be created to contain the read
                        results. Object information with attribute information
                        can be retrieved from the buffer with the function:
                           NwNdsGetObjectListFromBuffer.

                        After the call to this function, this buffer is ONLY
                        manipulated by the functions:
                          NwNdsGetObjectListFromBuffer,
                          and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/

#ifndef NWCONN_HANDLE
#define NWCONN_HANDLE        HANDLE
#endif

NWCONN_HANDLE
NwNdsObjectHandleToConnHandle(
	IN HANDLE ObjectHandle);

/*
   NwNdsObjectHandleToConnHandle()

   This function is used to get the NWCONN_HANDLE for a ObjectHandle 
   (like that returned from NwNdsOpenObject).

   Arguments:

       HANDLE           ObjectHandle - the handle to use to retrieve the NWCONN_HANDLE.

    Returns:

       NULL			- Call GetLastError for Win32 error code.
	   Otherwise	- NWCONN_HANDLE - this MUST be freed by the caller by the 
						NwNdsConnHandleFree routine.
*/

VOID
NwNdsConnHandleFree(
	IN NWCONN_HANDLE hConn);

/*
   NwNdsConnHandleFree()

	Frees the NWCONN_HANDLE returned from NwNdsObjectHandleToConnHandle().

   Arguments:

       IN NWCONN_HANDLE		Handle to free.

    Returns:
	   Nothing
*/

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\nlrepl.h ===
/*++
Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    nlrepl.h

Abstract:

    Prototypes of the database replication functions called either from
    LSA OR SAM.

Author:

    Madan Appiah

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    14-Apr-1992 (madana)
        Created.

--*/

#ifndef _NLREPL_H_
#define _NLREPL_H_

//
// Don't require the DS to include every .h in the world
//

#include <lmcons.h>
#include <dsgetdc.h>

#ifndef _AVOID_REPL_API
NTSTATUS
I_NetNotifyDelta (
    IN SECURITY_DB_TYPE DbType,
    IN LARGE_INTEGER ModificationCount,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PSID ObjectSid,
    IN PUNICODE_STRING ObjectName,
    IN DWORD ReplicationImmediately,
    IN PSAM_DELTA_DATA DeltaData
    );

NTSTATUS
I_NetNotifyRole(
    IN POLICY_LSA_SERVER_ROLE Role
    );

NTSTATUS
I_NetNotifyMachineAccount (
    IN ULONG ObjectRid,
    IN PSID DomainSid,
    IN ULONG OldUserAccountControl,
    IN ULONG NewUserAccountControl,
    IN PUNICODE_STRING ObjectName
    );

NTSTATUS
I_NetNotifyTrustedDomain (
    IN PSID HostedDomainSid,
    IN PSID TrustedDomainSid,
    IN BOOLEAN IsDeletion
    );

typedef enum {
    //
    // Indicates that a subnet object has been added, deleted, renamed, or
    //  the site containing the subnet has changed.
    //

    NlSubnetObjectChanged,

    //
    // Indicates that a site object has been added, deleted or renamed.
    //

    NlSiteObjectChanged,

    //
    // Indicates that the site this DC is in has changed.
    //

    NlSiteChanged,

    //
    // Indicates that the org tree changed
    //

    NlOrgChanged,

    //
    // Indicate that the DC demotion is in progress
    //

    NlDcDemotionInProgress,

    //
    // Indicate that the DC demotion is completed
    //

    NlDcDemotionCompleted,

    //
    // Indicate that NDNC info has changed
    //

    NlNdncChanged,

    //
    // Indicate that DnsRootAlias has changed
    //

    NlDnsRootAliasChanged


} NL_DS_CHANGE_TYPE, *PNL_DS_CHANGE_TYPE;

NTSTATUS
I_NetNotifyDsChange(
    IN NL_DS_CHANGE_TYPE DsChangeType
    );

NTSTATUS
I_NetLogonGetSerialNumber (
    IN SECURITY_DB_TYPE DbType,
    IN PSID DomainSid,
    OUT PLARGE_INTEGER SerialNumber
    );

NTSTATUS
I_NetLogonReadChangeLog(
    IN PVOID InContext,
    IN ULONG InContextSize,
    IN ULONG ChangeBufferSize,
    OUT PVOID *ChangeBuffer,
    OUT PULONG BytesRead,
    OUT PVOID *OutContext,
    OUT PULONG OutContextSize
    );

NTSTATUS
I_NetLogonNewChangeLog(
    OUT HANDLE *ChangeLogHandle
    );

NTSTATUS
I_NetLogonAppendChangeLog(
    IN HANDLE ChangeLogHandle,
    IN PVOID ChangeBuffer,
    IN ULONG ChangeBufferSize
    );

NTSTATUS
I_NetLogonCloseChangeLog(
    IN HANDLE ChangeLogHandle,
    IN BOOLEAN Commit
    );

NTSTATUS
I_NetLogonSendToSamOnPdc(
    IN LPWSTR DomainName,
    IN LPBYTE OpaqueBuffer,
    IN ULONG OpaqueBufferSize
    );

#endif // _AVOID_REPL_API

NET_API_STATUS
I_DsGetDcCache(
    IN LPCWSTR NetbiosDomainName OPTIONAL,
    IN LPCWSTR DnsDomainName OPTIONAL,
    OUT PBOOLEAN InNt4Domain,
    OUT LPDWORD InNt4DomainTime
    );

NET_API_STATUS
DsrGetDcName(
        IN LPWSTR ComputerName OPTIONAL,
        IN LPWSTR DomainName OPTIONAL,
        IN GUID *DomainGuid OPTIONAL,
        IN GUID *SiteGuid OPTIONAL,
        IN ULONG Flags,
        OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
        );

NET_API_STATUS
DsrGetDcNameEx2(
        IN LPWSTR ComputerName OPTIONAL,
        IN LPWSTR AccountName OPTIONAL,
        IN ULONG AllowableAccountControlBits,
        IN LPWSTR DomainName OPTIONAL,
        IN GUID *DomainGuid OPTIONAL,
        IN LPWSTR SiteName OPTIONAL,
        IN ULONG Flags,
        OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
        );

NTSTATUS
I_NetLogonSetServiceBits(
    IN DWORD ServiceBitsOfInterest,
    IN DWORD ServiceBits
    );

NTSTATUS
I_NetLogonLdapLookup(
    IN PVOID Filter,
    OUT PVOID *Response,
    OUT PULONG ResponseSize
    );

NTSTATUS
I_NetLogonLdapLookupEx(
    IN PVOID Filter,
    IN PVOID SockAddr,
    OUT PVOID *Response,
    OUT PULONG ResponseSize
    );

NET_API_STATUS
I_NetLogonGetIpAddresses(
    OUT PULONG IpAddressCount,
    OUT LPBYTE *IpAddresses
    );

NTSTATUS
I_NetLogonGetDirectDomain(
    IN LPWSTR HostedDomainName,
    IN LPWSTR TrustedDomainName,
    OUT LPWSTR *DirectDomainName
    );

//
// OS verion number from I_NetLogonGetAuthDataEx
//

typedef enum _NL_OS_VERSION {
    NlNt35_or_older = 1,
    NlNt351,
    NlNt40,
    NlWin2000,  // NT 5.0
    NlWhistler  // NT 5.1
} NL_OS_VERSION, *PNL_OS_VERSION;
//
// Flags to I_NetLogonGetAuthDataEx
//
#define NL_DIRECT_TRUST_REQUIRED    0x01
#define NL_RETURN_CLOSEST_HOP       0x02
#define NL_ROLE_PRIMARY_OK          0x04
#define NL_REQUIRE_DOMAIN_IN_FOREST 0x08

NTSTATUS
I_NetLogonGetAuthDataEx(
    IN LPWSTR HostedDomainName,
    IN LPWSTR TrustedDomainName,
    IN BOOLEAN ResetChannel,
    IN ULONG Flags,
    OUT LPWSTR *ServerName,
    OUT PNL_OS_VERSION ServerOsVersion,
    OUT LPWSTR *ServerPrincipleName,
    OUT PVOID *ClientContext OPTIONAL,
    OUT PULONG AuthnLevel
    );

NTSTATUS
I_NetNotifyNtdsDsaDeletion (
    IN LPWSTR DnsDomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN GUID *DsaGuid,
    IN LPWSTR DnsHostName
    );

VOID
I_NetLogonFree(
    IN PVOID Buffer
    );

NTSTATUS
I_NetLogonMixedDomain(
    OUT PBOOL MixedMode
    );

#ifdef _WINSOCK2API_

NET_API_STATUS
I_NetLogonAddressToSiteName(
    IN PSOCKET_ADDRESS SocketAddress,
    OUT LPWSTR *SiteName
    );

#endif

#endif // _NLREPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\ndsattr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NdsAttr.h

Abstract:

    This module defines NDS Class names and NDS Attributes supported by
    the NDS object manipulation API found in Nds32.h.

Author:

    Glenn Curtis    [GlennC]    15-Dec-1995

--*/

#ifndef __NDSATTR_H
#define __NDSATTR_H


/**************************************************/
/* Supported NetWare Directory Service Attributes */
/**************************************************/

/*
  Account Balance:
    Single valued, nonremovable, sync immediate (4.1)
    (Counter)
*/
#define ACCOUNT_BALANCE_name        L"Account Balance"
#define ACCOUNT_BALANCE_syntax      NDS_SYNTAX_ID_22
#define NDS_ACCOUNT_BALANCE         ACCOUNT_BALANCE_name,ACCOUNT_BALANCE_syntax

/*
  ACL:
    Multivalued, nonremovable, Sync Immediate (4.1)
    (Object ACL)
*/
#define ACL_name                    L"ACL"
#define ACL_syntax                  NDS_SYNTAX_ID_17
#define NDS_ACL                     ACL_name,ACL_syntax

/*
  Aliased Object Name:
    Single valued, nonremovable, sync immediate (4.1)
    (Distinguished Name)
*/
#define ALIASED_OBJECT_NAME_name    L"Aliased Object Name"
#define ALIASED_OBJECT_NAME_syntax  NDS_SYNTAX_ID_1
#define NDS_ALIASED_OBJECT_NAME     ALIASED_OBJECT_NAME_name,ALIASED_OBJECT_NAME_syntax

/*
  Allow Unlimited Credit:
    Single valued, nonremovable, sync immediate (4.1)
    (Boolean)
*/
#define ALLOW_UNLIMITED_CREDIT_name     L"Allow Unlimited Credit"
#define ALLOW_UNLIMITED_CREDIT_syntax   NDS_SYNTAX_ID_7
#define NDS_ALLOW_UNLIMITED_CREDIT  ALLOW_UNLIMITED_CREDIT_name,ALLOW_UNLIMITED_CREDIT_syntax

/*
  Authority Revocation:
    Single valued, nonremovable, read only, sync immediate (4.1)
    (Octet String)
*/
#define AUTHORITY_REVOCATION_name   L"Authority Revocation"
#define AUTHORITY_REVOCATION_syntax NDS_SYNTAX_ID_9
#define NDS_AUTHORITY_REVOCATION    AUTHORITY_REVOCATION_name,AUTHORITY_REVOCATION_syntax

/*
  Back Link:
    Single valued, nonremovable, read only
    (Back Link)
*/
#define BACK_LINK_name              L"Back Link"
#define BACK_LINK_syntax            NDS_SYNTAX_ID_23
#define NDS_BACK_LINK               BACK_LINK_name,BACK_LINK_syntax

/*
  Bindery Object Restriction:
    Single valued, nonremovable, read only
    (Integer)
*/
#define BINDERY_OBJECT_RESTRICTION_name     L"Bindery Object Restriction"
#define BINDERY_OBJECT_RESTRICTION_syntax   NDS_SYNTAX_ID_8
#define NDS_BINDERY_OBJECT_RESTRICTION  BINDERY_OBJECT_RESTRICTION_name,BINDERY_OBJECT_RESTRICTION_syntax

/*
  Bindery Property:
    Multivalued, nonremovable, read only
    (Octet String)
*/
#define BINDERY_PROPERTY_name       L"Bindery Property"
#define BINDERY_PROPERTY_syntax     NDS_SYNTAX_ID_9
#define NDS_BINDERY_PROPERTY        BINDERY_PROPERTY_name,BINDERY_PROPERTY_syntax

/*
  Bindery Type:
    Single valued, nonremovable, read only
    (Numeric String)
*/
#define BINDERY_TYPE_name           L"Bindery Type"
#define BINDERY_TYPE_syntax         NDS_SYNTAX_ID_5
#define NDS_BINDERY_TYPE            BINDERY_TYPE_name,BINDERY_TYPE_syntax

/*
  C (Country):
    Single valued, nonremovable, sized attr (2,2), sync immediate (4.1)
    (Case Ignore String)
*/
#define COUNTRY_NAME_name           L"C"
#define COUNTRY_NAME_syntax         NDS_SYNTAX_ID_3
#define NDS_COUNTRY_NAME            COUNTRY_NAME_name,COUNTRY_NAME_syntax

/*
  CA Private Key:
    Single valued, nonremovable, sync immediate, hidden, read only
    (Octet String)
*/
#define CA_PRIVATE_KEY_name         L"CA Private Key"
#define CA_PRIVATE_KEY_syntax       NDS_SYNTAX_ID_9
#define NDS_CA_PRIVATE_KEY          CA_PRIVATE_KEY_name,CA_PRIVATE_KEY_syntax

/*
  CA Public Key:
    Single valued, nonremovable, sync immediate, public read, read only
    (Octet String)
*/
#define CA_PUBLIC_KEY_name          L"CA Public Key"
#define CA_PUBLIC_KEY_syntax        NDS_SYNTAX_ID_9
#define NDS_CA_PUBLIC_KEY           CA_PUBLIC_KEY_name,CA_PUBLIC_KEY_syntax

/*
  Cartridge:
    Multivalued, nonremovable, sync immediate (4.1)
    (Case Ignore String)
*/
#define CARTRIDGE_name              L"Cartridge"
#define CARTRIDGE_syntax            NDS_SYNTAX_ID_3
#define NDS_CARTRIDGE               CARTRIDGE_name,CARTRIDGE_syntax

/*
  Certificate Revocation:
    Single valued, nonremovable, sync immediate (4.1), read only
    (Octet String)
*/
#define CERTIFICATE_REVOCATION_name     L"Certificate Revocation"
#define CERTIFICATE_REVOCATION_syntax   NDS_SYNTAX_ID_9
#define NDS_CERTIFICATE_REVOCATION  CERTIFICATE_REVOCATION_name,CERTIFICATE_REVOCATION_syntax

/*
  CN (Common Name):
    Multivalued, nonremovable, sized attr (1..64), sync immediate (4.1)
    (Case Ignore String)
*/
#define COMMON_NAME_name            L"CN"
#define COMMON_NAME_syntax          NDS_SYNTAX_ID_3
#define NDS_COMMON_NAME             COMMON_NAME_name,COMMON_NAME_syntax

/*
  Convergence:
    Single valued, nonremovable, sized attr (0,1), sync immediate (4.1)
    (Integer)
*/
#define CONVERGENCE_name            L"Convergence"
#define CONVERGENCE_syntax          NDS_SYNTAX_ID_8
#define NDS_CONVERGENCE             CONVERGENCE_name,CONVERGENCE_syntax

/*
  Cross Certificate Pair:
    Multivalued, nonremovable, sync immediate (4.1)
    (Octet String)
*/
#define CROSS_CERTIFICATE_PAIR_name     L"Cross Certificate Pair"
#define CROSS_CERTIFICATE_PAIR_syntax   NDS_SYNTAX_ID_9
#define NDS_CROSS_CERTIFICATE_PAIR  CROSS_CERTIFICATE_PAIR_name,CROSS_CERTIFICATE_PAIR_syntax

/*
  Default Queue:
    Single valued, nonremovable, server read, sync immediate (4.1)
    (Distinguished Name)
*/
#define DEFAULT_QUEUE_name          L"Default Queue"
#define DEFAULT_QUEUE_syntax        NDS_SYNTAX_ID_1
#define NDS_DEFAULT_QUEUE           DEFAULT_QUEUE_name,DEFAULT_QUEUE_syntax

/*
  Description:
    Multivalued, nonremovable, sized attr (1..1024), sync immediate (4.1)
    (Case Ignore String)
*/
#define DESCRIPTION_name            L"Description"
#define DESCRIPTION_syntax          NDS_SYNTAX_ID_3
#define NDS_DESCRIPTION             DESCRIPTION_name,DESCRIPTION_syntax

/*
  Detect Intruder:
    Single valued, nonremovable, sync immediate (4.1)
    (Boolean)
*/
#define DETECT_INTRUDER_name        L"Detect Intruder"
#define DETECT_INTRUDER_syntax      NDS_SYNTAX_ID_
#define NDS_DETECT_INTRUDER         DETECT_INTRUDER_name,DETECT_INTRUDER_syntax

/*
  Device:
    Multivalued, nonremovable, sync immediate (4.1)
    (Distinguished Name)
*/
#define DEVICE_name                 L"Device"
#define DEVICE_syntax               NDS_SYNTAX_ID_1
#define NDS_DEVICE                  DEVICE_name,DEVICE_syntax

/*
  EMail Address:
    Multivalued, nonremovable, public read, sync immediate (4.1)
    (EMail Address)
*/
#define EMAIL_ADDRESS_name          L"EMail Address"
#define EMAIL_ADDRESS_syntax        NDS_SYNTAX_ID_14
#define NDS_EMAIL_ADDRESS           EMAIL_ADDRESS_name,EMAIL_ADDRESS_syntax

/*
  Equivalent To Me:
    Multivalued, nonremovable, server read, sync immediate
    (Distinguished Name)
*/
#define EQUIVALENT_TO_ME_name       L"Equivelent To Me"
#define EQUIVALENT_TO_ME_syntax     NDS_SYNTAX_ID_1
#define NDS_EQUIVALENT_TO_ME        EQUIVALENT_TO_ME_name,EQUIVALENT_TO_ME_syntax

/*
  Facsimile Telephone Number:
    Multivalued, nonremovable, sync immediate (4.1)
    (Facsimile Telephone Number)
*/
#define FAX_NUMBER_name             L"Facsimile Telephone Number"
#define FAX_NUMBER_syntax           NDS_SYNTAX_ID_11
#define NDS_FAX_NUMBER              FAX_NUMBER_name,FAX_NUMBER_syntax

/*
  Full Name:
    Multivalued, nonremovable, sized attr (0..127), sync immediate (4.1)
    (Case Ignore String)
*/
#define FULL_NAME_name              L"Full Name"
#define FULL_NAME_syntax            NDS_SYNTAX_ID_3
#define NDS_FULL_NAME               FULL_NAME_name,FULL_NAME_syntax

/*
  Generational Qualifier:
    Single valued, nonremovable, public read, sized attr (1..8), sync immediate
    (Case Ignore String)
*/
#define GENERATIONAL_QUALIFIER_name     L"Generational Qualifier"
#define GENERATIONAL_QUALIFIER_syntax   NDS_SYNTAX_ID_3
#define NDS_GENERATIONAL_QUALIFIER  GENERATIONAL_QUALIFIER_name,GENERATIONAL_QUALIFIER_syntax

/*
  GID (Group ID):
    Single valued, nonremovable, sync immediate (4.1)
    (Integer)
*/
#define GROUP_ID_name                   L"GID"
#define GROUP_ID_syntax                 NDS_SYNTAX_ID_8
#define GROUP_ID                        GROUP_ID_name,GROUP_ID_syntax

/*
  Given Name:
    Single valued, nonremovable, public read (4.1), sized attr (1..32),
    sync immediate
    (Case Ignore String)
*/
#define GIVEN_NAME_name             L"Given Name"
#define GIVEN_NAME_syntax           NDS_SYNTAX_ID_3
#define NDS_GIVEN_NAME              GIVEN_NAME_name,GIVEN_NAME_syntax

/*
  Group Membership:
    Multivalued, nonremovable, sync immediate, write managed
    (Distinguished Name)
*/
#define GROUP_MEMBERSHIP_name       L"Group Membership"
#define GROUP_MEMBERSHIP_syntax     NDS_SYNTAX_ID_1
#define NDS_GROUP_MEMBERSHIP        GROUP_MEMBERSHIP_name,GROUP_MEMBERSHIP_syntax

/*
  High Convergence Sync Interval:
    Single valued, nonremovable, sync immediate (4.1)
    (Interval)
*/
#define HIGH_CON_SYNC_INTERVAL_name     L"High Convergence Sync Interval"
#define HIGH_CON_SYNC_INTERVAL_syntax   NDS_SYNTAX_ID_27
#define NDS_HIGH_CON_SYNC_INTERVAL  HIGH_CON_SYNC_INTERVAL_name,HIGH_CON_SYNC_INTERVAL_syntax

/*
  Higher Privileges:
    Multivalued, nonremovable, sync immediate, write managed
    (Distinguished Name)
*/
#define HIGHER_PRIVILEGES_name      L"Higher Privileges"
#define HIGHER_PRIVILEGES_syntax    NDS_SYNTAX_ID_1
#define NDS_HIGHER_PRIVILEGES       HIGHER_PRIVILEGES_name,HIGHER_PRIVILEGES_syntax

/*
  Home Directory:
    Single valued, nonremovable, sized attr (1..255), sync immediate (4.1)
    (Path)
*/
#define HOME_DIRECTORY_name         L"Home Directory"
#define HOME_DIRECTORY_syntax       NDS_SYNTAX_ID_15
#define NDS_HOME_DIRECTORY          HOME_DIRECTORY_name,HOME_DIRECTORY_syntax

/*
  Host Device:
    Single valued, nonremovable, sync immediate (4.1)
    (Distinguished Name)
*/
#define HOST_DEVICE_name            L"Host Device"
#define HOST_DEVICE_syntax          NDS_SYNTAX_ID_1
#define NDS_HOST_DEVICE             HOST_DEVICE_name,HOST_DEVICE_syntax

/*
  Host Resource Name:
    Single valued, nonremovable, sync immediate (4.1)
    (Case Ignore String)
*/
#define HOST_RESOURCE_NAME_name     L"Host Resource Name"
#define HOST_RESOURCE_NAME_syntax   NDS_SYNTAX_ID_3
#define NDS_HOST_RESOURCE_NAME      HOST_RESOURCE_NAME_name,HOST_RESOURCE_NAME_syntax

/*
  Host Server:
    Single valued, nonremovable, sync immediate (4.1)
    (Distinguished Name)
*/
#define HOST_SERVER_name            L"Host Server"
#define HOST_SERVER_syntax          NDS_SYNTAX_ID_1
#define NDS_HOST_SERVER             HOST_SERVER_name,HOST_SERVER_syntax

/*
  Inherited ACL:
    Multivalued, nonremovable, read only, sync immediate (4.1)
    (Object ACL)
*/
#define INHERITED_ACL_name          L"Inherited ACL"
#define INHERITED_ACL_syntax        NDS_SYNTAX_ID_17
#define NDS_INHERITED_ACL           INHERITED_ACL_name,INHERITED_ACL_syntax

/*
  Initials:
    Single valued, nonremovable, public read, sized attr (1..8), sync immediate
    (Case Ignore String)
*/
#define INITIALS_name               L"Initials"
#define INITIALS_syntax             NDS_SYNTAX_ID_3
#define NDS_INITIALS                INITIALS_name,INITIALS_syntax

/*
  Intruder Attempt Reset Interval:
    Single valued, nonremovable, sync immediate (4.1)
    (Interval)
*/
#define INTRUDER_ATTEMPT_RESET_INTERVAL_name L"Intruder Attempt Reset Interval"
#define INTRUDER_ATTEMPT_RESET_INTERVAL_syntax NDS_SYNTAX_ID_27
#define NDS_INTRUDER_ATTEMPT_RESET_INTERVAL INTRUDER_ATTEMPT_RESET_INTERVAL_name,INTRUDER_ATTEMPT_RESET_INTERVAL_syntax

/*
  Intruder Lockout Reset Interval:
    Single valued, nonremovable, sync immediate (4.1)
    (Interval)
*/
#define INTRUDER_LOCKOUT_RESET_INTERVAL_name L"Intruder Lockout Reset Interval"
#define INTRUDER_LOCKOUT_RESET_INTERVAL_syntax NDS_SYNTAX_ID_27
#define NDS_INTRUDER_LOCKOUT_RESET_INTERVAL INTRUDER_LOCKOUT_RESET_INTERVAL_name,INTRUDER_LOCKOUT_RESET_INTERVAL_syntax

/*
  L (Locality):
    Multi valued, nonremovable, sync immediate (4.1)
    (Case Ignore String)
*/
#define LOCALITY_NAME_name          L"L"
#define LOCALITY_NAME_syntax        NDS_SYNTAX_ID_3
#define NDS_LOCALITY_NAME           LOCALITY_NAME_name,LOCALITY_NAME_syntax

/*
  Language:
    Single valued, nonremovable, sync immediate (4.1)
    (Case Ignore List)
*/
#define LANGUAGE_name               L"Language"
#define LANGUAGE_syntax             NDS_SYNTAX_ID_6
#define NDS_LANGUAGE                LANGUAGE_name,LANGUAGE_syntax

/*
  Login Allowed Time Map:
    A 42 byte buffer (6 Time Intervals X 7 Days)
    1 Time Interval = 1 Byte = 4 Hours
    First Byte = Saturday, 4:00 PM
    If Byte = 0xFF, then access is allowed (4 hrs).
    If Byte = 0x00, then access is not allowed (4 hrs).
    Each bit represents a 1/2 hour time interval.
    Single valued, nonremovable, sized attr (42,42), sync immediate (4.1)
    (Octet String)
*/
#define LOGIN_ALLOWED_TIME_MAP_name     L"Login Allowed Time Map"
#define LOGIN_ALLOWED_TIME_MAP_syntax   NDS_SYNTAX_ID_9
#define NDS_LOGIN_ALLOWED_TIME_MAP  LOGIN_ALLOWED_TIME_MAP_name,LOGIN_ALLOWED_TIME_MAP_syntax

/*
  Login Disabled:
    Single valued, nonremovable, sync immediate (4.1)
    (Boolean)
*/
#define LOGIN_DISABLED_name         L"Login Disabled"
#define LOGIN_DISABLED_syntax       NDS_SYNTAX_ID_7
#define NDS_LOGIN_DISABLED          LOGIN_DISABLED_name,LOGIN_DISABLED_syntax

/*
  Login Expiration Time:
    Single valued, nonremovable, sync immediate (4.1)
    (Time)
*/
#define LOGIN_EXPIRATION_TIME_name      L"Login Expiration Time"
#define LOGIN_EXPIRATION_TIME_syntax    NDS_SYNTAX_ID_24
#define NDS_LOGIN_EXPIRATION_TIME   LOGIN_EXPIRATION_TIME_name,LOGIN_EXPIRATION_TIME_syntax

/*
  Login Grace Limit:
    Single valued, nonremovable, sync immediate (4.1)
    (Integer)
*/
#define LOGIN_GRACE_LIMIT_name      L"Login Grace Limit"
#define LOGIN_GRACE_LIMIT_syntax    NDS_SYNTAX_ID_8
#define NDS_LOGIN_GRACE_LIMIT       LOGIN_GRACE_LIMIT_name,LOGIN_GRACE_LIMIT_syntax

/*
  Login Grace Remaining:
    Single valued, nonremovable, sync immediate (4.1)
    (Counter)
*/
#define LOGIN_GRACE_REMAINING_name      L"Login Grace Remaining"
#define LOGIN_GRACE_REMAINING_syntax    NDS_SYNTAX_ID_22
#define NDS_LOGIN_GRACE_REMAINING   LOGIN_GRACE_REMAINING_name,LOGIN_GRACE_REMAINING_syntax

/*
  Login Maximum Simultaneous:
    Single valued, nonremovable, sync immediate (4.1)
    (Integer)
*/
#define LOGIN_MAXIMUM_SIMULTANEOUS_name     L"Login Maximum Simultaneous"
#define LOGIN_MAXIMUM_SIMULTANEOUS_syntax   NDS_SYNTAX_ID_8
#define NDS_LOGIN_MAXIMUM_SIMULTANEOUS  LOGIN_MAXIMUM_SIMULTANEOUS_name,LOGIN_MAXIMUM_SIMULTANEOUS_syntax

/*
  Mailbox Id:
    Single valued, nonremovable, public read, sized attr (1..8), sync immediate
    (Case Ignore String)
*/
#define MAILBOX_ID_name             L"Mailbox ID"
#define MAILBOX_ID_syntax           NDS_SYNTAX_ID_3
#define NDS_MAILBOX_ID              MAILBOX_ID_name,MAILBOX_ID_syntax

/*
  Member:
    Multivalued, nonremovable, sync immediate (4.1)
    (Distinguished Name)
*/
#define MEMBER_name                 L"Member"
#define MEMBER_syntax               NDS_SYNTAX_ID_1
#define NDS_MEMBER                  MEMBER_name,MEMBER_syntax

/*
  Messaging Server:
    Multivalued, nonremovable, sync immediate
    (Distinguished Name)
*/
#define MESSAGING_SERVER_name       L"Messaging Server"
#define MESSAGING_SERVER_syntax     NDS_SYNTAX_ID_1
#define NDS_MESSAGING_SERVER        MESSAGING_SERVER_name,MESSAGING_SERVER_syntax

/*
  Minimum Accout Balance:
    Single valued, nonremovable, sync immediate (4.1)
    (Integer)
*/
#define MINIMUM_ACCOUNT_BALANCE_name    L"Minimum Account Balance"
#define MINIMUM_ACCOUNT_BALANCE_syntax  NDS_SYNTAX_ID_8
#define NDS_MINIMUM_ACCOUNT_BALANCE MINIMUM_ACCOUNT_BALANCE_name,MINIMUM_ACCOUNT_BALANCE_syntax

/*
  O (Organization):
    Multivalued, nonremovable, sized attr (1..64), sync immediate (4.1)
    (Case Ignore String)
*/
#define ORGANIZATION_NAME_name      L"O"
#define ORGANIZATION_NAME_syntax    NDS_SYNTAX_ID_3
#define NDS_ORGANIZATION_NAME       ORGANIZATION_NAME_name,ORGANIZATION_NAME_syntax

/*
  Object Class:
    Multivalued, nonremovable, read only, sync immediate (4.1)
    (Class Name)
*/
#define OBJECT_CLASS_name           L"Object Class"
#define OBJECT_CLASS_syntax         NDS_SYNTAX_ID_20
#define NDS_OBJECT_CLASS            OBJECT_CLASS_name,OBJECT_CLASS_syntax

/*
  OU (Organizational Unit):
    Multivalued, nonremovable, sized attr (1..64), sync immediate (4.1)
    (Case Ignore String)
*/
#define ORGANIZATIONAL_UNIT_NAME_name   L"OU"
#define ORGANIZATIONAL_UNIT_NAME_syntax NDS_SYNTAX_ID_3
#define NDS_ORGANIZATIONAL_UNIT_NAME ORGANIZATIONAL_UNIT_NAME_name,ORGANIZATIONAL_UNIT_NAME_syntax

/*
  Owner:
    Multivalued, nonremovable, sync immediate (4.1)
    (Distinguished Name)
*/
#define OWNER_name                  L"Owner"
#define OWNER_syntax                NDS_SYNTAX_ID_1
#define NDS_OWNER                   OWNER_name,OWNER_syntax

/*
  Password Allow Change:
    Single valued, nonremovable, sync immediate (4.1)
    (Boolean)
*/
#define PASSWORD_ALLOW_CHANGE_name      L"Password Allow Change"
#define PASSWORD_ALLOW_CHANGE_syntax    NDS_SYNTAX_ID_7
#define NDS_PASSWORD_ALLOW_CHANGE   PASSWORD_ALLOW_CHANGE_name,PASSWORD_ALLOW_CHANGE_syntax

/*
  Password Expiration Interval:
    Single valued, nonremovable, sync immediate (4.1)
    (Interval)
*/
#define PASSWORD_EXPIRATION_INTERVAL_name   L"Password Expiration Interval"
#define PASSWORD_EXPIRATION_INTERVAL_syntax NDS_SYNTAX_ID_27
#define NDS_PASSWORD_EXPIRATION_INTERVAL    PASSWORD_EXPIRATION_INTERVAL_name,PASSWORD_EXPIRATION_INTERVAL_syntax

/*
  Password Expiration Time:
    Single valued, nonremovable, sync immediate (4.1)
    (Time)
*/
#define PASSWORD_EXPIRATION_TIME_name   L"Password Expiration Time"
#define PASSWORD_EXPIRATION_TIME_syntax NDS_SYNTAX_ID_24
#define NDS_PASSWORD_EXPIRATION_TIME     PASSWORD_EXPIRATION_TIME_name,PASSWORD_EXPIRATION_TIME_syntax

/*
  Password Minimun Length:
    Single valued, nonremovable, sync immediate (4.1)
    (Integer)
*/
#define PASSWORD_MINIMUM_LENGTH_name    L"Password Minimum Length"
#define PASSWORD_MINIMUM_LENGTH_syntax  NDS_SYNTAX_ID_8
#define NDS_PASSWORD_MINIMUM_LENGTH     PASSWORD_MINIMUM_LENGTH_name,PASSWORD_MINIMUM_LENGTH_syntax

/*
  Password Required:
    Single valued, nonremovable, sync immediate (4.1)
    (Boolean)
*/
#define PASSWORD_REQUIRED_name      L"Password Required"
#define PASSWORD_REQUIRED_syntax    NDS_SYNTAX_ID_7
#define NDS_PASSWORD_REQUIRED       PASSWORD_REQUIRED_name,PASSWORD_REQUIRED_syntax

/*
  Password Unique Required:
    Single valued, nonremovable, sync immediate (4.1)
    (Boolean)
*/
#define PASSWORD_UNIQUE_REQUIRED_name   L"Password Unique Required"
#define PASSWORD_UNIQUE_REQUIRED_syntax NDS_SYNTAX_ID_7
#define NDS_PASSWORD_UNIQUE_REQUIRED PASSWORD_UNIQUE_REQUIRED_name,PASSWORD_UNIQUE_REQUIRED_syntax

/*
  Physical Delivery Office Name:
    Multivalued, nonremovable, sized attr (1..128), sync immediate (4.1)
    (Case Ignore String)
*/
#define CITY_NAME_name                  L"Physical Delivery Office Name"
#define CITY_NAME_syntax                NDS_SYNTAX_ID_3
#define NDS_PHYSICAL_DELIVERY_OFFICE_NAME   CITY_NAME_name,CITY_NAME_syntax

/*
  Postal Address:
    Multivalued, nonremovable, sync immediate (4.1)
    (Postal Address)
*/
#define POSTAL_ADDRESS_name             L"Postal Address"
#define POSTAL_ADDRESS_syntax           NDS_SYNTAX_ID_18
#define NDS_POSTAL_ADDRESS              POSTAL_ADDRESS_name,POSTAL_ADDRESS_syntax

/*
  Postal Code:
    Multivalued, nonremovable, sized attr (0..40), sync immediate (4.1)
    (Case Ignore String)
*/
#define POSTAL_CODE_name                L"Postal Code"
#define POSTAL_CODE_syntax              NDS_SYNTAX_ID_3
#define NDS_POSTAL_CODE                 POSTAL_CODE_name,POSTAL_CODE_syntax

/*
  Postal Office Box:
    Multivalued, nonremovable, sized attr (0..40), sync immediate (4.1)
    (Case Ignore String)
*/
#define POSTAL_OFFICE_BOX_name          L"Postal Office Box"
#define POSTAL_OFFICE_BOX_syntax        NDS_SYNTAX_ID_3
#define NDS_POSTAL_OFFICE_BOX           POSTAL_OFFICE_BOX_name,POSTAL_OFFICE_BOX_syntax

/*
  Profile:
    Single valued, nonremovable, sync immediate (4.1)
    (Distinguished Name)
*/
#define PROFILE_name                    L"Profile"
#define PROFILE_syntax                  NDS_SYNTAX_ID_1
#define NDS_PROFILE                     PROFILE_name,PROFILE_syntax

/*
  S (State Or Province):
    Multivalued, nonremovable, sized attr (1..128), sync immediate (4.1)
    (Case Ignore String)
*/
#define STATE_OR_PROVINCE_NAME_name     L"S"
#define STATE_OR_PROVINCE_NAME_syntax   NDS_SYNTAX_ID_3
#define NDS_STATE_OR_PROVINCE_NAME      STATE_OR_PROVINCE_NAME_name,STATE_OR_PROVINCE_NAME_syntax

/*
  SA (Street Address):
    Multivalued, nonremovable, sized attr (1..128), sync immediate (4.1)
    (Case Ignore String)
*/
#define STREET_ADDRESS_name             L"SA"
#define STREET_ADDRESS_syntax           NDS_SYNTAX_ID_3
#define NDS_STREET_ADDRESS              STREET_ADDRESS_name,STREET_ADDRESS_syntax

/*
  Security Equals:
    Multivalued, nonremovable, server read, write managed, sync immediate
    (Distinguished Name)
*/
#define SECURITY_EQUALS_name            L"Security Equals"
#define SECURITY_EQUALS_syntax          NDS_SYNTAX_ID_1
#define NDS_SECURITY_EQUALS             SECURITY_EQUALS_name,SECURITY_EQUALS_syntax

/*
  See Also:
    Multivalued, nonremovable, sync immediate (4.1)
    (Distinguished Name)
*/
#define SEE_ALSO_name                   L"See Also"
#define SEE_ALSO_syntax                 NDS_SYNTAX_ID_1
#define NDS_SEE_ALSO                    SEE_ALSO_name,SEE_ALSO_syntax

/*
  Surname:
    Multivalued, nonremovable, sized attr (1..64), sync immediate (4.1)
    (Case Ignore String)
*/
#define SURNAME_name                    L"Surname"
#define SURNAME_syntax                  NDS_SYNTAX_ID_3
#define NDS_SURNAME                     SURNAME_name,SURNAME_syntax

/*
  Telephone Number:
    Multivalued, nonremovable, sync immediate (4.1)
    (Telephone Number)
*/
#define PHONE_NUMBER_name               L"Telephone Number"
#define PHONE_NUMBER_syntax             NDS_SYNTAX_ID_10
#define NDS_PHONE_NUMBER                PHONE_NUMBER_name,PHONE_NUMBER_syntax

/*
  Title:
    Multivalued, nonremovable, sized attr (1..64), sync immediate (4.1)
    (Case Ignore String)
*/
#define TITLE_name                      L"Title"
#define TITLE_syntax                    NDS_SYNTAX_ID_3
#define NDS_TITLE                       TITLE_name,TITLE_syntax


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\ndsclass.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NdsClass.h

Abstract:

    This module defines the NDS Class names supported by
    the NDS object manipulation API found in Nds32.h.

Author:

    Glenn Curtis    [GlennC]    15-Dec-1995

--*/

#ifndef __NDSCLASS_H
#define __NDSCLASS_H

/***********************************************/
/* Supported NetWare Directory Service Classes */
/***********************************************/

#define NDS_CLASS_AFP_SERVER         L"AFP Server"            /* Effective */
#define NDS_CLASS_ALIAS              L"Alias"                 /* Effective */
#define NDS_CLASS_BINDERY_OBJECT     L"Bindery Object"        /* Effective */
#define NDS_CLASS_BINDERY_QUEUE      L"Bindery Queue"         /* Effective */
#define NDS_CLASS_COMPUTER           L"Computer"              /* Effective */
#define NDS_CLASS_COUNTRY            L"Country"               /* Effective */
#define NDS_CLASS_DEVICE             L"Device"                /* Noneffective */
#define NDS_CLASS_DIRECTORY_MAP      L"Directory Map"         /* Effective */
#define NDS_CLASS_EXTERNAL_ENTITY    L"External Entity"       /* Effective */
#define NDS_CLASS_GROUP              L"Group"                 /* Effective */
#define NDS_CLASS_LIST               L"List"                  /* Effective */
#define NDS_CLASS_LOCALITY           L"Locality"              /* Effective */
#define NDS_CLASS_MESSAGE_ROUT_GROUP L"Message Routing Group" /* Effective */
#define NDS_CLASS_MESSAGING_SERVER   L"Messaging Server"      /* Effective */
#define NDS_CLASS_NCP_SERVER         L"NCP Server"            /* Effective */
#define NDS_CLASS_ORGANIZATION       L"Organization"          /* Effective */
#define NDS_CLASS_ORG_PERSON         L"Organizational Person" /* Noneffective */
#define NDS_CLASS_ORG_ROLE           L"Organizational Role"   /* Effective */
#define NDS_CLASS_ORG_UNIT           L"Organizational Unit"   /* Effective */
#define NDS_CLASS_PARTITION          L"Partition"             /* Noneffective */
#define NDS_CLASS_PERSON             L"Person"                /* Noneffective */
#define NDS_CLASS_PRINT_SERVER       L"Print Server"          /* Effective */
#define NDS_CLASS_PRINTER            L"Printer"               /* Effective */
#define NDS_CLASS_PROFILE            L"Profile"               /* Effective */
#define NDS_CLASS_QUEUE              L"Queue"                 /* Effective */
#define NDS_CLASS_RESOURCE           L"Resource"              /* Noneffective */
#define NDS_CLASS_SERVER             L"Server"                /* Noneffective */
#define NDS_CLASS_TOP                L"Top"                   /* Effective */
#define NDS_CLASS_UNKNOWN            L"Unknown"               /* Effective */
#define NDS_CLASS_USER               L"User"                  /* Effective */
#define NDS_CLASS_VOLUME             L"Volume"                /* Effective */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\ndssntx.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NdsSntx.h

Abstract:

    This module defines NDS Syntax IDs and Structures used in the NDS
    object API found in nds32.h.

Author:

    Glenn Curtis    [GlennC]    15-Dec-1995

--*/

#ifndef __NDSSNTX_H
#define __NDSSNTX_H


#define NDS_SYNTAX_ID_0      0 /* Unknown */
#define NDS_SYNTAX_ID_1      1 /* Distinguished Name */
#define NDS_SYNTAX_ID_2      2 /* Case Exact String */
#define NDS_SYNTAX_ID_3      3 /* Case Ignore String */
#define NDS_SYNTAX_ID_4      4 /* Printable String */
#define NDS_SYNTAX_ID_5      5 /* Numeric String */
#define NDS_SYNTAX_ID_6      6 /* Case Ignore List */
#define NDS_SYNTAX_ID_7      7 /* Boolean */
#define NDS_SYNTAX_ID_8      8 /* Integer */
#define NDS_SYNTAX_ID_9      9 /* Octet String */
#define NDS_SYNTAX_ID_10    10 /* Telephone Number */
#define NDS_SYNTAX_ID_11    11 /* Facsimile Telephone Number */
#define NDS_SYNTAX_ID_12    12 /* Net Address */
#define NDS_SYNTAX_ID_13    13 /* Octet List */
#define NDS_SYNTAX_ID_14    14 /* EMail Address */
#define NDS_SYNTAX_ID_15    15 /* Path */
#define NDS_SYNTAX_ID_16    16 /* Replica Pointer */
#define NDS_SYNTAX_ID_17    17 /* Object ACL */
#define NDS_SYNTAX_ID_18    18 /* Postal Address */
#define NDS_SYNTAX_ID_19    19 /* Timestamp */
#define NDS_SYNTAX_ID_20    20 /* Class Name */
#define NDS_SYNTAX_ID_21    21 /* Stream */
#define NDS_SYNTAX_ID_22    22 /* Counter */
#define NDS_SYNTAX_ID_23    23 /* Back Link */
#define NDS_SYNTAX_ID_24    24 /* Time */
#define NDS_SYNTAX_ID_25    25 /* Typed Name */
#define NDS_SYNTAX_ID_26    26 /* Hold */
#define NDS_SYNTAX_ID_27    27 /* Interval */


//
// NDS Distinguished Name
//
// Used in attributes: Alias Object Name, Default Queue, Device,
//                     Group Membership, Higher Privileges, Host Device,
//                     Host Server, Member, Message Server, Operator, Owner,
//                     Profile, Reference, Resource, Role Occupant,
//                     Security Equals, See Also, Server, User, Volume
//
typedef struct
{
    LPWSTR DNString;

} ASN1_TYPE_1, * LPASN1_TYPE_1;

//
// NDS Case Exact String syntax
//
// Used in attribute: Home Directory
//
typedef struct
{
    LPWSTR CaseExactString;

} ASN1_TYPE_2, * LPASN1_TYPE_2;

//
// NDS Case Ignore String syntax
//
// Used in attributes: Cartridge, CN (Common Name), C (Country Name),
//                     Description, Host Resource Name, L (Locality Name),
//                     O (Organization Name), OU (Organizational Unit Name),
//                     Physical Delivery Office Name, Postal Code,
//                     Postal Office Box, Queue Directory, SAP Name,
//                     S (State or Province Name), SA (Street Address),
//                     Supported Services, Supported Typefaces, Surname,
//                     Title, Unknown Base Class, Version
//
typedef struct
{
    LPWSTR CaseIgnoreString;

} ASN1_TYPE_3, * LPASN1_TYPE_3;

//
// NDS Printable String syntax
//
// Used in attributes: Page Description Language, Serial Number
//
typedef struct
{
    LPWSTR PrintableString;

} ASN1_TYPE_4, * LPASN1_TYPE_4;

//
// NDS Numeric String syntax
//
// Used in attributes: Bindery Type
//
typedef struct
{
    LPWSTR NumericString;

} ASN1_TYPE_5, * LPASN1_TYPE_5;

//
// NDS Case Ignore List syntax
//
// Used in attribute: Language
//
typedef struct _CI_LIST
{
    struct _CI_LIST * Next;
    LPWSTR            String;

} ASN1_TYPE_6, * LPASN1_TYPE_6;

//
// NDS Boolean syntax
//
// Used in attributes: Allow Unlimited Credit, Detect Intruder,
//                     Lockout After Detection, Locked By Intruder,
//                     Login Diabled, Password Allow Change, Password Required,
//                     Password Unique Required
//
typedef struct
{
    DWORD Boolean;

} ASN1_TYPE_7, * LPASN1_TYPE_7;

//
// Example: NDS Integer syntax
//
// Used in attributes: Bindery Object Restriction, Convergence, GID (Group ID),
//                     Login Grace Limit, Login Intruder Limit,
//                     Login Maximum Simultaneous, Memory,
//                     Minimum Account Balance, Password Minimum Length, Status,
//                     Supported Connections, UID (User ID)
//
typedef struct
{
    DWORD Integer;

} ASN1_TYPE_8, * LPASN1_TYPE_8;

//
// NDS Octet String syntax
//
// Used in attributes: Athority Revocation, Bindery Property, CA Private Key,
//                     CA Public Key, Certificate Revocation,
//                     Cross Certificate Pair, Login Allowed Time Map,
//                     Passwords Used, Printer Configuration, Private Key,
//                     Public Key
//
typedef struct
{
    DWORD  Length;
    LPBYTE OctetString;

} ASN1_TYPE_9, * LPASN1_TYPE_9;

//
// NDS Telephone Number syntax
//
// Used in attribute: Telephone Number
//
typedef struct
{
    LPWSTR TelephoneNumber;

} ASN1_TYPE_10, * LPASN1_TYPE_10;

//
// NDS Facsimile Telephone Number syntax
//
// Used in attribute: Facsimile Telephone Number
//
typedef struct
{
    LPWSTR TelephoneNumber;
    DWORD  NumberOfBits;
    LPBYTE Parameters;

} ASN1_TYPE_11, * LPASN1_TYPE_11;

//
// NDS Network Address syntax
//
// Used in attributes: Login Intruder Address, Network Address,
//                     Network Address Restriction
//
typedef struct
{
    DWORD  AddressType; // 0 = IPX,
    DWORD  AddressLength;
    BYTE * Address;

} ASN1_TYPE_12, * LPASN1_TYPE_12;

//
// NDS Octet List syntax
//
// Used in attribute: (none)
//
typedef struct _OCTET_LIST
{
    struct _OCTET_LIST * Next;
    DWORD  Length;
    BYTE * Data;

} ASN1_TYPE_13, * LPASN1_TYPE_13;

//
// NDS EMail Address syntax
//
// Used in attribute: EMail Address
//
typedef struct
{
    DWORD  Type;
    LPWSTR Address;

} ASN1_TYPE_14, * LPASN1_TYPE_14;

//
// NDS Path syntax
//
// Used in attribute: Path
//
typedef struct
{
    DWORD  Type;
    LPWSTR VolumeName;
    LPWSTR Path;

} ASN1_TYPE_15, * LPASN1_TYPE_15;

//
// NDS Replica Pointer syntax
//
// Used in attribute: Replica
//
typedef struct
{
    LPWSTR ServerName;
    DWORD  ReplicaType;
    DWORD  ReplicaNumber;
    DWORD  Count;
    ASN1_TYPE_12 ReplicaAddressHint[1]; // ReplicaAddressHint is variable and
                                        // can be calculated by Count * the
                                        // length of a ASN1_TYPE_12 ( that is
                                        // Count * 9).

} ASN1_TYPE_16, * LPASN1_TYPE_16;

//
// NDS Object ACL syntax
//
// Used in attributes: ACL, Inherited ACL
//
typedef struct
{
    LPWSTR ProtectedAttrName;
    LPWSTR SubjectName;
    DWORD  Privileges;

} ASN1_TYPE_17, * LPASN1_TYPE_17;

//
// NDS Postal Address syntax
//
// Used in attribute: Postal Address
//
typedef struct
{
    LPWSTR PostalAddress[6]; // Value is limited to 6 lines,
                             // 30 characters each.

} ASN1_TYPE_18, * LPASN1_TYPE_18;

//
// NDS Timestamp syntax
//
// Used in attribute: Obituary, Partition Creation Time, Received Up To,
//                    Syncronized Up To
//
typedef struct
{
    DWORD WholeSeconds; // Zero equals 12:00 midnight, January 1, 1970, UTC
    DWORD EventID;

} ASN1_TYPE_19, * LPASN1_TYPE_19;

//
// NDS Class Name syntax
//
// Used in attribute: Object Class
//
typedef struct
{
    LPWSTR ClassName;

} ASN1_TYPE_20, * LPASN1_TYPE_20;

//
// NDS Stream syntax
//
// Used in attribute: Login Script, Print Job Configuration, Printer Control,
//                    Type Creator Map
//
typedef struct
{
    DWORD  Length; // Always zero
    BYTE * Data; 

} ASN1_TYPE_21, * LPASN1_TYPE_21;

//
// NDS Count syntax
//
// Used in attributes: Account Balance, Login Grace Remaining,
//                     Login Intruder Attempts
//
typedef struct
{
    DWORD Counter;

} ASN1_TYPE_22, * LPASN1_TYPE_22;

//
// NDS Back Link syntax
//
// Used in attribute: Back Link
//
typedef struct
{
    DWORD  RemoteID;
    LPWSTR ObjectName;

} ASN1_TYPE_23, * LPASN1_TYPE_23;

//
// NDS Time syntax
//
// Used in attributes: Last Login Time, Login Expiration Time,
//                     Login Intruder Rest Time, Login Time,
//                     Low Convergence Reset Time, Password Expiration Time
//
typedef struct
{
    DWORD Time; // (in whole seconds) zero equals 12:00 midnight,
                // January 1, 1970, UTC

} ASN1_TYPE_24, * LPASN1_TYPE_24;

//
// NDS Typed Name syntax
//
// Used in attribute: Notify, Print Server, Printer, Queue
//
typedef struct
{
    LPWSTR ObjectName;
    DWORD  Level;
    DWORD  Interval;

} ASN1_TYPE_25, * LPASN1_TYPE_25;

//
// NDS Hold syntax
//
// Used in attribute: Server Holds
//
typedef struct
{
    LPWSTR ObjectName;
    DWORD  Amount;

} ASN1_TYPE_26, * LPASN1_TYPE_26;

//
// NDS Interval syntax
//
// Used in attribute: High Convergence Syncronization Interval,
//                    Intruder Attempt Reset Interval,
//                    Intruder Lockout Reset Interval,
//                    Low Convergence Syncronization Interval,
//                    Password Expiration Interval
//
typedef struct
{
    DWORD  Interval;

} ASN1_TYPE_27, * LPASN1_TYPE_27;

//
// rc.exe falls over because this macro gets way too long
//
#ifndef RC_INVOKED

#define SIZE_OF_ASN1_1  sizeof( ASN1_TYPE_1 )
#define SIZE_OF_ASN1_2  sizeof( ASN1_TYPE_2 )
#define SIZE_OF_ASN1_3  sizeof( ASN1_TYPE_3 )
#define SIZE_OF_ASN1_4  sizeof( ASN1_TYPE_4 )
#define SIZE_OF_ASN1_5  sizeof( ASN1_TYPE_5 )
#define SIZE_OF_ASN1_6  sizeof( ASN1_TYPE_6 )
#define SIZE_OF_ASN1_7  sizeof( ASN1_TYPE_7 )
#define SIZE_OF_ASN1_8  sizeof( ASN1_TYPE_8 )
#define SIZE_OF_ASN1_9  sizeof( ASN1_TYPE_9 )
#define SIZE_OF_ASN1_10 sizeof( ASN1_TYPE_10 )
#define SIZE_OF_ASN1_11 sizeof( ASN1_TYPE_11 )
#define SIZE_OF_ASN1_12 sizeof( ASN1_TYPE_12 )
#define SIZE_OF_ASN1_13 sizeof( ASN1_TYPE_13 )
#define SIZE_OF_ASN1_14 sizeof( ASN1_TYPE_14 )
#define SIZE_OF_ASN1_15 sizeof( ASN1_TYPE_15 )
#define SIZE_OF_ASN1_16 sizeof( ASN1_TYPE_16 )
#define SIZE_OF_ASN1_17 sizeof( ASN1_TYPE_17 )
#define SIZE_OF_ASN1_18 sizeof( ASN1_TYPE_18 )
#define SIZE_OF_ASN1_19 sizeof( ASN1_TYPE_19 )
#define SIZE_OF_ASN1_20 sizeof( ASN1_TYPE_20 )
#define SIZE_OF_ASN1_21 sizeof( ASN1_TYPE_21 )
#define SIZE_OF_ASN1_22 sizeof( ASN1_TYPE_22 )
#define SIZE_OF_ASN1_23 sizeof( ASN1_TYPE_23 )
#define SIZE_OF_ASN1_24 sizeof( ASN1_TYPE_24 )
#define SIZE_OF_ASN1_25 sizeof( ASN1_TYPE_25 )
#define SIZE_OF_ASN1_26 sizeof( ASN1_TYPE_26 )
#define SIZE_OF_ASN1_27 sizeof( ASN1_TYPE_27 )

#define MOD_OF_ASN1_1  (SIZE_OF_ASN1_1 % sizeof(DWORD))
#define MOD_OF_ASN1_2  (SIZE_OF_ASN1_2 % sizeof(DWORD))
#define MOD_OF_ASN1_3  (SIZE_OF_ASN1_3 % sizeof(DWORD))
#define MOD_OF_ASN1_4  (SIZE_OF_ASN1_4 % sizeof(DWORD))
#define MOD_OF_ASN1_5  (SIZE_OF_ASN1_5 % sizeof(DWORD))
#define MOD_OF_ASN1_6  (SIZE_OF_ASN1_6 % sizeof(DWORD))
#define MOD_OF_ASN1_7  (SIZE_OF_ASN1_7 % sizeof(DWORD))
#define MOD_OF_ASN1_8  (SIZE_OF_ASN1_8 % sizeof(DWORD))
#define MOD_OF_ASN1_9  (SIZE_OF_ASN1_9 % sizeof(DWORD))
#define MOD_OF_ASN1_10 (SIZE_OF_ASN1_10 % sizeof(DWORD))
#define MOD_OF_ASN1_11 (SIZE_OF_ASN1_11 % sizeof(DWORD))
#define MOD_OF_ASN1_12 (SIZE_OF_ASN1_12 % sizeof(DWORD))
#define MOD_OF_ASN1_13 (SIZE_OF_ASN1_13 % sizeof(DWORD))
#define MOD_OF_ASN1_14 (SIZE_OF_ASN1_14 % sizeof(DWORD))
#define MOD_OF_ASN1_15 (SIZE_OF_ASN1_15 % sizeof(DWORD))
#define MOD_OF_ASN1_16 (SIZE_OF_ASN1_16 % sizeof(DWORD))
#define MOD_OF_ASN1_17 (SIZE_OF_ASN1_17 % sizeof(DWORD))
#define MOD_OF_ASN1_18 (SIZE_OF_ASN1_18 % sizeof(DWORD))
#define MOD_OF_ASN1_19 (SIZE_OF_ASN1_19 % sizeof(DWORD))
#define MOD_OF_ASN1_20 (SIZE_OF_ASN1_20 % sizeof(DWORD))
#define MOD_OF_ASN1_21 (SIZE_OF_ASN1_21 % sizeof(DWORD))
#define MOD_OF_ASN1_22 (SIZE_OF_ASN1_22 % sizeof(DWORD))
#define MOD_OF_ASN1_23 (SIZE_OF_ASN1_23 % sizeof(DWORD))
#define MOD_OF_ASN1_24 (SIZE_OF_ASN1_24 % sizeof(DWORD))
#define MOD_OF_ASN1_25 (SIZE_OF_ASN1_25 % sizeof(DWORD))
#define MOD_OF_ASN1_26 (SIZE_OF_ASN1_26 % sizeof(DWORD))
#define MOD_OF_ASN1_27 (SIZE_OF_ASN1_27 % sizeof(DWORD))

#define SUM_OF_ASN1_MODS ( MOD_OF_ASN1_1  + MOD_OF_ASN1_2  + MOD_OF_ASN1_3  + \
                           MOD_OF_ASN1_4  + MOD_OF_ASN1_5  + MOD_OF_ASN1_6  + \
                           MOD_OF_ASN1_7  + MOD_OF_ASN1_8  + MOD_OF_ASN1_9  + \
                           MOD_OF_ASN1_10 + MOD_OF_ASN1_11 + MOD_OF_ASN1_12 + \
                           MOD_OF_ASN1_13 + MOD_OF_ASN1_14 + MOD_OF_ASN1_15 + \
                           MOD_OF_ASN1_16 + MOD_OF_ASN1_17 + MOD_OF_ASN1_18 + \
                           MOD_OF_ASN1_19 + MOD_OF_ASN1_20 + MOD_OF_ASN1_21 + \
                           MOD_OF_ASN1_22 + MOD_OF_ASN1_23 + MOD_OF_ASN1_24 + \
                           MOD_OF_ASN1_25 + MOD_OF_ASN1_26 + MOD_OF_ASN1_27 )

//
// If an error occurs here, then the structures found in this file are not
// DWORD aligned. They should be in order to run on RISC platforms.
//
static int x[1 - SUM_OF_ASN1_MODS] ;

#endif  // RC_INVOKED
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\nwpapi32.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1993 Microsoft Corporation
//
//  Module Name:
//
//      nwapi32.h
//
//  Abstract:
//
//      This module contains the support to routines
//      into the CSNW that use NTSTATUS.
//
//  Author:
//
//      Chris Sandys    (a-chrisa)  09-Sep-1993
//
//  Revision History:
//      Chuck Y Chan    Feb 7, 1996    Spilt of NTSTATUS type calls 
//                                     from nwapi32.h
//
//////////////////////////////////////////////////////////////////////////////


#ifndef _NWPAPI32_H_
#define _NWPAPI32_H_

#include <nwapi32.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Versions of functions above, but return NTSTATUS. Keep around because     //
// existing DSMN code calls them. Do not extenf this set. The NWC* functions //
// are the ones to use.                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NWPAttachToFileServerW(
    const WCHAR             *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE           *phNewConn
    );

NTSTATUS
NWPDetachFromFileServer(
    NWCONN_HANDLE           hConn
    );

NTSTATUS
NWPGetFileServerVersionInfo(
    NWCONN_HANDLE           hConn,
    VERSION_INFO            *lpVerInfo
    );

DWORD
NWPLoginToFileServerW(
    NWCONN_HANDLE           hConn,
    LPWSTR                  pszUserName,
    NWOBJ_TYPE              wObType,
    LPWSTR                  pszPassword
    );

DWORD
NWPLogoutFromFileServer(
    NWCONN_HANDLE           hConn
    );

NTSTATUS
NWPDeleteObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType
    );

NTSTATUS
NWPCreateObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    NWFLAGS                 ucObjectFlags, 
    NWFLAGS                 ucObjSecurity
    );

NTSTATUS
NWPWritePropertyValue(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    NWSEGMENT_NUM           segmentNumber,
    NWSEGMENT_DATA          *segmentData,
    NWFLAGS                 moreSegments
    );

NTSTATUS
NWPChangeObjectPasswordEncrypted(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    BYTE                    *validationKey,
    BYTE                    *newKeyedPassword
    );

NTSTATUS
NWPGetObjectID(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    NWOBJ_ID                *objectID
    );

NTSTATUS
NWPAddObjectToSet( 
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    const char              *pszMemberName,
    NWOBJ_TYPE              memberType
    );

NTSTATUS
NWPDeleteObjectFromSet( 
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    const char              *pszMemberName,
    NWOBJ_TYPE              memberType
    );

NTSTATUS
NWPCreateProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    NWFLAGS                 ucObjectFlags, 
    NWFLAGS                 ucObjSecurity
    );

NTSTATUS
NWPDeleteProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName
    );

NTSTATUS
NWPGetChallengeKey(
    NWCONN_HANDLE           hConn,
    UCHAR                   *challengeKey
    );

NTSTATUS
NWPReadPropertyValue(
    NWCONN_HANDLE           hConn,
    const char              *pszObjName,
    NWOBJ_TYPE              wObjType,
    char                    *pszPropName,
    unsigned char           ucSegment,
    char                    *pValue,
    NWFLAGS                 *pucMoreFlag,
    NWFLAGS                 *pucPropFlag
    );


NTSTATUS
NWPCreateDirectory(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWACCESS_RIGHTS         accessMask
    );

NTSTATUS
NWPAddTrustee(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWOBJ_ID                dwTrusteeID,
    NWRIGHTS_MASK           rightsMask
    );

NTSTATUS
NWPRenameBinderyObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    const char              *pszNewObjectName,
    NWOBJ_TYPE              wObjType 
    );

NTSTATUS
NWPGetObjectName(
    NWCONN_HANDLE           hConn,
    NWOBJ_ID                dwObjectID,
    char                    *pszObjName,
    NWOBJ_TYPE              *pwObjType
    );

NTSTATUS
NWPScanObject(
    NWCONN_HANDLE           hConn,
    const char              *pszSearchName,
    NWOBJ_TYPE              wObjSearchType,
    NWOBJ_ID                *pdwObjectID,
    char                    *pszObjectName,
    NWOBJ_TYPE              *pwObjType,
    NWFLAGS                 *pucHasProperties,
    NWFLAGS                 *pucObjectFlags,
    NWFLAGS                 *pucObjSecurity
    );

NTSTATUS
NWPScanProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    char                    *pszSearchName,
    NWOBJ_ID                *pdwSequence,
    char                    *pszPropName,
    NWFLAGS                 *pucPropFlags,
    NWFLAGS                 *pucPropSecurity,
    NWFLAGS                 *pucHasValue,
    NWFLAGS                 *pucMore
    );

NTSTATUS
NWPScanForTrustees(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszsearchDirPath,
    NWSEQUENCE              *pucsequenceNumber,
    BYTE                    *numberOfEntries,
    TRUSTEE_INFO            *tl
    );

NTSTATUS
NWPScanDirectoryForTrustees2(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszsearchDirPath,
    NWSEQUENCE              *pucsequenceNumber,
    char                    *pszdirName,
    NWDATE_TIME             *dirDateTime,
    NWOBJ_ID                *ownerID,
    TRUSTEE_INFO            *trusteeList
    );

NTSTATUS
NWPGetBinderyAccessLevel(
    NWCONN_HANDLE           hConn,
    NWFLAGS                 *accessLevel,
    NWOBJ_ID                *objectID
    );

NTSTATUS
NWPGetFileServerDescription(
    NWCONN_HANDLE           hConn,
    char                    *pszCompany,
    char                    *pszVersion,
    char                    *pszRevision
);

NTSTATUS
NWPGetVolumeNumber(
    NWCONN_HANDLE           hConn,
    char                    *pszVolume,
    NWVOL_NUM               *VolumeNumber
);

NTSTATUS
NWPGetVolumeUsage(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               VolumeNumber,
    DWORD                   *TotalBlocks,
    DWORD                   *FreeBlocks,
    DWORD                   *PurgeableBlocks,
    DWORD                   *NotYetPurgeableBlocks,
    DWORD                   *TotalDirectoryEntries,
    DWORD                   *AvailableDirectoryEntries,
    BYTE                    *SectorsPerBlock
);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif //_NWPAPI32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\nwstatus.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwstatus.h

Abstract:

    This module defines NWRDR specific NTSTATUS

Author:

Revision History:

--*/

#ifndef _NWSTATUS_
#define _NWSTATUS_

#define FACILITY_NWRDR                    0x11

#define NWRDR_PASSWORD_HAS_EXPIRED        0x40110001

#endif // _NWSTATUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\nwutil.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwutil.h

Abstract:

    Common header for Workstation client-side code.

Author:

    Yi-Hsin Sung    (yihsins)      25-Oct-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NWUTIL_H_
#define _NWUTIL_H_

#ifdef __cplusplus
extern "C" {
#endif

#define TREECHAR L'*'
#define TWO_KB   2048

BOOL
NwIsNdsSyntax(
    IN LPWSTR lpstrUnc
);

VOID
NwAbbreviateUserName(
    IN  LPWSTR pszFullName,
    OUT LPWSTR pszUserName
);

VOID
NwMakePrettyDisplayName(
    IN  LPWSTR pszName
);

VOID
NwExtractTreeName(
    IN  LPWSTR pszUNCPath,
    OUT LPWSTR pszTreeName
);


VOID
NwExtractServerName(
    IN  LPWSTR pszUNCPath,
    OUT LPWSTR pszServerName
);


VOID
NwExtractShareName(
    IN  LPWSTR pszUNCPath,
    OUT LPWSTR pszShareName
);

DWORD
NwIsServerInDefaultTree(
    IN  LPWSTR  pszFullServerName,
    OUT BOOL   *pfInDefaultTree
);

DWORD
NwIsServerOrTreeAttached(
    IN  LPWSTR  pszServerName,
    OUT BOOL   *pfAttached,
    OUT BOOL   *pfAuthenticated
);

DWORD
NwGetConnectionInformation(
    IN  LPWSTR  pszName,
    OUT LPBYTE  Buffer,
    IN  DWORD   BufferSize
);

DWORD
NwGetConnectionStatus(
    IN     LPWSTR  pszServerName,
    IN OUT PDWORD_PTR  ResumeKey,
    OUT    LPBYTE  *Buffer,
    OUT    PDWORD  EntriesRead
);

DWORD
NwGetNdsVolumeInfo(
    IN  LPWSTR pszName,
    OUT LPWSTR pszServerBuffer,
    IN  WORD   wServerBufferSize,    // in bytes
    OUT LPWSTR pszVolumeBuffer,
    IN  WORD   wVolumeBufferSize     // in bytes
);

DWORD
NwOpenAndGetTreeInfo(
    LPWSTR pszNdsUNCPath,
    HANDLE *phTreeConn,
    DWORD  *pdwOid
);

DWORD
NwGetConnectedTrees(
    IN  LPWSTR  pszNtUserName,
    OUT LPBYTE  Buffer,
    IN  DWORD   BufferSize,
    OUT LPDWORD lpEntriesRead,
    OUT LPDWORD lpUserLUID
);

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _NWUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\spud.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    Spud.h

Abstract:

    Contains structures and declarations for SPUD.  SPUD stands for the
    Special Purpose Utility Driver.  This driver enhances the performance
    of IIS.

Author:

    John Ballard (jballard)    21-Oct-1996

Revision History:

--*/

#ifndef _SPUD_
#define _SPUD_

#define SPUD_VERSION     0x00010000

typedef enum {
    TransmitFileAndRecv,
    SendAndRecv,
} REQ_TYPE;

typedef struct _SPUD_REQ_CONTEXT {
    REQ_TYPE            ReqType;
    IO_STATUS_BLOCK     IoStatus1;
    IO_STATUS_BLOCK     IoStatus2;
    PVOID               KernelReqInfo;
} SPUD_REQ_CONTEXT, *PSPUD_REQ_CONTEXT;

typedef struct _SPUD_COUNTERS {
    ULONG       CtrTransmitfileAndRecv;
    ULONG       CtrTransRecvFastTrans;
    ULONG       CtrTransRecvFastRecv;
    ULONG       CtrTransRecvSlowTrans;
    ULONG       CtrTransRecvSlowRecv;
    ULONG       CtrSendAndRecv;
    ULONG       CtrSendRecvFastSend;
    ULONG       CtrSendRecvFastRecv;
    ULONG       CtrSendRecvSlowSend;
    ULONG       CtrSendRecvSlowRecv;
} SPUD_COUNTERS, *PSPUD_COUNTERS;

#if 0
typedef struct _SPUD_REQUEST_ITEM {
    HANDLE              Socket;
    DWORD               RequestIoctl;
    union {
        AFD_TRANSMIT_FILE_INFO  TransmitFileInfo;
        AFD_SEND_INFO           SendInfo;
        AFD_RECV_INFO           RecvInfo;
    } AfdRequest;
    IO_STATUS_BLOCK             StatusBlock;
} SPUD_REQUEST_ITEM, *PSPUD_REQUEST_ITEM;

typedef struct _SPUD_BATCH_REQUEST {
    ULONG               RequestCount;
    PSPUD_REQUEST_ITEM  RequestList;
} SPUD_BATCH_REQUEST, *PSPUD_BATCH_REQUEST;
#endif

#endif // ndef _SPUD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\strarray.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    StrArray.h

Abstract:

    This is the a header file of handy functions and macros for TCHAR
    string arrays.

    These arrays are in the following format (spaces added for clarity):

       one \0 two \0 three \0 \0

    where \0 is a null character in the appropriate format.

    These functions are useful for the NetServerDiskEnum and NetConfigGetAll
    APIs, and possibly others.

Author:

    John Rogers (JohnRo) 03-Jan-1992

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    03-Jan-1992 JohnRo
        Created this file from bits and pieces in RxCommon and NetLib.
    01-Sep-1992 JohnRo
        RAID 5016: NetConfigGetAll heap trash.

--*/

#ifndef _STRARRAY_
#define _STRARRAY_


// These must be included first:

#include <windef.h>             // IN, LPTSTR, LPVOID, etc.

// These may be included in any order:

// (none)


//
//////////////////////////////// LPTSTR_ARRAY stuff //////////////////////////
//

typedef LPTSTR LPTSTR_ARRAY;


VOID
NetpAddTStrToTStrArray (
    IN OUT LPTSTR_ARRAY Dest,
    IN LPTSTR Src
    );


VOID
NetpCopyStrArrayToTStrArray (
    OUT LPTSTR_ARRAY Dest,  // string array: TCHARs
    IN  LPSTR  Src    // string array: 8-bit input in default codepage for LAN
    );


#if DBG

VOID
NetpDisplayTStrArray (
    IN LPTSTR_ARRAY Array
    );

#else // not DBG

#define NetpDisplayTStrArray(Array)     /* nothing */

#endif // not DBG


// BOOL
// NetpIsTStrArrayEmpty (
//     IN LPTSTR_ARRAY Array
//     );
#define NetpIsTStrArrayEmpty( Array )  \
    ( ( (*(Array)) == (TCHAR) '\0') ? TRUE : FALSE )


// LPTSTR_ARRAY
// NetpNextTStrArrayEntry (
//     IN LPTSTR_ARRAY Array
//     );
#define NetpNextTStrArrayEntry(Array) \
    ( ((LPTSTR)(Array)) + (STRLEN(Array) + 1) )


//
// Return number of entries in this string array.
//
DWORD
NetpTStrArrayEntryCount (
    IN LPTSTR_ARRAY Array
    );


//
// Return number of bytes to allocate for this string array.
// This includes the "extra" trailing null char.
//
DWORD
NetpTStrArraySize(
    IN LPTSTR_ARRAY Array
    );


//
//////////////////////////////// LPSTR_ARRAY stuff //////////////////////////
//

typedef LPSTR  LPSTR_ARRAY;

DWORD
NetpStrArraySize(
    IN LPSTR_ARRAY Array
    );


#endif // ndef _STRARRAY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\wxlpc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       wxlpc.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-18-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __WXLPC_H__
#define __WXLPC_H__

#define SYSKEY_SIZE 16 //size in bytes

typedef enum _WX_AUTH_TYPE {
    WxNone = 0,
    WxStored,
    WxPrompt,
    WxDisk
    } WX_AUTH_TYPE ;

typedef struct _WXHASH {
    UCHAR Digest[16];
} WXHASH, *PWXHASH;

NTSTATUS
WxServerThread(
    PVOID Ignored
    );

NTSTATUS
WxConnect(
    OUT PHANDLE Handle
    );

NTSTATUS
WxGetKeyData(
    IN HANDLE Handle,
    IN WX_AUTH_TYPE ExpectedAuthSource,
    IN ULONG BufferSize,
    OUT PUCHAR Buffer,
    OUT PULONG BufferData
    );

NTSTATUS
WxReportResults(
    IN HANDLE Handle,
    IN NTSTATUS Status
    );

VOID
WxClientDisconnect(
    IN HANDLE Handle
    );

NTSTATUS
WxSaveSysKey(
    IN ULONG    Keylen,
    IN PVOID    Key
    );

NTSTATUS
WxReadSysKey(
    IN OUT PULONG BufferLength,
    OUT PVOID  Key
    );

NTSTATUS
WxReadSysKeyEx(
    IN HANDLE Handle,
    IN OUT PULONG BufferLength,
    OUT PVOID  Key
    );

NTSTATUS
WxLoadSysKeyFromDisk(
    OUT PVOID Key,
    IN OUT PULONG BufferLength
    );

NTSTATUS
WxHashKey(
    IN OUT LPWSTR Key,
    OUT PVOID  Syskey,
    IN OUT ULONG cbSyskey
    );

NTSTATUS
WxSaveBootOption( WX_AUTH_TYPE NewType );

#endif  // __WXLPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\nwstruct.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwstruct.h

Abstract:

    Contains data structures used by NCP Server APIs.

Author:

    Yi-Hsin Sung (yihsins)  11-Sept-1993

Revision History:

--*/

#ifndef _NWSTRUCT_H_
#define _NWSTRUCT_H_

#include <fpnwapi.h>

#ifdef __cplusplus
extern "C" {
#endif

//
//  Volume types : disk or printer
//

#define NWVOL_TYPE_DISKTREE             FPNWVOL_TYPE_DISKTREE
#define NWVOL_TYPE_CDROM                FPNWVOL_TYPE_CDROM
#define NWVOL_TYPE_REMOVABLE            FPNWVOL_TYPE_REMOVABLE

#define NWVOL_MAX_USES_UNLIMITED        ((ULONG)-1)

//
//  Permissions flags returned in structure FPNWFILEINFO
//

#define NWFILE_PERM_NONE                FPNWFILE_PERM_NONE
#define NWFILE_PERM_READ                FPNWFILE_PERM_READ
#define NWFILE_PERM_WRITE               FPNWFILE_PERM_WRITE
#define NWFILE_PERM_CREATE              FPNWFILE_PERM_CREATE
#define NWFILE_PERM_EXEC                FPNWFILE_PERM_EXEC
#define NWFILE_PERM_DELETE              FPNWFILE_PERM_DELETE
#define NWFILE_PERM_ATRIB               FPNWFILE_PERM_ATRIB
#define NWFILE_PERM_PERM                FPNWFILE_PERM_PERM

#define NWSERVERADDR                    FPNWSERVERADDR

typedef FPNWSERVERINFO  NWSERVERINFO, *PNWSERVERINFO;
typedef FPNWVOLUMEINFO  NWVOLUMEINFO, *PNWVOLUMEINFO;
typedef FPNWVOLUMEINFO_2  NWVOLUMEINFO_2, *PNWVOLUMEINFO_2;
typedef FPNWCONNECTIONINFO  NWCONNECTIONINFO, *PNWCONNECTIONINFO;
typedef FPNWVOLUMECONNINFO  NWVOLUMECONNINFO, *PNWVOLUMECONNINFO;
typedef FPNWFILEINFO  NWFILEINFO, *PNWFILEINFO;

//
//  Below are the APIs available to manipulate FPNW servers, volumes, etc.
//

DWORD
NwApiBufferFree(
    IN  LPVOID pBuffer
);

DWORD
NwServerGetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT PNWSERVERINFO *ppServerInfo
);

DWORD
NwServerSetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  PNWSERVERINFO pServerInfo
);

DWORD
NwVolumeAdd(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  PNWVOLUMEINFO pVolumeInfo
);

DWORD
NwVolumeDel(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName
);

DWORD
NwVolumeEnum(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT PNWVOLUMEINFO *ppVolumeInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
);

DWORD
NwVolumeGetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    OUT PNWVOLUMEINFO *ppVolumeInfo
);

DWORD
NwVolumeSetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    IN  PNWVOLUMEINFO pVolumeInfo
);

DWORD
NwConnectionEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    OUT PNWCONNECTIONINFO *ppConnectionInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
);

DWORD NwConnectionDel(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId
);

DWORD
NwVolumeConnEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD dwLevel,
    IN LPWSTR pVolumeName,
    IN DWORD  dwConnectionId,
    OUT PNWVOLUMECONNINFO *ppVolumeConnInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
);

DWORD
NwFileEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    IN LPWSTR pPathName OPTIONAL,
    OUT PNWFILEINFO *ppFileInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
);

DWORD
NwFileClose(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  nFileId
);

DWORD NwMessageBufferSend(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId,
    IN DWORD  fConsoleBroadcast,
    IN LPBYTE pbBuffer,
    IN DWORD  cbBuffer
);

DWORD NwSetDefaultQueue(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pQueueName
);

DWORD NwAddPServer(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pPServerName
);

DWORD NwRemovePServer(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pPServerName
);

#ifdef __cplusplus
}   /* extern "C" */
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\prefix.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Prefix.h

Abstract:

    This header file declares equates for debug print "prefix" strings.
    For the moment, these are of the form:

        #define PREFIX_NETLIB     "NETLIB: "

    These are collected into a header file in case someone decides to
    change the look of these strings, or internationalize them, or
    whatever.

Author:

    John Rogers (JohnRo) 08-May-1992

Environment:

    Portable to just about any computer I ever saw.  --JR

Revision History:

    08-May-1992 JohnRo
        Created.
    27-May-1992 JohnRo
        Added PREFIX_SC and PREFIX_SC_CLIENT for service controller.
        Added PREFIX_PORTUAS for PortUAS utility (run during setup).
    07-Aug-1992 JohnRo
        RAID 1895: Net APIs and svc should use OEM char set (not ANSI).
        (Added PREFIX_XACTSRV as part of support for that.)
    16-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.

--*/


#ifndef _PREFIX_H_INCLUDED_
#define _PREFIX_H_INCLUDED_


#define PREFIX_NETAPI       "NETAPI32: "
#define PREFIX_NETLIB       "NETLIB: "
#define PREFIX_NETLOGON     "NETLOGON: "
#define PREFIX_NETRAP       "NETRAP: "
#define PREFIX_PORTUAS      "PORTUAS: "
#define PREFIX_REPL         "REPL: "
#define PREFIX_REPL_CLIENT  "REPL-CLIENT: "
#define PREFIX_REPL_MASTER  "REPL-MASTER: "
#define PREFIX_SC           "SC: "
#define PREFIX_SC_CLIENT    "SC-CLIENT: "
#define PREFIX_WKSTA        "WKSTA: "
#define PREFIX_XACTSRV      "XACTSRV: "



#endif // ndef _PREFIX_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\xpress.h ===
#ifndef _XPRESS_H_
#define _XPRESS_H_

#ifdef _MSC_VER
#pragma once
#endif


/* ------------------------------------------------------------------------ */
/*                                                                          */
/*  Copyright (c) Microsoft Corporation, 2000-2001. All rights reserved.    */
/*  Copyright (c) Andrew Kadatch, 1991-2001. All rights reserved.           */
/*                                                                          */
/*  Microsoft Confidential -- do not redistribute.                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */


#ifdef __cplusplus
extern "C" {
#endif

/* ---------------------- Common declarations ------------------------- */
/*                        -------------------                           */

// max. size of input block
#define XPRESS_MAX_BLOCK_LOG    16
#define XPRESS_MAX_BLOCK        (1 << XPRESS_MAX_BLOCK_LOG)


// preferred data alignment to avoid misaligned accesses
#define XPRESS_ALIGNMENT        8

// declare default calling convention used in xpress
#if !defined (UNIX) && !defined (XPRESS_CALL)
#define XPRESS_CALL __stdcall
#endif


// user-supplied callback function that allocates memory
// if there is no memory available it shall return NULL
typedef
void *
XPRESS_CALL
  XpressAllocFn
  (
    void *context,      // user-defined context (as passed to XpressEncodeCreate)
    int size            // size of memory block to allocate
  );

// user-supplied callback function that releases memory
typedef
void
XPRESS_CALL
  XpressFreeFn
  (
    void *context,      // user-defined context (as passed to XpressEncodeClose)
    void *address       // pointer to the block to be freed
  );


/* ----------------------------- Encoder ------------------------------ */
/*                               -------                                */

// declare unique anonymous types for type safety
typedef struct {int XpressEncodeDummy;} *XpressEncodeStream;

// allocate and initialize encoder's data structures
// returns NULL if callback returned NULL (not enough memory)
XpressEncodeStream
XPRESS_CALL
  XpressEncodeCreate
  (
    int MaxOrigSize,                    // max size of original data block
    void *context,                      // user-defined context info (will  be passed to AllocFn)
    XpressAllocFn *AllocFn,             // memory allocation callback
    int CompressionLevel                // use 0 for speed, 9 for quality
  );


// callback function called by XpressEncode to indicate compression progress
typedef
void
XPRESS_CALL
  XpressProgressFn
  (
    void *context,                      // user-defined context
    int compressed                      // size of processed original data
  );
    

// returns size of compressed data
// if compression failed then compressed buffer is left as is, and
// original data should be saved instead
int
XPRESS_CALL
  XpressEncode
  (
    XpressEncodeStream stream,          // encoder's workspace
    void *CompAdr, int CompSize,        // compressed data region
    const void *OrigAdr, int OrigSize,  // input data block
    XpressProgressFn *ProgressFn,       // NULL or progress callback
    void *ProgressContext,              // user-defined context that will be passed to ProgressFn
    int ProgressSize                    // call ProgressFn each time ProgressSize bytes processed
  );

// invalidate input stream and release workspace memory
void
XPRESS_CALL
  XpressEncodeClose
  (
    XpressEncodeStream stream,          // encoder's workspace
    void *context, XpressFreeFn *FreeFn // memory releasing callback
  );


/* ----------------------------- Decoder ------------------------------ */
/*                               -------                                */

// declare unique anonymous types for type safety
typedef struct {int XpressDecodeDummy;} *XpressDecodeStream;

// allocate memory for decoder. Returns NULL if not enough memory.
XpressDecodeStream
XPRESS_CALL
  XpressDecodeCreate
  (
    void *context,                      // user-defined context info (will  be passed to AllocFn)
    XpressAllocFn *AllocFn              // memory allocation callback
  );

// decode compressed block. Returns # of decoded bytes or -1 otherwise
int
XPRESS_CALL
XpressDecode
  (
    XpressDecodeStream stream,          // decoder's workspace
    void *OrigAdr, int OrigSize,        // original data region
    int DecodeSize,                     // # of bytes to decode ( <= OrigSize)
    const void *CompAdr, int CompSize   // compressed data block
  );

void
XPRESS_CALL
  XpressDecodeClose
  (
    XpressDecodeStream stream,          // encoder's workspace
    void *context,                      // user-defined context info (will  be passed to FreeFn)
    XpressFreeFn *FreeFn                // callback that releases the memory
  );


/* ------------------------------ CRC32 ------------------------------- */
/*                                -----                                 */

int
XPRESS_CALL
  XpressCrc32
  (
    const void *data,                   // beginning of data block
    int bytes,                          // number of bytes
    int crc                             // initial value
  );


#ifdef __cplusplus
};
#endif

#endif /* _XPRESS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\winrnr.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    winrnr.c

Abstract:

    Rnr provider for ActiveDirectory.

Work items:

    1) Need to support the NTDS Global catalog on LUP_DEEP from Root searches.
    2) Need to add bind handle caching.

Author:

    GlennC      23-Jul-1996

Revision History:

    GlennC      Added support for LUP_CONTAINERS in NSP2LookupServiceXXX
                functions.

    jamesg      Jan 2001        cleanup, bug fixes, proper alignment
    jamesg      May 2001        rewrite
                                    - 64-bit completely broken because 32-bit
                                        structures used as bervals
                                    - leaks
                                    - duplicate code
                                    - simplify flat buffer building macros
                                    - allow for sockaddrs other than IP4

--*/


#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include <rpcdce.h>
#include <winsock2.h>
#include <ws2spi.h>
#include <wsipx.h>
#include <svcguid.h>
#include <rnraddrs.h>
#include <align.h>
#include <winldap.h>

#include <windns.h>     // alignment macro
#include <dnslib.h>     // flat buffer stuff, memory allocation


//
//  RnR context
//
//  Context we keep during a given RnR lookup session.
//

typedef struct
{
    PLDAP   pLdapServer;
    PLDAP   pLdapGlobalCatalog;
    PWSTR   DomainDN;
    PWSTR   WinsockServicesDN;
}
RNR_CONNECTION, *PRNR_CONNECTION;

typedef struct
{
    DWORD   Count;
    DWORD   CurrentIndex;
    PWSTR   Strings[0];
}
DN_ARRAY, *PDN_ARRAY;

typedef struct
{
    DWORD               Signature;
    DWORD               ControlFlags;
    DWORD               CurrentDN;
    DWORD               NumberOfProtocols;
    PWSTR               pwsServiceName;
    PRNR_CONNECTION     pRnrConnection;
    PDN_ARRAY           pDnArray;
    PWSTR               pwsContext;
    PAFPROTOCOLS        pafpProtocols;
    PWSAVERSION         pVersion;
    WSAVERSION          WsaVersion;
    GUID                ServiceClassGuid;
    GUID                ProviderGuid;
}
RNR_LOOKUP, *PRNR_LOOKUP;


//
//  WSANSCLASSINFO stored in berval
//
//  ClassInfo blobs read and written to directory with
//  pointers replaced by offsets.
//
//  Note:  need to explicitly make this structure, because
//  the WSANSCLASSINFO struct is different sizes for
//  32/64bit;   this structure will match the 32-bit
//  WSANSCLASSINFO which have already been written to
//  the directory in Win2K deployments
//

typedef struct _ClassInfoAsBerval
{
    DWORD   NameOffset;
    DWORD   dwNameSpace;
    DWORD   dwValueType;
    DWORD   dwValueSize;
    DWORD   ValueOffset;
}
CLASSINFO_BERVAL, *PCLASSINFO_BERVAL;

//
//  CSADDR stored in berval
//
//  CSADDRs read and written to directory with
//  pointers replaced by offsets.
//
//  Note:  as with WSANSCLASSINFO above CSADDR can not
//  be used directly in both 32 and 64 bit.  Make a structure
//  that explicitly uses offsets and matches the already
//  deployed 32-bit form.
//

typedef struct _CsaddrAsBerval
{
    DWORD       LocalZero;
    LONG        LocalLength;
    DWORD       RemoteZero;
    LONG        RemoteLength;
    LONG        iSocketType;
    LONG        iProtocol;
}
CSADDR_BERVAL, *PCSADDR_BERVAL;


//
//  RnR defines      
//

#define RNR_SIGNATURE           0x7364736e      //  "nsds"
#define RNR_SIGNATURE_FREE      0x65657266      //  "free"

#define LDAP_GLOBAL_CATALOG     3268

//
//  Standard out-of-mem rcode
//

#define ERROR_NO_MEMORY         WSA_NOT_ENOUGH_MEMORY

//
//  Defs to straight pointer
//

typedef LPGUID  PGUID;

typedef LPWSASERVICECLASSINFOW  PWSASERVICECLASSINFOW;

typedef DWORD   RNR_STATUS;

#define GuidEqual(x,y)          RtlEqualMemory( x, y, sizeof(GUID) )

//
//  Debug printing
//

#ifdef DBG
//#define WINRNR_PRINT( foo )     KdPrint( foo )
#define WINRNR_PRINT( foo )     DNS_PRINT( foo )
#else
#define WINRNR_PRINT( foo )
#endif

#ifdef DBG
#define DnsDbg_DnArray(h,p)         Print_DnArray( DnsPR, NULL, (h), (p) )
#define DnsDbg_RnrConnection(h,p)   Print_RnrConnection( DnsPR, NULL, (h), (p) )
#define DnsDbg_RnrLookup(h,p)       Print_RnrLookup( DnsPR, NULL, (h), (p) )
#else
#define DnsDbg_DnArray(h,p)
#define DnsDbg_RnrConnection(h,p)
#define DnsDbg_RnrLookup(h,p)
#endif

//
//  LDAP search stuff
//      - DN pieces
//      - attributes
//      - filters
//

WCHAR   g_NtdsContainer[]       = L"Container";
WCHAR   g_CommonName[]          = L"CN";
WCHAR   g_DisplayName[]         = L"displayName";
WCHAR   g_Comment[]             = L"description";
WCHAR   g_DefaultDn[]           = L"defaultNamingContext";
WCHAR   g_ObjectClass[]         = L"objectClass";
WCHAR   g_ObjectName[]          = L"name";
WCHAR   g_ServiceClass[]        = L"serviceClass";
WCHAR   g_ServiceClassId[]      = L"serviceClassID";
WCHAR   g_ServiceClassInfo[]    = L"serviceClassInfo";
WCHAR   g_ServiceInstance[]     = L"serviceInstance";
WCHAR   g_ServiceVersion[]      = L"serviceInstanceVersion";
WCHAR   g_WinsockAddresses[]    = L"winsockAddresses";
WCHAR   g_WinsockServicesDn[]   = L"CN=WinsockServices,CN=System,";

WCHAR   g_FilterObjectClass_ServiceClass[]      = L"(objectClass=serviceClass)";
WCHAR   g_FilterObjectClass_ServiceInstance[]   = L"(objectClass=serviceInstance)";
WCHAR   g_FilterObjectClass_Container[]         = L"(objectClass=Container)";
WCHAR   g_FilterObjectClass_Star[]              = L"(objectClass=*)";

WCHAR   g_FilterCnEquals[]                      = L"CN=";
WCHAR   g_FilterParenCnEquals[]                 = L"(CN=";
WCHAR   g_FilterParenServiceClassIdEquals[]     = L"(serviceClassId=";
WCHAR   g_FilterParenServiceVersionEquals[]     = L"(serviceVersion=";

//
//  Access with #defines
//

#define NTDS_CONTAINER          g_NtdsContainer
#define COMMON_NAME             g_CommonName
#define DEFAULT_DOMAIN_DN       g_DefaultDn
#define OBJECT_CLASS            g_ObjectClass
#define OBJECT_COMMENT          g_Comment
#define OBJECT_NAME             g_ObjectName
#define SERVICE_CLASS           g_ServiceClass
#define SERVICE_CLASS_ID        g_ServiceClassId
#define SERVICE_CLASS_INFO      g_ServiceClassInfo
#define SERVICE_CLASS_NAME      g_DisplayName
#define SERVICE_COMMENT         g_Comment
#define SERVICE_INSTANCE        g_ServiceInstance
#define SERVICE_INSTANCE_NAME   g_DisplayName
#define SERVICE_VERSION         g_ServiceVersion
#define WINSOCK_ADDRESSES       g_WinsockAddresses
#define WINSOCK_SERVICES        g_WinsockServicesDn

//  Filters

#define FILTER_OBJECT_CLASS_SERVICE_CLASS       g_FilterObjectClass_ServiceClass
#define FILTER_OBJECT_CLASS_SERVICE_INSTANCE    g_FilterObjectClass_ServiceInstance
#define FILTER_OBJECT_CLASS_NTDS_CONTAINER      g_FilterObjectClass_Container
#define FILTER_OBJECT_CLASS_STAR                g_FilterObjectClass_Star
                                                                                            
#define FILTER_CN_EQUALS                        g_FilterCnEquals
#define FILTER_PAREN_CN_EQUALS                  g_FilterParenCnEquals
#define FILTER_PAREN_SERVICE_CLASS_ID_EQUALS    g_FilterParenServiceClassIdEquals
#define FILTER_PAREN_SERVICE_VERSION_EQUALS     g_FilterParenServiceVersionEquals


//
//  GUID generated by uuidgen.exe for provider identifer,
//      (3b2637ee-e580-11cf-a555-00c04fd8d4ac)
//

GUID    g_NtdsProviderGuid =
{
    0x3b2637ee,
    0xe580,
    0x11cf,
    {0xa5, 0x55, 0x00, 0xc0, 0x4f, 0xd8, 0xd4, 0xac}
};

WCHAR   g_NtdsProviderName[] = L"NTDS";
WCHAR   g_NtdsProviderPath[] = L"%SystemRoot%\\System32\\winrnr.dll";

PWSTR   g_pHostName = NULL;
PWSTR   g_pFullName = NULL;

DWORD   g_TlsIndex;

GUID    HostAddrByInetStringGuid    = SVCID_INET_HOSTADDRBYINETSTRING;
GUID    ServiceByNameGuid           = SVCID_INET_SERVICEBYNAME;
GUID    HostAddrByNameGuid          = SVCID_INET_HOSTADDRBYNAME;
GUID    HostNameGuid                = SVCID_HOSTNAME;


//
//  Heap
//

#define ALLOC_HEAP_ZERO( size )     Dns_AllocZero( size )
#define ALLOC_HEAP( size )          Dns_Alloc( size )
#define FREE_HEAP( p )              Dns_Free( p )



#ifdef DBG
//
//  Debug print utils
//

VOID
Print_DnArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN      PPRINT_CONTEXT  PrintContext,
    IN      PSTR            pszHeader,
    IN      PDN_ARRAY       pDnArray
    )
/*++

Routine Description:

    Print DN array

Arguments:

    pDnArray -- DN array to free

Return Value:

    None

--*/
{
    DWORD   iter;

    if ( !pszHeader )
    {
        pszHeader = "DN Array:";
    }
    if ( !pDnArray )
    {
        PrintRoutine(
            PrintContext,
            "%s NULL DN Array!\n",
            pszHeader );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        PrintContext,
        "%s\n"
        "\tPtr      = %p\n"
        "\tCount    = %d\n"
        "\tStrings:\n",
        pszHeader,
        pDnArray,
        pDnArray->Count );

    for ( iter = 0; iter < pDnArray->Count; iter++ )
    {
        PrintRoutine(
            PrintContext,
            "\t\tDN[%d] %S\n",
            iter,
            pDnArray->Strings[iter] );
    }
    DnsPrint_Unlock();
}



VOID
Print_RnrConnection(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN      PPRINT_CONTEXT  PrintContext,
    IN      PSTR            pszHeader,
    IN      PRNR_CONNECTION pRnrCon
    )
/*++

Routine Description:

    Print RnR connection info.

Arguments:

    pRnrCon -- Rnr connection blob

Return Value:

    None

--*/
{
    if ( !pszHeader )
    {
        pszHeader = "RnR Connection:";
    }
    if ( !pRnrCon )
    {
        PrintRoutine(
            PrintContext,
            "%s NULL RnR Connection!\n",
            pszHeader );
        return;
    }

    PrintRoutine(
        PrintContext,
        "%s\n"
        "\tPtr              = %p\n"
        "\tpLdap            = %p\n"
        "\tpLdap GC         = %p\n"
        "\tDomain DN        = %S\n"
        "\tWsockServicesDN  = %S\n",
        pszHeader,
        pRnrCon, 
        pRnrCon->pLdapServer,
        pRnrCon->pLdapGlobalCatalog,
        pRnrCon->DomainDN,
        pRnrCon->WinsockServicesDN
        );
}



VOID
Print_RnrLookup(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN      PPRINT_CONTEXT  PrintContext,
    IN      PSTR            pszHeader,
    IN      PRNR_LOOKUP     pRnr
    )
/*++

Routine Description:

    Print RnR lookup blob.

Arguments:

    pRnr -- Rnr lookup blob

Return Value:

    None

--*/
{
    CHAR    serviceGuidBuffer[ GUID_STRING_BUFFER_LENGTH ];
    CHAR    providerGuidBuffer[ GUID_STRING_BUFFER_LENGTH ];


    if ( !pszHeader )
    {
        pszHeader = "RnR Lookup:";
    }
    if ( !pRnr )
    {
        PrintRoutine(
            PrintContext,
            "%s NULL RnR Lookup!\n",
            pszHeader );
        return;
    }

    //  convert GUIDs to strings

    DnsStringPrint_Guid(
        serviceGuidBuffer,
        &pRnr->ServiceClassGuid
        );
    DnsStringPrint_Guid(
        providerGuidBuffer,
        &pRnr->ProviderGuid
        );

    DnsPrint_Lock();

    PrintRoutine(
        PrintContext,
        "%s\n"
        "\tPtr              = %p\n"
        "\tSig              = %08x\n"
        "\tCntrl Flags      = %08x\n"
        "\tService Name     = %S\n"
        "\tpConnection      = %p\n"
        "\tpDnArray         = %p\n"
        "\tDN Index         = %d\n"
        "\tClass GUID       = %s\n"
        "\tProvider GUID    = %s\n"
        "\tpContext         = %S\n"
        "\tVersion          = %p %08x %d\n"
        "\tpProtocols       = %p\n"
        "\tNum Protocols    = %d\n",
        pszHeader,
        pRnr, 
        pRnr->Signature,        
        pRnr->ControlFlags,     
        pRnr->pwsServiceName,   
        pRnr->pRnrConnection,   
        pRnr->pDnArray,         
        pRnr->CurrentDN,        
        serviceGuidBuffer,
        providerGuidBuffer,
        pRnr->pwsContext,       
        pRnr->pVersion,
        pRnr->WsaVersion.dwVersion,
        pRnr->WsaVersion.ecHow,
        pRnr->pafpProtocols,
        pRnr->NumberOfProtocols
        );

    if ( pRnr->pRnrConnection )
    {
        Print_RnrConnection(
            PrintRoutine,
            PrintContext,
            NULL,
            pRnr->pRnrConnection );
    }

    if ( pRnr->pDnArray )
    {
        Print_DnArray(
            PrintRoutine,
            PrintContext,
            NULL,
            pRnr->pDnArray );
    }

    if ( pRnr->pafpProtocols )
    {
        DnsPrint_AfProtocolsArray(
            PrintRoutine,
            PrintContext,
            "\tProtocol array:",
            pRnr->pafpProtocols,
            pRnr->NumberOfProtocols );
    }
    PrintRoutine(
        PrintContext,
        "\n" );

    DnsPrint_Unlock();
}
#endif



//
//  Basic utils
//

PDN_ARRAY
AllocDnArray(
    IN      DWORD           Count
    )
/*++

Routine Description:

    Create DN array

Arguments:

    Count -- string count to handle

Return Value:

    None

--*/
{
    PDN_ARRAY   parray;

    //
    //  free strings in array
    //

    parray = (PDN_ARRAY) ALLOC_HEAP_ZERO(
                                sizeof(*parray) +
                                Count*sizeof(PSTR) );
    if ( parray )
    {
        parray->Count = Count;
    }
    return  parray;
}


VOID
FreeDnArray(
    IN OUT  PDN_ARRAY       pDnArray
    )
/*++

Routine Description:

    Free DN array

Arguments:

    pDnArray -- DN array to free

Return Value:

    None

--*/
{
    DWORD   iter;

    if ( !pDnArray )
    {
        return;
    }

    //
    //  free strings in array
    //

    for ( iter = 0; iter < pDnArray->Count; iter++ )
    {
        PWSTR   pstr = pDnArray->Strings[iter];
        if ( pstr )
        {
            FREE_HEAP( pstr );
        }
    }
    FREE_HEAP( pDnArray );
}



RNR_STATUS
BuildDnArrayFromResults(
    IN OUT  PLDAP           pLdap,
    IN      PLDAPMessage    pLdapResults,
    OUT     PDWORD          pdwCount,       OPTIONAL
    OUT     PDN_ARRAY *     ppDnArray       OPTIONAL
    )
/*++

Routine Description:

    Build DN array from LDAP results

Arguments:

    pLdap   -- LDAP connection

    pLdapResults -- LDAP results from search

    pdwCount -- addr to receive count if getting count

    ppDnArray -- addr to receive ptr to DN array
        if not given, no DN array built

Return Value:

    NO_ERROR if successful.
    ErrorCode on memory allocation failure.

--*/
{
    DWORD           status;
    DWORD           count;
    PDN_ARRAY       pdnArray = NULL;
    LDAPMessage *   pnext;
    DWORD           iter;


    DNSDBG( TRACE, (
        "BuildDnArrayFromResults()\n"
        "\tpLdap            = %p\n"
        "\tpResults         = %p\n"
        "\tpCount OUT       = %p\n"
        "\tpDnArray OUT     = %p\n",
        pLdap,
        pLdapResults,
        pdwCount,
        ppDnArray ));

    //
    //  count search hits
    //

    count = ldap_count_entries(
                    pLdap,
                    pLdapResults );

    if ( count == 0  ||  !ppDnArray )
    {
        status = NO_ERROR;
        goto Done;
    }

    //
    //  build DN array from ldap results
    //      - note that allocated strings are IN dnarray
    // 

    pdnArray = AllocDnArray( count );
    if ( !pdnArray )
    {
        status = ERROR_NO_MEMORY;
        goto Done;
    }

    for ( pnext = ldap_first_entry( pLdap, pLdapResults ), iter=0;
          pnext != NULL;
          pnext = ldap_next_entry( pLdap, pnext ), iter++ )
    {
        PWSTR   pnextDn = ldap_get_dn( pLdap, pnext );
        PWSTR   pdn;

        pdn = Dns_CreateStringCopy_W( pnextDn );

        ldap_memfree( pnextDn );

        if ( !pdn )
        {
            FREE_HEAP( pdnArray );
            pdnArray = NULL;
            status = ERROR_NO_MEMORY;
            goto Done;
        }
        if ( iter >= count )
        {
            DNS_ASSERT( FALSE );
            break;
        }
        pdnArray->Strings[iter] = pdn;
    }
    
    status = NO_ERROR;

Done:

    
    if ( ppDnArray )
    {
        *ppDnArray = pdnArray;
    }
    if ( pdwCount )
    {
        *pdwCount = count;
    }

    IF_DNSDBG( TRACE )
    {
        DnsDbg_Lock();
        DNS_PRINT((
            "Leave BuildDnArrayFromResults() => %d\n"
            "\tcount = %d\n",
            status,
            count ));
        DnsDbg_DnArray(
            NULL,
            pdnArray );
        DnsDbg_Unlock();
    }
    return  status;
}



PWSTR
CreateFilterElement(
    IN      PBYTE           pBlob,
    IN      DWORD           BlobLength
    )
/*++

Routine Description:

    Create filter element for flat blob.

Arguments:

    pBlob -- ptr to blob

    BlobLength -- length

Return Value:

    Ptr to allocated filter element.
    NULL on error.

--*/
{
    PWSTR   pfilter;
    DWORD   size;

    DNSDBG( TRACE, (
        "CreateFilterElement( %p, %d )\n",
        pBlob,
        BlobLength ));

    //
    //  get size of filter string
    //
    //  DCR:  hard to believe the size should go *WCHAR
    //      seems like that would be taken care of
    //

    size = ldap_escape_filter_element(
                pBlob,
                BlobLength,
                NULL,       // no buffer
                0 );

    size *= sizeof(WCHAR);

    pfilter = ALLOC_HEAP_ZERO( size );
    if ( !pfilter )
    {
        SetLastError( ERROR_NO_MEMORY );
        return  NULL;
    }

    ldap_escape_filter_element(
            pBlob,
            BlobLength,
            pfilter,
            size );

    DNSDBG( TRACE, (
        "Leave CreateFilterElement() => %S\n",
        pfilter ));

    return  pfilter;
}



RNR_STATUS
SetError(
    IN      RNR_STATUS      dwError
    )
/*++

Routine Description:

    Wraps SetLastError() and SOCKET_ERROR return.

Arguments:

    dwError -- error code

Return Value:

    NO_ERROR if dwError==NO_ERROR
    SOCKET_ERROR on any other error.

--*/
{
    if ( dwError )
    {
        SetLastError( dwError );
        return( (DWORD) SOCKET_ERROR );
    }
    else
    {
        return( NO_ERROR );
    }
}



BOOL
IsNameADn(
    IN      PWSTR           szName,
    OUT     PWSTR *         ppwsRdn,
    OUT     PWSTR *         ppwsContext
    )
{
#define  NTDS_MAX_DN_LEN 1024
    DWORD       status = NO_ERROR;
    WCHAR       szNameBuf[ NTDS_MAX_DN_LEN ];
    PWSTR       szTemp;
    PWSTR       szComma = NULL;
    DWORD       i;
    BOOL        fQuoted = FALSE;

    DNSDBG( TRACE, (
        "IsNameADn( %S )\n",
        szName ));

    wcsncpy( szNameBuf, szName, NTDS_MAX_DN_LEN );
    szNameBuf[ NTDS_MAX_DN_LEN-1 ] = 0;

    szTemp = szNameBuf;

    for ( i = 0; i < wcslen( szName ); i++ )
    {
        if ( szTemp[i] == L',' )
        {
            if ( !fQuoted )
            {
                szComma = &szTemp[i];
                break;
            }
        }

        if ( szTemp[i] == L'\"' )
        {
#if 0
            //  this one is a classic ... saving for posterity

            if ( fQuoted )
                fQuoted = FALSE;
            else
                fQuoted = TRUE;
#endif
            fQuoted = !fQuoted;
        }
    }

    if ( i >= wcslen( szName ) )
    {
        return FALSE;
    }

    szComma[0] = 0;
    szComma++;

    if ( szComma[0] == L' ' )
        szComma++;

    if ( wcslen( szComma ) == 0 )
        return FALSE;

    *ppwsContext = (LPWSTR) ALLOC_HEAP_ZERO( ( wcslen( szComma ) + 1 ) *
                                              sizeof( WCHAR ) );

    if ( *ppwsContext == NULL )
    {
        return FALSE;
    }

    wcscpy( *ppwsContext, szComma );

    *ppwsRdn = (LPWSTR) ALLOC_HEAP_ZERO( ( wcslen( szNameBuf ) + 1 ) *
                                          sizeof( WCHAR ) );

    if ( *ppwsRdn == NULL )
    {
        (void) FREE_HEAP( *ppwsContext );
        *ppwsContext = NULL;

        return FALSE;
    }

    if ( szNameBuf[0] == L'C' || szNameBuf[0] == L'c' &&
         szNameBuf[1] == L'N' || szNameBuf[1] == L'n' &&
         szNameBuf[2] == L'=' )
    {
        wcscpy( *ppwsRdn, szNameBuf + 3 );
    }
    else
    {
        wcscpy( *ppwsRdn, szNameBuf );
    }

    return TRUE;
}



//
//  Recursion locking
//
//  Idea here is to keep LDAP calls from recursing back
//  into these functions through ConnectToDefaultDirectory
//  Simply set TLS pointer to one when do LDAP search and
//  test in ConnectToDefaultDirectory(), quiting if already
//  set.
//

BOOL
GetRecurseLock(
    IN      PSTR            pszFunctionName
    )
{
    if ( TlsSetValue( g_TlsIndex, (LPVOID) 1 ) == FALSE )
    {
        WINRNR_PRINT((
            "WINRNR!%s - TlsSetValue( %d, 1 ) failed!\n"
            "\terror code: 0%x\n",
            pszFunctionName,
            g_TlsIndex,
            GetLastError() ));

        return( FALSE );
    }
    return( TRUE );
}

BOOL
ReleaseRecurseLock(
    IN      PSTR            pszFunctionName
    )
{
    if ( TlsSetValue( g_TlsIndex, NULL ) == FALSE )
    {
        WINRNR_PRINT((
            "WINRNR!%s - TlsSetValue( %d, NULL ) failed!\n"
            "\terror code: 0%x\n",
            pszFunctionName,
            g_TlsIndex,
            GetLastError() ));

        return( FALSE );
    }
    return( TRUE );
}

BOOL
IsRecurseLocked(
    VOID
    )
{
    return  TlsGetValue( g_TlsIndex ) ? TRUE : FALSE;
}






RNR_STATUS
DoLdapSearch(
    IN      PSTR                pszFunction,
    IN      BOOL                fLocked,
    IN      PLDAP               pLdap,
    IN      PWSTR               pwsDN,
    IN      DWORD               Flag,
    IN      PWSTR               pwsFilter,
    IN      PWSTR *             Attributes,
    OUT     PLDAPMessage *      ppResults
    )
/*++

Routine Description:

    Do ldap search.

    Wrapper function to do ldap search with recurse locking
    and debug print.

Arguments:

    pszFunction -- function calling in

    fLocked -- already recurse locked

    LDAP search params:

    pLdap -- LDAP connection

    pwsDN -- DN to search at

    Flag -- search flag

    pwsFilter -- filter

    Attributes -- attribute array

    ppResults -- addr to recv ptr to result message
        caller must free

Return Value:

    NO_ERROR if successful.
    WSAEFAULT if buffer too small.
    ErrorCode on failure.

--*/
{
    RNR_STATUS  status;

    IF_DNSDBG( TRACE )
    {
        DnsDbg_Lock();
        DNSDBG( TRACE, (
            "DoLdapSearch()\n"
            "\tFunction         = %s\n"
            "\tLocked           = %d\n"
            "\tLDAP search params:\n"
            "\tpLdap            = %p\n"
            "\tDN               = %S\n"
            "\tFlags            = %08x\n"
            "\tpFilter          = %S\n"
            "\tppResults        = %p\n",
            pszFunction,
            fLocked,
            pLdap,
            pwsDN,
            Flag,
            pwsFilter,
            ppResults ));

        DnsDbg_StringArray(
            "  Search Attributes:",
            (PSTR *) Attributes,
            0,          // count unknown, array NULL terminated
            TRUE        // in unicode
            );
        DnsDbg_Unlock();
    }

    //
    //  search
    //

    if ( !fLocked &&
         !GetRecurseLock( pszFunction ) )
    {
        status = ERROR_LOCK_FAILED;
        goto Exit;
    }

    status = ldap_search_s(
                    pLdap,
                    pwsDN,
                    Flag,
                    pwsFilter,
                    Attributes,
                    0,
                    ppResults );

    if ( !fLocked &&
         !ReleaseRecurseLock( pszFunction ) )
    {
        status = ERROR_LOCK_FAILED;
        goto Exit;
    }

    if ( status != NO_ERROR  &&  !*ppResults )
    {
        WINRNR_PRINT((
            "WINRNR!%s -- ldap_search_s() failed 0%x\n",
            pszFunction,
            status ));
    
        DNSDBG( ANY, (
            "ERROR:  ldap_search_s() Failed! => %d\n"
            "\tIn function  %s\n"
            "\tDN           %S\n"
            "\tFlag         %08x\n"
            "\tFilter       %S\n",
            status,
            pszFunction,
            pwsDN,
            Flag,
            pwsFilter ));
    }

Exit:

    DNSDBG( TRACE, (
        "Leave DoLdapSearch() => %d\n",
        status ));

    return  status;
}



VOID
DisconnectFromLDAPDirectory(
    IN OUT  PRNR_CONNECTION *  ppRnrConnection
    )
/*++

Routine Description:

    Disconnect and cleanup RnR connection to directory.

Arguments:

    pCsAddr -- ptr to CSADDR buffer to write

    pBerval -- ptr to berval

    NumberOfProtocols -- number of protocols in protocol array

    pafpProtocols -- protocol array

Return Value:

    None

--*/
{
    DNSDBG( TRACE, (
        "DisconnectFromLDAPDirectory( %p (%p) )\n",
        ppRnrConnection,
        (ppRnrConnection) ? *ppRnrConnection : NULL ));

    if ( ppRnrConnection )
    {
        PRNR_CONNECTION prnr = *ppRnrConnection;

        if ( prnr )
        {
            ldap_unbind( prnr->pLdapServer );
            ldap_unbind( prnr->pLdapGlobalCatalog );
            FREE_HEAP( prnr->WinsockServicesDN );
            FREE_HEAP( prnr->DomainDN );
            FREE_HEAP( prnr );
            *ppRnrConnection = NULL;
        }
    }
}



RNR_STATUS
ConnectToDefaultLDAPDirectory(
    IN      BOOL                fNeedGlobalCatalog,
    OUT     PRNR_CONNECTION *   ppRnrConnection
    )
/*++

Routine Description:

    Connect to directory.

Arguments:

    fNeedGlobalCatalog -- TRUE if need to connect to GC

    ppRnrConnection -- addr to recv connection blob

Return Value:

    NO_ERROR if successful.
    ErrorCode on failure.

--*/
{
    RNR_STATUS      status = NO_ERROR;
    PRNR_CONNECTION prnr = NULL;
    PLDAP           pldap = NULL;
    PWSTR           pstr;
    DWORD           count = 0;
    BOOL            frecurseLocked = FALSE;
    LDAPMessage *   results = NULL;
    LDAPMessage *   object;
    PWSTR *         ppvalue = NULL;
    PWSTR           stringArray[4];
    PWSTR           attrs[3] = {    COMMON_NAME,
                                    DEFAULT_DOMAIN_DN,
                                    NULL };

    DNSDBG( TRACE, (
        "ConnectToDefaultLDAPDirectory()\n"
        "\tNeed global catalog  = %d\n"
        "\tPtr to get Rnr conn  = %p\n",
        fNeedGlobalCatalog,
        ppRnrConnection ));

    //
    //  allocate blob of connection info
    //

    if ( ppRnrConnection == NULL )
    {
        return( WSA_INVALID_PARAMETER );
    }

    prnr = (PRNR_CONNECTION) ALLOC_HEAP_ZERO( sizeof(RNR_CONNECTION) );
    *ppRnrConnection = prnr;
    if ( !prnr )
    {
        return( WSA_NOT_ENOUGH_MEMORY );
    }

    //
    //  being called recursively -- bail
    //

    if ( IsRecurseLocked() )
    {
        status = WSAEFAULT;
        goto Exit;
    }
    if ( !GetRecurseLock( "ConnectToDefaultLDAPDirectory" ) )
    {
        status = WSAEFAULT;
        goto Exit;
    }
    frecurseLocked = TRUE;

    //
    //  We need to keep the TLS value non-zero not just on the open but also
    //  across the bind and any other ldap calls for that matter. This is
    //  because the LDAP bind may do a reverse name lookup, in which case
    //  we'd come looping through here.
    //

    pldap = ldap_open( NULL, LDAP_PORT );
    prnr->pLdapServer = pldap;

    if ( fNeedGlobalCatalog )
    {
        prnr->pLdapGlobalCatalog = ldap_open( NULL, LDAP_GLOBAL_CATALOG );
    }
    if ( !pldap )
    {
        DNSDBG( TRACE, ( "Failed ldap_open() of default directory!\n" ));
        status = WSAEHOSTUNREACH;
        goto Exit;
    }

    //
    // If fNeedGlobalCatalog was TRUE and ldap_open failed against the
    // GC server, don't bother about returning with error. We can still
    // use the  pldap handle.
    //
    // End of comment.
    //

    status = ldap_bind_s(
                    pldap,
                    NULL,
                    NULL,
                    LDAP_AUTH_SSPI );
    if ( status )
    {
        DNSDBG( TRACE, (
            "Failed ldap_bind_s() => %d\n",
            status ));
        status = WSAENOTCONN;
        goto Exit;
    }

    //
    //  for the server that we are connected to, get the DN of the Domain
    //
    //  need some general error code -- not WSAEFAULT
    //

    status = DoLdapSearch(
                    "ConnectToDefaultDirectory",
                    TRUE,       // already locked
                    pldap,
                    NULL,
                    LDAP_SCOPE_BASE,
                    FILTER_OBJECT_CLASS_STAR,
                    attrs,
                    &results );

    frecurseLocked = FALSE;
    if ( !ReleaseRecurseLock( "ConnectToDefaultLDAPDirectory" ) )
    {
        status = ERROR_LOCK_FAILED;
        goto Exit;
    }
    if ( status && !results )
    {
        status = WSAEFAULT;
        goto Exit;
    }

    //
    //  count results
    //      - searched with flag LDAP_OBJECT_BASE should have one object
    //
    count = ldap_count_entries(
                    pldap,
                    results );
    if ( count == 0 )
    {
        DNSDBG( TRACE, (
            "No entries found in base search()\n" ));
        status = WSATYPE_NOT_FOUND;
        goto Exit;
    }
    DNS_ASSERT( count == 1 );

    //
    //  get object from results
    //

    object = ldap_first_entry(
                    pldap,
                    results );
    if ( !object )
    {
        DNSDBG( TRACE, ( "Failed ldap_first_entry()\n" ));
        status = WSANO_DATA;
        goto Exit;
    }

    //
    //  read the defaultDomainDN base attribute
    //

    ppvalue = ldap_get_values(
                    pldap,
                    object,
                    DEFAULT_DOMAIN_DN );
    if ( !ppvalue )
    {
        DNSDBG( TRACE, ( "Failed ldap_get_values()\n" ));
        status = WSANO_DATA;
        goto Exit;
    }

    //
    //  create DNs
    //      - winsock services \ default domain
    //      - domain
    //

    stringArray[0] = WINSOCK_SERVICES;
    stringArray[1] = ppvalue[0];
    stringArray[2] = NULL;

    pstr = Dns_CreateConcatenatedString_W( stringArray );
    if ( !pstr )
    {
        status = WSA_NOT_ENOUGH_MEMORY;
        goto Exit;
    }
    prnr->WinsockServicesDN = pstr;


    pstr = Dns_CreateStringCopy_W( ppvalue[0] );
    if ( !pstr )
    {
        status = WSA_NOT_ENOUGH_MEMORY;
        goto Exit;
    }
    prnr->DomainDN = pstr;
    
    status = NO_ERROR;


Exit:

    if ( frecurseLocked )
    {
        ReleaseRecurseLock( "ConnectToDefaultLDAPDirectory" );
    }

    ldap_value_free( ppvalue );
    ldap_msgfree( results );

    if ( status != NO_ERROR )
    {
        DisconnectFromLDAPDirectory( ppRnrConnection );
        DNS_ASSERT( *ppRnrConnection == NULL );
    }

    DNSDBG( TRACE, (
        "Leaving ConnectToDefaultLDAPDirectory() => %d\n",
        status ));

    IF_DNSDBG( TRACE )
    {
        if ( status == NO_ERROR )
        {
            DnsDbg_RnrConnection(
                "New RnR connection:",
                *ppRnrConnection );
        }
    }
    return( status );
}



VOID
FreeRnrLookup(
    IN OUT  PRNR_LOOKUP     pRnr
    )
/*++

Routine Description:

    Free RnR lookup blob.

Arguments:

    pRnr -- ptr to Rnr lookup blob

Return Value:

    None

--*/
{
    DNSDBG( TRACE, (
        "FreeRnrLookup( %p )\n",
        pRnr ));

    if ( !pRnr )
    {
        return;
    }

    //  disconnect from directory

    if ( pRnr->pRnrConnection )
    {
        DisconnectFromLDAPDirectory( &pRnr->pRnrConnection );
    }

    //  free subfields

    FreeDnArray( pRnr->pDnArray );
    Dns_Free( pRnr->pwsServiceName );
    Dns_Free( pRnr->pwsContext );
    Dns_Free( pRnr->pafpProtocols );

    //  specifically invalidate sig to help catch
    //      multiple frees

    pRnr->Signature = RNR_SIGNATURE_FREE;

    FREE_HEAP( pRnr );
}



//
//  CSADDR read\write routines
//

RNR_STATUS
ModifyAddressInServiceInstance(
    IN      PRNR_CONNECTION pRnrConnection,
    IN      PWSTR           pwsDn,
    IN      PCSADDR_INFO    pCsAddr,
    IN      BOOL            fAdd
    )
/*++

Routine Description:

    Modify address (CSADDR) in service instance.

Arguments:

    pRnrConnection -- RnR connection

    pwsDn -- DN to make mod at

    pCsAddr -- CSADDR for mode

    fAdd -- TRUE for add, FALSE for delete

Return Value:

    NO_ERROR if successful.
    ErrorCode on failure.

--*/
{
    RNR_STATUS      status = NO_ERROR;
    LDAPMod *       modPtrArray[2];
    LDAPMod         mod;
    PLDAP_BERVAL    modBValues[2];
    LDAP_BERVAL     berval;

    DWORD           lenBerval;
    DWORD           lenLocal;
    DWORD           lenRemote;
    DWORD           offset;
    DWORD           op;
    PCSADDR_BERVAL  pcsaddrBerval;


    DNSDBG( TRACE, (
        "ModifyAddressInServiceInstance()\n"
        "\tpRnrCon          = %p\n"
        "\tpwsDN            = %S\n"
        "\tpCsAddr          = %p\n"
        "\tfAdd             = %d\n",
        pRnrConnection,
        pwsDn,
        pCsAddr,
        fAdd ));

    //
    //  allocate CSADDR_BERVAL
    //      - can not use CSADDR as contains pointers and will break in 64bit
    //      - CSADDR_BERVAL maps to 32-bit CSADDR size
    //

    lenLocal    = pCsAddr->LocalAddr.iSockaddrLength;
    lenRemote   = pCsAddr->RemoteAddr.iSockaddrLength;
    lenBerval   = sizeof(CSADDR_BERVAL) + lenLocal + lenRemote;

    pcsaddrBerval = (PCSADDR_BERVAL) ALLOC_HEAP_ZERO( lenBerval );
    if ( !pcsaddrBerval )
    {
        status = ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  fill in CSADDR berval with CSADDR fields -- zero pointers
    //

    pcsaddrBerval->LocalZero    = 0;
    pcsaddrBerval->LocalLength  = lenLocal;
    pcsaddrBerval->RemoteZero   = 0;
    pcsaddrBerval->RemoteLength = lenRemote;
    pcsaddrBerval->iSocketType  = pCsAddr->iSocketType;                           
    pcsaddrBerval->iProtocol    = pCsAddr->iProtocol;

    //
    //  copy sockaddrs
    //      - store offsets of sockaddrs from berval start
    //      (this allows any sockaddr
    //

    if ( lenLocal )
    {
        offset = sizeof(CSADDR_BERVAL);

        RtlCopyMemory(
            (PBYTE)pcsaddrBerval + offset,
            pCsAddr->LocalAddr.lpSockaddr,
            lenLocal );
    }
    if ( lenRemote )
    {
        offset = sizeof(CSADDR_BERVAL) + lenLocal;

        RtlCopyMemory(
            (PBYTE)pcsaddrBerval + offset,
            pCsAddr->RemoteAddr.lpSockaddr,
            lenRemote );
    }

    //
    //  WINSOCK_ADDRESSES attribute
    //      - CSADDR berval
    //

    if ( fAdd )
    {
        op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
    }
    else
    {
        op = LDAP_MOD_DELETE | LDAP_MOD_BVALUES;
    }

    mod.mod_op          = op;
    mod.mod_type        = WINSOCK_ADDRESSES;
    mod.mod_bvalues     = modBValues;
    modBValues[0]       = & berval;
    modBValues[1]       = NULL;
    berval.bv_len       = lenBerval;
    berval.bv_val       = (PBYTE) pcsaddrBerval;

    modPtrArray[0] = &mod;
    modPtrArray[1] = NULL;

    //
    //  do modify
    //

    if ( !GetRecurseLock( "ModifyAddressInServiceInstance" ) )
    {
        status = WSAEFAULT;
        goto Done;
    }
    status = ldap_modify_s(
                pRnrConnection->pLdapServer,
                pwsDn,
                modPtrArray );

    if ( !ReleaseRecurseLock( "ModifyAddressInServiceInstance" ) )
    {
        status = WSAEFAULT;
        goto Done;
    }

    //
    //  modify failed?
    //      - add treats already-exists as success
    //      - deleter treats doesn't-exist as success
    //

    if ( status != NO_ERROR )
    {
        if ( fAdd && status == LDAP_ATTRIBUTE_OR_VALUE_EXISTS )
        {
            DNSDBG( TRACE, (
                "AlreadyExists error on add modify for %S\n"
                "\ttreating as success\n",
                pwsDn ));
            status = NO_ERROR;
        }
        else if ( !fAdd && status == LDAP_NO_SUCH_ATTRIBUTE )
        {
            DNSDBG( TRACE, (
                "NoSuchAttribute error on remove modify for %S\n"
                "\ttreating as success\n",
                pwsDn ));
            status = NO_ERROR;
        }
        else
        {
            WINRNR_PRINT((
                "WINRNR!ModifyAddressInServiceInstance -\n"
                "ldap_modify_s() failed with error code: 0%x\n",
                status ));
            DNSDBG( TRACE, (
                "ERROR:  %d on CSADDR ldap_modify_s() for %S\n"
                "\tfAdd = %d\n",
                status,
                pwsDn,
                fAdd ));
            status = WSAEFAULT;
        }
    }


Done:

    FREE_HEAP( pcsaddrBerval );

    DNSDBG( TRACE, (
        "Leave ModifyAddressInServiceInstance() => %d\n",
        status ));

    return  status;
}



BOOL
ExtractCsaddrFromBerval(
    OUT     PCSADDR_INFO    pCsAddr,
    IN      PLDAP_BERVAL    pBerval,
    IN      DWORD           NumberOfProtocols,
    IN      PAFPROTOCOLS    pafpProtocols
    )
/*++

Routine Description:

    Extract CSADDR from berval, and validate it matches
    desired protocol.

Arguments:

    pCsAddr -- ptr to CSADDR buffer to write

    pBerval -- ptr to berval

    NumberOfProtocols -- number of protocols in protocol array

    pafpProtocols -- protocol array

Return Value:

    TRUE if valid CSADDR of desired protocol.
    FALSE otherwise.
                                          
--*/
{
    PCSADDR_BERVAL  pcsaBval;
    PCHAR           pend;
    DWORD           iter;
    BOOL            retval = FALSE;
    INT             lenLocal;
    INT             lenRemote;
    PSOCKADDR       psaLocal;
    PSOCKADDR       psaRemote;

    DNSDBG( TRACE, (
        "ExtractCsaddrFromBerval()\n"
        "\tpCsaddr OUT      = %p\n"
        "\tpBerval          = %p\n"
        "\tProto array      = %p\n",
        pCsAddr,
        pBerval,
        pafpProtocols ));

    IF_DNSDBG( TRACE )
    {
        DnsDbg_AfProtocolsArray(
            "\tProtocol array:",
            pafpProtocols,
            NumberOfProtocols );
    }

    //
    //  unpack
    //      - verify csaddr has both sockaddrs within berval
    //      - unpack into real CSADDR, note we set the pointers
    //      but do NOT copy the sockaddrs
    //
    //  note:  we can't directly use the CSADDR_BERVAL because it is
    //  not a CSADDR in 64-bit
    //
    //  note:  perhaps should get the family fields out for test below
    //      with UNALIGNED copy;  but as long as future sockaddrs are
    //      fixed, then their size will always be WORD aligned;  since
    //      we unpack as vanilla SOCKADDR which only assumes WORD
    //      alignment we're ok;  just need to make sure don't write
    //      odd byte count
    //

    pcsaBval = (PCSADDR_BERVAL) pBerval->bv_val;
    pend     = (PBYTE)pcsaBval + pBerval->bv_len;

    //  unpack local sockaddr info

    psaLocal = NULL;
    lenLocal = pcsaBval->LocalLength;

    if ( lenLocal )
    {
        psaLocal = (PSOCKADDR) (pcsaBval + 1);
        if ( lenLocal < 0  ||
             (PBYTE)psaLocal + (DWORD)lenLocal > pend )
        {
            DNS_ASSERT( FALSE );
            goto Exit;
        }
    }

    //  unpack remote sockaddr info

    psaRemote = NULL;
    lenRemote = pcsaBval->RemoteLength;

    if ( lenRemote )
    {
        psaRemote = (PSOCKADDR) ((PBYTE)(pcsaBval + 1) + lenLocal);
        if ( lenRemote < 0  ||
             (PBYTE)psaRemote + (DWORD)lenRemote > pend )
        {
            DNS_ASSERT( FALSE );
            goto Exit;
        }
    }

    //  fill in CSADDR fields

    pCsAddr->LocalAddr.lpSockaddr       = psaLocal;
    pCsAddr->LocalAddr.iSockaddrLength  = lenLocal;
    pCsAddr->RemoteAddr.lpSockaddr      = psaRemote;
    pCsAddr->RemoteAddr.iSockaddrLength = lenRemote;
    pCsAddr->iSocketType                = pcsaBval->iSocketType;
    pCsAddr->iProtocol                  = pcsaBval->iProtocol;      

    //
    //  if given protocols, sockaddr must match
    //

    retval = TRUE;

    if ( pafpProtocols )
    {
        retval = FALSE;

        for ( iter = 0; iter < NumberOfProtocols; iter++ )
        {
            INT proto   = pafpProtocols[iter].iProtocol;
            INT family  = pafpProtocols[iter].iAddressFamily;
    
            if ( proto == PF_UNSPEC ||
                 proto == pCsAddr->iProtocol )
            {
                if ( family == AF_UNSPEC            ||
                     family == psaLocal->sa_family  ||
                     family == psaRemote->sa_family )
                {
                    retval = TRUE;
                    break;
                }
            }
        }
    }

Exit:

    DNSDBG( TRACE, ( "Leave ExtractCsaddrFromBerval() => found = %d\n", retval ));
    return retval;
}



//
//  Add routines
//

RNR_STATUS
AddServiceClass(
    IN      PRNR_CONNECTION    pRnrConnection,
    IN      PGUID              pServiceClassId,
    IN      PWSTR              pwsClassName,
    OUT     PDN_ARRAY *        ppDnArray            OPTIONAL
    )
{
    RNR_STATUS      status = NO_ERROR;
    PWSTR           pwsDn;
    PWSTR           stringArray[6];
    PDN_ARRAY       pdnArray = NULL;

    //  mod data
    //      - need up to four mods
    //      - three string
    //      - one berval

    PLDAPMod        modPtrArray[5];
    LDAPMod         modArray[4];
    PWSTR           modValues1[2];
    PWSTR           modValues2[2];
    PWSTR           modValues3[2];
    PLDAP_BERVAL    modBvalues1[2];
    LDAP_BERVAL     berval1;
    PLDAPMod        pmod;
    DWORD           index;


    DNSDBG( TRACE, (
        "AddServiceClass()\n"
        "\tpRnr         = %p\n"
        "\tpClassGuid   = %p\n"
        "\tClassName    = %S\n",
        pRnrConnection,
        pServiceClassId,
        pwsClassName
        ));

    //
    //  build DN for the ServiceClass object to be created
    //

    index = 0;
    stringArray[index++] = FILTER_CN_EQUALS;
    stringArray[index++] = pwsClassName;
    stringArray[index++] = L",";
    stringArray[index++] = pRnrConnection->WinsockServicesDN;
    stringArray[index++] = NULL;

    pwsDn = Dns_CreateConcatenatedString_W( stringArray );
    if ( !pwsDn )
    {
        status = ERROR_NO_MEMORY;
        goto Exit;
    }

    //
    //  build attributes for new service class
    //      - CN
    //      - ServiceClassName
    //      - ObjectClass
    //      - ServiceClassId (GUID)
    //

    pmod = modArray;

    pmod->mod_op        = LDAP_MOD_ADD;
    pmod->mod_type      = COMMON_NAME;
    pmod->mod_values    = modValues1;
    modValues1[0]       = pwsClassName;
    modValues1[1]       = NULL;
    modPtrArray[0]      = pmod++;

    pmod->mod_op        = LDAP_MOD_ADD;
    pmod->mod_type      = SERVICE_CLASS_NAME;
    pmod->mod_values    = modValues2;
    modValues2[0]       = pwsClassName;
    modValues2[1]       = NULL;
    modPtrArray[1]      = pmod++;

    pmod->mod_op        = LDAP_MOD_ADD;
    pmod->mod_type      = OBJECT_CLASS;
    pmod->mod_values    = modValues3;
    modValues3[0]       = SERVICE_CLASS;
    modValues3[1]       = NULL;
    modPtrArray[2]      = pmod++;

    pmod->mod_op        = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
    pmod->mod_type      = SERVICE_CLASS_ID;
    pmod->mod_bvalues   = modBvalues1;
    modBvalues1[0]      = & berval1;
    modBvalues1[1]      = NULL;
    berval1.bv_len      = sizeof(GUID);
    berval1.bv_val      = (LPBYTE) pServiceClassId;
    modPtrArray[3]      = pmod++;

    modPtrArray[4]      = NULL;


    //
    //  add the service class
    //

    if ( !GetRecurseLock("AddServiceClass") )
    {
        status = WSAEFAULT;
        goto Exit;
    }

    status = ldap_add_s(
                    pRnrConnection->pLdapServer,
                    pwsDn,
                    modPtrArray );

    if ( !ReleaseRecurseLock("AddServiceClass") )
    {
        status = WSAEFAULT;
        goto Exit;
    }
    if ( status != NO_ERROR )
    {
        WINRNR_PRINT((
            "WINRNR!AddServiceClass -\n"
            "ldap_add_s() failed with error code: 0%x\n", status ));
        status = WSAEFAULT;
        goto Exit;
    }

    //
    //  create DN array for added service class
    //
    //  DCR:  do we need DN or just service
    //

    if ( ppDnArray )
    {
        pdnArray = AllocDnArray( 1 );
        if ( !pdnArray )
        {
            status = ERROR_NO_MEMORY;
            goto Exit;
        }
        pdnArray->Strings[0] = pwsDn;
        *ppDnArray = pdnArray;
        pwsDn = NULL;
    }

Exit:

    FREE_HEAP( pwsDn );

    DNSDBG( TRACE, (
        "Leaving AddServiceClass() => %d\n",
        status ));

    return( status );
}



RNR_STATUS
AddClassInfoToServiceClass(
    IN      PRNR_CONNECTION pRnrConnection,
    IN      PWSTR           pwsServiceClassDN,
    IN      PWSANSCLASSINFO pNSClassInfo
    )
/*++

Routine Description:

    Add class info to a service class object.

    This is helper routine for AddServiceInstance().

Arguments:

    pRnrConnection -- Rnr blob

    pwsServiceClassDN -- DN for service class being added

    pNSClassInfo -- class info to add

Return Value:

    NO_ERROR if successful.
    ErrorCode on failure.

--*/
{
    RNR_STATUS          status = NO_ERROR;
    LDAPMod *           modPtrArray[2];
    LDAPMod             mod;
    PLDAP_BERVAL        modBValues[2];
    LDAP_BERVAL         berval;
    DWORD               blobSize;
    DWORD               nameLen;
    PCLASSINFO_BERVAL   pblob;


    DNSDBG( TRACE, (
        "AddClassInfoToServiceClass()\n"
        "\tpRnr             = %p\n"
        "\tServiceClassDN   = %S\n"
        "\tpClassInfo       = %p\n",
        pRnrConnection,
        pwsServiceClassDN,
        pNSClassInfo ));

    //
    //  build ClassInfo as berval
    //
    //      - not directly using WSANSCLASSINFO as it contains
    //          pointers making length vary 32\64-bit
    //      - to handle this, offsets to name and value fields are
    //          encoded in DWORD fields where ptrs would be in WSANSCLASSINFO
    //
    //      - name immediately follows CLASSINFO
    //      - value follows name (rounded to DWORD)
    //

    nameLen  = (wcslen( pNSClassInfo->lpszName ) + 1) * sizeof(WCHAR);
    nameLen  = ROUND_UP_COUNT( nameLen, ALIGN_DWORD );

    blobSize = sizeof(CLASSINFO_BERVAL)
                    + nameLen
                    + pNSClassInfo->dwValueSize;

    pblob = (PCLASSINFO_BERVAL) ALLOC_HEAP_ZERO( blobSize );
    if ( !pblob )
    {
        status = ERROR_NO_MEMORY;
        goto Exit;
    }

    pblob->dwNameSpace  = pNSClassInfo->dwNameSpace;
    pblob->dwValueType  = pNSClassInfo->dwValueType;
    pblob->dwValueSize  = pNSClassInfo->dwValueSize;
    pblob->NameOffset   = sizeof(CLASSINFO_BERVAL);
    pblob->ValueOffset  = sizeof(CLASSINFO_BERVAL) + nameLen;

    wcscpy(
        (PWSTR) ((PBYTE)pblob + pblob->NameOffset),
        (PWSTR) pNSClassInfo->lpszName );

    RtlCopyMemory(
        (PBYTE)pblob + pblob->ValueOffset,
        pNSClassInfo->lpValue,
        pNSClassInfo->dwValueSize );

    //
    //  ldap mod to add service class info
    //

    mod.mod_op      = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
    mod.mod_type    = SERVICE_CLASS_INFO;
    mod.mod_bvalues = modBValues;
    modBValues[0]   = & berval;
    modBValues[1]   = NULL;
    berval.bv_len   = blobSize;
    berval.bv_val   = (PCHAR) pblob;

    modPtrArray[0]  = &mod;
    modPtrArray[1]  = NULL;

    //
    //  add the class info to the service class
    //

    if ( !GetRecurseLock("AddClassInfoToServiceClass") )
    {
        status = WSAEFAULT;
        goto Exit;
    }

    status = ldap_modify_s(
                    pRnrConnection->pLdapServer,
                    pwsServiceClassDN,
                    modPtrArray );

    if ( !ReleaseRecurseLock("AddClassInfoToServiceClass") )
    {
        status = WSAEFAULT;
        goto Exit;
    }

    //
    //  modify failed?
    //      - treat already exits as success
    //

    if ( status != NO_ERROR )
    {
        if ( status == LDAP_ATTRIBUTE_OR_VALUE_EXISTS )
        {
            status = NO_ERROR;
            goto Exit;
        }
        WINRNR_PRINT((
            "WINRNR!AddClassInfoToServiceClass -\n"
            "ldap_modify_s() failed with error code: 0%x\n",
            status ));
        status = WSAEFAULT;
    }

Exit:

    FREE_HEAP( pblob );

    DNSDBG( TRACE, (
        "Leave AddClassInfoToServiceClass() => %d\n",
        status ));

    return( status );
}



RNR_STATUS
AddServiceInstance(
    IN      PRNR_CONNECTION pRnrConnection,
    IN      PWSTR           pwsServiceName,
    IN      PGUID           pServiceClassId,
    IN      PWSAVERSION     pVersion,           OPTIONAL
    IN      PWSTR           pwsComment,         OPTIONAL
    OUT     PDN_ARRAY *     ppDnArray
    )
/*++

Routine Description:

    Add a service to the directory.

Arguments:

    pRnrConnection -- Rnr blob

    pwsServiceName -- name of service being added

    pServiceClassId -- class GUID

    pVersion -- version data

    pwsComment -- comment data

    //
    //  DCR:  should we just pass back name?
    //

    ppDnArray -- addr to receive DN array

Return Value:

    NO_ERROR if successful.
    ErrorCode on failure.

--*/
{
    RNR_STATUS      status = NO_ERROR;

    //  mod data
    //      - need up to six mods
    //      - four string
    //      - two berval

    LDAPMod *       modPtrArray[7];
    LDAPMod         modArray[6];
    PWSTR           modValues1[2];
    PWSTR           modValues2[2];
    PWSTR           modValues3[2];
    PWSTR           modValues4[2];
    PLDAP_BERVAL    modBvalues1[2];
    PLDAP_BERVAL    modBvalues2[2];
    LDAP_BERVAL     berval1;
    LDAP_BERVAL     berval2;

    PLDAPMod        pmod;
    DWORD           modIndex;
    BOOL            fuseDN;
    PWSTR           pwsRdn = NULL;
    PWSTR           psearchContextAllocated = NULL;
    PWSTR           pcontextDN = NULL;
    DWORD           contextLen;
    PWSTR           pnameService = NULL;
    PWSTR           pwsDN = NULL;
    PDN_ARRAY       pdnArray = NULL;
    PWSTR           stringArray[6];
    DWORD           index;


    DNSDBG( TRACE, (
        "AddServiceInstance()\n"
        "\tpRnrCon      = %p\n"
        "\tServiceName  = %S\n"
        "\tClass GUID   = %p\n"
        "\tpVersion     = %p\n"
        "\tComment      = %S\n"
        "\tppArray OUT  = %p\n",
        pRnrConnection,
        pwsServiceName,
        pServiceClassId,
        pVersion,
        pwsComment,
        ppDnArray ));

    //
    //  determine service instance name
    //

    fuseDN = IsNameADn(
                    pwsServiceName,
                    & pwsRdn,
                    & psearchContextAllocated
                    );
    if ( fuseDN )
    {
        pnameService = pwsRdn;
    }
    else
    {
        pnameService = pwsServiceName;
    }

    //
    //  build up an object DN for the ServiceClass object to be created.
    //      - if no context found from passed in name, append
    //      WinsockServices container

    pcontextDN = psearchContextAllocated;
    if ( !pcontextDN )
    {
        pcontextDN = pRnrConnection->WinsockServicesDN;
    }

    index = 0;
    stringArray[index++] = FILTER_CN_EQUALS;
    stringArray[index++] = pnameService;
    stringArray[index++] = L",";                        
    stringArray[index++] = pcontextDN;                  
    stringArray[index++] = NULL;
    
    pwsDN = Dns_CreateConcatenatedString_W( stringArray );
    if ( !pwsDN )
    {
        status = ERROR_NO_MEMORY;
        goto Exit;
    }

    //
    //  fill out attribute list to define new ServiceClass object
    //      - need to have CN, ObjectClass, and ServiceClassId
    //

    pmod = modArray;

    pmod->mod_op        = LDAP_MOD_ADD;
    pmod->mod_type      = COMMON_NAME;
    pmod->mod_values    = modValues1;
    modValues1[0]       = pnameService;
    modValues1[1]       = NULL;
    modPtrArray[0]      = pmod++;

    pmod->mod_op        = LDAP_MOD_ADD;
    pmod->mod_type      = SERVICE_INSTANCE_NAME;
    pmod->mod_values    = modValues2;
    modValues2[0]       = pnameService;
    modValues2[1]       = NULL;
    modPtrArray[1]      = pmod++;

    pmod->mod_op        = LDAP_MOD_ADD;
    pmod->mod_type      = OBJECT_CLASS;
    pmod->mod_values    = modValues3;
    modValues3[0]       = SERVICE_INSTANCE;
    modValues3[1]       = NULL;
    modPtrArray[2]      = pmod++;

    pmod->mod_op        = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
    pmod->mod_type      = SERVICE_CLASS_ID;
    pmod->mod_bvalues   = modBvalues1;
    modBvalues1[0]      = & berval1;
    modBvalues1[1]      = NULL;
    berval1.bv_len      = sizeof(GUID);
    berval1.bv_val      = (LPBYTE) pServiceClassId;
    modPtrArray[3]      = pmod++;

    //
    //  write optional attributes
    //

    modIndex = 4;

    if ( pVersion )
    {
        pmod->mod_op        = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
        pmod->mod_type      = SERVICE_VERSION;
        pmod->mod_bvalues   = modBvalues2;
        modBvalues2[0]      = & berval2;
        modBvalues2[1]      = NULL;
        berval2.bv_len      = sizeof(WSAVERSION);
        berval2.bv_val      = (PBYTE) pVersion;

        modPtrArray[ modIndex++ ] = pmod++;
    }

    if ( pwsComment )
    {
        pmod->mod_op        = LDAP_MOD_ADD;
        pmod->mod_type      = SERVICE_COMMENT;
        pmod->mod_values    = modValues4;
        modValues4[0]       = pwsComment;
        modValues4[1]       = NULL;

        modPtrArray[ modIndex++ ] = pmod++;
    }

    modPtrArray[ modIndex ] = NULL;

    //
    // Set thread table to (1) to prevent possible recursion in ldap_ call.
    //

    if ( !GetRecurseLock( "AddServiceInstance" ) )
    {
        status = WSAEFAULT;
        goto Exit;
    }

    status = ldap_add_s(
                    pRnrConnection->pLdapServer,
                    pwsDN,
                    modPtrArray );

    if ( status == LDAP_ALREADY_EXISTS )
    {
        status = ldap_modify_s(
                        pRnrConnection->pLdapServer,
                        pwsDN,
                        modPtrArray );
    }

    if ( !ReleaseRecurseLock( "AddServiceInstance" ) )
    {
        status = WSAEFAULT;
        goto Exit;
    }

    if ( status != NO_ERROR )
    {
        DNSDBG( ANY, (
            "AddServiceInstance - ldap_modify\\add failed %d (%0x)\n",
            status, status ));
        status = WSAEFAULT;
        goto Exit;
    }

    //  create out DN array -- if requested

    pdnArray = AllocDnArray( 1 );
    if ( !pdnArray )
    {
        status = ERROR_NO_MEMORY;
        goto Exit;
    }
    pdnArray->Strings[0] = pwsDN;


Exit:

    *ppDnArray = pdnArray;

    FREE_HEAP( pwsRdn );
    FREE_HEAP( psearchContextAllocated );

    if ( status != NO_ERROR )
    {
        FREE_HEAP( pwsDN );
        DNS_ASSERT( pdnArray == NULL );
    }

    DNSDBG( TRACE, ( "Leave AddServiceInstance()\n" ));
    return  status;
}



RNR_STATUS
GetAddressCountFromServiceInstance(
    IN      PRNR_CONNECTION pRnrConnection,
    IN      PWSTR           pwsDN,
    OUT     PDWORD          pdwAddressCount
    )
{
    RNR_STATUS      status = NO_ERROR;
    PLDAP           pldap = pRnrConnection->pLdapServer;
    LDAPMessage *   results = NULL;
    DWORD           count;
    DWORD           countAddrs = 0;
    LDAPMessage *   object;
    PLDAP_BERVAL *  ppbval = NULL;
    PWSTR           attrs[3] = {    SERVICE_CLASS_NAME,
                                    WINSOCK_ADDRESSES,
                                    NULL };

    DNSDBG( TRACE, (
        "GetAddressCountFromServiceInstance()\n"
        "\tpRnrCon  = %p\n"
        "\tDN       = %S\n",
        pRnrConnection,
        pwsDN ));

    //
    //  search
    //

    status = DoLdapSearch(
                    "GetAddressCountFromServiceInstance",
                    FALSE,
                    pldap,
                    pwsDN,
                    LDAP_SCOPE_BASE,
                    FILTER_OBJECT_CLASS_SERVICE_INSTANCE,
                    attrs,
                    &results );

    if ( status && !results )
    {
        // ldap_search_s was not successful, return known error code.
        status = WSATYPE_NOT_FOUND;
        goto Exit;
    }

    //
    //  search completed successfully -- count results
    //

    count = ldap_count_entries( pldap, results );
    if ( count == 0 )
    {
        WINRNR_PRINT((
            "WINRNR!GetAddressCountFromServiceInstance -\n"
            "ldap_count_entries() failed\n" ));
        status = WSATYPE_NOT_FOUND;
        goto Exit;
    }

    //
    // We performed a search with flag LDAP_OBJECT_BASE, we should have
    // only 1 entry returned for count.
    //
    // ASSERT( count == 1 );

    //
    // Parse the results.
    //

    object = ldap_first_entry( pldap, results );
    if ( !object )
    {
        WINRNR_PRINT(( "WINRNR!GetAddressCountFromServiceInstance -\n" ));
        WINRNR_PRINT(( "ldap_first_entry() failed\n" ));
        status = WSANO_DATA;
        goto Exit;
    }

    //
    //  Read the WinsockAddresses (if any) and get the count value.
    //  Remember these are BER values (Octet strings).
    //

    ppbval = ldap_get_values_len(
                    pldap,
                    object,
                    WINSOCK_ADDRESSES );
    if ( !ppbval )
    {
        // Attribute not present, return address count of zero.

        DNSDBG( ANY, (
            "ERROR:  GetAddressCountFromServiceInstance()\n"
            "\tldap_get_values_len() failed\n" ));
        status = NO_ERROR;
        goto Exit;
    }

    countAddrs = ldap_count_values_len( ppbval );
    ldap_value_free_len( ppbval );
    status = NO_ERROR;

Exit:

    ldap_msgfree( results );

    //  count out param

    *pdwAddressCount = countAddrs;

    return( status );
}



RNR_STATUS
FindServiceClass(
    IN      PRNR_CONNECTION    pRnrConnection,
    IN      PWSTR              pwsServiceClassName, OPTIONAL
    IN      PGUID              pServiceClassId,
    OUT     PDWORD             pdwDnArrayCount,     OPTIONAL
    OUT     PDN_ARRAY *        ppDnArray            OPTIONAL
    )
/*++

Routine Description:

    Find service class in directory.

Arguments:

    pRnrConnection -- RnR connection

    pwsServiceClassName -- service class name

    pServiceClassId -- class GUID

    pdwArrayCount -- addr to receive count

    ppDnArray -- addr to recv DN array

Return Value:

    NO_ERROR if successful.
    ErrorCode on failure.

--*/
{
    RNR_STATUS      status = NO_ERROR;
    PLDAP           pldap = pRnrConnection->pLdapServer;
    PWSTR           pclassFilter = NULL;
    PWSTR           pfinalStr;
    PWSTR           pfilter = NULL;
    LDAPMessage *   presults = NULL;
    PDN_ARRAY       pdnArray = NULL;
    DWORD           count;
    LDAPMessage *   pnext;
    DWORD           iter = 0;
    DWORD           index;
    PWSTR           stringArray[12];
    PWSTR           searchAttributes[2] = { COMMON_NAME, NULL };


    DNSDBG( TRACE, (
        "FindServiceClass()\n"
        "\tpRnrCon          = %p\n"
        "\tClass Name       = %S\n",
        pRnrConnection,
        pwsServiceClassName 
        ));

    //
    //  convert the GUID to a string for the search filter
    //

    pclassFilter = CreateFilterElement(
                        (PCHAR) pServiceClassId,
                        sizeof(GUID) );
    if ( !pclassFilter )
    {
        return( ERROR_NO_MEMORY );
    }

    //
    //  build search filter
    //      class == ServiceClass
    //          AND
    //          CN == ServiceClassName
    //              OR
    //          serviceClass == ServiceClassGuid
    //
    // (&(OBJECT_CLASS=SERVICE_CLASS)
    //   (|(CN=xxxx)
    //     (SERVICE_CLASS_ID=yyyy)))
    //

    index = 0;
    stringArray[index++] = L"(&";
    stringArray[index++] = FILTER_OBJECT_CLASS_SERVICE_CLASS;

    pfinalStr = L"))";

    if ( pwsServiceClassName )
    {
        stringArray[index++] = L"(|(";
        stringArray[index++] = FILTER_CN_EQUALS;
        stringArray[index++] = pwsServiceClassName;
        stringArray[index++] = L")";

        pfinalStr = L")))";
    }
    stringArray[index++] = FILTER_PAREN_SERVICE_CLASS_ID_EQUALS;
    stringArray[index++] = pclassFilter;
    stringArray[index++] = pfinalStr;
    stringArray[index]   = NULL;

    pfilter = Dns_CreateConcatenatedString_W( stringArray );
    if ( !pfilter )
    {
        status = ERROR_NO_MEMORY;
        goto Exit;
    }

    //
    //  search the default Winsock Services container
    //

    status = DoLdapSearch(
                    "FindServiceClass",
                    FALSE,
                    pldap,
                    pRnrConnection->WinsockServicesDN,
                    LDAP_SCOPE_ONELEVEL,
                    pfilter,
                    searchAttributes,
                    &presults );

    //
    //  if search unsuccessful, bail
    //

    if ( status != NO_ERROR  &&  !presults )
    {
        //status = WSAEFAULT;     // DCR:  wrong error code
        status = WSANO_DATA;
        goto Exit;
    }

    //
    //  build DN array from results
    //

    status = BuildDnArrayFromResults(
                    pldap,
                    presults,
                    pdwDnArrayCount,
                    ppDnArray );

Exit:

    ldap_msgfree( presults );
    FREE_HEAP( pclassFilter );
    FREE_HEAP( pfilter );

    //  set results OUT param

    if ( status != NO_ERROR )
    {
        if ( ppDnArray )
        {
            *ppDnArray = NULL;
        }
        if ( pdwDnArrayCount )
        {
            *pdwDnArrayCount = 0;
        }
    }

    DNSDBG( TRACE, (
        "Leave FindServiceClass() => %d\n"
        "\tcount            = %d\n"
        "\tpdnArray         = %p\n"
        "\tfirst DN         = %S\n",
        status,
        pdwDnArrayCount ? *pdwDnArrayCount : 0,
        (ppDnArray && *ppDnArray)
            ?   *ppDnArray
            :   NULL,
        (ppDnArray && *ppDnArray)
            ?   (*ppDnArray)->Strings[0]
            :   NULL
        ));

    return( status );
}



RNR_STATUS
FindServiceInstance(
    IN      PRNR_CONNECTION    pRnrConnection,
    IN      PWSTR              pwsServiceName       OPTIONAL,
    IN      PGUID              pServiceClassId      OPTIONAL,
    IN      PWSAVERSION        pVersion             OPTIONAL,
    IN      PWSTR              pwsContext           OPTIONAL,
    IN      BOOL               fPerformDeepSearch,
    OUT     PDWORD             pdwDnArrayCount,
    OUT     PDN_ARRAY *        ppDnArray            OPTIONAL
    )
{
    RNR_STATUS      status = NO_ERROR;
    PLDAP           pldap = pRnrConnection->pLdapServer;
    PWSTR           pnameService;
    PWSTR           pwsRdn = NULL;
    PWSTR           psearchContextAllocated = NULL;
    PWSTR           pserviceContext;
    PWSTR           pclassFilter = NULL;
    PWSTR           pversionFilter = NULL;
    PWSTR           pfilter = NULL;
    LDAPMessage *   presults = NULL;
    BOOL            fuseDN;
    DWORD           index;
    PWSTR           psearchContext = NULL;
    PWSTR           stringArray[15];
    PWSTR           searchAttributes[2] = { COMMON_NAME, NULL };

    DNSDBG( TRACE, (
        "FindServiceInstance()\n"
        "\tpRnrCon          = %p\n"
        "\tServiceName      = %S\n"
        "\tpClassGUID       = %p\n"
        "\tpVersion         = %p\n"
        "\tpwsContext       = %S\n"
        "\tpCount   OUT     = %p\n"
        "\tpDnArray OUT     = %p\n",
        pRnrConnection,
        pwsServiceName,
        pServiceClassId,
        pVersion,
        pwsContext,
        pdwDnArrayCount,
        ppDnArray 
        ));

    //
    //  get service name
    //      - if given name
    //          - get DN or is DN
    //      - else
    //          - search for any service "*"
    //

    pnameService = L"*";

    if ( pwsServiceName )
    {
        //  note, this can allocate pwsRdn and psearchContext

        fuseDN = IsNameADn(
                    pwsServiceName,
                    & pwsRdn,
                    & psearchContextAllocated );
        if ( fuseDN )
        {
            pnameService = pwsRdn;
        }
        else
        {
            pnameService = pwsServiceName;
        }
    }

    //
    //  if service class specified make filter
    //

    if ( pServiceClassId )
    {
        pclassFilter = CreateFilterElement(
                            (PCHAR) pServiceClassId,
                            sizeof(GUID) );
        if ( !pclassFilter )
        {
            status = ERROR_NO_MEMORY;
            goto Exit;
        }
    }

    //
    //  version specified -- make filter
    //

    if ( pVersion )
    {
        pversionFilter = CreateFilterElement(
                            (PCHAR) pVersion,
                            sizeof(WSAVERSION) );
        if ( !pversionFilter )
        {
            status = ERROR_NO_MEMORY;
            goto Exit;
        }
    }

    //
    //  context
    //      - use context found above or
    //      - passed in context or
    //      - WinsockServices DN
    //

    if ( psearchContextAllocated )
    {
        pserviceContext = psearchContextAllocated;
    }
    else if ( pwsContext )
    {
        pserviceContext = pwsContext;
    }
    else
    {
        pserviceContext = pRnrConnection->WinsockServicesDN;
    }

    //
    //  build filter
    //      - objects of class ServiceClass
    //      - with common name equal to pServiceInstanceName
    //
    //    (&(objectClass=serviceInstance)
    //      (CN=pnameService)
    //      (serviceClassId=pclassFilter)
    //      (serviceVersion=pversionFilter))
    //

    index = 0;
    stringArray[index++] = L"(&";                      
    stringArray[index++] = FILTER_OBJECT_CLASS_SERVICE_INSTANCE;                
    stringArray[index++] = FILTER_PAREN_CN_EQUALS;                 
    stringArray[index++] = pnameService;
    stringArray[index++] = L")";

    if ( pServiceClassId )
    {
        stringArray[index++] = FILTER_PAREN_SERVICE_CLASS_ID_EQUALS;
        stringArray[index++] = pclassFilter;
        stringArray[index++] = L")";
    }
    if ( pVersion )
    {
        stringArray[index++] = FILTER_PAREN_SERVICE_VERSION_EQUALS;
        stringArray[index++] = pversionFilter;
        stringArray[index++] = L")";
    }                          
    stringArray[index++] = L")";
    stringArray[index]   = NULL;

    pfilter = Dns_CreateConcatenatedString_W( stringArray );
    if ( !pfilter )
    {
        status = ERROR_NO_MEMORY;
        goto Exit;
    }

    //
    //  search
    //      - in pserviceContext defined above
    //
    // DCR: - We may want to perform all of these searches against the
    //          Global Catalog server.
    //

    status = DoLdapSearch(
                    "FindServiceInstance",
                    FALSE,
                    pldap,
                    pserviceContext,
                    fPerformDeepSearch
                        ? LDAP_SCOPE_SUBTREE
                        : LDAP_SCOPE_ONELEVEL,
                    pfilter,
                    searchAttributes,
                    &presults );

    if ( status && !presults )
    {
        status = WSAEFAULT;
        goto Exit;
    }

    //
    //  build DN array from results
    //

    status = BuildDnArrayFromResults(
                    pldap,
                    presults,
                    pdwDnArrayCount,
                    ppDnArray );

Exit:

    ldap_msgfree( presults );
    FREE_HEAP( pwsRdn );
    FREE_HEAP( psearchContextAllocated );
    FREE_HEAP( pclassFilter );
    FREE_HEAP( pversionFilter );
    FREE_HEAP( pfilter );

    if ( status != NO_ERROR )
    {
        if ( pdwDnArrayCount )
        {
            *pdwDnArrayCount = 0;
        }
        if ( ppDnArray )
        {
            *ppDnArray = NULL;
        }
    }

    DNSDBG( TRACE, (
        "Leave FindServiceInstance() => %d\n"
        "\tpDnArray OUT     = %p\n"
        "\tfirst DN         = %S\n",
        status,
        (ppDnArray && *ppDnArray)
            ?   *ppDnArray
            :   NULL,
        (ppDnArray && *ppDnArray)
            ?   (*ppDnArray)->Strings[0]
            :   NULL
        ));

    return( status );
}



RNR_STATUS
FindSubordinateContainers(
    IN      PRNR_CONNECTION pRnrConnection,
    IN      PWSTR           pwsServiceName          OPTIONAL,
    IN      PWSTR           pwsContext              OPTIONAL,
    IN      BOOL            fPerformDeepSearch,
    OUT     PDN_ARRAY *     ppDnArray               OPTIONAL
    )
{
    RNR_STATUS      status = NO_ERROR;
    PLDAP           pldap = pRnrConnection->pLdapServer;
    PWSTR           pnameService;
    PWSTR           pwsRdn = NULL;
    PWSTR           psearchContextAllocated = NULL;
    PWSTR           psearchContext;
    PWSTR           pfilter = NULL;
    DWORD           index;
    BOOL            fuseDN;
    PWSTR           stringArray[8];
    LDAPMessage *   presults = NULL;



    DNSDBG( TRACE, (
        "FindSubordinateContainers()\n"
        "\tpRnrCon          = %p\n"
        "\tServiceName      = %S\n"
        "\tpwsContext       = %S\n"
        "\tfDeepSearch      = %d\n"
        "\tpDnArray OUT     = %p\n",
        pRnrConnection,
        pwsServiceName,
        pwsContext,
        fPerformDeepSearch,
        ppDnArray 
        ));

    //
    //  get service name
    //      - if given name
    //          - get DN or is DN
    //      - else
    //          - search for any service "*"
    //

    pnameService = L"*";

    if ( pwsServiceName )
    {
        //  note, this can allocate pwsRdn and psearchContext

        fuseDN = IsNameADn(
                    pwsServiceName,
                    & pwsRdn,
                    & psearchContextAllocated );
        if ( fuseDN )
        {
            pnameService = pwsRdn;
        }
        else
        {
            pnameService = pwsServiceName;
        }
    }

    //
    //  build filter
    //      - objects of class NTDS container
    //      - with common name equal to pServiceInstanceName
    //
    //    (&(OBJECT_CLASS=NTDS_CONTAINER)
    //      (COMMON_NAME=ServiceName))
    //

    index = 0;
    stringArray[index++] = L"(&";                      
    stringArray[index++] = FILTER_OBJECT_CLASS_NTDS_CONTAINER;                
    stringArray[index++] = FILTER_PAREN_CN_EQUALS;                 
    stringArray[index++] = pnameService;
    stringArray[index++] = L"))";
    stringArray[index]   = NULL;

    pfilter = Dns_CreateConcatenatedString_W( stringArray );
    if ( !pfilter )
    {
        status = ERROR_NO_MEMORY;
        goto Exit;
    }

    //
    //  search context
    //      - use allocated from passed in DN or
    //      - passed in context
    //          - special context to indicated DomainDN or
    //      - winsock services DN
    //

    if ( psearchContextAllocated )
    {
        psearchContext = psearchContextAllocated;
    }
    else if ( pwsContext )
    {
        if ( wcscmp( pwsContext, L"\\" ) == 0 )
        {
            psearchContext = pRnrConnection->DomainDN;
        }
        else
        {
            psearchContext = pwsContext;
        }
    }
    else
    {
        psearchContext = pRnrConnection->WinsockServicesDN;
    }

    //
    //  search
    //      - in pserviceContext defined above
    //
    // DCR: - We may want to perform all of these searches against the
    //          Global Catalog server.
    //

    status = DoLdapSearch(
                    "FindSubordinateContainer",
                    FALSE,      // no locked
                    pldap,
                    psearchContext,
                    fPerformDeepSearch
                        ? LDAP_SCOPE_SUBTREE
                        : LDAP_SCOPE_ONELEVEL,
                    pfilter,
                    NULL,       // no attribute selection
                    &presults );

    if ( status && !presults )
    {
        status = WSAEFAULT;
        goto Exit;
    }

    //
    //  build DN array from results
    //

    status = BuildDnArrayFromResults(
                    pldap,
                    presults,
                    NULL,
                    ppDnArray );

Exit:

    ldap_msgfree( presults );
    FREE_HEAP( pfilter );
    FREE_HEAP( pwsRdn );
    FREE_HEAP( psearchContextAllocated );

    DNSDBG( TRACE, (
        "Leave FindSubordinateContainer() => %d\n"
        "\tpDnArray OUT     = %p\n",
        "\tfirst DN         = %S\n",
        status,
        (ppDnArray && *ppDnArray)
            ?   *ppDnArray
            :   NULL,
        (ppDnArray && *ppDnArray)
            ?   (*ppDnArray)->Strings[0]
            :   NULL
        ));

    return( status );
}



//
//  Read routines
//
//  These routines read directory data and write into
//  RnR buffer.  They are the working functions for
//  RnR "Get" routines.
//

RNR_STATUS
ReadServiceClass(
    IN      PRNR_CONNECTION         pRnrConnection,
    IN      PWSTR                   pwsDN,
    IN OUT  PDWORD                  pdwBufSize,
    IN OUT  PWSASERVICECLASSINFOW   pServiceClassInfo
    )
/*++

Routine Description:

    Return service class info to caller.

    Helper routine for NTDS_GetServiceClassInfo().
    Read service class info for given DN and return
    service class info buffer to caller.

Arguments:

Return Value:

    NO_ERROR if successful.
    WSAEFAULT if buffer too small.
    ErrorCode on failure.

--*/
{
    RNR_STATUS          status = NO_ERROR;
    PLDAP               pldap = pRnrConnection->pLdapServer;
    LDAPMessage *       presults = NULL;
    DWORD               count;
    DWORD               iter;
    LDAPMessage *       object;
    PWSTR *             ppvalue = NULL;
    PLDAP_BERVAL *      ppberVal = NULL;
    FLATBUF             flatbuf;
    PWSANSCLASSINFOW    pbufClassInfoArray;
    PBYTE               pbuf;
    PWSTR               pbufString;
    PWSTR               attrs[4] = {
                                SERVICE_CLASS_INFO,
                                SERVICE_CLASS_ID,
                                SERVICE_CLASS_NAME,
                                NULL };

    DNSDBG( TRACE, (
        "ReadServiceClass()\n"
        "\tprnr     = %p\n"
        "\tDN       = %S\n"
        "\tbuf size = %p (%d)\n"
        "\tbuffer   = %p\n",
        pRnrConnection,
        pwsDN,
        pdwBufSize,
        pdwBufSize ? *pdwBufSize : 0,
        pServiceClassInfo ));
    
    //
    //  create flat buffer for building response
    //      - starts immediately after service class info struct itself
    //

    ASSERT( pServiceClassInfo != NULL );

    RtlZeroMemory(
        (PBYTE) pServiceClassInfo,
        *pdwBufSize );

    FlatBuf_Init(
        & flatbuf,
        (LPBYTE) pServiceClassInfo + sizeof(WSASERVICECLASSINFOW),
        (INT) *pdwBufSize - sizeof(WSASERVICECLASSINFOW)
        );

    //
    //  search
    //

    status = DoLdapSearch(
                    "ReadServiceClass",
                    FALSE,      // no locked
                    pldap,
                    pwsDN,
                    LDAP_SCOPE_BASE,
                    FILTER_OBJECT_CLASS_SERVICE_CLASS,
                    attrs,
                    &presults );

    if ( status && !presults )
    {
        status = WSATYPE_NOT_FOUND;
        goto Done;
    }

    //
    //  search completed
    //      - should have found just one service class
    //

    count = ldap_count_entries( pldap, presults );
    if ( count == 0 )
    {
        WINRNR_PRINT((
            "WINRNR!ReadServiceClass -\n"
            "ldap_count_entries() failed\n" ));
        status = WSATYPE_NOT_FOUND;
        goto Done;
    }

    DNS_ASSERT( count == 1 );

    object = ldap_first_entry(
                pldap,
                presults );
    if ( !object )
    {
        WINRNR_PRINT((
            "WINRNR!ReadServiceClass -\n"
            "ldap_first_entry() failed\n" ));
        status = WSATYPE_NOT_FOUND;
        goto Done;
    }

    //
    //  read the ServiceClassInfo(s) from bervals
    //  and write them to buffer
    //

    ppberVal = ldap_get_values_len(
                        pldap,
                        object,
                        SERVICE_CLASS_INFO );
    count = 0;
    if ( ppberVal )
    {
        count = ldap_count_values_len( ppberVal );
    }
    pServiceClassInfo->dwCount = count;

    //  reserve space for class info array

    pbufClassInfoArray = (PWSANSCLASSINFOW)
                            FlatBuf_Reserve(
                                & flatbuf,
                                count * sizeof(WSANSCLASSINFOW),
                                ALIGN_LPVOID
                                );

    pServiceClassInfo->lpClassInfos = pbufClassInfoArray;

    //
    //  copy each WSANSCLASSINFO we find
    //      - note that do not stop loop even if out of space
    //      continue for sizing purposes
    //

    for ( iter = 0; iter < count; iter++ )
    {
        PCLASSINFO_BERVAL pclassInfo;
        PWSTR   pname;
        PBYTE   pvalue;
        PBYTE   pdataEnd;

        //  recover WSANSCLASSINFO as structure
        //
        //  WSANSCLASSINFO structures are stored as octect string in
        //  directory with offsets from structure start for pointer
        //  fields
        //
        //  note:  that the "pointer fields" are offsets in the
        //  structure and hence are NOT the size of pointers in 64-bit
        //  so we can NOT simply recover the structure and fixup
        //

        pclassInfo = (PCLASSINFO_BERVAL) ppberVal[iter]->bv_val;
        pdataEnd = (PBYTE)pclassInfo + ppberVal[iter]->bv_len;

        pvalue =         ((PBYTE) pclassInfo + pclassInfo->ValueOffset);
        pname  = (PWSTR) ((PBYTE) pclassInfo + pclassInfo->NameOffset);

        //
        //  validity check recovered data
        //      - name aligned
        //      - value within berval
        //      - name within berval
        //
        //  DCR:  explicit string validity\length check
        //

        if ( !POINTER_IS_ALIGNED( pname, ALIGN_WCHAR ) ||
             pvalue < (PBYTE) (pclassInfo+1) ||
             (pvalue + pclassInfo->dwValueSize) > pdataEnd ||
             pname < (PWSTR) (pclassInfo+1) ||
             pname >= (PWSTR) pdataEnd )
        {
            DNS_ASSERT( FALSE );
            status = WSATYPE_NOT_FOUND;
            goto Done;
        }

        //
        //  copy NSCLASSINFO to buffer
        //      - flat copy of DWORD types and sizes
        //      - copy name string
        //      - copy value

        pbufString = (PWSTR) FlatBuf_WriteString_W(
                                & flatbuf,
                                pname );

        pbuf = FlatBuf_CopyMemory(
                    & flatbuf,
                    pvalue,
                    pclassInfo->dwValueSize,
                    0           // no alignment required
                    );

        //  write only if had space for NSCLASSINFO array above

        if ( pbufClassInfoArray )
        {
            PWSANSCLASSINFO pbufClassInfo = &pbufClassInfoArray[iter];

            pbufClassInfo->dwNameSpace  = pclassInfo->dwNameSpace;
            pbufClassInfo->dwValueType  = pclassInfo->dwValueType;
            pbufClassInfo->dwValueSize  = pclassInfo->dwValueSize;
            pbufClassInfo->lpszName     = pbufString;
            pbufClassInfo->lpValue      = pbuf;
        }
    }

    ldap_value_free_len( ppberVal );
    ppberVal = NULL;
    

    //
    //  Read the ServiceClassId and write it into buffer.
    //  Remember this is a BER value (Octet string).
    //

    ppberVal = ldap_get_values_len(
                        pldap,
                        object,
                        SERVICE_CLASS_ID );
    if ( !ppberVal || !ppberVal[0] )
    {
        WINRNR_PRINT((
            "WINRNR!ReadServiceClass -\n"
            "ldap_get_values_len() failed\n" ));
        status = WSATYPE_NOT_FOUND;
        goto Done;
    }
    if ( ppberVal[0]->bv_len != sizeof(GUID) )
    {
        WINRNR_PRINT((
            "WINRNR!ReadServiceClass - corrupted DS data!\n"
            "\tservice class id berval %p with invalid length %d\n",
            ppberVal[0],
            ppberVal[0]->bv_len ));
        DNS_ASSERT( ppberVal[0]->bv_len == sizeof(GUID) );
        status = WSATYPE_NOT_FOUND;
        goto Done;
    }

    // ASSERT( ldap_count_values_len( ppberVal ) == 1 );

    //  write the service class id GUID to buffer

    pbuf = FlatBuf_CopyMemory(
                    & flatbuf,
                    ppberVal[0]->bv_val,
                    sizeof(GUID),
                    ALIGN_DWORD );

    pServiceClassInfo->lpServiceClassId = (PGUID) pbuf;

    ldap_value_free_len( ppberVal );
    ppberVal = NULL;

    //
    //  Read the ServiceClassName and write it into buffer.
    //

    ppvalue = ldap_get_values(
                    pldap,
                    object,
                    SERVICE_CLASS_NAME );
    if ( !ppvalue )
    {
        WINRNR_PRINT((
            "WINRNR!ReadServiceClass -\n"
            "ldap_get_values() failed\n" ));
        status = WSATYPE_NOT_FOUND;
        goto Done;
    }

    //  copy service class name

    pbufString = (PWSTR) FlatBuf_WriteString_W(
                            & flatbuf,
                            ppvalue[0] );

    pServiceClassInfo->lpszServiceClassName = pbufString;

    ldap_value_free( ppvalue );

    //
    //  check for inadequate space
    //      - set actual buffer size used
    //
    //  DCR_QUESTION:  do we fix up space all the time?
    //      or only when fail
    //

    status = NO_ERROR;
    //*pdwBufSize -= flatbuf.BytesLeft;

    if ( flatbuf.BytesLeft < 0 )
    {
        *pdwBufSize -= flatbuf.BytesLeft;
        status = WSAEFAULT;
    }

Done:

    ldap_value_free_len( ppberVal );
    ldap_msgfree( presults );

    DNSDBG( TRACE, (
        "Leave ReadServiceClass() = %d\n",
        status ));

    return( status );
}



RNR_STATUS
ReadQuerySet(
    IN      PRNR_LOOKUP         pRnr,
    IN      PWSTR               pwsDN,
    IN OUT  PDWORD              pdwBufSize,
    IN OUT  PWSAQUERYSETW       pqsResults
    )
/*++

Routine Description:

    Read query set info.

    Does LDAP search and fills in query set with desired results.

    This collapses previous ReadServiceInstance() and
    ReadSubordinateContainer() functions which had huge signatures
    and basically had the same code except for the LDAP attributes.

    The old functions had signature like this:
        if ( prnr->ControlFlags & LUP_CONTAINERS )
        {
            status = ReadSubordinateContainer(
                            prnr->pRnrConnection,
                            preadDn,
                            prnr->ControlFlags,
                            prnr->ProviderGuid,
                            pdwBufSize,
                            pqsResults );
        }
        else
        {
            status = ReadServiceInstance(
                            prnr->pRnrConnection,
                            preadDn,
                            prnr->ControlFlags,
                            prnr->ProviderGuid,
                            prnr->ServiceClassGuid,
                            prnr->NumberOfProtocols,
                            prnr->pafpProtocols,
                            pdwBufSize,
                            pqsResults );
        }

Arguments:

    pRnrConnection -- RnR LDAP connection info

    pwsDN -- DN to read at

    pdwBufSize -- addr of result buffer length;
        on return receives required buffer length

    pqsResults -- query set result buffer
        on return receives results of query

Return Value:

    NO_ERROR if successful.
    WSAEFAULT if buffer too small.
    ErrorCode on failure.

--*/
{
    RNR_STATUS      status = NO_ERROR;
    PLDAP           pldap;
    DWORD           controlFlags;
    BOOL            fserviceInstance;
    BOOL            freturnedData = FALSE;
    LDAPMessage *   presults = NULL;
    DWORD           count = 0;
    FLATBUF         flatbuf;
    LDAPMessage *   object;
    PWSTR *         ppvalue = NULL;
    PLDAP_BERVAL *  ppberVal = NULL;
    PCSADDR_INFO    ptempCsaddrArray = NULL;
    PBYTE           pbuf;
    PSTR            pbufString;
    PWSTR           pcontext;
    WSAQUERYSETW    dummyResults;
    INT             bufSize;
    PWSTR           pfilter;
    PWSTR           pname;
    PWSTR           pcomment;
    PWSTR           attributes[6];


    DNSDBG( TRACE, (
        "ReadQuerySet()\n"
        "\tpRnr     = %p\n"
        "\tDN       = %S\n"
        "\tbuf size = %p (%d)\n"
        "\tbuffer   = %p\n",
        pRnr,
        pwsDN,
        pdwBufSize,
        pdwBufSize ? *pdwBufSize : 0,
        pqsResults ));

    //
    //  grab a few common params
    //

    if ( !pRnr->pRnrConnection )
    {
        DNS_ASSERT( FALSE );
        status = WSA_INVALID_PARAMETER;
        goto Exit;
    }
    pldap        = pRnr->pRnrConnection->pLdapServer;
    controlFlags = pRnr->ControlFlags;

    //
    //  setup ReadServiceInstance\ReadSubordinateContainer diffs
    //      - search attributes
    //      - search filter
    //      - attribute for name
    //      - attribute for comment
    //
    //  DCR:  could select attributes based on LUP_X flags
    //      but doubt there's much perf impact here
    //

    fserviceInstance = !(controlFlags & LUP_CONTAINERS);

    if ( fserviceInstance )
    {
        attributes[0] = SERVICE_INSTANCE_NAME;
        attributes[1] = SERVICE_CLASS_ID;
        attributes[2] = SERVICE_VERSION;
        attributes[3] = SERVICE_COMMENT;
        attributes[4] = WINSOCK_ADDRESSES;
        attributes[5] = NULL;

        pfilter     = FILTER_OBJECT_CLASS_SERVICE_INSTANCE;
        pname       = SERVICE_INSTANCE_NAME;
        pcomment    = SERVICE_COMMENT;
    }
    else    // read container
    {
        attributes[0] = OBJECT_CLASS;
        attributes[1] = OBJECT_COMMENT;
        attributes[2] = OBJECT_NAME;
        attributes[3] = NULL;

        pfilter     = FILTER_OBJECT_CLASS_NTDS_CONTAINER;
        pname       = OBJECT_NAME;
        pcomment    = OBJECT_COMMENT;
    }

    //
    //  init the buffer and flatbuf builder
    //
    //  if given buffer that's even less than QUERYSET size
    //  use a dummy buffer to avoid useless tests while we
    //  build\size
    //

    bufSize = *pdwBufSize - sizeof(WSAQUERYSET);
    if ( bufSize < 0 )
    {
        pqsResults = &dummyResults;
    }

    RtlZeroMemory(
        (PBYTE) pqsResults,
        sizeof(WSAQUERYSETW) );

    FlatBuf_Init(
        & flatbuf,
        (PBYTE) pqsResults + sizeof(WSAQUERYSETW),
        bufSize
        );

    //
    //  search
    //

    status = DoLdapSearch(
                    "ReadQuerySet",
                    FALSE,      // no locked
                    pldap,
                    pwsDN,
                    LDAP_SCOPE_BASE,
                    pfilter,
                    attributes,
                    & presults );

    if ( status && !presults )
    {
        WINRNR_PRINT((
            "WINRNR!ReadQuerySet -\n"
            "ldap_search_s() failed with error code: 0%x\n",
            status ));
        status = WSANO_DATA;
        goto Exit;
    }

    //
    //  search completed -- check for valid presults
    //      - should have one object matching search criteria

    count = ldap_count_entries( pldap, presults );
    if ( count == 0 )
    {
        WINRNR_PRINT((
            "WINRNR!ReadQuerySet -\n"
            "ldap_count_entries() failed\n" ));
        status = WSANO_DATA;
        goto Exit;
    }
    
    object = ldap_first_entry( pldap, presults );
    if ( !object )
    {
        WINRNR_PRINT((
            "WINRNR!ReadQuerySet -\n"
            "ldap_first_entry() failed\n" ));
        status = WSANO_DATA;
        goto Exit;
    }

    //
    //  for ReadServiceInstance -- read the sockaddrs and write to buffer
    //      - these are BER values
    //

    if ( fserviceInstance &&
         controlFlags & LUP_RETURN_ADDR )
    {
        DWORD           countBerval;
        DWORD           iter;
        DWORD           countCsaddr = 0;
        PCSADDR_INFO    pcsaddr;
    
        ppberVal = ldap_get_values_len(
                            pldap,
                            object,
                            WINSOCK_ADDRESSES );
        if ( !ppberVal )
        {
            goto WriteName;
        }
        countBerval = ldap_count_values_len( ppberVal );

        //
        //  extract each acceptable CSADDR to result buffer
        //
        //  note:  CSADDRs are written in packed array, so must write
        //      them all before writing their corresponding sockaddrs;
        //      and since we don't know whether result buffer is
        //      sufficient, must allocate temp array to handle unpacking
        //

        ptempCsaddrArray = (PCSADDR_INFO) ALLOC_HEAP(
                                        countBerval * sizeof(CSADDR_INFO) );
        if ( !ptempCsaddrArray )
        {
            status = ERROR_NO_MEMORY;
            goto Exit;
        }

        //
        //  build temp CSADDR_INFO array
        //      - unpack from CSADDR_BERVAL format
        //      - verify acceptable protocol and family

        pcsaddr = ptempCsaddrArray;

        for ( iter = 0; iter < countBerval; iter++ )
        {
            if ( ! ExtractCsaddrFromBerval(
                        pcsaddr,
                        ppberVal[iter],
                        pRnr->NumberOfProtocols,
                        pRnr->pafpProtocols ) )
            {
                continue;
            }
            countCsaddr++;
            pcsaddr++;
        }

        //
        //  protocol restrictions eliminated all address data?
        //      - return error code to skip this entry so caller
        //      can call down again
        //
        //  DCR_QUESTION:  why is this different than search failing?

        if ( countCsaddr == 0 &&
             pRnr->pafpProtocols &&
             pRnr->NumberOfProtocols )
        {
            status = WSANO_ADDRESS;
            goto Exit;
        }

        //
        //  reserve space for CSADDR array
        //

        pbuf = FlatBuf_Reserve(
                    & flatbuf,
                    countCsaddr * sizeof(CSADDR_INFO),
                    ALIGN_LPVOID
                    );

        pqsResults->lpcsaBuffer = (PCSADDR_INFO) pbuf;
        pqsResults->dwNumberOfCsAddrs = countCsaddr;

        //
        //  write sockaddrs for CSADDRs to result buffer
        //
        //  note:  that CSADDRs have been written to the result buffer
        //      with their sockaddr pointers pointing to the original
        //      sockaddrs IN the BERVAL;  when we copy the sockaddr data
        //      we also need to reset the CSADDR sockaddr pointer
        //

        pcsaddr = ptempCsaddrArray;
    
        for ( iter = 0; iter < countCsaddr; iter++ )
        {
            //  write local sockaddr
    
            pbuf = FlatBuf_CopyMemory(
                        & flatbuf,
                        (PBYTE) pcsaddr->LocalAddr.lpSockaddr,
                        pcsaddr->LocalAddr.iSockaddrLength,
                        ALIGN_DWORD );

            pcsaddr->LocalAddr.lpSockaddr = (PSOCKADDR) pbuf;

            //  write remote sockaddr
    
            pbuf = FlatBuf_CopyMemory(
                        & flatbuf,
                        (PBYTE) pcsaddr->LocalAddr.lpSockaddr,
                        pcsaddr->LocalAddr.iSockaddrLength,
                        ALIGN_DWORD );

            pcsaddr->LocalAddr.lpSockaddr = (PSOCKADDR) pbuf;
            pcsaddr++;
        }

        //
        //  copy temp CSADDR array to result buffer
        //      - space was reserved and aligned above
        //

        pbuf = (PBYTE) pqsResults->lpcsaBuffer;
        if ( pbuf )
        {
            RtlCopyMemory(
                pbuf,
                ptempCsaddrArray,
                countCsaddr * sizeof(CSADDR_INFO) );
        }
        freturnedData = TRUE;
    }

WriteName:

    //
    //  read the name and write it into buffer.
    //

    if ( controlFlags & LUP_RETURN_NAME )
    {
        ppvalue = ldap_get_values(
                        pldap,
                        object,
                        pname );
        if ( ppvalue )
        {
            pbufString = FlatBuf_WriteString_W(
                            & flatbuf,
                            ppvalue[0] );
            pqsResults->lpszServiceInstanceName = (PWSTR) pbufString;
            freturnedData = TRUE;
            ldap_value_free( ppvalue );
        }
    }

    //
    //  for service instance
    //      - get serviceClassId
    //      - get serviceVersion
    //

    if ( fserviceInstance )
    {
        //
        //  read ServiceClassId (GUID) and write it to buffer
        //
        //  DCR_QUESTION:  originally we copied ServiceClassId passed in
        //      rather than one we read?
        //

        if ( controlFlags & LUP_RETURN_TYPE )
        {
            ppberVal = ldap_get_values_len(
                            pldap,
                            object,
                            SERVICE_CLASS_ID );
            if ( ppberVal )
            {
                if ( ppberVal[0]->bv_len == sizeof(GUID) )
                {
                    pbuf = FlatBuf_CopyMemory(
                                & flatbuf,
                                ppberVal[0]->bv_val,
                                sizeof(GUID),
                                ALIGN_DWORD
                                );
                    pqsResults->lpServiceClassId = (PGUID) pbuf;
                    freturnedData = TRUE;
                }
                ldap_value_free_len( ppberVal );
            }
        }
    
        //
        //  read ServiceVersion and write it to buffer
        //
    
        if ( controlFlags & LUP_RETURN_VERSION )
        {
            ppberVal = ldap_get_values_len(
                            pldap,
                            object,
                            SERVICE_VERSION );
    
            if ( ppberVal )
            {
                if ( ppberVal[0]->bv_len == sizeof(WSAVERSION) )
                {
                    pbuf = FlatBuf_CopyMemory(
                                & flatbuf,
                                ppberVal[0]->bv_val,
                                sizeof(WSAVERSION),
                                ALIGN_DWORD
                                );
                    pqsResults->lpVersion = (LPWSAVERSION) pbuf;
                    freturnedData = TRUE;
                }
                ldap_value_free_len( ppberVal );
            }
        }
    }

    //
    //  read comment and copy to buffer
    //

    if ( controlFlags & LUP_RETURN_COMMENT )
    {
        ppvalue = ldap_get_values(
                        pldap,
                        object,
                        pcomment );
        if ( ppvalue )
        {
            pbufString = FlatBuf_WriteString_W(
                            & flatbuf,
                            ppvalue[0]
                            );
            pqsResults->lpszComment = (PWSTR) pbufString;
            freturnedData = TRUE;
            ldap_value_free( ppvalue );
        }
    }

    //
    //  if no search results written -- done
    //

    if ( !freturnedData )
    {
        status = WSANO_DATA;
        goto Exit;
    }
    
    //
    //  fill in other queryset fields
    //

    pqsResults->dwSize = sizeof( WSAQUERYSETW );
    pqsResults->dwNameSpace = NS_NTDS;
    
    //
    //  add the provider GUID
    //

    pbuf = FlatBuf_CopyMemory(
                & flatbuf,
                & pRnr->ProviderGuid,
                sizeof(GUID),
                ALIGN_DWORD
                );
    pqsResults->lpNSProviderId = (PGUID) pbuf;

    //
    //  add the context string
    //

    pcontext = wcschr( pwsDN, L',' );
    pcontext++;

    pbufString = FlatBuf_WriteString_W(
                    & flatbuf,
                    pcontext );

    pqsResults->lpszContext = (PWSTR) pbufString;
    
    //
    //  check for inadequate space
    //      - set actual buffer size used
    //
    //  DCR_QUESTION:  do we fix up space all the time?
    //      or only when fail
    //

    status = NO_ERROR;
    //*pdwBufSize -= flatbuf.BytesLeft;

    if ( flatbuf.BytesLeft < 0 )
    {
        *pdwBufSize -= flatbuf.BytesLeft;
        status = WSAEFAULT;
    }

Exit:

    ldap_msgfree( presults );
    FREE_HEAP( ptempCsaddrArray );

    DNSDBG( TRACE, (
        "Leave ReadQuerySet() => %d\n"
        "\tpRnr             = %p\n"
        "\tpQuerySet        = %p\n"
        "\tbufLength        = %d\n",
        status,
        pRnr,
        pqsResults,
        pdwBufSize ? *pdwBufSize : 0
        ));
    return( status );
}



//
//  NSP definition
//

INT
WINAPI
NTDS_Cleanup(
    IN      PGUID           pProviderId
    )
/*++

Routine Description:

    Cleanup NTDS provider.

    This is called by WSACleanup() if NSPStartup was called.

Arguments:

    pProviderId -- provider GUID

Return Value:

    None

--*/
{
    DNSDBG( TRACE, ( "NTDS_Cleanup( %p )\n", pProviderId ));

    //  free any global memory allocated

    DnsApiFree( g_pHostName );
    DnsApiFree( g_pFullName );

    g_pHostName = NULL;
    g_pFullName = NULL;

    //
    //  DCR:  note potentially leaking RnR lookup handles
    //      we are not keeping list of lookup handles,
    //      so can not clean them up, if callers expect WSACleanup() to
    //      handle it -- they'll leak
    //

    return( NO_ERROR );
}



INT
WINAPI
NTDS_InstallServiceClass(
    IN      PGUID                   pProviderId,
    IN      PWSASERVICECLASSINFOW   pServiceClassInfo
    )
/*++

Routine Description:

    Install service class in directory.

Arguments:

    pProviderId -- provider GUID

    pServiceClassInfo -- service class info blob

Return Value:

    NO_ERROR if successful.
    SOCKET_ERROR on failure.  GetLastError() contains status.

--*/
{
    RNR_STATUS      status = NO_ERROR;
    PRNR_CONNECTION prnrCon = NULL;
    DWORD           iter;
    DWORD           count = 0;
    PDN_ARRAY       pdnArray = NULL;
    BOOL            fisNTDS = FALSE;
    PGUID           pclassGuid;


    DNSDBG( TRACE, (
        "NTDS_InstallServiceClass()\n"
        "\tpGuid            = %p\n"
        "\tpServiceClass    = %p\n",
        pProviderId,
        pServiceClassInfo ));

    IF_DNSDBG( TRACE )
    {
        DnsDbg_Guid(
            "InstallServiceClass Provider GUID:",
            pProviderId );
    }
    IF_DNSDBG( TRACE )
    {
        DnsDbg_WsaServiceClassInfo(
            "InstallServiceClass() ServiceClassInfo:",
            pServiceClassInfo,
            TRUE        // unicode
            );
    }

    //
    //  validate service class
    //

    if ( ! pServiceClassInfo ||
         ! pServiceClassInfo->lpServiceClassId ||
         ! pServiceClassInfo->lpszServiceClassName ||
         ( pServiceClassInfo->dwCount &&
           !pServiceClassInfo->lpClassInfos ) )
    {
        status = WSA_INVALID_PARAMETER;
        goto Exit;
    }

    //
    //  don't install the DNS services -- they already exist
    //

    pclassGuid = pServiceClassInfo->lpServiceClassId;

    if ( GuidEqual( pclassGuid, &HostAddrByInetStringGuid ) ||
         GuidEqual( pclassGuid, &ServiceByNameGuid ) ||
         GuidEqual( pclassGuid, &HostAddrByNameGuid ) ||
         GuidEqual( pclassGuid, &HostNameGuid ) ||
         IS_SVCID_DNS( pclassGuid ) )
    {
        status = WSA_INVALID_PARAMETER;
        goto Exit;
    }

    for ( iter = 0; iter < pServiceClassInfo->dwCount; iter++ )
    {
        if ( pServiceClassInfo->lpClassInfos[iter].dwNameSpace == NS_NTDS ||
             pServiceClassInfo->lpClassInfos[iter].dwNameSpace == NS_ALL )
        {
            fisNTDS = TRUE;
            break;
        }
    }
    if ( !fisNTDS )
    {
        status = WSA_INVALID_PARAMETER;
        goto Exit;
    }

    //
    //  connect to directory
    //

    status = ConnectToDefaultLDAPDirectory( FALSE, &prnrCon );
    if ( status != NO_ERROR )
    {
        goto Exit;
    }

    //
    //  check if service class already installed in directory
    //

    status = FindServiceClass(
                    prnrCon,
                    pServiceClassInfo->lpszServiceClassName,
                    pclassGuid,
                    NULL,           // don't need count
                    &pdnArray );

    if ( status != NO_ERROR )
    {
        goto Exit;
    }

    //
    //  service class not found -- add it
    //

    if ( !pdnArray )
    {
        status = AddServiceClass(
                        prnrCon,
                        pclassGuid,
                        pServiceClassInfo->lpszServiceClassName,
                        &pdnArray );

        if ( status != NO_ERROR )
        {
            goto Exit;
        }
    }

    //
    //  loop through the WSANSCLASSINFO's for the given pServiceClassInfo
    //      - add/modify the ones with our dwNameSpace to the NSClassInfo
    //          property of the ServiceClass object.
    //
    //  DCR:  continue on error here and just save failing status?
    //

    for ( iter = 0; iter < pServiceClassInfo->dwCount; iter++ )
    {
        PWSANSCLASSINFO pclassInfo = &pServiceClassInfo->lpClassInfos[iter];

        if ( pclassInfo->dwNameSpace == NS_NTDS ||
             pclassInfo->dwNameSpace == NS_ALL )
        {
            status = AddClassInfoToServiceClass(
                            prnrCon,
                            pdnArray->Strings[0],
                            pclassInfo );

            if ( status != NO_ERROR )
            {
                goto Exit;
            }
        }
    }


Exit:

    FreeDnArray( pdnArray );

    DisconnectFromLDAPDirectory( &prnrCon );

    DNSDBG( TRACE, (
        "Leave InstallServiceClass() => %d\n",
        status ));

    return( SetError( status ) );
}



INT
WINAPI
NTDS_RemoveServiceClass(
    IN      PGUID          pProviderId,
    IN      PGUID          pServiceClassId
    )
/*++

Routine Description:

    Remove service class from directory.

Arguments:

    pProviderId -- provider GUID

    pServiceClassInfo -- service class info blob

Return Value:

    NO_ERROR if successful.
    SOCKET_ERROR on failure.  GetLastError() contains status.

--*/
{
    RNR_STATUS      status = NO_ERROR;
    PRNR_CONNECTION prnrCon = NULL;
    DWORD           serviceCount = 0;
    DWORD           iter;
    PDN_ARRAY       pdnArray = NULL;


    DNSDBG( TRACE, (
        "NTDS_RemoveServiceClass()\n"
        "\tpProviderGuid    = %p\n"
        "\tpClassGuid       = %p\n",
        pProviderId,
        pServiceClassId ));

    IF_DNSDBG( TRACE )
    {
        DnsDbg_Guid(
            "RemoveServiceClass Provider GUID:",
            pProviderId );
    }
    IF_DNSDBG( TRACE )
    {
        DnsDbg_Guid(
            "RemoveServiceClass GUID:",
            pServiceClassId );
    }

    //
    //  validation
    //

    if ( !pServiceClassId )
    {
        return( SetError( WSA_INVALID_PARAMETER ) );
    }

    //
    //  connect to directory
    //

    status = ConnectToDefaultLDAPDirectory(
                FALSE,
                &prnrCon );

    if ( status != NO_ERROR )
    {
        goto Exit;
    }

    //
    //  find service class in directory
    //

    status = FindServiceClass(
                    prnrCon,
                    NULL,
                    pServiceClassId,
                    NULL,   // don't need count
                    & pdnArray );

    if ( status != NO_ERROR )
    {
        goto Exit;
    }
    if ( !pdnArray )
    {
        status = WSATYPE_NOT_FOUND;
        goto Exit;
    }

    //
    //  should have found only one ServiceClass in the container,
    //  CN=WinsockServices, ... , with a ServiceClassId of pServiceClassId.
    //

    ASSERT( pdnArray->Count == 1 );

    //
    //  found service class
    //      - check for service instances objects for the the class
    //      if found, we can't remove the class until instances
    //      are removed
    //

    status = FindServiceInstance(
                    prnrCon,
                    NULL,               // no instance names
                    pServiceClassId,    // find class by GUID
                    NULL,               // no version
                    prnrCon->DomainDN,  // context
                    TRUE,               // search entire subtree
                    &serviceCount,      // retrieve count
                    NULL                // don't need DNs just count
                    );

    if ( status != NO_ERROR )
    {
        goto Exit;
    }
    if ( serviceCount > 0 )
    {
        //  still have service instances that reference the class
        //  so can't remove class

        status = WSAETOOMANYREFS;
        goto Exit;
    }

    //
    //  remove the service class
    //      - first string in pdnArray contains DN of the ServiceClass
    //

    status = ldap_delete_s(
                prnrCon->pLdapServer,
                pdnArray->Strings[0] );

    if ( status != NO_ERROR )
    {
        WINRNR_PRINT((
            "WINRNR!NTDS_RemoveServiceClass - ldap_delete_s()\n"
            "failed with error code: 0%x\n",
            status ));
        status = WSAEACCES;
        goto Exit;
    }


Exit:

    FreeDnArray( pdnArray );

    DisconnectFromLDAPDirectory( &prnrCon );

    DNSDBG( TRACE, (
        "Leave RemoveServiceClass() => %d\n",
        status ));

    return( SetError( status ) );
}



INT
WINAPI
NTDS_GetServiceClassInfo(
    IN      PGUID                  pProviderId,
    IN OUT  PDWORD                 pdwBufSize,
    IN OUT  PWSASERVICECLASSINFOW  pServiceClassInfo
    )
/*++

Routine Description:

    Read service class info

Arguments:

    pProviderId -- provider GUID

    pdwBufSize -- addr with and to recv buffer size
        input:      buffer size
        output:     bytes required or written

    pServiceClassInfo -- service class info buffer
        input:      valid service class GUID (lpServiceClassId)
        output:     filled in with service class info;  subfield data follows
                    WSASERVICECLASSINFO struct

Return Value:

    NO_ERROR if successful.
    SOCKET_ERROR on failure.  GetLastError() contains status.

--*/
{
    RNR_STATUS      status = NO_ERROR;
    PRNR_CONNECTION prnrCon = NULL;
    DWORD           count = 0;
    PDN_ARRAY       pdnArray = NULL;


    DNSDBG( TRACE, (
        "NTDS_GetServiceClassInfo()\n"
        "\tpProviderGuid    = %p\n"
        "\tpdwBufSize       = %p (%d)\n"
        "\tpClassInfo       = %p\n",
        pProviderId,
        pdwBufSize,
        pdwBufSize ? *pdwBufSize : 0,
        pServiceClassInfo ));

    //
    //  validate
    //

    if ( !pServiceClassInfo || !pdwBufSize )
    {
        status = WSA_INVALID_PARAMETER;
        goto Exit;
    }

    IF_DNSDBG( TRACE )
    {
        DnsDbg_WsaServiceClassInfo(
            "GetServiceClassInfo  ServiceClassInfo:",
            pServiceClassInfo,
            TRUE        // unicode
            );
    }

    //
    //  connect
    //

    status = ConnectToDefaultLDAPDirectory(
                FALSE,
                &prnrCon );

    if ( status != NO_ERROR )
    {
        goto Exit;
    }

    //
    //  find service class
    //      

    status = FindServiceClass(
                    prnrCon,
                    NULL,
                    pServiceClassInfo->lpServiceClassId,
                    NULL,       // don't need count
                    &pdnArray );

    if ( status != NO_ERROR )
    {
        goto Exit;
    }
    if ( !pdnArray )
    {
        status = WSATYPE_NOT_FOUND;
        goto Exit;
    }

    //  should be only one ServiceClass in the container,
    //  OU=WinsockServices, ... , with a ServiceClassId of pServiceClassId.

    ASSERT( pdnArray->Count == 1 );

    //
    //  read attributes of the ServiceClass into buffer
    //

    status = ReadServiceClass(
                prnrCon,
                pdnArray->Strings[0],
                pdwBufSize,
                pServiceClassInfo );



Exit:

    FreeDnArray( pdnArray );

    DisconnectFromLDAPDirectory( &prnrCon );

    IF_DNSDBG( TRACE )
    {
        DNS_PRINT((
            "Leave GetServiceClassInfo() = %d\n"
            "\tbuf size     = %d\n",
            status,
            pdwBufSize ? *pdwBufSize : 0 ));

        if ( status == NO_ERROR )
        {
            DnsDbg_WsaServiceClassInfo(
                "Leaving GetServiceClassInfo:",
                pServiceClassInfo,
                TRUE        // unicode
                );
        }
    }

    return( SetError( status ) );
}



INT
WINAPI
NTDS_SetService(
    IN      PGUID                   pProviderId,
    IN      PWSASERVICECLASSINFOW   pServiceClassInfo,
    IN      PWSAQUERYSETW           pqsReqInfo,
    IN      WSAESETSERVICEOP        essOperation,
    IN      DWORD                   dwControlFlags
    )
/*++

Routine Description:

    Read service class info

Arguments:

    pProviderId -- provider GUID

    pdwBufSize -- addr with and to recv buffer size
        input:      buffer size
        output:     bytes required or written

    pServiceClassInfo -- service class info buffer
        input:      valid service class GUID (lpServiceClassId)
        output:     filled in with service class info;  subfield data follows
                    WSASERVICECLASSINFO struct

Return Value:

    NO_ERROR if successful.
    SOCKET_ERROR on failure.  GetLastError() contains status.

--*/
{
    RNR_STATUS          status = NO_ERROR;
    PRNR_CONNECTION     prnrCon = NULL;
    DWORD               count = 0;
    DWORD               iter;
    PDN_ARRAY           pdnArray = NULL;

    DNSDBG( TRACE, (
        "NTDS_SetService()\n"
        "\tpProviderGuid        = %p\n"
        "\tpServiceClassInfo    = %p\n"
        "\tpQuerySet            = %p\n"
        "\tOperation            = %d\n"
        "\tControlFlags         = %08x\n",
        pProviderId,
        pServiceClassInfo,
        pqsReqInfo,
        essOperation,
        dwControlFlags ));

    IF_DNSDBG( TRACE )
    {
        DnsDbg_Lock();
        DnsDbg_Guid(
            "SetService()  Provider GUID:",
            pProviderId );

        DnsDbg_WsaServiceClassInfo(
            "SetService ServiceClassInfo:",
            pServiceClassInfo,
            TRUE        // unicode
            );

        DnsDbg_WsaQuerySet(
            "SetService QuerySet:",
            pqsReqInfo,
            TRUE        // unicode
            );
        DnsDbg_Unlock();
    }

    //
    //  param validation
    //

    if ( !pqsReqInfo )
    {
        return( SetError( WSA_INVALID_PARAMETER ) );
    }
    if ( pqsReqInfo->dwSize != sizeof( WSAQUERYSET ) )
    {
        return( SetError( WSAVERNOTSUPPORTED ) );
    }

    //
    //  connect
    //

    status = ConnectToDefaultLDAPDirectory(
                    FALSE,
                    &prnrCon );

    if ( status != NO_ERROR )
    {
        goto Exit;
    }

    //
    //  Figure out what operation and with what control flags are to be
    //  performed.
    //

    switch( essOperation )
    {
        case RNRSERVICE_REGISTER:

            //
            //  check if service already registered
            //

            status = FindServiceInstance(
                            prnrCon,
                            pqsReqInfo->lpszServiceInstanceName,
                            pqsReqInfo->lpServiceClassId,
                            pqsReqInfo->lpVersion,
                            NULL,           // no context
                            FALSE,          // one level search
                            NULL,           // don't need count
                            &pdnArray       // get instance DNs
                            );

            if ( status != NO_ERROR )
            {
                goto Exit;
            }

            //
            //  service instances doesn't exist => need to add
            //      - verify service class (matching GUID) exists
            //      - create instance of class
            //

            if ( !pdnArray )
            {
                PDN_ARRAY   pserviceArray = NULL;

                status = FindServiceClass(
                                prnrCon,
                                NULL,       // no class name, using GUID
                                pqsReqInfo->lpServiceClassId,
                                & count,
                                NULL        // class DN not required 
                                );
                if ( status != NO_ERROR )
                {
                    goto Exit;
                }
                if ( count == 0 )
                {
                    status = WSA_INVALID_PARAMETER;
                    goto Exit;
                }
                DNS_ASSERT( count == 1 );

                status = AddServiceInstance(
                                prnrCon,
                                pqsReqInfo->lpszServiceInstanceName,
                                pqsReqInfo->lpServiceClassId,
                                pqsReqInfo->lpVersion,
                                pqsReqInfo->lpszComment,
                                & pdnArray
                                );
                if ( status != NO_ERROR )
                {
                    goto Exit;
                }
            }

            //
            //  add CSADDR_INFO
            //  to an Octet string, then try add it.
            //

            for ( iter = 0; iter < pqsReqInfo->dwNumberOfCsAddrs; iter++ )
            {
                status = ModifyAddressInServiceInstance(
                                prnrCon,
                                pdnArray->Strings[0],
                                & pqsReqInfo->lpcsaBuffer[iter],
                                TRUE        // add address
                                );
                if ( status != NO_ERROR )
                {
                    goto Exit;
                }
            }
            break;

        case RNRSERVICE_DEREGISTER:
        case RNRSERVICE_DELETE:

            status = FindServiceInstance(
                            prnrCon,
                            pqsReqInfo->lpszServiceInstanceName,
                            pqsReqInfo->lpServiceClassId,
                            pqsReqInfo->lpVersion,
                            NULL,           // no context
                            FALSE,          // one level search
                            NULL,           // don't need count
                            & pdnArray      // get DN array
                            );

            if ( status != NO_ERROR )
            {
                goto Exit;
            }
            if ( !pdnArray )
            {
                //  no service instance of given name found
                status = WSATYPE_NOT_FOUND;
                goto Exit;
            }
            DNS_ASSERT( pdnArray->Count == 1 );

            //
            //  delete each CSADDR_INFO in pqsReqInfo from service instance
            //

            for ( iter = 0; iter < pqsReqInfo->dwNumberOfCsAddrs; iter++ )
            {
                status = ModifyAddressInServiceInstance(
                                prnrCon,
                                pdnArray->Strings[0],
                                & pqsReqInfo->lpcsaBuffer[iter],
                                FALSE           // remove address
                                );
                if ( status != NO_ERROR )
                {
                    goto Exit;
                }
            }

            //
            //  delete service?
            //      - RNRSERVICE_DELETE operation
            //      - no addresses on ServiceInstance object
            //      => then delete the serviceInstance
            //
            //  DCR_QUESTION:  RNRSERVICE_DELETE doesn't whack service
            //      regardless of existing CSADDRs?
            //

            if ( essOperation == RNRSERVICE_DELETE )
            {
                status = GetAddressCountFromServiceInstance(
                                          prnrCon,
                                          pdnArray->Strings[0],
                                          & count );
                if ( status != NO_ERROR )
                {
                    goto Exit;
                }
                if ( count == 0 )
                {
                    status = ldap_delete_s(
                                    prnrCon->pLdapServer,
                                    pdnArray->Strings[0] );

                    if ( status != NO_ERROR )
                    {
                        WINRNR_PRINT((
                            "WINRNR!NTDS_SetService - ldap_delete_s()\n"
                            "failed with error code: 0%x\n",
                            status ));
                        status = WSAEACCES;
                        goto Exit;
                    }
                }
            }
            break;

        default :
            status = WSA_INVALID_PARAMETER;
            goto Exit;
    }


Exit:

    DNSDBG( TRACE, (
        "Leave NTDS_SetService() => %d\n",
        status ));

    FreeDnArray( pdnArray );

    DisconnectFromLDAPDirectory( &prnrCon );

    return( SetError(status) );
}



INT
WINAPI
NTDS_LookupServiceBegin(
    IN      PGUID                   pProviderId,
    IN      PWSAQUERYSETW           pqsRestrictions,
    IN      PWSASERVICECLASSINFOW   pServiceClassInfo,
    IN      DWORD                   dwControlFlags,
    OUT     PHANDLE                 phLookup
    )
/*++

Routine Description:

    Start an NTDS service query.

Arguments:

    pProviderId -- provider GUID

    pqsRestrictions -- restrictions on query

    pServiceClassInfo -- service class info blob

    dwControlFlags -- query control flags

    phLookup -- addr to recv RnR lookup handle

Return Value:

    NO_ERROR if successful.
    SOCKET_ERROR on failure.  GetLastError() contains status.

--*/
{
    RNR_STATUS      status = NO_ERROR;
    PRNR_LOOKUP     prnr = NULL;
    DWORD           iter;
    PWSTR           pstring;
    PBYTE           pmem;
    PGUID           pclassGuid;

    DNSDBG( TRACE, (
        "NTDS_LookupServiceBegin()\n"
        "\tpProviderGuid        = %p\n"
        "\tpqsRestrictions      = %p\n"
        "\tpServiceClassInfo    = %p\n"
        "\tControlFlags         = %08x\n",
        pProviderId,
        pqsRestrictions,
        pServiceClassInfo,
        dwControlFlags ));

    IF_DNSDBG( TRACE )
    {
        DnsDbg_Lock();
        DnsDbg_Guid(
            "LookupServiceBegin  Provider GUID:",
            pProviderId
            );
        DnsDbg_WsaQuerySet(
            "LookupServiceBegin  QuerySet:",
            pqsRestrictions,
            TRUE    // unicode
            );
        DnsDbg_WsaServiceClassInfo(
            "LookupServiceBegin  ServiceClassInfo:",
            pServiceClassInfo,
            TRUE        // unicode
            );
        DnsDbg_Unlock();
    }

    //
    //  parameter validation
    //

    if ( !pqsRestrictions  ||
         !pProviderId      ||
         !pqsRestrictions->lpServiceClassId )
    {
        status = WSA_INVALID_PARAMETER;
        goto Failed;
    }

    if ( pqsRestrictions->dwNameSpace != NS_ALL &&
         pqsRestrictions->dwNameSpace != NS_NTDS )
    {
        status = WSAEINVAL;
        goto Failed;
    }

    //
    //  if known DNS lookup -- you're in the wrong provider
    //

    pclassGuid = pqsRestrictions->lpServiceClassId;

    if ( GuidEqual( pclassGuid, &HostAddrByInetStringGuid ) ||
         GuidEqual( pclassGuid, &ServiceByNameGuid ) ||
         GuidEqual( pclassGuid, &HostAddrByNameGuid ) ||
         GuidEqual( pclassGuid, &HostNameGuid ) ||
         IS_SVCID_DNS( pclassGuid ) )
    {
        status = WSASERVICE_NOT_FOUND;
        goto Failed;
    }

    if ( !( dwControlFlags & LUP_CONTAINERS ) &&
         pqsRestrictions->lpszServiceInstanceName == NULL )
    {
        status = WSA_INVALID_PARAMETER;
        goto Failed;
    }

    DNSDBG( TRACE, (
        "VALID LookupServiceBegin ...\n" ));

    //
    // If were not enumerating containers, we need to test to see if name
    // is TCPs (DNS).
    //

    if ( !( dwControlFlags & LUP_CONTAINERS ) )
    {
        //
        // Need to test the ppwsServiceName to see if it is the same
        // as that of the local machine name. If it is, then we return with
        // an error since we don't know how to handle this scenario.
        //
        //  DCR:  fix local name compare
        //  DCR:  this doesn't work on local name as service instance!!!!
        //

        if ( !g_pHostName )
        {
            g_pHostName = DnsQueryConfigAlloc(
                                DnsConfigHostName_W,
                                NULL );
        }
        if ( DnsNameCompare_W(
                pqsRestrictions->lpszServiceInstanceName,
                g_pHostName ) )
        {
            status = WSA_INVALID_PARAMETER;
            goto Failed;
        }

        //
        // Need to test the ppwsServiceName to see if it is the same
        // as that of the local machine's DNS name. If it is, then we return with
        // an error since we don't know how to handle this scenario.
        //

        if ( !g_pFullName )
        {
            g_pFullName = DnsQueryConfigAlloc(
                                DnsConfigFullHostName_W,
                                NULL );
        }
        if ( DnsNameCompare_W(
                pqsRestrictions->lpszServiceInstanceName,
                g_pFullName ) )
        {
            status = WSA_INVALID_PARAMETER;
            goto Failed;
        }
    }

    if ( pqsRestrictions->dwSize != sizeof( WSAQUERYSET ) )
    {
        status = WSAVERNOTSUPPORTED;
        goto Failed;
    }

    if ( pqsRestrictions->lpNSProviderId &&
         !GuidEqual( pqsRestrictions->lpNSProviderId, pProviderId ) )
    {
        status = WSAEINVALIDPROVIDER;
        goto Failed;
    }

    //
    //  create RnR lookup context
    //

    prnr = (PRNR_LOOKUP) ALLOC_HEAP_ZERO( sizeof(RNR_LOOKUP) );
    if ( !prnr )
    {
        status = ERROR_NO_MEMORY;
        goto Failed;
    }

    prnr->Signature = RNR_SIGNATURE;
    prnr->ControlFlags = dwControlFlags;

    //
    //  copy subfields
    //      - service class GUID and version have buffers in RnR blob
    //      - instance name, context, proto array we alloc
    //

    RtlCopyMemory(
            &prnr->ProviderGuid,
            pProviderId,
            sizeof(GUID) );

    if ( pqsRestrictions->lpServiceClassId )
    {
        RtlCopyMemory(
            &prnr->ServiceClassGuid,
            pqsRestrictions->lpServiceClassId,
            sizeof(GUID) );
    }

    if ( pqsRestrictions->lpVersion )
    {
        RtlCopyMemory(
            &prnr->WsaVersion,
            pqsRestrictions->lpVersion,
            sizeof(WSAVERSION) );
        prnr->pVersion = &prnr->WsaVersion;
    }

    if ( pqsRestrictions->lpszServiceInstanceName )
    {
        pstring = Dns_CreateStringCopy_W( 
                        pqsRestrictions->lpszServiceInstanceName );
        if ( !pstring )
        {
            status = ERROR_NO_MEMORY;
            goto Failed;
        }
        prnr->pwsServiceName = pstring;
    }

    if ( pqsRestrictions->lpszContext )
    {
        pstring = Dns_CreateStringCopy_W( 
                        pqsRestrictions->lpszContext );
        if ( !pstring )
        {
            status = ERROR_NO_MEMORY;
            goto Failed;
        }
        prnr->pwsContext = pstring;
    }

    if ( pqsRestrictions->dwNumberOfProtocols > 0 )
    {
        pmem = Dns_AllocMemCopy(
                    pqsRestrictions->lpafpProtocols,
                    pqsRestrictions->dwNumberOfProtocols * sizeof(AFPROTOCOLS) );
        if ( !pmem )
        {
            status = ERROR_NO_MEMORY;
            goto Failed;
        }
        prnr->pafpProtocols = (LPAFPROTOCOLS) pmem;
        prnr->NumberOfProtocols = pqsRestrictions->dwNumberOfProtocols;
    }

    *phLookup = (HANDLE) prnr;

    DNSDBG( TRACE, (
        "Leave NTDS_LookupServiceBegin() => Success\n"
        "\tpRnr     = %p\n",
        prnr ));

    IF_DNSDBG( TRACE )
    {
        DnsDbg_RnrLookup( "RnR Lookup Handle:", prnr );
    }
    return  NO_ERROR;


Failed:

    FreeRnrLookup( prnr );
    
    DNSDBG( TRACE, (
        "Leave NTDS_LookupServiceBegin() => %d\n",
        status ));

    return  SetError(status);
}



INT
WINAPI
NTDS_LookupServiceNext(
    IN      HANDLE          hLookup,
    IN      DWORD           dwControlFlags,
    IN OUT  PDWORD          pdwBufferLength,
    OUT     PWSAQUERYSETW   pqsResults
    )
/*++

Routine Description:

    Execute NTDS name space service query.

    Queries for next instance result of query.

Arguments:

    hLookup -- RnR lookup handle from NTDS_LookupServiceBegin

    dwControlFlags -- control flags on query

    pdwBufSize -- addr with and to recv buffer size
        input:      buffer size
        output:     bytes required or written

    pqsResults -- query set buffer
        input:      ignored
        output:     filled in with query set results;  subfield data follows
                    WSASQUERYSET struct

Return Value:

    NO_ERROR if successful.
    SOCKET_ERROR on failure.  GetLastError() contains status.
        WSA_E_NO_MORE -- if no more results for query
        WSASERVICE_NOT_FOUND -- if no results found for query

--*/
{
    RNR_STATUS      status = NO_ERROR;
    PRNR_LOOKUP     prnr = (PRNR_LOOKUP) hLookup;
    PDN_ARRAY       pdnArray = NULL;


    DNSDBG( TRACE, (
        "NTDS_LookupServiceNext()\n"
        "\tpRnr             = %p\n"
        "\tControlFlags     = %08x\n"
        "\tpdwBufLength     = %p (len=%d)\n"
        "\tpResultBuffer    = %p\n",
        hLookup,
        dwControlFlags,
        pdwBufferLength,
        pdwBufferLength ? *pdwBufferLength : 0,
        pqsResults ));


    //
    //  validate RnR handle
    //

    if ( !prnr ||
         prnr->Signature != RNR_SIGNATURE )
    {
        DNSDBG( ANY, (
            "ERROR:  Invalid RnR lookup handle!\n"
            "\thandle   = %p\n"
            "\tsig      = %p\n",
            prnr,
            prnr ? prnr->Signature : 0 ));

        DNS_ASSERT( !prnr || prnr->Signature != RNR_SIGNATURE_FREE );
        status = WSA_INVALID_HANDLE;
        goto Exit;
    }

    IF_DNSDBG( TRACE )
    {
        DnsDbg_RnrLookup(
            "LookupServiceNext RnR Handle:",
            prnr );
    }

    //
    //  if no connection -- first LookupServiceNext
    //      - connect to directory
    //      - do search for desired objects
    //

    if ( !prnr->pRnrConnection )
    {
        status = ConnectToDefaultLDAPDirectory(
                        TRUE,
                        &prnr->pRnrConnection );

        if ( status != NO_ERROR )
        {
            goto Exit;
        }

        //
        //  LUP_CONTAINERS
        //      - search for subordinate container objects to
        //      prnr->ServiceInstanceName
        //
    
        if ( prnr->ControlFlags & LUP_CONTAINERS )
        {
            status = FindSubordinateContainers(
                        prnr->pRnrConnection,
                        prnr->pwsServiceName,
                        ( (prnr->ControlFlags & LUP_DEEP) &&
                                    !prnr->pwsContext )
                            ? prnr->pRnrConnection->DomainDN
                            : prnr->pwsContext,
                        ( prnr->ControlFlags & LUP_DEEP )
                            ? TRUE
                            : FALSE,
                        & pdnArray );
        }

        //
        //  not LUP_CONTAINERS -- find service instance
        //

        else
        {
            status = FindServiceInstance(
                        prnr->pRnrConnection,
                        prnr->pwsServiceName,
                        &prnr->ServiceClassGuid,
                        prnr->pVersion,
                        ( (prnr->ControlFlags & LUP_DEEP) &&
                                !prnr->pwsContext )
                            ? prnr->pRnrConnection->DomainDN
                            : prnr->pwsContext,
                        (prnr->ControlFlags & LUP_DEEP)
                            ? TRUE
                            : FALSE,
                        NULL,           // don't need count
                        &pdnArray );
        }

        if ( status != NO_ERROR )
        {
            goto Exit;
        }
    
        //  if couldn't find container or service instance -- bail
    
        if ( !pdnArray )
        {
            status = WSASERVICE_NOT_FOUND;
            goto Exit;
        }

        //  save DN array to lookup blob
        //      - need on next LookupServiceNext call

        prnr->pDnArray = pdnArray;
    }

    //
    //  have DN array
    //      - from search above
    //      - or previous LookupServiceNext() call
    //

    pdnArray = prnr->pDnArray;
    if ( !pdnArray )
    {
        DNS_ASSERT( FALSE );
        status = WSA_E_NO_MORE;
        goto Exit;
    }

    if ( dwControlFlags & LUP_FLUSHPREVIOUS )
    {
        prnr->CurrentDN++;

        DNSDBG( TRACE, (
            "NTDS_LookupServiceNext() -- flushing previous\n"
            "\tDN index now %d\n",
            prnr->CurrentDN ));
    }

    //
    //  loop until successfully read info from DN
    //

    while ( 1 )
    {
        PWSTR   preadDn;

        if ( pdnArray->Count <= prnr->CurrentDN )
        {
            DNSDBG( TRACE, (
                "NTDS_LookupServiceNext() -- used all the DNs\n"
                "\tDN index now %d\n",
                prnr->CurrentDN ));
            status = WSA_E_NO_MORE;
            goto Exit;
        }
        preadDn = pdnArray->Strings[ prnr->CurrentDN ];
    
        //
        //  read properties and write to query set
        //
        //  LUP_CONTAINERS
        //      - from container
        //  not LUP_CONTAINERS
        //      - service instance
        //

        status = ReadQuerySet(
                    prnr,
                    preadDn,
                    pdwBufferLength,
                    pqsResults );

        //  if successful, return

        if ( status == NO_ERROR )
        {
            prnr->CurrentDN++;
            goto Exit;
        }

        //  if out of addresses, continue

        if ( status == WSANO_ADDRESS )
        {
            prnr->CurrentDN++;
            status = NO_ERROR;
            continue;
        }
        break;      //  other errors are terminal
    }

Exit:

    DNSDBG( TRACE, (
        "Leave NTDS_LookupServiceNext() => %d\n"
        "\tpRnr             = %p\n"
        "\t  DN Array       = %p\n"
        "\t  DN Index       = %d\n"
        "\tbufLength        = %d\n",
        status,
        hLookup,
        prnr->pDnArray,
        prnr->CurrentDN,
        pdwBufferLength ? *pdwBufferLength : 0
        ));

    if ( status != NO_ERROR )
    {
        SetLastError( status );
        status = SOCKET_ERROR;
    }

    return( status );
}



INT
WINAPI
NTDS_LookupServiceEnd(
    IN      HANDLE          hLookup
    )
/*++

Routine Description:

    End\cleanup query on RnR handle.

Arguments:

    hLookup -- RnR query handle from NTDS_LookupServiceBegin

Return Value:

    NO_ERROR if successful.
    SOCKET_ERROR on failure.  GetLastError() contains status.

--*/
{
    PRNR_LOOKUP prnr = (PRNR_LOOKUP) hLookup;

    DNSDBG( TRACE, (
        "NTDS_LookupServiceEnd( %p )\n",
        hLookup ));

    //
    //  validate lookup handle
    //      - close LDAP connection
    //      - free lookup blob
    //

    if ( !prnr ||
         prnr->Signature != RNR_SIGNATURE )
    {
        DNS_ASSERT( prnr && prnr->Signature == RNR_SIGNATURE_FREE );
        return  SetError( WSA_INVALID_HANDLE );
    }

    DisconnectFromLDAPDirectory( & prnr->pRnrConnection );

    FreeRnrLookup( prnr );

    return( NO_ERROR );
}



//
//  NSP defintion
//

NSP_ROUTINE nsrVector =
{
    FIELD_OFFSET( NSP_ROUTINE, NSPIoctl ),
    1,                                    // major version
    1,                                    // minor version
    NTDS_Cleanup,
    NTDS_LookupServiceBegin,
    NTDS_LookupServiceNext,
    NTDS_LookupServiceEnd,
    NTDS_SetService,
    NTDS_InstallServiceClass,
    NTDS_RemoveServiceClass,
    NTDS_GetServiceClassInfo
};


INT
WINAPI
NSPStartup(
    IN      PGUID           pProviderId,
    OUT     LPNSP_ROUTINE   psnpRoutines
    )
/*++

Routine Description:

    Main NTDS provider entry point.

    This exposes the NTDS provider to the world.

Arguments:

    pProviderId -- provider GUID

    psnpRoutines -- address to receive the NTDS provider definition
        (the NSP table);

Return Value:

    None

--*/
{
    DNSDBG( TRACE, (
        "NSPStartup( %p %p )\n",
        pProviderId,
        psnpRoutines ));
    IF_DNSDBG( TRACE )
    {
        DnsDbg_Guid(
            "NSPStartup()  Provider GUID:",
            pProviderId );
    }

    //
    //  copy NTDS RnR NSP table to caller
    //

    RtlCopyMemory( psnpRoutines, &nsrVector, sizeof(nsrVector) );

    return( NO_ERROR );
}



//
//  DLL exports
//
//  Other exports beyond NSPStartup
//

RNR_STATUS
WINAPI
InstallNTDSProvider(
    IN      PWSTR           szProviderName  OPTIONAL,
    IN      PWSTR           szProviderPath  OPTIONAL,
    IN      PGUID           pProviderId     OPTIONAL
    )
/*++

    IN      PWSTR szProviderName OPTIONAL, // NULL defaults to name "NTDS"
    IN      PWSTR szProviderPath OPTIONAL, // NULL defaults to path
                                       // "%SystemRoot%\System32\winrnr.dll"
    IN      PGUID pProviderId OPTIONAL ); // NULL defaults to GUID
                                       // 3b2637ee-e580-11cf-a555-00c04fd8d4ac
--*/
{
    WORD    wVersionRequested;
    WSADATA wsaData;
    INT     err;

    wVersionRequested = MAKEWORD( 1, 1 );

    err = WSAStartup( wVersionRequested, &wsaData );
    if ( err != 0 )
    {
        return( ERROR_ACCESS_DENIED );
    }

    //
    // Confirm that the WinSock DLL supports 1.1.
    // Note that if the DLL supports versions greater
    // than 2.0 in addition to 1.1, it will still return
    // 2.0 in wVersion since that is the version we
    // requested.
    //
    if ( LOBYTE( wsaData.wVersion ) != 1 ||
         HIBYTE( wsaData.wVersion ) != 1 )
    {
        err = ERROR_FILE_NOT_FOUND;
        goto Done;
    }

    err = WSCInstallNameSpace(
                szProviderName ? szProviderName : g_NtdsProviderName,
                szProviderPath ? szProviderPath : g_NtdsProviderPath,
                NS_NTDS,
                0,
                pProviderId ? pProviderId : &g_NtdsProviderGuid );

    if ( err != ERROR_SUCCESS )
    {
        WSCUnInstallNameSpace( pProviderId ? pProviderId : &g_NtdsProviderGuid );

        err = WSCInstallNameSpace(
                    szProviderName ? szProviderName : g_NtdsProviderName,
                    szProviderPath ? szProviderPath : g_NtdsProviderPath,
                    NS_NTDS,
                    0,
                    pProviderId ? pProviderId : &g_NtdsProviderGuid );
        if ( err )
        {
            err = ERROR_BAD_ENVIRONMENT;
        }
    }

Done:

    WSACleanup();
    return( (DWORD)err );
}



RNR_STATUS
WINAPI
RemoveNTDSProvider(
    IN      PGUID           pProviderId OPTIONAL
    )
{
    WORD        wVersionRequested;
    WSADATA     wsaData;
    INT         err;

    wVersionRequested = MAKEWORD( 1, 1 );

    err = WSAStartup( wVersionRequested, &wsaData );
    if ( err != 0 )
    {
        return( ERROR_ACCESS_DENIED );
    }

    //
    // Confirm that the WinSock DLL supports 1.1.
    // Note that if the DLL supports versions greater
    // than 2.0 in addition to 1.1, it will still return
    // 2.0 in wVersion since that is the version we
    // requested.
    //

    if ( LOBYTE( wsaData.wVersion ) != 1 ||
         HIBYTE( wsaData.wVersion ) != 1 )
    {
        WSACleanup();
        return( ERROR_FILE_NOT_FOUND );
    }

    WSCUnInstallNameSpace( pProviderId ? pProviderId : &g_NtdsProviderGuid );

    WSACleanup();

    return( NO_ERROR );
}



//
//  DLL init\cleanup
//

BOOL
InitializeDll(
    IN      HINSTANCE       hInstance,
    IN      DWORD           dwReason,
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Dll init.

Arguments:

    hdll -- instance handle

    dwReason -- reason

    pReserved -- reserved

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    //
    //  process attach
    //      - ignore thread attach\detach
    //

    if ( dwReason == DLL_PROCESS_ATTACH )
    {
        if ( ! DisableThreadLibraryCalls( hInstance ) )
        {
            return( FALSE );
        }

        //
        //  create recurse lock through TLS
        //      - start open
        //

        g_TlsIndex = TlsAlloc();
        if ( g_TlsIndex == 0xFFFFFFFF )
        {
            // Could not allocate a thread table index.
            WINRNR_PRINT(( "WINRNR!InitializeDll - TlsAlloc() failed\n" ));
            return( FALSE );
        }
        if ( !ReleaseRecurseLock( "InitializeDll" ) )
        {
            return( FALSE );
        }

#if DBG
        //
        //  init debug logging
        //      - do for any process beyond simple attach
        //
        //  start logging with log filename generated to be
        //      unique for this process
        //
        //  do NOT put drive specification in the file path
        //  do NOT set the debug flag -- the flag is read from
        //      the winrnr.flag file
        //
        
        {
            CHAR    szlogFileName[ 30 ];
        
            sprintf(
                szlogFileName,
                "winrnr.%d.log",
                GetCurrentProcessId() );
        
             Dns_StartDebug(
                0,
                "winrnr.flag",
                NULL,
                szlogFileName,
                0 );
        }
#endif
    }

    //
    //  process detach
    //      - cleanup IF pReserved==NULL which indicates detach due
    //      to FreeLibrary
    //      - if process is exiting do nothing
    //

    else if ( dwReason == DLL_PROCESS_DETACH
                &&
              pReserved == NULL )
    {
        if ( g_TlsIndex != 0xFFFFFFFF )
        {
            if ( TlsFree( g_TlsIndex ) == FALSE )
            {
                // Could not free thread table index.
                WINRNR_PRINT((
                    "WINRNR!InitializeDll - TlsFree( Index )\n"
                    "failed with error code: 0%x\n",
                    GetLastError() ));
                return( FALSE );
            }
            g_TlsIndex = 0xFFFFFFFF;
        }
    }

    return( TRUE );
}

//
//  End winrnr.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\remove\remove.c ===
#include <winsock2.h>
#include <ws2spi.h>
#include <stdio.h>
#include <stdlib.h>
#include "..\setup.h"


INT
UnInstallTestProviders(void)
{
    INT ReturnCode;

    ReturnCode = WSCUnInstallNameSpace( &gProviderId );

    return(ReturnCode);
}

int __cdecl main( int argc, char**argv )
{
    DWORD NameSpaceId;
    INT   ReturnCode;
    DWORD LastError;

    WORD    wVersionRequested;
    WSADATA wsaData;
    INT     err;

    wVersionRequested = MAKEWORD( 1, 1 );

    err = WSAStartup( wVersionRequested, &wsaData );

    if ( err != 0 )
    {
        //
        // Tell the user that we couldn't find a useable WinSock DLL.
        //
        fprintf( stderr,
                 "Useable Winsock DLL couldn't be found\n" );
        return -1;
    }

    //
    // Confirm that the WinSock DLL supports 1.1.
    // Note that if the DLL supports versions greater
    // than 1.1 in addition to 1.1, it will still return
    // 1.1 in wVersion since that is the version we
    // requested.
    //
    if ( LOBYTE( wsaData.wVersion ) != 1 ||
             HIBYTE( wsaData.wVersion ) != 1 )
    {
        //
        // Tell the user that we couldn't find a useable WinSock DLL.
        //
        fprintf( stderr,
                 "Useable Winsock DLL couldn't be found\n" );
        WSACleanup();
        return -1;
    }

    ReturnCode = UnInstallTestProviders();

    if(ReturnCode != ERROR_SUCCESS)
    {
        fprintf( stderr,
                 "NT5 Uninstall failed \n" );
        return -1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\sample\rnrsrv\rnrsrv.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    RnrSrv.c

Abstract:

    Test and demonstration service for the RNR (service Registration and
    Name Resolution) APIs.  This is a simple service designed to show
    the basic principles involved in using the RNR APIs to _write a
    protocol-independent Windows Sockets service.

    This service opens a number of listening sockets, waits for an
    incoming connection from a client, accepts the connection, then
    echos data back to the client until the client terminates the
    virtual circuit.  This service is single-threaded and can handle
    only a single client at a time.

    The OpenListeners() routine implemented herein is intended to be a
    demonstration of RNR functionality commonly used in
    protocol-independent services.  Service writers are encouraged to
    leverage this code to assist them in writing protocol-independent
    services on top of the Windows Sockets API.

--*/

#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>
#include <nspapi.h>

WSADATA WsaData;

PSTR ServiceTypeName = "EchoExample";
PSTR ServiceName = "EchoServer";

#define MAX_SOCKETS    20

INT
OpenListeners (
    IN PTSTR ServiceName,
    IN LPGUID ServiceType,
    IN BOOL Reliable,
    IN BOOL MessageOriented,
    IN BOOL StreamOriented,
    IN BOOL Connectionless,
    OUT SOCKET SocketHandles[],
    OUT INT ProtocolsUsed[]
    );

INT
AdvertiseService(
    IN PTSTR ServiceName,
    IN LPGUID ServiceType,
    IN SOCKET SocketHandles[],
    IN INT SocketCount
    );


void __cdecl
main (
    int argc,
    char *argv[]
    )
{
    INT count, err, i ;
    DWORD tmpProtocol[2];
    BYTE buffer[1024];
    DWORD bytesRequired;
    PPROTOCOL_INFO protocolInfo;
    GUID serviceType;
    FD_SET readfds;
    SOCKET listenSockets[MAX_SOCKETS+1];
    INT protocols[MAX_SOCKETS+1];
    SOCKET s;

    //
    // Initialize the Windows Sockets DLL.
    //

    err = WSAStartup( 0x0202, &WsaData );

    if ( err == SOCKET_ERROR )
    {
        printf( "WSAStartup() failed: %ld\n", GetLastError( ) );
        return;
    }

    //
    // Determine the value of our GUID.  The GUID uniquely identifies
    // the type of service we provide.
    //

    err = GetTypeByName( ServiceTypeName, &serviceType );

    if ( err == SOCKET_ERROR )
    {
        printf( "GetTypeByName for \"%s\" failed: %ld\n",
                    ServiceTypeName, GetLastError( ) );
        exit( 1 );
    }

    //
    // Open listening sockets for this service.
    //

    count = OpenListeners(
                ServiceName,
                &serviceType,
                TRUE,
                FALSE,
                FALSE,
                FALSE,
                listenSockets,
                protocols
                );

    if ( count <= 0 )
    {
        printf( "failed to open listenSockets for name \"%s\" type \"%s\"\n",
                    ServiceName, ServiceTypeName );
        exit( 1 );
    }

    //
    // We successfully opened some listening sockets.  Display some
    // information on each protocol in use.
    //

    tmpProtocol[1] = 0;

    for ( i = 0; i < count; i++ )
    {
        tmpProtocol[0] = protocols[i];

        bytesRequired = sizeof(buffer);
        err = EnumProtocols( tmpProtocol, buffer, &bytesRequired );

        if ( err < 1 )
        {
            printf( "EnumProtocols failed for protocol %ld: %ld\n",
                        tmpProtocol[0], GetLastError( ) );
            exit( 1 );
        }

        protocolInfo = (PPROTOCOL_INFO)buffer;
        printf( "Socket %lx listening on protocol \"%s\" (%ld)\n",
                    listenSockets[i],
                    protocolInfo->lpProtocol,
                    protocolInfo->iProtocol );

    }

    //
    // Advertise the service so thet it can be found.
    //
    printf( "Going to advertise the service.\n" ) ;

    err = AdvertiseService(
                ServiceName,
                &serviceType,
                listenSockets,
                count) ;

    if (err == SOCKET_ERROR)
    {
        printf( "Failed to advertise the service. Error %d\n", GetLastError()) ;
        exit( 1 ) ;
    }

    printf( "Successfully advertised the service.\n" ) ;

    //
    // Loop accepting connections and servicing them.
    //

    FD_ZERO( &readfds );

    while ( TRUE )
    {
        //
        // Add the listening sockets to the FD_SET we'll pass to select.
        //

        for ( i = 0; i < count; i++ )
        {
            FD_SET( listenSockets[i], &readfds );
        }

        //
        // Wait for one of the listenSockets to receive an incoming connection.
        //

        err = select( count, &readfds, NULL, NULL, NULL );

        if ( err < 1 )
        {
            printf( "select() returned %ld, error %ld\n", err, GetLastError( ) );
            exit( 1 );
        }

        //
        // Find the socket that received an incoming connection and accept
        // the connection.
        //

        for ( i = 0; i < count; i++ )
        {
            if ( FD_ISSET( listenSockets[i], &readfds ) )
                break;
        }

        //
        // Accept the connection from the client.  We ignore the client's
        // address here.
        //

        s = accept( listenSockets[i], NULL, NULL );

        if ( s == INVALID_SOCKET )
        {
            printf( "accept() failed, error %ld\n", GetLastError( ) );
            exit( 1 );
        }

        printf( "Accepted incoming connection on socket %lx\n",
                listenSockets[i] );

        //
        // Loop echoing data back to the client.  Note that this
        // single-threaded service can handle only a single client at a
        // time.  A more sophisticated service would service multiple
        // clients simultaneously by using multiple threads or
        // asynchronous I/O.
        //

        while ( TRUE )
        {
            err = recv( s, buffer, sizeof(buffer), 0 );
            if ( err == 0 )
            {
                printf( "Connection terminated gracefully.\n" );
                break;
            }
            else if ( err < 0 )
            {
                err = GetLastError();

                if ( err == WSAEDISCON )
                {
                    printf( "Connection disconnected.\n" );
                }
                else
                {
                    printf( "recv() failed, error %ld.\n", err );
                }

                break;
            }

            err = send( s, buffer, err, 0 );

            if ( err < 0 )
            {
                printf( "send() failed, error %ld\n", GetLastError( ) );
                break;
            }
        }

        //
        // Close the connected socket and continue accepting connections.
        //

        closesocket( s );
    }

} // main



INT
OpenListeners (
    IN PTSTR ServiceName,
    IN LPGUID ServiceType,
    IN BOOL Reliable,
    IN BOOL MessageOriented,
    IN BOOL StreamOriented,
    IN BOOL Connectionless,
    OUT SOCKET SocketHandles[],
    OUT INT ProtocolsUsed[]
    )

/*++

Routine Description:

    Examines the Windows Sockets transport protocols loaded on a machine
    and opens listening sockets on all the protocols which support the
    characteristics requested by the caller.

Arguments:

    ServiceName - a friendly name which identifies this service.  On
        name spaces which support name resolution at the service level
        (e.g.  SAP) this is the name clients will use to connect to this
        service.  On name spaces which support name resolution at the
        host level (e.g.  DNS) this name is ignored and applications
        must use the host name to establish communication with this
        service.

    ServiceType - the GUID value which uniquely identifies the type of
        service we provide.  A GUID is created with the UUIDGEN program.

    Reliable - if TRUE, the caller requests that only transport protocols
        which support reliable data delivery be used.  If FALSE, both
        reliable and unreliable protocols may be used.

    MessageOriented - if TRUE, only message-oriented transport protocols
        should be used.  If FALSE, the caller either does not care
        whether the protocols used are message oriented or desires only
        stream-oriented protocols.

    StreamOriented - if TRUE, only stream-oriented transport protocols
        should be used.  If FALSE, the caller either does not care
        whether the protocols used are stream oriented or desires only
        message-oriented protocols.

    Connectionless - if TRUE, only connectionless protocols should be
        used.  If FALSE, both connection-oriented and connectionless
        protocols may be used.

    SocketHandles - an array of size MAX_SOCKETS which receives listening
        socket handles.

    ProtocolsUsed - an array of size MAX_SOCKETS which receives the
        protocol values for each of the socket handles in the
        SocketHandles array.

Return Value:

    The count of listening sockets successfully opened, or -1 if no
    sockets could be successfully opened that met the desired
    characteristics.

--*/

{
    INT            protocols[MAX_SOCKETS+1];
    BYTE           buffer[2048];
    DWORD          bytesRequired;
    INT            err;
    PPROTOCOL_INFO protocolInfo;
    PCSADDR_INFO   csaddrInfo;
    INT            protocolCount;
    INT            addressCount;
    INT            i;
    DWORD          protocolIndex;
    SOCKET         s;
    DWORD          index = 0;

    //
    // First look up the protocols installed on this machine.  The
    // EnumProtocols() API returns about all the Windows Sockets
    // protocols loaded on this machine, and we'll use this information
    // to identify the protocols which provide the necessary semantics.
    //

    bytesRequired = sizeof(buffer);

    err = EnumProtocols( NULL, buffer, &bytesRequired );

    if ( err <= 0 )
    {
        return 0;
    }

    //
    // Walk through the available protocols and pick out the ones which
    // support the desired characteristics.
    //

    protocolCount = err;
    protocolInfo = (PPROTOCOL_INFO)buffer;

    for ( i = 0, protocolIndex = 0;
          i < protocolCount && protocolIndex < MAX_SOCKETS;
          i++, protocolInfo++ )
    {
        //
        // If "reliable" support is requested, then check if supported
        // by this protocol.  Reliable support means that the protocol
        // guarantees delivery of data in the order in which it is sent.
        // Note that we assume here that if the caller requested reliable
        // service then they do not want a connectionless protocol.
        //

        if ( Reliable )
        {
            //
            // Check to see if the protocol is reliable.  It must
            // guarantee both delivery of all data and the order in
            // which the data arrives.  Also, it must not be a
            // connectionless protocol.
            //

            if ( (protocolInfo->dwServiceFlags &
                      XP_GUARANTEED_DELIVERY) == 0 ||
                 (protocolInfo->dwServiceFlags &
                      XP_GUARANTEED_ORDER) == 0 )
            {
                continue;
            }

            if ( (protocolInfo->dwServiceFlags & XP_CONNECTIONLESS) != 0 )
            {
                continue;
            }

            //
            // Check to see that the protocol matches the stream/message
            // characteristics requested.  A stream oriented protocol
            // either has the XP_MESSAGE_ORIENTED bit turned off, or
            // else supports "pseudo stream" capability.  Pseudo stream
            // means that although the underlying protocol is message
            // oriented, the application may open a socket of type
            // SOCK_STREAM and the protocol will hide message boundaries
            // from the application.
            //

            if ( StreamOriented &&
                 (protocolInfo->dwServiceFlags & XP_MESSAGE_ORIENTED) != 0 &&
                 (protocolInfo->dwServiceFlags & XP_PSEUDO_STREAM) == 0 )
            {
                continue;
            }

            if ( MessageOriented &&
                 (protocolInfo->dwServiceFlags & XP_MESSAGE_ORIENTED) == 0 )
            {
                continue;
            }

        }
        else if ( Connectionless )
        {
            //
            // Make sure that this is a connectionless protocol.  In a
            // connectionless protocol, data is sent as discrete
            // datagrams with no connection establishment required.
            // Connectionless protocols typically have no reliability
            // guarantees.
            //

            if ( (protocolInfo->dwServiceFlags & XP_CONNECTIONLESS) != 0 )
            {
                continue;
            }
        }

        //
        // This protocol fits all the criteria.  Add it to the list of
        // protocols in which we're interested.
        //

        protocols[protocolIndex++] = protocolInfo->iProtocol;
    }

    //
    // Make sure that we found at least one acceptable protocol.  If
    // there no protocols on this machine which meet the caller's
    // requirements then fail here.
    //

    if ( protocolIndex == 0 )
    {
        return 0;
    }

    protocols[protocolIndex] = 0;

    //
    // Now attempt to find the socket addresses to which we need to
    // bind.  Note that we restrict the scope of the search to those
    // protocols of interest by passing the protocol array we generated
    // above to GetAddressByName().  This forces GetAddressByName() to
    // return socket addresses for only the protocols we specify,
    // ignoring possible addresses for protocols we cannot support
    // because of the caller's constraints.
    //

    bytesRequired = sizeof(buffer);

    err = GetAddressByName(
               NS_DEFAULT,
               ServiceType,
               ServiceName,
               protocols,
               RES_SERVICE | RES_FIND_MULTIPLE,
               NULL,                     // lpServiceAsyncInfo
               buffer,
               &bytesRequired,
               NULL,                     // lpAliasBuffer
               NULL                      // lpdwAliasBufferLength
               );

    if ( err <= 0 )
    {
        return 0;
    }

    //
    // For each address, open a socket and attempt to listen. Note
    // that if anything fails for a particular protocol we just skip on
    // to the next protocol. As long as we can successfully listen on
    // one protocol we are satisfied here.
    //

    addressCount = err;
    csaddrInfo = (PCSADDR_INFO)buffer;

    for ( i = 0; i < addressCount; i++, csaddrInfo++ )
    {
        //
        // Open the socket. Note that we manually specify stream type
        // if so requested in case the protocol is natively a message
        // protocol but supports stream semantics.
        //

        s = socket( csaddrInfo->LocalAddr.lpSockaddr->sa_family,
                    StreamOriented ? SOCK_STREAM : csaddrInfo->iSocketType,
                    csaddrInfo->iProtocol );

        if ( s == INVALID_SOCKET )
        {
            continue;
        }

        //
        // Bind the socket to the local address specified.
        //

        err = bind( s, csaddrInfo->LocalAddr.lpSockaddr,
                    csaddrInfo->LocalAddr.iSockaddrLength );

        if ( err != NO_ERROR )
        {
            closesocket( s );
            continue;
        }

        //
        // Start listening for incoming sockets on the socket if this is
        // not a datagram socket.  If this is a datagram socket, then
        // the listen() API doesn't make sense; doing a bind() is
        // sufficient to listen for incoming datagrams on a
        // connectionless protocol.
        //

        if ( csaddrInfo->iSocketType != SOCK_DGRAM )
        {
            err = listen( s, 5 );

            if ( err != NO_ERROR )
            {
                closesocket( s );
                continue;
            }
        }

        //
        // The socket was successfully opened and we're listening on it.
        // Remember the protocol used and the socket handle and continue
        // listening on other protocols.
        //

        ProtocolsUsed[index] = csaddrInfo->iProtocol;
        SocketHandles[index] = s;

        index++;
        if ( index == MAX_SOCKETS )
        {
            return index;
        }
    }

    (void) LocalFree( (HLOCAL) csaddrInfo );

    //
    // Return the count of sockets that we're sucecssfully listening on.
    //

    return index;

} // OpenListeners


INT
AdvertiseService(
    IN PTSTR ServiceName,
    IN LPGUID ServiceType,
    IN SOCKET SocketHandles[],
    IN INT SocketCount
    )
/*++

Routine Description:

    Advertises this service on all the default name spaces.

Arguments:

    ServiceName - the name of the service.

    ServiceType - the GUID value which uniquely the service.

    SocketHandles - array of sockets that we have opened. For each socket,
        we do a getsockname() to discover the actual local address.

    SocketCount - number of sockets in SockHandles[]

Return Value:

    0 if success. SOCK_ERROR otherwise.

--*/

{

    WSAVERSION          Version;
    WSAQUERYSET         QuerySet;
    LPCSADDR_INFO       lpCSAddrInfo;
    PSOCKADDR           sockAddr ;
    BYTE *              addressBuffer;
    DWORD               addressBufferSize ;
    DWORD               successCount = 0 ;
    INT                 i, err ;

    //
    // Allocate some memory for the CSADDR_INFO structures.
    //

    lpCSAddrInfo = (LPCSADDR_INFO) malloc( sizeof(CSADDR_INFO) * SocketCount );

    if (!lpCSAddrInfo)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY) ;
        return SOCKET_ERROR ;
    }

    //
    // Allocate some memory for the SOCKADDR addresses returned
    // by getsockname().
    //

    addressBufferSize = SocketCount * sizeof(SOCKADDR);
    addressBuffer = malloc( addressBufferSize ) ;

    if (!addressBuffer)
    {
        free(lpCSAddrInfo) ;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY) ;
        return SOCKET_ERROR ;
    }

    RtlZeroMemory( &QuerySet, sizeof( WSAQUERYSET ) );

    //
    // For each socket, get its local association.
    //

    sockAddr = (PSOCKADDR) addressBuffer ;

    for (i = 0; i < SocketCount; i++)
    {
        int size = (int) addressBufferSize ;

        //
        // Call getsockname() to get the local association for the socket.
        //

        err = getsockname(
                  SocketHandles[i],
                  sockAddr,
                  &size) ;

        if (err == SOCKET_ERROR)
        {
            continue ;
        }

        //
        // Now setup the Addressing information for this socket.
        // Only the dwAddressType, dwAddressLength and lpAddress
        // is of any interest in this example.
        //

        lpCSAddrInfo[i].LocalAddr.iSockaddrLength = size;
        lpCSAddrInfo[i].LocalAddr.lpSockaddr = sockAddr;
        lpCSAddrInfo[i].RemoteAddr.iSockaddrLength = size;
        lpCSAddrInfo[i].RemoteAddr.lpSockaddr = sockAddr;
        lpCSAddrInfo[i].iSocketType = SOCK_RDM; // Reliable
        lpCSAddrInfo[i].iProtocol = sockAddr->sa_family;

        //
        // Advance pointer and adjust buffer size. Assumes that
        // the structures are aligned.
        //

        addressBufferSize -= size ;
        sockAddr = (PSOCKADDR) ((BYTE*)sockAddr + size)  ;

        successCount++ ;
    }

    //
    // If we got at least one address, go ahead and advertise it.
    //

    if (successCount)
    {
        QuerySet.dwSize = sizeof( WSAQUERYSET );
        QuerySet.lpServiceClassId = ServiceType;
        QuerySet.lpszServiceInstanceName = ServiceName;
        QuerySet.lpszComment = "D/C/M's Example Echo Service";
        QuerySet.lpVersion = &Version;
        QuerySet.lpVersion->dwVersion = 1;
        QuerySet.lpVersion->ecHow = COMP_NOTLESS;
        QuerySet.dwNameSpace = NS_ALL;
        QuerySet.dwNumberOfCsAddrs = successCount;
        QuerySet.lpcsaBuffer = lpCSAddrInfo;

        err = WSASetService( &QuerySet,
                             RNRSERVICE_REGISTER,
                             SERVICE_MULTIPLE );

        if ( err )
            err = SOCKET_ERROR;
    }
    else
        err = SOCKET_ERROR ;

    free (addressBuffer) ;

    return (err) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\ats.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>
#include "..\setup.h"


#define BUFFSIZE 3000

char HexCharToDec(char cChar)
{
    if(cChar >= '0' && cChar <= '9')
        return cChar - '0';
    else
        if(cChar >= 'a' && cChar <= 'f')
            return cChar - 'a' + 10;
        else
            if(cChar >= 'A' && cChar <= 'F')
                return cChar - 'A' + 10;
            else
                return -1;
}

int HexFillMem(LPVOID lpAddr, LPSTR lpszString)
{
    BOOL    bHexString = TRUE;
    UINT    uIdx;
    u_char  *lpChar = (u_char *)lpAddr;

    if(1 == strlen(lpszString)%2)
        bHexString = FALSE;
    else
        for (uIdx = 0; uIdx < strlen(lpszString); uIdx++)
            if(!(lpszString[uIdx] >= '0' && lpszString[uIdx] <= '9' ||
                 lpszString[uIdx] >= 'a' && lpszString[uIdx] <= 'f' ||
                 lpszString[uIdx] >= 'A' && lpszString[uIdx] <= 'F'))
                bHexString = FALSE;
    if(!bHexString)
        return -1;

    for(uIdx = 0; uIdx < strlen(lpszString)/2; uIdx++)
        *(lpChar + uIdx) = 16*HexCharToDec(lpszString[2*uIdx])+HexCharToDec(lpszString[2*uIdx+1]);

    return 0;
}


_cdecl
main(int argc, char **argv)
{
    DWORD              dwAddrSize = BUFFSIZE;
    WCHAR              AddressString[BUFFSIZE];
    DWORD              ret;
    WSADATA            wsaData;
    SOCKADDR_IN        SockAddrTCP;
    SOCKADDR_IPX       SockAddrIPX;
    WSAPROTOCOL_INFO   wsaProtocolInfoTCP[5];
    WSAPROTOCOL_INFO   wsaProtocolInfoIPX[5];
    int                Result;
    int                rgProtocol[2];
    DWORD              dwBufLen;
    LPWSAPROTOCOL_INFO lpProtInf = NULL;

    WSAStartup( MAKEWORD(2, 0), &wsaData );

    rgProtocol[1] = 0;

    SockAddrTCP.sin_family = AF_INET;
    SockAddrTCP.sin_port = 80;
    SockAddrTCP.sin_addr.s_addr = inet_addr("157.55.80.37");

    rgProtocol[0] = IPPROTO_TCP;
    dwBufLen = 5*sizeof( WSAPROTOCOL_INFO );
    Result = WSAEnumProtocols( rgProtocol,
                               wsaProtocolInfoTCP,
                               &dwBufLen);

    if ( Result != SOCKET_ERROR )
        lpProtInf = wsaProtocolInfoTCP;
    else
    {
        printf( "WSAEnumProtocols failed 0x%.8x", WSAGetLastError() );
    }

    ret = WSAAddressToString( &SockAddrTCP,
                              sizeof( SOCKADDR_IN ),
                              NULL,
                              AddressString,
                              &dwAddrSize );

    if ( ret )
    {
        printf("Error: WSAAddressToString returned 0x%X\n", ret );
        printf("   GetLastError returned 0x%X\n", GetLastError() );
    }
    else
    {
        printf( "WSAAddressToString returned <%S>\n", AddressString );
    }

    SockAddrIPX.sa_family = AF_IPX;
    HexFillMem( SockAddrIPX.sa_netnum, "00002602" );
    HexFillMem( SockAddrIPX.sa_nodenum, "00a0c95ec894" );
    SockAddrIPX.sa_socket = 80;

    ret = WSAAddressToString( &SockAddrIPX,
                              sizeof( SOCKADDR_IPX ),
                              NULL,
                              AddressString,
                              &dwAddrSize );

    if ( ret )
    {
        printf("Error: WSAAddressToString returned 0x%X\n", ret );
        printf("   GetLastError returned 0x%X\n", GetLastError() );
    }
    else
    {
        printf( "WSAAddressToString returned <%S>\n", AddressString );
    }

    WSACleanup();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\install\install.c ===
#include <winsock2.h>
#include <ws2spi.h>
#include <stdio.h>
#include <stdlib.h>
#include "..\setup.h"


INT
InstallNT5Provider()
{
    INT   ReturnCode;
    BOOL  ReturnValue = FALSE;
    DWORD NameSpaceId;

    NameSpaceId = NS_NTDS;

    ReturnCode = WSCInstallNameSpace( gProviderName,
                                      gProviderPath,
                                      NameSpaceId,
                                      0,
                                      &gProviderId );

    return ReturnCode;
}


int __cdecl main(int argc, char**argv)
{
    DWORD NameSpaceId;
    WORD  ReturnCode;
    DWORD LastError;

    WORD    wVersionRequested;
    WSADATA wsaData;
    WORD    err;

    wVersionRequested = MAKEWORD( 1, 1 );
    err = WSAStartup( wVersionRequested, &wsaData );
    if ( err != 0 )
    {
        //
        // Tell the user that we couldn't find a useable WinSock DLL.
        //
        fprintf( stderr, "Winsock DLL couldn't be found\n" );
        return( -1 );
    }

    //
    // Confirm that the WinSock DLL supports 1.1.
    // Note that if the DLL supports versions greater
    // than 2.0 in addition to 1.1, it will still return
    // 2.0 in wVersion since that is the version we
    // requested.
    //
    if ( LOBYTE( wsaData.wVersion ) != 1 ||
             HIBYTE( wsaData.wVersion ) != 1 )
    {
        //
        // Tell the user that we couldn't find a useable WinSock DLL.
        //
        fprintf( stderr, "Winsock DLL couldn't be found\n" );
        WSACleanup();
        return( -1 );
    }

    //
    // Install the providers for this test
    //
    if( ( ReturnCode = InstallNT5Provider() ) != ERROR_SUCCESS )
    {
        fprintf( stderr,
                 "NT5 Uninstall failed; error code = %d \n",
                 ReturnCode);

        return( -1 );
    }

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\delete.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


GUID    ServiceClassId = { /* 5b50962a-e5a5-11cf-a555-00c04fd8d4ac */
    0x5b50962a,
    0xe5a5,
    0x11cf,
    {0xa5, 0x55, 0x00, 0xc0, 0x4f, 0xd8, 0xd4, 0xac}
  };

WCHAR   ServiceInstanceName[] = L"GlennC on GLENNC_PRO";

_cdecl
main(int argc, char **argv)
{
    DWORD               ret;
    WSADATA             wsaData;
    WSAQUERYSET         QuerySet;
    CSADDR_INFO         CSAddrInfo[6];
    SOCKADDR            SocketAddress1;
    SOCKADDR            SocketAddress2;
    SOCKADDR            SocketAddress3;
    SOCKADDR            SocketAddress4;
    SOCKADDR            SocketAddress5;
    ANSI_STRING         asServiceInstanceName;
    UNICODE_STRING      usServiceInstanceName;
    WCHAR               UnicodeStringBuf[1024];

    if ( argc == 2 )
    {
        usServiceInstanceName.Length = 0;
        usServiceInstanceName.MaximumLength = 1024;
        usServiceInstanceName.Buffer = UnicodeStringBuf;

        RtlInitAnsiString( &asServiceInstanceName, argv[1] );

        RtlAnsiStringToUnicodeString( &usServiceInstanceName,
                                      &asServiceInstanceName,
                                      FALSE );
    }

    RtlZeroMemory( (LPBYTE) &QuerySet, sizeof( WSAQUERYSET ) );
    RtlZeroMemory( (LPBYTE) &CSAddrInfo[0], sizeof( CSADDR_INFO ) );
    RtlZeroMemory( (LPBYTE) &CSAddrInfo[1], sizeof( CSADDR_INFO ) );
    RtlZeroMemory( (LPBYTE) &CSAddrInfo[2], sizeof( CSADDR_INFO ) );
    RtlZeroMemory( (LPBYTE) &CSAddrInfo[3], sizeof( CSADDR_INFO ) );
    RtlZeroMemory( (LPBYTE) &CSAddrInfo[4], sizeof( CSADDR_INFO ) );
    RtlZeroMemory( (LPBYTE) &CSAddrInfo[5], sizeof( CSADDR_INFO ) );

    SocketAddress1.sa_family = AF_UNIX;
    RtlFillMemory( (LPBYTE) &SocketAddress1.sa_data, 14, 1 );

    SocketAddress2.sa_family = AF_INET;
    RtlFillMemory( (LPBYTE) &SocketAddress2.sa_data, 14, 2 );

    SocketAddress3.sa_family = AF_IPX;
    RtlFillMemory( (LPBYTE) &SocketAddress3.sa_data, 14, 6 );

    SocketAddress4.sa_family = AF_ISO;
    RtlFillMemory( (LPBYTE) &SocketAddress4.sa_data, 14, 7 );

    SocketAddress5.sa_family = AF_ECMA;
    RtlFillMemory( (LPBYTE) &SocketAddress5.sa_data, 14, 8 );

    CSAddrInfo[0].LocalAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[0].LocalAddr.lpSockaddr = &SocketAddress2;
    CSAddrInfo[0].RemoteAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[0].RemoteAddr.lpSockaddr = &SocketAddress2;
    CSAddrInfo[0].iSocketType = SOCK_RAW;
    CSAddrInfo[0].iProtocol = PF_INET;

    CSAddrInfo[1].LocalAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[1].LocalAddr.lpSockaddr = &SocketAddress2;
    CSAddrInfo[1].RemoteAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[1].RemoteAddr.lpSockaddr = &SocketAddress2;
    CSAddrInfo[1].iSocketType = SOCK_STREAM;
    CSAddrInfo[1].iProtocol = PF_INET;

    CSAddrInfo[2].LocalAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[2].LocalAddr.lpSockaddr = &SocketAddress1;
    CSAddrInfo[2].RemoteAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[2].RemoteAddr.lpSockaddr = &SocketAddress1;
    CSAddrInfo[2].iSocketType = SOCK_STREAM;
    CSAddrInfo[2].iProtocol = PF_UNIX;

    CSAddrInfo[3].LocalAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[3].LocalAddr.lpSockaddr = &SocketAddress3;
    CSAddrInfo[3].RemoteAddr.iSockaddrLength = 0;
    CSAddrInfo[3].RemoteAddr.lpSockaddr = NULL;
    CSAddrInfo[3].iSocketType = SOCK_STREAM;
    CSAddrInfo[3].iProtocol = PF_IPX;

    CSAddrInfo[4].LocalAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[4].LocalAddr.lpSockaddr = &SocketAddress4;
    CSAddrInfo[4].RemoteAddr.iSockaddrLength = 0;
    CSAddrInfo[4].RemoteAddr.lpSockaddr = NULL;
    CSAddrInfo[4].iSocketType = SOCK_STREAM;
    CSAddrInfo[4].iProtocol = PF_ISO;

    CSAddrInfo[5].LocalAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[5].LocalAddr.lpSockaddr = &SocketAddress5;
    CSAddrInfo[5].RemoteAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[5].RemoteAddr.lpSockaddr = &SocketAddress5;
    CSAddrInfo[5].iSocketType = SOCK_STREAM;
    CSAddrInfo[5].iProtocol = PF_ECMA;

    QuerySet.dwSize = sizeof( WSAQUERYSET );
    QuerySet.lpServiceClassId = &ServiceClassId;
    if ( argc == 2 )
    {
        QuerySet.lpszServiceInstanceName = usServiceInstanceName.Buffer;
    }
    else
    {
        QuerySet.lpszServiceInstanceName = ServiceInstanceName;
    }
    QuerySet.dwNameSpace = NS_ALL;
    QuerySet.dwNumberOfCsAddrs = 6;
    QuerySet.lpcsaBuffer = &CSAddrInfo;
    
    WSAStartup( MAKEWORD(1, 1), &wsaData );

    ret = WSASetService( &QuerySet,
                         RNRSERVICE_DELETE,
                         SERVICE_MULTIPLE );

    if ( ret )
    {
        printf("Error: WSASetService returned 0x%X\n", ret );
        printf("   GetLastError returned 0x%X\n", GetLastError() );

        WSACleanup();

        return -1;
    }

    printf( "SetService was successful.\n" );

    WSACleanup();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\ghba.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <nspapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


_cdecl
main(int argc, char **argv)
{
    WSADATA          wsaData;
    struct hostent * lpHostEnt;
    BYTE             AddrBuffer[1000];
    BYTE             AliasBuffer[1000];
    DWORD            AddrBufLen = 1000;
    DWORD            AliasBufLen = 1000;
    LPCSADDR_INFO    lpCSAddrInfo = (LPCSADDR_INFO) AddrBuffer;
    LPSTR            lpAliases = (LPSTR) AliasBuffer;
    GUID             dnsGuid = SVCID_DOMAIN_TCP;
    char **          ppHostAliases;
    LPSTR            lpTemp = NULL, lpAddress = NULL;
    BYTE             Part1, Part2, Part3, Part4;
    DWORD            Address;

    if ( argc != 2 )
    {
        printf( "\nUseage: ghbn <Address>\n" );
        return( -1 );
    }

    lpAddress = argv[1];

    lpTemp = strtok( lpAddress, "." );
    Part1 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part2 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part3 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part4 = atoi( lpTemp );

    ((LPBYTE) &Address)[0] = Part1;
    ((LPBYTE) &Address)[1] = Part2;
    ((LPBYTE) &Address)[2] = Part3;
    ((LPBYTE) &Address)[3] = Part4;

    WSAStartup( MAKEWORD(1, 1), &wsaData );

    lpHostEnt = gethostbyaddr( &Address, 4, 0 );

    if ( lpHostEnt )
    {
        DWORD iter = 0;

        printf( "\nHost address found for IP address %d.%d.%d.%d.\n",
                Part1, Part2, Part3, Part4 );
        printf( "Official name of host: %s\n", lpHostEnt->h_name );
        ppHostAliases = lpHostEnt->h_aliases;

        while ( *ppHostAliases )
            printf( "Alias name: %s\n", *ppHostAliases++ );

        printf( "Host address type: %d\n", lpHostEnt->h_addrtype );
        printf( "Length of addresses: %d\n", lpHostEnt->h_length );
        while ( lpHostEnt->h_addr_list[iter] )
        {
            printf( "Address %d\t: [%d.%d.%d.%d]\n",
                    iter + 1,
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][0],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][1],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][2],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][3] );
            iter++;
        }
    }
    else
    {
        printf( "\nNo host found for IP address %d.%d.%d.%d.\nError: %d",
        Part1, Part2, Part3, Part4, WSAGetLastError() );
    }

    WSACleanup();

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\sample\rnrsetup\rnrsetup.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    RnrClnt.c

Abstract:

    Setup program for installing/removing the "EchoExample" service.

--*/

#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>
#include <nspapi.h>

WSADATA WsaData;

#ifndef NS_NTDS
#define NS_NTDS 9999
#endif
//
// GUID for Echo-Example created with uuidgen:
//     "47da8500-96a1-11cd-901d-204c4f4f5020"
//

GUID ServiceGuid = { 0x47da8500, 0x96a1, 0x11cd, 0x90, 0x1d,
                     0x20, 0x4c, 0x4f, 0x4f, 0x50, 0x20 };

#define ECHO_SERVICE_TYPE_NAME "EchoExample"
#define ECHO_SERVICE_SAPID     999
#define ECHO_SERVICE_TCPPORT   999
#define RNR_SERVICE_NAME       "RnrSvc"
#define RNR_DISPLAY_NAME       "RnrSampleService"

void
DoServiceSetup(
    char * Path
    )
{
    SC_HANDLE ServiceManagerHandle;
    SC_HANDLE ServiceHandle;
    LPSTR KeyName = "System\\CurrentControlSet\\Services\\EventLog\\System\\RnrSvc";
    HKEY RnrKey;
    LONG err;
    DWORD Disposition;

    //
    //  Create the service.
    //

    ServiceManagerHandle = OpenSCManager( NULL,
                                          NULL,
                                          STANDARD_RIGHTS_REQUIRED
                                          | SC_MANAGER_CREATE_SERVICE );

    if( ServiceManagerHandle == NULL ) {
        printf( "OpenSCManager failed: %ld\n", GetLastError() );
        exit(1);
    }

    ServiceHandle = CreateService( ServiceManagerHandle,
                                   RNR_SERVICE_NAME,
                                   RNR_DISPLAY_NAME,
                                   GENERIC_READ | GENERIC_WRITE,
                                   SERVICE_WIN32_OWN_PROCESS,
                                   SERVICE_DEMAND_START,
                                   SERVICE_ERROR_NORMAL,
                                   Path,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL );

    if( ServiceHandle == NULL ) {
        printf( "CreateService failed: %ld\n", GetLastError() );
        CloseServiceHandle( ServiceManagerHandle );
        exit(1);
    }

    CloseServiceHandle( ServiceHandle );
    CloseServiceHandle( ServiceManagerHandle );

    printf( "%s created with path %s\n",
            RNR_SERVICE_NAME,
            Path );

    //
    //  Add the data to the EventLog's registry key so that the
    //  log insertion strings may be found by the Event Viewer.
    //

    err = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                          KeyName,
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_WRITE,
                          NULL,
                          &RnrKey,
                          &Disposition );

    if( err != 0 ) {
        printf( "RegCreateKeyEx failed: %ld\n", err );
        exit(1);
    }

    err = RegSetValueEx( RnrKey,
                         "EventMessageFile",
                         0,
                         REG_EXPAND_SZ,
                         Path,
                         strlen( Path ) + 1 );

    if( err == 0 ) {
        DWORD Value;

        Value = EVENTLOG_ERROR_TYPE
                | EVENTLOG_WARNING_TYPE
                | EVENTLOG_INFORMATION_TYPE;

        err = RegSetValueEx( RnrKey,
                             "TypesSupported",
                             0,
                             REG_DWORD,
                             (CONST BYTE *)&Value,
                             sizeof(Value) );
    }

    RegCloseKey( RnrKey );

    if( err != 0 ) {
        printf( "RegSetValueEx failed: %ld\n", err );
        exit(1);
    }

    exit(0);
}

void __cdecl
main (
    int argc,
    char *argv[]
    )
{
    INT err;

    WSASERVICECLASSINFO ServiceClassInfo;
    WSANSCLASSINFO      lpNSClassInfo[6];

    DWORD Value1 = 1 ;
    DWORD SapValue = ECHO_SERVICE_SAPID ;
    DWORD TcpPortValue = ECHO_SERVICE_TCPPORT ;
    DWORD operation = SERVICE_ADD_TYPE;

    //
    // Initilize the Windows Sockets DLL.
    //

    err = WSAStartup( 0x0202, &WsaData );
    if ( err == SOCKET_ERROR ) {
        printf( "WSAStartup() failed: %ld\n", GetLastError( ) );
        exit(1);
    }

    //
    // Parse command-line arguments.
    //

    if (argc > 2) {
        printf( "usage: rnrsetup [/ADD | /DEL | /SVC:path]\n") ;
        exit(1);
    }

    if (argc == 2)
    {
        if ( _strnicmp( argv[1], "/add", 4 ) == 0 )
        {
            printf( "\nAdding service types to Rnr name spaces.\n" );
        }
        else if ( _strnicmp( argv[1], "/delete", 4 ) == 0 )
        {
            err = WSARemoveServiceClass( &ServiceGuid );

            WSACleanup();

            if ( err != NO_ERROR )
            {
                printf( "\nWSARemoveServiceClass failed: %ld\n",
                        GetLastError( ) );
                exit(1);
            }

            printf( "\nWSARemoveServiceClass succeeded\n" );

            exit(0);
        }
        else if ( _strnicmp( argv[1], "/svc:", 5 ) == 0 )
        {
            printf( "\nAdding service entry to service control manager.\n" );
            DoServiceSetup( strchr( argv[1], ':' ) + 1 );
            printf( "Adding service types to Rnr name spaces.\n" );
        }
        else
        {
            printf( "usage: rnrsetup [/ADD | /DEL | /SVC:path]\n") ;
            exit(1);
        }
    }

    //
    // Set up information to pass to NSPInstallServiceClass() or
    // NSPRemoveServiceClass() to add or delete this
    // service type.
    //

    ServiceClassInfo.lpServiceClassId = &ServiceGuid;
    ServiceClassInfo.lpszServiceClassName = ECHO_SERVICE_TYPE_NAME;
    ServiceClassInfo.dwCount = 6;
    ServiceClassInfo.lpClassInfos = lpNSClassInfo;

    //
    // - - - SAP provider setup - - -
    //
    // The first value tells SAP that this is a connection-oriented
    // service.
    //
    lpNSClassInfo[0].lpszName = SERVICE_TYPE_VALUE_CONN ;
    lpNSClassInfo[0].dwNameSpace = NS_SAP ;
    lpNSClassInfo[0].dwValueType = REG_DWORD ;
    lpNSClassInfo[0].dwValueSize = 4 ;
    lpNSClassInfo[0].lpValue     = &Value1 ;

    //
    // Next, give SAP the object type to use when broadcasting the
    // service name.
    //
    lpNSClassInfo[1].lpszName = SERVICE_TYPE_VALUE_SAPID ;
    lpNSClassInfo[1].dwNameSpace = NS_SAP ;
    lpNSClassInfo[1].dwValueType = REG_DWORD ;
    lpNSClassInfo[1].dwValueSize = sizeof(DWORD) ;
    lpNSClassInfo[1].lpValue     = &SapValue ;

    //
    // - - - TCPIP provider setup - - -
    //
    // Tell the TCPIP name space provider that we will be using TCP
    // port 0x999.
    //
    lpNSClassInfo[2].lpszName = SERVICE_TYPE_VALUE_TCPPORT ;
    lpNSClassInfo[2].dwNameSpace = NS_DNS ;
    lpNSClassInfo[2].dwValueType = REG_DWORD ;
    lpNSClassInfo[2].dwValueSize = sizeof(DWORD) ;
    lpNSClassInfo[2].lpValue     = &TcpPortValue ;

    //
    // - - - NTDS provider setup - - -
    //
    // The first value tells SAP that this is a connection-oriented
    // service.
    //
    lpNSClassInfo[3].lpszName = SERVICE_TYPE_VALUE_CONN ;
    lpNSClassInfo[3].dwNameSpace = NS_NTDS ;
    lpNSClassInfo[3].dwValueType = REG_DWORD ;
    lpNSClassInfo[3].dwValueSize = 4 ;
    lpNSClassInfo[3].lpValue     = &Value1 ;

    //
    // Next, give SAP the object type to use when broadcasting the
    // service name.
    //
    lpNSClassInfo[4].lpszName = SERVICE_TYPE_VALUE_SAPID ;
    lpNSClassInfo[4].dwNameSpace = NS_NTDS ;
    lpNSClassInfo[4].dwValueType = REG_DWORD ;
    lpNSClassInfo[4].dwValueSize = sizeof(DWORD) ;
    lpNSClassInfo[4].lpValue     = &SapValue ;

    //
    // Tell the NTDS name space provider that we will be using TCP
    // port 0x999.
    //
    lpNSClassInfo[5].lpszName = SERVICE_TYPE_VALUE_TCPPORT ;
    lpNSClassInfo[5].dwNameSpace = NS_NTDS ;
    lpNSClassInfo[5].dwValueType = REG_DWORD ;
    lpNSClassInfo[5].dwValueSize = sizeof(DWORD) ;
    lpNSClassInfo[5].lpValue     = &TcpPortValue ;

    //
    // Finally, call WSAInstallServiceClass to actually perform the operation.
    //

    err = WSAInstallServiceClass( &ServiceClassInfo );

    WSACleanup();

    if ( err != NO_ERROR )
    {
        printf( "WSAInstallServiceClass failed: %ld\n", GetLastError( ) );
        exit(1);
    }

    printf( "WSAInstallServiceClass succeeded\n" );

    exit(0);

} // main
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\sample\rnrclnt\rnrclnt.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    RnrClnt.c

Abstract:

    Test and demonstration client for the RNR (service Registration and
    Name Resolution) APIs.  This is a simple client application designed
    to show the basic principles involved in using the RNR APIs to _write
    a protocol-independent Windows Sockets client application.

    This client works by examining the protocols loaded on the machine,
    looking for protocols which are reliable and stream-oriented.  Then
    it attempts to locate and connect to the service on these protocols.
    When is has successfully connected to the service, it sends
    exchanges several messages with the service and then terminates the
    connection.

    The OpenConnection() routine implemented herein is intended to be a
    demonstration of RNR functionality commonly used in
    protocol-independent clients.  Application writers are encouraged to
    leverage this code to assist them in writing protocol-independent
    applications on top of the Windows Sockets API.


--*/

#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>
#include <nspapi.h>

#define DEFAULT_TRANSFER_SIZE    512
#define DEFAULT_TRANSFER_COUNT   0x10
#define DEFAULT_CONNECTION_COUNT 1
#define DEFAULT_DELAY            0

#define DEFAULT_RECEIVE_BUFFER_SIZE 4096
#define DEFAULT_SEND_BUFFER_SIZE    4096

#define MAX_PROTOCOLS  10
#define MAX_HOST_NAMES 16

WSADATA WsaData;
DWORD TransferSize = DEFAULT_TRANSFER_SIZE;
DWORD TransferCount = DEFAULT_TRANSFER_COUNT;
PCHAR IoBuffer;
DWORD RepeatCount = 1;
INT ReceiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE;
INT SendBufferSize = DEFAULT_SEND_BUFFER_SIZE;

PCHAR RemoteName = "localhost";
PCHAR ServiceTypeName = "EchoExample";

VOID
DoEcho(
    IN SOCKET s );

SOCKET
OpenConnection(
    IN  PTSTR  ServiceName,
    IN  LPGUID ServiceType,
    IN  BOOL   Reliable,
    IN  BOOL   MessageOriented,
    IN  BOOL   StreamOriented,
    IN  BOOL   Connectionless,
    OUT PINT   ProtocolUsed );

INT
Rnr20_GetAddressByName(
    IN     PTSTR         ServiceName,
    IN     LPGUID        ServiceType,
    IN     DWORD         dwNameSpace,
    IN     DWORD         dwNumberOfProtocols,
    IN     LPAFPROTOCOLS lpAfpProtocols,
    IN OUT LPVOID        lpCSAddrInfo,
    IN OUT LPDWORD       lpdwBufferLength );

void __cdecl
main(
    int argc,
    char *argv[] )
{
    INT err;
    DWORD i;
    DWORD protocol[2];
    SOCKET s;
    BYTE buffer[1024];
    BYTE buffer2[1024];
    DWORD bytesRequired;
    PPROTOCOL_INFO protocolInfo;
    GUID serviceType;

    //
    // Initialize the Windows Sockets DLL.
    //

    err = WSAStartup( 0x0202, &WsaData );
    if ( err == SOCKET_ERROR )
    {
        printf( "WSAStartup() failed: %ld\n", GetLastError( ) );
        return;
    }

    //
    // Parse command-line arguments.
    //

    for ( i = 1; i < (ULONG)argc != 0; i++ )
    {
        if ( _strnicmp( argv[i], "/name:", 6 ) == 0 )
        {
            RemoteName = argv[i] + 6;
        }
        else if ( _strnicmp( argv[i], "/type:", 6 ) == 0 )
        {
            ServiceTypeName = argv[i] + 6;
        }
        else if ( _strnicmp( argv[i], "/size:", 6 ) == 0 )
        {
            TransferSize = atoi( argv[i] + 6 );
        }
        else if ( _strnicmp( argv[i], "/count:", 7 ) == 0 )
        {
            TransferCount = atoi( argv[i] + 7 );
        }
        else if ( _strnicmp( argv[i], "/rcvbuf:", 8 ) == 0 )
        {
            ReceiveBufferSize = atoi( argv[i] + 8 );
        }
        else if ( _strnicmp( argv[i], "/sndbuf:", 8 ) == 0 )
        {
            SendBufferSize = atoi( argv[i] + 8 );
        }
        else
        {
            printf( "Usage: rnrclnt [/name:SVCNAME] [/type:TYPENAME] [/size:N]\n" );
            printf( "               [/count:N] [/rcvbuf:N] [/sndbuf:N]\n" );
            exit( 0 );
        }
    }

    //
    // Allocate memory to hold the network I/O buffer.
    //

    IoBuffer = malloc( TransferSize + 1 );
    if ( IoBuffer == NULL )
    {
        printf( "Failed to allocate I/O buffer.\n" );
        exit( 0 );
    }

    //
    // Determine the type (GUID) of the service we are interested in
    // connecting to.
    //

    err = GetTypeByName( ServiceTypeName, &serviceType );
    if ( err == SOCKET_ERROR )
    {
        printf( "GetTypeByName for \"%s\" failed: %ld\n",
                    ServiceTypeName, GetLastError( ) );
        exit( 0 );
    }

    //
    // Open a connected socket to the service.
    //

    s = OpenConnection(
            RemoteName,
            &serviceType,
            TRUE,
            FALSE,
            FALSE,
            FALSE,
            &protocol[0]
            );

    if ( s == INVALID_SOCKET )
    {
        printf( "Failed to open connection to name \"%s\" type \"%s\"\n",
                    RemoteName, ServiceTypeName );
        exit( 0 );
    }

    //
    // The connection succeeded.  Display some information on the
    // protocol which was used.
    //

    bytesRequired = sizeof(buffer);
    protocol[1] = 0;

    err = EnumProtocols( protocol, buffer, &bytesRequired );

    if ( err < 1 )
    {
        printf( "EnumProtocols failed for protocol %ld: %ld\n",
                protocol[0], GetLastError( ) );
        exit( 0 );
    }

    err = GetNameByType( &serviceType, buffer2, sizeof(buffer2) );

    if ( err != NO_ERROR )
    {
        printf( "GetNameByType failed: %ld\n", GetLastError( ) );
        exit ( 0 );
    }

    protocolInfo = (PPROTOCOL_INFO)buffer;
    printf( "Connected to %s/%s with protocol \"%s\" (%ld)\n",
            RemoteName, buffer2,
            protocolInfo->lpProtocol,
            protocolInfo->iProtocol );

    //
    // Send data to and from the service.
    //

    DoEcho( s );

} // main


VOID
DoEcho(
    IN SOCKET s )
{
    INT err;
    INT bytesReceived;
    DWORD i;
    DWORD startTime;
    DWORD endTime;
    DWORD transferStartTime;
    DWORD transferEndTime;
    DWORD totalTime;
    INT thisTransferSize;
    DWORD bytesTransferred = 0;

    startTime = GetTickCount( );

    for ( i = 0; i < TransferCount; i++ )
    {
        thisTransferSize = TransferSize;

        transferStartTime = GetTickCount( );

        err = send( s, IoBuffer, thisTransferSize, 0 );

        if ( err != thisTransferSize )
        {
            printf( "send didn't work, ret = %ld, error = %ld\n",
                    err, GetLastError( ) );
            closesocket( s );
            return;
        }

        bytesReceived = 0;
        do {
            err = recv( s, IoBuffer, thisTransferSize, 0 );

            if ( err == SOCKET_ERROR )
            {
                printf( "recv failed: %ld\n", GetLastError( ) );
                closesocket( s );
                return;
            }
            else if ( err == 0 && thisTransferSize != 0 )
            {
                printf( "socket closed prematurely by remote.\n" );
                return;
            }

            bytesReceived += err;
        } while ( bytesReceived < thisTransferSize );

        transferEndTime = GetTickCount( );
        printf( "%5ld bytes sent and received in %ld ms\n",
                thisTransferSize, transferEndTime - transferStartTime );

        bytesTransferred += thisTransferSize;
    }

    endTime = GetTickCount( );
    totalTime = endTime - startTime;

    printf( "\n%ld bytes transferred in %ld iterations, time = %ld ms\n",
            bytesTransferred, TransferCount, totalTime );
    printf( "Rate = %ld KB/s, %ld T/S, %ld ms/iteration\n",
            (bytesTransferred / totalTime) * 2,
            (TransferCount*1000) / totalTime,
            totalTime / TransferCount );

    err = closesocket( s );

    if ( err == SOCKET_ERROR )
    {
        printf( "closesocket failed: %ld\n", GetLastError( ) );
        return;
    }

    return;

} // DoEcho


SOCKET
OpenConnection(
    IN  PTSTR  ServiceName,
    IN  LPGUID ServiceType,
    IN  BOOL   Reliable,
    IN  BOOL   MessageOriented,
    IN  BOOL   StreamOriented,
    IN  BOOL   Connectionless,
    OUT PINT   ProtocolUsed )

/*++

Routine Description:

    Examines the Windows Sockets transport protocols loaded on a machine
    and determines those which support the characteristics requested by
    the caller.  Attempts to locate and connect to the specified service
    on these protocols.

Arguments:

    ServiceName - a friendly name which identifies the service we want
        to connect to.  On name spaces which support name resolution at
        the service level (e.g.  SAP) this is the name clients will use
        to connect to this service.  On name spaces which support name
        resolution at the host level (e.g.  DNS) this name is ignored
        and applications must use the host name to establish
        communication with this service.

    ServiceType - the GUID value which uniquely identifies the type of
        service we provide.  A GUID is created with the UUIDGEN program.

    Reliable - if TRUE, the caller requests that only transport protocols
        which support reliable data delivery be used.  If FALSE, both
        reliable and unreliable protocols may be used.

    MessageOriented - if TRUE, only message-oriented transport protocols
        should be used.  If FALSE, the caller either does not care
        whether the protocols used are message oriented or desires only
        stream-oriented protocols.

    StreamOriented - if TRUE, only stream-oriented transport protocols
        should be used.  If FALSE, the caller either does not care
        whether the protocols used are stream oriented or desires only
        message-oriented protocols.

    Connectionless - if TRUE, only connectionless protocols should be
        used.  If FALSE, both connection-oriented and connectionless
        protocols may be used.

    ProtocolUsed - if a connection is opened successfully, this
        parameter receives the protocol ID of the protocol used to
        establish the connection.

Return Value:

    A connected socket handle, or INVALID_SOCKET if the connection
    could not be established.

--*/

{
    INT protocols[MAX_PROTOCOLS+1];
    AFPROTOCOLS afProtocols[MAX_PROTOCOLS+1];
    BYTE buffer[2048];
    DWORD bytesRequired;
    INT err;
    PPROTOCOL_INFO protocolInfo;
    PCSADDR_INFO csaddrInfo = NULL;
    INT protocolCount;
    INT addressCount;
    INT i;
    DWORD protocolIndex;
    SOCKET s;

    //
    // First look up the protocols installed on this machine.  The
    // EnumProtocols() API returns about all the Windows Sockets
    // protocols loaded on this machine, and we'll use this information
    // to identify the protocols which provide the necessary semantics.
    //

    bytesRequired = sizeof(buffer);

    err = EnumProtocols( NULL, buffer, &bytesRequired );

    if ( err <= 0 )
    {
        return INVALID_SOCKET;
    }

    //
    // Walk through the available protocols and pick out the ones which
    // support the desired characteristics.
    //

    protocolCount = err;
    protocolInfo = (PPROTOCOL_INFO)buffer;

    for ( i = 0, protocolIndex = 0;
          i < protocolCount && protocolIndex < MAX_PROTOCOLS;
          i++, protocolInfo++ )
    {
        //
        // If "reliable" support is requested, then check if supported
        // by this protocol.  Reliable support means that the protocol
        // guarantees delivery of data in the order in which it is sent.
        // Note that we assume here that if the caller requested reliable
        // service then they do not want a connectionless protocol.
        //

        if ( Reliable )
        {
            //
            // Check to see if the protocol is reliable.  It must
            // guarantee both delivery of all data and the order in
            // which the data arrives.  Also, it must not be a
            // connectionless protocol.
            //

            if ( (protocolInfo->dwServiceFlags &
                      XP_GUARANTEED_DELIVERY) == 0 ||
                 (protocolInfo->dwServiceFlags &
                      XP_GUARANTEED_ORDER) == 0 )
            {
                continue;
            }

            if ( (protocolInfo->dwServiceFlags & XP_CONNECTIONLESS) != 0 )
            {
                continue;
            }

            //
            // Check to see that the protocol matches the stream/message
            // characteristics requested.  A stream oriented protocol
            // either has the XP_MESSAGE_ORIENTED bit turned off, or
            // else supports "pseudo stream" capability.  Pseudo stream
            // means that although the underlying protocol is message
            // oriented, the application may open a socket of type
            // SOCK_STREAM and the protocol will hide message boundaries
            // from the application.
            //

            if ( StreamOriented &&
                 (protocolInfo->dwServiceFlags & XP_MESSAGE_ORIENTED) != 0 &&
                 (protocolInfo->dwServiceFlags & XP_PSEUDO_STREAM) == 0 )
            {
                continue;
            }

            if ( MessageOriented &&
                 (protocolInfo->dwServiceFlags & XP_MESSAGE_ORIENTED) == 0 )
            {
                continue;
            }
        }
        else if ( Connectionless )
        {
            //
            // Make sure that this is a connectionless protocol.  In a
            // connectionless protocol, data is sent as discrete
            // datagrams with no connection establishment required.
            // Connectionless protocols typically have no reliability
            // guarantees.
            //

            if ( (protocolInfo->dwServiceFlags & XP_CONNECTIONLESS) != 0 )
            {
                continue;
            }
        }

        //
        // This protocol fits all the criteria.  Add it to the list of
        // protocols in which we're interested.
        //
        afProtocols[protocolIndex].iProtocol = protocolInfo->iProtocol;
        afProtocols[protocolIndex].iAddressFamily = AF_UNSPEC;

        protocols[protocolIndex++] = protocolInfo->iProtocol;
    }

    //
    // Make sure that we found at least one acceptable protocol.  If
    // there no protocols on this machine which meet the caller's
    // requirements then fail here.
    //

    if ( protocolIndex == 0 )
    {
        return INVALID_SOCKET;
    }

    afProtocols[protocolIndex].iProtocol = 0;
    afProtocols[protocolIndex].iAddressFamily = 0;

    protocols[protocolIndex] = 0;

    //
    // Now attempt to find the address of the service to which we're
    // connecting.  Note that we restrict the scope of the search to
    // those protocols of interest by passing the protocol array we
    // generated above to RnrGetAddressFromName() or GetAddressByName()
    // depending on whether we are running the client on the same machine
    // as the server rnrsrv.exe is running on.  This forces
    // RnrGetAddressFromName() or GetAddressByName() to return socket
    // addresses for only the protocols we specify, ignoring possible
    // addresses for protocols we cannot support because of the caller's
    // constraints.
    //

    bytesRequired = sizeof( buffer );

    if ( !strcmp( ServiceName, "localhost" ) )
    {
        //
        // This is a Winsock 1.0 call . . .
        //
        err = GetAddressByName( NS_DEFAULT,
                                ServiceType,
                                ServiceName,
                                protocols,
                                0,
                                NULL,
                                buffer,
                                &bytesRequired,
                                NULL,
                                NULL );
    }
    else
    {
        //
        // This calls into Winsock 2.0 . . .
        //
        err = Rnr20_GetAddressByName( ServiceName,
                                      ServiceType,
                                      NS_ALL,
                                      protocolIndex,
                                      afProtocols,
                                      buffer,
                                      &bytesRequired );
    }

    if ( err <= 0 )
    {
        return INVALID_SOCKET;
    }

    addressCount = err;
    csaddrInfo = (PCSADDR_INFO) buffer;

    //
    // For each address, open a socket and attempt to connect.  Note that
    // if anything fails for a particular protocol we just skip on to
    // the next protocol.  As soon as we have established a connection,
    // quit trying.
    //

    for ( i = 0; i < addressCount; i++, csaddrInfo++ )
    {
        //
        // Open the socket.  Note that we manually specify stream type
        // if so requested in case the protocol is natively a message
        // protocol but supports stream semantics.
        //

        s = socket( csaddrInfo->LocalAddr.lpSockaddr->sa_family,
                    StreamOriented ? SOCK_STREAM : csaddrInfo->iSocketType,
                    csaddrInfo->iProtocol );

        if ( s == INVALID_SOCKET )
        {
            continue;
        }

        //
        // Bind the socket to the local address specified.
        //

        err = bind( s, csaddrInfo->LocalAddr.lpSockaddr,
                    csaddrInfo->LocalAddr.iSockaddrLength );

        if ( err != NO_ERROR )
        {
            closesocket( s );
            continue;
        }

        //
        // Attempt to connect the socket to the service.  If this fails,
        // keep trying on other protocols.
        //

        err = connect( s, csaddrInfo->RemoteAddr.lpSockaddr,
                       csaddrInfo->RemoteAddr.iSockaddrLength );

        if ( err != NO_ERROR )
        {
            closesocket( s );
            continue;
        }

        //
        // The socket was successfully connected.  Remember the protocol
        // used and return the socket handle to the caller.
        //

        *ProtocolUsed = csaddrInfo->iProtocol;
        return s;
    }

    if ( csaddrInfo )
    {
        (void) LocalFree( (HLOCAL) csaddrInfo );
    }

    //
    // We failed to connect to the service.
    //

    return INVALID_SOCKET;

} // OpenConnection


INT
Rnr20_GetAddressByName(
    IN     PTSTR         szServiceName,
    IN     LPGUID        lpServiceType,
    IN     DWORD         dwNameSpace,
    IN     DWORD         dwNumberOfProtocols,
    IN     LPAFPROTOCOLS lpAfpProtocols,
    IN OUT LPVOID        lpCSAddrInfos,
    IN OUT LPDWORD       lpdwBufferLength )

/*++

Routine Description:

    Calls Winsock 2.0 service lookup routines to find service addresses.

Arguments:

    szServiceName - a friendly name which identifies the service we want
        to find the address of.

    lpServiceType - a GUID that identifies the type of service we want
        to find the address of.

    dwNameSpace - The Winsock2 Name Space to get address from (i.e. NS_ALL)

    dwNumberOfProtocols - Size of the protocol constraint array, may be zero.

    lpAftProtocols -  (Optional) References an array of AFPROTOCOLS structure.
        Only services that utilize these protocols will be returned.

    lpCSAddrInfos - On successful return, this will point to an array of
        CSADDR_INFO structures that contains the host address(es). Memory
        is passed in by callee and the length of the buffer is provided by
        lpdwBufferLength.

    lpdwBufferLength - On input provides the length in bytes of the buffer
        lpCSAddrInfos. On output returns the length of the buffer used or
        what length the buffer needs to be to store the address.

Return Value:

    The number of CSADDR_INFO structures returned in lpCSAddrInfos, or
    (INVALID_SOCKET) with a WIN32 error in GetLastError.

--*/

{
    ULONG            dwLength = 2048;      // Guess at buffer size
    PWSAQUERYSETA    pwsaQuerySet;
    ULONG            err;
    HANDLE           hRnR;
    DWORD            tempSize;
    DWORD            entries = 0;
    DWORD            dwNumberOfCsAddrs;

    RtlZeroMemory( lpCSAddrInfos, *lpdwBufferLength );

    pwsaQuerySet = (PWSAQUERYSETA) LocalAlloc( LMEM_ZEROINIT, dwLength );

    if ( pwsaQuerySet == NULL )
    {
        //
        // Unsuccessful.
        //
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory( pwsaQuerySet, dwLength );

    //
    // Do a lookup using RNRr.
    //
    pwsaQuerySet->dwSize = sizeof( WSAQUERYSETA );
    pwsaQuerySet->lpszServiceInstanceName = szServiceName;
    pwsaQuerySet->lpServiceClassId = lpServiceType;
    pwsaQuerySet->lpVersion = 0;
    pwsaQuerySet->lpszComment = 0;
    pwsaQuerySet->dwNameSpace = dwNameSpace;
    pwsaQuerySet->lpNSProviderId = 0;
    pwsaQuerySet->lpszContext = 0;
    pwsaQuerySet->dwNumberOfProtocols = dwNumberOfProtocols;
    pwsaQuerySet->lpafpProtocols = lpAfpProtocols;

    err = WSALookupServiceBegin( pwsaQuerySet,
                                 LUP_RETURN_NAME |
                                 LUP_RETURN_ADDR,
                                 &hRnR );

    if ( err != NO_ERROR )
    {
        err = WSAGetLastError();

        //
        // Free memory before returning.
        //
        (void) LocalFree( (HLOCAL) pwsaQuerySet );

        //
        // Unsuccessful.
        //
        return (DWORD) err;
    }

    //
    // The query was accepted, so execute it via the Next call.
    //
    tempSize = dwLength;

    err = WSALookupServiceNext( hRnR,
                                0,
                                &tempSize,
                                pwsaQuerySet );

    if ( err != NO_ERROR )
    {
        err = WSAGetLastError();

        if ( err == WSA_E_NO_MORE )
        {
            err = 0;
        }

        if ( err == WSASERVICE_NOT_FOUND )
        {
            err = WSAHOST_NOT_FOUND;
        }

        (void) LocalFree( (HLOCAL) pwsaQuerySet );

        //
        // Unsuccessful.
        //
        return (DWORD) err;

    }

    dwNumberOfCsAddrs = pwsaQuerySet->dwNumberOfCsAddrs;

    if ( dwNumberOfCsAddrs > 0 )
    {
        //
        // Make a copy of the CSAddrInfos returned from WSALookupServiceNext()
        //
        DWORD dwCSAddrInfoLen = dwNumberOfCsAddrs * sizeof( CSADDR_INFO );

        if ( *lpdwBufferLength > dwCSAddrInfoLen )
        {
            RtlCopyMemory( lpCSAddrInfos,
                           pwsaQuerySet->lpcsaBuffer,
                           dwCSAddrInfoLen );
        }
        else
        {
            *lpdwBufferLength = dwCSAddrInfoLen;
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            dwNumberOfCsAddrs = INVALID_SOCKET;
        }
    }

    //
    // Close lookup service handle.
    //
    (VOID) WSALookupServiceEnd( hRnR );

    //
    // Free memory used for query set info.
    //
    (void) LocalFree( (HLOCAL) pwsaQuerySet );

    return dwNumberOfCsAddrs;

} // RnrGetHostFromName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\setup.h ===
//
// GUID generated by uuidgen.exe for provider identifer,
//

GUID gProviderId = { /* 3b2637ee-e580-11cf-a555-00c04fd8d4ac */
    0x3b2637ee,
    0xe580,
    0x11cf,
    {0xa5, 0x55, 0x00, 0xc0, 0x4f, 0xd8, 0xd4, 0xac}
  };


WCHAR gProviderName[] = L"NT5 Directory";
WCHAR gProviderPath[] = L"winrnr.dll";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\ghbnleak.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <nspapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


_cdecl
main(int argc, char **argv)
{
    WSADATA          wsaData;
    struct hostent * lpHostEnt;
    char *           lpTemp;
    BYTE             AddrBuffer[1000];
    BYTE             AliasBuffer[1000];
    DWORD            AddrBufLen = 1000;
    DWORD            AliasBufLen = 1000;
    LPCSADDR_INFO    lpCSAddrInfo = (LPCSADDR_INFO) AddrBuffer;
    LPSTR            lpAliases = (LPSTR) AliasBuffer;
    GUID             dnsGuid = SVCID_DOMAIN_TCP;
    char **          ppHostAliases;
    DWORD            iter;

    if ( argc != 2 )
    {
        printf( "\nUseage: ghbn <Name>\n" );
        return( -1 );
    }

    WSAStartup( MAKEWORD(1, 1), &wsaData );

    system( "pause" );

    for ( iter = 0; iter < 10000; iter ++ )
    {
        lpHostEnt = gethostbyname( argv[1] );
    }

    system( "pause" );

    if ( lpHostEnt )
    {
        DWORD iter = 0;

        printf( "\nHost address found for %s.\n", argv[1] );
        printf( "Official name of host: %s\n", lpHostEnt->h_name );
        ppHostAliases = lpHostEnt->h_aliases;

        while ( *ppHostAliases )
            printf( "Alias name: %s\n", *ppHostAliases++ );

        printf( "Host address type: %d\n", lpHostEnt->h_addrtype );
        printf( "Length of addresses: %d\n", lpHostEnt->h_length );
        while ( lpHostEnt->h_addr_list[iter] )
        {
            printf( "Address %d\t: [%d.%d.%d.%d]\n",
                    iter + 1,
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][0],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][1],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][2],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][3] );
            iter++;
        }
    }
    else
    {
        printf( "\nNo host found for %s.\nError: %d", argv[1], WSAGetLastError() );
    }

    WSACleanup();

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\dereg.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


GUID    ServiceClassId = { /* 5b50962a-e5a5-11cf-a555-00c04fd8d4ac */
    0x5b50962a,
    0xe5a5,
    0x11cf,
    {0xa5, 0x55, 0x00, 0xc0, 0x4f, 0xd8, 0xd4, 0xac}
  };

WCHAR   ServiceInstanceName[] = L"GlennC on GLENNC_PRO";

_cdecl
main(int argc, char **argv)
{
    DWORD               ret;
    WSADATA             wsaData;
    WSAQUERYSET         QuerySet;
    CSADDR_INFO         CSAddrInfo[2];
    SOCKADDR            SocketAddress1;
    SOCKADDR            SocketAddress2;

    RtlZeroMemory( (LPBYTE) &QuerySet, sizeof( WSAQUERYSET ) );
    RtlZeroMemory( (LPBYTE) &CSAddrInfo[0], sizeof( CSADDR_INFO ) );
    RtlZeroMemory( (LPBYTE) &CSAddrInfo[1], sizeof( CSADDR_INFO ) );

    SocketAddress1.sa_family = AF_INET;
    RtlFillMemory( (LPBYTE) &SocketAddress1.sa_data, 14, 2 );

    SocketAddress2.sa_family = AF_IPX;
    RtlFillMemory( (LPBYTE) &SocketAddress2.sa_data, 14, 6 );

    CSAddrInfo[0].LocalAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[0].LocalAddr.lpSockaddr = &SocketAddress1;
    CSAddrInfo[0].RemoteAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[0].RemoteAddr.lpSockaddr = &SocketAddress1;
    CSAddrInfo[0].iSocketType = SOCK_RAW;
    CSAddrInfo[0].iProtocol = PF_INET;

    CSAddrInfo[1].LocalAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[1].LocalAddr.lpSockaddr = &SocketAddress2;
    CSAddrInfo[1].RemoteAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[1].RemoteAddr.lpSockaddr = &SocketAddress2;
    CSAddrInfo[1].iSocketType = SOCK_STREAM;
    CSAddrInfo[1].iProtocol = PF_IPX;

    QuerySet.dwSize = sizeof( WSAQUERYSET );
    QuerySet.lpServiceClassId = &ServiceClassId;
    QuerySet.lpszServiceInstanceName = ServiceInstanceName;
    QuerySet.dwNameSpace = NS_NTDS;
    QuerySet.dwNumberOfCsAddrs = 2;
    QuerySet.lpcsaBuffer = &CSAddrInfo;
    
    WSAStartup( MAKEWORD(1, 1), &wsaData );

    ret = WSASetService( &QuerySet,
                         RNRSERVICE_DEREGISTER,
                         SERVICE_MULTIPLE );

    if ( ret )
    {
        printf("Error: WSASetService returned 0x%X\n", ret );
        printf("   GetLastError returned 0x%X\n", GetLastError() );

        WSACleanup();

        return -1;
    }

    printf( "SetService was successful.\n" );

    WSACleanup();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\enumnsp.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


#define BUFFSIZE 3000

_cdecl
main(int argc, char **argv)
{
    DWORD               dwBufSize = BUFFSIZE;
    WCHAR               Buffer[BUFFSIZE];
    DWORD               ret;
    DWORD               iter;
    WSADATA             wsaData;
    LPWSANAMESPACE_INFO lpnspBuffer = (LPWSANAMESPACE_INFO) Buffer;

    WSAStartup(MAKEWORD(1, 1), &wsaData);

    ret = WSAEnumNameSpaceProviders( &dwBufSize,
                                     lpnspBuffer );
    if ( ret == SOCKET_ERROR )
    {
        printf("Error: WSAEnumNameSpaceProviders returned 0x%X\n", ret );
        printf("   GetLastError returned 0x%X\n", GetLastError() );

        WSACleanup();

        return -1;
    }

    printf( "\nWSAEnumNameSpaceProviders returned %d entries . . .\n\n", ret );

    for ( iter = 0; iter < ret; iter++ )
    {
        printf( "NSProviderId    : %x\n",
                lpnspBuffer[iter].NSProviderId );
        printf( "dwNameSpace     : %d\n",
                lpnspBuffer[iter].dwNameSpace );
        printf( "fActive         : %S\n",
                lpnspBuffer[iter].fActive ? L"TRUE" : L"FALSE" );
        printf( "dwVersion       : %x\n",
                lpnspBuffer[iter].dwVersion );
        printf( "lpszIdentifier  : %S\n\n",
                lpnspBuffer[iter].lpszIdentifier );
    }

    WSACleanup();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\ghbn.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <nspapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <rpc.h>
#include <rpcdce.h>


_cdecl
main(int argc, char **argv)
{
    WSADATA          wsaData;
    struct hostent * lpHostEnt;
    char *           lpTemp;
    BYTE             AddrBuffer[1000];
    BYTE             AliasBuffer[1000];
    DWORD            AddrBufLen = 1000;
    DWORD            AliasBufLen = 1000;
    LPCSADDR_INFO    lpCSAddrInfo = (LPCSADDR_INFO) AddrBuffer;
    LPSTR            lpAliases = (LPSTR) AliasBuffer;
    GUID             dnsGuid = SVCID_DOMAIN_TCP;
    char **          ppHostAliases;
    BOOL             fLoop = FALSE;

    if ( !( argc == 2 | argc == 3 ) )
    {
        printf( "\nUseage: ghbn <Name> [-l]\n" );
        return( -1 );
    }

    if ( argc == 3 )
    {
        if ( !_stricmp( argv[2], "-l" ) )
            fLoop = TRUE;
        else
        {
            printf( "\nUseage: ghbn <Name> [-l]\n" );
            return( -1 );
        }
    }

    WSAStartup( MAKEWORD(1, 1), &wsaData );

Repeat :

    if ( fLoop )
        system( "pause" );

    lpHostEnt = gethostbyname( argv[1] );

    if ( lpHostEnt )
    {
        DWORD iter = 0;

        printf( "\nHost address found for %s.\n", argv[1] );
        printf( "Official name of host: %s\n", lpHostEnt->h_name );
        ppHostAliases = lpHostEnt->h_aliases;

        while ( *ppHostAliases )
            printf( "Alias name: %s\n", *ppHostAliases++ );

        printf( "Host address type: %d\n", lpHostEnt->h_addrtype );
        printf( "Length of addresses: %d\n", lpHostEnt->h_length );
        while ( lpHostEnt->h_addr_list[iter] )
        {
            printf( "Address %d\t: [%d.%d.%d.%d]\n",
                    iter + 1,
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][0],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][1],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][2],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][3] );
            iter++;
        }
    }
    else
    {
        printf( "\nNo host found for %s.\nError: %d", argv[1], WSAGetLastError() );
    }

    if ( fLoop )
        goto Repeat;

    WSACleanup();

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\gsci.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>
#include "..\setup.h"


#define BUFFSIZE 3000

GUID    ServiceClassId = { /* 5b50962a-e5a5-11cf-a555-00c04fd8d4ac */
    0x5b50962a,
    0xe5a5,
    0x11cf,
    {0xa5, 0x55, 0x00, 0xc0, 0x4f, 0xd8, 0xd4, 0xac}
  };

_cdecl
main(int argc, char **argv)
{
    DWORD                  dwBufSize = BUFFSIZE;
    WCHAR                  Buffer[BUFFSIZE];
    DWORD                  ret;
    DWORD                  iter;
    WSADATA                wsaData;
    LPWSASERVICECLASSINFOW lpServiceClassInfo = (LPWSASERVICECLASSINFOW) Buffer;

    WSAStartup( MAKEWORD(1, 1), &wsaData );

    ret = WSAGetServiceClassInfo( &gProviderId,
                                  &ServiceClassId,
                                  &dwBufSize,
                                  lpServiceClassInfo );

    if ( ret )
    {
        printf("Error: WSAGetServiceClassInfo returned 0x%X\n", ret );
        printf("   GetLastError returned 0x%X\n", GetLastError() );

        WSACleanup();

        return -1;
    }

    printf( "\nlpServiceClassId      : 0x%x\n",
            lpServiceClassInfo->lpServiceClassId );
    printf( "lpszServiceClassName  : %S\n",
            lpServiceClassInfo->lpszServiceClassName );
    printf( "dwCount               : %d\n",
            lpServiceClassInfo->dwCount );

    for ( iter = 0; iter < lpServiceClassInfo->dwCount; iter++ )
    {
        printf( "\n   lpszName          : %S\n",
                    lpServiceClassInfo->lpClassInfos[iter].lpszName );
        printf( "   dwNameSpace       : %d\n",
                    lpServiceClassInfo->lpClassInfos[iter].dwNameSpace );
        printf( "   dwValueType       : %d\n",
                    lpServiceClassInfo->lpClassInfos[iter].dwValueType );
        printf( "   dwValueSize       : %d\n",
                    lpServiceClassInfo->lpClassInfos[iter].dwValueSize );
        printf( "   lpValue           : 0x%X\n",
                    lpServiceClassInfo->lpClassInfos[iter].lpValue );
    }

    WSACleanup();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\gabn.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock.h>
#include <nspapi.h>
#include <wsipx.h>
#include <svcguid.h>
#include <nspapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


_cdecl
main(int argc, char **argv)
{
    WSADATA          wsaData;
    BYTE             AddrBuffer[1000];
    DWORD            AddrBufLen = 1000;
    LPCSADDR_INFO    lpCSAddrInfo = (LPCSADDR_INFO) AddrBuffer;
    GUID             ServiceType = SVCID_NAMESERVER_UDP;
    DWORD            err;

    WSAStartup( MAKEWORD(1, 1), &wsaData );

    err = GetAddressByName( 0,
                            &ServiceType,
                            NULL,
                            NULL,
                            0,
                            NULL,
                            lpCSAddrInfo,
                            &AddrBufLen,
                            NULL,
                            NULL );

    if ( err <= 0 )
        return INVALID_SOCKET;

    WSACleanup();

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\install.c ===
#include <windows.h>
#include <winsock2.h>
#include <svcguid.h>
#include <stdio.h>

DWORD WINAPI
InstallNTDSProvider(
    IN LPWSTR szProviderName OPTIONAL, // NULL defaults to name "NTDS"
    IN LPWSTR szProviderPath OPTIONAL, // NULL defaults to path
                                       // "%SystemRoot%\System32\winrnr.dll"
    IN LPGUID lpProviderId OPTIONAL ); // NULL defaults to GUID
                                       // 3b2637ee-e580-11cf-a555-00c04fd8d4ac

_cdecl
main(int argc, char **argv)
{
    DWORD status = NO_ERROR;

    status = InstallNTDSProvider( NULL,
                                  NULL,
                                  NULL );

    if ( status )
    {
        printf( "\nInstallation of NTDS Rnr provider was NOT successful.\n" );
        printf( "Error: %d\n", status );

        return( -1 );
    }

    printf( "\nInstallation of NTDS Rnr provider was successful.\n" );

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\ghn.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <nspapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


_cdecl
main(int argc, char **argv)
{
    WSADATA wsaData;
    char    hostName[256];

    WSAStartup( MAKEWORD(1, 1), &wsaData );

    if ( !gethostname( hostName, 256 ) )
    {
        printf( "\nHost name is %s.\n", hostName );
    }
    else
    {
        printf( "\nNo host name.\nError: %d", WSAGetLastError() );
    }

    WSACleanup();

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\isc.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


#define BUFFSIZE 3000

GUID    ServiceClassId = { /* 5b50962a-e5a5-11cf-a555-00c04fd8d4ac */
    0x5b50962a,
    0xe5a5,
    0x11cf,
    {0xa5, 0x55, 0x00, 0xc0, 0x4f, 0xd8, 0xd4, 0xac}
  };

WCHAR   ServiceClassName[] = L"Winsock2 Example Class";

_cdecl
main(int argc, char **argv)
{
    DWORD               dwBufSize = BUFFSIZE;
    WCHAR               Buffer[BUFFSIZE];
    DWORD               ret;
    WSADATA             wsaData;
    WSASERVICECLASSINFO ServiceClassInfo;
    WSANSCLASSINFO      NSClassInfo;
    DWORD               dwValue = 0x67676767;

    NSClassInfo.lpszName = SERVICE_TYPE_VALUE_OBJECTID;
    NSClassInfo.dwNameSpace = NS_ALL;
    NSClassInfo.dwValueType = REG_DWORD;
    NSClassInfo.dwValueSize = 4;
    NSClassInfo.lpValue = &dwValue;

    ServiceClassInfo.lpServiceClassId = &ServiceClassId;
    ServiceClassInfo.lpszServiceClassName = ServiceClassName;
    ServiceClassInfo.dwCount = 1;
    ServiceClassInfo.lpClassInfos = &NSClassInfo;

    WSAStartup( MAKEWORD(1, 1), &wsaData );

    ret = WSAInstallServiceClass( &ServiceClassInfo );

    if ( ret )
    {
        printf("Error: WSAInstallServiceClass returned 0x%X\n", ret );
        printf("   GetLastError returned 0x%X\n", GetLastError() );

        WSACleanup();

        return -1;
    }

    printf( "Service class was installed\n" );

    WSACleanup();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\reg.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


GUID    ServiceClassId = { /* 5b50962a-e5a5-11cf-a555-00c04fd8d4ac */
    0x5b50962a,
    0xe5a5,
    0x11cf,
    {0xa5, 0x55, 0x00, 0xc0, 0x4f, 0xd8, 0xd4, 0xac}
  };

WCHAR   ServiceInstanceName[] = L"GlennC on GLENNC_PRO";
WCHAR   ServiceInstanceComment[] = L"This is a service added via Rnr over LDAP";

_cdecl
main(int argc, char **argv)
{
    DWORD               ret;
    WSAVERSION          Version;
    WSADATA             wsaData;
    WSAQUERYSET         QuerySet;
    CSADDR_INFO         CSAddrInfo[6];
    SOCKADDR            SocketAddress1;
    SOCKADDR            SocketAddress2;
    SOCKADDR            SocketAddress3;
    SOCKADDR            SocketAddress4;
    SOCKADDR            SocketAddress5;

    RtlZeroMemory( (LPBYTE) &QuerySet, sizeof( WSAQUERYSET ) );
    RtlZeroMemory( (LPBYTE) &CSAddrInfo[0], sizeof( CSADDR_INFO ) );
    RtlZeroMemory( (LPBYTE) &CSAddrInfo[1], sizeof( CSADDR_INFO ) );
    RtlZeroMemory( (LPBYTE) &CSAddrInfo[2], sizeof( CSADDR_INFO ) );
    RtlZeroMemory( (LPBYTE) &CSAddrInfo[3], sizeof( CSADDR_INFO ) );
    RtlZeroMemory( (LPBYTE) &CSAddrInfo[4], sizeof( CSADDR_INFO ) );
    RtlZeroMemory( (LPBYTE) &CSAddrInfo[5], sizeof( CSADDR_INFO ) );

    SocketAddress1.sa_family = AF_UNIX;
    RtlFillMemory( (LPBYTE) &SocketAddress1.sa_data, 14, 1 );

    SocketAddress2.sa_family = AF_INET;
    RtlFillMemory( (LPBYTE) &SocketAddress2.sa_data, 14, 2 );

    SocketAddress3.sa_family = AF_IPX;
    RtlFillMemory( (LPBYTE) &SocketAddress3.sa_data, 14, 6 );

    SocketAddress4.sa_family = AF_ISO;
    RtlFillMemory( (LPBYTE) &SocketAddress4.sa_data, 14, 7 );

    SocketAddress5.sa_family = AF_ECMA;
    RtlFillMemory( (LPBYTE) &SocketAddress5.sa_data, 14, 8 );

    CSAddrInfo[0].LocalAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[0].LocalAddr.lpSockaddr = &SocketAddress2;
    CSAddrInfo[0].RemoteAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[0].RemoteAddr.lpSockaddr = &SocketAddress2;
    CSAddrInfo[0].iSocketType = SOCK_RAW;
    CSAddrInfo[0].iProtocol = PF_INET;

    CSAddrInfo[1].LocalAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[1].LocalAddr.lpSockaddr = &SocketAddress2;
    CSAddrInfo[1].RemoteAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[1].RemoteAddr.lpSockaddr = &SocketAddress2;
    CSAddrInfo[1].iSocketType = SOCK_STREAM;
    CSAddrInfo[1].iProtocol = PF_INET;

    CSAddrInfo[2].LocalAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[2].LocalAddr.lpSockaddr = &SocketAddress1;
    CSAddrInfo[2].RemoteAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[2].RemoteAddr.lpSockaddr = &SocketAddress1;
    CSAddrInfo[2].iSocketType = SOCK_STREAM;
    CSAddrInfo[2].iProtocol = PF_UNIX;

    CSAddrInfo[3].LocalAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[3].LocalAddr.lpSockaddr = &SocketAddress3;
    CSAddrInfo[3].RemoteAddr.iSockaddrLength = 0;
    CSAddrInfo[3].RemoteAddr.lpSockaddr = NULL;
    CSAddrInfo[3].iSocketType = SOCK_STREAM;
    CSAddrInfo[3].iProtocol = PF_IPX;

    CSAddrInfo[4].LocalAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[4].LocalAddr.lpSockaddr = &SocketAddress4;
    CSAddrInfo[4].RemoteAddr.iSockaddrLength = 0;
    CSAddrInfo[4].RemoteAddr.lpSockaddr = NULL;
    CSAddrInfo[4].iSocketType = SOCK_STREAM;
    CSAddrInfo[4].iProtocol = PF_ISO;

    CSAddrInfo[5].LocalAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[5].LocalAddr.lpSockaddr = &SocketAddress5;
    CSAddrInfo[5].RemoteAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[5].RemoteAddr.lpSockaddr = &SocketAddress5;
    CSAddrInfo[5].iSocketType = SOCK_STREAM;
    CSAddrInfo[5].iProtocol = PF_ECMA;

    QuerySet.dwSize = sizeof( WSAQUERYSET );
    QuerySet.lpServiceClassId = &ServiceClassId;
    QuerySet.lpszServiceInstanceName = ServiceInstanceName;
    QuerySet.lpszComment = ServiceInstanceComment;
    QuerySet.lpVersion = &Version;
    QuerySet.lpVersion->dwVersion = 5;
    QuerySet.lpVersion->ecHow = COMP_NOTLESS;
    QuerySet.dwNameSpace = NS_NTDS;
    QuerySet.dwNumberOfCsAddrs = 6;
    QuerySet.lpcsaBuffer = &CSAddrInfo;
    
    WSAStartup( MAKEWORD(1, 1), &wsaData );

    ret = WSASetService( &QuerySet,
                         RNRSERVICE_REGISTER,
                         SERVICE_MULTIPLE );

    if ( ret )
    {
        printf("Error: WSASetService returned 0x%X\n", ret );
        printf("   GetLastError returned 0x%X\n", GetLastError() );

        WSACleanup();

        return -1;
    }

    printf( "SetService was successful.\n" );

    WSACleanup();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\rnrdns.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


#define BUFFSIZE 3000

_cdecl
main(int argc, char **argv)
{
    HANDLE hLib;
    WCHAR Buffer[BUFFSIZE];
    PWSAQUERYSETA Query = (PWSAQUERYSETA)Buffer;
    HANDLE hRnr;
    DWORD dwIp;
    DWORD dwQuerySize = BUFFSIZE;
    WSADATA wsaData;
    ANSI_STRING         asServiceInstanceName;
    UNICODE_STRING      usServiceInstanceName;
    WCHAR               UnicodeStringBuf[1024];
    AFPROTOCOLS         lpAfpProtocols[3];
    GUID                ServiceGuid = SVCID_INET_HOSTADDRBYNAME;
    DWORD               uLoop;

    usServiceInstanceName.Length = 0;
    usServiceInstanceName.MaximumLength = 1024;
    usServiceInstanceName.Buffer = UnicodeStringBuf;

    if ( argc != 2 )
    {
        printf( "\nUsage: lookup <Name>\n" );

        return( -1 );
    }

    RtlInitAnsiString( &asServiceInstanceName, argv[1] );

    RtlAnsiStringToUnicodeString( &usServiceInstanceName,
                                  &asServiceInstanceName,
                                  FALSE );

    WSAStartup(MAKEWORD(2, 0), &wsaData);

    memset(Query, 0, sizeof(*Query));

    if ( usServiceInstanceName.Buffer[0] != L'*' )
    {
        Query->lpszServiceInstanceName = argv[1];
    }
    Query->dwSize = sizeof(*Query);
    Query->dwNameSpace = NS_DNS;
    Query->lpServiceClassId = &ServiceGuid;

    if( WSALookupServiceBeginA( Query,
                               LUP_RETURN_ALL,
                               &hRnr ) == SOCKET_ERROR )
    {
        printf( "LookupBegin failed  %d\n", GetLastError() );
    }

    while ( WSALookupServiceNextA( hRnr,
                                  0,
                                  &dwQuerySize,
                                  Query ) == NO_ERROR )
    {
        printf( "Next got: \n" );
        printf( "   dwSize = %d\n",
                Query->dwSize );
        printf( "   dwOutputFlags = %d\n",
                Query->dwOutputFlags );
        printf( "   lpszServiceInstanceName = %ws\n",
                Query->lpszServiceInstanceName );
        if ( Query->lpVersion )
        {
            printf( "   lpVersion->dwVersion = %d\n",
                    Query->lpVersion->dwVersion );
            printf( "   lpVersion->ecHow = %d\n",
                    Query->lpVersion->ecHow );
        }
        if ( Query->lpszComment )
        {
            printf( "   lpszComment = %ws\n",
                    Query->lpszComment );
        }
        printf( "   dwNameSpace = %d\n",
                Query->dwNameSpace );
        if ( Query->lpszContext )
        {
            printf( "   lpszContext = %ws\n",
                    Query->lpszContext );
        }
        printf( "   dwNumberOfCsAddrs = %d\n",
                Query->dwNumberOfCsAddrs );
    }

    printf( "Next finished with %d\n", GetLastError() );

    if( WSALookupServiceEnd( hRnr ) )
    {
        printf( "ServiceEnd failed %d\n", GetLastError() );
    }

    WSACleanup();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\regatdn.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


GUID    ServiceClassId = { /* 5b50962a-e5a5-11cf-a555-00c04fd8d4ac */
    0x5b50962a,
    0xe5a5,
    0x11cf,
    {0xa5, 0x55, 0x00, 0xc0, 0x4f, 0xd8, 0xd4, 0xac}
  };

WCHAR   ServiceInstanceName[] = L"GlennC on GLENNC_PRO";
WCHAR   ServiceInstanceComment[] = L"This is a service added via Rnr over LDAP";

_cdecl
main(int argc, char **argv)
{
    DWORD               ret;
    WSAVERSION          Version;
    WSADATA             wsaData;
    WSAQUERYSET         QuerySet;
    CSADDR_INFO         CSAddrInfo[2];
    SOCKADDR            SocketAddress1;
    SOCKADDR            SocketAddress2;
    ANSI_STRING         asServiceInstanceName;
    UNICODE_STRING      usServiceInstanceName;
    WCHAR               UnicodeStringBuf[1024];

    usServiceInstanceName.Length = 0;
    usServiceInstanceName.MaximumLength = 1024;
    usServiceInstanceName.Buffer = UnicodeStringBuf;

    if ( argc != 2 )
    {
        printf( "\nUsage: regatdn CN=MyService,OU=NTDS,O=Microsoft,C=US\n" );

        return( -1 );
    }

    RtlInitAnsiString( &asServiceInstanceName, argv[1] );

    RtlAnsiStringToUnicodeString( &usServiceInstanceName,
                                  &asServiceInstanceName,
                                  FALSE );

    RtlZeroMemory( (LPBYTE) &QuerySet, sizeof( WSAQUERYSET ) );
    RtlZeroMemory( (LPBYTE) &CSAddrInfo[0], sizeof( CSADDR_INFO ) );
    RtlZeroMemory( (LPBYTE) &CSAddrInfo[1], sizeof( CSADDR_INFO ) );

    SocketAddress1.sa_family = AF_INET;
    RtlFillMemory( (LPBYTE) &SocketAddress1.sa_data, 14, 1 );

    SocketAddress2.sa_family = AF_IPX;
    RtlFillMemory( (LPBYTE) &SocketAddress2.sa_data, 14, 2 );

    CSAddrInfo[0].LocalAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[0].LocalAddr.lpSockaddr = &SocketAddress1;
    CSAddrInfo[0].RemoteAddr.iSockaddrLength = 0;
    CSAddrInfo[0].RemoteAddr.lpSockaddr = NULL;
    CSAddrInfo[0].iSocketType = SOCK_RAW;
    CSAddrInfo[0].iProtocol = PF_INET;

    CSAddrInfo[1].LocalAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[1].LocalAddr.lpSockaddr = &SocketAddress1;
    CSAddrInfo[1].RemoteAddr.iSockaddrLength = sizeof( SOCKADDR );
    CSAddrInfo[1].RemoteAddr.lpSockaddr = &SocketAddress2;
    CSAddrInfo[1].iSocketType = SOCK_STREAM;
    CSAddrInfo[1].iProtocol = PF_IPX;

    QuerySet.dwSize = sizeof( WSAQUERYSET );
    QuerySet.lpServiceClassId = &ServiceClassId;
    QuerySet.lpszServiceInstanceName = usServiceInstanceName.Buffer;
    QuerySet.lpszComment = ServiceInstanceComment;
    QuerySet.lpVersion = &Version;
    QuerySet.lpVersion->dwVersion = 5;
    QuerySet.lpVersion->ecHow = COMP_NOTLESS;
    QuerySet.dwNameSpace = NS_NTDS;
    QuerySet.dwNumberOfCsAddrs = 2;
    QuerySet.lpcsaBuffer = &CSAddrInfo;
    
    WSAStartup( MAKEWORD(1, 1), &wsaData );

    ret = WSASetService( &QuerySet,
                         RNRSERVICE_REGISTER,
                         SERVICE_MULTIPLE );

    if ( ret )
    {
        printf("Error: WSASetService returned 0x%X\n", ret );
        printf("   GetLastError returned 0x%X\n", GetLastError() );

        WSACleanup();

        return -1;
    }

    printf( "SetService was successful.\n" );

    WSACleanup();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\rnrtst.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


GUID ServiceClassId = { /* 5b50962a-e5a5-11cf-a555-00c04fd8d4ac */
    0x5b50962a,
    0xe5a5,
    0x11cf,
    {0xa5, 0x55, 0x00, 0xc0, 0x4f, 0xd8, 0xd4, 0xac}
  };

GUID CLSID_ILSServicClass = { /* C9F17940-79A7-11d1-B008-00C04FC31FEE */
    0xc9f17940,
    0x79a7,
    0x11d1,
    {0xb0, 0x8, 0x0, 0xc0, 0x4f, 0xc3, 0x1f, 0xee}
  };

#define BUFFSIZE 3000

_cdecl
main(int argc, char **argv)
{
    HANDLE hLib;
    WCHAR Buffer[BUFFSIZE];
    PWSAQUERYSETW Query = (PWSAQUERYSETW)Buffer;
    HANDLE hRnr;
    DWORD dwIp;
    DWORD dwQuerySize = BUFFSIZE;
    WSADATA wsaData;
    ANSI_STRING         asServiceInstanceName;
    UNICODE_STRING      usServiceInstanceName;
    WCHAR               UnicodeStringBuf[1024];
    ANSI_STRING         asContext;
    UNICODE_STRING      usContext;
    WCHAR               UnicodeStringBuf2[1024];
    AFPROTOCOLS         lpAfpProtocols[3];

    usServiceInstanceName.Length = 0;
    usServiceInstanceName.MaximumLength = 1024;
    usServiceInstanceName.Buffer = UnicodeStringBuf;

    usContext.Length = 0;
    usContext.MaximumLength = 1024;
    usContext.Buffer = UnicodeStringBuf2;

    if ( argc != 2 )
    {
        printf( "\nUsage: rnrtst <Name>\n" );

        return( -1 );
    }

    RtlInitAnsiString( &asServiceInstanceName, argv[1] );

    RtlAnsiStringToUnicodeString( &usServiceInstanceName,
                                  &asServiceInstanceName,
                                  FALSE );

    WSAStartup(MAKEWORD(1, 1), &wsaData);

    memset(Query, 0, sizeof(*Query));

    Query->dwSize = sizeof(*Query);

    if ( usServiceInstanceName.Buffer[0] != L'*' )
    {
        Query->lpszServiceInstanceName = usServiceInstanceName.Buffer;
    }
    Query->lpServiceClassId = &CLSID_ILSServicClass;
    Query->lpVersion = 0;
    Query->dwNameSpace = NS_NTDS;
    Query->lpNSProviderId = 0;
    Query->lpszContext = NULL;
    Query->dwNumberOfProtocols = 3;

    lpAfpProtocols[0].iAddressFamily = AF_INET;
    lpAfpProtocols[0].iProtocol = PF_INET;
    lpAfpProtocols[1].iAddressFamily = AF_IPX;
    lpAfpProtocols[1].iProtocol = PF_IPX;
    lpAfpProtocols[2].iAddressFamily = AF_UNSPEC;
    lpAfpProtocols[2].iProtocol = PF_UNSPEC;
    
    Query->lpafpProtocols = lpAfpProtocols;

    if( WSALookupServiceBegin( Query,
                               LUP_RETURN_NAME |
                               LUP_RETURN_TYPE |
                               LUP_RETURN_VERSION |
                               LUP_RETURN_COMMENT |
                               LUP_RETURN_ADDR |
                               LUP_RETURN_BLOB,
                               &hRnr ) == SOCKET_ERROR )
    {
        printf( "LookupBegin failed  %d\n", GetLastError() );
    }

    while ( WSALookupServiceNext( hRnr,
                                  0,
                                  &dwQuerySize,
                                  Query ) == NO_ERROR )
    {
        printf( "Next got: \n" );
        printf( "   dwSize = %d\n",
                Query->dwSize );
        printf( "   dwOutputFlags = %d\n",
                Query->dwOutputFlags );
        printf( "   lpszServiceInstanceName = %ws\n",
                Query->lpszServiceInstanceName );
        if ( Query->lpVersion )
        {
            printf( "   lpVersion->dwVersion = %d\n",
                    Query->lpVersion->dwVersion );
            printf( "   lpVersion->ecHow = %d\n",
                    Query->lpVersion->ecHow );
        }
        if ( Query->lpszComment )
        {
            printf( "   lpszComment = %ws\n",
                    Query->lpszComment );
        }
        printf( "   dwNameSpace = %d\n",
                Query->dwNameSpace );
        if ( Query->lpszContext )
        {
            printf( "   lpszContext = %ws\n",
                    Query->lpszContext );
        }
        printf( "   dwNumberOfCsAddrs = %d\n",
                Query->dwNumberOfCsAddrs );
    }

    printf( "Next finished with %d\n", GetLastError() );

    if( WSALookupServiceEnd( hRnr ) )
    {
        printf( "ServiceEnd failed %d\n", GetLastError() );
    }

    WSACleanup();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\remove.c ===
#include <windows.h>
#include <winsock2.h>
#include <svcguid.h>
#include <stdio.h>

DWORD WINAPI
RemoveNTDSProvider(
    IN LPGUID lpProviderId OPTIONAL );

_cdecl
main(int argc, char **argv)
{
    DWORD status = NO_ERROR;

    status = RemoveNTDSProvider( NULL );

    if ( status )
    {
        printf( "\nRemoval of NTDS Rnr provider was NOT successful.\n" );
        printf( "Error: %d\n", status );

        return( -1 );
    }

    printf( "\nRemoval of NTDS Rnr provider was successful.\n" );

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\rnrtest.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


GUID ServiceClassId = { /* 5b50962a-e5a5-11cf-a555-00c04fd8d4ac */
    0x5b50962a,
    0xe5a5,
    0x11cf,
    {0xa5, 0x55, 0x00, 0xc0, 0x4f, 0xd8, 0xd4, 0xac}
  };

#define BUFFSIZE 3000

_cdecl
main(int argc, char **argv)
{

    HANDLE hLib;
    WCHAR Buffer[BUFFSIZE];
    WCHAR Buffer1[BUFFSIZE];
    PWSAQUERYSETW Query = (PWSAQUERYSETW)Buffer;
    PWSAQUERYSETW Query1 = (PWSAQUERYSETW)Buffer1;
    HANDLE hRnr;
    DWORD dwNameSpace = NS_NTDS;
    DWORD dwIp;
    DWORD dwQuerySize = BUFFSIZE;
    WSADATA wsaData;

    WSAStartup(MAKEWORD(1, 1), &wsaData);

    memset(Query, 0, sizeof(*Query));
    memset(Query1, 0, sizeof(*Query1));

    Query->lpszServiceInstanceName = 0;
    Query->dwNumberOfCsAddrs = 0;
    Query->lpcsaBuffer = 0;
    Query->dwNameSpace = dwNameSpace;
    Query->dwSize = sizeof(*Query);
    Query->lpServiceClassId = &ServiceClassId;

    //
    // Find containers. This should fail.
    //
    if ( WSALookupServiceBegin( Query,
                                LUP_CONTAINERS,
                                &hRnr ) == SOCKET_ERROR )
    {
        printf( "LookupBegin containers failed %d\n", GetLastError() );
    }
    else
    {
        //
        // Ready to actually look for one of these ...
        //
        Query->dwSize = BUFFSIZE;

        while ( WSALookupServiceNext( hRnr,
                                      0,
                                      &dwQuerySize,
                                      Query ) == NO_ERROR )
        {
            printf( "Next containers got %ws\n",
                    Query->lpszServiceInstanceName );
        }

        printf( "Next finished with %d\n", GetLastError() );

        WSALookupServiceEnd( hRnr );
    }

    Query1->dwSize = sizeof(*Query1); // TEST LATER
    Query1->lpszServiceInstanceName = 0; // TEST NAME AND WILD CARDS
    Query1->lpServiceClassId = &ServiceClassId; // REQUIRED - TEST
    Query1->lpVersion = 0; // TEST LATER
    Query1->dwNameSpace = dwNameSpace; // TEST
    Query1->lpNSProviderId = &ServiceClassId; //BOGUS
    Query1->lpafpProtocols = 0; // TEST LATER

    if( WSALookupServiceBegin( Query1,
                               LUP_RETURN_NAME |   // TEST ALL COMBINATIONS
                               LUP_RETURN_ADDR |   // OF LUP FLAGS
                               LUP_RETURN_TYPE,
                               &hRnr) == SOCKET_ERROR)
    {
        printf( "LookupBegin for local name failed %d\n", GetLastError() );
        goto more;
    }

    while ( WSALookupServiceNext( hRnr,
                                  0,
                                  &dwQuerySize,
                                  Query1) == NO_ERROR )
    {
        printf( "Next succeeded with %d addresses for Service %ws:",
                Query1->dwNumberOfCsAddrs,
                Query1->lpszServiceInstanceName );
        //
        // get the address out. This is the local machine address that
        // can be used in a revere lookup
        //

        if( Query1->dwNumberOfCsAddrs )
        {
            struct sockaddr_in * psock;
            PBYTE p;
            DWORD dwX;

            for( dwX = 0; dwX < Query1->dwNumberOfCsAddrs; dwX++ )
            {
                psock = (struct sockaddr_in *)
                        Query1->lpcsaBuffer[dwX].RemoteAddr.lpSockaddr;
                dwIp = psock->sin_addr.S_un.S_addr;
                p = (PBYTE)&dwIp;
                printf( "\n   socket type %d, protocol %d, length %d addr: %d.%d.%d.%d, port %d\n",
                        Query1->lpcsaBuffer[dwX].iSocketType,
                        Query1->lpcsaBuffer[dwX].iProtocol,
                        Query1->lpcsaBuffer[dwX].RemoteAddr.iSockaddrLength,
                        (DWORD)p[0], (DWORD)p[1], (DWORD)p[2], (DWORD)p[3],
                        (DWORD)ntohs(psock->sin_port));
            }
            break;
        }
    }

    if( WSALookupServiceEnd( hRnr ) )
    {
        printf("ServiceEnd failed %d\n", GetLastError());
    }
    else
    {
        printf("ServiceEnd succeeded\n");
    }

    //
    // Let's try a reverse lookup on this address!
    //
more:

    Query->lpServiceClassId = &ServiceClassId;
    Query->dwNameSpace = dwNameSpace;
    Query->lpafpProtocols = 0;

    //
    // Ready to actually look for one of these ...
    Query->lpszServiceInstanceName = 0;
    Query->dwNumberOfCsAddrs = 1;
    Query->lpcsaBuffer = Query1->lpcsaBuffer;

    if( WSALookupServiceBegin( Query,
                               LUP_RETURN_NAME |
                               LUP_RETURN_ADDR,
                               &hRnr ) == SOCKET_ERROR )
    {
        printf( "LookupBegin for reverse failed  %d\n", GetLastError() );
    }

    //
    // Ready to actually look for one of these ...
    //
    while ( WSALookupServiceNext( hRnr,
                                  0,
                                  &dwQuerySize,
                                  Query ) == NO_ERROR )
    {
        printf( "Next got %ws\n", Query->lpszServiceInstanceName );
    }

    printf( "Next finished with %d\n", GetLastError() );

    //
    // done.
    //
    if( WSALookupServiceEnd( hRnr ) )
    {
        printf( "ServiceEnd failed %d\n", GetLastError() );
    }

    WSACleanup();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\rnratm.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <ws2atm.h>


GUID ATMAType = SVCID_DNS_TYPE_ATMA;

#define BUFFSIZE 3000

_cdecl
main(int argc, char **argv)
{
    HANDLE hLib;
    WCHAR Buffer[BUFFSIZE];
    PWSAQUERYSETW Query = (PWSAQUERYSETW)Buffer;
    HANDLE hRnr;
    DWORD dwIp;
    DWORD dwQuerySize = BUFFSIZE;
    WSADATA wsaData;
    ANSI_STRING         asServiceInstanceName;
    UNICODE_STRING      usServiceInstanceName;
    WCHAR               UnicodeStringBuf[1024];
    ANSI_STRING         asContext;
    UNICODE_STRING      usContext;
    WCHAR               UnicodeStringBuf2[1024];
    AFPROTOCOLS         lpAfpProtocols[1];

    usServiceInstanceName.Length = 0;
    usServiceInstanceName.MaximumLength = 1024;
    usServiceInstanceName.Buffer = UnicodeStringBuf;

    usContext.Length = 0;
    usContext.MaximumLength = 1024;
    usContext.Buffer = UnicodeStringBuf2;

    if ( argc != 2 )
    {
        printf( "\nUsage: rnrtst <Name>\n" );

        return( -1 );
    }

    RtlInitAnsiString( &asServiceInstanceName, argv[1] );

    RtlAnsiStringToUnicodeString( &usServiceInstanceName,
                                  &asServiceInstanceName,
                                  FALSE );

    WSAStartup(MAKEWORD(1, 1), &wsaData);

    memset(Query, 0, sizeof(*Query));

    Query->dwSize = sizeof(*Query);

    if ( usServiceInstanceName.Buffer[0] != L'*' )
    {
        Query->lpszServiceInstanceName = usServiceInstanceName.Buffer;
    }
    Query->lpServiceClassId = &ATMAType;
    Query->lpVersion = 0;
    Query->dwNameSpace = NS_ALL;
    Query->lpNSProviderId = 0;
    Query->lpszContext = NULL;
    Query->dwNumberOfProtocols = 1;

    lpAfpProtocols[0].iAddressFamily = AF_ATM;
    lpAfpProtocols[0].iProtocol = PF_ATM;
    
    Query->lpafpProtocols = lpAfpProtocols;

    if( WSALookupServiceBegin( Query,
                               LUP_RETURN_NAME |
                               LUP_RETURN_TYPE |
                               LUP_RETURN_VERSION |
                               LUP_RETURN_COMMENT |
                               LUP_RETURN_ADDR |
                               LUP_RETURN_BLOB,
                               &hRnr ) == SOCKET_ERROR )
    {
        printf( "LookupBegin failed  %d\n", GetLastError() );
    }

    while ( WSALookupServiceNext( hRnr,
                                  0,
                                  &dwQuerySize,
                                  Query ) == NO_ERROR )
    {
        PCSADDR_INFO csaddrInfo;
        PSOCKADDR_ATM sockaddrAtm;

        printf( "Next got: \n" );
        printf( "   dwSize = %d\n",
                Query->dwSize );
        printf( "   dwOutputFlags = %d\n",
                Query->dwOutputFlags );
        printf( "   lpszServiceInstanceName = %ws\n",
                Query->lpszServiceInstanceName );
        if ( Query->lpVersion )
        {
            printf( "   lpVersion->dwVersion = %d\n",
                    Query->lpVersion->dwVersion );
            printf( "   lpVersion->ecHow = %d\n",
                    Query->lpVersion->ecHow );
        }
        if ( Query->lpszComment )
        {
            printf( "   lpszComment = %ws\n",
                    Query->lpszComment );
        }
        printf( "   dwNameSpace = %d\n",
                Query->dwNameSpace );
        if ( Query->lpszContext )
        {
            printf( "   lpszContext = %ws\n",
                    Query->lpszContext );
        }
        printf( "   dwNumberOfCsAddrs = %d\n",
                Query->dwNumberOfCsAddrs );

        if ( Query->dwNumberOfCsAddrs )
        {
            DWORD iter;

            csaddrInfo = Query->lpcsaBuffer;

            for ( iter = 0; iter < Query->dwNumberOfCsAddrs; iter++ )
            {
                sockaddrAtm =
                    (PSOCKADDR_ATM) csaddrInfo->RemoteAddr.lpSockaddr; 

                printf( "        CsAddrInfo[%d]\n", iter );
                printf( "            iSocketType = %d\n",
                        csaddrInfo->iSocketType );
                printf( "            iProtocol = %d\n",
                        csaddrInfo->iProtocol );

                printf( "            ATM address (Remote)\n" );
                printf( "                Address Type = %d\n",
                        sockaddrAtm->satm_number.AddressType );
                printf( "                Address Length = %d\n",
                        sockaddrAtm->satm_number.NumofDigits );
                if ( sockaddrAtm->satm_number.AddressType == ATM_E164 )
                    printf( "                Address = %s\n",
                            sockaddrAtm->satm_number.Addr );
                else
                {
                    DWORD jiter;

                    printf( "                Address = " );

                    for ( jiter = 0; jiter < ATM_ADDR_SIZE; jiter++ )
                    {
                        printf( "%02x", sockaddrAtm->satm_number.Addr[jiter] );
                    }

                    printf( "\n" );
                }

                csaddrInfo++;
            }
        }
    }

    printf( "Next finished with %d\n", GetLastError() );

    if( WSALookupServiceEnd( hRnr ) )
    {
        printf( "ServiceEnd failed %d\n", GetLastError() );
    }

    WSACleanup();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\rnrtst2.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


GUID ServiceClassId = { /* 5b50962a-e5a5-11cf-a555-00c04fd8d4ac */
    0x5b50962a,
    0xe5a5,
    0x11cf,
    {0xa5, 0x55, 0x00, 0xc0, 0x4f, 0xd8, 0xd4, 0xac}
  };

GUID ServiceGuid = { 0x47da8500, 0x96a1, 0x11cd, 0x90, 0x1d,
                     0x20, 0x4c, 0x4f, 0x4f, 0x50, 0x20 };

#define BUFFSIZE 3000

_cdecl
main(int argc, char **argv)
{
    HANDLE hLib;
    WCHAR Buffer[BUFFSIZE];
    PWSAQUERYSETW Query = (PWSAQUERYSETW)Buffer;
    HANDLE hRnr;
    DWORD dwIp;
    DWORD dwQuerySize = BUFFSIZE;
    WSADATA wsaData;
    ANSI_STRING         asServiceInstanceName;
    UNICODE_STRING      usServiceInstanceName;
    WCHAR               UnicodeStringBuf[1024];
    ANSI_STRING         asContext;
    UNICODE_STRING      usContext;
    WCHAR               UnicodeStringBuf2[1024];
    AFPROTOCOLS         lpAfpProtocols[3];

    usServiceInstanceName.Length = 0;
    usServiceInstanceName.MaximumLength = 1024;
    usServiceInstanceName.Buffer = UnicodeStringBuf;

    usContext.Length = 0;
    usContext.MaximumLength = 1024;
    usContext.Buffer = UnicodeStringBuf2;

    if ( argc != 5 )
    {
        printf( "\nUsage: lookup <Name> <Context> Deep Echo\n" );

        return( -1 );
    }

    RtlInitAnsiString( &asServiceInstanceName, argv[1] );

    RtlAnsiStringToUnicodeString( &usServiceInstanceName,
                                  &asServiceInstanceName,
                                  FALSE );

    RtlInitAnsiString( &asContext, argv[2] );

    RtlAnsiStringToUnicodeString( &usContext,
                                  &asContext,
                                  FALSE );

    WSAStartup(MAKEWORD(1, 1), &wsaData);

    memset(Query, 0, sizeof(*Query));

    Query->dwSize = sizeof(*Query);

    if ( usServiceInstanceName.Buffer[0] != L'*' )
    {
        Query->lpszServiceInstanceName = usServiceInstanceName.Buffer;
    }

    if ( argv[4][0] == 'E' )
    {
        Query->lpServiceClassId = &ServiceGuid;
    }
    else
    {
        Query->lpServiceClassId = &ServiceClassId;
    }
    Query->lpVersion = 0;
    Query->dwNameSpace = NS_NTDS;
    Query->lpNSProviderId = 0;
    Query->lpszContext = usContext.Buffer;
    Query->dwNumberOfProtocols = 0;

    lpAfpProtocols[0].iAddressFamily = AF_INET;
    lpAfpProtocols[0].iProtocol = PF_INET;
    lpAfpProtocols[1].iAddressFamily = AF_IPX;
    lpAfpProtocols[1].iProtocol = PF_IPX;
    lpAfpProtocols[2].iAddressFamily = AF_UNSPEC;
    lpAfpProtocols[2].iProtocol = PF_UNSPEC;
    
    Query->lpafpProtocols = lpAfpProtocols;

    if( WSALookupServiceBegin( Query,
                               ( argv[3][0] == 'D' ? LUP_DEEP : 0 ) |
                               LUP_RETURN_NAME |
                               LUP_RETURN_TYPE |
                               LUP_RETURN_VERSION |
                               LUP_RETURN_COMMENT |
                               LUP_RETURN_ADDR |
                               LUP_RETURN_BLOB,
                               // LUP_RETURN_ALIASES |
                               // LUP_RETURN_QUERY_STRING |
                               // LUP_RETURN_ALL,
                               &hRnr ) == SOCKET_ERROR )
    {
        printf( "LookupBegin failed  %d\n", GetLastError() );
    }

    while ( WSALookupServiceNext( hRnr,
                                  0,
                                  &dwQuerySize,
                                  Query ) == NO_ERROR )
    {
        printf( "Next got: \n" );
        printf( "   dwSize = %d\n",
                Query->dwSize );
        printf( "   dwOutputFlags = %d\n",
                Query->dwOutputFlags );
        printf( "   lpszServiceInstanceName = %ws\n",
                Query->lpszServiceInstanceName );
        if ( Query->lpVersion )
        {
            printf( "   lpVersion->dwVersion = %d\n",
                    Query->lpVersion->dwVersion );
            printf( "   lpVersion->ecHow = %d\n",
                    Query->lpVersion->ecHow );
        }
        if ( Query->lpszComment )
        {
            printf( "   lpszComment = %ws\n",
                    Query->lpszComment );
        }
        printf( "   dwNameSpace = %d\n",
                Query->dwNameSpace );
        if ( Query->lpszContext )
        {
            printf( "   lpszContext = %ws\n",
                    Query->lpszContext );
        }
        printf( "   dwNumberOfCsAddrs = %d\n",
                Query->dwNumberOfCsAddrs );
    }

    printf( "Next finished with %d\n", GetLastError() );

    if( WSALookupServiceEnd( hRnr ) )
    {
        printf( "ServiceEnd failed %d\n", GetLastError() );
    }

    WSACleanup();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\rsc.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


GUID    ServiceClassId = { /* 5b50962a-e5a5-11cf-a555-00c04fd8d4ac */
    0x5b50962a,
    0xe5a5,
    0x11cf,
    {0xa5, 0x55, 0x00, 0xc0, 0x4f, 0xd8, 0xd4, 0xac}
  };


_cdecl
main(int argc, char **argv)
{
    DWORD                ret;
    WSADATA              wsaData;

    WSAStartup( MAKEWORD(1, 1), &wsaData );

    ret = WSARemoveServiceClass( &ServiceClassId );

    if ( ret )
    {
        printf("Error: WSARemoveServiceClass returned 0x%X\n", ret );
        printf("   GetLastError returned 0x%X\n", GetLastError() );

        WSACleanup();

        return -1;
    }

    printf( "Service class was removed\n" );

    WSACleanup();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nameres\rnr\setup\test\rnrtst3.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>

#define BUFFSIZE 3000

GUID ServiceClassId = { /* 5b50962a-e5a5-11cf-a555-00c04fd8d4ac */
    0x5b50962a,
    0xe5a5,
    0x11cf,
    {0xa5, 0x55, 0x00, 0xc0, 0x4f, 0xd8, 0xd4, 0xac}
  };

_cdecl
main(int argc, char **argv)
{
    HANDLE hLib;
    WCHAR Buffer[BUFFSIZE];
    PWSAQUERYSETW Query = (PWSAQUERYSETW)Buffer;
    HANDLE hRnr;
    DWORD dwIp;
    DWORD dwQuerySize = BUFFSIZE;
    WSADATA wsaData;
    ANSI_STRING         asServiceInstanceName;
    UNICODE_STRING      usServiceInstanceName;
    WCHAR               UnicodeStringBuf[1024];
    ANSI_STRING         asContext;
    UNICODE_STRING      usContext;
    WCHAR               UnicodeStringBuf2[1024];

    usServiceInstanceName.Length = 0;
    usServiceInstanceName.MaximumLength = 1024;
    usServiceInstanceName.Buffer = UnicodeStringBuf;

    usContext.Length = 0;
    usContext.MaximumLength = 1024;
    usContext.Buffer = UnicodeStringBuf2;

    if ( argc < 2 || argc > 4 )
    {
        printf( "\nUsage: lookup <Name> <Context> Deep\n" );

        return( -1 );
    }

    RtlInitAnsiString( &asServiceInstanceName, argv[1] );
    RtlAnsiStringToUnicodeString( &usServiceInstanceName,
                                  &asServiceInstanceName,
                                  FALSE );
    RtlInitAnsiString( &asContext, argv[2] );
    RtlAnsiStringToUnicodeString( &usContext,
                                  &asContext,
                                  FALSE );

    WSAStartup(MAKEWORD(1, 1), &wsaData);

    memset(Query, 0, sizeof(*Query));

    Query->dwSize = sizeof(*Query);
    Query->lpszServiceInstanceName = usServiceInstanceName.Buffer;
    Query->lpVersion = 0;
    Query->dwNameSpace = NS_NTDS;
    Query->lpNSProviderId = 0;
    Query->lpszContext = usContext.Buffer;
    Query->dwNumberOfProtocols = 0;
    Query->lpServiceClassId = &ServiceClassId;

    if( WSALookupServiceBegin( Query,
                               ( argv[3][0] == 'D' ? LUP_DEEP : 0 ) |
                               LUP_RETURN_NAME |
                               // LUP_RETURN_TYPE |
                               // LUP_RETURN_VERSION |
                               LUP_RETURN_COMMENT |
                               // LUP_RETURN_ADDR |
                               // LUP_RETURN_BLOB |
                               // LUP_RETURN_ALIASES |
                               // LUP_RETURN_QUERY_STRING |
                               LUP_CONTAINERS,
                               // LUP_RETURN_ALL,
                               &hRnr ) == SOCKET_ERROR )
    {
        printf( "LookupBegin failed  %d\n", GetLastError() );
    }

    while ( WSALookupServiceNext( hRnr,
                                  0,
                                  &dwQuerySize,
                                  Query ) == NO_ERROR )
    {
        printf( "Next got: \n" );
        printf( "   dwSize = %d\n",
                Query->dwSize );
        printf( "   dwOutputFlags = %d\n",
                Query->dwOutputFlags );
        printf( "   lpszServiceInstanceName = %ws\n",
                Query->lpszServiceInstanceName );
        if ( Query->lpVersion )
        {
            printf( "   lpVersion->dwVersion = %d\n",
                    Query->lpVersion->dwVersion );
            printf( "   lpVersion->ecHow = %d\n",
                    Query->lpVersion->ecHow );
        }
        if ( Query->lpszComment )
        {
            printf( "   lpszComment = %ws\n",
                    Query->lpszComment );
        }
        printf( "   dwNameSpace = %d\n",
                Query->dwNameSpace );
        if ( Query->lpszContext )
        {
            printf( "   lpszContext = %ws\n",
                    Query->lpszContext );
        }
        printf( "   dwNumberOfCsAddrs = %d\n",
                Query->dwNumberOfCsAddrs );
    }

    printf( "Next finished with %d\n", GetLastError() );

    if( WSALookupServiceEnd( hRnr ) )
    {
        printf( "ServiceEnd failed %d\n", GetLastError() );
    }

    WSACleanup();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\anydc.c ===
/*--

Copyright (c) 1995 Microsoft Corporation

Module Name:

    anydc.c

Abstract:

    Test program for the Finding a DC in any domain

Author:

    04-Sep-1995 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:


--*/


//
// Common include files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef DOMAIN_ALL_ACCESS // defined in both ntsam.h and ntwinapi.h
#include <ntsam.h>
#include <ntlsa.h>

#include <windows.h>
#include <lmcons.h>

// #include <accessp.h>
//#include <icanon.h>
#include <lmerr.h>
// #include <lmwksta.h>
// #include <lmaccess.h>
// #include <lmapibuf.h>
// #include <lmremutl.h>           // NetpRemoteComputerSupports(), SUPPORTS_ stuff
// #include <lmsvc.h>              // SERVICE_WORKSTATION.
#include <lmuse.h>              // NetUseDel()
// #include <netlogon.h>           // Needed by logonp.h
// #include <logonp.h>             // I_NetGetDCList()
// #include <names.h>
// #include <netdebug.h>
#include <netlib.h>
// #include <netlibnt.h>
// #include <winnetwk.h>

// #include <secobj.h>

#include <stddef.h>
#include <stdio.h>

#include <uasp.h>

// #include <rpc.h>                // Needed by NetRpc.h
// #include <netrpc.h>             // My prototype, NET_REMOTE_FLAG_ equates.
// #include <rpcutil.h>            // NetpRpcStatusToApiStatus().
#include <tstring.h>            // NetAllocWStrFromStr

#include <wtypes.h>


VOID
PrintStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    default:
        printf( " %ld", NetStatus );
        break;

    }

    printf( "\n" );
}


VOID
NlpDumpSid(
    IN PSID Sid OPTIONAL
    )
/*++

Routine Description:

    Dumps a SID

Arguments:

    DebugFlag - Debug flag to pass on to NlPrintRoutine

    Sid - SID to output

Return Value:

    none

--*/
{
    //
    // Output the SID
    //

    if ( Sid == NULL ) {
        printf( "(null)\n" );
    } else {
        UNICODE_STRING SidString;
        NTSTATUS Status;

        Status = RtlConvertSidToUnicodeString( &SidString, Sid, TRUE );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Invalid 0x%lX\n", Status );
        } else {
            printf( "%wZ\n", &SidString );
            RtlFreeUnicodeString( &SidString );
        }
    }

}

int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Call UaspOpenDomainWithDomainName with first arguement

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    NET_API_STATUS NetStatus;
    LPWSTR DomainName;
    BOOL AccountDomain;
    SAM_HANDLE DomainHandle;
    PSID DomainId;


    //
    // Validate the argument count
    //

    if ( argc != 2 && argc != 3) {
        fprintf( stderr, "Usage: anydc <DomainName> [Builtin]\n");
        return 1;
    }


    //
    // Convert the args to unicode
    //

    DomainName = NetpAllocWStrFromStr( argv[1] );
    AccountDomain = argc < 3;

    //
    // Find a DC
    //

    NetStatus = UaspOpenDomainWithDomainName(
                    DomainName,
                    0,
                    AccountDomain,
                    &DomainHandle,
                    &DomainId );

    PrintStatus( NetStatus );

    if ( NetStatus == NERR_Success ) {
        printf( "Sid is: ");
        NlpDumpSid( DomainId );

        UaspCloseDomain( DomainHandle );

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\alias.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    alias.c

Abstract:

    NetLocalGroup API functions

Author:

    Cliff Van Dyke (cliffv) 05-Mar-1991  Original group.c
    Rita Wong      (ritaw)  27-Nov-1992  Adapted for alias.c

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef DOMAIN_ALL_ACCESS // defined in both ntsam.h and ntwinapi.h
#include <ntsam.h>
#include <ntlsa.h>

#include <windef.h>
#include <winbase.h>
#include <lmcons.h>

#include <access.h>
#include <align.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <netdebug.h>
#include <netlib.h>
#include <netlibnt.h>
#include <rpcutil.h>
#include <rxgroup.h>
#include <prefix.h>
#include <stddef.h>
#include <uasp.h>
#include <stdlib.h>

/*lint -e614 */  /* Auto aggregate initializers need not be constant */

// Lint complains about casts of one structure type to another.
// That is done frequently in the code below.
/*lint -e740 */  /* don't complain about unusual cast */ \




NET_API_STATUS NET_API_FUNCTION
NetLocalGroupAdd(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD Level,
    IN LPBYTE Buffer,
    OUT LPDWORD ParmError OPTIONAL // Name required by NetpSetParmError
    )

/*++

Routine Description:

    Create a local group (alias) account in the user account database.
    This local group is created in the account domain.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    Level - Level of information provided.  Must be 0, or 1.

    Buffer - A pointer to the buffer containing the group information
        structure.

    ParmError - Optional pointer to a DWORD to return the index of the
        first parameter in error when ERROR_INVALID_PARAMETER is returned.
        If NULL, the parameter is not returned on error.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    LPWSTR AliasName;
    UNICODE_STRING AliasNameString;
    LPWSTR AliasComment;
    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAM_HANDLE AliasHandle = NULL;
    ULONG RelativeId;


    //
    // Initialize
    //

    NetpSetParmError( PARM_ERROR_NONE );

    //
    // Validate Level parameter and fields of structures.
    //

    switch (Level) {
    case 0:
        AliasName = ((PLOCALGROUP_INFO_0) Buffer)->lgrpi0_name;
        AliasComment = NULL;
        break;

    case 1:
        AliasName = ((PLOCALGROUP_INFO_1) Buffer)->lgrpi1_name;
        AliasComment = ((PLOCALGROUP_INFO_1) Buffer)->lgrpi1_comment;
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_ALIAS ) {
            NetpKdPrint(( "NetLocalGroupAdd: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Make sure that the alias does not already exist in the builtin
    // domain.
    //

    NetStatus = AliaspOpenAliasInDomain( SamServerHandle,
                                         AliaspBuiltinDomain,
                                         ALIAS_READ_INFORMATION,
                                         AliasName,
                                         &AliasHandle );

    if ( NetStatus == NERR_Success ) {

        //
        // We found it in builtin domain.  Cannot create same one in
        // account domain.
        //
        (VOID) SamCloseHandle( AliasHandle );
        NetStatus = ERROR_ALIAS_EXISTS;
        goto Cleanup;
    }

    //
    // Open the Domain asking for DOMAIN_CREATE_ALIAS access.
    //
    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_CREATE_ALIAS | DOMAIN_LOOKUP,
                                TRUE,   // Account Domain
                                &DomainHandle,
                                NULL);  // DomainId

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_ALIAS ) {
            NetpKdPrint(( "NetLocalGroupAdd: Cannot UaspOpenDomain %ld\n", NetStatus ));
        }
        goto Cleanup;
    }


    //
    // Create the LocalGroup with the specified group name
    // (and a default security descriptor).
    //
    RtlInitUnicodeString( &AliasNameString, AliasName );

    Status = SamCreateAliasInDomain( DomainHandle,
                                     &AliasNameString,
                                     DELETE | ALIAS_WRITE_ACCOUNT,
                                     &AliasHandle,
                                     &RelativeId );


    if ( !NT_SUCCESS(Status) ) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Set the Admin Comment on the group.
    //
    if (Level == 1) {

        ALIAS_ADM_COMMENT_INFORMATION AdminComment;


        RtlInitUnicodeString( &AdminComment.AdminComment, AliasComment );

        Status = SamSetInformationAlias( AliasHandle,
                                         AliasAdminCommentInformation,
                                         &AdminComment );

        if ( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );

            Status = SamDeleteAlias( AliasHandle );

            goto Cleanup;
        }

    }

    //
    // Close the created alias.
    //
    (VOID) SamCloseHandle( AliasHandle );
    NetStatus = NERR_Success;

    //
    // Clean up
    //

Cleanup:
    IF_DEBUG( UAS_DEBUG_ALIAS ) {
        NetpKdPrint(( "NetLocalGroupAdd: returns %lu\n", NetStatus ));
    }
    UaspCloseDomain( DomainHandle );
    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }
    return NetStatus;

} // NetLocalGroupAdd


NET_API_STATUS NET_API_FUNCTION
NetLocalGroupAddMember(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR LocalGroupName,
    IN PSID MemberSid
    )

/*++

Routine Description:

    Give an existing user or global group account membership in an existing
    local group.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    LocalGroupName - Name of the local group to which the user or global
        group is to be given membership.

    MemberName - SID of the user or global group to be given local group
        membership.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;


    //
    // Call the routine shared by NetLocalGroupAddMember and
    // NetLocalGroupDelMember
    //

    NetStatus = AliaspChangeMember( ServerName, LocalGroupName, MemberSid, TRUE);

    IF_DEBUG( UAS_DEBUG_ALIAS ) {
        NetpKdPrint(( PREFIX_NETAPI
                      "NetLocalGroupAddMember: returns %lu\n", NetStatus ));
    }

    return NetStatus;

} // NetLocalGroupAddMember


NET_API_STATUS NET_API_FUNCTION
NetLocalGroupDel(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR LocalGroupName
    )

/*++

Routine Description:

    Delete a localgroup (alias).

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    LocalGroupName - Name of the local group (alias) to delete.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE AliasHandle = NULL;

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_ALIAS ) {
            NetpKdPrint(( "NetLocalGroupDel: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }


    //
    // Look for the specified alias in either the builtin or account
    // domain.
    //
    NetStatus = AliaspOpenAliasInDomain(
                    SamServerHandle,
                    AliaspBuiltinOrAccountDomain,
                    DELETE,
                    LocalGroupName,
                    &AliasHandle );

    if (NetStatus != NERR_Success) {
        goto Cleanup;
    }

    //
    // Delete it.
    //
    Status = SamDeleteAlias(AliasHandle);

    if (! NT_SUCCESS(Status)) {
        NetpKdPrint((PREFIX_NETAPI
                     "NetLocalGroupDel: SamDeleteAlias returns %lX\n",
                     Status));

        NetStatus = NetpNtStatusToApiStatus(Status);
        AliasHandle = NULL;
        goto Cleanup;
    } else {
        //
        // Don't touch the handle once it has been deleted
        //
        AliasHandle = NULL;
    }


    NetStatus = NERR_Success;

Cleanup:
    if ( AliasHandle != NULL ) {
        (void) SamCloseHandle(AliasHandle);
    }

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    IF_DEBUG( UAS_DEBUG_ALIAS ) {
        NetpKdPrint(( "NetLocalGroupDel: returns %lu\n", NetStatus ));
    }

    return NetStatus;

} // NetLocalGroupDel


NET_API_STATUS NET_API_FUNCTION
NetLocalGroupDelMember(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR LocalGroupName,
    IN PSID MemberSid
    )

/*++

Routine Description:

    Remove a user from a particular local group.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    LocalGroupName - Name of the local group (alias) from which the
        user is to be removed.

    MemberSid - SID of the user to be removed from the alias.

Return Value:

    Error code for the operation.

--*/

{
    //
    // Call the routine shared by NetAliasAddMember and NetAliasDelMember
    //

    return AliaspChangeMember( ServerName, LocalGroupName, MemberSid, FALSE );

} // NetLocalGroupDelMember



NET_API_STATUS NET_API_FUNCTION
NetLocalGroupEnum(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE *Buffer,
    IN DWORD PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT PDWORD_PTR ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    Retrieve information about each local group on a server.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    Level - Level of information required. 0, 1 and 2 are valid.

    Buffer - Returns a pointer to the return information structure.
        Caller must deallocate buffer using NetApiBufferFree.

    PrefMaxLen - Prefered maximum length of returned data.

    EntriesRead - Returns the actual enumerated element count.

    EntriesLeft - Returns the total entries available to be enumerated.

    ResumeHandle -  Used to continue an existing search.  The handle should
        be zero on the first call and left unchanged for subsequent calls.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    PSAM_RID_ENUMERATION SamEnum;   // Sam returned buffer
    PLOCALGROUP_INFO_0 lgrpi0;
    PLOCALGROUP_INFO_0 lgrpi0_temp = NULL;
    SAM_HANDLE SamServerHandle = NULL;

    BUFFER_DESCRIPTOR BufferDescriptor;
    PDOMAIN_GENERAL_INFORMATION DomainGeneral;

    //
    // Declare Opaque group enumeration handle.
    //

    struct _UAS_ENUM_HANDLE {
        SAM_HANDLE  DomainHandleBuiltin;        // Enumerate built in domain first
        SAM_HANDLE  DomainHandleAccounts;       // Aliases in the accounts domain
        SAM_HANDLE  DomainHandleCurrent;        // where to get info from

        SAM_ENUMERATE_HANDLE SamEnumHandle;     // Current Sam Enum Handle
        PSAM_RID_ENUMERATION SamEnum;           // Sam returned buffer
        ULONG Index;                            // Index to current entry
        ULONG Count;                            // Total Number of entries
        ULONG TotalRemaining;

        BOOL SamDoneWithBuiltin ;               // Set to TRUE after all of
                                                // builtin domain is enumerated
        BOOL SamAllDone;                        // True if both the accounts
                                                // and builtin have been
                                                // enumerated

    } *UasEnumHandle = NULL;


    //
    // If this is a resume, get the resume handle that the caller passed in.
    //

    BufferDescriptor.Buffer = NULL;
    *EntriesRead = 0;
    *EntriesLeft = 0;
    *Buffer = NULL;

    if ( ARGUMENT_PRESENT( ResumeHandle ) && *ResumeHandle != 0 ) {
/*lint -e511 */  /* Size incompatibility */
        UasEnumHandle = (struct _UAS_ENUM_HANDLE *) *ResumeHandle;
/*lint +e511 */  /* Size incompatibility */

    //
    // If this is not a resume, allocate and initialize a resume handle.
    //

    } else {

        //
        // Allocate a resume handle.
        //

        UasEnumHandle = NetpMemoryAllocate( sizeof(struct _UAS_ENUM_HANDLE) );

        if ( UasEnumHandle == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Initialize all the fields in the newly allocated resume handle
        //  to indicate that SAM has never yet been called.
        //
        UasEnumHandle->DomainHandleAccounts = NULL;
        UasEnumHandle->DomainHandleBuiltin  = NULL;
        UasEnumHandle->DomainHandleCurrent  = NULL;
        UasEnumHandle->SamEnumHandle = 0;
        UasEnumHandle->SamEnum = NULL;
        UasEnumHandle->Index = 0;
        UasEnumHandle->Count = 0;
        UasEnumHandle->TotalRemaining = 0;
        UasEnumHandle->SamDoneWithBuiltin = FALSE;
        UasEnumHandle->SamAllDone = FALSE;

        //
        // Connect to the SAM server
        //

        NetStatus = UaspOpenSam( ServerName,
                                 FALSE,  // Don't try null session
                                 &SamServerHandle );

        if ( NetStatus != NERR_Success ) {
            IF_DEBUG( UAS_DEBUG_ALIAS ) {
                NetpKdPrint(( "NetLocalGroupEnum: Cannot UaspOpenSam %ld\n", NetStatus ));
            }
            goto Cleanup;
        }

        //
        // Open the Domains.
        //

        NetStatus = UaspOpenDomain( SamServerHandle,
                                    DOMAIN_LOOKUP |
                                        DOMAIN_LIST_ACCOUNTS |
                                        DOMAIN_READ_OTHER_PARAMETERS,
                                    FALSE,   // Builtin Domain
                                    &UasEnumHandle->DomainHandleBuiltin,
                                    NULL );

        if ( NetStatus != NERR_Success ) {
            goto Cleanup;
        }

        NetStatus = UaspOpenDomain( SamServerHandle,
                                    DOMAIN_LOOKUP |
                                        DOMAIN_LIST_ACCOUNTS |
                                        DOMAIN_READ_OTHER_PARAMETERS,
                                    TRUE,   // Account Domain
                                    &UasEnumHandle->DomainHandleAccounts,
                                    NULL );

        if ( NetStatus != NERR_Success ) {
            goto Cleanup;
        }

        //
        // Get the total number of aliases from SAM
        //
        Status = SamQueryInformationDomain( UasEnumHandle->DomainHandleBuiltin,
                                            DomainGeneralInformation,
                                            (PVOID *)&DomainGeneral );

        if ( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        UasEnumHandle->TotalRemaining = DomainGeneral->AliasCount;
        (void) SamFreeMemory( DomainGeneral );

        Status = SamQueryInformationDomain( UasEnumHandle->DomainHandleAccounts,
                                            DomainGeneralInformation,
                                            (PVOID *)&DomainGeneral );

        if ( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        UasEnumHandle->TotalRemaining += DomainGeneral->AliasCount;
        (void) SamFreeMemory( DomainGeneral );
    }


    //
    // Loop for each alias
    //
    // Each iteration of the loop below puts one more entry into the array
    // returned to the caller.  The algorithm is split into 3 parts.  The
    // first part checks to see if we need to retrieve more information from
    // SAM.  We then get the description of several aliases from SAM in a single
    // call.  The second part sees if there is room for this entry in the
    // buffer we'll return to the caller.  If not, a larger buffer is allocated
    // for return to the caller.  The third part puts the entry in the
    // buffer.
    //

    for ( ;; ) {
        DWORD FixedSize;
        DWORD Size;

        //
        // Get more alias information from SAM
        //
        // Handle when we've already consumed all of the information
        // returned on a previous call to SAM.  This is a 'while' rather
        // than an if to handle the case where SAM returns zero entries.
        //

        while ( UasEnumHandle->Index >= UasEnumHandle->Count ) {

            //
            // If we've already gotten everything from SAM,
            //      return all done status to our caller.
            //

            if ( UasEnumHandle->SamAllDone ) {
                NetStatus = NERR_Success;
                goto Cleanup;
            }

            //
            // Free any previous buffer returned from SAM.
            //

            if ( UasEnumHandle->SamEnum != NULL ) {
                Status = SamFreeMemory( UasEnumHandle->SamEnum );
                NetpAssert( NT_SUCCESS(Status) );

                UasEnumHandle->SamEnum = NULL;
            }

            //
            // Do the actual enumeration
            //

            UasEnumHandle->DomainHandleCurrent  =
                        UasEnumHandle->SamDoneWithBuiltin ?
                            UasEnumHandle->DomainHandleAccounts :
                            UasEnumHandle->DomainHandleBuiltin,
            Status = SamEnumerateAliasesInDomain(
                        UasEnumHandle->DomainHandleCurrent,
                        &UasEnumHandle->SamEnumHandle,
                        (PVOID *)&UasEnumHandle->SamEnum,
                        PrefMaxLen,
                        &UasEnumHandle->Count );

            if ( !NT_SUCCESS( Status ) ) {
                NetStatus = NetpNtStatusToApiStatus( Status );
                goto Cleanup;
            }

            //
            // Adjust TotalRemaining as we get better information
            //

            if (UasEnumHandle->TotalRemaining < UasEnumHandle->Count) {
                UasEnumHandle->TotalRemaining = UasEnumHandle->Count;
            }

            //
            // If SAM says there is more information, just ensure he returned
            // something to us on this call.
            //

            if ( Status == STATUS_MORE_ENTRIES ) {
                if ( UasEnumHandle->Count == 0 ) {
                    NetStatus = NERR_BufTooSmall;
                    goto Cleanup;
                }

            //
            // If SAM says he's returned all of the information for this domain,
            // check if we still have to do the accounts domain.
            //

            } else {

                if ( UasEnumHandle->SamDoneWithBuiltin ) {

                    UasEnumHandle->SamAllDone = TRUE;

                } else {

                    UasEnumHandle->SamDoneWithBuiltin = TRUE ;
                    UasEnumHandle->SamEnumHandle = 0;
                }
            }

            UasEnumHandle->Index = 0;
        }

        //
        // ASSERT:  UasEnumHandle identifies the next entry to return
        //          from SAM.
        //

        SamEnum = &UasEnumHandle->SamEnum[UasEnumHandle->Index];


        //
        // Place this entry into the return buffer.
        //
        // Determine the size of the data passed back to the caller
        //

        switch (Level) {
        case 0:
            FixedSize = sizeof(LOCALGROUP_INFO_0);
            Size = sizeof(LOCALGROUP_INFO_0) +
                SamEnum->Name.Length + sizeof(WCHAR);
            break;

        case 1:
            {
                SAM_HANDLE AliasHandle ;
                NetStatus = AliaspOpenAlias2(
                                        UasEnumHandle->DomainHandleCurrent,
                                        ALIAS_READ_INFORMATION,
                                        SamEnum->RelativeId,
                                        &AliasHandle ) ;

                if ( NetStatus != NERR_Success ) {
                    goto Cleanup;
                }

                NetStatus = AliaspGetInfo( AliasHandle,
                                           Level,
                                           (PVOID *)&lgrpi0_temp);

                (void) SamCloseHandle( AliasHandle ) ;

                if ( NetStatus != NERR_Success ) {
                    goto Cleanup;
                }

                FixedSize = sizeof(LOCALGROUP_INFO_1);
                Size = sizeof(LOCALGROUP_INFO_1) +
                        SamEnum->Name.Length + sizeof(WCHAR) +
                        (wcslen(((PLOCALGROUP_INFO_1)lgrpi0_temp)->lgrpi1_comment) +
                            1) * sizeof(WCHAR);
            }
            break;

        default:
            NetStatus = ERROR_INVALID_LEVEL;
            goto Cleanup;
        }

        //
        // Ensure there is buffer space for this information.
        //

        Size = ROUND_UP_COUNT( Size, ALIGN_WCHAR );

        NetStatus = NetpAllocateEnumBuffer(
                        &BufferDescriptor,
                        FALSE,      // Not a 'get' operation
                        PrefMaxLen,
                        Size,
                        AliaspRelocationRoutine,
                        Level );

        if (NetStatus != NERR_Success) {
            goto Cleanup;
        }

        //
        // Fill in the information.  The array of fixed entries is
        // placed at the beginning of the allocated buffer.  The strings
        // pointed to by these fixed entries are allocated starting at
        // the end of the allocate buffer.
        //

        //
        // Copy the common group name
        //

        NetpAssert( offsetof( LOCALGROUP_INFO_0, lgrpi0_name ) ==
                    offsetof( LOCALGROUP_INFO_1, lgrpi1_name ) );

        lgrpi0 = (PLOCALGROUP_INFO_0)(BufferDescriptor.FixedDataEnd);
        BufferDescriptor.FixedDataEnd += FixedSize;

        //
        // Fill in the Level dependent fields
        //

        switch ( Level ) {

        case 1:
            if ( !NetpCopyStringToBuffer(
                        ((PLOCALGROUP_INFO_1)lgrpi0_temp)->lgrpi1_comment,
                        wcslen(((PLOCALGROUP_INFO_1)lgrpi0_temp)->lgrpi1_comment),
                        BufferDescriptor.FixedDataEnd,
                        (LPWSTR *)&BufferDescriptor.EndOfVariableData,
                        &((PLOCALGROUP_INFO_1)lgrpi0)->lgrpi1_comment) ) {

                NetStatus = NERR_InternalError;
                goto Cleanup;
            }

            MIDL_user_free( lgrpi0_temp );
            lgrpi0_temp = NULL;

            /* FALL THROUGH FOR THE NAME FIELD */

        case 0:

            if ( !NetpCopyStringToBuffer(
                            SamEnum->Name.Buffer,
                            SamEnum->Name.Length/sizeof(WCHAR),
                            BufferDescriptor.FixedDataEnd,
                            (LPWSTR *)&BufferDescriptor.EndOfVariableData,
                            &(lgrpi0->lgrpi0_name))){

                NetStatus = NERR_InternalError;
                goto Cleanup;
            }

            break;


        default:
            NetStatus = ERROR_INVALID_LEVEL;
            goto Cleanup;

        }

        //
        // ASSERT: The current entry has been completely copied to the
        //  return buffer.
        //

        (*EntriesRead)++;

        UasEnumHandle->Index ++;
        UasEnumHandle->TotalRemaining --;
    }

    //
    // Clean up.
    //

Cleanup:
    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    //
    // Free any locally used resources.
    //

    if ( lgrpi0_temp != NULL ) {
        MIDL_user_free( lgrpi0_temp );
    }

    //
    // Set EntriesLeft to the number left to return plus those that
    //  we returned on this call.
    //

    if ( UasEnumHandle != NULL ) {
        *EntriesLeft = UasEnumHandle->TotalRemaining + *EntriesRead;
    }

    //
    // If we're done or the caller doesn't want an enumeration handle,
    //  free the enumeration handle.
    //

    if ( NetStatus != ERROR_MORE_DATA || !ARGUMENT_PRESENT( ResumeHandle ) ) {

        if ( UasEnumHandle != NULL ) {
            if ( UasEnumHandle->DomainHandleAccounts != NULL ) {
                UaspCloseDomain( UasEnumHandle->DomainHandleAccounts );
            }

            if ( UasEnumHandle->DomainHandleBuiltin != NULL ) {
                UaspCloseDomain( UasEnumHandle->DomainHandleBuiltin );
            }

            if ( UasEnumHandle->SamEnum != NULL ) {
                Status = SamFreeMemory( UasEnumHandle->SamEnum );
                NetpAssert( NT_SUCCESS(Status) );
            }

            NetpMemoryFree( UasEnumHandle );
            UasEnumHandle = NULL;
        }

    }

    //
    // If we're not returning data to the caller,
    //  free the return buffer.
    //

    if ( NetStatus != ERROR_MORE_DATA && NetStatus != NERR_Success ) {
        if ( BufferDescriptor.Buffer != NULL ) {
            MIDL_user_free( BufferDescriptor.Buffer );
            BufferDescriptor.Buffer = NULL;
        }
        *EntriesRead = 0;
        *EntriesLeft = 0;
    }

    //
    // Set the output parameters
    //

    *Buffer = BufferDescriptor.Buffer;
    if ( ARGUMENT_PRESENT( ResumeHandle ) ) {
        *ResumeHandle = (DWORD_PTR) UasEnumHandle;
    }


    IF_DEBUG( UAS_DEBUG_ALIAS ) {
        NetpKdPrint(( "NetLocalGroupEnum: returns %ld\n", NetStatus ));
    }

    return NetStatus;
}


NET_API_STATUS NET_API_FUNCTION
NetLocalGroupGetInfo(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR LocalGroupName,
    IN DWORD Level,
    OUT LPBYTE *Buffer
    )

/*++

Routine Description:

    Retrieve information about a particular local group (alias).

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    LocalGroupName - Name of the group to get information about.

    Level - Level of information required. 0, 1 and 2 are valid.

    Buffer - Returns a pointer to the return information structure.
        Caller must deallocate buffer using NetApiBufferFree.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE AliasHandle = NULL;

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_ALIAS ) {
            NetpKdPrint(( "NetLocalGroupGetInfo: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }


    //
    // Look for the specified alias in either the builtin or account
    // domain.
    //
    NetStatus = AliaspOpenAliasInDomain(
                    SamServerHandle,
                    AliaspBuiltinOrAccountDomain,
                    ALIAS_READ_INFORMATION,
                    LocalGroupName,
                    &AliasHandle );

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // Get the information about the alias.
    //
    NetStatus = AliaspGetInfo( AliasHandle,
                               Level,
                               (PVOID *)Buffer);


Cleanup:
    if ( AliasHandle != NULL ) {
        (void) SamCloseHandle( AliasHandle );
    }

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    IF_DEBUG( UAS_DEBUG_ALIAS ) {
        NetpKdPrint(( "NetLocalGroupGetInfo: returns %lu\n", NetStatus ));
    }

    return NetStatus;

} // NetLocalGroupGetInfo



NET_API_STATUS NET_API_FUNCTION
NetLocalGroupGetMembers(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR LocalGroupName,
    IN DWORD Level,
    OUT LPBYTE *Buffer,
    IN DWORD PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT PDWORD_PTR ResumeHandle
    )

/*++

Routine Description:

    Enumerate the users which are members of a particular group.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    LocalGroupName - The name of the local group whose members are to be listed.

    Level - Level of information required. 0 and 1 are valid.

    Buffer - Returns a pointer to the return information structure.
        Caller must deallocate buffer using NetApiBufferFree.

    PrefMaxLen - Prefered maximum length of returned data.

    EntriesRead - Returns the actual enumerated element count.

    EntriesLeft - Returns the total entries available to be enumerated.

    ResumeHandle -  Used to continue an existing search.  The handle should
        be zero on the first call and left unchanged for subsequent calls.

Return Value:

    Error code for the operation.

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    DWORD FixedSize;        // The fixed size of each new entry.
    DWORD Size;
    BUFFER_DESCRIPTOR BufferDescriptor;
    SAM_HANDLE SamServerHandle = NULL;

    PLOCALGROUP_MEMBERS_INFO_0 lgrmi0;
    LPWSTR MemberName;

    //
    // Declare Opaque group member enumeration handle.
    //

    struct _UAS_ENUM_HANDLE {
        LSA_HANDLE  LsaHandle ;           // For looking up the Sids
        SAM_HANDLE  AliasHandle;

        PSID * MemberSids ;               // Sid for each member
        PLSA_TRANSLATED_NAME Names;       // Names of each member
        PLSA_REFERENCED_DOMAIN_LIST RefDomains; // Domains of each member

        ULONG Index;                      // Index to current entry
        ULONG Count;                      // Total Number of entries

    } *UasEnumHandle = NULL;


    //
    // Validate Parameters
    //

    BufferDescriptor.Buffer = NULL;
    *Buffer = NULL;
    *EntriesRead = 0;
    *EntriesLeft = 0;
    switch (Level) {
    case 0:
        FixedSize = sizeof(LOCALGROUP_MEMBERS_INFO_0);
        break;

    case 1:
        FixedSize = sizeof(LOCALGROUP_MEMBERS_INFO_1);
        break;

    case 2:
        FixedSize = sizeof(LOCALGROUP_MEMBERS_INFO_2);
        break;

    case 3:
        FixedSize = sizeof(LOCALGROUP_MEMBERS_INFO_3);
        break;

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    //
    // If this is a resume, get the resume handle that the caller passed in.
    //

    if ( ARGUMENT_PRESENT( ResumeHandle ) && *ResumeHandle != 0 ) {
/*lint -e511 */  /* Size incompatibility */
        UasEnumHandle = (struct _UAS_ENUM_HANDLE *) *ResumeHandle;
/*lint +e511 */  /* Size incompatibility */

    //
    // If this is not a resume, allocate and initialize a resume handle.
    //

    } else {

        //
        // Allocate a resume handle.
        //

        UasEnumHandle = NetpMemoryAllocate( sizeof(struct _UAS_ENUM_HANDLE) );

        if ( UasEnumHandle == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Initialize all the fields in the newly allocated resume handle
        //  to indicate that SAM has never yet been called.
        //

        UasEnumHandle->LsaHandle  = NULL;
        UasEnumHandle->AliasHandle= NULL;

        UasEnumHandle->MemberSids = NULL;
        UasEnumHandle->Names      = NULL;
        UasEnumHandle->RefDomains = NULL;
        UasEnumHandle->Index = 0;
        UasEnumHandle->Count = 0;

        //
        // Connect to the SAM server
        //

        NetStatus = UaspOpenSam( ServerName,
                                 FALSE,  // Don't try null session
                                 &SamServerHandle );

        if ( NetStatus != NERR_Success ) {
            IF_DEBUG( UAS_DEBUG_ALIAS ) {
                NetpKdPrint(( "NetLocalGroupGetMembers: Cannot UaspOpenSam %ld\n", NetStatus ));
            }
            goto Cleanup;
        }

        //
        // Open the Domain
        //

        NetStatus = AliaspOpenAliasInDomain(
                                       SamServerHandle,
                                       AliaspBuiltinOrAccountDomain,
                                       ALIAS_READ | ALIAS_EXECUTE,
                                       LocalGroupName,
                                       &UasEnumHandle->AliasHandle );

        if ( NetStatus != NERR_Success ) {
            IF_DEBUG( UAS_DEBUG_ALIAS ) {
                NetpKdPrint((
                    "NetLocalGroupGetMembers: AliaspOpenAliasInDomain returns %ld\n",
                    NetStatus ));
            }
            goto Cleanup;
        }

        //
        // Get the group membership information from SAM
        //

        Status = SamGetMembersInAlias( UasEnumHandle->AliasHandle,
                                       &UasEnumHandle->MemberSids,
                                       &UasEnumHandle->Count );

        if ( !NT_SUCCESS( Status ) ) {
            IF_DEBUG( UAS_DEBUG_ALIAS ) {
                NetpKdPrint((
                    "NetLocalGroupGetMembers: SamGetMembersInAlias returned %lX\n",
                    Status ));
            }
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        if ( UasEnumHandle->Count == 0 ) {
            NetStatus = NERR_Success;
            goto Cleanup;
        }

        if ( Level > 0 ) {

            //
            // Determine the names and name usage for all the returned SIDs
            //

            OBJECT_ATTRIBUTES ObjectAttributes ;
            UNICODE_STRING    ServerNameString ;

            RtlInitUnicodeString( &ServerNameString, ServerName ) ;
            InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL ) ;

            Status = LsaOpenPolicy( &ServerNameString,
                                    &ObjectAttributes,
                                    POLICY_EXECUTE,
                                    &UasEnumHandle->LsaHandle ) ;

            if ( !NT_SUCCESS( Status ) ) {

                NetStatus = NetpNtStatusToApiStatus( Status );
                goto Cleanup;
            }

            Status = LsaLookupSids( UasEnumHandle->LsaHandle,
                                    UasEnumHandle->Count,
                                    UasEnumHandle->MemberSids,
                                    &UasEnumHandle->RefDomains,
                                    &UasEnumHandle->Names );

           if ( !NT_SUCCESS( Status ) ) {

                if( Status == STATUS_NONE_MAPPED ||
                    Status == STATUS_TRUSTED_RELATIONSHIP_FAILURE ||
                    Status == STATUS_TRUSTED_DOMAIN_FAILURE ||
                    Status == STATUS_DS_GC_NOT_AVAILABLE ) {

                    //
                    // LsaLookupSids may return any of these error codes in Win2K, and STATUS_NONE_MAPPED alone in newer 
                    // versions of server side LsaLookupSids call. The function returns null in RefDomains and Names 
                    // on these errors, but we still have to copy over the SIDs in MemberSids to the return Buffers.
                    // Ignore the status and fall through.
                    //
                    Status = STATUS_SUCCESS;
                }
            
                if ( !NT_SUCCESS( Status ) ) {
            
                    NetStatus = NetpNtStatusToApiStatus( Status );
                    goto Cleanup;
                }

            }
        }
    }


    //
    // Loop for each member
    //

    while ( UasEnumHandle->Index < UasEnumHandle->Count ) {

        DWORD cbMemberSid;
        PUNICODE_STRING DomainName, UserName;
        UNICODE_STRING tempDomain, tempUser;
        //
        // ASSERT:  UasEnumHandle identifies the next entry to return
        //

#if 0
        //
        // Ignore members which aren't a user.
        //

        if ( UasEnumHandle->NameUse[UasEnumHandle->Index] != SidTypeUser ) {
            continue;
        }
#endif
        //
        // Place this entry into the return buffer.
        //  Compute the total size of this entry.  Both info levels have the
        //  member's SID.  Cache the member sid size for copying
        //

        cbMemberSid = RtlLengthSid( UasEnumHandle->MemberSids[UasEnumHandle->Index] ) ;

        Size = FixedSize;

        if( UasEnumHandle->Names == NULL || UasEnumHandle->RefDomains == NULL )
        {
            RtlInitUnicodeString( &tempDomain, L"" );
            DomainName = &tempDomain;

            RtlInitUnicodeString( &tempUser, L"" );
            UserName = &tempUser;
        }
        else
        {
            //
            // If the domain is unknown, set to the empty string.
            //
            if (UasEnumHandle->Names[UasEnumHandle->Index].DomainIndex == LSA_UNKNOWN_INDEX) {
                RtlInitUnicodeString( &tempDomain, L"" );
                DomainName = &tempDomain;
            } else {
                DomainName = &UasEnumHandle->RefDomains->Domains[UasEnumHandle->Names[UasEnumHandle->Index].DomainIndex].Name;
            }
            UserName = &UasEnumHandle->Names[UasEnumHandle->Index].Name;
        }
        switch ( Level )
        {
        case 0:
            Size += cbMemberSid;
            break ;

        case 1:
            Size += cbMemberSid +
                    UserName->Length +
                    sizeof( WCHAR );
            break ;

        case 2:
            Size += cbMemberSid +
                    DomainName->Length + sizeof(WCHAR) +
                    UserName->Length +
                    sizeof( WCHAR );
            break ;

        case 3:
            Size += DomainName->Length + sizeof(WCHAR) +
                    UserName->Length +
                    sizeof( WCHAR );
            break ;

        default:
            NetStatus = ERROR_INVALID_LEVEL;
            goto Cleanup;
        }
        
        //
        // Ensure there is buffer space for this information.
        //

        Size = ROUND_UP_COUNT( Size, ALIGN_DWORD );

        NetStatus = NetpAllocateEnumBuffer(
                        &BufferDescriptor,
                        FALSE,      // Not a 'get' operation
                        PrefMaxLen,
                        Size,
                        AliaspMemberRelocationRoutine,
                        Level );

        if (NetStatus != NERR_Success) {
            IF_DEBUG( UAS_DEBUG_ALIAS ) {
                NetpKdPrint((
                    "NetLocalGroupGetMembers: NetpAllocateEnumBuffer returns %ld\n",
                    NetStatus ));
            }
            goto Cleanup;
        }

        //
        // Copy the common member sid
        //

        lgrmi0 = (PLOCALGROUP_MEMBERS_INFO_0)BufferDescriptor.FixedDataEnd;
        BufferDescriptor.FixedDataEnd += FixedSize;

        if ( Level == 0 || Level == 1 || Level == 2 ) {
            NetpAssert( offsetof( LOCALGROUP_MEMBERS_INFO_0,  lgrmi0_sid ) ==
                        offsetof( LOCALGROUP_MEMBERS_INFO_1,  lgrmi1_sid ) );
            NetpAssert( offsetof( LOCALGROUP_MEMBERS_INFO_0,  lgrmi0_sid ) ==
                        offsetof( LOCALGROUP_MEMBERS_INFO_2,  lgrmi2_sid ) );
            NetpAssert( offsetof( LOCALGROUP_MEMBERS_INFO_0,  lgrmi0_sid ) ==
                        offsetof( LOCALGROUP_MEMBERS_INFO_2,  lgrmi2_sid ) );

            if ( ! NetpCopyDataToBuffer(
                           (LPBYTE) UasEnumHandle->MemberSids[UasEnumHandle->Index],
                           cbMemberSid,
                           BufferDescriptor.FixedDataEnd,
                           (LPBYTE *)&BufferDescriptor.EndOfVariableData,
                           (LPBYTE *)&lgrmi0->lgrmi0_sid,
                           ALIGN_DWORD ) ) {

                NetStatus = NERR_InternalError;
                goto Cleanup;
            }
        }

        //
        // Copy DomainName\MemberName
        //

        if ( Level == 2 || Level == 3 ) {
            LPWSTR TempString;


            //
            // Copy the terminating zero after domain\membername
            //
            // It might seem you'd want to copy the domain name first,
            //  but the strings are being copied to the tail of the allocated
            //  buffer.
            //

            if ( ! NetpCopyDataToBuffer(
                       (LPBYTE) L"",
                       sizeof(WCHAR),
                       BufferDescriptor.FixedDataEnd,
                       (LPBYTE *)&BufferDescriptor.EndOfVariableData,
                       (LPBYTE *)&TempString,
                       ALIGN_WCHAR) ) {

                NetStatus = NERR_InternalError;
                goto Cleanup;
            }

            //
            // Copy the member name portion of domain\membername
            //

            if ( ! NetpCopyDataToBuffer(
                       (LPBYTE) UserName->Buffer,
                       UserName->Length,
                       BufferDescriptor.FixedDataEnd,
                       (LPBYTE *)&BufferDescriptor.EndOfVariableData,
                       (LPBYTE *)&MemberName,
                       ALIGN_WCHAR) ) {

                NetStatus = NERR_InternalError;
                goto Cleanup;
            }

            //
            // Only prepend the dommain name if it is there.
            //

            if ( DomainName->Length > 0 ) {
                //
                // Copy the separating \ between domain\membername
                //

                if ( ! NetpCopyDataToBuffer(
                           (LPBYTE) L"\\",
                           sizeof(WCHAR),
                           BufferDescriptor.FixedDataEnd,
                           (LPBYTE *)&BufferDescriptor.EndOfVariableData,
                           (LPBYTE *)&TempString,
                           ALIGN_WCHAR) ) {

                    NetStatus = NERR_InternalError;
                    goto Cleanup;
                }

                //
                // Copy the domain name onto the front of the domain\membername.
                //

                if ( ! NetpCopyDataToBuffer(
                           (LPBYTE) DomainName->Buffer,
                           DomainName->Length,
                           BufferDescriptor.FixedDataEnd,
                           (LPBYTE *)&BufferDescriptor.EndOfVariableData,
                           (LPBYTE *)&MemberName,
                           ALIGN_WCHAR) ) {

                    NetStatus = NERR_InternalError;
                    goto Cleanup;
                }
            }
        }

        //
        // Fill in the Level dependent fields
        //

        switch ( Level ) {
        case 0:
            break ;

        case 1:
            //
            //  Copy the Member name and sid usage
            //

            if ( ! NetpCopyStringToBuffer(
                       UserName->Buffer,
                       UserName->Length /sizeof(WCHAR),
                       BufferDescriptor.FixedDataEnd,
                       (LPWSTR *)&BufferDescriptor.EndOfVariableData,
                       &((PLOCALGROUP_MEMBERS_INFO_1)lgrmi0)->lgrmi1_name) ) {

                NetStatus = NERR_InternalError;
                goto Cleanup;
            }

            ((PLOCALGROUP_MEMBERS_INFO_1)lgrmi0)->lgrmi1_sidusage = 
                             UasEnumHandle->Names ?
                             UasEnumHandle->Names[UasEnumHandle->Index].Use :
                             SidTypeUnknown;
            
            break ;

        case 2:
            //
            //  Copy the Member name and sid usage
            //

            ((PLOCALGROUP_MEMBERS_INFO_2)lgrmi0)->lgrmi2_domainandname = MemberName;

            ((PLOCALGROUP_MEMBERS_INFO_2)lgrmi0)->lgrmi2_sidusage =
                             UasEnumHandle->Names ?
                             UasEnumHandle->Names[UasEnumHandle->Index].Use :
                             SidTypeUnknown;
            break ;

        case 3:
            //
            //  Copy the Member name and sid usage
            //

            ((PLOCALGROUP_MEMBERS_INFO_3)lgrmi0)->lgrmi3_domainandname = MemberName;
            break;

        default:
            NetStatus = ERROR_INVALID_LEVEL;
            goto Cleanup;
        }

        //
        // ASSERT: The current entry has been completely copied to the
        //  return buffer.
        //

        UasEnumHandle->Index ++;
        (*EntriesRead)++;
    }

    //
    // All entries have been returned to the caller.
    //

    NetStatus = NERR_Success;


    //
    // Clean up.
    //

Cleanup:

    //
    // Set EntriesLeft to the number left to return plus those that
    //  we returned on this call.
    //

    if ( UasEnumHandle != NULL ) {
        *EntriesLeft = (UasEnumHandle->Count - UasEnumHandle->Index)
             + *EntriesRead;
    }

    //
    // If we're done or the caller doesn't want an enumeration handle,
    //  free the enumeration handle.
    //

    if ( NetStatus != ERROR_MORE_DATA || !ARGUMENT_PRESENT( ResumeHandle ) ) {

        if ( UasEnumHandle != NULL ) {
            if ( UasEnumHandle->LsaHandle != NULL ) {
                (void) LsaClose( UasEnumHandle->LsaHandle );
            }

            if ( UasEnumHandle->AliasHandle != NULL ) {
                (void) SamCloseHandle( UasEnumHandle->AliasHandle );
            }

            if ( UasEnumHandle->Names != NULL ) {
                (void) LsaFreeMemory( UasEnumHandle->Names );
            }

            if ( UasEnumHandle->RefDomains != NULL ) {
                (void) LsaFreeMemory( UasEnumHandle->RefDomains );
            }

            if ( UasEnumHandle->MemberSids != NULL ) {
                (void) SamFreeMemory( UasEnumHandle->MemberSids );
            }

            NetpMemoryFree( UasEnumHandle );
            UasEnumHandle = NULL;
        }
    }

    //
    // If we're not returning data to the caller,
    //  free the return buffer.
    //

    if ( NetStatus != NERR_Success && NetStatus != ERROR_MORE_DATA ) {
        if ( BufferDescriptor.Buffer != NULL ) {
            MIDL_user_free( BufferDescriptor.Buffer );
        }
        BufferDescriptor.Buffer = NULL;

    }

    //
    // Set the output parameters
    //

    *Buffer = BufferDescriptor.Buffer;
    if ( ARGUMENT_PRESENT( ResumeHandle ) ) {
        NetpAssert( sizeof(UasEnumHandle) <= sizeof(DWORD_PTR) );
        *ResumeHandle = (DWORD_PTR) UasEnumHandle;
    }

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    IF_DEBUG( UAS_DEBUG_ALIAS ) {
        NetpKdPrint(( "NetLocalGroupGetMembers: returns %ld\n", NetStatus ));
    }

    return NetStatus;

} // NetLocalGroupGetMembers



NET_API_STATUS NET_API_FUNCTION
NetLocalGroupSetInfo(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR LocalGroupName,
    IN DWORD Level,
    IN LPBYTE Buffer,
    OUT LPDWORD ParmError OPTIONAL // Name required by NetpSetParmError
    )

/*++

Routine Description:

    Set the parameters on a local group account in the user accounts database.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    GroupName - Name of the group to modify.

    Level - Level of information provided.  Must be 1.

    Buffer - A pointer to the buffer containing the local group
        information structure.

    ParmError - Optional pointer to a DWORD to return the index of the
        first parameter in error when ERROR_INVALID_PARAMETER is returned.
        If NULL, the parameter is not returned on error.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE AliasHandle = NULL;


    //
    // Initialize
    //
    NetpSetParmError( PARM_ERROR_NONE );

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_ALIAS ) {
            NetpKdPrint(( "NetLocalGroupSetInfo: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Look for the specified alias in either the builtin or account
    // domain.
    //
    NetStatus = AliaspOpenAliasInDomain(
                    SamServerHandle,
                    AliaspBuiltinOrAccountDomain,
                    ALIAS_WRITE_ACCOUNT,
                    LocalGroupName,
                    &AliasHandle );

    if (NetStatus != NERR_Success) {
        goto Cleanup;
    }

    //
    // Change the alias
    //
    switch (Level) {

        case 0:
        //
        // Set alias name
        //
        {
            LPWSTR  NewAliasName;
            ALIAS_NAME_INFORMATION  NewSamAliasName;


            NewAliasName =  ((PLOCALGROUP_INFO_0)Buffer)->lgrpi0_name;

            if (NewAliasName == NULL) {

                IF_DEBUG( UAS_DEBUG_ALIAS ) {
                    NetpKdPrint(( "NetLocalGroupSetInfo: Alias Name is NULL\n" ));
                }
                NetStatus = NERR_Success;
                goto Cleanup;
            }

            RtlInitUnicodeString( &NewSamAliasName.Name, NewAliasName );

            IF_DEBUG( UAS_DEBUG_ALIAS ) {
                NetpKdPrint(( "NetLocalAliasSetInfo: Renaming Alias Account to %wZ\n",
                                &NewSamAliasName.Name));
            }

            Status = SamSetInformationAlias( AliasHandle,
                                             AliasNameInformation,
                                             &NewSamAliasName );

            if ( !NT_SUCCESS(Status) ) {
                IF_DEBUG( UAS_DEBUG_ALIAS ) {
                    NetpKdPrint(( "NetLocalGroupSetInfo: SamSetInformationAlias %lX\n",
                              Status ));
                }
                NetStatus = NetpNtStatusToApiStatus( Status );

                if (NetStatus == ERROR_INVALID_PARAMETER) {
                    NetpSetParmError(LOCALGROUP_NAME_PARMNUM);
                }
                goto Cleanup;
            }

            break;
        }


        case 1:
        case 1002:
        //
        // Set the alias comment
        //
        {
            LPWSTR   AliasComment;
            ALIAS_ADM_COMMENT_INFORMATION AdminComment;

            //
            // Get the new alias comment
            //
            if ( Level == 1002 ) {
                AliasComment = ((PLOCALGROUP_INFO_1002)Buffer)->lgrpi1002_comment;
            } else {
                AliasComment = ((PLOCALGROUP_INFO_1)Buffer)->lgrpi1_comment;
            }

            if ( AliasComment == NULL ) {
                IF_DEBUG( UAS_DEBUG_ALIAS ) {
                    NetpKdPrint(( "NetLocalGroupSetInfo: Alias comment is NULL\n" ));
                }
                NetStatus = NERR_Success;
                goto Cleanup;
            }

            RtlInitUnicodeString( &AdminComment.AdminComment, AliasComment );

            IF_DEBUG( UAS_DEBUG_ALIAS ) {
                NetpKdPrint(( "NetLocalGroupSetInfo: Setting AdminComment to %wZ\n",
                          &AdminComment.AdminComment ));
            }

            Status = SamSetInformationAlias( AliasHandle,
                                             AliasAdminCommentInformation,
                                             &AdminComment );

            if ( !NT_SUCCESS(Status) ) {
                IF_DEBUG( UAS_DEBUG_ALIAS ) {
                    NetpKdPrint(( "NetLocalGroupSetInfo: SamSetInformationAlias %lX\n",
                              Status ));
                }
                NetStatus = NetpNtStatusToApiStatus( Status );

                if (NetStatus == ERROR_INVALID_PARAMETER) {
                    NetpSetParmError(LOCALGROUP_COMMENT_PARMNUM);
                }
                goto Cleanup;
            }
            break;
        }

        default:
            NetStatus = ERROR_INVALID_LEVEL;
            IF_DEBUG( UAS_DEBUG_ALIAS ) {
                NetpKdPrint(( "NetLocalGroupSetInfo: Invalid Level %lu\n", Level ));
            }
            goto Cleanup;
    }

    NetStatus = NERR_Success;

    //
    // Clean up.
    //

Cleanup:
    if (AliasHandle != NULL) {
        (VOID) SamCloseHandle( AliasHandle );
    }
    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    IF_DEBUG( UAS_DEBUG_ALIAS ) {
        NetpKdPrint(( "NetLocalGroupSetInfo: returns %lu\n", NetStatus ));
    }

    return NetStatus;

} // NetLocalGroupSetInfo


NET_API_STATUS NET_API_FUNCTION
NetLocalGroupSetMembers (
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR LocalGroupName,
    IN DWORD Level,
    IN LPBYTE Buffer,
    IN DWORD NewMemberCount
    )

/*++

Routine Description:

    Set the list of members of a local group.

    The SAM API allows only one member to be added or deleted at a time.
    This API allows all of the members of a alias to be specified en-masse.
    This API is careful to always leave the alias membership in the SAM
    database in a reasonable state.  It does by mergeing the list of
    old and new members, then only changing those memberships which absolutely
    need changing.

    Alias membership is restored to its previous state (if possible) if
    an error occurs during changing the alias membership.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    LocalGroupName - Name of the alias to modify.

    Level - Level of information provided.  Must be 0 or 3.

    Buffer - A pointer to the buffer containing an array of NewMemberCount
        the alias membership information structures.

    NewMemberCount - Number of entries in Buffer.

Return Value:

    Error code for the operation.

    NERR_GroupNotFound - The specified LocalGroupName does not exist

    ERROR_NO_SUCH_MEMBER - One or more of the members doesn't exist.  Therefore,
        the local group membership was not changed.

    ERROR_INVALID_MEMBER - one or more of the members cannot be added because
        it has an invalid account type.  Therefore, the local group membership
        was not changed.

--*/

{
    NET_API_STATUS NetStatus;


    NetStatus = AliaspSetMembers( ServerName,
                                  LocalGroupName,
                                  Level,
                                  Buffer,
                                  NewMemberCount,
                                  SetMembers );


    IF_DEBUG( UAS_DEBUG_ALIAS ) {
        NetpKdPrint(( "NetLocalGroupSetMembers: returns %lu\n", NetStatus ));
    }

    return NetStatus;

} // NetLocalGroupSetMembers


NET_API_STATUS NET_API_FUNCTION
NetLocalGroupAddMembers (
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR LocalGroupName,
    IN DWORD Level,
    IN LPBYTE Buffer,
    IN DWORD NewMemberCount
    )

/*++

Routine Description:

    Add the list of members of a local group.  Any previous members of the
    local group are preserved.

    The SAM API allows only one member to be added at a time.
    This API allows several new members of a alias to be specified en-masse.
    This API is careful to always leave the alias membership in the SAM
    database in a reasonable state.

    Alias membership is restored to its previous state (if possible) if
    an error occurs during changing the alias membership.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    LocalGroupName - Name of the alias to modify.

    Level - Level of information provided.  Must be 0 or 3.

    Buffer - A pointer to the buffer containing an array of NewMemberCount
        the alias membership information structures.

    NewMemberCount - Number of entries in Buffer.

Return Value:

    NERR_Success - Members were added successfully

    NERR_GroupNotFound - The specified LocalGroupName does not exist

    ERROR_NO_SUCH_MEMBER - One or more of the members doesn't exist.  Therefore,
        no new members were added.

    ERROR_MEMBER_IN_ALIAS - one or more of the members specified were already
        members of the local group.  Therefore, no new members were added.

    ERROR_INVALID_MEMBER - one or more of the members cannot be added because
        it has an invalid account type.  Therefore, no new members were added.


--*/

{
    NET_API_STATUS NetStatus;


    NetStatus = AliaspSetMembers( ServerName,
                                  LocalGroupName,
                                  Level,
                                  Buffer,
                                  NewMemberCount,
                                  AddMembers );


    IF_DEBUG( UAS_DEBUG_ALIAS ) {
        NetpKdPrint(( "NetLocalGroupAddMembers: returns %lu\n", NetStatus ));
    }

    return NetStatus;

} // NetLocalGroupAddMembers


NET_API_STATUS NET_API_FUNCTION
NetLocalGroupDelMembers (
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR LocalGroupName,
    IN DWORD Level,
    IN LPBYTE Buffer,
    IN DWORD NewMemberCount
    )

/*++

Routine Description:

    Delete the list of members of a local group.

    The SAM API allows only one member to be deleted at a time.
    This API allows several members of a alias to be specified en-masse.
    This API is careful to always leave the alias membership in the SAM
    database in a reasonable state.

    Alias membership is restored to its previous state (if possible) if
    an error occurs during changing the alias membership.


Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    LocalGroupName - Name of the alias to modify.

    Level - Level of information provided.  Must be 0 or 3.

    Buffer - A pointer to the buffer containing an array of NewMemberCount
        the alias membership information structures.

    NewMemberCount - Number of entries in Buffer.

Return Value:

    NERR_Success - Members were added successfully

    NERR_GroupNotFound - The specified LocalGroupName does not exist

    ERROR_MEMBER_NOT_IN_ALIAS - one or more of the members specified were not
        in the local group.  Therefore, no members were deleted.

    ERROR_NO_SUCH_MEMBER - One or more of the members doesn't exist.  Therefore,
        no new members were added.

--*/

{
    NET_API_STATUS NetStatus;


    NetStatus = AliaspSetMembers( ServerName,
                                  LocalGroupName,
                                  Level,
                                  Buffer,
                                  NewMemberCount,
                                  DelMembers );


    IF_DEBUG( UAS_DEBUG_ALIAS ) {
        NetpKdPrint(( "NetLocalGroupDelMembers: returns %lu\n", NetStatus ));
    }

    return NetStatus;

} // NetLocalGroupDelMembers
/*lint +e614 */
/*lint +e740 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\aliasp.c ===
/*++

Copyright (c) 1991, 1992  Microsoft Corporation

Module Name:

    aliasp.c

Abstract:

    Private functions for supporting NetLocalGroup API

Author:

    Cliff Van Dyke (cliffv) 06-Mar-1991  Original groupp.c
    Rita Wong      (ritaw)  27-Nov-1992  Adapted for aliasp.c

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:


Note:
    This comment is temporary...

    Worker routines completed and called by entrypoints in alias.c:
        AliaspOpenAliasInDomain
        AliaspOpenAlias
        AliaspChangeMember
        AliaspSetMembers
        AliaspGetInfo

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef DOMAIN_ALL_ACCESS // defined in both ntsam.h and ntwinapi.h
#include <ntsam.h>
#include <ntlsa.h>

#define NOMINMAX        // Avoid redefinition of min and max in stdlib.h
#include <windef.h>
#include <winbase.h>
#include <lmcons.h>

#include <access.h>
#include <align.h>
#include <icanon.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <netdebug.h>
#include <netlib.h>
#include <netlibnt.h>
#include <rpcutil.h>
#include <secobj.h>
#include <stddef.h>
#include <prefix.h>
#include <uasp.h>
#include <stdlib.h>



NET_API_STATUS
AliaspChangeMember(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR AliasName,
    IN PSID MemberSid,
    IN BOOL AddMember
    )

/*++

Routine Description:

    Common routine to add or remove a member from an alias.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    AliasName - Name of the alias to change membership of.

    MemberSid - SID of the user or global group to change membership of.

    AddMember - TRUE to add the user or global group to the alias.  FALSE
        to delete.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE AliasHandle = NULL;

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_ALIAS ) {
            NetpKdPrint(( "AliaspChangeMember: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }


    //
    // Open the alias.  Look for alias in the builtin domain first,
    // and if not found look in the account domain.
    //
    NetStatus = AliaspOpenAliasInDomain(
                    SamServerHandle,
                    AliaspBuiltinOrAccountDomain,
                    AddMember ?
                       ALIAS_ADD_MEMBER : ALIAS_REMOVE_MEMBER,
                    AliasName,
                    &AliasHandle );


    if (NetStatus != NERR_Success) {
        goto Cleanup;
    }

    if (AddMember) {

        //
        // Add the user or global group as a member of the local group.
        //
        Status = SamAddMemberToAlias(
                     AliasHandle,
                     MemberSid
                     );
    }
    else {

        //
        // Delete the user as a member of the group
        //
        Status = SamRemoveMemberFromAlias(
                     AliasHandle,
                     MemberSid
                     );
    }

    if (! NT_SUCCESS(Status)) {
        NetpKdPrint((
            PREFIX_NETAPI
            "AliaspChangeMember: SamAdd(orRemove)MemberFromAlias returned %lX\n",
            Status));
        NetStatus = NetpNtStatusToApiStatus(Status);
        goto Cleanup;
    }

    NetStatus = NERR_Success;

Cleanup:
    //
    // Clean up.
    //
    if (AliasHandle != NULL) {
        (VOID) SamCloseHandle(AliasHandle);
    }
    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    return NetStatus;

} // AliaspChangeMember


NET_API_STATUS
AliaspGetInfo(
    IN SAM_HANDLE AliasHandle,
    IN DWORD Level,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    Internal routine to get alias information

Arguments:

    AliasHandle - Supplies the handle of the alias.

    Level - Level of information required. 0 and 1 are valid.

    Buffer - Returns a pointer to the return information structure.
        Caller must deallocate buffer using NetApiBufferFree.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    ALIAS_GENERAL_INFORMATION *AliasGeneral = NULL;
    LPWSTR LastString;
    DWORD BufferSize;
    DWORD FixedSize;

    PLOCALGROUP_INFO_1 Info;


    //
    // Get the information about the alias.
    //
    Status = SamQueryInformationAlias( AliasHandle,
                                       AliasGeneralInformation,
                                       (PVOID *)&AliasGeneral);

    if ( ! NT_SUCCESS( Status ) ) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }


    //
    // Figure out how big the return buffer needs to be
    //
    switch ( Level ) {
        case 0:
            FixedSize = sizeof( LOCALGROUP_INFO_0 );
            BufferSize = FixedSize +
                AliasGeneral->Name.Length + sizeof(WCHAR);
            break;

        case 1:
            FixedSize = sizeof( LOCALGROUP_INFO_1 );
            BufferSize = FixedSize +
                AliasGeneral->Name.Length + sizeof(WCHAR) +
                AliasGeneral->AdminComment.Length + sizeof(WCHAR);
            break;

        default:
            NetStatus = ERROR_INVALID_LEVEL;
            goto Cleanup;

    }

    //
    // Allocate the return buffer.
    //
    BufferSize = ROUND_UP_COUNT( BufferSize, ALIGN_WCHAR );

    *Buffer = MIDL_user_allocate( BufferSize );

    if ( *Buffer == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LastString = (LPWSTR) (((LPBYTE)*Buffer) + BufferSize);

    //
    // Fill the name into the return buffer.
    //

    NetpAssert( offsetof( LOCALGROUP_INFO_0, lgrpi0_name ) ==
                offsetof( LOCALGROUP_INFO_1, lgrpi1_name ) );

    Info = (PLOCALGROUP_INFO_1) *Buffer;

    //
    // Fill in the return buffer.
    //

    switch ( Level ) {

    case 1:

        //
        // copy fields common to info level 1 and 0.
        //

        if ( !NetpCopyStringToBuffer(
                        AliasGeneral->AdminComment.Buffer,
                        AliasGeneral->AdminComment.Length/sizeof(WCHAR),
                        ((LPBYTE)(*Buffer)) + FixedSize,
                        &LastString,
                        &Info->lgrpi1_comment ) ) {

            NetStatus = NERR_InternalError;
            goto Cleanup;
        }


        //
        // Fall through for name field
        //

    case 0:

        //
        // copy common field (name field) in the buffer.
        //

        if ( !NetpCopyStringToBuffer(
                        AliasGeneral->Name.Buffer,
                        AliasGeneral->Name.Length/sizeof(WCHAR),
                        ((LPBYTE)(*Buffer)) + FixedSize,
                        &LastString,
                        &Info->lgrpi1_name ) ) {

            NetStatus = NERR_InternalError;
            goto Cleanup;
        }


        break;

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;

    }

    NetStatus = NERR_Success;

    //
    // Cleanup and return.
    //

Cleanup:
    if ( AliasGeneral ) {
        Status = SamFreeMemory( AliasGeneral );
        NetpAssert( NT_SUCCESS(Status) );
    }

    IF_DEBUG( UAS_DEBUG_ALIAS ) {
        NetpKdPrint(( "AliaspGetInfo: returns %lu\n", NetStatus ));
    }

    return NetStatus;

} // AliaspGetInfo


NET_API_STATUS
AliaspOpenAliasInDomain(
    IN SAM_HANDLE SamServerHandle,
    IN ALIASP_DOMAIN_TYPE DomainType,
    IN ACCESS_MASK DesiredAccess,
    IN LPCWSTR AliasName,
    OUT PSAM_HANDLE AliasHandle
    )
/*++

Routine Description:

    Open a Sam Alias by Name

Arguments:

    SamServerHandle - A handle to the SAM server to open the alias on.

    DomainType - Supplies the type of domain to look for an alias.  This
        may specify to look for the alias in either the BuiltIn or Account
        domain (searching in the BuiltIn first), or specifically one of them.

    DesiredAccess - Supplies access mask indicating desired access to alias.

    AliasName - Name of the alias.

    AliasHandle - Returns a handle to the alias.

Return Value:

    Error code for the operation.

--*/
{
    NET_API_STATUS NetStatus;

    SAM_HANDLE DomainHandleLocal ;

    switch (DomainType) {

        case AliaspBuiltinOrAccountDomain:

            //
            // Try looking for alias in the builtin domain first
            //
            NetStatus = UaspOpenDomain( SamServerHandle,
                                        DOMAIN_LOOKUP,
                                        FALSE,   //  Builtin Domain
                                        &DomainHandleLocal,
                                        NULL );  // DomainId

            if (NetStatus != NERR_Success) {
                return NetStatus;
            }

            NetStatus = AliaspOpenAlias( DomainHandleLocal,
                                         DesiredAccess,
                                         AliasName,
                                         AliasHandle );

            if (NetStatus != ERROR_NO_SUCH_ALIAS  &&
                NetStatus != NERR_GroupNotFound) {
                goto Cleanup;
            }

            //
            // Close the builtin domain handle.
            //
            UaspCloseDomain( DomainHandleLocal );

            //
            // Fall through.  Try looking for alias in the account
            // domain.
            //

        case AliaspAccountDomain:

            NetStatus = UaspOpenDomain( SamServerHandle,
                                        DOMAIN_LOOKUP,
                                        TRUE,   // Account Domain
                                        &DomainHandleLocal,
                                        NULL ); // DomainId

            if (NetStatus != NERR_Success) {
                return NetStatus;
            }

            NetStatus = AliaspOpenAlias( DomainHandleLocal,
                                         DesiredAccess,
                                         AliasName,
                                         AliasHandle );

            break;

        case AliaspBuiltinDomain:

            NetStatus = UaspOpenDomain( SamServerHandle,
                                        DOMAIN_LOOKUP,
                                        FALSE,   //  Builtin Domain
                                        &DomainHandleLocal,
                                        NULL );  // DomainId

            if (NetStatus != NERR_Success) {
                return NetStatus;
            }

            NetStatus = AliaspOpenAlias( DomainHandleLocal,
                                         DesiredAccess,
                                         AliasName,
                                         AliasHandle );

            break;

        default:
            NetpAssert(FALSE);
            return NERR_InternalError;

    }

Cleanup:

    UaspCloseDomain( DomainHandleLocal );

    if (NetStatus != NERR_Success) {
        *AliasHandle = NULL;
        IF_DEBUG( UAS_DEBUG_ALIAS ) {
            NetpKdPrint((PREFIX_NETAPI "AliaspOpenAliasInDomain of type %lu returns %lu\n",
                         DomainType, NetStatus));
        }
    }

    return NetStatus;

} // AliaspOpenAliasInDomain


NET_API_STATUS
AliaspOpenAlias(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN LPCWSTR AliasName,
    OUT PSAM_HANDLE AliasHandle
    )

/*++

Routine Description:

    Open a Sam Alias by Name

Arguments:

    DomainHandle - Supplies the handle of the domain the alias is in.

    DesiredAccess - Supplies access mask indicating desired access to alias.

    AliasName - Name of the alias.

    AliasHandle - Returns a handle to the alias.

Return Value:

    Error code for the operation.

--*/

{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    //
    // Variables for converting names to relative IDs
    //

    UNICODE_STRING NameString;
    PSID_NAME_USE NameUse;
    PULONG LocalRelativeId;


    RtlInitUnicodeString( &NameString, AliasName );


    //
    // Convert group name to relative ID.
    //

    Status = SamLookupNamesInDomain( DomainHandle,
                                     1,
                                     &NameString,
                                     &LocalRelativeId,
                                     &NameUse );

    if ( !NT_SUCCESS(Status) ) {
        IF_DEBUG( UAS_DEBUG_ALIAS ) {
            NetpKdPrint(( "AliaspOpenAlias: %wZ: SamLookupNamesInDomain %lX\n",
                &NameString,
                Status ));
        }
        return NetpNtStatusToApiStatus( Status );
    }

    if ( *NameUse != SidTypeAlias ) {
        IF_DEBUG( UAS_DEBUG_ALIAS ) {
            NetpKdPrint(( "AliaspOpenAlias: %wZ: Name is not an alias %ld\n",
                &NameString,
                *NameUse ));
        }
        NetStatus = ERROR_NO_SUCH_ALIAS;
        goto Cleanup;
    }

    //
    // Open the alias
    //

    Status = SamOpenAlias( DomainHandle,
                           DesiredAccess,
                           *LocalRelativeId,
                           AliasHandle);

    if ( !NT_SUCCESS(Status) ) {
        IF_DEBUG( UAS_DEBUG_ALIAS ) {
            NetpKdPrint(( "AliaspOpenAlias: %wZ: SamOpenGroup %lX\n",
                &NameString,
                Status ));
        }
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    NetStatus = NERR_Success;


    //
    // Cleanup
    //

Cleanup:
    if ( LocalRelativeId != NULL ) {
        Status = SamFreeMemory( LocalRelativeId );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if ( NameUse != NULL ) {
        Status = SamFreeMemory( NameUse );
        NetpAssert( NT_SUCCESS(Status) );
    }

    return NetStatus;


} // AliaspOpenAlias


NET_API_STATUS
AliaspOpenAlias2(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG RelativeID,
    OUT PSAM_HANDLE AliasHandle
    )
/*++

Routine Description:

    Open a Sam Alias by its RID

Arguments:

    DomainHandle - Supplies the handle of the domain the alias is in.

    DesiredAccess - Supplies access mask indicating desired access to alias.

    RelativeID - RID of the alias to open

    AliasHandle - Returns a handle to the alias

Return Value:

    Error code for the operation.

--*/

{
    NTSTATUS Status;
    NET_API_STATUS NetStatus = NERR_Success ;

    if ( AliasHandle == NULL )
        return ERROR_INVALID_PARAMETER ;

    //
    // Open the alias
    //

    Status = SamOpenAlias( DomainHandle,
                           DesiredAccess,
                           RelativeID,
                           AliasHandle);

    if ( !NT_SUCCESS(Status) ) {
        IF_DEBUG( UAS_DEBUG_ALIAS ) {
            NetpKdPrint(( "AliaspOpenAlias2: SamOpenAlias %lX\n",
                Status ));
        }
        NetStatus = NetpNtStatusToApiStatus( Status );
    }

    return NetStatus;

} // AliaspOpenAlias2





VOID
AliaspRelocationRoutine(
    IN DWORD Level,
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN PTRDIFF_T Offset
    )

/*++

Routine Description:

   Routine to relocate the pointers from the fixed portion of a NetGroupEnum
   enumeration
   buffer to the string portion of an enumeration buffer.  It is called
   as a callback routine from NetpAllocateEnumBuffer when it re-allocates
   such a buffer.  NetpAllocateEnumBuffer copied the fixed portion and
   string portion into the new buffer before calling this routine.

Arguments:

    Level - Level of information in the  buffer.

    BufferDescriptor - Description of the new buffer.

    Offset - Offset to add to each pointer in the fixed portion.

Return Value:

    Returns the error code for the operation.

--*/

{
    DWORD EntryCount;
    DWORD EntryNumber;
    DWORD FixedSize;
    IF_DEBUG( UAS_DEBUG_ALIAS ) {
        NetpKdPrint(( "AliaspRelocationRoutine: entering\n" ));
    }

    //
    // Compute the number of fixed size entries
    //

    switch (Level) {
    case 0:
        FixedSize = sizeof(LOCALGROUP_INFO_0);
        break;

    case 1:
        FixedSize = sizeof(LOCALGROUP_INFO_1);
        break;

    default:
        NetpAssert( FALSE );
        return;

    }

    EntryCount =
        ((DWORD)(BufferDescriptor->FixedDataEnd - BufferDescriptor->Buffer)) /
        FixedSize;

    //
    // Loop relocating each field in each fixed size structure
    //

    for ( EntryNumber=0; EntryNumber<EntryCount; EntryNumber++ ) {

        LPBYTE TheStruct = BufferDescriptor->Buffer + FixedSize * EntryNumber;

        switch ( Level ) {
        case 1:
            RELOCATE_ONE( ((PLOCALGROUP_INFO_1)TheStruct)->lgrpi1_comment, Offset );

            //
            // Drop through to case 0
            //

        case 0:
            RELOCATE_ONE( ((PLOCALGROUP_INFO_0)TheStruct)->lgrpi0_name, Offset );
            break;

        default:
            return;

        }

    }

    return;

} // AliaspRelocationRoutine


VOID
AliaspMemberRelocationRoutine(
    IN DWORD Level,
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN PTRDIFF_T Offset
    )

/*++

Routine Description:

   Routine to relocate the pointers from the fixed portion of a
   NetGroupGetUsers enumeration
   buffer to the string portion of an enumeration buffer.  It is called
   as a callback routine from NetpAllocateEnumBuffer when it re-allocates
   such a buffer.  NetpAllocateEnumBuffer copied the fixed portion and
   string portion into the new buffer before calling this routine.

Arguments:

    Level - Level of information in the  buffer.

    BufferDescriptor - Description of the new buffer.

    Offset - Offset to add to each pointer in the fixed portion.

Return Value:

    Returns the error code for the operation.

--*/

{
    DWORD EntryCount;
    DWORD EntryNumber;
    DWORD FixedSize;
    IF_DEBUG( UAS_DEBUG_ALIAS ) {
        NetpKdPrint(( "AliaspMemberRelocationRoutine: entering\n" ));
    }

    //
    // Compute the number of fixed size entries
    //

    NetpAssert( sizeof(LOCALGROUP_MEMBERS_INFO_1) ==
                sizeof(LOCALGROUP_MEMBERS_INFO_2));
    NetpAssert( offsetof( LOCALGROUP_MEMBERS_INFO_1,  lgrmi1_sid ) ==
                offsetof( LOCALGROUP_MEMBERS_INFO_2,  lgrmi2_sid ) );
    NetpAssert( offsetof( LOCALGROUP_MEMBERS_INFO_1,  lgrmi1_sidusage ) ==
                offsetof( LOCALGROUP_MEMBERS_INFO_2,  lgrmi2_sidusage ) );
    NetpAssert( offsetof( LOCALGROUP_MEMBERS_INFO_1,  lgrmi1_name ) ==
                offsetof( LOCALGROUP_MEMBERS_INFO_2,  lgrmi2_domainandname ) );

    switch (Level) {
    case 0:
        FixedSize = sizeof(LOCALGROUP_MEMBERS_INFO_0);
        break;

    case 1:
    case 2:
        FixedSize = sizeof(LOCALGROUP_MEMBERS_INFO_1);
        break;

    case 3:
        FixedSize = sizeof(LOCALGROUP_MEMBERS_INFO_3);
        break;

    default:
        NetpAssert( FALSE );
        return;

    }

    EntryCount =
        ((DWORD)(BufferDescriptor->FixedDataEnd - BufferDescriptor->Buffer)) /
        FixedSize;

    //
    // Loop relocating each field in each fixed size structure
    //

    for ( EntryNumber=0; EntryNumber<EntryCount; EntryNumber++ ) {

        LPBYTE TheStruct = BufferDescriptor->Buffer + FixedSize * EntryNumber;

        switch ( Level ) {
        case 3:

            RELOCATE_ONE( ((PLOCALGROUP_MEMBERS_INFO_3)TheStruct)->lgrmi3_domainandname, Offset );
            break;


        case 1:
        case 2:
            //
            //  Sid usage gets relocated automatically
            //

            RELOCATE_ONE( ((PLOCALGROUP_MEMBERS_INFO_1)TheStruct)->lgrmi1_name, Offset );

            //
            // Drop through to case 0
            //

        case 0:
            RELOCATE_ONE( ((PLOCALGROUP_MEMBERS_INFO_0)TheStruct)->lgrmi0_sid, Offset );
            break;

        default:
            return;

        }
    }

    return;

} // AliaspMemberRelocationRoutine


NET_API_STATUS
AliaspSetMembers (
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR AliasName,
    IN DWORD Level,
    IN LPBYTE Buffer,
    IN DWORD NewMemberCount,
    IN ALIAS_MEMBER_CHANGE_TYPE ChangeType
    )

/*++

Routine Description:

    Set the list of members of an alias.

    The members specified by "Buffer" are called new members.  The current
    members of the alias are called old members.

    The SAM API allows only one member to be added or deleted at a time.
    This API allows all of the members of an alias to be specified en-masse.
    This API is careful to always leave the alias membership in the SAM
    database in a reasonable state.  It does by mergeing the list of
    old and new members, then only changing those memberships which absolutely
    need changing.

    Alias membership is restored to its previous state (if possible) if
    an error occurs during changing the alias membership.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    AliasName - Name of the alias to modify.

    Level - Level of information provided.  Must be 0 (so Buffer contains
        array of member SIDs) or 3 (so Buffer contains array of pointers to
        names)

    Buffer - A pointer to the buffer containing an array of NewMemberCount
        the alias membership information structures.

    NewMemberCount - Number of entries in Buffer.

    ChangeType - Indicates whether the specified members are to be set, added,
        or deleted.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE AliasHandle = NULL;

    //
    // Define an internal member list structure.
    //
    //   This structure is to hold information about a member which
    //   requires some operation in SAM: either it is a new member to
    //   be added, or an old member to be deleted.
    //

    typedef enum {          // Action taken for this member
        NoAction,
        AddMember,          // Add Member to group
        RemoveMember        // Remove Member from group
    } MEMBER_ACTION;

    typedef struct {
        LIST_ENTRY Next;        // Next entry in linked list;

        MEMBER_ACTION Action;   // Action to taken for this member

        PSID MemberSid;         // SID of member

        BOOL    Done;           // True if this action has been taken

    } MEMBER_DESCRIPTION, *PMEMBER_DESCRIPTION;

    MEMBER_DESCRIPTION *ActionEntry;

    PLIST_ENTRY ListEntry;
    LIST_ENTRY ActionList;

    //
    // Array of existing (old) members, and count
    //
    PSID *OldMemberList = NULL;
    PSID *OldMember;
    ULONG OldMemberCount, i;

    //
    // Array of new members
    //
    PLOCALGROUP_MEMBERS_INFO_0 NewMemberList;
    PLOCALGROUP_MEMBERS_INFO_0 NewMember;
    BOOLEAN FreeNewMemberList = FALSE;
    DWORD j;



    //
    // Validate the level
    //

    InitializeListHead( &ActionList );

    switch (Level) {
    case 0:
        NewMemberList = (PLOCALGROUP_MEMBERS_INFO_0) Buffer;
        break;

    //
    // If this is level 3,
    //  compute the SID of each of the added members
    //
    case 3:
        NetpAssert( sizeof( LOCALGROUP_MEMBERS_INFO_3) ==
                    sizeof( LPWSTR ) );
        NetpAssert( sizeof( LOCALGROUP_MEMBERS_INFO_0) ==
                    sizeof( PSID ) );

        NetStatus = AliaspNamesToSids (
                        ServerName,
                        FALSE,
                        NewMemberCount,
                        (LPWSTR *)Buffer,
                        (PSID **) &NewMemberList );

        if ( NetStatus != NERR_Success ) {
            goto Cleanup;
        }

        FreeNewMemberList = TRUE;
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_ALIAS ) {
            NetpKdPrint(( "AliaspChangeMember: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Look for the specified alias in either the builtin or account
    // domain.
    //
    NetStatus = AliaspOpenAliasInDomain(
                    SamServerHandle,
                    AliaspBuiltinOrAccountDomain,
                    ALIAS_READ_INFORMATION | ALIAS_LIST_MEMBERS |
                        ALIAS_ADD_MEMBER | ALIAS_REMOVE_MEMBER,
                    AliasName,
                    &AliasHandle );

    if (NetStatus != NERR_Success) {
        goto Cleanup;
    }

    //
    // Get the existing membership list.
    //

    if ( ChangeType == SetMembers ) {
        Status = SamGetMembersInAlias(
                     AliasHandle,
                     &OldMemberList,
                     &OldMemberCount
                     );

        if (! NT_SUCCESS(Status)) {
            NetpKdPrint((PREFIX_NETAPI
                         "AliaspSetMembers: SamGetMembersInAlias returns %lX\n",
                         Status));
            NetStatus = NetpNtStatusToApiStatus(Status);
            goto Cleanup;
        }

    }


    //
    // Loop through each new member deciding what to do with it.
    //
    for (i = 0, NewMember = NewMemberList;
         i < NewMemberCount;
         i++, NewMember++) {

        MEMBER_ACTION ProposedAction;
        PSID ActionSid;

        //
        // If we're setting the complete membership to the new member list,
        //  See if New member is also in Old member list.
        //  if not, add the new member.
        //  if so, mark the old member as being already found.
        //

        switch ( ChangeType ) {
        case SetMembers:

            ProposedAction = AddMember;
            ActionSid = NewMember->lgrmi0_sid;

            for (j = 0, OldMember = OldMemberList;
                 j < OldMemberCount;
                 j++, OldMember++) {

                if ( *OldMember != NULL &&
                     EqualSid(*OldMember, NewMember->lgrmi0_sid)) {

                    ProposedAction = NoAction;
                    *OldMember = NULL;  // Mark this old member as already found
                    break;              // leave OldMemberList loop
                }
            }

            break;

        case AddMembers:
            ProposedAction = AddMember;
            ActionSid = NewMember->lgrmi0_sid;
            break;

        case DelMembers:
            ProposedAction = RemoveMember;
            ActionSid = NewMember->lgrmi0_sid;
            break;

        }

        if ( ProposedAction != NoAction ) {

            //
            // If action needs to be taken, create an action list entry
            // and chain it on the tail of the ActionList.
            //
            ActionEntry = (PMEMBER_DESCRIPTION)
                          LocalAlloc(
                              LMEM_ZEROINIT,
                              (UINT) sizeof(MEMBER_DESCRIPTION)
                              );

            if (ActionEntry == NULL) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto RestoreMembership;
            }

            ActionEntry->MemberSid = ActionSid;
            ActionEntry->Action = ProposedAction;
            InsertTailList( &ActionList, &ActionEntry->Next );
        }
    }

    //
    // For each old member,
    //  if it doesn't have a corresponding entry in the new member list,
    //  remember to delete the old membership.
    //

    if ( ChangeType == SetMembers ) {

        for (j = 0, OldMember = OldMemberList;
             j < OldMemberCount;
             j++, OldMember++) {

            if ( *OldMember != NULL ) {

                //
                // Create an add action entry for this new member and
                // chain it up on the tail of the ActionList.
                //
                ActionEntry = (PMEMBER_DESCRIPTION)
                              LocalAlloc(
                                  LMEM_ZEROINIT,
                                  (UINT) sizeof(MEMBER_DESCRIPTION)
                                  );

                if (ActionEntry == NULL) {
                    NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto RestoreMembership;
                }

                ActionEntry->MemberSid = *OldMember;
                ActionEntry->Action = RemoveMember;
                InsertTailList( &ActionList, &ActionEntry->Next );
            }
        }
    }

    //
    // Now we can call SAM to do the work.  Add first so that we
    // leave less damage should we fail to restore on an error.
    //

    for ( ListEntry = ActionList.Flink ;
          ListEntry != &ActionList ;
          ListEntry = ListEntry->Flink) {

        ActionEntry = CONTAINING_RECORD( ListEntry,
                                         MEMBER_DESCRIPTION,
                                         Next );

        if (ActionEntry->Action == AddMember) {

            Status = SamAddMemberToAlias(
                         AliasHandle,
                         ActionEntry->MemberSid
                         );

            if (! NT_SUCCESS(Status)) {
                NetpKdPrint((PREFIX_NETAPI
                             "AliaspSetMembers: SamAddMemberToAlias returns %lX\n",
                             Status));

                NetStatus = NetpNtStatusToApiStatus(Status);
                goto RestoreMembership;
            }

            ActionEntry->Done = TRUE;
        }
    }

    //
    // Delete old members.
    //

    for ( ListEntry = ActionList.Flink ;
          ListEntry != &ActionList ;
          ListEntry = ListEntry->Flink) {

        ActionEntry = CONTAINING_RECORD( ListEntry,
                                         MEMBER_DESCRIPTION,
                                         Next );

        if (ActionEntry->Action == RemoveMember) {

            Status = SamRemoveMemberFromAlias(
                         AliasHandle,
                         ActionEntry->MemberSid
                         );

            if (! NT_SUCCESS(Status)) {
                NetpKdPrint((PREFIX_NETAPI
                             "AliaspSetMembers: SamRemoveMemberFromAlias returns %lX\n",
                             Status));

                NetStatus = NetpNtStatusToApiStatus(Status);
                goto RestoreMembership;
            }

            ActionEntry->Done = TRUE;
        }
    }

    NetStatus = NERR_Success;


    //
    // Delete the action list
    //  On error, undo any action already done.
    //
RestoreMembership:

    while ( !IsListEmpty( &ActionList ) ) {

        ListEntry = RemoveHeadList( &ActionList );

        ActionEntry = CONTAINING_RECORD( ListEntry,
                                         MEMBER_DESCRIPTION,
                                         Next );

        if (NetStatus != NERR_Success && ActionEntry->Done) {

            switch (ActionEntry->Action) {

                case AddMember:
                    Status = SamRemoveMemberFromAlias(
                                 AliasHandle,
                                 ActionEntry->MemberSid
                                 );

                    NetpAssert(NT_SUCCESS(Status));
                    break;

                case RemoveMember:
                    Status = SamAddMemberToAlias(
                                AliasHandle,
                                ActionEntry->MemberSid
                                );

                    NetpAssert(NT_SUCCESS(Status));
                    break;

                default:
                    break;
            }
        }

        //
        // Delete the entry
        //

        (void) LocalFree( ActionEntry );
    }

Cleanup:

    //
    // If we allocated the new member list,
    //  delete it and any SIDs it points to.
    //

    if ( FreeNewMemberList ) {
        AliaspFreeSidList( NewMemberCount, (PSID *)NewMemberList );
    }

    if (OldMemberList != NULL) {
        SamFreeMemory(OldMemberList);
    }

    if (AliasHandle != NULL) {
        (VOID) SamCloseHandle(AliasHandle);
    }

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    IF_DEBUG(UAS_DEBUG_ALIAS) {
        NetpKdPrint((PREFIX_NETAPI "AliaspSetMembers: returns %lu\n", NetStatus));
    }

    return NetStatus;

} // AliaspSetMembers


NET_API_STATUS
AliaspNamesToSids (
    IN LPCWSTR ServerName,
    IN BOOL OnlyAllowUsers,
    IN DWORD NameCount,
    IN LPWSTR *Names,
    OUT PSID **Sids
    )

/*++

Routine Description:

    Convert a list of Domain\Member strings to SIDs.

Arguments:

    ServerName - Name of the server to do the translation on.

    OnlyAllowUsers - True if all names must be user accounts.

    NameCount - Number of names to convert.

    Names - Array of pointers to Domain\Member strings

    Sids - Returns a pointer to an array of pointers to SIDs.  The array should
        be freed via AliaspFreeSidList.

Return Value:

    NERR_Success - The translation was successful

    ERROR_NO_SUCH_MEMBER - One or more of the names could not be converted
        to a SID.

    ...

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    DWORD i;

    LSA_HANDLE LsaHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes ;
    UNICODE_STRING    ServerNameString ;

    PUNICODE_STRING NameStrings = NULL;
    PSID *SidList = NULL;

    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains = NULL;
    PLSA_TRANSLATED_SID2 LsaSids = NULL;


    //
    // Open the LSA database
    //

    RtlInitUnicodeString( &ServerNameString, ServerName ) ;
    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL ) ;

    Status = LsaOpenPolicy( &ServerNameString,
                            &ObjectAttributes,
                            POLICY_EXECUTE,
                            &LsaHandle ) ;

    if ( !NT_SUCCESS( Status ) ) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Convert the names to unicode strings
    //

    NameStrings = (PUNICODE_STRING) LocalAlloc(
                           0,
                           sizeof(UNICODE_STRING) * NameCount );

    if ( NameStrings == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    for ( i=0; i<NameCount; i++ ) {
        RtlInitUnicodeString( &NameStrings[i], Names[i] );
    }


    //
    // Convert the names to sids
    //

    Status = LsaLookupNames2(
                    LsaHandle,
                    0, // Flags
                    NameCount,
                    NameStrings,
                    &ReferencedDomains,
                    &LsaSids );

    if ( !NT_SUCCESS( Status ) ) {
        ReferencedDomains = NULL;
        LsaSids = NULL;

        if ( Status == STATUS_NONE_MAPPED ) {
            NetStatus = ERROR_NO_SUCH_MEMBER;
        } else {
            NetStatus = NetpNtStatusToApiStatus( Status );
        }

        goto Cleanup;
    }

    if ( Status == STATUS_SOME_NOT_MAPPED ) {
        NetStatus = ERROR_NO_SUCH_MEMBER;
        goto Cleanup;
    }


    //
    // Allocate the SID list to return
    //

    SidList = (PSID *) LocalAlloc(
                           LMEM_ZEROINIT,   // Initially all to NULL
                           sizeof(PSID) * NameCount );

    if ( SidList == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Construct a SID for each name
    //

    for ( i=0; i<NameCount; i++ ) {

        ULONG Length;

        //
        // If the caller only want user accounts,
        //  ensure this is one.
        //

        if ( LsaSids[i].Use != SidTypeUser ) {
            if ( OnlyAllowUsers ||
                    (LsaSids[i].Use != SidTypeGroup &&
                     LsaSids[i].Use != SidTypeAlias &&
                     LsaSids[i].Use != SidTypeWellKnownGroup )) {
                NetStatus = ERROR_NO_SUCH_MEMBER;
                goto Cleanup;
            }
        }


        //
        // Construct a SID for the name.
        //
        Length = RtlLengthSid( LsaSids[i].Sid );
        SidList[i] = NetpMemoryAllocate(Length);
        if ( NULL == SidList[i] ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        RtlCopySid( Length, SidList[i], LsaSids[i].Sid );

    }


    NetStatus = NERR_Success;

    //
    // Free locally used resources.
    //
Cleanup:

    if ( LsaHandle != NULL ) {
        (void) LsaClose( LsaHandle );
    }

    if ( NameStrings != NULL ) {
        (void) LocalFree( NameStrings );
    }

    if ( ReferencedDomains != NULL ) {
        (void) LsaFreeMemory( ReferencedDomains );
    }

    if ( LsaSids != NULL ) {
        (void) LsaFreeMemory( LsaSids );
    }

    //
    // If the translation wasn't successful,
    //  free any partial translation.
    //

    if ( NetStatus != NERR_Success ) {
        if ( SidList != NULL ) {
            AliaspFreeSidList( NameCount, SidList );
        }
        SidList = NULL;
    }

    //
    // Return
    //

    *Sids = SidList;
    return NetStatus;
}


VOID
AliaspFreeSidList (
    IN DWORD SidCount,
    IN PSID *Sids
    )

/*++

Routine Description:

    Free the SID list returned by AliaspNamesToSids

Arguments:

    SidCount - Number of entries in the sid list

    Sids - Aan array of pointers to SIDs.

Return Value:

    None;

--*/

{
    DWORD i;

    if ( Sids != NULL ) {

        for ( i=0; i<SidCount; i++ ) {
            if ( Sids[i] != NULL ) {
                NetpMemoryFree( Sids[i] );
            }
        }
        (void) LocalFree( Sids );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\display.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    display.c

Abstract:

    NetQueryDisplay Information and NetGetDisplayInformationIndex API functions

Author:

    Cliff Van Dyke (cliffv) 14-Dec-1994

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef DOMAIN_ALL_ACCESS // defined in both ntsam.h and ntwinapi.h
#include <ntsam.h>
#include <ntlsa.h>

#include <windef.h>
#include <winbase.h>
#include <lmcons.h>

#include <accessp.h>
#include <align.h>
// #include <lmapibuf.h>
#include <lmaccess.h>
#include <lmerr.h>
// #include <limits.h>
#include <netdebug.h>
#include <netlib.h>
#include <netlibnt.h>
#include <rpcutil.h>
// #include <rxuser.h>
// #include <secobj.h>
// #include <stddef.h>
#include <uasp.h>


VOID
DisplayRelocationRoutine(
    IN DWORD Level,
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN PTRDIFF_T Offset
    )

/*++

Routine Description:

   Routine to relocate the pointers from the fixed portion of a NetGroupEnum
   enumeration
   buffer to the string portion of an enumeration buffer.  It is called
   as a callback routine from NetpAllocateEnumBuffer when it re-allocates
   such a buffer.  NetpAllocateEnumBuffer copied the fixed portion and
   string portion into the new buffer before calling this routine.

Arguments:

    Level - Level of information in the  buffer.

    BufferDescriptor - Description of the new buffer.

    Offset - Offset to add to each pointer in the fixed portion.

Return Value:

    Returns the error code for the operation.

--*/

{
    DWORD EntryCount;
    DWORD EntryNumber;
    DWORD FixedSize;
    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "DisplayRelocationRoutine: entering\n" ));
    }

    //
    // Compute the number of fixed size entries
    //

    switch (Level) {
    case 1:
        FixedSize = sizeof(NET_DISPLAY_USER);
        break;
    case 2:
        FixedSize = sizeof(NET_DISPLAY_MACHINE);
        break;
    case 3:
        FixedSize = sizeof(NET_DISPLAY_GROUP);
        break;

    default:
        NetpAssert( FALSE );
        return;

    }

    EntryCount =
        ((DWORD)(BufferDescriptor->FixedDataEnd - BufferDescriptor->Buffer)) /
        FixedSize;

    //
    // Loop relocating each field in each fixed size structure
    //

    for ( EntryNumber=0; EntryNumber<EntryCount; EntryNumber++ ) {

        LPBYTE TheStruct = BufferDescriptor->Buffer + FixedSize * EntryNumber;

        switch (Level) {
        case 1:
            RELOCATE_ONE( ((PNET_DISPLAY_USER)TheStruct)->usri1_name, Offset );
            RELOCATE_ONE( ((PNET_DISPLAY_USER)TheStruct)->usri1_comment, Offset );
            RELOCATE_ONE( ((PNET_DISPLAY_USER)TheStruct)->usri1_full_name, Offset );
            break;

        case 2:
            RELOCATE_ONE( ((PNET_DISPLAY_MACHINE)TheStruct)->usri2_name, Offset );
            RELOCATE_ONE( ((PNET_DISPLAY_MACHINE)TheStruct)->usri2_comment, Offset );
            break;

        case 3:
            RELOCATE_ONE( ((PNET_DISPLAY_GROUP)TheStruct)->grpi3_name, Offset );
            RELOCATE_ONE( ((PNET_DISPLAY_GROUP)TheStruct)->grpi3_comment, Offset );
            break;

        default:
            return;

        }
    }

    return;

} // DisplayRelocationRoutine



NET_API_STATUS NET_API_FUNCTION
NetQueryDisplayInformation(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD Level,
    IN DWORD Index,
    IN DWORD EntriesRequested,
    IN DWORD PreferredMaximumLength,
    OUT LPDWORD ReturnedEntryCount,
    OUT PVOID   *SortedBuffer )

/*++

Routine Description:

    This routine provides fast return of information commonly
    needed to be displayed in user interfaces.

    NT User Interface has a requirement for quick enumeration of
    accounts for display in list boxes.

    This API is remotable. The Server can be any NT workstation or server.
    The server cannot be a Lanman or WFW machine.

    NT 3.1 workstations and servers do not support Level 3.
    NT 3.1 workstations and servers do not support an infinitely large
    EntriesRequested.


Parameters:


    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    Level - Level of information provided.  Must be

            1 --> Return all Local and Global (normal) user accounts
            2 --> Return all Workstation and Server (BDC) user accounts
            3 --> Return all Global Groups.

    Index - The index of the first entry to be retrieved.  Pass zero on
        the first call. Pass the 'next_index' field of the last entry
        returned on the previous call.

    EntriesRequested - Specifies an upper limit on the number of entries
        to be returned .

    PreferedMaximumLength - A recommended upper limit to the number of
        bytes to be returned.  The returned information is allocated by
        this routine.

    ReturnedEntryCount - Number of entries returned by this call.  Zero
        indicates there are no entries with an index as large as that
        specified.

        Entries may be returned for a return status of either NERR_Success
        or ERROR_MORE_DATA.

    SortedBuffer - Receives a pointer to a buffer containing a sorted
        list of the requested information.  This buffer is allocated
        by this routine and contains the following structure:

            1 --> An array of ReturnedEntryCount elements of type
                  NET_DISPLAY_USER.  This is followed by the bodies of the
                  various strings pointed to from within the
                  NET_DISPLAY_USER structures.

            2 --> An array of ReturnedEntryCount elements of type
                  NET_DISPLAY_MACHINE.  This is followed by the bodies of the
                  various strings pointed to from within the
                  NET_DISPLAY_MACHINE structures.

            3 --> An array of ReturnedEntryCount elements of type
                  NET_DISPLAY_GROUP.  This is followed by the bodies of the
                  various strings pointed to from within the
                  NET_DISPLAY_GROUP structures.


Return Values:

    NERR_Success - normal, successful completion.  There are no more entries
        to be returned.

    ERROR_ACCESS_DENIED - The caller doesn't have access to the requested
        information.

    ERROR_INVALID_LEVEL - The requested level of information
        is not legitimate for this service.

    ERROR_MORE_DATA - More entries are available.  That is, the last entry
        returned in SortedBuffer is not the last entry available.  More
        entries will be returned by calling again with the Index parameter
        set to the 'next_index' field of the last entry in SortedBuffer.


--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    NET_API_STATUS SavedStatus;

    BUFFER_DESCRIPTOR BufferDescriptor;
    DWORD i;

    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE  DomainHandle = NULL;

    DOMAIN_DISPLAY_INFORMATION DisplayInformation;
    DWORD FixedSize;
    LPBYTE FixedData;


    DWORD SamTotalBytesAvailable;
    DWORD SamTotalBytesReturned;
    DWORD SamReturnedEntryCount;
    PVOID SamSortedBuffer = NULL;

    DWORD Mode = SAM_SID_COMPATIBILITY_ALL;

    //
    // Validate Level parameter
    //

    *ReturnedEntryCount = 0;
    *SortedBuffer = NULL;
    BufferDescriptor.Buffer = NULL;

    switch (Level) {
    case 1:
        DisplayInformation = DomainDisplayUser;
        FixedSize = sizeof(NET_DISPLAY_USER);
        break;
    case 2:
        DisplayInformation = DomainDisplayMachine;
        FixedSize = sizeof(NET_DISPLAY_MACHINE);
        break;
    case 3:
        DisplayInformation = DomainDisplayGroup;
        FixedSize = sizeof(NET_DISPLAY_GROUP);
        break;

    default:
        return ERROR_INVALID_LEVEL;

    }

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetQueryDisplayInformation: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the Account Domain.
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_LIST_ACCOUNTS,
                                TRUE,   // Account Domain
                                &DomainHandle,
                                NULL );

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    Status = SamGetCompatibilityMode(DomainHandle,
                                     &Mode);
    if (NT_SUCCESS(Status)) {
        if ( (Mode == SAM_SID_COMPATIBILITY_STRICT)) {
              //
              // All these info levels return RID's
              //
              Status = STATUS_NOT_SUPPORTED;
          }
    }
    if (!NT_SUCCESS(Status)) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }


    //
    // Pass the call to SAM
    //

    Status = SamQueryDisplayInformation (
                        DomainHandle,
                        DisplayInformation,
                        Index,
                        EntriesRequested,
                        PreferredMaximumLength,
                        &SamTotalBytesAvailable,
                        &SamTotalBytesReturned,
                        &SamReturnedEntryCount,
                        &SamSortedBuffer );

    if ( !NT_SUCCESS( Status ) ) {
        SamSortedBuffer = NULL;
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint((
                "NetQueryDisplayInformation: SamQueryDisplayInformation returned %lX\n",
                Status ));
        }

        //
        // NT 3.1 systems returned STATUS_NO_MORE_ENTRIES if Index is too large.
        //

        if ( Status == STATUS_NO_MORE_ENTRIES ) {
            NetStatus = NERR_Success;
            goto Cleanup;
        }
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Remember what status to return on success.
    //

    if ( Status == STATUS_MORE_ENTRIES ) {
        SavedStatus = ERROR_MORE_DATA;
    } else {
        SavedStatus = NERR_Success;
    }

    //
    // Loop for each entry
    //

    for ( i = 0; i < SamReturnedEntryCount; i++ ) {

        PDOMAIN_DISPLAY_USER DomainDisplayUser;
        PDOMAIN_DISPLAY_MACHINE DomainDisplayMachine;
        PDOMAIN_DISPLAY_GROUP DomainDisplayGroup;

        DWORD Size;


        //
        // Determine the total size of the return information.
        //

        Size = FixedSize;
        switch (Level) {
        case 1:
            DomainDisplayUser = &((PDOMAIN_DISPLAY_USER)(SamSortedBuffer))[i];
            Size += DomainDisplayUser->LogonName.Length + sizeof(WCHAR) +
                    DomainDisplayUser->AdminComment.Length + sizeof(WCHAR) +
                    DomainDisplayUser->FullName.Length + sizeof(WCHAR);
            break;

        case 2:
            DomainDisplayMachine = &((PDOMAIN_DISPLAY_MACHINE)(SamSortedBuffer))[i];
            Size += DomainDisplayMachine->Machine.Length + sizeof(WCHAR) +
                    DomainDisplayMachine->Comment.Length + sizeof(WCHAR);
            break;
        case 3:
            DomainDisplayGroup = &((PDOMAIN_DISPLAY_GROUP)(SamSortedBuffer))[i];

            Size += DomainDisplayGroup->Group.Length + sizeof(WCHAR) +
                    DomainDisplayGroup->Comment.Length + sizeof(WCHAR);
            break;

        default:
            NetStatus = ERROR_INVALID_LEVEL;
            goto Cleanup;

        }

        //
        // Ensure there is buffer space for this information.
        //

        Size = ROUND_UP_COUNT( Size, ALIGN_WCHAR );

        NetStatus = NetpAllocateEnumBuffer(
                        &BufferDescriptor,
                        FALSE,      // Enumeration
                        0xFFFFFFFF, // PrefMaxLen (already limited by SAM)
                        Size,
                        DisplayRelocationRoutine,
                        Level );

        if (NetStatus != NERR_Success) {

            //
            // NetpAllocateEnumBuffer returns ERROR_MORE_DATA if this
            // entry doesn't fit into the buffer.
            //
            if ( NetStatus == ERROR_MORE_DATA ) {
                NetStatus = NERR_InternalError;
            }

            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint(( "NetQueryDisplayInformation: NetpAllocateEnumBuffer returns %ld\n",
                    NetStatus ));
            }

            goto Cleanup;
        }

        //
        // Define macros to make copying zero terminated strings less repetitive.
        //

#define COPY_STRING( _dest, _string ) \
        if ( !NetpCopyStringToBuffer( \
                        (_string).Buffer, \
                        (_string).Length/sizeof(WCHAR), \
                        BufferDescriptor.FixedDataEnd, \
                        (LPWSTR *)&BufferDescriptor.EndOfVariableData, \
                        (_dest) )) { \
            \
            NetStatus = NERR_InternalError; \
            IF_DEBUG( UAS_DEBUG_USER ) { \
                NetpKdPrint(( "NetQueryDisplayInformation: NetpCopyString returns %ld\n", \
                    NetStatus )); \
            } \
            goto Cleanup; \
        }


        //
        // Place this entry into the return buffer.
        //
        // Fill in the information.  The array of fixed entries are
        // placed at the beginning of the allocated buffer.  The strings
        // pointed to by these fixed entries are allocated starting at
        // the end of the allocated buffer.
        //

        FixedData = BufferDescriptor.FixedDataEnd;
        BufferDescriptor.FixedDataEnd += FixedSize;

        switch (Level) {
        case 1: {
            PNET_DISPLAY_USER NetDisplayUser = (PNET_DISPLAY_USER)FixedData;

            COPY_STRING( &NetDisplayUser->usri1_name,
                         DomainDisplayUser->LogonName );

            COPY_STRING( &NetDisplayUser->usri1_comment,
                         DomainDisplayUser->AdminComment );

            NetDisplayUser->usri1_flags = NetpAccountControlToFlags(
                                    DomainDisplayUser->AccountControl,
                                    NULL );

            COPY_STRING( &NetDisplayUser->usri1_full_name,
                         DomainDisplayUser->FullName );

            if (Mode == SAM_SID_COMPATIBILITY_ALL) {
                NetDisplayUser->usri1_user_id = DomainDisplayUser->Rid;
            } else {
                NetDisplayUser->usri1_user_id = 0;
            }
            NetDisplayUser->usri1_next_index = DomainDisplayUser->Index;

            break;
        }

        case 2: {
            PNET_DISPLAY_MACHINE NetDisplayMachine = (PNET_DISPLAY_MACHINE)FixedData;

            COPY_STRING( &NetDisplayMachine->usri2_name,
                         DomainDisplayMachine->Machine );

            COPY_STRING( &NetDisplayMachine->usri2_comment,
                         DomainDisplayMachine->Comment );

            NetDisplayMachine->usri2_flags = NetpAccountControlToFlags(
                                    DomainDisplayMachine->AccountControl,
                                    NULL );

            if (Mode == SAM_SID_COMPATIBILITY_ALL) {
                NetDisplayMachine->usri2_user_id = DomainDisplayMachine->Rid;
            } else {
                NetDisplayMachine->usri2_user_id = 0;
            }
            NetDisplayMachine->usri2_next_index = DomainDisplayMachine->Index;

            break;
        }

        case 3: {
            PNET_DISPLAY_GROUP NetDisplayGroup = (PNET_DISPLAY_GROUP)FixedData;

            COPY_STRING( &NetDisplayGroup->grpi3_name,
                         DomainDisplayGroup->Group );

            COPY_STRING( &NetDisplayGroup->grpi3_comment,
                         DomainDisplayGroup->Comment );

            if (Mode == SAM_SID_COMPATIBILITY_ALL) {
                NetDisplayGroup->grpi3_group_id = DomainDisplayGroup->Rid;
            } else {
                NetDisplayGroup->grpi3_group_id = 0;
            }
            NetDisplayGroup->grpi3_attributes = DomainDisplayGroup->Attributes;
            NetDisplayGroup->grpi3_next_index = DomainDisplayGroup->Index;

            break;
        }

        default:
            NetStatus = ERROR_INVALID_LEVEL;
            goto Cleanup;

        }

        //
        // Indicate that more information was returned.
        //

        (*ReturnedEntryCount) ++;

    }

    NetStatus = SavedStatus;

    //
    // Clean up.
    //

Cleanup:

    //
    // Free up all resources, we reopen them if the caller calls again.
    //

    if ( DomainHandle != NULL ) {
        UaspCloseDomain( DomainHandle );
    }

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    //
    // If we're not returning data to the caller,
    //  free the return buffer.
    //

    if ( NetStatus != NERR_Success && NetStatus != ERROR_MORE_DATA ) {
        if ( BufferDescriptor.Buffer != NULL ) {
            MIDL_user_free( BufferDescriptor.Buffer );
            BufferDescriptor.Buffer = NULL;
        }
    }

    //
    // Free buffer returned from SAM.
    //

    if ( SamSortedBuffer != NULL ) {
        (VOID) SamFreeMemory( SamSortedBuffer );
    }

    //
    // Set the output parameters
    //

    *SortedBuffer = BufferDescriptor.Buffer;

    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "NetQueryDisplayInformation: returning %ld\n", NetStatus ));
    }

    return NetStatus;

}


NET_API_STATUS NET_API_FUNCTION
NetGetDisplayInformationIndex(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD Level,
    IN LPCWSTR Prefix,
    OUT LPDWORD Index )

/*++

Routine Description:

    This routine returns the index of the first display information entry
    alphabetically equal to or following Prefix.

Parameters:


    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    Level - Level of information queried.  Must be

            1 --> all Local and Global (normal) user accounts
            2 --> all Workstation and Server (BDC) user accounts
            3 --> all Global Groups.


    Prefix - Prefix to be searched for

    Index - The index of the entry found.

Return Values:

    NERR_Success - normal, successful completion.  The specified index
        was returned.

    ERROR_ACCESS_DENIED - The caller doesn't have access to the requested
        information.

    ERROR_INVALID_LEVEL - The requested level of information
        is not legitimate for this service.

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE  DomainHandle = NULL;

    DOMAIN_DISPLAY_INFORMATION DisplayInformation;
    UNICODE_STRING PrefixString;

    DWORD Mode = SAM_SID_COMPATIBILITY_ALL;

    //
    // Validate Level parameter
    //

    switch (Level) {
    case 1:
        DisplayInformation = DomainDisplayUser;
        break;
    case 2:
        DisplayInformation = DomainDisplayMachine;
        break;
    case 3:
        DisplayInformation = DomainDisplayGroup;
        break;

    default:
        return ERROR_INVALID_LEVEL;

    }

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetGetDisplayInformationIndex: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the Account Domain.
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_LIST_ACCOUNTS,
                                TRUE,   // Account Domain
                                &DomainHandle,
                                NULL );

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    Status = SamGetCompatibilityMode(DomainHandle,
                                     &Mode);
    if (NT_SUCCESS(Status)) {
        if ( (Mode == SAM_SID_COMPATIBILITY_STRICT)) {
              //
              // All these info levels return RID's
              //
              Status = STATUS_NOT_SUPPORTED;
          }
    }
    if (!NT_SUCCESS(Status)) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Pass the call to SAM
    //

    RtlInitUnicodeString( &PrefixString, Prefix );

    Status = SamGetDisplayEnumerationIndex (
                        DomainHandle,
                        DisplayInformation,
                        &PrefixString,
                        Index );

    if ( !NT_SUCCESS( Status ) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint((
                "NetGetDisplayInformationIndex: SamGetDisplayEnumerationIndex returned %lX\n",
                Status ));
        }

        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    Status = NERR_Success;

    //
    // Clean up.
    //

Cleanup:

    //
    // Free up all resources, we reopen them if the caller calls again.
    //

    if ( DomainHandle != NULL ) {
        UaspCloseDomain( DomainHandle );
    }
    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    //
    // Set the output parameters
    //

    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "NetGetDisplayInformationIndex: returning %ld\n", NetStatus ));
    }

    return NetStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\disptest.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    disptest.c

Abstract:

    Test program for NetQueryDisplayInformation and
    NetGetDisplayInformationIndex API functions

Author:

    Cliff Van Dyke (cliffv) 15-Dec-1994

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef DOMAIN_ALL_ACCESS // defined in both ntsam.h and ntwinapi.h
// #include <ntsam.h>
// #include <ntlsa.h>

#include <windef.h>
#include <winbase.h>
#include <lmcons.h>

// #include <accessp.h>
// #include <align.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmerr.h>
// #include <limits.h>
#include <netdebug.h>
#include <netlib.h>
#include <netlibnt.h>
#include <rpcutil.h>
#include <stdlib.h>
#include <stdio.h>
#include <tstring.h>
// #include <secobj.h>
// #include <stddef.h>
///#include <uasp.h>



DWORD
DisplayStruct(
    IN DWORD Level,
    IN PVOID Buffer
    )
/*++

Routine Description:

    Display the appropriate structure.

Arguments:

    Level - Info level of structure

    Buffer - structure to display

Return Value:

    Index of next entry

--*/
{
    DWORD Index;

    switch (Level) {
    case 1: {
        PNET_DISPLAY_USER NetDisplayUser = (PNET_DISPLAY_USER) Buffer;

        printf("%4.4ld %-20.20ws comm:%ws flg:%lx full:%ws rid:%lx\n",
               NetDisplayUser->usri1_next_index,
                NetDisplayUser->usri1_name,
                NetDisplayUser->usri1_comment,
                NetDisplayUser->usri1_flags,
                NetDisplayUser->usri1_full_name,
                NetDisplayUser->usri1_user_id );

        Index = NetDisplayUser->usri1_next_index;

        break;
    }

    case 2: {
        PNET_DISPLAY_MACHINE NetDisplayMachine = (PNET_DISPLAY_MACHINE) Buffer;

        printf("%4.4ld %-20.20ws comm:%ws flg:%lx rid:%lx\n",
                NetDisplayMachine->usri2_next_index,
                NetDisplayMachine->usri2_name,
                NetDisplayMachine->usri2_comment,
                NetDisplayMachine->usri2_flags,
                NetDisplayMachine->usri2_user_id );

        Index = NetDisplayMachine->usri2_next_index;

        break;
    }

    case 3: {
        PNET_DISPLAY_GROUP NetDisplayGroup = (PNET_DISPLAY_GROUP) Buffer;

        printf("%4.4ld %-20.20ws comm:%ws attr:%lx rid:%lx\n",
                NetDisplayGroup->grpi3_next_index,
                NetDisplayGroup->grpi3_name,
                NetDisplayGroup->grpi3_comment,
                NetDisplayGroup->grpi3_attributes,
                NetDisplayGroup->grpi3_group_id );

        Index = NetDisplayGroup->grpi3_next_index;

        break;
    }
    }

    return Index;
}


int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Test program for NetQueryDisplayInformation and
    NetGetDisplayInformationIndex API functions

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    NET_API_STATUS NetStatus;

    char *end;
    DWORD i;
    DWORD FixedSize;

    LPWSTR ServerName = NULL;
    DWORD Level = 1;
    DWORD Index = 0;
    DWORD EntriesRequested = 0xFFFFFFFF;
    DWORD PreferredMaximumLength = 0xFFFFFFFF;
    LPWSTR Prefix = NULL;

    DWORD ReturnedEntryCount;
    PVOID SortedBuffer;

    if ( argc > 1 ) {
        ServerName = NetpAllocWStrFromStr( argv[1] );
    }
    if ( argc > 2 ) {
        Level = strtoul( argv[2], &end, 10 );
    }
    if ( argc > 3 ) {
        Index = strtoul( argv[3], &end, 10 );
    }
    if ( argc > 4 ) {
        EntriesRequested = strtoul( argv[4], &end, 10 );
    }
    if ( argc > 5 ) {
        PreferredMaximumLength = strtoul( argv[5], &end, 10 );
    }
    if ( argc > 6 ) {
        Prefix = NetpAllocWStrFromStr( argv[6] );
    }


    //
    // Size of each entry.
    //

    switch (Level) {
    case 1:
        FixedSize = sizeof(NET_DISPLAY_USER);
        break;
    case 2:
        FixedSize = sizeof(NET_DISPLAY_MACHINE);
        break;
    case 3:
        FixedSize = sizeof(NET_DISPLAY_GROUP);
        break;

    default:
        FixedSize = 0;
        break;
    }

   printf( "Server: %ws Level: %ld Index: %ld EntriesRequested: %ld PrefMax: %ld\n",
           ServerName,
           Level,
           Index,
           EntriesRequested,
           PreferredMaximumLength );

    if ( Prefix != NULL) {
        printf( "Prefix: %ws\n", Prefix );
        NetStatus = NetGetDisplayInformationIndex(
                        ServerName,
                        Level,
                        Prefix,
                        &Index );

        printf( "Status from NetGetDisplayInformationIndex: %ld\n", NetStatus );

        if ( NetStatus != NERR_Success ) {
            return 0;
        }
        printf( "NewIndex: %ld\n", Index );

    }

    do {

        NetStatus = NetQueryDisplayInformation(
                        ServerName,
                        Level,
                        Index,
                        EntriesRequested,
                        PreferredMaximumLength,
                        &ReturnedEntryCount,
                        &SortedBuffer );

        printf( "Count: %ld Status: %ld\n",
                ReturnedEntryCount,
                NetStatus );

        if ( NetStatus != NERR_Success && NetStatus != ERROR_MORE_DATA ) {
            break;
        }

        for ( i=0; i<ReturnedEntryCount; i++ ) {

            Index = DisplayStruct( Level,
                                   ((LPBYTE) SortedBuffer) + FixedSize * i );
        }

        //
        // Free the returned buffer.
        //

        NetApiBufferFree( SortedBuffer );

    } while ( NetStatus == ERROR_MORE_DATA );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\groupp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    groupp.c

Abstract:

    Private functions for supporting NetGroup API

Author:

    Cliff Van Dyke (cliffv) 06-Mar-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    17-Apr-1991 (cliffv)
        Incorporated review comments.

    20-Jan-1992 (madana)
        Sundry API changes

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef DOMAIN_ALL_ACCESS // defined in both ntsam.h and ntwinapi.h
#include <ntsam.h>
#include <ntlsa.h>

#define NOMINMAX        // Avoid redefinition of min and max in stdlib.h
#include <windef.h>
#include <winbase.h>
#include <lmcons.h>

#include <access.h>
#include <align.h>
#include <icanon.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <netdebug.h>
#include <netlib.h>
#include <netlibnt.h>
#include <rpcutil.h>
#include <stddef.h>
#include <uasp.h>
#include <stdlib.h>
#include <accessp.h>



NET_API_STATUS
GrouppChangeMember(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR GroupName,
    IN LPCWSTR UserName,
    IN BOOL AddMember
    )

/*++

Routine Description:

    Common routine to add or remove a member from a group

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    GroupName - Name of the group to change membership of.

    UserName - Name of the user to change membership of.

    AddMember - True to ADD the user to the group.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAM_HANDLE GroupHandle = NULL;

    //
    // Variables for converting names to relative IDs
    //

    UNICODE_STRING NameString;
    PULONG RelativeId = NULL;
    PSID_NAME_USE NameUse = NULL;

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint(( "GrouppChangeMember: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the Domain
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_LOOKUP,
                                TRUE,   // Account Domain
                                &DomainHandle,
                                NULL);  // DomainId

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint((
                "GrouppChangeMember: UaspOpenDomain returned %ld\n",
                NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the group
    //

    NetStatus = GrouppOpenGroup( DomainHandle,
                                 AddMember ?
                                    GROUP_ADD_MEMBER : GROUP_REMOVE_MEMBER,
                                 GroupName,
                                 &GroupHandle,
                                 NULL );    // Relative Id

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint((
                "GrouppChangeMember: GrouppOpenGroup returned %ld\n",
                NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Convert User name to relative ID.
    //

    RtlInitUnicodeString( &NameString, UserName );
    Status = SamLookupNamesInDomain( DomainHandle,
                                     1,
                                     &NameString,
                                     &RelativeId,
                                     &NameUse );

    if ( !NT_SUCCESS(Status) ) {
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint((
                "GrouppChangeMember: SamLookupNamesInDomain returned %lX\n",
                Status ));
        }
        if ( Status == STATUS_NONE_MAPPED ) {
            NetStatus = NERR_UserNotFound;
        } else {
            NetStatus = NetpNtStatusToApiStatus( Status );
        }
        goto Cleanup;
    }

    if ( *NameUse != SidTypeUser ) {
        NetStatus = NERR_UserNotFound;
        goto Cleanup;
    }

    //
    // Add the user as a member of the group.
    //
    // SE_GROUP_MANDATORY might be conflict with the attributes of the group, so
    //  try that attribute both ways.
    //

    if ( AddMember ) {
        Status = SamAddMemberToGroup(
                    GroupHandle,
                    *RelativeId,
                    SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT |
                        SE_GROUP_ENABLED );

        if ( Status == STATUS_INVALID_GROUP_ATTRIBUTES ) {
            Status = SamAddMemberToGroup( GroupHandle,
                                          *RelativeId,
                                          SE_GROUP_ENABLED_BY_DEFAULT |
                                              SE_GROUP_ENABLED );
        }

    //
    // Delete the user as a member of the group
    //

    } else {
        Status = SamRemoveMemberFromGroup( GroupHandle,
                                           *RelativeId);
    }

    IF_DEBUG( UAS_DEBUG_GROUP ) {
        NetpKdPrint((
            "GrouppChangeMember: SamAdd(orRemove)MemberFromGroup returned %lX\n",
            Status ));
    }

    if ( !NT_SUCCESS(Status) ) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    NetStatus = NERR_Success;

    //
    // Clean up.
    //

Cleanup:
    if ( RelativeId != NULL ) {
        Status = SamFreeMemory( RelativeId );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if ( NameUse != NULL ) {
        Status = SamFreeMemory( NameUse );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if ( GroupHandle != NULL ) {
        (VOID) SamCloseHandle( GroupHandle );
    }

    UaspCloseDomain( DomainHandle );

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }
    return NetStatus;

} // GrouppChangeMember


NET_API_STATUS
GrouppGetInfo(
    IN SAM_HANDLE DomainHandle,
    IN ULONG RelativeId,
    IN DWORD Level,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    Internal routine to get group information

Arguments:

    DomainHandle - Supplies the Handle of the domain the group is in.

    RelativeId - Supplies the relative ID of the group to open.

    Level - Level of information required. 0, 1 and 2 are valid.

    Buffer - Returns a pointer to the return information structure.
        Caller must deallocate buffer using NetApiBufferFree.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    SAM_HANDLE GroupHandle = NULL;
    GROUP_GENERAL_INFORMATION *GroupGeneral = NULL;
    PVOID lastVarData;
    DWORD BufferSize;
    DWORD FixedSize;
    PSID  GroupSid = NULL;
    ULONG RidToReturn = RelativeId;

    PGROUP_INFO_0 grpi0;

    //
    // Validate the level
    //
    if ( Level == 2 ) {

        ULONG Mode;
        Status = SamGetCompatibilityMode(DomainHandle, &Mode);
        if (!NT_SUCCESS(Status)) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }
        switch (Mode) {
        case SAM_SID_COMPATIBILITY_STRICT:
            NetStatus = ERROR_NOT_SUPPORTED;
            goto Cleanup;
        case SAM_SID_COMPATIBILITY_LAX:
            RidToReturn = 0;
            break;
        }
    }

    //
    // Open the group
    //

    Status = SamOpenGroup( DomainHandle,
                           GROUP_READ_INFORMATION,
                           RelativeId,
                           &GroupHandle);

    if ( !NT_SUCCESS(Status) ) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Get the information about the group.
    //

    Status = SamQueryInformationGroup( GroupHandle,
                                       GroupReplicationInformation,
                                       (PVOID *)&GroupGeneral);

    if ( ! NT_SUCCESS( Status ) ) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Obtain the group's sid
    //
    if ( Level == 3 ) { 

        NetStatus = NetpSamRidToSid(DomainHandle,
                                    RelativeId,
                                   &GroupSid);

        if ( NetStatus != NERR_Success ) {
            goto Cleanup;
        }
    }


    //
    // Figure out how big the return buffer needs to be
    //

    switch ( Level ) {
    case 0:
        FixedSize = sizeof( GROUP_INFO_0 );
        BufferSize = FixedSize +
            GroupGeneral->Name.Length + sizeof(WCHAR);
        break;

    case 1:
        FixedSize = sizeof( GROUP_INFO_1 );
        BufferSize = FixedSize +
            GroupGeneral->Name.Length + sizeof(WCHAR) +
            GroupGeneral->AdminComment.Length + sizeof(WCHAR);
        break;

    case 2:
        FixedSize = sizeof( GROUP_INFO_2 );
        BufferSize = FixedSize +
            GroupGeneral->Name.Length + sizeof(WCHAR) +
            GroupGeneral->AdminComment.Length + sizeof(WCHAR);
        break;

    case 3:
        FixedSize = sizeof( GROUP_INFO_3 );
        BufferSize = FixedSize +
            GroupGeneral->Name.Length + sizeof(WCHAR) +
            GroupGeneral->AdminComment.Length + sizeof(WCHAR) +
            RtlLengthSid(GroupSid);

        break;

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;

    }

    //
    // Allocate the return buffer.
    //
    BufferSize = ROUND_UP_COUNT( BufferSize, ALIGN_DWORD );

    *Buffer = MIDL_user_allocate( BufferSize );

    if (*Buffer == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    lastVarData = (PBYTE) ((LPBYTE)(*Buffer)) + BufferSize;
    

    //
    // Fill the name into the return buffer.
    //

    NetpAssert( offsetof( GROUP_INFO_0, grpi0_name ) ==
                offsetof( GROUP_INFO_1, grpi1_name ) );

    NetpAssert( offsetof( GROUP_INFO_1, grpi1_name ) ==
                offsetof( GROUP_INFO_2, grpi2_name ) );

    NetpAssert( offsetof( GROUP_INFO_2, grpi2_name ) ==
                offsetof( GROUP_INFO_3, grpi3_name ) );

    NetpAssert( offsetof( GROUP_INFO_1, grpi1_comment ) ==
                offsetof( GROUP_INFO_2, grpi2_comment ) );

    NetpAssert( offsetof( GROUP_INFO_2, grpi2_comment ) ==
                offsetof( GROUP_INFO_3, grpi3_comment ) );

    grpi0 = ((PGROUP_INFO_0)*Buffer);


    //
    // Fill in the return buffer.
    //

    switch ( Level ) {
    case 3:
        {
            PGROUP_INFO_3 grpi3 = ((PGROUP_INFO_3)grpi0);

            NetpAssert( NULL != GroupSid );

            if ( !NetpCopyDataToBuffer(
                           (LPBYTE) GroupSid,
                           RtlLengthSid(GroupSid),
                           ((LPBYTE)(*Buffer)) + FixedSize,
                           (PBYTE*) &lastVarData,
                           (LPBYTE *)&grpi3->grpi3_group_sid,
                           ALIGN_DWORD ) ) {

                NetStatus = NERR_InternalError;
                goto Cleanup;
            }

            ((PGROUP_INFO_3)grpi3)->grpi3_attributes = GroupGeneral->Attributes;

            //
            // Fall through to the next level
            //

        }

    case 2:

        //
        // copy info level 2 only fields
        //
        if ( Level == 2 ) {

            ((PGROUP_INFO_2)grpi0)->grpi2_group_id = RidToReturn;
    
            ((PGROUP_INFO_2)grpi0)->grpi2_attributes = GroupGeneral->Attributes;
        }



        /* FALL THROUGH FOR OTHER FIELDS */

    case 1:

        //
        // copy fields common to info level 1 and 2.
        //


        if ( !NetpCopyStringToBuffer(
                        GroupGeneral->AdminComment.Buffer,
                        GroupGeneral->AdminComment.Length/sizeof(WCHAR),
                        ((LPBYTE)(*Buffer)) + FixedSize,
                        (LPWSTR*)&lastVarData,
                        &((PGROUP_INFO_1)grpi0)->grpi1_comment ) ) {

            NetStatus = NERR_InternalError;
            goto Cleanup;
        }


        /* FALL THROUGH FOR NAME FIELD */

    case 0:

        //
        // copy common field (name field) in the buffer.
        //

        if ( !NetpCopyStringToBuffer(
                        GroupGeneral->Name.Buffer,
                        GroupGeneral->Name.Length/sizeof(WCHAR),
                        ((LPBYTE)(*Buffer)) + FixedSize,
                        (LPWSTR*)&lastVarData,
                        &grpi0->grpi0_name ) ) {

            NetStatus = NERR_InternalError;
            goto Cleanup;
        }


        break;

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;

    }

    NetStatus = NERR_Success;

    //
    // Cleanup and return.
    //

Cleanup:
    if ( GroupGeneral ) {
        Status = SamFreeMemory( GroupGeneral );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if ( GroupHandle ) {
        (VOID) SamCloseHandle( GroupHandle );
    }

    if ( GroupSid ) {
        NetpMemoryFree( GroupSid );
    }

    IF_DEBUG( UAS_DEBUG_GROUP ) {
        NetpKdPrint(( "GrouppGetInfo: returns %ld\n", NetStatus ));
    }
    return NetStatus;

} // GrouppGetInfo


NET_API_STATUS
GrouppOpenGroup(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN LPCWSTR GroupName,
    OUT PSAM_HANDLE GroupHandle OPTIONAL,
    OUT PULONG RelativeId OPTIONAL
    )

/*++

Routine Description:

    Open a Sam Group by Name

Arguments:

    DomainHandle - Supplies the Domain Handle.

    DesiredAccess - Supplies access mask indicating desired access to group.

    GroupName - Group name of the group.

    GroupHandle - Returns a handle to the group.  If NULL, group is not
        actually opened (merely the relative ID is returned).

    RelativeId - Returns the relative ID of the group.  If NULL the relative
        Id is not returned.

Return Value:

    Error code for the operation.

--*/

{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    //
    // Variables for converting names to relative IDs
    //

    UNICODE_STRING NameString;
    PSID_NAME_USE NameUse;
    PULONG LocalRelativeId;

    RtlInitUnicodeString( &NameString, GroupName );


    //
    // Convert group name to relative ID.
    //

    Status = SamLookupNamesInDomain( DomainHandle,
                                     1,
                                     &NameString,
                                     &LocalRelativeId,
                                     &NameUse );

    if ( !NT_SUCCESS(Status) ) {
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint(( "GrouppOpenGroup: %wZ: SamLookupNamesInDomain %lX\n",
                &NameString,
                Status ));
        }
        return NetpNtStatusToApiStatus( Status );
    }

    if ( *NameUse != SidTypeGroup ) {
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint(( "GrouppOpenGroup: %wZ: Name is not a group %ld\n",
                &NameString,
                *NameUse ));
        }
        NetStatus = NERR_GroupNotFound;
        goto Cleanup;
    }

    //
    // Open the group
    //

    if ( GroupHandle != NULL ) {
        Status = SamOpenGroup( DomainHandle,
                               DesiredAccess,
                               *LocalRelativeId,
                               GroupHandle);

        if ( !NT_SUCCESS(Status) ) {
            IF_DEBUG( UAS_DEBUG_GROUP ) {
                NetpKdPrint(( "GrouppOpenGroup: %wZ: SamOpenGroup %lX\n",
                    &NameString,
                    Status ));
            }
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }
    }

    //
    // Return the relative Id if it's wanted.
    //

    if ( RelativeId != NULL ) {
        *RelativeId = *LocalRelativeId;
    }

    NetStatus = NERR_Success;


    //
    // Cleanup
    //

Cleanup:
    if ( LocalRelativeId != NULL ) {
        Status = SamFreeMemory( LocalRelativeId );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if ( NameUse != NULL ) {
        Status = SamFreeMemory( NameUse );
        NetpAssert( NT_SUCCESS(Status) );
    }

    return NetStatus;


} // GrouppOpenGroup


VOID
GrouppRelocationRoutine(
    IN DWORD Level,
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN PTRDIFF_T Offset
    )

/*++

Routine Description:

   Routine to relocate the pointers from the fixed portion of a NetGroupEnum
   enumeration
   buffer to the string portion of an enumeration buffer.  It is called
   as a callback routine from NetpAllocateEnumBuffer when it re-allocates
   such a buffer.  NetpAllocateEnumBuffer copied the fixed portion and
   string portion into the new buffer before calling this routine.

Arguments:

    Level - Level of information in the  buffer.

    BufferDescriptor - Description of the new buffer.

    Offset - Offset to add to each pointer in the fixed portion.

Return Value:

    Returns the error code for the operation.

--*/

{
    DWORD EntryCount;
    DWORD EntryNumber;
    DWORD FixedSize;
    IF_DEBUG( UAS_DEBUG_GROUP ) {
        NetpKdPrint(( "GrouppRelocationRoutine: entering\n" ));
    }

    //
    // Compute the number of fixed size entries
    //

    switch (Level) {
    case 0:
        FixedSize = sizeof(GROUP_INFO_0);
        break;

    case 1:
        FixedSize = sizeof(GROUP_INFO_1);
        break;

    case 2:
        FixedSize = sizeof(GROUP_INFO_2);
        break;

    default:
        NetpAssert( FALSE );
        return;

    }

    EntryCount =
        ((DWORD)(BufferDescriptor->FixedDataEnd - BufferDescriptor->Buffer)) /
        FixedSize;

    //
    // Loop relocating each field in each fixed size structure
    //

    for ( EntryNumber=0; EntryNumber<EntryCount; EntryNumber++ ) {

        LPBYTE TheStruct = BufferDescriptor->Buffer + FixedSize * EntryNumber;

        switch ( Level ) {
        case 2:
        case 1:
            RELOCATE_ONE( ((PGROUP_INFO_1)TheStruct)->grpi1_comment, Offset );

            //
            // Drop through to case 0
            //

        case 0:
            RELOCATE_ONE( ((PGROUP_INFO_0)TheStruct)->grpi0_name, Offset );
            break;

        default:
            return;

        }

    }

    return;

} // GrouppRelocationRoutine


VOID
GrouppMemberRelocationRoutine(
    IN DWORD Level,
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN PTRDIFF_T Offset
    )

/*++

Routine Description:

   Routine to relocate the pointers from the fixed portion of a
   NetGroupGetUsers enumeration
   buffer to the string portion of an enumeration buffer.  It is called
   as a callback routine from NetpAllocateEnumBuffer when it re-allocates
   such a buffer.  NetpAllocateEnumBuffer copied the fixed portion and
   string portion into the new buffer before calling this routine.

Arguments:

    Level - Level of information in the  buffer.

    BufferDescriptor - Description of the new buffer.

    Offset - Offset to add to each pointer in the fixed portion.

Return Value:

    Returns the error code for the operation.

--*/

{
    DWORD EntryCount;
    DWORD EntryNumber;
    DWORD FixedSize;
    IF_DEBUG( UAS_DEBUG_GROUP ) {
        NetpKdPrint(( "GrouppMemberRelocationRoutine: entering\n" ));
    }

    //
    // Compute the number of fixed size entries
    //

    switch (Level) {
    case 0:
        FixedSize = sizeof(GROUP_USERS_INFO_0);
        break;

    case 1:
        FixedSize = sizeof(GROUP_USERS_INFO_1);
        break;

    default:
        NetpAssert( FALSE );
        return;

    }

    EntryCount =
        ((DWORD)(BufferDescriptor->FixedDataEnd - BufferDescriptor->Buffer)) /
        FixedSize;

    //
    // Loop relocating each field in each fixed size structure
    //

    for ( EntryNumber=0; EntryNumber<EntryCount; EntryNumber++ ) {

        LPBYTE TheStruct = BufferDescriptor->Buffer + FixedSize * EntryNumber;

        //
        // Both info levels only have one field to relocate
        //

        RELOCATE_ONE( ((PGROUP_USERS_INFO_0)TheStruct)->grui0_name, Offset );


    }

    return;

} // GrouppMemberRelocationRoutine



NET_API_STATUS
GrouppSetUsers (
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR GroupName,
    IN DWORD Level,
    IN LPBYTE Buffer,
    IN DWORD NewMemberCount,
    IN BOOL DeleteGroup
    )

/*++

Routine Description:

    Set the list of members of a group and optionally delete the group
    when finished.

    The members specified by "Buffer" are called new members.  The current
    members of the group are called old members.  Members which are
    on both the old and new list are common members.

    The SAM API allows only one member to be added or deleted at a time.
    This API allows all of the members of a group to be specified en-masse.
    This API is careful to always leave the group membership in the SAM
    database in a reasonable state.  It does by mergeing the list of
    old and new members, then only changing those memberships which absolutely
    need changing.

    Group membership is restored to its previous state (if possible) if
    an error occurs during changing the group membership.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    GroupName - Name of the group to modify.

    Level - Level of information provided.  Must be 0 or 1.

    Buffer - A pointer to the buffer containing an array of NewMemberCount
        the group membership information structures.

    NewMemberCount - Number of entries in Buffer.

    DeleteGroup - TRUE if the group is to be deleted after changing the
        membership.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAM_HANDLE GroupHandle = NULL;
    ACCESS_MASK DesiredAccess;

    //
    // Variables for dealing with old or new lists of members
    //

    PULONG  NewRelativeIds = NULL;  // Relative Ids of the new members
    PULONG  OldRelativeIds = NULL;  // Relative Ids of the old members
    PULONG  OldAttributes = NULL;   // Attributes of the old members

    PSID_NAME_USE NewNameUse = NULL;// Name usage of the new members
    PSID_NAME_USE OldNameUse = NULL;// Name usage of the old members

    PUNICODE_STRING NameStrings = NULL;        // Names of a list of members

    ULONG OldMemberCount;       // Number of current members in the group

    ULONG DefaultMemberAttributes;      // Default attributes for new members

    DWORD FixedSize;

    //
    // Define an internal member list structure.
    //
    // The structure defines a list of new members to be added, members whose
    //      attributes merely need to be changed, and members which
    //      need to be deleted.  The list is maintained in relative ID sorted
    //      order.
    //

    struct _MEMBER_DESCRIPTION {
        struct _MEMBER_DESCRIPTION * Next;  // Next entry in linked list;

        ULONG   RelativeId;     // Relative ID of this member

        enum _Action {          // Action taken for this member
            AddMember,              // Add Member to group
            RemoveMember,           // Remove Member from group
            SetAttributesMember,    // Change the Members attributes
            IgnoreMember            // Ignore this member
        } Action;

        ULONG NewAttributes;    // Attributes to set for the member

        BOOL    Done;           // True if this action has been taken

        ULONG OldAttributes;    // Attributes to restore on a recovery

    } *MemberList = NULL , *CurEntry, **Entry;

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint(( "GrouppSetUsers: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the Domain
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_LOOKUP,
                                TRUE,   // Account Domain
                                &DomainHandle,
                                NULL); // DomainId

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint(( "GrouppSetUsers: UaspOpenDomain returns %ld\n",
                      NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the group
    //
    DesiredAccess = GROUP_READ_INFORMATION | GROUP_LIST_MEMBERS |
                                    GROUP_ADD_MEMBER | GROUP_REMOVE_MEMBER;
    if ( DeleteGroup ) {
        NetpAssert( NewMemberCount == 0 );
        DesiredAccess |= DELETE;
    }

    NetStatus = GrouppOpenGroup( DomainHandle,
                                 DesiredAccess,
                                 GroupName,
                                 &GroupHandle,
                                 NULL );    // Relative Id

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint(( "GrouppSetUsers: GrouppOpenGroup returns %ld\n",
                      NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Validate the level
    //

    switch (Level) {
    case 0: {

        //
        // Determine the attributes of the group as a whole.  Use that
        // for deciding on the default attributes for new members.
        //

        PGROUP_ATTRIBUTE_INFORMATION Attributes;

        Status = SamQueryInformationGroup( GroupHandle,
                                           GroupAttributeInformation,
                                           (PVOID*)&Attributes );

        if ( !NT_SUCCESS(Status) ) {
            IF_DEBUG( UAS_DEBUG_GROUP ) {
                NetpKdPrint((
                    "GrouppSetUsers: SamQueryInformationGroup returns %lX\n",
                    Status ));
            }
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        DefaultMemberAttributes =
            (Attributes->Attributes & SE_GROUP_MANDATORY) |
            SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED ;

        FixedSize = sizeof( GROUP_USERS_INFO_0 );

        Status = SamFreeMemory( Attributes );
        NetpAssert( NT_SUCCESS(Status) );

        break;
    }

    case 1:
        FixedSize = sizeof( GROUP_USERS_INFO_1 );
        break;

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    //
    // Determine the Relative Id and usage of each of the new members.
    //

    if ( NewMemberCount > 0 ) {
        DWORD NewIndex;     // Index to a new member
        PGROUP_USERS_INFO_0 grui0;

        //
        // Allocate a buffer big enough to contain all the string variables
        //  for the new member names.
        //

        NameStrings = NetpMemoryAllocate( NewMemberCount *
            sizeof(UNICODE_STRING) );

        if ( NameStrings == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Fill in the list of member name strings for each new member.
        //

        NetpAssert( offsetof( GROUP_USERS_INFO_0, grui0_name ) ==
                    offsetof( GROUP_USERS_INFO_1, grui1_name ) );

        for ( NewIndex=0, grui0 = (PGROUP_USERS_INFO_0)Buffer;
                    NewIndex<NewMemberCount;
                        NewIndex++,
                        grui0 = (PGROUP_USERS_INFO_0)
                                    ((LPBYTE)grui0 + FixedSize) ) {

            RtlInitUnicodeString(&NameStrings[NewIndex], grui0->grui0_name);

        }

        //
        // Convert the member names to relative Ids.
        //

        Status = SamLookupNamesInDomain( DomainHandle,
                                         NewMemberCount,
                                         NameStrings,
                                         &NewRelativeIds,
                                         &NewNameUse );

        if ( !NT_SUCCESS( Status )) {
            IF_DEBUG( UAS_DEBUG_GROUP ) {
                NetpKdPrint((
                    "GrouppSetUsers: SamLookupNamesInDomain returns %lX\n",
                    Status ));
            }
            if ( Status == STATUS_NONE_MAPPED ) {
                NetStatus = NERR_UserNotFound;
                goto Cleanup;
            }
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        //
        // Build a member entry for each of the new members.
        //  The list is maintained in RelativeId sorted order.
        //

        for ( NewIndex=0; NewIndex<NewMemberCount; NewIndex++ ) {

            //
            // Ensure this new member name is an existing user name.
            //  Group names are not allowed to be added via this API.
            //

            if (NewNameUse[NewIndex] != SidTypeUser) {
                NetStatus = NERR_UserNotFound;
                goto Cleanup;
            }

            //
            // Find the place to put the new entry
            //

            Entry = &MemberList ;
            while ( *Entry != NULL &&
                (*Entry)->RelativeId < NewRelativeIds[NewIndex] ) {

                Entry = &( (*Entry)->Next );
            }

            //
            // If this is not a duplicate entry, allocate a new member structure
            //  and fill it in.
            //
            // Just ignore duplicate relative Ids.
            //

            if ( *Entry == NULL ||
                (*Entry)->RelativeId > NewRelativeIds[NewIndex] ) {

                CurEntry = NetpMemoryAllocate(
                    sizeof(struct _MEMBER_DESCRIPTION));

                if ( CurEntry == NULL ) {
                    NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }

                CurEntry->Next = *Entry;
                CurEntry->RelativeId = NewRelativeIds[NewIndex];
                CurEntry->Action = AddMember;
                CurEntry->Done = FALSE;

                CurEntry->NewAttributes = ( Level == 1 ) ?
                    ((PGROUP_USERS_INFO_1)Buffer)[NewIndex].grui1_attributes :
                    DefaultMemberAttributes;

                *Entry = CurEntry;
            }
        }

        NetpMemoryFree( NameStrings );
        NameStrings = NULL;

        Status = SamFreeMemory( NewRelativeIds );
        NewRelativeIds = NULL;
        NetpAssert( NT_SUCCESS(Status) );

        Status = SamFreeMemory( NewNameUse );
        NewNameUse = NULL;
        NetpAssert( NT_SUCCESS(Status) );
    }

    //
    // Determine the number of old members for this group and the
    //  relative ID's of the old members.
    //

    Status = SamGetMembersInGroup(
                    GroupHandle,
                    &OldRelativeIds,
                    &OldAttributes,
                    &OldMemberCount );

    if ( !NT_SUCCESS( Status ) ) {
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint((
                "GrouppSetUsers: SamGetMembersInGroup returns %lX\n",
                Status ));
        }
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // If there are any old members,
    //  Merge them into the list.
    //

    if ( OldMemberCount > 0 ) {
        ULONG OldIndex;                     // Index to current entry
        PUNICODE_STRING Names;


        //
        // Determine the usage for all the returned relative Ids.
        //

        Status = SamLookupIdsInDomain(
            DomainHandle,
            OldMemberCount,
            OldRelativeIds,
            &Names,
            &OldNameUse );

        if ( !NT_SUCCESS( Status ) ) {
            IF_DEBUG( UAS_DEBUG_GROUP ) {
                NetpKdPrint((
                    "GrouppSetUsers: SamLookupIdsInDomain returns %lX\n",
                    Status ));
            }

            if ( Status == STATUS_NONE_MAPPED ) {
                NetStatus = NERR_InternalError ;
                goto Cleanup;
            }

            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        Status = SamFreeMemory( Names );    // Don't need names at all
        NetpAssert( NT_SUCCESS(Status) );


        //
        // Loop for each current member
        //

        for ( OldIndex=0; OldIndex<OldMemberCount; OldIndex++ ) {

            //
            // Ignore old members which aren't a user.
            //

            if ( OldNameUse[OldIndex] != SidTypeUser ) {

                //
                // ?? Why? is't it internal error ?
                //

                continue;
            }

            //
            // Find the place to put the new entry
            //

            Entry = &MemberList ;
            while ( *Entry != NULL &&
                (*Entry)->RelativeId < OldRelativeIds[OldIndex] ) {

                Entry = &( (*Entry)->Next );
            }

            //
            // If this entry is not already in the list,
            //      this is a member which exists now but should be deleted.
            //

            if( *Entry == NULL || (*Entry)->RelativeId > OldRelativeIds[OldIndex]){

                CurEntry =
                    NetpMemoryAllocate(sizeof(struct _MEMBER_DESCRIPTION));
                if ( CurEntry == NULL ) {
                    NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }

                CurEntry->Next = *Entry;
                CurEntry->RelativeId = OldRelativeIds[OldIndex];
                CurEntry->Action = RemoveMember;
                CurEntry->Done = FALSE;
                CurEntry->OldAttributes = OldAttributes[OldIndex];

                *Entry = CurEntry;

            //
            // Handle the case where this member is already in the list
            //

            } else {

                //
                // Watch out for SAM returning the same member twice.
                //

                if ( (*Entry)->Action != AddMember ) {
                    Status = NERR_InternalError;
                    goto Cleanup;
                }

                //
                // If this is info level 1 and the requested attributes are
                //  different than the current attributes,
                //      Remember to change the attributes.
                //

                if ( Level == 1 &&
                    (*Entry)->NewAttributes != OldAttributes[OldIndex] ) {

                    (*Entry)->OldAttributes = OldAttributes[OldIndex];
                    (*Entry)->Action = SetAttributesMember;

                //
                // This is either info level 0 or the level 1 attributes
                //  are the same as the existing attributes.
                //

                } else {
                    (*Entry)->Action = IgnoreMember;
                }
            }
        }
    }

    //
    // Loop through the list adding all new members.
    //  We do this in a separate loop to minimize the damage that happens
    //  should we get an error and not be able to recover.
    //

    for ( CurEntry = MemberList; CurEntry != NULL ; CurEntry=CurEntry->Next ) {
        if ( CurEntry->Action == AddMember ) {
            Status = SamAddMemberToGroup( GroupHandle,
                                          CurEntry->RelativeId,
                                          CurEntry->NewAttributes );

            if ( !NT_SUCCESS( Status ) ) {
                IF_DEBUG( UAS_DEBUG_GROUP ) {
                    NetpKdPrint((
                        "GrouppSetUsers: SamAddMemberToGroup returns %lX\n",
                        Status ));
                }
                NetStatus = NetpNtStatusToApiStatus( Status );
                goto Cleanup;
            }

            CurEntry->Done = TRUE;

        }
    }

    //
    // Loop through the list deleting all old members and changing the
    //  attributes of all common members.
    //

    for ( CurEntry = MemberList; CurEntry != NULL ; CurEntry=CurEntry->Next ) {

        if ( CurEntry->Action == RemoveMember ) {
            Status = SamRemoveMemberFromGroup( GroupHandle,
                                               CurEntry->RelativeId);

            if ( !NT_SUCCESS( Status ) ) {
                IF_DEBUG( UAS_DEBUG_GROUP ) {
                    NetpKdPrint((
                        "GrouppSetUsers: SamRemoveMemberFromGroup returns %lX\n",
                        Status ));
                }
                NetStatus = NetpNtStatusToApiStatus( Status );
                goto Cleanup;
            }

        } else if ( CurEntry->Action == SetAttributesMember ) {
            Status = SamSetMemberAttributesOfGroup( GroupHandle,
                                                    CurEntry->RelativeId,
                                                    CurEntry->NewAttributes);

            if ( !NT_SUCCESS( Status ) ) {
                IF_DEBUG( UAS_DEBUG_GROUP ) {
                    NetpKdPrint((
                        "GrouppSetUsers: SamSetMemberAttributesOfGroup returns %lX\n",
                        Status ));
                }
                NetStatus = NetpNtStatusToApiStatus( Status );
                goto Cleanup;
            }

        }


        CurEntry->Done = TRUE;
    }

    //
    // Delete the group if requested to do so.
    //

    if ( DeleteGroup ) {

        Status = SamDeleteGroup( GroupHandle );

        if ( !NT_SUCCESS( Status ) ) {
            IF_DEBUG( UAS_DEBUG_GROUP ) {
                NetpKdPrint(( "GrouppSetUsers: SamDeleteGroup returns %lX\n",
                    Status ));
            }
            NetStatus = NetpNtStatusToApiStatus( Status );

            //
            // Put the group memberships back the way they were.
            //
            goto Cleanup;
        }
        GroupHandle = NULL;
    }

    NetStatus = NERR_Success;

    //
    // Clean up.
    //

Cleanup:

    //
    // Walk the member list cleaning up any damage we've done
    //

    for ( CurEntry = MemberList; CurEntry != NULL ; ) {

        struct _MEMBER_DESCRIPTION *DelEntry;

        if ( NetStatus != NERR_Success && CurEntry->Done ) {
            switch (CurEntry->Action) {
            case AddMember:
                Status = SamRemoveMemberFromGroup( GroupHandle,
                                                   CurEntry->RelativeId );
                NetpAssert( NT_SUCCESS(Status) );

                break;

            case RemoveMember:
                Status = SamAddMemberToGroup( GroupHandle,
                                              CurEntry->RelativeId,
                                              CurEntry->OldAttributes );
                NetpAssert( NT_SUCCESS(Status) );

                break;

            case SetAttributesMember:
                Status = SamSetMemberAttributesOfGroup(
                                            GroupHandle,
                                            CurEntry->RelativeId,
                                            CurEntry->OldAttributes );
                NetpAssert( NT_SUCCESS(Status) );

                break;

            default:
                break;
            }
        }

        DelEntry = CurEntry;
        CurEntry = CurEntry->Next;

        NetpMemoryFree( DelEntry );
    }

    if ( NameStrings != NULL ) {
        NetpMemoryFree( NameStrings );
    }

    if (NewRelativeIds != NULL) {
        Status = SamFreeMemory( NewRelativeIds );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if (NewNameUse != NULL) {
        Status = SamFreeMemory( NewNameUse );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if (OldNameUse != NULL) {
        Status = SamFreeMemory( OldNameUse );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if (OldRelativeIds != NULL) {
        Status = SamFreeMemory( OldRelativeIds );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if (OldAttributes != NULL) {
        Status = SamFreeMemory( OldAttributes );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if (GroupHandle != NULL) {
        (VOID) SamCloseHandle( GroupHandle );
    }

    UaspCloseDomain( DomainHandle );

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    IF_DEBUG( UAS_DEBUG_GROUP ) {
        NetpKdPrint(( "GrouppSetUsers: returns %ld\n", NetStatus ));
    }

    return NetStatus;

} // GrouppSetUsers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\dumpdb.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    repltest.c

Abstract:

    List user objects from SAM  database. Used to verify SAM
    replication.

Author:

    Cliff Van Dyke (cliffv) 26-Mar-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <netlib.h>
#include <netdebug.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <ntsam.h>

#include "accessp.h"
#include "netlogon.h"
#include "logonp.h"


NET_API_STATUS
Print_UserInfo3(
    LPWSTR UserName
    )
/*++
Routine Description:

    Prints out the user information at level 3.

Arguments:

    UserName : Name of the user.

Return Value:

    Net access API error code.

--*/
{

    NET_API_STATUS NetStatus;
    PUSER_INFO_3  UserInfo3;

    //
    // get user info
    //

    NetStatus = NetUserGetInfo(
                    NULL,
                    UserName,
                    3,
                    (LPBYTE *)&UserInfo3
                    );

    if( NetStatus != NERR_Success ) {

        return( NetStatus );
    }

    //
    // print out user info
    //

    printf( "name           : %ws \n", UserInfo3->usri3_name);
    // printf( "password       : %ws \n", UserInfo3->usri3_password);
    printf( "password_age   : %d \n", UserInfo3->usri3_password_age);
    printf( "priv           : %d \n", UserInfo3->usri3_priv);
    printf( "home_dir       : %ws \n", UserInfo3->usri3_home_dir);
    printf( "comment        : %ws \n", UserInfo3->usri3_comment);
    printf( "flags          : %d \n", UserInfo3->usri3_flags);
    printf( "script_path    : %ws \n", UserInfo3->usri3_script_path);
    printf( "auth_flags     : %d \n", UserInfo3->usri3_auth_flags);
    printf( "full_name      : %ws \n", UserInfo3->usri3_full_name);
    printf( "usr_comment    : %ws \n", UserInfo3->usri3_usr_comment);
    printf( "parms          : %ws \n", UserInfo3->usri3_parms);
    printf( "workstations   : %ws \n", UserInfo3->usri3_workstations);
    printf( "last_logon     : %d \n", UserInfo3->usri3_last_logon);
    printf( "last_logoff    : %d \n", UserInfo3->usri3_last_logoff);
    printf( "acct_expires   : %d \n", UserInfo3->usri3_acct_expires);
    printf( "max_storage    : %d \n", UserInfo3->usri3_max_storage);
    printf( "units_per_week : %d \n", UserInfo3->usri3_units_per_week);
    printf( "logon_hours    : %ws \n", UserInfo3->usri3_logon_hours);
    printf( "bad_pw_count   : %d \n", UserInfo3->usri3_bad_pw_count);
    printf( "num_logons     : %d \n", UserInfo3->usri3_num_logons);
    printf( "logon_server   : %ws \n", UserInfo3->usri3_logon_server);
    printf( "country_code   : %d \n", UserInfo3->usri3_country_code);
    printf( "code_page      : %d \n", UserInfo3->usri3_code_page);
    printf( "user_id        : %d \n", UserInfo3->usri3_user_id);
    printf( "primary_group_i: %d \n", UserInfo3->usri3_primary_group_id);
    printf( "profile        : %ws \n", UserInfo3->usri3_profile);
    printf( "home_dir_drive : %ws \n", UserInfo3->usri3_home_dir_drive);

    (VOID) NetApiBufferFree( UserInfo3 );

    return( NetStatus );

}

NET_API_STATUS
Print_GroupInfo2(
    LPWSTR GroupName
    )
/*++
Routine Description:

    Prints out the group information at level 2.

Arguments:

    GroupName : Name of the group.

Return Value:

    Net access API error code.

--*/
{
    NET_API_STATUS NetStatus;
    PGROUP_INFO_2 GroupInfo2;

    //
    // get group info
    //

    NetStatus = NetGroupGetInfo(
                    NULL,
                    GroupName,
                    2,
                    (LPBYTE *)&GroupInfo2
                    );

    if( NetStatus != NERR_Success ) {

        return( NetStatus );
    }

    printf( "name        : %ws \n", GroupInfo2->grpi2_name);
    printf( "comment     : %ws \n", GroupInfo2->grpi2_comment);
    printf( "group_id    : %d \n", GroupInfo2->grpi2_group_id);
    printf( "attributes  : %d \n", GroupInfo2->grpi2_attributes);

    (VOID) NetApiBufferFree( GroupInfo2 );

    return( NetStatus );
}

NET_API_STATUS
Print_ModalsInfo(
    )
/*++
Routine Description:

    Prints out the modals information.

Arguments:

    None.

Return Value:

    Net access API error code.

--*/
{

    NET_API_STATUS NetStatus;
    PUSER_MODALS_INFO_0 ModalsInfo0;
    PUSER_MODALS_INFO_1 ModalsInfo1;
    PUSER_MODALS_INFO_2 ModalsInfo2;


    //
    // get modals info 0
    //

    NetStatus = NetUserModalsGet(
                    NULL,
                    0,
                    (LPBYTE *)&ModalsInfo0
                    );

    if( NetStatus != NERR_Success ) {

        return( NetStatus );
    }

    printf( "Modals Info  \n\n" );
    printf( "min_passwd_len   : %d \n", ModalsInfo0->usrmod0_min_passwd_len);
    printf( "max_passwd_age   : %d \n", ModalsInfo0->usrmod0_max_passwd_age);
    printf( "min_passwd_age   : %d \n", ModalsInfo0->usrmod0_min_passwd_age);
    printf( "force_logoff     : %d \n", ModalsInfo0->usrmod0_force_logoff);
    printf( "password_hist_len: %d \n", ModalsInfo0->usrmod0_password_hist_len);

    //
    // get modals info 1
    //

    NetStatus = NetUserModalsGet(
                    NULL,
                    1,
                    (LPBYTE *)&ModalsInfo1
                    );

    if( NetStatus != NERR_Success ) {

        return( NetStatus );
    }

    printf( "role     : %d \n", ModalsInfo1->usrmod1_role);
    printf( "primary  : %ws \n", ModalsInfo1->usrmod1_primary);

    //
    // get modals info 2
    //

    NetStatus = NetUserModalsGet(
                    NULL,
                    2,
                    (LPBYTE *)&ModalsInfo2
                    );

    if( NetStatus != NERR_Success ) {

        return( NetStatus );
    }

    printf( "domain_name  : %ws \n", ModalsInfo2->usrmod2_domain_name);
    printf( "domain_id    : %d \n", ModalsInfo2->usrmod2_domain_id);
    printf("--------------------------------\n\n");

    (VOID) NetApiBufferFree( ModalsInfo0 );
    (VOID) NetApiBufferFree( ModalsInfo1 );
    (VOID) NetApiBufferFree( ModalsInfo2 );

    return( NetStatus );
}

NET_API_STATUS
Print_Users(
    )
/*++
Routine Description:

    Enumurates user accounts.

Arguments:

    None.

Return Value:

    Net access API error code.

--*/
{

    NET_API_STATUS NetStatus;

    PUSER_INFO_0 UserEnum0;
    DWORD EntriesRead;
    DWORD TotalEnties;
    DWORD ResumeHandle = 0;
    DWORD i;

    //
    // Enum users
    //

    NetStatus = NetUserEnum(
                    NULL,
                    0,
                    FILTER_TEMP_DUPLICATE_ACCOUNT |
                        FILTER_NORMAL_ACCOUNT |
                        FILTER_PROXY_ACCOUNT |
                        FILTER_INTERDOMAIN_TRUST_ACCOUNT |
                        FILTER_WORKSTATION_TRUST_ACCOUNT|
                        FILTER_SERVER_TRUST_ACCOUNT,
                    (LPBYTE *)&UserEnum0,
                    0x10000,
                    &EntriesRead,
                    &TotalEnties,
                    &ResumeHandle );

    if( NetStatus != NERR_Success ) {

        return( NetStatus );
    }

    //
    // ?? implement resume
    //

    //
    // get info of users
    //

    for( i = 0; i < EntriesRead; i++ ) {

        printf("UserInfo, Count : %d \n\n", i+1 );

        NetStatus = Print_UserInfo3( UserEnum0[i].usri0_name );

        if( NetStatus != NERR_Success ) {

            return( NetStatus );
        }

        printf("--------------------------------\n\n");
    }

    (VOID) NetApiBufferFree( UserEnum0 );

    return( NetStatus );
}


NET_API_STATUS
Print_Groups(
    )
/*++
Routine Description:

    Enumurates group accounts.

Arguments:

    None.

Return Value:

    Net access API error code.

--*/
{

    NET_API_STATUS NetStatus;

    PGROUP_INFO_0 GroupEnum0;
    DWORD EntriesRead;
    DWORD TotalEnties;
    DWORD ResumeHandle = 0;
    DWORD i;

    //
    // Enum groups
    //

    NetStatus = NetGroupEnum(
                    NULL,
                    0,
                    (LPBYTE *)&GroupEnum0,
                    0x10000,
                    &EntriesRead,
                    &TotalEnties,
                    &ResumeHandle );

    if( NetStatus != NERR_Success ) {

        return( NetStatus );
    }

    //
    // ?? implement resume
    //

    //
    // get info of groups
    //

    for( i = 0; i < EntriesRead; i++ ) {

        printf("GroupInfo, Count : %d \n\n", i+1 );

        NetStatus = Print_GroupInfo2( GroupEnum0[i].grpi0_name );

        if( NetStatus != NERR_Success ) {

            return( NetStatus );
        }

        printf("--------------------------------\n\n");
    }

    (VOID) NetApiBufferFree( GroupEnum0 );

    return( NetStatus );
}


void
main(
    DWORD argc,
    LPSTR *argv
    )
/*++
Routine Description:

    main function to dump user database.

Arguments:

    argc : argument count.

    argv : argument vector.

Return Value:

    none

--*/
{

    NET_API_STATUS NetStatus;


    NetStatus = Print_ModalsInfo();

    if( NetStatus != NERR_Success ) {

        goto Cleanup;
    }

    NetStatus = Print_Users();

    if( NetStatus != NERR_Success ) {

        goto Cleanup;
    }

    NetStatus = Print_Groups();

    if( NetStatus != NERR_Success ) {

        goto Cleanup;
    }

Cleanup:

    if( NetStatus != NERR_Success ) {

        printf( "DumpDB : Unsuccessful, Error code %d \n", NetStatus );
    }
    else {

        printf( "DumpDB : Successful \n" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\setrole.c ===
///**************************************************************
///          Microsoft LAN Manager          *
///        Copyright(c) Microsoft Corp., 1990       *
///**************************************************************
//
//  This program is designed to do functional testing on the following
//  APIs:
//      NetUserModalsGet
//      NetUserModalsSet
//
//  This test can be run independently of other tests.
//
//

#include <nt.h> // TIME definition
#include <ntrtl.h>      // TIME definition
#include <nturtl.h>     // TIME definition
#define NOMINMAX        // Avoid redefinition of min and max in stdlib.h
#include        <windef.h>
#include        <winbase.h>

#include        <stdio.h>
#include        <stdlib.h>
#include        <string.h>
#include        <lmcons.h>
#include        <lmapibuf.h>
#include        <netlib.h>
#include        <netdebug.h>
#include        <lmaccess.h>
#include        <lmerr.h>
#include <ntsam.h>

#include "accessp.h"
#include "netlogon.h"
#include "logonp.h"


//
//  SetRole()
//

void
SetRole(
    DWORD Role
    )
{
    DWORD err;
    PUSER_MODALS_INFO_1 um1p;
    USER_MODALS_INFO_1006 um1006;

    //
    // setup data for update
    //
    um1006.usrmod1006_role = Role;

    if (err = NetUserModalsSet(NULL, 1006, (LPBYTE)&um1006, NULL)) {

        printf("NetUserModalsSet failed %d \n", err);
        return;

    } else {

        //
        // verify set data
        //

        if (err = NetUserModalsGet(NULL, 1, (LPBYTE *) &um1p)) {

            printf("NetUserModalsGet failed %d \n", err);
            return;

        } else {

            //
            // verify initial settings
            //

            if( um1p->usrmod1_role != Role ) {
                printf("Verify ROLE failed \n");
            }
            else {
                printf("SamRole set successfully");
            }

            NetApiBufferFree( um1p );

        }
    }

    return;
}

void __cdecl
main(argc, argv)
int argc;
char    **argv;
{
    DWORD Role;

    if( argc < 2 ) {
        printf("Usage : SamRole [ Primary | Backup ] \n" );
        return;
    }

    if(_stricmp( argv[1], "Primary" ) == 0) {

        Role = UAS_ROLE_PRIMARY;

    } else if( _stricmp(argv[1], "Backup") == 0) {

        Role = UAS_ROLE_BACKUP;

    } else {

        printf("Usage : SamRole [ Primary | Backup ] \n" );
        return;
    }

    SetRole(Role);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\uasp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    uasp.c

Abstract:

    Private functions shared by the UAS API routines.

Author:

    Cliff Van Dyke (cliffv) 20-Feb-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    17-Apr-1991 (cliffv)
        Incorporated review comments.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef DOMAIN_ALL_ACCESS // defined in both ntsam.h and ntwinapi.h
#include <ntsam.h>
#include <ntlsa.h>

#include <windef.h>
#include <winbase.h>
#include <lmcons.h>

#include <accessp.h>
#include <dsgetdc.h>
#include <icanon.h>
#include <lmerr.h>
#include <lmwksta.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmremutl.h>           // NetpRemoteComputerSupports(), SUPPORTS_ stuff
#include <lmsvc.h>              // SERVICE_WORKSTATION.
#include <names.h>
#include <netdebug.h>
#include <netlib.h>
#include <netlibnt.h>

#include <stddef.h>
#include <stdlib.h>

#include <uasp.h>

#include <tstring.h>            // NetAllocWStrFromWStr

SID_IDENTIFIER_AUTHORITY UaspBuiltinAuthority = SECURITY_NT_AUTHORITY;

#ifdef UAS_DEBUG
DWORD UasTrace = 0;
#endif // UAS_DEBUG


NET_API_STATUS
UaspOpenSam(
    IN LPCWSTR ServerName OPTIONAL,
    IN BOOL AllowNullSession,
    OUT PSAM_HANDLE SamServerHandle
    )

/*++

Routine Description:

    Open a handle to a Sam server.

Arguments:

    ServerName - A pointer to a string containing the name of the
        Domain Controller (DC) to query.  A NULL pointer
        or string specifies the local machine.

    AllowNullSession - TRUE if we should fall back to the NULL session if
        we cannot connect using current credentials

    SamServerHandle - Returns the SAM connection handle if the caller wants it.
        Close this handle by calling SamCloseHandle

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    BOOLEAN ImpersonatingAnonymous = FALSE;
    HANDLE CurrentToken = NULL;

    UNICODE_STRING ServerNameString;


    //
    // Sanity check the server name
    //

    if ( ServerName == NULL ) {
        ServerName = L"";
    }

#ifdef notdef
    if ( *ServerName != L'\0' &&
         (ServerName[0] != L'\\' || ServerName[1] != L'\\') ) {
        return NERR_InvalidComputer;
    }
#endif // notdef


    //
    // Connect to the SAM server
    //

    RtlInitUnicodeString( &ServerNameString, ServerName );

    Status = SamConnect(
                &ServerNameString,
                SamServerHandle,
                SAM_SERVER_LOOKUP_DOMAIN | SAM_SERVER_ENUMERATE_DOMAINS,
                NULL);

    //
    // If the caller would rather use the null session than fail,
    //  impersonate the anonymous token.
    //

    if ( AllowNullSession && Status == STATUS_ACCESS_DENIED ) {
        *SamServerHandle = NULL;

        //
        // Check to see if we're already impsonating
        //

        Status = NtOpenThreadToken(
                        NtCurrentThread(),
                        TOKEN_IMPERSONATE,
                        TRUE,       // as self to ensure we never fail
                        &CurrentToken
                        );

        if ( Status == STATUS_NO_TOKEN ) {
            //
            // We're not already impersonating
            CurrentToken = NULL;

        } else if ( !NT_SUCCESS(Status) ) {
            IF_DEBUG( UAS_DEBUG_UASP ) {
                NetpKdPrint(( "UaspOpenSam: cannot NtOpenThreadToken: 0x%lx\n",
                               Status ));
            }

            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }


        //
        // Impersonate the anonymous token
        //
        Status = NtImpersonateAnonymousToken( NtCurrentThread() );

        if ( !NT_SUCCESS( Status)) {
            IF_DEBUG( UAS_DEBUG_UASP ) {
                NetpKdPrint(( "UaspOpenSam: cannot NtImpersonateAnonymousToken: 0x%lx\n",
                               Status ));
            }

            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        ImpersonatingAnonymous = TRUE;

        //
        // Connect again now that we're impersonating anonymous
        //

        Status = SamConnect(
                    &ServerNameString,
                    SamServerHandle,
                    SAM_SERVER_LOOKUP_DOMAIN | SAM_SERVER_ENUMERATE_DOMAINS,
                    NULL);

    }

    if ( !NT_SUCCESS(Status)) {
        IF_DEBUG( UAS_DEBUG_UASP ) {
            NetpKdPrint(( "UaspOpenSam: Cannot connect to Sam %lX\n",
                           Status ));
        }
        *SamServerHandle = NULL;
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }


    NetStatus = NERR_Success;


    //
    // Cleanup locally used resources
    //
Cleanup:

    if ( ImpersonatingAnonymous ) {

        Status = NtSetInformationThread(
                         NtCurrentThread(),
                         ThreadImpersonationToken,
                         &CurrentToken,
                         sizeof(HANDLE) );

        if ( !NT_SUCCESS( Status)) {
            IF_DEBUG( UAS_DEBUG_UASP ) {
                NetpKdPrint(( "UaspOpenSam: cannot NtSetInformationThread: 0x%lx\n",
                               Status ));
            }
        }

    }

    if ( CurrentToken != NULL ) {
        NtClose( CurrentToken );
    }

    return NetStatus;

}


NET_API_STATUS
UaspGetDomainId(
    IN SAM_HANDLE SamServerHandle,
    OUT PSID *DomainId
    )

/*++

Routine Description:

    Return a domain ID of the account domain of a server.

Arguments:

    SamServerHandle - A handle to the SAM server to open the domain on

    DomainId - Receives a pointer to the domain ID.
        Caller must deallocate buffer using NetpMemoryFree.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    SAM_ENUMERATE_HANDLE EnumContext;
    PSAM_RID_ENUMERATION EnumBuffer = NULL;
    DWORD CountReturned = 0;
    PSID LocalDomainId = NULL;
    DWORD LocalBuiltinDomainSid[sizeof(SID)/sizeof(DWORD) + SID_MAX_SUB_AUTHORITIES ];


    BOOL AllDone = FALSE;
    ULONG i;

    //
    // Compute the builtin domain sid.
    //

    RtlInitializeSid( (PSID) LocalBuiltinDomainSid, &UaspBuiltinAuthority, 1 );
    *(RtlSubAuthoritySid( (PSID)LocalBuiltinDomainSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;


    //
    // Loop getting the list of domain ids from SAM
    //

    EnumContext = 0;
    do {

        //
        // Get several domain names.
        //

        Status = SamEnumerateDomainsInSamServer(
                            SamServerHandle,
                            &EnumContext,
                            &EnumBuffer,
                            8192,        // PrefMaxLen
                            &CountReturned );

        if ( !NT_SUCCESS( Status ) ) {

            IF_DEBUG( UAS_DEBUG_UASP ) {
                NetpKdPrint(( "UaspGetDomainId: Cannot SamEnumerateDomainsInSamServer %lX\n",
                    Status ));
            }
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        if( Status != STATUS_MORE_ENTRIES ) {
            AllDone = TRUE;
        }


        //
        // Lookup the domain ids for the domains
        //

        for( i = 0; i < CountReturned; i++ ) {

            IF_DEBUG( UAS_DEBUG_UASP ) {
                NetpKdPrint(( "UaspGetDomainId: %wZ: domain name\n",
                              &EnumBuffer[i].Name ));
            }

            //
            // Free the sid from the previous iteration.
            //

            if ( LocalDomainId != NULL ) {
                SamFreeMemory( LocalDomainId );
                LocalDomainId = NULL;
            }

            //
            // Lookup the domain id
            //

            Status = SamLookupDomainInSamServer(
                            SamServerHandle,
                            &EnumBuffer[i].Name,
                            &LocalDomainId );

            if ( !NT_SUCCESS( Status ) ) {
                IF_DEBUG( UAS_DEBUG_UASP ) {
                    NetpKdPrint(( "UaspGetDomainId: Cannot SamLookupDomainInSamServer %lX\n",
                        Status ));
                }
                NetStatus = NetpNtStatusToApiStatus( Status );
                goto Cleanup;
            }

            //
            // If this is the builtin domain,
            //  ignore it.
            //

            if ( RtlEqualSid( (PSID)LocalBuiltinDomainSid, LocalDomainId ) ) {
                continue;
            }

            //
            // Found it.
            //

            *DomainId = LocalDomainId;
            LocalDomainId = NULL;
            NetStatus = NO_ERROR;
            goto Cleanup;

        }

        //
        // free up current EnumBuffer and get another EnumBuffer.
        //

        Status = SamFreeMemory( EnumBuffer );
        NetpAssert( NT_SUCCESS(Status) );
        EnumBuffer = NULL;

    } while ( !AllDone );

    NetStatus = ERROR_NO_SUCH_DOMAIN;

    //
    // Cleanup locally used resources
    //
Cleanup:

    if ( EnumBuffer != NULL ) {
        Status = SamFreeMemory( EnumBuffer );
        NetpAssert( NT_SUCCESS(Status) );
    }

    return NetStatus;

} // UaspGetDomainId



NET_API_STATUS
UaspOpenDomain(
    IN SAM_HANDLE SamServerHandle,
    IN ULONG DesiredAccess,
    IN BOOL AccountDomain,
    OUT PSAM_HANDLE DomainHandle,
    OUT PSID *DomainId OPTIONAL
    )

/*++

Routine Description:

    Return a domain handle given the server name and the access desired to the domain.

Arguments:

    SamServerHandle - A handle to the SAM server to open the domain on

    DesiredAccess - Supplies the access mask indicating which access types
        are desired to the domain.  This routine always requests DOMAIN_LOOKUP
        access in addition to those specified.

    AccountDomain - TRUE to open the Account domain.  FALSE to open the
        builtin domain.

    DomainHandle - Receives the Domain handle to be used on future calls
        to the SAM server.

    DomainId - Recieves a pointer to the Sid of the domain.  This domain ID
        must be freed using NetpMemoryFree.

Return Value:

    Error code for the operation.  NULL means initialization was successful.

--*/

{

    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    PSID LocalDomainId;
    PSID AccountDomainId = NULL;
    DWORD LocalBuiltinDomainSid[sizeof(SID)/sizeof(DWORD) + SID_MAX_SUB_AUTHORITIES ];

    //
    // Give everyone DOMAIN_LOOKUP access.
    //

    DesiredAccess |= DOMAIN_LOOKUP;


    //
    // Choose the domain ID for the right SAM domain.
    //

    if ( AccountDomain ) {
        NetStatus = UaspGetDomainId( SamServerHandle, &AccountDomainId );

        if ( NetStatus != NO_ERROR ) {
            goto Cleanup;
        }

        LocalDomainId = AccountDomainId;
    } else {
        RtlInitializeSid( (PSID) LocalBuiltinDomainSid, &UaspBuiltinAuthority, 1 );
        *(RtlSubAuthoritySid( (PSID)LocalBuiltinDomainSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
        LocalDomainId = (PSID) LocalBuiltinDomainSid;
    }

    //
    // Open the domain.
    //

    Status = SamOpenDomain( SamServerHandle,
                            DesiredAccess,
                            LocalDomainId,
                            DomainHandle );

    if ( !NT_SUCCESS( Status ) ) {

        IF_DEBUG( UAS_DEBUG_UASP ) {
            NetpKdPrint(( "UaspOpenDomain: Cannot SamOpenDomain %lX\n",
                Status ));
        }
        *DomainHandle = NULL;
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Return the DomainId to the caller in an allocated buffer
    //

    if (ARGUMENT_PRESENT( DomainId ) ) {

        //
        // If we've already allocated the sid,
        //  just return it.
        //

        if ( AccountDomainId != NULL ) {
            *DomainId = AccountDomainId;
            AccountDomainId = NULL;

        //
        // Otherwise make a copy.
        //

        } else {
            ULONG SidSize;
            SidSize = RtlLengthSid( LocalDomainId );

            *DomainId = NetpMemoryAllocate( SidSize );

            if ( *DomainId == NULL ) {
                (VOID) SamCloseHandle( *DomainHandle );
                *DomainHandle = NULL;
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            if ( !NT_SUCCESS( RtlCopySid( SidSize, *DomainId, LocalDomainId) ) ) {
                (VOID) SamCloseHandle( *DomainHandle );
                *DomainHandle = NULL;
                NetpMemoryFree( *DomainId );
                *DomainId = NULL;
                NetStatus = NERR_InternalError;
                goto Cleanup;
            }
        }

    }

    NetStatus = NERR_Success;


Cleanup:
    if ( AccountDomainId != NULL ) {
        NetpMemoryFree( AccountDomainId );
    }

    return NetStatus;

}


NET_API_STATUS
UaspOpenDomainWithDomainName(
    IN LPCWSTR DomainName,
    IN ULONG DesiredAccess,
    IN BOOL AccountDomain,
    OUT PSAM_HANDLE DomainHandle,
    OUT PSID *DomainId OPTIONAL
    )

/*++

Routine Description:

    Returns the name of a DC in the specified domain.  The Server is guaranteed
    to be up at the instance of this call.

Arguments:

    DoaminName - A pointer to a string containing the name of the remote
        domain containing the SAM database.  A NULL pointer
        or string specifies the local machine.

    DesiredAccess - Supplies the access mask indicating which access types
        are desired to the domain.  This routine always requests DOMAIN_LOOKUP
        access in addition to those specified.

    AccountDomain - TRUE to open the Account domain.  FALSE to open the
        builtin domain.

    DomainHandle - Receives the Domain handle to be used on future calls
        to the SAM server.

    DomainId - Recieves a pointer to the Sid of the domain.  This domain ID
        must be freed using NetpMemoryFree.

Return Value:

    NERR_Success - Operation completed successfully
    NERR_DCNotFound - DC for the specified domain could not be found.
    etc.

--*/

{
    NET_API_STATUS NetStatus;

    NT_PRODUCT_TYPE NtProductType;
    LPWSTR ServerName;
    LPWSTR MyDomainName = NULL;
    ULONG Flags;
    ULONG i;
    PDOMAIN_CONTROLLER_INFOW DcInfo = NULL;
    SAM_HANDLE SamServerHandle = NULL;


    //
    // Check to see if the domain specified refers to this machine.
    //

    if ( DomainName == NULL || *DomainName == L'\0' ) {

        //
        // Connect to the SAM server
        //

        NetStatus = UaspOpenSam( NULL,
                                 FALSE,  // Don't try null session
                                 &SamServerHandle );

        if ( NetStatus != NERR_Success ) {
            IF_DEBUG( UAS_DEBUG_UASP ) {
                NetpKdPrint(( "UaspOpenDomainWithDomainName: Cannot UaspOpenSam %ld\n", NetStatus ));
            }
        }

        goto Cleanup;
    }


    //
    // Validate the DomainName
    //

    if ( !NetpIsDomainNameValid( (LPWSTR)DomainName) ) {
        NetStatus = NERR_DCNotFound;
        IF_DEBUG( UAS_DEBUG_UASP ) {
            NetpKdPrint(( "UaspOpenDomainWithDomainName: %ws: Cannot SamOpenDomain %ld\n",
                DomainName,
                NetStatus ));
        }
        goto Cleanup;
    }



    //
    // Grab the product type once.
    //

    if ( !RtlGetNtProductType( &NtProductType ) ) {
        NtProductType = NtProductWinNt;
    }

    //
    // If this machine is a DC, this machine is refered to by domain name.
    //

    if ( NtProductType == NtProductLanManNt ) {

        NetStatus = NetpGetDomainName( &MyDomainName );

        if ( NetStatus != NERR_Success ) {
            IF_DEBUG( UAS_DEBUG_UASP ) {
                NetpKdPrint(( "UaspOpenDomainWithDomainName: %ws: Cannot NetpGetDomainName %ld\n",
                    DomainName,
                    NetStatus ));
            }
            goto Cleanup;
        }

    //
    // If this machine is not a DC, this machine is refered to by computer name.
    //

    } else {

        NetStatus = NetpGetComputerName( &MyDomainName );

        if ( NetStatus != NERR_Success ) {
            IF_DEBUG( UAS_DEBUG_UASP ) {
                NetpKdPrint(( "UaspOpenDomainWithDomainName: %ws: Cannot NetpGetComputerName %ld\n",
                    DomainName,
                    NetStatus ));
            }
            goto Cleanup;
        }
    }

    if ( UaspNameCompare( MyDomainName, (LPWSTR) DomainName, NAMETYPE_DOMAIN ) == 0 ) {

        //
        // Connect to the SAM server
        //

        NetStatus = UaspOpenSam( NULL,
                                 FALSE,  // Don't try null session
                                 &SamServerHandle );

        if ( NetStatus != NERR_Success ) {
            IF_DEBUG( UAS_DEBUG_UASP ) {
                NetpKdPrint(( "UaspOpenDomainWithDomainName: Cannot UaspOpenSam %ld\n", NetStatus ));
            }
        }

        goto Cleanup;
    }


    //
    // Try at least twice to find a DC.
    //

    Flags = 0;
    for ( i=0; i<2; i++ ) {


        //
        // Get the name of a DC in the domain.
        //

        NetStatus = DsGetDcNameW( NULL,
                                  DomainName,
                                  NULL,  // No domain GUID
                                  NULL,  // No site name
                                  Flags |
                                    DS_IS_FLAT_NAME |
                                    DS_RETURN_FLAT_NAME,
                                  &DcInfo );

        if ( NetStatus != NO_ERROR ) {

            IF_DEBUG( UAS_DEBUG_UASP ) {
                NetpKdPrint(( "UaspOpenDomainWithDomainName: %ws: Cannot DsGetDcName %ld\n",
                    DomainName,
                    NetStatus ));
            }

            goto Cleanup;
        }

        //
        // Connect to the SAM server on that DC
        //

        NetStatus = UaspOpenSam( DcInfo->DomainControllerName,
                                 TRUE,  // Try null session
                                 &SamServerHandle );

        if ( NetStatus != NERR_Success ) {
            IF_DEBUG( UAS_DEBUG_UASP ) {
                NetpKdPrint(( "UaspOpenDomainWithDomainName: Cannot UaspOpenSam %ld\n", NetStatus ));
            }
        }

        //
        // If we got a definitive answer back from this DC,
        //  use it.
        //

        switch ( NetStatus ) {
        case NO_ERROR:
        case ERROR_ACCESS_DENIED:
        case ERROR_NOT_ENOUGH_MEMORY:
        case NERR_InvalidComputer:
            goto Cleanup;
        }

        //
        // Otherwise, force rediscovery of a new DC.
        //

        Flags |= DS_FORCE_REDISCOVERY;

    }



    //
    // Delete locally used resources
    //

Cleanup:

    //
    // If we've successfully gotten this far,
    //  we have a SamServer handle.
    //
    //  Just open the domain.
    //

    if ( NetStatus == NO_ERROR && SamServerHandle != NULL ) {

        NetStatus = UaspOpenDomain(
                        SamServerHandle,
                        DesiredAccess,
                        AccountDomain,
                        DomainHandle,
                        DomainId );
    }

    //
    // The SamServerHandle has outlived its usefulness
    //
    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }


    if ( MyDomainName != NULL ) {
        NetApiBufferFree( MyDomainName );
    }
    if ( DcInfo != NULL) {
        NetApiBufferFree( DcInfo );
    }

    if ( NetStatus != NERR_Success ) {
        *DomainHandle = NULL;
    }

    return NetStatus;
} // UaspOpenDomainWithDomainName




VOID
UaspCloseDomain(
    IN SAM_HANDLE DomainHandle OPTIONAL
    )

/*++

Routine Description:

    Close a Domain handle opened by UaspOpenDomain.

Arguments:

    DomainHandle - Supplies the Domain Handle to close.

Return Value:

    None.

--*/

{

    //
    // Close the Domain Handle
    //

    if ( DomainHandle != NULL ) {
        (VOID) SamCloseHandle( DomainHandle );
    }

    return;
} // UaspCloseDomain



NET_API_STATUS
UaspDownlevel(
    IN LPCWSTR ServerName OPTIONAL,
    IN NET_API_STATUS OriginalError,
    OUT LPBOOL TryDownLevel
    )
/*++

Routine Description:

    This routine is based on NetpHandleRpcFailure (courtesy of JohnRo).
    It is different in that it doesn't handle RPC failures.  Rather,
    it tries to determine if a Sam call should go downlevel simply by
    calling using the specified ServerName.

Arguments:

    ServerName - The server name to handle the call.

    OriginalError - Error gotten from RPC attempt.

    TryDownLevel - Returns TRUE if we should try down-level.

Return Value:

    NERR_Success - Use SAM to handle the call.

    Other - Return the error to the caller.

--*/

{
    NET_API_STATUS NetStatus;
    DWORD OptionsSupported = 0;


    *TryDownLevel = FALSE;

    //
    // Learn about the machine.  This is fairly easy since the
    // NetRemoteComputerSupports also handles the local machine (whether
    // or not a server name is given).
    //
    NetStatus = NetRemoteComputerSupports(
            (LPWSTR) ServerName,
            SUPPORTS_RPC | SUPPORTS_LOCAL | SUPPORTS_SAM_PROTOCOL,
            &OptionsSupported);

    if (NetStatus != NERR_Success) {
        // This is where machine not found gets handled.
        return NetStatus;
    }

    //
    // If the machine supports SAM,
    //  just return now.
    //
    if (OptionsSupported & SUPPORTS_SAM_PROTOCOL) {
        // SAM is only supported over RPC
        NetpAssert((OptionsSupported & SUPPORTS_RPC) == SUPPORTS_RPC );
        return OriginalError;
    }

    // The local system should always support SAM
    NetpAssert((OptionsSupported & SUPPORTS_LOCAL) == 0 );

    //
    // Local workstation is not started?  (It must be in order to
    // remote APIs to the other system.)
    //

    if ( ! NetpIsServiceStarted(SERVICE_WORKSTATION) ) {
        return (NERR_WkstaNotStarted);
    }

    //
    // Tell the caller to try the RxNet routine.
    //
    *TryDownLevel = TRUE;
    return OriginalError;

} // UaspDownlevel



NET_API_STATUS
UaspLSASetServerRole(
    IN LPCWSTR ServerName,
    IN PDOMAIN_SERVER_ROLE_INFORMATION DomainServerRole
    )

/*++

Routine Description:

    This function sets the server role in LSA.

Arguments:

    ServerName - The server name to handle the call.

    ServerRole - The server role information.

Return Value:

    NERR_Success - if the server role is successfully set in LSA.

    Error code for the operation - if the operation was unsuccessful.

--*/

{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    UNICODE_STRING UnicodeStringServerName;

    ACCESS_MASK LSADesiredAccess;
    LSA_HANDLE  LSAPolicyHandle = NULL;
    OBJECT_ATTRIBUTES LSAObjectAttributes;

    POLICY_LSA_SERVER_ROLE_INFO PolicyLsaServerRoleInfo;


    RtlInitUnicodeString( &UnicodeStringServerName, ServerName );

    //
    // set desired access mask.
    //

    LSADesiredAccess = POLICY_SERVER_ADMIN;

    InitializeObjectAttributes( &LSAObjectAttributes,
                                  NULL,             // Name
                                  0,                // Attributes
                                  NULL,             // Root
                                  NULL );           // Security Descriptor

    Status = LsaOpenPolicy( &UnicodeStringServerName,
                            &LSAObjectAttributes,
                            LSADesiredAccess,
                            &LSAPolicyHandle );

    if( !NT_SUCCESS(Status) ) {

        IF_DEBUG( UAS_DEBUG_UASP ) {
            NetpKdPrint(( "UaspLSASetServerRole: "
                          "Cannot open LSA Policy %lX\n", Status ));
        }

        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }


    //
    // make PolicyLsaServerRoleInfo
    //

    switch( DomainServerRole->DomainServerRole ) {

        case DomainServerRoleBackup :

            PolicyLsaServerRoleInfo.LsaServerRole = PolicyServerRoleBackup;

            break;

        case DomainServerRolePrimary :

            PolicyLsaServerRoleInfo.LsaServerRole = PolicyServerRolePrimary;

            break;

        default:

            IF_DEBUG( UAS_DEBUG_UASP ) {
                NetpKdPrint(( "UaspLSASetServerRole: "
                              "Unknown Server Role %lX\n",
                                DomainServerRole->DomainServerRole ));
            }

            NetStatus = NERR_InternalError;
            goto Cleanup;

    }

    //
    // now set PolicyLsaServerRoleInformation
    //

    Status = LsaSetInformationPolicy(
                    LSAPolicyHandle,
                    PolicyLsaServerRoleInformation,
                    (PVOID) &PolicyLsaServerRoleInfo );

    if( !NT_SUCCESS(Status) ) {

        IF_DEBUG( UAS_DEBUG_UASP ) {
            NetpKdPrint(( "UaspLSASetServerRole: "
                          "Cannot set Information Policy %lX\n", Status ));
        }

        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;

    }

    //
    // Successfully done
    //

    NetStatus = NERR_Success;

Cleanup:

    if( LSAPolicyHandle != NULL ) {
        Status = LsaClose( LSAPolicyHandle );
        NetpAssert( NT_SUCCESS( Status ) );
    }

    return NetStatus;

}


NET_API_STATUS
UaspBuiltinDomainSetServerRole(
    IN SAM_HANDLE SamServerHandle,
    IN PDOMAIN_SERVER_ROLE_INFORMATION DomainServerRole
    )

/*++

Routine Description:

    This function sets the server role in builtin domain.

Arguments:

    SamServerHandle - A handle to the SAM server to set the role on

    ServerRole - The server role information.

Return Value:

    NERR_Success - if the server role is successfully set in LSA.

    Error code for the operation - if the operation was unsuccessful.

--*/

{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    SAM_HANDLE BuiltinDomainHandle = NULL;

    //
    // Open the domain asking for accumulated desired access
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_ADMINISTER_SERVER,
                                FALSE,  // Builtin Domain
                                &BuiltinDomainHandle,
                                NULL );  // DomainId

    if ( NetStatus != NERR_Success ) {

        IF_DEBUG( UAS_DEBUG_UASP ) {
            NetpKdPrint(( "UaspBuiltinSetServerRole: "
                            "Cannot UaspOpenDomain [Builtin] %ld\n",
                            NetStatus ));
        }
        goto Cleanup;
    }

    //
    // now we have open the builtin domain, update server role.
    //

    Status = SamSetInformationDomain(
                BuiltinDomainHandle,
                DomainServerRoleInformation,
                DomainServerRole );

    if ( !NT_SUCCESS( Status ) ) {

        IF_DEBUG( UAS_DEBUG_UASP ) {
            NetpKdPrint(( "UaspBuiltinSetServerRole: "
                            "Cannot SamSetInformationDomain %lX\n",
                            Status ));
        }

        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    NetStatus = NERR_Success;

Cleanup:

    //
    // Close DomainHandle.
    //

    if ( BuiltinDomainHandle != NULL ) {
        (VOID) SamCloseHandle( BuiltinDomainHandle );
    }

    return NetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\uastest.h ===
///**************************************************************
///          Microsoft LAN Manager          *
///        Copyright(c) Microsoft Corp., 1990       *
///**************************************************************

//
//  For use in UASTEST*.C
//

// #define printf NetpDbgPrint
#define exit ExitProcess


#define USER1       L"User1"
#define USER2       L"User2"
#define NOTTHERE    L"NotThere"

#define USER        L"USERS"
#define GUEST       L"GUESTS"
#define ADMIN       L"ADMINS"

#define TEXIT       if(exit_flag)exit(1);

#define ENUM_FILTER FILTER_NORMAL_ACCOUNT

//
// uastestm.c will #include this file with LSRVDATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef UASTEST_ALLOCATE
#define EXTERN
#define INIT( _x ) = _x
#else
#define EXTERN extern
#define INIT(_x)
#endif

EXTERN LPWSTR server INIT( NULL );
EXTERN DWORD  err INIT( 0 );
EXTERN DWORD  ParmError INIT( 0 );
EXTERN DWORD  exit_flag  INIT( 0 );
EXTERN DWORD  totavail;
EXTERN DWORD  total;
EXTERN DWORD  nread;

//
// Interface to error_exit
//
#define ACTION 0
#define PASS 1
#define FAIL 2

EXTERN PCHAR testname;

void
error_exit(
    int type,
    char    *msgp,
    LPWSTR namep
    );

void PrintUnicode(
    LPWSTR string
    );

void TestDiffDword(
    char *msgp,
    LPWSTR namep,
    DWORD Actual,
    DWORD Good
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\group.c ===
/*++
Copyright (c) 1991  Microsoft Corporation

Module Name:

    group.c

Abstract:

    NetGroup API functions

Author:

    Cliff Van Dyke (cliffv) 05-Mar-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    17-Apr-1991 (cliffv)
        Incorporated review comments.

    17-Jan-1992 (madana)
        Added support to change group account name.

    20-Jan-1992 (madana)
        Sundry API changes
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef DOMAIN_ALL_ACCESS // defined in both ntsam.h and ntwinapi.h
#include <ntsam.h>
#include <ntlsa.h>

#include <windef.h>
#include <winbase.h>
#include <lmcons.h>

#include <access.h>
#include <align.h>
#include <icanon.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <netdebug.h>
#include <netlib.h>
#include <netlibnt.h>
#include <rpcutil.h>
#include <rxgroup.h>
#include <stddef.h>
#include <uasp.h>
#include <stdlib.h>

/*lint -e614 */  /* Auto aggregate initializers need not be constant */

// Lint complains about casts of one structure type to another.
// That is done frequently in the code below.
/*lint -e740 */  /* don't complain about unusual cast */ \




NET_API_STATUS NET_API_FUNCTION
NetGroupAdd(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD Level,
    IN LPBYTE Buffer,
    OUT LPDWORD ParmError OPTIONAL // Name required by NetpSetParmError
    )

/*++

Routine Description:

    Create a group account in the user accounts database.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    Level - Level of information provided.  Must be 0, 1 or 2.

    Buffer - A pointer to the buffer containing the group information
        structure.

    ParmError - Optional pointer to a DWORD to return the index of the
        first parameter in error when ERROR_INVALID_PARAMETER is returned.
        If NULL, the parameter is not returned on error.

Return Value:

    Error code for the operation.

--*/

{
    LPWSTR GroupName;
    UNICODE_STRING GroupNameString;
    LPWSTR GroupComment;
    DWORD GroupAttributes;
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAM_HANDLE GroupHandle;
    ULONG RelativeId;


    //
    // Initialize
    //

    NetpSetParmError( PARM_ERROR_NONE );

    //
    // Validate Level parameter and fields of structures.
    //

    switch (Level) {
    case 0:
        GroupName = ((PGROUP_INFO_0)Buffer)->grpi0_name;
        GroupComment = NULL;
        break;

    case 1:
        GroupName = ((PGROUP_INFO_1)Buffer)->grpi1_name;
        GroupComment = ((PGROUP_INFO_1)Buffer)->grpi1_comment;
        break;

    case 2:
        GroupName = ((PGROUP_INFO_2)Buffer)->grpi2_name;
        GroupComment = ((PGROUP_INFO_2)Buffer)->grpi2_comment;
        GroupAttributes = ((PGROUP_INFO_2)Buffer)->grpi2_attributes;
        break;

    case 3:
        GroupName = ((PGROUP_INFO_3)Buffer)->grpi3_name;
        GroupComment = ((PGROUP_INFO_3)Buffer)->grpi3_comment;
        GroupAttributes = ((PGROUP_INFO_3)Buffer)->grpi3_attributes;
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    //
    // Don't allow creation of the group names that will confuse LM 2.x BDCs.
    //

    if ( UaspNameCompare( GroupName, L"users", NAMETYPE_GROUP ) == 0 ||
         UaspNameCompare( GroupName, L"guests", NAMETYPE_GROUP ) == 0 ||
         UaspNameCompare( GroupName, L"admins", NAMETYPE_GROUP ) == 0 ||
         UaspNameCompare( GroupName, L"local", NAMETYPE_GROUP ) == 0 ) {

        NetStatus = NERR_SpeGroupOp;
        goto Cleanup;
    }

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint(( "NetGroupAdd: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the Domain asking for DOMAIN_CREATE_GROUP access.
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_CREATE_GROUP | DOMAIN_LOOKUP,
                                TRUE,   // Account Domain
                                &DomainHandle,
                                NULL);  // DomainId

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint(( "NetGroupAdd: Cannot UaspOpenDomain %ld\n", NetStatus ));
        }
        goto Cleanup;
    }


    //
    // Create the Group with the specified group name
    // (and a default security descriptor).
    //

    RtlInitUnicodeString( &GroupNameString, GroupName );

    Status = SamCreateGroupInDomain( DomainHandle,
                                     &GroupNameString,
                                     DELETE | GROUP_WRITE_ACCOUNT,
                                     &GroupHandle,
                                     &RelativeId );


    if ( !NT_SUCCESS(Status) ) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }




    //
    // Set the Admin Comment on the group.
    //

    if ( (Level == 1)  || (Level == 2) || (Level == 3) ) {

        GROUP_ADM_COMMENT_INFORMATION AdminComment;

        RtlInitUnicodeString( &AdminComment.AdminComment, GroupComment );

        Status = SamSetInformationGroup( GroupHandle,
                                         GroupAdminCommentInformation,
                                         &AdminComment );

        if ( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );

            Status = SamDeleteGroup( GroupHandle );
            NetpAssert( NT_SUCCESS(Status) );

            goto Cleanup;
        }

    }

    // Set the attributes on the group.
    //

    if ( (Level == 2) || (Level == 3) ) {

        GROUP_ATTRIBUTE_INFORMATION  GroupAttributeInfo;

        GroupAttributeInfo.Attributes = GroupAttributes;

        Status = SamSetInformationGroup( GroupHandle,
                                         GroupAttributeInformation,
                                         &GroupAttributeInfo );

        if ( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );

            Status = SamDeleteGroup( GroupHandle );
            NetpAssert( NT_SUCCESS(Status) );

            goto Cleanup;
        }

    }

    //
    // Close the created group.
    //

    (VOID) SamCloseHandle( GroupHandle );

    NetStatus = NERR_Success;

    //
    // Clean up
    //

Cleanup:
    if ( DomainHandle != NULL ) {
        UaspCloseDomain( DomainHandle );
    }
    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetGroupAdd( (LPWSTR) ServerName, Level, Buffer, ParmError );

    UASP_DOWNLEVEL_END;


    IF_DEBUG( UAS_DEBUG_GROUP ) {
        NetpKdPrint(( "NetGroupAdd: returns %ld\n", NetStatus ));
    }
    return NetStatus;

} // NetGroupAdd


NET_API_STATUS NET_API_FUNCTION
NetGroupAddUser(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR GroupName,
    IN LPCWSTR UserName
    )

/*++

Routine Description:

    Give an existing user account membership in an existing group.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    GroupName - Name of the group to which the user is to be given membership.

    UserName - Name of the user to be given group membership.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;

    //
    // Call the routine shared by NetGroupAddUser and NetGroupDelUser
    //

    NetStatus = GrouppChangeMember( ServerName, GroupName, UserName, TRUE);

    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetGroupAddUser( (LPWSTR) ServerName, (LPWSTR) GroupName, (LPWSTR) UserName );

    UASP_DOWNLEVEL_END( NetStatus );


    IF_DEBUG( UAS_DEBUG_GROUP ) {
        NetpKdPrint(( "NetGroupAddUser: returns %ld\n", NetStatus ));
    }
    return NetStatus;

} // NetGroupAddUser


NET_API_STATUS NET_API_FUNCTION
NetGroupDel(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR GroupName
    )

/*++

Routine Description:

    Delete a Group

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    GroupName - Name of the group to delete.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;

    //
    // Call a common routine to delete all of the memberships in this group
    // and then delete the group itself.
    //

    NetStatus = GrouppSetUsers( ServerName,
                                GroupName,
                                0,              // Level
                                NULL,           // No new members
                                0,              // Number of members desired
                                TRUE );         // Delete the group when done

    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetGroupDel( (LPWSTR) ServerName, (LPWSTR) GroupName );

    UASP_DOWNLEVEL_END;

    IF_DEBUG( UAS_DEBUG_GROUP ) {
        NetpKdPrint(( "NetGroupDel: returns %ld\n", NetStatus ));
    }
    return NetStatus;

} // NetGroupDel


NET_API_STATUS NET_API_FUNCTION
NetGroupDelUser(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR GroupName,
    IN LPCWSTR UserName
    )

/*++

Routine Description:

    Remove a user from a particular group.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    GroupName - Name of the group from which the user is to be removed.

    UserName - Name of the user to be removed from the group.

Return Value:

    Error code for the operation.

--*/

{

    NET_API_STATUS NetStatus;

    //
    // Call the routine shared by NetGroupAddUser and NetGroupDelUser
    //

    NetStatus = GrouppChangeMember( ServerName, GroupName, UserName, FALSE );

    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetGroupDelUser( (LPWSTR) ServerName, (LPWSTR) GroupName, (LPWSTR) UserName );

    UASP_DOWNLEVEL_END;

    return NetStatus;

} // NetGroupDelUser


NET_API_STATUS NET_API_FUNCTION
NetGroupEnum(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE *Buffer,
    IN DWORD PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT PDWORD_PTR ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    Retrieve information about each group on a server.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    Level - Level of information required. 0, 1 and 2 are valid.

    Buffer - Returns a pointer to the return information structure.
        Caller must deallocate buffer using NetApiBufferFree.

    PrefMaxLen - Prefered maximum length of returned data.

    EntriesRead - Returns the actual enumerated element count.

    EntriesLeft - Returns the total entries available to be enumerated.

    ResumeHandle -  Used to continue an existing search.  The handle should
        be zero on the first call and left unchanged for subsequent calls.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    PDOMAIN_DISPLAY_GROUP SamQDIEnum;   // Sam returned buffer
    PSAM_RID_ENUMERATION SamEnum;
    PGROUP_INFO_0 grpi0;
    PGROUP_INFO_0 grpi0_temp = NULL;
    SAM_HANDLE SamServerHandle = NULL;

    BUFFER_DESCRIPTOR BufferDescriptor;
    PDOMAIN_GENERAL_INFORMATION DomainGeneral;

    DWORD Mode = SAM_SID_COMPATIBILITY_ALL;

    //
    // Declare Opaque group enumeration handle.
    //

    struct _UAS_ENUM_HANDLE {
        SAM_HANDLE  DomainHandle;

        ULONG SamEnumHandle;                    // Current Sam Enum Handle
        PDOMAIN_DISPLAY_GROUP SamQDIEnum;          // Sam returned buffer
        PSAM_RID_ENUMERATION SamEnum;
        ULONG Index;                            // Index to current entry
        ULONG Count;                            // Total Number of entries
        ULONG TotalRemaining;

        BOOL SamAllDone;                        // True, if Sam has completed
        BOOL fUseSamQDI;

    } *UasEnumHandle = NULL;

    //
    // If this is a resume, get the resume handle that the caller passed in.
    //

    BufferDescriptor.Buffer = NULL;
    *EntriesRead = 0;
    *EntriesLeft = 0;
    *Buffer = NULL;


    if ( ARGUMENT_PRESENT( ResumeHandle ) && *ResumeHandle != 0 ) {
/*lint -e511 */  /* Size incompatibility */
        UasEnumHandle = (struct _UAS_ENUM_HANDLE *) *ResumeHandle;
/*lint +e511 */  /* Size incompatibility */

    //
    // If this is not a resume, allocate and initialize a resume handle.
    //

    } else {

        //
        // Allocate a resume handle.
        //

        UasEnumHandle = NetpMemoryAllocate( sizeof(struct _UAS_ENUM_HANDLE) );

        if ( UasEnumHandle == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Initialize all the fields in the newly allocated resume handle
        //  to indicate that SAM has never yet been called.
        //

        UasEnumHandle->DomainHandle = NULL;
        UasEnumHandle->SamEnumHandle = 0;
        UasEnumHandle->SamQDIEnum = NULL;
        UasEnumHandle->SamEnum = NULL;
        UasEnumHandle->Index = 0;
        UasEnumHandle->Count = 0;
        UasEnumHandle->TotalRemaining = 0;
        UasEnumHandle->SamAllDone = FALSE;
        UasEnumHandle->fUseSamQDI = TRUE;

        //
        // Connect to the SAM server
        //

        NetStatus = UaspOpenSam( ServerName,
                                 FALSE,  // Don't try null session
                                 &SamServerHandle );

        if ( NetStatus != NERR_Success ) {
            IF_DEBUG( UAS_DEBUG_GROUP ) {
                NetpKdPrint(( "NetGroupEnum: Cannot UaspOpenSam %ld\n", NetStatus ));
            }
            goto Cleanup;
        }

        //
        // Open the Domain.
        //

        NetStatus = UaspOpenDomain( SamServerHandle,
                                    DOMAIN_LOOKUP |
                                        DOMAIN_LIST_ACCOUNTS |
                                        DOMAIN_READ_OTHER_PARAMETERS,
                                    TRUE,   // Account Domain
                                    &UasEnumHandle->DomainHandle,
                                    NULL );

        if ( NetStatus != NERR_Success ) {
            goto Cleanup;
        }

        //
        // Get the total number of groups from SAM
        //

        Status = SamQueryInformationDomain( UasEnumHandle->DomainHandle,
                                            DomainGeneralInformation,
                                            (PVOID *)&DomainGeneral );

        if ( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        UasEnumHandle->TotalRemaining = DomainGeneral->GroupCount;
        Status = SamFreeMemory( DomainGeneral );
        NetpAssert( NT_SUCCESS(Status) );

    }

    Status = SamGetCompatibilityMode(UasEnumHandle->DomainHandle,
                                     &Mode);
    if (NT_SUCCESS(Status)) {
        if ( (Mode == SAM_SID_COMPATIBILITY_STRICT)
          && ( Level == 2 ) ) {
              //
              // This info level returns a RID
              //
              Status = STATUS_NOT_SUPPORTED;
          }
    }
    if (!NT_SUCCESS(Status)) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }


    //
    // Loop for each group
    //
    // Each iteration of the loop below puts one more entry into the array
    // returned to the caller.  The algorithm is split into 3 parts.  The
    // first part checks to see if we need to retrieve more information from
    // SAM.  We then get the description of several group from SAM in a single
    // call.  The second part sees if there is room for this entry in the
    // buffer we'll return to the caller.  If not, a larger buffer is allocated
    // for return to the caller.  The third part puts the entry in the
    // buffer.
    //

    for ( ;; ) {
        DWORD FixedSize;
        DWORD Size;
        ULONG TotalAvail;
        ULONG TotalReturned;

        //
        // Get more group information from SAM
        //
        // Handle when we've already consumed all of the information
        // returned on a previous call to SAM.  This is a 'while' rather
        // than an if to handle the case where SAM returns zero entries.
        //

        while ( UasEnumHandle->Index >= UasEnumHandle->Count ) {

            //
            // If we've already gotten everything from SAM,
            //      return all done status to our caller.
            //

            if ( UasEnumHandle->SamAllDone ) {
                NetStatus = NERR_Success;
                goto Cleanup;
            }

            //
            // Free any previous buffer returned from SAM.
            //

            if ( UasEnumHandle->SamQDIEnum != NULL ) {
                Status = SamFreeMemory( UasEnumHandle->SamQDIEnum );
                NetpAssert( NT_SUCCESS(Status) );

                UasEnumHandle->SamQDIEnum = NULL;
            }

            //
            // Do the actual enumeration
            //

            if ( UasEnumHandle->fUseSamQDI )
            {
                Status = SamQueryDisplayInformation(
                            UasEnumHandle->DomainHandle,
                            DomainDisplayGroup,
                            UasEnumHandle->SamEnumHandle,
                            0xffffffff, //query as many as PrefMaxLen can handle
                            PrefMaxLen,
                            &TotalAvail,
                            &TotalReturned,
                            &UasEnumHandle->Count,
                            (PVOID *)&UasEnumHandle->SamQDIEnum );

                if ( !NT_SUCCESS( Status ) ) {
                    if ( Status == STATUS_INVALID_INFO_CLASS ) {
                        UasEnumHandle->fUseSamQDI = FALSE;
                    } else {
                        NetStatus = NetpNtStatusToApiStatus( Status );
                        goto Cleanup;
                    }
                }

                UasEnumHandle->SamEnumHandle += UasEnumHandle->Count;

            }

            if ( !UasEnumHandle->fUseSamQDI ) {
                Status = SamEnumerateGroupsInDomain(
                            UasEnumHandle->DomainHandle,
                            &UasEnumHandle->SamEnumHandle,
                            (PVOID *)&UasEnumHandle->SamEnum,
                            PrefMaxLen,
                            &UasEnumHandle->Count );

                if ( !NT_SUCCESS( Status ) ) {
                    NetStatus = NetpNtStatusToApiStatus( Status );
                    goto Cleanup;
                }
            }

            //
            // Adjust TotalRemaining as we get better information
            //

            if (UasEnumHandle->TotalRemaining < UasEnumHandle->Count) {
                UasEnumHandle->TotalRemaining = UasEnumHandle->Count;
            }

            //
            // If SAM says there is more information, just ensure he returned
            // something to us on this call.
            //

            if ( Status == STATUS_MORE_ENTRIES ) {
                if ( UasEnumHandle->Count == 0 ) {
                    NetStatus = NERR_BufTooSmall;
                    goto Cleanup;
                }

            //
            // If SAM says he's returned all of the information,
            //  remember not to ask SAM for more.
            //

            } else {
                UasEnumHandle->SamAllDone = TRUE;
            }

            UasEnumHandle->Index = 0;
        }

        //
        // ASSERT:  UasEnumHandle identifies the next entry to return
        //          from SAM.
        //

        if ( UasEnumHandle->fUseSamQDI ) {
            SamQDIEnum = &UasEnumHandle->SamQDIEnum[UasEnumHandle->Index];
        } else {
            SamEnum = &UasEnumHandle->SamEnum[UasEnumHandle->Index];
        }


        //
        // Place this entry into the return buffer.
        //
        // Determine the size of the data passed back to the caller
        //

        switch (Level) {
        case 0:
            FixedSize = sizeof(GROUP_INFO_0);
            Size = sizeof(GROUP_INFO_0) +
                (UasEnumHandle->fUseSamQDI ? SamQDIEnum->Group.Length : SamEnum->Name.Length) +
                sizeof(WCHAR);
            break;

        case 1:


            FixedSize = sizeof(GROUP_INFO_1);

            if ( UasEnumHandle->fUseSamQDI ) {
                Size = sizeof(GROUP_INFO_1) +
                   SamQDIEnum->Group.Length + sizeof(WCHAR) +
                   SamQDIEnum->Comment.Length + sizeof(WCHAR);
            } else {
                NetStatus = GrouppGetInfo( UasEnumHandle->DomainHandle,
                                           SamEnum->RelativeId,
                                           Level,
                                           (PVOID *)&grpi0_temp);

                if ( NetStatus != NERR_Success ) {
                    goto Cleanup;
                }

                Size = sizeof(GROUP_INFO_1) +
                        SamEnum->Name.Length + sizeof(WCHAR) +
                        (wcslen(((PGROUP_INFO_1)grpi0_temp)->grpi1_comment) +
                            1) * sizeof(WCHAR);

            }


            break;

        case 2:

            FixedSize = sizeof(GROUP_INFO_2);

            if ( UasEnumHandle->fUseSamQDI ) {
                Size = sizeof(GROUP_INFO_2) +
                        SamQDIEnum->Group.Length + sizeof(WCHAR) +
                        SamQDIEnum->Comment.Length + sizeof(WCHAR);
            } else {
                NetStatus = GrouppGetInfo( UasEnumHandle->DomainHandle,
                                           SamEnum->RelativeId,
                                           Level,
                                           (PVOID *)&grpi0_temp);

                if ( NetStatus != NERR_Success ) {
                    goto Cleanup;
                }

                Size = sizeof(GROUP_INFO_2) +
                        SamEnum->Name.Length + sizeof(WCHAR) +
                        (wcslen(((PGROUP_INFO_2)grpi0_temp)->grpi2_comment) +
                            1) * sizeof(WCHAR);
            }
            break;

        default:
            NetStatus = ERROR_INVALID_LEVEL;
            goto Cleanup;
        }

        //
        // Ensure there is buffer space for this information.
        //

        Size = ROUND_UP_COUNT( Size, ALIGN_WCHAR );

        NetStatus = NetpAllocateEnumBuffer(
                        &BufferDescriptor,
                        FALSE,      // Not a 'get' operation
                        PrefMaxLen,
                        Size,
                        GrouppRelocationRoutine,
                        Level );

        if (NetStatus != NERR_Success) {
            goto Cleanup;
        }

        //
        // Fill in the information.  The array of fixed entries is
        // placed at the beginning of the allocated buffer.  The strings
        // pointed to by these fixed entries are allocated starting at
        // the end of the allocate buffer.
        //

        //
        // Copy the common group name
        //

        NetpAssert( offsetof( GROUP_INFO_0, grpi0_name ) ==
                    offsetof( GROUP_INFO_1, grpi1_name ) );

        NetpAssert( offsetof( GROUP_INFO_1, grpi1_name ) ==
                    offsetof( GROUP_INFO_2, grpi2_name ) );

        NetpAssert( offsetof( GROUP_INFO_1, grpi1_comment ) ==
                    offsetof( GROUP_INFO_2, grpi2_comment ) );

        grpi0 = (PGROUP_INFO_0)(BufferDescriptor.FixedDataEnd);
        BufferDescriptor.FixedDataEnd += FixedSize;

        //
        // Fill in the Level dependent fields
        //

        switch ( Level ) {
        case 2:
            if (Mode == SAM_SID_COMPATIBILITY_ALL) {
                ((PGROUP_INFO_2)grpi0)->grpi2_group_id =
                                UasEnumHandle->fUseSamQDI
                                    ? SamQDIEnum->Rid
                                    : ((PGROUP_INFO_2)grpi0_temp)->grpi2_group_id;
            } else {
                ((PGROUP_INFO_2)grpi0)->grpi2_group_id = 0;
            }

            ((PGROUP_INFO_2)grpi0)->grpi2_attributes =
                            UasEnumHandle->fUseSamQDI
                                ? SamQDIEnum->Attributes
                                : ((PGROUP_INFO_2)grpi0_temp)->grpi2_attributes;

            /* FALL THROUGH FOR THE OTHER FIELDS */

        case 1:
            if ( !NetpCopyStringToBuffer(
                        UasEnumHandle->fUseSamQDI
                            ? SamQDIEnum->Comment.Buffer
                            : ((PGROUP_INFO_1)grpi0_temp)->grpi1_comment,
                        UasEnumHandle->fUseSamQDI
                            ? SamQDIEnum->Comment.Length/sizeof(WCHAR)
                            : wcslen(((PGROUP_INFO_1)grpi0_temp)->grpi1_comment),
                        BufferDescriptor.FixedDataEnd,
                        (LPWSTR *)&BufferDescriptor.EndOfVariableData,
                        &((PGROUP_INFO_1)grpi0)->grpi1_comment) ) {

                NetStatus = NERR_InternalError;
                goto Cleanup;
            }

            if ( !UasEnumHandle->fUseSamQDI ) {
                MIDL_user_free( grpi0_temp );
                grpi0_temp = NULL;
            }

            /* FALL THROUGH FOR THE NAME FIELD */

        case 0:

            if ( !NetpCopyStringToBuffer(
                            UasEnumHandle->fUseSamQDI
                                ? SamQDIEnum->Group.Buffer
                                : SamEnum->Name.Buffer,
                            UasEnumHandle->fUseSamQDI
                                ? SamQDIEnum->Group.Length/sizeof(WCHAR)
                                : SamEnum->Name.Length/sizeof(WCHAR),
                            BufferDescriptor.FixedDataEnd,
                            (LPWSTR *)&BufferDescriptor.EndOfVariableData,
                            &(grpi0->grpi0_name))){

                NetStatus = NERR_InternalError;
                goto Cleanup;
            }

            break;


        default:
            NetStatus = ERROR_INVALID_LEVEL;
            goto Cleanup;

        }

        //
        // ASSERT: The current entry has been completely copied to the
        //  return buffer.
        //

        (*EntriesRead)++;

        UasEnumHandle->Index ++;
        UasEnumHandle->TotalRemaining --;
    }

    //
    // Clean up.
    //

Cleanup:

    //
    // Free any locally used resources.
    //

    if ( grpi0_temp != NULL ) {
        MIDL_user_free( grpi0_temp );
    }

    //
    // Set EntriesLeft to the number left to return plus those that
    //  we returned on this call.
    //

    if ( UasEnumHandle != NULL ) {
        *EntriesLeft = UasEnumHandle->TotalRemaining + *EntriesRead;
    }

    //
    // If we're done or the caller doesn't want an enumeration handle,
    //  free the enumeration handle.
    //

    if ( NetStatus != ERROR_MORE_DATA || !ARGUMENT_PRESENT( ResumeHandle ) ) {

        if ( UasEnumHandle != NULL ) {
            if ( UasEnumHandle->DomainHandle != NULL ) {
                UaspCloseDomain( UasEnumHandle->DomainHandle );
            }

            if ( UasEnumHandle->SamQDIEnum != NULL ) {
                Status = SamFreeMemory( UasEnumHandle->SamQDIEnum );
                NetpAssert( NT_SUCCESS(Status) );
            }

            if ( UasEnumHandle->SamEnum != NULL ) {
                Status = SamFreeMemory( UasEnumHandle->SamEnum );
                NetpAssert( NT_SUCCESS(Status) );
            }

            NetpMemoryFree( UasEnumHandle );
            UasEnumHandle = NULL;
        }

    }

    //
    // If we're not returning data to the caller,
    //  free the return buffer.
    //

    if ( NetStatus != NERR_Success && NetStatus != ERROR_MORE_DATA ) {
        if ( BufferDescriptor.Buffer != NULL ) {
            MIDL_user_free( BufferDescriptor.Buffer );
            BufferDescriptor.Buffer = NULL;
        }
        *EntriesRead = 0;
        *EntriesLeft = 0;
    }

    //
    // Set the output parameters
    //

    *Buffer = BufferDescriptor.Buffer;
    if ( ARGUMENT_PRESENT( ResumeHandle ) ) {
        *ResumeHandle = (DWORD_PTR) UasEnumHandle;
    }

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }


    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetGroupEnum( (LPWSTR) ServerName,
                                    Level,
                                    Buffer,
                                    PrefMaxLen,
                                    EntriesRead,
                                    EntriesLeft,
                                    ResumeHandle );

    UASP_DOWNLEVEL_END;


    IF_DEBUG( UAS_DEBUG_GROUP ) {
        NetpKdPrint(( "NetGroupEnum: returns %ld\n", NetStatus ));
    }

    return NetStatus;

} // NetGroupEnum


NET_API_STATUS NET_API_FUNCTION
NetGroupGetInfo(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR GroupName,
    IN DWORD Level,
    OUT LPBYTE *Buffer
    )

/*++

Routine Description:

    Retrieve information about a particular group.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    GroupName - Name of the group to get information about.

    Level - Level of information required. 0, 1 and 2 are valid.

    Buffer - Returns a pointer to the return information structure.
        Caller must deallocate buffer using NetApiBufferFree.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;

    ULONG RelativeId;           // Relative Id of the group

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint(( "NetGroupGetInfo: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the Domain
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_LOOKUP,
                                TRUE,   // Account Domain
                                &DomainHandle,
                                NULL);  // DomainId

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // Validate the group name and get the relative ID.
    //

    NetStatus = GrouppOpenGroup( DomainHandle,
                                 0,         // DesiredAccess
                                 GroupName,
                                 NULL,      // GroupHandle
                                 &RelativeId );

    if (NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // Get the Information about the group.
    //

    NetStatus = GrouppGetInfo( DomainHandle,
                               RelativeId,
                               Level,
                               (PVOID *)Buffer);

    //
    // Clean up.
    //

Cleanup:
    UaspCloseDomain( DomainHandle );

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetGroupGetInfo( (LPWSTR)ServerName, (LPWSTR)GroupName, Level, Buffer );

    UASP_DOWNLEVEL_END;

    IF_DEBUG( UAS_DEBUG_GROUP ) {
        NetpKdPrint(( "NetGroupGetInfo: returns %ld\n", NetStatus ));
    }

    return NetStatus;

} // NetGroupGetInfo


NET_API_STATUS NET_API_FUNCTION
NetGroupGetUsers(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR GroupName,
    IN DWORD Level,
    OUT LPBYTE *Buffer,
    IN DWORD PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT PDWORD_PTR ResumeHandle
    )

/*++

Routine Description:

    Enumerate the users which are members of a particular group.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    GroupName - The name of the group whose members are to be listed.

    Level - Level of information required. 0 and 1 are valid.

    Buffer - Returns a pointer to the return information structure.
        Caller must deallocate buffer using NetApiBufferFree.

    PrefMaxLen - Prefered maximum length of returned data.

    EntriesRead - Returns the actual enumerated element count.

    EntriesLeft - Returns the total entries available to be enumerated.

    ResumeHandle -  Used to continue an existing search.  The handle should
        be zero on the first call and left unchanged for subsequent calls.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    NTSTATUS Status2;

    DWORD FixedSize;        // The fixed size of each new entry.
    DWORD Size;
    BUFFER_DESCRIPTOR BufferDescriptor;

    PGROUP_USERS_INFO_0 grui0;
    SAM_HANDLE SamServerHandle = NULL;

    //
    // Declare Opaque group member enumeration handle.
    //

    struct _UAS_ENUM_HANDLE {
        SAM_HANDLE  DomainHandle;
        SAM_HANDLE  GroupHandle;

        PUNICODE_STRING Names;                  // Names of each member
        PSID_NAME_USE NameUse;                  // Usage of each member
        PULONG Attributes;                      // Attributes of each member

        ULONG Index;                            // Index to current entry
        ULONG Count;                            // Total Number of entries

    } *UasEnumHandle = NULL;

    //
    // Validate Parameters
    //

    BufferDescriptor.Buffer = NULL;
    *Buffer = NULL;
    *EntriesRead = 0;
    *EntriesLeft = 0;
    switch (Level) {
    case 0:
        FixedSize = sizeof(GROUP_USERS_INFO_0);
        break;

    case 1:
        FixedSize = sizeof(GROUP_USERS_INFO_1);
        break;

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    //
    // If this is a resume, get the resume handle that the caller passed in.
    //

    if ( ARGUMENT_PRESENT( ResumeHandle ) && *ResumeHandle != 0 ) {
/*lint -e511 */  /* Size incompatibility */
        UasEnumHandle = (struct _UAS_ENUM_HANDLE *) *ResumeHandle;
/*lint +e511 */  /* Size incompatibility */

    //
    // If this is not a resume, allocate and initialize a resume handle.
    //

    } else {
        PULONG MemberIds;           // Member IDs returned from SAM


        //
        // Allocate a resume handle.
        //

        UasEnumHandle = NetpMemoryAllocate( sizeof(struct _UAS_ENUM_HANDLE) );

        if ( UasEnumHandle == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Initialize all the fields in the newly allocated resume handle
        //  to indicate that SAM has never yet been called.
        //

        UasEnumHandle->DomainHandle = NULL;
        UasEnumHandle->GroupHandle = NULL;
        UasEnumHandle->Names = NULL;
        UasEnumHandle->NameUse = NULL;
        UasEnumHandle->Attributes = NULL;
        UasEnumHandle->Index = 0;
        UasEnumHandle->Count = 0;

        //
        // Connect to the SAM server
        //

        NetStatus = UaspOpenSam( ServerName,
                                 FALSE,  // Don't try null session
                                 &SamServerHandle );

        if ( NetStatus != NERR_Success ) {
            IF_DEBUG( UAS_DEBUG_GROUP ) {
                NetpKdPrint(( "NetGroupGetUsers: Cannot UaspOpenSam %ld\n", NetStatus ));
            }
            goto Cleanup;
        }

        //
        // Open the Domain
        //

        NetStatus = UaspOpenDomain( SamServerHandle,
                                    DOMAIN_LOOKUP,
                                    TRUE,   // Account Domain
                                    &UasEnumHandle->DomainHandle,
                                    NULL );

        if ( NetStatus != NERR_Success ) {
            IF_DEBUG( UAS_DEBUG_GROUP ) {
                NetpKdPrint((
                    "NetGroupGetUsers: UaspOpenDomain returns %ld\n",
                    NetStatus ));
            }
            goto Cleanup;
        }

        //
        // Open the group asking for GROUP_LIST_MEMBER access.
        //

        NetStatus = GrouppOpenGroup( UasEnumHandle->DomainHandle,
                                     GROUP_LIST_MEMBERS,
                                     GroupName,
                                     &UasEnumHandle->GroupHandle,
                                     NULL );    // Relative ID

        if ( NetStatus != NERR_Success ) {
            IF_DEBUG( UAS_DEBUG_GROUP ) {
                NetpKdPrint((
                    "NetGroupGetUsers: GrouppOpenGroup returns %ld\n",
                    NetStatus ));
            }
            goto Cleanup;
        }

        //
        // Get the group membership information from SAM
        //

        Status = SamGetMembersInGroup(
            UasEnumHandle->GroupHandle,
            &MemberIds,
            &UasEnumHandle->Attributes,
            &UasEnumHandle->Count );

        if ( !NT_SUCCESS( Status ) ) {
            IF_DEBUG( UAS_DEBUG_GROUP ) {
                NetpKdPrint((
                    "NetGroupGetUsers: SamGetMembersInGroup returned %lX\n",
                    Status ));
            }
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        if ( UasEnumHandle->Count == 0 ) {
            NetStatus = NERR_Success;
            goto Cleanup;
        }

        //
        // Determine the names and name usage for all the returned
        //  relative Ids.
        //


        Status = SamLookupIdsInDomain( UasEnumHandle->DomainHandle,
                                       UasEnumHandle->Count,
                                       MemberIds,
                                       &UasEnumHandle->Names,
                                       &UasEnumHandle->NameUse );

        Status2 = SamFreeMemory( MemberIds );
        NetpAssert( NT_SUCCESS(Status2) );


        if ( !NT_SUCCESS( Status ) ) {

                IF_DEBUG( UAS_DEBUG_GROUP ) {
                    NetpKdPrint((
                        "NetGroupGetUsers: SamLookupIdsInDomain returned %lX\n",
                        Status ));
                }

                if ( Status == STATUS_NONE_MAPPED ) {
                    NetStatus = NERR_GroupNotFound;
                    goto Cleanup;
                }

                NetStatus = NetpNtStatusToApiStatus( Status );
                goto Cleanup;
            }

    }


    //
    // Loop for each member
    //

    while ( UasEnumHandle->Index < UasEnumHandle->Count ) {

        //
        // ASSERT:  UasEnumHandle identifies the next entry to return
        //          from SAM.
        //

        //
        // Ignore members which aren't a user.
        //

        if ( UasEnumHandle->NameUse[UasEnumHandle->Index] != SidTypeUser ) {
            UasEnumHandle->Index ++;
            continue;
        }

        //
        // Place this entry into the return buffer.
        //  Compute the total size of this entry.
        //

        Size = FixedSize +
            UasEnumHandle->Names[UasEnumHandle->Index].Length + sizeof(WCHAR);

        //
        // Ensure there is buffer space for this information.
        //

        Size = ROUND_UP_COUNT( Size, ALIGN_WCHAR );

        NetStatus = NetpAllocateEnumBuffer(
                        &BufferDescriptor,
                        FALSE,      // Not a 'get' operation
                        PrefMaxLen,
                        Size,
                        GrouppMemberRelocationRoutine,
                        Level );

        if (NetStatus != NERR_Success) {
            IF_DEBUG( UAS_DEBUG_GROUP ) {
                NetpKdPrint((
                    "NetGroupGetUsers: NetpAllocateEnumBuffer returns %ld\n",
                    NetStatus ));
            }
            goto Cleanup;
        }

        //
        // Copy the common member name
        //

        NetpAssert( offsetof( GROUP_USERS_INFO_0,  grui0_name ) ==
                    offsetof( GROUP_USERS_INFO_1, grui1_name ) );

        grui0 = (PGROUP_USERS_INFO_0)BufferDescriptor.FixedDataEnd;
        BufferDescriptor.FixedDataEnd += FixedSize;

        if ( ! NetpCopyStringToBuffer(
                        UasEnumHandle->Names[UasEnumHandle->Index].Buffer,
                        UasEnumHandle->Names[UasEnumHandle->Index].Length
                            /sizeof(WCHAR),
                        BufferDescriptor.FixedDataEnd,
                        (LPWSTR *)&BufferDescriptor.EndOfVariableData,
                        &grui0->grui0_name) ) {

            NetStatus = NERR_InternalError;
            goto Cleanup;
        }


        //
        // Fill in the Level dependent fields
        //

        switch ( Level ) {
        case 0:
            break;

        case 1:

            //
            // Return the attributes for this particular membership
            //

            ((PGROUP_USERS_INFO_1)grui0)->grui1_attributes =
                UasEnumHandle->Attributes[UasEnumHandle->Index];

            break;

        default:
            NetStatus = ERROR_INVALID_LEVEL;
            goto Cleanup;

        }

        //
        // ASSERT: The current entry has been completely copied to the
        //  return buffer.
        //

        UasEnumHandle->Index ++;
        (*EntriesRead)++;
    }

    //
    // All entries have be returned to the caller.
    //

    NetStatus = NERR_Success;


    //
    // Clean up.
    //

Cleanup:

    //
    // Set EntriesLeft to the number left to return plus those that
    //  we returned on this call.
    //

    if ( UasEnumHandle != NULL ) {
        *EntriesLeft = (UasEnumHandle->Count - UasEnumHandle->Index)
             + *EntriesRead;
    }

    //
    // If we're done or the caller doesn't want an enumeration handle,
    //  free the enumeration handle.
    //

    if ( NetStatus != ERROR_MORE_DATA || !ARGUMENT_PRESENT( ResumeHandle ) ) {

        if ( UasEnumHandle != NULL ) {
            if ( UasEnumHandle->GroupHandle != NULL ) {
                (VOID) SamCloseHandle( UasEnumHandle->GroupHandle );
            }

            if ( UasEnumHandle->DomainHandle != NULL ) {
                UaspCloseDomain( UasEnumHandle->DomainHandle );
            }

            if ( UasEnumHandle->NameUse != NULL ) {
                Status = SamFreeMemory( UasEnumHandle->NameUse );
                NetpAssert( NT_SUCCESS(Status) );
            }

            if ( UasEnumHandle->Names != NULL ) {
                Status = SamFreeMemory( UasEnumHandle->Names );
                NetpAssert( NT_SUCCESS(Status) );
            }

            if ( UasEnumHandle->Attributes != NULL ) {
                Status = SamFreeMemory( UasEnumHandle->Attributes );
                NetpAssert( NT_SUCCESS(Status) );
            }

            NetpMemoryFree( UasEnumHandle );
            UasEnumHandle = NULL;
        }

    }

    //
    // If we're not returning data to the caller,
    //  free the return buffer.
    //

    if ( NetStatus != NERR_Success && NetStatus != ERROR_MORE_DATA ) {
        if ( BufferDescriptor.Buffer != NULL ) {
            MIDL_user_free( BufferDescriptor.Buffer );
        }
        BufferDescriptor.Buffer = NULL;

    }

    //
    // Set the output parameters
    //

    *Buffer = BufferDescriptor.Buffer;
    if ( ARGUMENT_PRESENT( ResumeHandle ) ) {
        NetpAssert( sizeof(UasEnumHandle) <= sizeof(DWORD_PTR) );
        *ResumeHandle = (DWORD_PTR) UasEnumHandle;
    }

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetGroupGetUsers( (LPWSTR) ServerName,
                                        (LPWSTR) GroupName,
                                        Level,
                                        Buffer,
                                        PrefMaxLen,
                                        EntriesRead,
                                        EntriesLeft,
                                        ResumeHandle );

    UASP_DOWNLEVEL_END;

    IF_DEBUG( UAS_DEBUG_GROUP ) {
        NetpKdPrint(( "NetGroupGetUsers: returns %ld\n", NetStatus ));
    }


    return NetStatus;

} // NetGroupGetUsers


NET_API_STATUS NET_API_FUNCTION
NetGroupSetInfo(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR GroupName,
    IN DWORD Level,
    IN LPBYTE Buffer,
    OUT LPDWORD ParmError OPTIONAL // Name required by NetpSetParmError
    )

/*++

Routine Description:

    Set the parameters on a group account in the user accounts database.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    GroupName - Name of the group to modify.

    Level - Level of information provided.  Must be 0, 1, 2, 1002 or 1005.

    Buffer - A pointer to the buffer containing the group information
        structure.

    ParmError - Optional pointer to a DWORD to return the index of the
        first parameter in error when ERROR_INVALID_PARAMETER is returned.
        If NULL, the parameter is not returned on error.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAM_HANDLE GroupHandle = NULL;

    //
    // Initialize
    //

    NetpSetParmError( PARM_ERROR_NONE );

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint(( "NetGroupSetInfo: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the Domain
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_LOOKUP,
                                TRUE,   // Account Domain
                                &DomainHandle,
                                NULL); // DomainId

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint(( "NetGroupSetInfo: UaspOpenDomain returns %ld\n",
                      NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the group
    //

    NetStatus = GrouppOpenGroup( DomainHandle,
                                 GROUP_WRITE_ACCOUNT|GROUP_READ_INFORMATION,
                                 GroupName,
                                 &GroupHandle,
                                 NULL );   // Relative ID

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint(( "NetGroupSetInfo: GrouppOpenGroup returns %ld\n",
                      NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Change the group
    //

    switch (Level) {

        //
        // changing group name
        //

    case 0:
    {
        LPWSTR  NewGroupName;
        GROUP_NAME_INFORMATION  NewSamGroupName;

        NewGroupName =  ((PGROUP_INFO_0)Buffer)->grpi0_name;

        if (NewGroupName == NULL) {

            IF_DEBUG( UAS_DEBUG_GROUP ) {
                NetpKdPrint(( "NetGroupSetInfo: Group Name is NULL\n" ));
            }
            NetStatus = NERR_Success;
            goto Cleanup;

        }

        //
        // Validate the new group name
        //

        RtlInitUnicodeString( &NewSamGroupName.Name, NewGroupName );

        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint(( "NetGroupSetInfo: Renaming Group Account to %wZ\n",
                            &NewSamGroupName.Name));
        }

        Status = SamSetInformationGroup( GroupHandle,
                                         GroupNameInformation,
                                         &NewSamGroupName );

        if ( !NT_SUCCESS(Status) ) {
            IF_DEBUG( UAS_DEBUG_GROUP ) {
                NetpKdPrint(( "NetGroupSetInfo: SamSetInformationGroup %lX\n",
                          Status ));
            }
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }
        break;
    }

        //
        // Set the group attributes
        //

    case 2:
    case 3:
    case 1005: {
        GROUP_ATTRIBUTE_INFORMATION Attributes;
        PGROUP_ATTRIBUTE_INFORMATION OldAttributes;

        //
        // Get the information out of the passed in structures.
        //

        if( Level == 1005 ) {
            Attributes.Attributes =
                ((PGROUP_INFO_1005)Buffer)->grpi1005_attributes;
        } else if ( Level == 2 ) {
            Attributes.Attributes =
                ((PGROUP_INFO_2)Buffer)->grpi2_attributes;
        } else {
            Attributes.Attributes =
                ((PGROUP_INFO_3)Buffer)->grpi3_attributes;
        }

        //
        // Get the current attributes so we can restore them in case of
        // error.
        //

        //
        // ?? OldAttributes gotten here is never used below.
        //

        Status = SamQueryInformationGroup( GroupHandle,
                                           GroupAttributeInformation,
                                           (PVOID*)&OldAttributes );

        if ( !NT_SUCCESS(Status) ) {
            IF_DEBUG( UAS_DEBUG_GROUP ) {
                NetpKdPrint((
                    "NetGroupSetInfo: SamQueryInformationGroup %lX\n",
                    Status ));
            }
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }


        //
        // Set the current attributes.
        //

        Status = SamSetInformationGroup( GroupHandle,
                                         GroupAttributeInformation,
                                         &Attributes );

        if ( !NT_SUCCESS(Status) ) {
            IF_DEBUG( UAS_DEBUG_GROUP ) {
                NetpKdPrint((
                    "NetGroupSetInfo: SamSetInformationGroup Attribute %lX\n",
                    Status ));
            }
            NetpSetParmError( GROUP_ATTRIBUTES_PARMNUM );
            NetStatus = NetpNtStatusToApiStatus( Status );

            Status = SamFreeMemory( OldAttributes );
            NetpAssert( NT_SUCCESS(Status) );

            goto Cleanup;
        }

        Status = SamFreeMemory( OldAttributes );
        NetpAssert( NT_SUCCESS(Status) );

        if( Level == 1005 ) {
            break;
        }

        //
        // for level 2 and 3, FALL THROUGH TO SET THE COMMENT FIELD
        //

    }

        //
        // Set the group comment
        //

    case 1:
    case 1002:
    {
        LPWSTR   GroupComment;
        GROUP_ADM_COMMENT_INFORMATION AdminComment;

        //
        // Get the new group comment
        //

        if ( Level == 1002 ) {
            GroupComment = ((PGROUP_INFO_1002)Buffer)->grpi1002_comment;
        } else if ( Level == 2 ) {
            GroupComment = ((PGROUP_INFO_2)Buffer)->grpi2_comment;
        } else if ( Level == 3 ) {
            GroupComment = ((PGROUP_INFO_3)Buffer)->grpi3_comment;
        } else {
            GroupComment = ((PGROUP_INFO_1)Buffer)->grpi1_comment;
        }

        if (GroupComment == NULL) {
            IF_DEBUG( UAS_DEBUG_GROUP ) {
                NetpKdPrint(( "NetGroupSetInfo: Group comment is NULL\n" ));
            }
            NetStatus = NERR_Success;
            goto Cleanup;
        }

        //
        // Validate the group comment
        //

        RtlInitUnicodeString( &AdminComment.AdminComment, GroupComment );
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint(( "NetGroupSetInfo: Setting AdminComment to %wZ\n",
                      &AdminComment.AdminComment ));
        }

        Status = SamSetInformationGroup( GroupHandle,
                                         GroupAdminCommentInformation,
                                         &AdminComment );

        if ( !NT_SUCCESS(Status) ) {
            IF_DEBUG( UAS_DEBUG_GROUP ) {
                NetpKdPrint(( "NetGroupSetInfo: SamSetInformationGroup %lX\n",
                          Status ));
            }
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }
        break;
    }

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        IF_DEBUG( UAS_DEBUG_GROUP ) {
            NetpKdPrint(( "NetGroupSetInfo: Invalid Level %ld\n", Level ));
        }
        goto Cleanup;

    }

    NetStatus = NERR_Success;

    //
    // Clean up.
    //

Cleanup:
    if (GroupHandle != NULL) {
        (VOID) SamCloseHandle( GroupHandle );
    }

    UaspCloseDomain( DomainHandle );

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetGroupSetInfo( (LPWSTR) ServerName,
                                       (LPWSTR) GroupName,
                                       Level,
                                       Buffer,
                                       ParmError );

    UASP_DOWNLEVEL_END;

    IF_DEBUG( UAS_DEBUG_GROUP ) {
        NetpKdPrint(( "NetGroupSetInfo: returns %ld\n", NetStatus ));
    }

    return NetStatus;

} // NetGroupSetInfo


NET_API_STATUS NET_API_FUNCTION
NetGroupSetUsers (
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR GroupName,
    IN DWORD Level,
    IN LPBYTE Buffer,
    IN DWORD NewMemberCount
    )

/*++

Routine Description:

    Set the list of members of a group.

    The SAM API allows only one member to be added or deleted at a time.
    This API allows all of the members of a group to be specified en-masse.
    This API is careful to always leave the group membership in the SAM
    database in a reasonable state.  It does by mergeing the list of
    old and new members, then only changing those memberships which absolutely
    need changing.

    Group membership is restored to its previous state (if possible) if
    an error occurs during changing the group membership.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    GroupName - Name of the group to modify.

    Level - Level of information provided.  Must be 0 or 1.

    Buffer - A pointer to the buffer containing an array of NewMemberCount
        the group membership information structures.

    NewMemberCount - Number of entries in Buffer.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;

    //
    // Call a routine shared by NetGroupDel to do all the actual work of
    // changing the membership.
    //

    NetStatus = GrouppSetUsers( ServerName,
                                GroupName,
                                Level,
                                Buffer,
                                NewMemberCount,
                                FALSE );    // Don't delete the group when done


    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetGroupSetUsers( (LPWSTR) ServerName,
                                        (LPWSTR) GroupName,
                                        Level,
                                        Buffer,
                                        NewMemberCount );

    UASP_DOWNLEVEL_END;

    IF_DEBUG( UAS_DEBUG_GROUP ) {
        NetpKdPrint(( "NetGroupSetUsers: returns %ld\n", NetStatus ));
    }

    return NetStatus;

} // NetGroupSetUsers
/*lint +e614 */
/*lint +e740 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\uasp.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    uasp.h

Abstract:

    Private declartions for function defined in uasp.c, aliasp.c,
    groupp.c, and userp.c

Author:

    Cliff Van Dyke (cliffv) 20-Feb-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    17-Apr-1991 (cliffv)
        Incorporated review comments.
    09-Apr-1992 JohnRo
        Prepare for WCHAR.H (_wcsicmp vs _wcscmpi, etc).
    28-Oct-1992 RitaW
    Added private support routines for localgroups (aliases)
    30-Nov-1992 Johnl
    Added AliaspOpenAlias2 (same as AliaspOpenAlias except operates on
    RID instead of account name).

--*/



//
// Procedure Forwards for uasp.c
//

NET_API_STATUS
UaspOpenSam(
    IN LPCWSTR ServerName OPTIONAL,
    IN BOOL AllowNullSession,
    OUT PSAM_HANDLE SamServerHandle
    );

NET_API_STATUS
UaspOpenDomain(
    IN SAM_HANDLE SamServerHandle,
    IN ULONG DesiredAccess,
    IN BOOL AccountDomain,
    OUT PSAM_HANDLE DomainHandle,
    OUT PSID *DomainId OPTIONAL
    );

NET_API_STATUS
UaspOpenDomainWithDomainName(
    IN LPCWSTR DomainName,
    IN ULONG DesiredAccess,
    IN BOOL AccountDomain,
    OUT PSAM_HANDLE DomainHandle,
    OUT PSID *DomainId OPTIONAL
    );

VOID
UaspCloseDomain(
    IN SAM_HANDLE DomainHandle
    );

NET_API_STATUS
UaspGetDomainId(
    IN SAM_HANDLE SamServerHandle,
    OUT PSID *DomainId
    );

NET_API_STATUS
UaspLSASetServerRole(
    IN LPCWSTR ServerName,
    IN PDOMAIN_SERVER_ROLE_INFORMATION DomainServerRole
    );

NET_API_STATUS
UaspBuiltinDomainSetServerRole(
    IN SAM_HANDLE SamServerHandle,
    IN PDOMAIN_SERVER_ROLE_INFORMATION DomainServerRole
    );

//
// Procedure forwards for aliasp.c
//

typedef enum _ALIASP_DOMAIN_TYPE {

    AliaspBuiltinOrAccountDomain,
    AliaspAccountDomain,
    AliaspBuiltinDomain

} ALIASP_DOMAIN_TYPE;

NET_API_STATUS
AliaspOpenAliasInDomain(
    IN SAM_HANDLE SamServerHandle,
    IN ALIASP_DOMAIN_TYPE DomainType,
    IN ACCESS_MASK DesiredAccess,
    IN LPCWSTR AliasName,
    OUT PSAM_HANDLE AliasHandle
    );

NET_API_STATUS
AliaspOpenAlias(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN LPCWSTR AliasName,
    OUT PSAM_HANDLE AliasHandle
    );

NET_API_STATUS
AliaspOpenAlias2(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG RelativeID,
    OUT PSAM_HANDLE AliasHandle
    );

NET_API_STATUS
AliaspChangeMember(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR AliasName,
    IN PSID MemberSid,
    IN BOOL AddMember
    );

typedef enum {
    SetMembers,
    AddMembers,
    DelMembers
} ALIAS_MEMBER_CHANGE_TYPE;

NET_API_STATUS
AliaspSetMembers (
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR AliasName,
    IN DWORD Level,
    IN LPBYTE Buffer,
    IN DWORD NewMemberCount,
    IN ALIAS_MEMBER_CHANGE_TYPE
    );

NET_API_STATUS
AliaspGetInfo(
    IN SAM_HANDLE AliasHandle,
    IN DWORD Level,
    OUT PVOID *Buffer
    );

VOID
AliaspRelocationRoutine(
    IN DWORD Level,
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN PTRDIFF_T Offset
    );

VOID
AliaspMemberRelocationRoutine(
    IN DWORD Level,
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN PTRDIFF_T Offset
    );

NET_API_STATUS
AliaspPackBuf(
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    IN DWORD EntriesCount,
    OUT LPDWORD EntriesRead,
    BUFFER_DESCRIPTOR *BufferDescriptor,
    DWORD FixedSize,
    PUNICODE_STRING Names) ;

NET_API_STATUS
AliaspNamesToSids (
    IN LPCWSTR ServerName,
    IN BOOL OnlyAllowUsers,
    IN DWORD NameCount,
    IN LPWSTR *Names,
    OUT PSID **Sids
    );

VOID
AliaspFreeSidList (
    IN DWORD SidCount,
    IN PSID *Sids
    );

//
// Procedure forwards for groupp.c
//

NET_API_STATUS
GrouppOpenGroup(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN LPCWSTR GroupName,
    OUT PSAM_HANDLE GroupHandle OPTIONAL,
    OUT PULONG RelativeId OPTIONAL
    );

NET_API_STATUS
GrouppChangeMember(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR GroupName,
    IN LPCWSTR UserName,
    IN BOOL AddMember
    );

NET_API_STATUS
GrouppGetInfo(
    IN SAM_HANDLE DomainHandle,
    IN ULONG RelativeId,
    IN DWORD Level,
    OUT PVOID *Buffer // Caller must deallocate buffer using NetApiBufferFree.
    );

VOID
GrouppRelocationRoutine(
    IN DWORD Level,
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN PTRDIFF_T Offset
    );

VOID
GrouppMemberRelocationRoutine(
    IN DWORD Level,
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN PTRDIFF_T Offset
    );

NET_API_STATUS
GrouppSetUsers (
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR GroupName,
    IN DWORD Level,
    IN LPBYTE Buffer,
    IN DWORD NewMemberCount,
    IN BOOL DeleteGroup
    );

//
// Procedure forwards for userp.c
//

NET_API_STATUS
UserpOpenUser(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN LPCWSTR UserName,
    OUT PSAM_HANDLE UserHandle OPTIONAL,
    OUT PULONG RelativeId OPTIONAL
    );

NET_API_STATUS
UserpGetInfo(
    IN SAM_HANDLE DomainHandle,
    IN PSID DomainId,
    IN SAM_HANDLE BuiltinDomainHandle OPTIONAL,
    IN UNICODE_STRING UserName,
    IN ULONG UserRelativeId,
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
        // Caller must deallocate BD->Buffer using MIDL_user_free.
    IN BOOL IsGet,
    IN DWORD SamFilter
    );

NET_API_STATUS
UserpSetInfo(
    IN SAM_HANDLE DomainHandle,
    IN PSID DomainId,
    IN SAM_HANDLE UserHandle OPTIONAL,
    IN SAM_HANDLE BuiltinDomainHandle OPTIONAL,
    IN ULONG UserRelativeId,
    IN LPCWSTR UserName,
    IN DWORD Level,
    IN LPBYTE Buffer,
    IN ULONG WhichFieldsMask,
    OUT LPDWORD ParmError OPTIONAL // Name required by NetpSetParmError
    );

ULONG
NetpDeltaTimeToSeconds(
    IN LARGE_INTEGER DeltaTime
    );

LARGE_INTEGER
NetpSecondsToDeltaTime(
    IN ULONG Seconds
    );

DWORD
NetpGetElapsedSeconds(
    IN PLARGE_INTEGER Time
    );

//
// Determine if the passed in DWORD has precisely one bit set.
//

#define JUST_ONE_BIT( _x ) (((_x) != 0 ) && ( ( (~(_x) + 1) & (_x) ) == (_x) ))


//
// Local macro to add a byte offset to a pointer.
//

#define RELOCATE_ONE( _fieldname, _offset ) \
    _fieldname = (PVOID) ((LPBYTE)(_fieldname) + _offset)


////////////////////////////////////////////////////////////////////////
//
// UaspNameCompare
//
// I_NetNameCompare but always takes UNICODE strings
//
////////////////////////////////////////////////////////////////////////

#ifdef UNICODE

#define UaspNameCompare( _name1, _name2, _nametype ) \
     I_NetNameCompare(NULL, (_name1), (_name2), (_nametype), 0 )

#else // UNICODE

#define UaspNameCompare( _name1, _name2, _nametype ) \
    _wcsicmp( (_name1), (_name2) )

#endif // UNICODE


////////////////////////////////////////////////////////////////////////
//
// UASP_DOWNLEVEL
//
// Decide if call is to be made to a downlevel server.
// This macro contains a 'return', so do not allocate any resources
// before calling this macro.
//
////////////////////////////////////////////////////////////////////////

NET_API_STATUS
UaspDownlevel(
    IN LPCWSTR ServerName OPTIONAL,
    IN NET_API_STATUS OriginalError,
    OUT LPBOOL TryDownLevel
    );

#define UASP_DOWNLEVEL_BEGIN( _ServerName, _NetStatus ) \
    if ( _NetStatus != NERR_Success &&                  \
         _NetStatus != ERROR_MORE_DATA ) {              \
        BOOL TryDownLevel;                              \
                                                        \
        _NetStatus = UaspDownlevel(                     \
                         _ServerName,                   \
                         _NetStatus,                    \
                         &TryDownLevel                  \
                         );                             \
                                                        \
        if (TryDownLevel) {


#define UASP_DOWNLEVEL_END \
        } \
    }


//
// Debug Macros
//

#define UAS_DEBUG_USER   0x00000001     // NetUser APIs
#define UAS_DEBUG_GROUP  0x00000002     // NetGroup APIs
#define UAS_DEBUG_ACCESS 0x00000004     // NetAccess APIs
#define UAS_DEBUG_ALIAS  0x00000008     // NetLocalGroup APIs
#define UAS_DEBUG_UASP   0x00000010     // uasp.c
#define UAS_DEBUG_AUASP  0x00000020     // uasp.c LocalGroup related functions

#if DBG
#define UAS_DEBUG
#endif // DBG

#ifdef UAS_DEBUG

extern DWORD UasTrace;

#define IF_DEBUG(Function) if (UasTrace & Function)

#else

/*lint -e614 */  /* Auto aggregate initializers need not be constant */
#define IF_DEBUG(Function) if (FALSE)

#endif // UAS_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\uastest1.c ===
///**************************************************************
///          Microsoft LAN Manager                              *
///        Copyright(c) Microsoft Corp., 1990-92                *
///**************************************************************
//
//  This program is designed to do functional testing on the following
//  APIs:
//      NetUserAdd
//      NetUserDel
//      NetUserGetInfo
//      NetUserSetInfo
//      NetUserEnum
//      NetUserValidate
//
//  Note: This leaves two users, User1 & User2, defined on the NET.ACC
//  file which are to be used in uastest2, group testing.  It also assumes
//  a NET.ACC which is just initialized by makeacc.
//

#include <nt.h> // TIME definition
#include <ntrtl.h>      // TIME definition
#include <nturtl.h>     // TIME definition
#define NOMINMAX        // Avoid redefinition of min and max in stdlib.h
#include        <windef.h>
#include        <winbase.h>

#include        <stdio.h>
#include        <stdlib.h>
#include        <string.h>
#include        <lmcons.h>
#include        <lmapibuf.h>
#include        <netdebug.h>
#include        <netlib.h>
#include        <lmaccess.h>
#include        <lmerr.h>
#include <ntsam.h>

#include        "uastest.h"
#include "accessp.h"
#include "netlogon.h"
#include "logonp.h"

#define HOMEDIR     L"C:\\HOMDIR"
#define COMMENT     L"COMMENT"
#define SCRIPT      L"SCRIPT"
#define SCRIPT_PATH L"SCRIPT_PATH"
#define FULL_NAME   L"FULL_NAME"
#define COMMENT2    L"COMMENT2"
#define PARMS       L"PARMS"
#define WORK        L"WORK"
#define EXPIRES     0xdddddddd
#define STORAGE     USER_MAXSTORAGE_UNLIMITED
#define STORAGE2    USER_MAXSTORAGE_UNLIMITED
#define SCRIPT_PATH2    L"SCRIPT_PATH"
#define FULL_NAME2  L"FULL_NAME2"
#define COMMENT22   L"COMMENT2"
#define PARMS2      L"PARMS"
#define WORK2       L"WORK2"
#define EXPIRES2    0xdddddddd
#define SCRIPT2     L"SCRIPT2"
#define HOMEDIR2    L"C:\\HOMEDIR2"

#define PROFILE     L"PROFILE"
#define PROFILE2    L"PROFILE2"

#define HOMEDIRDRIVE L"E:";
#define HOMEDIRDRIVE2 L"G:";

#define PASSWORD    L"Password"
#define TST_PASSWD  L"PARMNUM"
#define TST_FULL_NAME L"PARMNUM_FULL_NAME"
#define TST_ACCT_EXPIRES 0xCCCCCCCC
#define FINAL_PASSWORD  L"FINAL_PASSWORD"
#define ADD_PASSWORD    L"ADD_PASSWORD"

unsigned char    default_logon_hours[] =
{
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};


unsigned char    logon_hours1[] =
{
    0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};


unsigned char    logon_hours2[] =
{
    0xee, 0xee, 0xee, 0xee, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

void
CompareString(
    LPWSTR TestString,
    LPWSTR GoodString,
    LPSTR Comment1,
    LPWSTR Comment2 )
{
    CHAR Buffer[512];

    strcpy( Buffer, Comment1 );

    if (_wcsicmp(TestString, GoodString) != 0) {
        strcat( Buffer, " mismatch" );
        error_exit(FAIL, Buffer, Comment2 );
        printf("     \"");
        PrintUnicode( TestString );
        printf( "\" s.b. \"" );
        PrintUnicode( GoodString );
        printf( "\"\n" );
    } else {
        strcat( Buffer, " matched correctly" );
        error_exit(PASS, Buffer, Comment2 );
    }
}


void
set_level1(
    USER_INFO_1  *u1p,
    LPWSTR namep
    )
{
    u1p->usri1_name = namep;
    u1p->usri1_password = ADD_PASSWORD;
    u1p->usri1_password_age = 0;
    u1p->usri1_priv = USER_PRIV_USER;
    u1p->usri1_home_dir = HOMEDIR;
    u1p->usri1_comment = COMMENT;
    u1p->usri1_flags = UF_NORMAL_ACCOUNT | UF_SCRIPT;
    u1p->usri1_script_path = SCRIPT;
}



void
set_level12(u1p)
    USER_INFO_1  *u1p;
{
    u1p->usri1_password = NULL;
    u1p->usri1_priv = USER_PRIV_USER;
    u1p->usri1_home_dir = HOMEDIR2;
    u1p->usri1_comment = COMMENT2;
    u1p->usri1_flags = UF_NORMAL_ACCOUNT | UF_SCRIPT;
    u1p->usri1_script_path = SCRIPT2;
}



void
set_level2(u2p)
USER_INFO_2  *u2p;
{
    u2p->usri2_full_name = FULL_NAME;
    u2p->usri2_usr_comment = COMMENT2;
    u2p->usri2_parms = PARMS;
    u2p->usri2_workstations = WORK;
    u2p->usri2_acct_expires = EXPIRES;
    u2p->usri2_max_storage = STORAGE;
    u2p->usri2_units_per_week = UNITS_PER_WEEK;
    u2p->usri2_logon_hours = logon_hours1;
    u2p->usri2_country_code = 0;
    u2p->usri2_code_page = 0;
    u2p->usri2_auth_flags = 0;
    u2p->usri2_logon_server = NULL;
}




void
set_level22(u2p)
USER_INFO_2  *u2p;
{
    u2p->usri2_full_name = FULL_NAME2;
    u2p->usri2_usr_comment = COMMENT22;
    u2p->usri2_parms = PARMS2;
    u2p->usri2_workstations = WORK2;
    u2p->usri2_acct_expires = EXPIRES2;
    u2p->usri2_max_storage = STORAGE2;
    u2p->usri2_logon_hours = logon_hours2;
    u2p->usri2_auth_flags = 0;
    u2p->usri2_logon_server = NULL;
}


void
set_level3(u3p)
USER_INFO_3 *u3p;
{
    u3p->usri3_primary_group_id = DOMAIN_GROUP_RID_USERS;
    u3p->usri3_profile = PROFILE;
    u3p->usri3_home_dir_drive = HOMEDIRDRIVE;

}

void
set_level32(u3p)
USER_INFO_3 *u3p;
{
    u3p->usri3_profile = PROFILE2;
    u3p->usri3_home_dir_drive = HOMEDIRDRIVE2;

}

void
compare_level1(
    USER_INFO_1  *ui1p,
    USER_INFO_1  *uo1p,
    LPWSTR test
    )
{

    //
    // validate information
    //

    error_exit(ACTION, "Validate Level 1 Information", test);

    CompareString( ui1p->usri1_name,
                   uo1p->usri1_name,
                   "NetUserGetInfo(1) name",
                   NULL);

    if (ui1p->usri1_priv != uo1p->usri1_priv)
        error_exit(FAIL, "NetUserGetInfo(1) priv mismatch", NULL);
    else
        error_exit(PASS, "NetUserGetInfo(1) priv matched correctly", NULL);


    CompareString( ui1p->usri1_home_dir,
                   uo1p->usri1_home_dir,
                   "NetUserGetInfo(1) home_dir",
                   NULL);

    CompareString( ui1p->usri1_comment,
                   uo1p->usri1_comment,
                   "NetUserGetInfo(1) comment",
                   NULL);

    if (ui1p->usri1_flags != uo1p->usri1_flags)
        error_exit(FAIL, "NetUserGetInfo(1) flags mismatch", NULL);
    else
        error_exit(PASS, "NetUserGetInfo(1) flags matched correctly", NULL);


    CompareString( ui1p->usri1_script_path,
                   uo1p->usri1_script_path,
                   "NetUserGetInfo(1) script_path",
                   NULL);
}


void
compare_level2(
    USER_INFO_2  *ui2p,
    USER_INFO_2  *uo2p,
    LPWSTR test
    )
{
    error_exit(ACTION, "Validate Level 2 Information", test);


    CompareString( ui2p->usri2_script_path,
                   uo2p->usri2_script_path,
                   "NetUserGetInfo(2) script_path",
                   NULL);

    CompareString( ui2p->usri2_full_name,
                   uo2p->usri2_full_name,
                   "NetUserGetInfo(2) full_name",
                   NULL);

    CompareString( ui2p->usri2_usr_comment,
                   uo2p->usri2_usr_comment,
                   "NetUserGetInfo(2) usr_comment",
                   NULL);

    CompareString( ui2p->usri2_parms,
                   uo2p->usri2_parms,
                   "NetUserGetInfo(2) parms",
                   NULL);

    CompareString( ui2p->usri2_workstations,
                   uo2p->usri2_workstations,
                   "NetUserGetInfo(2) workstations",
                   NULL);

    if (ui2p->usri2_acct_expires != uo2p->usri2_acct_expires)
        error_exit(FAIL, "ACCOUNT_EXPIRES incorrect", NULL);
    else
        error_exit(PASS, "ACCOUNT_EXPIRES matched correctly", NULL);

    if (ui2p->usri2_max_storage != uo2p->usri2_max_storage)
        error_exit(FAIL, "MAX_STORAGE incorrect", NULL);
    else
        error_exit(PASS, "MAX_STORAGE matched correctly", NULL);

    if (memcmp (ui2p->usri2_logon_hours, uo2p->usri2_logon_hours, 21) != 0)
        error_exit(FAIL, "logon_hours1 incorrect", NULL);
    else
        error_exit(PASS, "logon_hours1 matched correctly", NULL );
}

void
compare_level3(
    USER_INFO_3  *ui3p,
    USER_INFO_3  *uo3p,
    LPWSTR test
    )
{
    error_exit(ACTION, "Validate Level 3 Information", test);

    CompareString( ui3p->usri3_profile,
                   uo3p->usri3_profile,
                   "NetUserGetInfo(3) profile",
                   NULL);

    CompareString( ui3p->usri3_home_dir_drive,
                   uo3p->usri3_home_dir_drive,
                   "NetUserGetInfo(3) home_dir_drive",
                   NULL);

}



void
test_getinfo_10_11_20()
{
    USER_INFO_10 *u10p;
    USER_INFO_11 *u11p;
    USER_INFO_20 *u20p;

    //
    // GetInfo level 10
    //

    if (err = NetUserGetInfo(server, USER2, 10, (LPBYTE *)&u10p)) {
        error_exit(FAIL, "NetUserGetInfo(10) failed", USER2);
    } else {

        CompareString( u10p->usri10_name,
                       USER2,
                       "NetUserGetInfo(10) name",
                       USER2);

        CompareString( u10p->usri10_usr_comment,
                       COMMENT2,
                       "NetUserGetInfo(10) usr_comment",
                       USER2);

        CompareString( u10p->usri10_full_name,
                       FULL_NAME,
                       "NetUserGetInfo(10) full_name",
                       USER2);

        (VOID) NetApiBufferFree( u10p );
    }

    //
    // GetInfo level 11
    //

    if (err = NetUserGetInfo(server, USER2, 11, (LPBYTE *)&u11p )) {
        error_exit(FAIL, "NetUserGetInfo(11) failed", USER2);

    } else {

        CompareString( u11p->usri11_name,
                       USER2,
                       "NetUserGetInfo(11) name",
                       USER2);

        CompareString( u11p->usri11_usr_comment,
                       COMMENT2,
                       "NetUserGetInfo(11) usr_comment",
                       USER2);

        CompareString( u11p->usri11_full_name,
                       FULL_NAME,
                       "NetUserGetInfo(11) full_name",
                       USER2);

        if (u11p->usri11_priv  != USER_PRIV_USER)
            error_exit(FAIL, "GetInfo(11) prive mismatch", USER2);

        CompareString( u11p->usri11_home_dir,
                       HOMEDIR,
                       "NetUserGetInfo(11) home_dir",
                       USER2);

        CompareString( u11p->usri11_parms,
                       PARMS,
                       "NetUserGetInfo(11) parms",
                       USER2);

        (VOID) NetApiBufferFree( u11p );
    }

    //
    // GetInfo level 20
    //

    if (err = NetUserGetInfo(server, USER2, 20, (LPBYTE *)&u20p )) {
        error_exit(FAIL, "NetUserGetInfo(20) failed", USER2);

    } else {

        CompareString( u20p->usri20_name,
                       USER2,
                       "NetUserGetInfo(20) name",
                       USER2);

        CompareString( u20p->usri20_full_name,
                       FULL_NAME,
                       "NetUserGetInfo(20) full_name",
                       USER2);

        (VOID) NetApiBufferFree( u20p );
    }
}





void
test_setinfo_l2_parmnum()
{
    USER_INFO_2  *ui2p ;
    USER_INFO_1011 User1011;
    USER_INFO_1017 User1017;
#ifdef NOPASSWORD_SUPPORT
    USER_INFO_1003 User1003;

    //
    // test 1003
    // password cant be changed before min_pw_age modal
    //

    User1003.usri1003_password = TST_PASSWD;
    error_exit(ACTION, "Password cant be changed before min_pw_age", USER1);
    if (err = NetUserSetInfo(server, USER1, 1003, (LPBYTE)&User1003, NULL )) {
        if ( err != ERROR_ACCESS_DENIED )
            error_exit(FAIL, "SetInfo of 1003 Incorrect", USER1);
        else
            error_exit(PASS, "SetInfo of 1003 Denied", USER1);
    }

    if (err = NetUserPasswordSet(server, USER1,
        TST_PASSWD, FINAL_PASSWORD)) {
        if ( err != ERROR_NETWORK_ACCESS_DENIED)
            error_exit(FAIL, "PasswordSet FINAL_PASSWORD Incorrect", USER1);
        else
            err("uastest1: Test Passed (PasswordSet of FINAL_PASSWORD Denied)");
    }
#endif // NOPASSWORD_SUPPORT

    //
    // test 1011
    //

    User1011.usri1011_full_name = TST_FULL_NAME;
    if (err = NetUserSetInfo(server, USER1, 1011, (LPBYTE) &User1011, NULL )) {
        error_exit(FAIL, "SetInfo 1011 failed", USER1);
    }

    //
    // GetInfo on user using level 2
    //

    if (err = NetUserGetInfo(server, USER1, 2, (LPBYTE * ) &ui2p)) {
        error_exit(FAIL, "GetInfo after SetInfo 1011", USER1);

    } else {

        CompareString( ui2p->usri2_full_name,
                       TST_FULL_NAME,
                       "NetUserSetInfo(1011) full_name",
                       USER1);

        (VOID) NetApiBufferFree( ui2p );

    }

    //
    // test 1017
    //

    User1017.usri1017_acct_expires = TST_ACCT_EXPIRES;

    if (err = NetUserSetInfo(server, USER1, 1017, (LPBYTE)&User1017, NULL )) {
        error_exit(FAIL, "SetInfo 1017 failed", USER1);
    }

    //
    // GetInfo on user using level 2
    //

    if (err = NetUserGetInfo(server, USER1, 2, (LPBYTE *) &ui2p ) ) {
        error_exit(FAIL, "GetInfo after SetInfo 1017", USER1);
    } else {

        if (ui2p->usri2_acct_expires != TST_ACCT_EXPIRES) {
            printf( "  Got %lx wanted %lx\n",
                          ui2p->usri2_acct_expires,
                          TST_ACCT_EXPIRES );
            error_exit(FAIL, "SetInfo 1017 mismatch", USER1);
        } else
            error_exit(PASS, "SetInfo 1017 succeeded", USER1);
        (VOID) NetApiBufferFree( ui2p );
    }

    //
    // test PARMNUM_PRIV
    // test PARMNUM_FLAGS
    // test PARMNUM_PARMS
    //

}



#ifdef USER_VAL // ?? UserValidate not implemented
void
test_user_val()
{
    unsigned short  priv = 0;
    struct user_logon_req_1 *ulr0p;
    struct user_logon_info_1 *uli0p;


    //
    // validate of non-user
    //

    if (err = NetUserValidate(NULL, NOTTHERE, FINAL_PASSWORD, &priv)) {

        if (err != ERROR_ACCESS_DENIED)
            error_exit(FAIL, "UserValidate NOTTHERE wrong", NULL);
        else
            error_exit(PASS, "UserValidate ok for NOTTHERE", NULL);
    } else
        error_exit(FAIL, "UserValidate for NOTTHERE wrong", NULL);

    //
    // validate of user bad password
    //

    if (err = NetUserValidate(NULL, USER1, PASSWORD, &priv)) {
        if (err != ERROR_ACCESS_DENIED)
            error_exit(FAIL, "UserValidate USER1 bad password wrong", USER1);
        else
            error_exit(PASS, "UserValidate bad password", USER1);
    } else
        error_exit(FAIL, "UserValidate ok USER1 bad password", USER1);

    //
    // validate User1
    // Note that password can not change before min_pw_age modal
    //

    if (err = NetUserValidate(NULL, USER1, (char * )ADD_PASSWORD, &priv))
        error_exit(FAIL, "UserValidate USER1 wrong", USER1);
    else if (priv != USER_PRIV_USER)
        error_exit(FAIL, "UserValidate priviledge incorrect", USER1);
    else
        error_exit(FAIL, "UserValidate USER1 successful", USER1);

    //
    // validate2 of non-user
    //

    ulr0p->usrreq1_name = NOTTHERE;
    ulr0p->usrreq1_password = FINAL_PASSWORD;
    ulr0p->usrreq1_workstation = WORK2;

    if (err = NetUserValidate2(NULL, 1, ulr0p, sizeof(*ulr0p), 0, &total)) {
        if (err != ERROR_ACCESS_DENIED)
            error_exit(FAIL, "UserValidate2 NOTTHERE wrong", NULL );
        else
            error_exit(PASS, "UserValidate2 NOTTHERE denied", NULL );
    } else
        error_exit(FAIL, "UserValidate2 NOTTHERE succeeded", NULL );

    //
    // validate2 of bad password
    //

    ulr0p->usrreq1_name = USER1;
    ulr0p->usrreq1_password = PASSWORD;
    ulr0p->usrreq1_workstation = WORK2;

    if (err = NetUserValidate2(NULL, 1, ulr0p, sizeof(*ulr0p), 0, &total)) {
        if (err != ERROR_ACCESS_DENIED)
            error_exit(FAIL, "UserValidate2 USER1 bad password wrong", USER1);
        else
            error_exit(PASS, "UserValidate2 USER1 bad password denied", USER1);
    } else
        error_exit(FAIL, "UserValidate2 USER1 bad password succeeded", USER1);


    //
    // validate2 of User1
    //

    ulr0p->usrreq1_name = USER1;
    ulr0p->usrreq1_password = ADD_PASSWORD;
    ulr0p->usrreq1_workstation = WORK2;

    if (err = NetUserValidate2(NULL, 1, ulr0p, sizeof(*ulr0p), 0, &total))
        error_exit(FAIL, "UserValidate2 USER1 failed", USER1);
    else
     {
        error_exit(PASS, "UserValidate2 USER1 successful", USER1);
        if (strcmpf(uli0p->usrlog1_eff_name, USER1) != 0)
            error_exit(FAIL, "UserValidate2 effective name mismatch", USER1);

        if (uli0p->usrlog1_priv != USER_PRIV_USER)
            error_exit(FAIL, "UserValidate2 priviledge mismatch", USER1);
    }
}
#endif // USER_VAL  // ?? UserValidate not implemented




BOOL
find_ptr( UserEnum, u1, u2, size, level)
LPBYTE UserEnum;
LPBYTE *  u1;
LPBYTE *  u2;
unsigned short  size,
level;
{
    LPBYTE p1;
    LPWSTR p2;
    DWORD i;
    BOOL ExitStatus = TRUE;


    // users in the domain are GUEST, ADMIN, USER1 and USER2, so the
    // nread and total must be equal to 4.

    if ((nread != total) || (nread != 4)) {
        err = 0;
        error_exit(FAIL, "NetUserEnum nread incorect", NULL);
        printf("nread = %d, total = %d\n", nread, total);
        TEXIT;
    }

    *u1 = NULL;
    *u2 = NULL;
    p1 = UserEnum;

    for (i = 0; i < nread; i++, p1 += size) {
        p2 = *((WCHAR **)p1);

        if (_wcsicmp(p2, USER1) == 0) {
            *u1 = p1;
        } else if (_wcsicmp( p2, USER2) == 0) {
            *u2 = p1;
        } else {
            if ((_wcsicmp(p2, L"ADMIN") != 0) && (_wcsicmp(p2, L"GUEST") != 0)) {
                printf("UASTEST1: FAIL - Invalid user '%ws' in enum buffer level %d\n", p2, level);
                TEXIT;
                ExitStatus = FALSE;
            }
        }
    }

    if (*u1 == NULL) {
        printf("UASTEST1: FAIL - Did not find USER1 in level %d enum\n", level);
        TEXIT;
        ExitStatus = FALSE;
    }

    if (*u2 == NULL) {
        printf("UASTEST1: FAIL - Did not find USER2 in level %d enum\n", level);
        TEXIT;
        ExitStatus = FALSE;
    }

    return ExitStatus;
}


void
validate_enum0(
    PUSER_INFO_2 User1Info,
    PUSER_INFO_2 User2Info
    )
{
    NET_API_STATUS  err;
    USER_INFO_0 *u1, *u2;
    PUSER_INFO_0 UserEnum;

    if (err = NetUserEnum( NULL,
                           0,
                           ENUM_FILTER,
                           (LPBYTE *)&UserEnum,
                           (DWORD)0xffffffff,
                           &nread,
                           &total,
                           NULL)) {
        error_exit(FAIL, "NetUserEnum(0) validate_enum0", NULL);
        return;
    }

    (VOID) find_ptr((LPBYTE) UserEnum, (LPBYTE * ) & u1, (LPBYTE * ) & u2,
                    sizeof(USER_INFO_0 ), 0);

    (VOID) NetApiBufferFree( UserEnum );
    UNREFERENCED_PARAMETER( User1Info );
    UNREFERENCED_PARAMETER( User2Info );
}



void
validate_enum1(
    PUSER_INFO_2 User1Info,
    PUSER_INFO_2 User2Info
    )
{
    NET_API_STATUS  err;
    USER_INFO_1 *u1, *u2;
    PUSER_INFO_1 UserEnum;

    //
    // check enum level 1
    //

    if (err = NetUserEnum(NULL,
                           1,
                           ENUM_FILTER,
                           (LPBYTE *)& UserEnum,
                           (DWORD)0xffffffff,
                           &nread,
                           &total,
                           NULL)) {

        error_exit(FAIL, "NetUserEnum(1) validate_enum1", NULL );
        return;
    }

    if ( find_ptr( (LPBYTE)UserEnum, (LPBYTE * ) & u1, (LPBYTE * ) & u2,
        sizeof(USER_INFO_1 ), 1) ) {

        compare_level1(u1, (USER_INFO_1 * ) User1Info, L"Enum level 1");
        compare_level1(u2, (USER_INFO_1 * ) User2Info, L"Enum level 1");
    }

    (VOID) NetApiBufferFree( UserEnum );
}



void
validate_enum2(
    PUSER_INFO_2 User1Info,
    PUSER_INFO_2 User2Info
    )
{
    NET_API_STATUS  err;
    USER_INFO_2 *u1, *u2;
    PUSER_INFO_2 UserEnum;

    //
    // check enum level 2
    //

    if (err = NetUserEnum(NULL,
                           2,
                           ENUM_FILTER,
                           (LPBYTE *)&UserEnum,
                           (DWORD)0xFFFFFFFF,
                           &nread,
                           &total,
                           NULL)) {
        error_exit(FAIL, "NetUserEnum(2) validate_enum2", NULL);
        return;
    }

    if ( find_ptr( (LPBYTE)UserEnum, (LPBYTE * ) & u1, (LPBYTE * ) & u2,
        sizeof(USER_INFO_2 ), 2) ) {

        compare_level1((USER_INFO_1 * ) u1,
            (USER_INFO_1 * ) User1Info, L"Enum level 2");
        compare_level1((USER_INFO_1 * ) u2,
            (USER_INFO_1 * ) User2Info, L"Enum level 2");
        compare_level2(u1, User1Info, L"Enum level 2");
        compare_level2(u2, User2Info, L"Enum level 2");
    }

    (VOID) NetApiBufferFree( UserEnum );
}


void
validate_enum3(
    PUSER_INFO_3 User1Info,
    PUSER_INFO_3 User2Info
    )
{
    NET_API_STATUS  err;
    USER_INFO_3 *u1, *u2;
    PUSER_INFO_3 UserEnum;

    //
    // check enum level 3
    //

    if (err = NetUserEnum(NULL, 3, ENUM_FILTER, (LPBYTE *)&UserEnum, (DWORD)0xFFFFFFFF, &nread, &total, NULL)) {
        error_exit(FAIL, "NetUserEnum(3) validate_enum3", NULL);
        return;
    }

    if ( find_ptr( (LPBYTE)UserEnum, (LPBYTE * ) & u1, (LPBYTE * ) & u2,
        sizeof(USER_INFO_3 ), 3) ) {

        compare_level1((USER_INFO_1 * ) u1,
            (USER_INFO_1 * ) User1Info, L"Enum level 3");
        compare_level1((USER_INFO_1 * ) u2,
            (USER_INFO_1 * ) User2Info, L"Enum level 3");

        compare_level2((USER_INFO_2 *)u1,
            (USER_INFO_2 *)User1Info, L"Enum level 3");
        compare_level2((USER_INFO_2 *)u2,
            (USER_INFO_2 *) User2Info, L"Enum level 3");

        compare_level3(u1, User1Info, L"Enum level 3");
        compare_level3(u2, User2Info, L"Enum level 3");
    }

    (VOID) NetApiBufferFree( UserEnum );
}

void
enum_compare10(ep, gp)
USER_INFO_10 *ep;
USER_INFO_2  *gp;
{

    CompareString( ep->usri10_usr_comment,
                   gp->usri2_usr_comment,
                   "NetUserEnum(10) usr_comment",
                   NULL);

    CompareString( ep->usri10_full_name,
                   gp->usri2_full_name,
                   "NetUserEnum(10) full_name",
                   NULL);
}


void
validate_enum10(
    PUSER_INFO_2 User1Info,
    PUSER_INFO_2 User2Info
    )
{
    NET_API_STATUS  err;
    USER_INFO_10 *u1, *u2;
    PUSER_INFO_10 UserEnum;

    //
    // check enum level 10
    //

    if (err = NetUserEnum(NULL, 10, ENUM_FILTER, (LPBYTE *)&UserEnum, (DWORD)0xFFFFFFFF, &nread, &total, NULL)) {
        error_exit(FAIL, "NetUserEnum(10) validate_enum10", NULL);
        return;
    }

    if ( find_ptr((LPBYTE)UserEnum, (LPBYTE * ) & u1, (LPBYTE * ) & u2,
                  sizeof(USER_INFO_10 ), 10) ) {

        enum_compare10(u1, User1Info);
        enum_compare10(u2, User2Info);
    }
    (VOID) NetApiBufferFree( UserEnum );
}




void
enum_compare11(ep, gp)
USER_INFO_11 *ep;
USER_INFO_2  *gp;
{
    if (ep->usri11_priv != gp->usri2_priv) {
        error_exit(FAIL, "NetUserEnum(11) priv mismatch enum", NULL);
    }

    if (ep->usri11_password_age == 0) {
        error_exit(FAIL, "NetUserEnum(11) password age is suspiciously zero",
                   NULL);
    }
    if (ep->usri11_password_age < gp->usri2_password_age) {
        printf( "Curr: %lx Prev: %lx\n",
            ep->usri11_password_age, gp->usri2_password_age);
        error_exit(FAIL, "NetUserEnum(11) password age mismatch enum", NULL);
    }

    CompareString( ep->usri11_home_dir,
                   gp->usri2_home_dir,
                   "NetUserEnum(11) home_dir",
                   NULL);

    CompareString( ep->usri11_parms,
                   gp->usri2_parms,
                   "NetUserEnum(11) parms",
                   NULL);

    CompareString( ep->usri11_usr_comment,
                   gp->usri2_usr_comment,
                   "NetUserEnum(11) usr_comment",
                   NULL);

    CompareString( ep->usri11_full_name,
                   gp->usri2_full_name,
                   "NetUserEnum(11) full_name",
                   NULL);

}





void
validate_enum11(
    PUSER_INFO_2 User1Info,
    PUSER_INFO_2 User2Info
    )
{
    USER_INFO_11 *u1, *u2;
    PUSER_INFO_11 UserEnum;

    //
    // check enum level 11
    //

    if (err = NetUserEnum(NULL, 11, ENUM_FILTER, (LPBYTE *)&UserEnum, 0xFFFFFFFF, &nread, &total, NULL)) {
        error_exit(FAIL, "NetUserEnum(11) validate_enum11", NULL);
        return;
    }

    if ( find_ptr((LPBYTE)UserEnum, (LPBYTE * ) & u1, (LPBYTE * ) & u2,
        sizeof(USER_INFO_11 ), 11) ) {

        enum_compare11(u1, User1Info);
        enum_compare11(u2, User2Info);
    }
    (VOID) NetApiBufferFree( UserEnum );
}

void
enum_compare20(ep, gp)
USER_INFO_20 *ep;
USER_INFO_3  *gp;
{

    CompareString( ep->usri20_full_name,
                   gp->usri3_full_name,
                   "NetUserEnum(20) full_name",
                   NULL);
}





void
validate_enum20(
    PUSER_INFO_3 User1Info,
    PUSER_INFO_3 User2Info
    )
{
    USER_INFO_20 *u1, *u2;
    PUSER_INFO_20 UserEnum;

    //
    // check enum level 20
    //

    if (err = NetUserEnum(NULL, 20, ENUM_FILTER, (LPBYTE *)&UserEnum, 0xFFFFFFFF, &nread, &total, NULL)) {
        error_exit(FAIL, "NetUserEnum(20) validate_enum20", NULL);
        return;
    }

    if ( find_ptr((LPBYTE)UserEnum, (LPBYTE * ) & u1, (LPBYTE * ) & u2,
        sizeof(USER_INFO_20 ), 20) ) {

        enum_compare20(u1, User1Info);
        enum_compare20(u2, User2Info);
    }

    (VOID) NetApiBufferFree( UserEnum );
}

void
validate_enum()
{
    NET_API_STATUS  err;
    PUSER_INFO_3 User1Info;
    PUSER_INFO_3 User2Info;

    if (err = NetUserGetInfo(server, USER1, 3, (LPBYTE *)&User1Info)) {
        error_exit(FAIL, "NetUserGetInfo(3) USER1 validate_enum", USER1);
        exit(1);
    }

    if (err = NetUserGetInfo(server, USER2, 3, (LPBYTE *)&User2Info)) {
        error_exit(FAIL, "NetUserGetInfo(3) USER2 validate_enum", USER2);
        exit(1);
    }

    //
    // check enum level X
    //

    validate_enum0( (PUSER_INFO_2) User1Info, (PUSER_INFO_2) User2Info );
    validate_enum1( (PUSER_INFO_2) User1Info, (PUSER_INFO_2) User2Info );
    validate_enum2( (PUSER_INFO_2) User1Info, (PUSER_INFO_2) User2Info );
    validate_enum3( (PUSER_INFO_3) User1Info, (PUSER_INFO_3) User2Info );
    validate_enum10( (PUSER_INFO_2) User1Info, (PUSER_INFO_2) User2Info );
    validate_enum11( (PUSER_INFO_2) User1Info, (PUSER_INFO_2) User2Info );
    validate_enum20( (PUSER_INFO_3) User1Info, (PUSER_INFO_3) User2Info );
    (VOID) NetApiBufferFree( User1Info );
    (VOID) NetApiBufferFree( User2Info );
}

void __cdecl
main(argc, argv)
int argc;
char    **argv;
{
    WCHAR * fred = L"fred";
    USER_INFO_1  ui1;
    PUSER_INFO_1 uo1p;
    USER_INFO_2  ui2;
    PUSER_INFO_2 uo2p;
    USER_INFO_3  ui3;
    PUSER_INFO_3 uo3p;

    testname = "UASTEST1";

    if (argv[1] != NULL)
        server = NetpLogonOemToUnicode(argv[1]);
    if (argc != 1)
        exit_flag = 1;

#ifdef UASP_LIBRARY
    printf( "Calling UaspInitialize\n");
    if (err = UaspInitialize()) {
        error_exit(FAIL, "UaspInitiailize failed", NULL );
    }
#endif // UASP_LIBRARY


    //
    // Delete user in add
    //

    error_exit(ACTION, "Clean up SAM database by deleting user", USER1 );
    if (err = NetUserDel(server, USER1)) {
        if (err != NERR_UserNotFound)
            error_exit(FAIL, "First cleanup user delete wrong", USER1);

        err = 0;
    }

    //
    // Delete user in add
    //

    error_exit(ACTION, "Clean up SAM database by deleting user", USER2 );
    if (err = NetUserDel(server, USER2)) {
        if (err != NERR_UserNotFound)
            error_exit(FAIL, "Second cleanup user delete wrong", USER2);

        err = 0;
    }

    //
    // Add a user using level 1
    //

    error_exit(ACTION, "Try NetUserAdd (level 1)", USER1 );
    set_level1(&ui1, USER1);

    if (err = NetUserAdd(server, 1, (LPBYTE) &ui1, NULL )) {
        exit_flag = 1;
        error_exit(FAIL, "NetUserAdd failed", USER1);

    } else
        error_exit(PASS, "NetUserAdd (level 1) successful", USER1);

    //
    // GetInfo on user who is not there
    //

    error_exit(ACTION,"Try NetUserGetInfo on non-existent user (level 1)",NULL);
    if (err = NetUserGetInfo(server, L"NotThere", 1, (LPBYTE *) &uo1p)) {
        if (err != NERR_UserNotFound)
            error_exit(FAIL, "NetUserGetInfo on NOTTHERE wrong", NULL);
        else
            error_exit(PASS, "GetInfo on Nonexistent User not found", NULL);
        err = 0;
    } else {
        error_exit(FAIL, "NetUserGetInfo succeeded on NOTTHERE", NULL);
        (VOID) NetApiBufferFree( uo1p );
    }

    //
    // GetInfo on user using level 1
    //

    error_exit(ACTION, "Try NetUserGetInfo (level 1) on created user", USER1 );
    if (err = NetUserGetInfo(server, USER1, 1, (LPBYTE *) &uo1p))
        error_exit(FAIL, "NetUserGetInfo(1) failed", USER1);
    else {
        error_exit(PASS, "NetUserGetInfo(1) successful", USER1);
        compare_level1(uo1p, &ui1, L"Test add level 1");
        (VOID) NetApiBufferFree( uo1p );
    }

    //
    // GetInfo on user using level 2
    //

    error_exit(ACTION, "Try NetUserGetInfo (level 2) on created user", USER1 );
    if (err = NetUserGetInfo(server, USER1, 2, (LPBYTE *) &uo2p))
        error_exit(FAIL, "NetUserGetInfo(2) failed", USER1);
    else {
        error_exit(PASS, "NetUserGetInfo(2) successful", USER1);

        //
        // Validate defaults
        //

        error_exit(ACTION, "Validate Defaults set at level 1 NetUserAdd", USER1);

        CompareString( uo2p->usri2_full_name,
                       uo2p->usri2_name,
                       "NetUserGetInfo(2) full_name default",
                       USER1);

        CompareString( uo2p->usri2_usr_comment,
                       L"",
                       "NetUserGetInfo(2) usr_comment default",
                       USER1);

        CompareString( uo2p->usri2_workstations,
                       L"",
                       "NetUserGetInfo(2) workstations default",
                       USER1);

        if (uo2p->usri2_acct_expires != 0xFFFFFFFF)
            error_exit(FAIL, "default account expires is not ALWAYS", USER1);
        else
            error_exit(PASS, "default account expires is ALWAYS", USER1);

        if (uo2p->usri2_max_storage != 0xFFFFFFFF)
            error_exit(FAIL, "default max storage is not MAX_ALLOWED", USER1);
        else
            error_exit(PASS, "default max storage is MAX_ALLOWED", USER1);

        if (memcmp(uo2p->usri2_logon_hours, default_logon_hours, 21)) {
            printf( "   Units_per_week: %ld\n", uo2p->usri2_units_per_week );
            printf( "   Logon Hours ptr: %lx\n", uo2p->usri2_logon_hours);
            error_exit(FAIL, "default logon hours is wrong", USER1);
        } else
            error_exit(PASS, "default logon hours is correct", USER1);

        //
        // Validate level 1 results
        //

        compare_level1((USER_INFO_1 * ) uo2p,
             &ui1, L"Test of Level2 GetInfo");
        (VOID) NetApiBufferFree( uo2p );
    }

    //
    // GetInfo on user using level 3
    //

    error_exit(ACTION, "Try NetUserGetInfo (level 3) on created user", USER1 );
    if (err = NetUserGetInfo(server, USER1, 3, (LPBYTE *) &uo3p))
        error_exit(FAIL, "NetUserGetInfo(3) failed", USER1);
    else {
        error_exit(PASS, "NetUserGetInfo(3) successful", USER1);

        //
        // Validate defaults
        //

        error_exit(ACTION, "Validate Defaults set at level 1 NetUserAdd",
                    USER1);

        CompareString( uo3p->usri3_profile,
                       L"",
                       "NetUserGetInfo(3) profile default",
                       USER1);

        CompareString( uo3p->usri3_home_dir_drive,
                       L"",
                       "NetUserGetInfo(3) home_dir_drive default",
                       USER1);
    }

    //
    // Delete user not there
    //

    error_exit(ACTION, "Try NetUserDel on non-existent user", USER1 );
    if (err = NetUserDel(server, NOTTHERE)) {
        if (err != NERR_UserNotFound)
            error_exit(FAIL, "NetUserDel of NOTTHERE failed", NULL);
        else
            error_exit(PASS, "NetUserDel of NOTTHERE not there", NULL);

        err = 0;
    } else
        error_exit(FAIL, "NetUserDel of NOTTHERE succeeded when should fail", NULL);

    //
    // Delete user in add
    //

    error_exit(ACTION, "Try NetUserDel on created user", USER1 );
    if (err = NetUserDel(server, USER1))
        error_exit(FAIL, "NetUserDel failed", USER1);
    else
        error_exit(PASS, "NetUserDel successful", USER1);

    //
    // Try again to Delete user in add
    //

    error_exit(ACTION, "Try NetUserDel again on newly deleted user", USER1 );
    if (err = NetUserDel(server, USER1)) {
        if (err != NERR_UserNotFound)
            error_exit(FAIL, "NetUserDel failed wrong", USER1);
        else
            error_exit(PASS, "NetUserDel of Deleted User, not there", USER1);

        err = 0;
    } else
        error_exit(PASS, "NetUserDel succeeded when already deleted", USER1);

    //
    // GetInfo on deleted user
    //

    error_exit(ACTION, "Try NetUserGetInfo on newly deleted user", USER1 );
    if (err = NetUserGetInfo(server, USER1, 2, (LPBYTE *) &uo2p)) {
        if (err != NERR_UserNotFound)
            error_exit(FAIL, "NetUserGetInfo(2) on deleted user", USER1);
        else
            error_exit(PASS, "GetInfo(2) on deleted user not there", USER1);
    } else {
        error_exit(FAIL, "NetUserGetInfo(1) of deleted user succeeded", USER1);
        (VOID) NetApiBufferFree( uo2p );
    }

    //
    // Add a user using level 2
    //

    error_exit(ACTION, "Try NetUserAdd (level 2)", USER1 );
    set_level1((USER_INFO_1 * ) &ui2, USER1);
    set_level2(&ui2);

    if (err = NetUserAdd(server, 2, (LPBYTE) &ui2, NULL ))
        error_exit(FAIL, "NetUserAdd (level 2) failed", USER1);
    else
        error_exit(PASS, "NetUserAdd (level 2) successful", USER1);

    //
    // Verify all data
    //

    error_exit(ACTION, "Try NetUserGetInfo (level 2)", USER1 );
    if (err = NetUserGetInfo(server, USER1, 2, (LPBYTE *) &uo2p)) {
        error_exit(FAIL, "NetUserGetInfo(2) failed", USER1);
    } else {
        compare_level1(
            (USER_INFO_1 * ) uo2p,
            (USER_INFO_1 * ) &ui2,
             L"Add user level2");
        compare_level2(uo2p, &ui2, L"Add user level2");
        (VOID) NetApiBufferFree( uo2p );
    }

    //
    // Delete user in add
    //

    error_exit(ACTION, "Try NetUserDel on created user", USER1 );
    if (err = NetUserDel(server, USER1))
        error_exit(FAIL, "NetUserDel failed", USER1);
    else
        error_exit(PASS, "NetUserDel successful", USER1);

    //
    // Add a user using level 3
    //

    error_exit(ACTION, "Try NetUserAdd (level 3)", USER1 );
    set_level1((USER_INFO_1 * ) &ui3, USER1);
    set_level2((USER_INFO_2 * ) &ui3);
    set_level3(&ui3);

    if (err = NetUserAdd(server, 3, (LPBYTE) &ui3, NULL ))
        error_exit(FAIL, "NetUserAdd (level 3) failed", USER1);
    else
        error_exit(PASS, "NetUserAdd (level 3) successful", USER1);

    //
    // Verify all data
    //

    error_exit(ACTION, "Try NetUserGetInfo (level 3)", USER1 );
    if (err = NetUserGetInfo(server, USER1, 3, (LPBYTE *) &uo3p)) {
        error_exit(FAIL, "NetUserGetInfo(3) failed", USER1);
    } else {
        compare_level1(
            (USER_INFO_1 * ) uo3p,
            (USER_INFO_1 * ) &ui3,
            L"Add user level3");
        compare_level2(
            (USER_INFO_2 *) uo3p,
            (USER_INFO_2 *) &ui3,
            L"Add user level3");
        compare_level3(uo3p, &ui3, L"Add user level3");
        (VOID) NetApiBufferFree( uo3p );
    }

    //
    // SetInfo on user not there
    //

    error_exit(ACTION, "Try NetUserSetInfo on non-existent user", NOTTHERE );
    set_level12((USER_INFO_1 * ) &ui2);
    set_level22(&ui2);
    if (err = NetUserSetInfo(server, NOTTHERE, 2, (LPBYTE)&ui2, NULL )) {
        if (err != NERR_UserNotFound)
            error_exit(FAIL, "SetInfo of NOTTHERE failed wrong", NULL);
        else
            error_exit(PASS, "SetInfo of NOTTHERE User, not there", NULL);

        err = 0;
    } else
        error_exit(FAIL, "SetInfo of NOTTHERE succeeded: should've failed", NULL);

    //
    // SetInfo on level 2 fields
    // This call will succeed only if password restrictions are
    // satisfied or password supplied is Null_Password indicating
    // no password change.
    //

    error_exit(ACTION, "Try NetUserSetInfo on created user", USER1 );
    if (err = NetUserSetInfo(server, USER1, 2, (LPBYTE)&ui2, NULL)) {
        error_exit(FAIL, "SetInfo (level 2, parmnum 0) failed", USER1);
    } else {
        error_exit(PASS, "SetInfo (level 2, parmnum 0) successful", USER1);

        //
        // Verify setinfo
        //

        if (err = NetUserGetInfo(server, USER1, 2, (LPBYTE *) &uo2p)) {
            error_exit(FAIL, "GetInfo(1) to verify SetInfo failed", USER1);
        } else {
            error_exit(PASS, "GetInfo(1) to verify SetInfo successful", USER1);

            compare_level1(
                (USER_INFO_1 * ) uo2p,
                (USER_INFO_1 * ) &ui2,
                L"Verify set info level2 fields");
            compare_level2(uo2p, &ui2, L"Verify set info level2 fields");
            (VOID) NetApiBufferFree( uo2p );
        }
    }

    //
    // test setinfo level 2 parmnums
    //

    test_setinfo_l2_parmnum();

    //
    // test add of duplicate record
    //

    set_level1((USER_INFO_1 * ) &ui2, USER1);
    set_level2(&ui2);

    if (err = NetUserAdd(server, 2, (LPBYTE) &ui2, NULL )) {
        if (err == NERR_UserExists) {
            error_exit(PASS, "NetUserAdd of duplicate OK", USER1);
        } else {
            error_exit(FAIL, "NetUserAdd of duplicate failed", USER1);
        }

        err = 0;
    } else
        error_exit(FAIL, "NetUserAdd of duplicate succeeded", USER1);

    //
    // add another user for enum test
    //

    set_level1((USER_INFO_1 * ) &ui2, USER2);
    set_level2(&ui2);

    if (err = NetUserAdd(server, 2, (LPBYTE) &ui2, NULL ))
        error_exit(FAIL, "NetUserAdd (level 2) failed", USER2);
    else
        error_exit(PASS, "NetUserAdd (level 2) successful", USER2);

    //
    // test NetUserGetInfo level 10, 11
    //

    test_getinfo_10_11_20();

    if (server == NULL) {

#ifdef USER_VAL // ?? UserValidate not implemented
        //
        // check UserValidate
        //

        test_user_val();
#endif // USER_VAL  // ?? UserValidate not implemented

        //
        // check NetUserEnum calls
        //

        validate_enum();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\uastest6.c ===
///**************************************************************
///          Microsoft LAN Manager          *
///        Copyright(c) Microsoft Corp., 1990-1992       *
///**************************************************************
//
//  Add and delete access record
//

#include <nt.h> // TIME definition
#include <ntrtl.h>      // TIME definition
#include <nturtl.h>     // TIME definition
#define NOMINMAX        // Avoid redefinition of min and max in stdlib.h
#include        <windef.h>

#include        <stdio.h>
#include        <stdlib.h>
#include        <string.h>
#include        <lmcons.h>
#include        <lmapibuf.h>
#include        <netlib.h>
#include        <netdebug.h>
#include        <lmaccess.h>
#include        <lmerr.h>

#include <ntsam.h>
#include <netlogon.h>
#include <logonp.h>


#define     TEST_USER1  L"USER1"
#define     TEST_PERM1  07
#define     TEST_PERM2  31
#define     TEST_PERM3  63
#define     TEST_RESOURCE   L"C:\\UASTEST"



//
//  AddAccess
//
//
void
AddAccess(server, username, resource, perms)
LPWSTR   server;
LPWSTR   resource;
LPWSTR   username;
DWORD    perms;
{
    NET_API_STATUS err;
    char    ebuf[512];
    PACCESS_INFO_1 acc = (PACCESS_INFO_1) ebuf;
    PACCESS_LIST acl;


    acc->acc1_resource_name = resource;
    acc->acc1_attr = 1;
    acc->acc1_count = 1;

    acl = (PACCESS_LIST) (ebuf + sizeof(ACCESS_INFO_1));
    acl->acl_ugname = username;
    acl->acl_access = perms;

    if (err = NetAccessAdd(server, 1, ebuf, NULL ))
        NetpKdPrint(("NetAccessAdd failed, ret = %d\n", err));
    else
        NetpKdPrint(("%ws added successfully\n", resource));
}


//
//  DelAccess
//
void
DelAccess(server, resource)
LPWSTR server;
LPWSTR resource;
{
    NET_API_STATUS err;

    if (err = NetAccessDel(server, resource))
        NetpKdPrint(("NetAccessDel failed, ret = %d\n", err));
    else
        NetpKdPrint(("%ws deleted successfully\n", resource));
}


//
//  GetAccess
//
void
GetAccess(server, resource)
LPWSTR server;
LPWSTR resource;
{
    NET_API_STATUS err;
    LPBYTE buf;
    DWORD   level;



    for (level = 0; level < 2; level++) {
        if (err = NetAccessGetInfo(server, resource, level, &buf))
            NetpKdPrint(("NetAccessGetInfo failed, ret = %d\n", err));
        else {
            NetpKdPrint(("NetAccessGetInfo: Level %d OK\n", level));
            NetApiBufferFree( buf );
        }
    }
}


//
//  main driver for NetAccessAdd and NetAccessDel tests
//
//
void
main(argc, argv)
int argc;
char    **argv;
{
    LPWSTR resource;
    LPWSTR user;
    LPWSTR server;
    DWORD   perm;

    if ((argc == 1) || (*argv[1] == '?')) {
        printf("usage: uastest6 resource user perms server\n");
        exit(0);
    }

    resource = TEST_RESOURCE;
    user = TEST_USER1;
    perm = TEST_PERM1;
    server = NULL;

    if (argv[1] != NULL) {
        resource = NetpLogonOemToUnicode(argv[1]);
        if (argv[2] != NULL) {
            user = NetpLogonOemToUnicode(argv[2]);
            if (argv[3] != NULL) {
                perm = atoi(argv[3]) & 0x3F;
                if (argv[4] != NULL)
                    server = NetpLogonOemToUnicode(argv[4]);
            }
        }
    }

    AddAccess(server, user, resource, perm);

    GetAccess(server, resource);

    DelAccess(server, resource);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\uastestm.c ===
#include <nt.h> // TIME definition
#include <ntrtl.h>      // TIME definition
#include <nturtl.h>     // TIME definition
#define NOMINMAX        // Avoid redefinition of min and max in stdlib.h
#include        <windef.h>
#include        <winbase.h>

#include        <stdio.h>
#include        <lmcons.h>
#include        <netlib.h>
#include        <netdebug.h>

#define UASTEST_ALLOCATE
#include        "uastest.h"

void PrintUnicode(
    LPWSTR string
    )
{

    if ( string != NULL ) {
        printf( "%ws", string );
    } else {
        printf( "<null>" );
    }
}

//
// Print error when two dwords are different
//
void TestDiffDword(
    char *msgp,
    LPWSTR namep,
    DWORD Actual,
    DWORD Good
    )
{

    if ( Actual != Good ) {
        error_exit( FAIL, msgp, namep );
        printf( "        %ld should be %ld\n", Actual, Good );
    }
}

//
//  error_exit      print the error message and exit if EXIT_FLAG set
//

void
error_exit(
    int type,
    char    *msgp,
    LPWSTR namep
    )
{
    printf("%s: ", testname );

    if ( type == ACTION ) {
        printf( "ACTION - " );
    } else if ( type == FAIL ) {
        printf( "FAIL - " );
    } else if ( type == PASS ) {
        printf( "PASS - " );
    }

    if ( namep != NULL ) {
        PrintUnicode( namep );
        printf( ": ");
    }

    printf("%s", msgp);

    if ( type != ACTION && err != 0) {
        printf(" Error = %d", err);
        if ( err == ERROR_INVALID_PARAMETER ) {
            printf(" ParmError = %d", ParmError );
        }
            
    }

    printf("\n");

    if ( type == FAIL ) {
        // NetpAssert(FALSE);
        TEXIT;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\uastest3.c ===
///**************************************************************
///          Microsoft LAN Manager          *
///        Copyright(c) Microsoft Corp., 1990-1992       *
///**************************************************************
//
//  This program is designed to do functional testing on the following
//  APIs:
//      NetUserModalsGet
//      NetUserModalsSet
//
//  This test can be run independently of other tests.
//
//

#include <nt.h> // TIME definition
#include <ntrtl.h>      // TIME definition
#include <nturtl.h>     // TIME definition
#define NOMINMAX        // Avoid redefinition of min and max in stdlib.h
#include        <windef.h>
#include        <winbase.h>

#include        <stdio.h>
#include        <stdlib.h>
#include        <string.h>
#include        <lmcons.h>
#include        <lmapibuf.h>
#include        <netlib.h>
#include        <netdebug.h>
#include        <lmaccess.h>
#include        <lmerr.h>
#include <ntsam.h>

#include        "uastest.h"
#include "accessp.h"
#include "netlogon.h"
#include "logonp.h"

#define TEST_MIN_PWLEN  2
#define TEST_MAX_PWAGE  0xDDDDDDDD
#define TEST_MIN_PWAGE  0x00000222
#define TEST_FORCE_LOGOFF 0xEEEEEEEE
#define TEST_MAX_PWHIST 7
#define COMPUTERNAME    "STAND_ALONE"
#define DEF_COMPNAME    "COMPNAME"


char    rbuf[1024];
char    ibuf[1024];
char    obuf[1024];
char    ibuf2[1024];
char    obuf2[1024];




void
test_init_modals()
{
    PUSER_MODALS_INFO_0 um0p;

    //
    // test with invalid level
    //

    if (err = NetUserModalsGet(server, 3, (LPBYTE *) &um0p)) {
        if (err != ERROR_INVALID_LEVEL) {
            error_exit( FAIL, "UserModalsGet invalid level wrong", NULL);
        } else {
            error_exit( PASS, "UserModalsGet invalid level OK", NULL);
        }
    } else {
        error_exit( FAIL, "UserModalsGet with invalid level succeeded", NULL);
        NetApiBufferFree( um0p );
    }

    //
    // get valid level
    //

    if (err = NetUserModalsGet(server, 0, (LPBYTE *) &um0p))
        error_exit( FAIL, "First UserModalsGet failed", NULL);
    else {
        error_exit( PASS, "First UserModalsGet successful", NULL);

        //
        // verify initial settings
        //

        TestDiffDword( "Min password default mismatch", NULL,
                       um0p->usrmod0_min_passwd_len, DEF_MIN_PWLEN );

        TestDiffDword( "Max password age default mismatch", NULL,
                        um0p->usrmod0_max_passwd_age, DEF_MAX_PWAGE );

        TestDiffDword( "Min password age default mismatch", NULL,
                        um0p->usrmod0_min_passwd_age, DEF_MIN_PWAGE );

        TestDiffDword( "Force logooff default mismatch", NULL,
                        um0p->usrmod0_force_logoff, DEF_FORCE_LOGOFF );

        TestDiffDword( "Password history length default mismatch", NULL,
                        um0p->usrmod0_password_hist_len, DEF_MAX_PWHIST );

        NetApiBufferFree( um0p );
    }

}

VOID
restore_original_modals( VOID )
{
    PUSER_MODALS_INFO_0 um0p;
    USER_MODALS_INFO_0 um0;


    //
    // attempt to restore original (default) settings
    //

    um0.usrmod0_min_passwd_len = DEF_MIN_PWLEN;
    um0.usrmod0_max_passwd_age = DEF_MAX_PWAGE;
    um0.usrmod0_min_passwd_age = DEF_MIN_PWAGE;
    um0.usrmod0_force_logoff = DEF_FORCE_LOGOFF;
    um0.usrmod0_password_hist_len = DEF_MAX_PWHIST;

    if (err = NetUserModalsSet(server, 0, (LPBYTE) &um0, &ParmError ))
        error_exit( FAIL, "UserModalsSet (restore) Failed", NULL);

    //
    // verify reset
    //

    if (err = NetUserModalsGet(server, 0, (LPBYTE *) &um0p)) {
        error_exit( FAIL, "Verify UserModalsGet failed", NULL);
    } else {

        TestDiffDword( "Min password default mismatch", NULL,
                       um0p->usrmod0_min_passwd_len, DEF_MIN_PWLEN );

        TestDiffDword( "Max password age default mismatch", NULL,
                        um0p->usrmod0_max_passwd_age, DEF_MAX_PWAGE );

        TestDiffDword( "Min password age default mismatch", NULL,
                        um0p->usrmod0_min_passwd_age, DEF_MIN_PWAGE );

        TestDiffDword( "Force logooff default mismatch", NULL,
                        um0p->usrmod0_force_logoff, DEF_FORCE_LOGOFF );

        TestDiffDword( "Password history length default mismatch", NULL,
                        um0p->usrmod0_password_hist_len, DEF_MAX_PWHIST );

        NetApiBufferFree( um0p );
    }
}



void
test_set_modals()
{
    PUSER_MODALS_INFO_0 um0p = (PUSER_MODALS_INFO_0 ) ibuf;
    USER_MODALS_INFO_0 um0;


    //
    // set with invalid level
    //

    if (err = NetUserModalsSet(server, 3, (LPBYTE) &um0, &ParmError )) {
        if (err != ERROR_INVALID_LEVEL)
            error_exit(FAIL, "UserModalsSet invalid level wrong", NULL);
    } else
        error_exit(FAIL, "UserModalsSet with invalid level succeeded", NULL);

    //
    // setup data for update
    //

    um0.usrmod0_min_passwd_len = TEST_MIN_PWLEN;
    um0.usrmod0_max_passwd_age = TEST_MAX_PWAGE;
    um0.usrmod0_min_passwd_age = TEST_MIN_PWAGE;
    um0.usrmod0_force_logoff = TEST_FORCE_LOGOFF;
    um0.usrmod0_password_hist_len = TEST_MAX_PWHIST;


    //
    // set with valid level
    //

    if (err = NetUserModalsSet(server, 0, (LPBYTE) &um0, &ParmError ))
        error_exit(FAIL, "UserModalsSet invalid", NULL);
    else {
        error_exit( PASS, "NetUserModalsSet level 0 OK", NULL);

        //
        // verify set data
        //

        if (err = NetUserModalsGet(server, 0, (LPBYTE *) &um0p)) {
            error_exit(FAIL, "Verify UserModalsGet failed", NULL);
        } else {


            //
            // verify initial settings
            //

            TestDiffDword( "Min password test mismatch", NULL,
                        um0p->usrmod0_min_passwd_len, TEST_MIN_PWLEN );

            TestDiffDword( "Max password age test mismatch", NULL,
                            um0p->usrmod0_max_passwd_age, TEST_MAX_PWAGE );

            TestDiffDword( "Min password age test mismatch", NULL,
                            um0p->usrmod0_min_passwd_age, TEST_MIN_PWAGE );

            TestDiffDword( "Force logooff test mismatch", NULL,
                            um0p->usrmod0_force_logoff, TEST_FORCE_LOGOFF );

            TestDiffDword( "Password history length test mismatch", NULL,
                            um0p->usrmod0_password_hist_len, TEST_MAX_PWHIST );

            NetApiBufferFree( um0p );
        }
    }


    //
    // attempt to restore original (default) settings
    //

    restore_original_modals( );

}


//
//  test_set_modals_1(parmnum)
//

void
test_set_modals_1(parmnum)
short   parmnum;
{
    PUSER_MODALS_INFO_0 um0p;
    USER_MODALS_INFO_1001 um1001;
    USER_MODALS_INFO_1002 um1002;
    USER_MODALS_INFO_1003 um1003;
    USER_MODALS_INFO_1004 um1004;
    USER_MODALS_INFO_1005 um1005;
    LPBYTE Parameter;
    LPWSTR LevelText;

    //
    // setup data for update
    //

    switch (parmnum) {
    case 1001:
        um1001.usrmod1001_min_passwd_len = TEST_MIN_PWLEN;
        LevelText = L"Parmnum 1001";
        Parameter = (LPBYTE) &um1001;
        break;

    case 1002:
        um1002.usrmod1002_max_passwd_age = TEST_MAX_PWAGE;
        LevelText = L"Parmnum 1002";
        Parameter = (LPBYTE) &um1002;
        break;


    case 1003:
        um1003.usrmod1003_min_passwd_age = TEST_MIN_PWAGE;
        LevelText = L"Parmnum 1003";
        Parameter = (LPBYTE) &um1003;
        break;


    case 1004:
        um1004.usrmod1004_force_logoff = TEST_FORCE_LOGOFF;
        LevelText = L"Parmnum 1004";
        Parameter = (LPBYTE) &um1004;
        break;


    case 1005:
        um1005.usrmod1005_password_hist_len = TEST_MAX_PWHIST;
        LevelText = L"Parmnum 1005";
        Parameter = (LPBYTE) &um1005;
        break;


    default:
        error_exit(FAIL, "Invalid parmnum internal error", NULL);
        return;
    }

    if (err = NetUserModalsSet(server, parmnum, Parameter, &ParmError)) {
        error_exit(FAIL, "UserModalsSet invalid", LevelText);
    } else {
        error_exit(PASS, "UserModalsSet successful", LevelText);

        //
        // verify set data
        //

        if (err = NetUserModalsGet(server, 0, (LPBYTE *) &um0p)) {
            error_exit(FAIL, "Verify UserModalsGet failed", NULL);

        } else {

            //
            // verify initial settings
            //

            switch (parmnum) {
            case 1001:
                TestDiffDword( "Min password test mismatch", LevelText,
                                um0p->usrmod0_min_passwd_len, TEST_MIN_PWLEN );
                break;
            case 1002:
                TestDiffDword( "Max password age test mismatch", LevelText,
                                um0p->usrmod0_max_passwd_age, TEST_MAX_PWAGE );
                break;
            case 1003:
                TestDiffDword( "Min password age test mismatch", LevelText,
                                um0p->usrmod0_min_passwd_age, TEST_MIN_PWAGE );
                break;
            case 1004:
                TestDiffDword( "Force logooff test mismatch", LevelText,
                                um0p->usrmod0_force_logoff, TEST_FORCE_LOGOFF );
                break;
            case 1005:
                TestDiffDword( "Password history length test mismatch", LevelText,
                            um0p->usrmod0_password_hist_len, TEST_MAX_PWHIST );
                break;
            default:
                printf("uastest1:Invalid Parmnum %d\n", parmnum);
            }

            NetApiBufferFree( um0p );

        }
    }

    //
    // attempt to restore original (default) settings
    //

    restore_original_modals( );

}




void
main(argc, argv)
int argc;
char    **argv;
{
    short   i;
    testname = "UASTEST3";

    if (argv[1] != NULL)
        server = NetpLogonOemToUnicode(argv[1]);

    if (argc > 1)
        exit_flag = 1;

#ifdef UASP_LIBRARY
    printf( "Calling UaspInitialize\n");
    if (err = UaspInitialize()) {
        error_exit(FAIL,  "UaspInitiailize failed", NULL );
    }
#endif // UASP_LIBRARY

    error_exit(ACTION, "test_init_modals()", NULL );
    test_init_modals();

    error_exit(ACTION, "test_set_modals()", NULL );
    test_set_modals();

    error_exit(ACTION, "test_set_modals_1()", NULL );
    for (i = 1001; i < 1005; i++) {
        test_set_modals_1(i);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\user.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    user.c

Abstract:

    NetUser API functions

Author:

    Cliff Van Dyke (cliffv) 26-Mar-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    17-Apr-1991 (cliffv)
        Incorporated review comments.

    20-Jan-1992 (madana)
        Sundry API changes

    28-Nov-1992 (chuckc)
        Added stub for NetUserGetLocalGroups

    1-Dec-1992 (chuckc)
        Added real code for NetUserGetLocalGroups

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef DOMAIN_ALL_ACCESS // defined in both ntsam.h and ntwinapi.h
#include <ntsam.h>
#include <ntlsa.h>

#include <windef.h>
#include <winbase.h>
#include <lmcons.h>

#include <access.h>
#include <align.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <crypt.h>
#include <ntmsv1_0.h>
#include <limits.h>
#include <netdebug.h>
#include <netlib.h>
#include <netlibnt.h>
#include <rpcutil.h>
#include <rxuser.h>
#include <secobj.h>
#include <stddef.h>
#include <uasp.h>
#include <accessp.h>

/*lint -e614 */  /* Auto aggregate initializers need not be constant */

// Lint complains about casts of one structure type to another.
// That is done frequently in the code below.
/*lint -e740 */  /* don't complain about unusual cast */



//
// Define the SAM info classes and pseudo-classes used in NetUserModalsSet.
//
// The values of these definitions must match the order of the
// SamInfoClass array in NetUserModalsSet.
//
#define SAM_LogoffClass         0
#define SAM_NameClass           1
#define SAM_PasswordClass       2
#define SAM_ReplicationClass    3
#define SAM_ServerRoleClass     4
#define SAM_LockoutClass        5

//
// Relate the NetUser API fields to the SAM API fields.
//
// This table contains as much information as possible to describe the
// relationship between fields in the NetUser API and the SAM API.
//

struct _USER_UAS_SAM_TABLE {

    //
    // Describe the field types for UAS and SAM.
    //

    enum {
        UMT_STRING,          // UAS is LPWSTR. SAM is UNICODE_STRING.
        UMT_USHORT,          // UAS is DWORD.  SAM is USHORT.
        UMT_ULONG,           // UAS is DWORD.  SAM is ULONG.
        UMT_ROLE,           // UAS is role.   SAM is enum.
        UMT_DELTA            // UAS is delta seconds.  SAM is LARGE_INTEGER.
    } ModalsFieldType;

    //
    // Define the UAS level and UAS parmnum for this field
    //

    DWORD UasLevel;
    DWORD UasParmNum;

    //
    // Describe the byte offset of the field in the appropriate UAS
    // and SAM structures.
    //

    DWORD UasOffset;
    DWORD SamOffset;

    //
    // Index to the structure describing the Sam Information class.
    //
    // If multiple fields use the same Sam information class, then
    // this field should have the same index for each such field.
    //

    DWORD Class;

} UserUasSamTable[] = {

    { UMT_USHORT, 0, MODALS_MIN_PASSWD_LEN_PARMNUM,
        offsetof( USER_MODALS_INFO_0, usrmod0_min_passwd_len ),
        offsetof( DOMAIN_PASSWORD_INFORMATION, MinPasswordLength ),
        SAM_PasswordClass },

    { UMT_USHORT, 1001, MODALS_MIN_PASSWD_LEN_PARMNUM,
        offsetof( USER_MODALS_INFO_1001, usrmod1001_min_passwd_len ),
        offsetof( DOMAIN_PASSWORD_INFORMATION, MinPasswordLength ),
        SAM_PasswordClass },



    { UMT_DELTA, 0, MODALS_MAX_PASSWD_AGE_PARMNUM,
        offsetof( USER_MODALS_INFO_0, usrmod0_max_passwd_age ),
        offsetof( DOMAIN_PASSWORD_INFORMATION, MaxPasswordAge ),
        SAM_PasswordClass },

    { UMT_DELTA, 1002, MODALS_MAX_PASSWD_AGE_PARMNUM,
        offsetof( USER_MODALS_INFO_1002, usrmod1002_max_passwd_age ),
        offsetof( DOMAIN_PASSWORD_INFORMATION, MaxPasswordAge ),
        SAM_PasswordClass },


    { UMT_DELTA, 0, MODALS_MIN_PASSWD_AGE_PARMNUM,
        offsetof( USER_MODALS_INFO_0, usrmod0_min_passwd_age ),
        offsetof( DOMAIN_PASSWORD_INFORMATION, MinPasswordAge ),
        SAM_PasswordClass },

    { UMT_DELTA, 1003, MODALS_MIN_PASSWD_AGE_PARMNUM,
        offsetof( USER_MODALS_INFO_1003, usrmod1003_min_passwd_age ),
        offsetof( DOMAIN_PASSWORD_INFORMATION, MinPasswordAge ),
        SAM_PasswordClass },


    { UMT_DELTA, 0, MODALS_FORCE_LOGOFF_PARMNUM,
        offsetof( USER_MODALS_INFO_0, usrmod0_force_logoff ),
        offsetof( DOMAIN_LOGOFF_INFORMATION, ForceLogoff ),
        SAM_LogoffClass },

    { UMT_DELTA, 1004, MODALS_FORCE_LOGOFF_PARMNUM,
        offsetof( USER_MODALS_INFO_1004, usrmod1004_force_logoff ),
        offsetof( DOMAIN_LOGOFF_INFORMATION, ForceLogoff ),
        SAM_LogoffClass },


    { UMT_USHORT, 0, MODALS_PASSWD_HIST_LEN_PARMNUM,
        offsetof( USER_MODALS_INFO_0, usrmod0_password_hist_len ),
        offsetof( DOMAIN_PASSWORD_INFORMATION, PasswordHistoryLength ),
        SAM_PasswordClass },

    { UMT_USHORT, 1005, MODALS_PASSWD_HIST_LEN_PARMNUM,
        offsetof( USER_MODALS_INFO_1005, usrmod1005_password_hist_len ),
        offsetof( DOMAIN_PASSWORD_INFORMATION, PasswordHistoryLength ),
        SAM_PasswordClass },


    { UMT_ROLE, 1, MODALS_ROLE_PARMNUM,
        offsetof( USER_MODALS_INFO_1, usrmod1_role ),
        offsetof( DOMAIN_SERVER_ROLE_INFORMATION, DomainServerRole ),
        SAM_ServerRoleClass },

    { UMT_ROLE, 1006, MODALS_ROLE_PARMNUM,
        offsetof( USER_MODALS_INFO_1006, usrmod1006_role ),
        offsetof( DOMAIN_SERVER_ROLE_INFORMATION, DomainServerRole ),
        SAM_ServerRoleClass },


    { UMT_STRING, 1, MODALS_PRIMARY_PARMNUM,
        offsetof( USER_MODALS_INFO_1, usrmod1_primary ),
        offsetof( DOMAIN_REPLICATION_INFORMATION, ReplicaSourceNodeName ),
        SAM_ReplicationClass },

    { UMT_STRING, 1007, MODALS_PRIMARY_PARMNUM,
        offsetof( USER_MODALS_INFO_1007, usrmod1007_primary ),
        offsetof( DOMAIN_REPLICATION_INFORMATION, ReplicaSourceNodeName ),
        SAM_ReplicationClass },



    { UMT_STRING, 2, MODALS_DOMAIN_NAME_PARMNUM,
        offsetof( USER_MODALS_INFO_2, usrmod2_domain_name ),
        offsetof( DOMAIN_NAME_INFORMATION, DomainName ),
        SAM_NameClass },

    { UMT_DELTA, 3, MODALS_LOCKOUT_DURATION_PARMNUM,
        offsetof( USER_MODALS_INFO_3, usrmod3_lockout_duration ),
        offsetof( DOMAIN_LOCKOUT_INFORMATION, LockoutDuration ),
        SAM_LockoutClass },

    { UMT_DELTA, 3, MODALS_LOCKOUT_OBSERVATION_WINDOW_PARMNUM,
        offsetof( USER_MODALS_INFO_3, usrmod3_lockout_observation_window ),
        offsetof( DOMAIN_LOCKOUT_INFORMATION, LockoutObservationWindow ),
        SAM_LockoutClass },

    { UMT_USHORT, 3, MODALS_LOCKOUT_THRESHOLD_PARMNUM,
        offsetof( USER_MODALS_INFO_3, usrmod3_lockout_threshold ),
        offsetof( DOMAIN_LOCKOUT_INFORMATION, LockoutThreshold ),
        SAM_LockoutClass },

};


NET_API_STATUS NET_API_FUNCTION
NetUserAdd(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD Level,
    IN LPBYTE Buffer,
    OUT LPDWORD ParmError OPTIONAL // Name required by NetpSetParmError
    )

/*++

Routine Description:

    Create a user account in the user accounts database.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    Level - Level of information provided.  Must be 1, 2, 3 or 22.

    Buffer - A pointer to the buffer containing the user information
        structure.

    ParmError - Optional pointer to a DWORD to return the index of the
        first parameter in error when ERROR_INVALID_PARAMETER is returned.
        If NULL, the parameter is not returned on error.

Return Value:

    Error code for the operation.

--*/

{
    UNICODE_STRING UserNameString;
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE UserHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    ULONG RelativeId;
    ULONG GrantedAccess;
    ULONG NewSamAccountType;
    DWORD UasUserFlags;
    ULONG WhichFieldsMask = 0xFFFFFFFF;


    //
    // Variables for building the new user's Sid
    //

    PSID DomainId = NULL;            // Domain Id of the primary domain

    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "NetUserAdd: entered \n"));
    }

    //
    // Initialize
    //

    NetpSetParmError( PARM_ERROR_NONE );

    //
    // Validate Level parameter.
    //

    switch (Level) {
    case 1:
    case 2:
    case 3:
    case 4:
        NetpAssert ( offsetof( USER_INFO_1, usri1_flags ) ==
                     offsetof( USER_INFO_2, usri2_flags ) );
        NetpAssert ( offsetof( USER_INFO_1, usri1_flags ) ==
                     offsetof( USER_INFO_3, usri3_flags ) );
        NetpAssert ( offsetof( USER_INFO_1, usri1_flags ) ==
                     offsetof( USER_INFO_4, usri4_flags ) );

        UasUserFlags = ((PUSER_INFO_1)Buffer)->usri1_flags;
        break;

    case 22:
        UasUserFlags = ((PUSER_INFO_22)Buffer)->usri22_flags;
        break;

    default:
        return ERROR_INVALID_LEVEL;  // Nothing to cleanup yet
    }


    //
    // Determine the account type we're creating.
    //

    if( UasUserFlags & UF_ACCOUNT_TYPE_MASK ) {

        //
        // Account Types bits are exclusive, so make sure that
        // precisely one Account Type bit is set.
        //

        if ( !JUST_ONE_BIT( UasUserFlags & UF_ACCOUNT_TYPE_MASK )) {

            NetpSetParmError( USER_FLAGS_PARMNUM );
            NetStatus = ERROR_INVALID_PARAMETER;
            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint((
                    "NetUserAdd: Invalid account control bits (2) \n" ));
            }
            goto Cleanup;
        }


        //
        // Determine what the new account type should be.
        //

        if ( UasUserFlags & UF_TEMP_DUPLICATE_ACCOUNT ) {
            NewSamAccountType = USER_TEMP_DUPLICATE_ACCOUNT;

        } else if ( UasUserFlags & UF_NORMAL_ACCOUNT ) {
            NewSamAccountType = USER_NORMAL_ACCOUNT;

        } else if (UasUserFlags & UF_WORKSTATION_TRUST_ACCOUNT){
            NewSamAccountType = USER_WORKSTATION_TRUST_ACCOUNT;

        // Because of a bug in NT 3.5x, we have to initially create SERVER
        // and interdomain trust accounts as normal accounts and change them
        // later.  Specifically, SAM didn't call I_NetNotifyMachineAccount
        // in SamCreateUser2InDomain.  Therefore, netlogon didn't get notified
        // of the change.  That bug is fixed in NT 4.0.
        //
        // In NT 5.0, we relaxed that restriction for BDC accounts.  An NT 5.0
        // client creating a BDC account on an NT 3.5x DC will have the problem
        // above.  However, by making the change, an NT 5.0 BDC creating a BDC
        // account on an NT 5.0 DC will properly create the BDC account as a
        // Computer object.
        //

        } else if ( UasUserFlags & UF_SERVER_TRUST_ACCOUNT ) {
            NewSamAccountType = USER_SERVER_TRUST_ACCOUNT;

        } else if (UasUserFlags & UF_INTERDOMAIN_TRUST_ACCOUNT){
            NewSamAccountType = USER_NORMAL_ACCOUNT;

        } else {

            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint((
                    "NetUserAdd: Invalid account type (3)\n"));
            }

            NetStatus = NERR_InternalError;
            goto Cleanup;
        }


    //
    //  If SAM has none of its bits set,
    //      set USER_NORMAL_ACCOUNT.
    //
    } else {
        NewSamAccountType = USER_NORMAL_ACCOUNT;
    }

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetUserAdd: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the Domain asking for DOMAIN_CREATE_USER access.
    //
    //  DOMAIN_LOOKUP is needed to lookup group memberships later.
    //
    //  DOMAIN_READ_PASSWORD_PARAMETERS is needed in those cases that we'll
    //  set the password on the account.
    //

    NetStatus = UaspOpenDomain(
                    SamServerHandle,
                    DOMAIN_CREATE_USER | DOMAIN_LOOKUP |
                    DOMAIN_READ_PASSWORD_PARAMETERS,
                    TRUE,   // Account Domain
                    &DomainHandle,
                    &DomainId );


    if ( NetStatus == ERROR_ACCESS_DENIED &&
         NewSamAccountType == USER_WORKSTATION_TRUST_ACCOUNT ) {

        // Workstation accounts can be created with either DOMAIN_CREATE_USER access
        // or SE_CREATE_MACHINE_ACCOUNT_PRIVILEGE.  So we'll try both.
        // In the later case, we probably will only have access to the account
        // to set the password, so we'll avoid setting any other parameters on the
        // account.
        //

        NetStatus = UaspOpenDomain(
                        SamServerHandle,
                        DOMAIN_LOOKUP | DOMAIN_READ_PASSWORD_PARAMETERS,
                        TRUE,   // Account Domain
                        &DomainHandle,
                        &DomainId );

        WhichFieldsMask = USER_ALL_NTPASSWORDPRESENT;

    }

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetUserAdd: UaspOpenDomain returns %ld\n",
                      NetStatus ));
        }
        goto Cleanup;
    }



    //
    // Create the User with the specified name
    //   Create workstation trust accounts(and default security descriptor).
    //

    RtlInitUnicodeString( &UserNameString, ((PUSER_INFO_1)Buffer)->usri1_name );

    Status = SamCreateUser2InDomain(
                DomainHandle,
                &UserNameString,
                NewSamAccountType,
                GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE |
                    WRITE_DAC | DELETE | USER_FORCE_PASSWORD_CHANGE |
                    USER_READ_ACCOUNT | USER_WRITE_ACCOUNT,
                &UserHandle,
                &GrantedAccess,
                &RelativeId );

    if ( !NT_SUCCESS(Status) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetUserAdd: SamCreateUserInDomain rets %lX\n",
                      Status ));
        }
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }



    //
    // Set all the other attributes for this user
    //

    NetStatus = UserpSetInfo(
                    DomainHandle,
                    DomainId,
                    UserHandle,
                    NULL,   // BuiltinDomainHandle not needed for create case
                    RelativeId,
                    ((PUSER_INFO_1)Buffer)->usri1_name,
                    Level,
                    Buffer,
                    WhichFieldsMask,
                    ParmError );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetUserAdd: UserpSetInfo returns %ld\n",
                      NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Done
    //

    NetStatus = NERR_Success;

    //
    // Clean up
    //

Cleanup:
    //
    // Delete the user or close the handle depending on success or failure.
    //

    if ( UserHandle != NULL ) {
        if ( NetStatus != NERR_Success ) {
            (VOID) SamDeleteUser( UserHandle );
        } else {
            (VOID) SamCloseHandle( UserHandle );
        }
    }

    //
    // Free locally used resources.
    //

    if ( DomainHandle != NULL ) {

        UaspCloseDomain( DomainHandle );
    }

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    if ( DomainId != NULL ) {
        NetpMemoryFree( DomainId );
    }


    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetUserAdd( (LPWSTR) ServerName, Level, Buffer, ParmError );

    UASP_DOWNLEVEL_END;


    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "NetUserAdd: returning %ld\n", NetStatus ));
    }

    return NetStatus;

} // NetUserAdd


NET_API_STATUS NET_API_FUNCTION
NetUserDel(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR UserName
    )

/*++

Routine Description:

    Delete a User

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    UserName - Name of the user to delete.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAM_HANDLE BuiltinDomainHandle = NULL;
    SAM_HANDLE UserHandle = NULL;
    PSID DomainId = NULL;           // Domain Id of the primary domain
    ULONG UserRelativeId;           // RelativeId of the user being deleted
    PSID UserSid = NULL;

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetUserDel: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }


    //
    // Open the Domain
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_LOOKUP,
                                TRUE,   // Account Domain
                                &DomainHandle,
                                &DomainId );

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // Open the Builtin Domain.
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_LOOKUP,
                                FALSE,  // Builtin Domain
                                &BuiltinDomainHandle,
                                NULL ); // DomainId

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // Open the user asking for delete access.
    //

    NetStatus = UserpOpenUser( DomainHandle,
                               DELETE,
                               UserName,
                               &UserHandle,
                               &UserRelativeId );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetUserDel: UserpOpenUser returns %ld\n",
                       NetStatus ));
        }
        goto Cleanup;
    }


    //
    // Determine the SID of the User being deleted.
    //

    NetStatus = NetpSamRidToSid( UserHandle,
                                 UserRelativeId,
                                &UserSid );

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }


    //
    // Delete any aliases to this user from the Builtin domain
    //

    Status = SamRemoveMemberFromForeignDomain( BuiltinDomainHandle,
                                               UserSid );


    if ( !NT_SUCCESS(Status) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint((
               "NetUserDel: SamRemoveMembershipFromForeignDomain returns %lX\n",
                 Status ));
        }

        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }


    //
    // Delete the user.
    //

    Status = SamDeleteUser( UserHandle );

    if ( !NT_SUCCESS(Status) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetUserDel: SamDeleteUser returns %lX\n", Status ));
        }

        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    NetStatus = NERR_Success;
    UserHandle = NULL;  // Don't touch the handle to a deleted user

    //
    // Clean up.
    //

Cleanup:
    if ( UserHandle != NULL ) {
        (VOID) SamCloseHandle( UserHandle );
    }

    if ( DomainHandle != NULL ) {
        UaspCloseDomain( DomainHandle );
    }

    if ( BuiltinDomainHandle != NULL ) {
        UaspCloseDomain( BuiltinDomainHandle );
    }

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    if ( DomainId != NULL ) {
        NetpMemoryFree( DomainId );
    }

    if ( UserSid != NULL ) {
        NetpMemoryFree( UserSid );
    }


    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetUserDel( (LPWSTR)ServerName, (LPWSTR)UserName );

    UASP_DOWNLEVEL_END;


    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "NetUserDel: returning %ld\n", NetStatus ));
    }
    return NetStatus;

} // NetUserDel




ULONG
UserpComputeSamPrefMaxLen(
    IN DWORD Level,
    IN DWORD NetUserPrefMaxLen,
    IN DWORD NetUserBytesAlreadyReturned,
    IN DWORD SamBytesAlreadyReturned
    )

/*++

Routine Description:

    This routine is a helper function for NetUserEnum.  NetUserEnum enumerates
    the appropriate users by calling SamEnumerateUsersInDomain.  NetUserEnum builds
    the appropriate return structure for each such enumerated user.

    SamEnumerateUsersInDomain returns a resume handle as does NetUserEnum.  If
    NetUserEnum were to return to its caller without having processed all of the
    entries returned from SAM, NetUserEnum would have to "compute" a resume handle
    corresponding to an intermediate entry returned from SAM.  That's impossible
    (except in the special cases where no "filter" parameter is passed to SAM).

    Instead, we choose to pass SamEnumerateUsersInDomain a PrefMaxLen which will
    attempt to enumerate exactly the right number of users that NetUserEnum can
    pack into its PrefMaxLen buffer.
    Since the size of the structure returned from SAM is different than the size of
    the structure returned from it is difficult to determine an optimal PrefMaxLen
    to pass to SamEnumerateUsersInDomain.  This routine attempts to do that.

    We realise that this algorithm may cause NetUserEnum to exceed its PrefMaxLen by
    a significant amount.

Arguments:

    Level - The NetUserEnum info level.

    NetUserPrefMaxLen - The NetUserEnum prefered maximum length of returned data.

    NetUserBytesAlreadyReturned - The number of bytes already packed by
        NetUserEnum

    SamBytesAlreadyReturned - The number of bytes already returned by
        SamEnumerateUserInDomain.

Return Value:

    Value to use as PrefMaxLen on next call to SamEnumerateUsersInDomain.

--*/

{
    ULONG RemainingPrefMaxLen;
    ULARGE_INTEGER LargeTemp;
    ULONG SamPrefMaxLen;

    //
    // If caller simply wants ALL the data,
    //  ask SAM for the same thing.
    //

    if ( NetUserPrefMaxLen == 0xFFFFFFFF ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(("SamPrefMaxLen: Net Pref: %ld Net bytes: %ld Sam Bytes: %ld Sam Pref: %ld\n",
                          NetUserPrefMaxLen, NetUserBytesAlreadyReturned, SamBytesAlreadyReturned, NetUserPrefMaxLen ));
        }
        return NetUserPrefMaxLen;
    }

    //
    // If no bytes have been returned yet,
    //  use sample data based on a sample domain (REDMOND).
    //  Since the information returned by SAM and NetUserEnum is variable
    //  length, there is no way to compute a value.
    //

    if ( NetUserBytesAlreadyReturned == 0 ) {

        //
        // Use a different constant for each info level.
        //

        switch ( Level ) {
        case 0:
            SamBytesAlreadyReturned =     1;
            NetUserBytesAlreadyReturned = 1;
            break;
        case 2:
        case 3:
        case 11:
            SamBytesAlreadyReturned =     1;
            NetUserBytesAlreadyReturned = 10;
            break;
        case 1:
        case 10:
        case 20:
            SamBytesAlreadyReturned =     1;
            NetUserBytesAlreadyReturned = 4;
            break;
        default:
            SamBytesAlreadyReturned =     1;
            NetUserBytesAlreadyReturned = 1;
            break;
        }

    }

    //
    // Use the above computed divisor to compute the desired number of bytes to
    // enumerate from SAM.
    //

    if ( NetUserBytesAlreadyReturned >= NetUserPrefMaxLen ) {
        RemainingPrefMaxLen = 0;
    } else {
        RemainingPrefMaxLen = NetUserPrefMaxLen - NetUserBytesAlreadyReturned;
    }

    LargeTemp.QuadPart = UInt32x32To64 ( RemainingPrefMaxLen, SamBytesAlreadyReturned );
    SamPrefMaxLen = (ULONG)(LargeTemp.QuadPart / (ULONGLONG) NetUserBytesAlreadyReturned);

    //
    // Ensure we always make reasonable progress by returning at least 5
    //  entries from SAM (unless the caller is really conservative).
    //

#define MIN_SAM_ENUMERATION \
    ((sizeof(SAM_RID_ENUMERATION) + LM20_UNLEN * sizeof(WCHAR) + sizeof(WCHAR)))
#define TYPICAL_SAM_ENUMERATION \
    (MIN_SAM_ENUMERATION * 5)

    if ( SamPrefMaxLen < TYPICAL_SAM_ENUMERATION && NetUserPrefMaxLen > 1 ) {
        SamPrefMaxLen = TYPICAL_SAM_ENUMERATION;
    } else if ( SamPrefMaxLen < MIN_SAM_ENUMERATION ) {
        SamPrefMaxLen = MIN_SAM_ENUMERATION;
    }

    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(("SamPrefMaxLen: Net Pref: %ld Net bytes: %ld Sam Bytes: %ld Sam Pref: %ld\n",
                  NetUserPrefMaxLen, NetUserBytesAlreadyReturned, SamBytesAlreadyReturned, SamPrefMaxLen ));
    }

    return SamPrefMaxLen;


}



NET_API_STATUS NET_API_FUNCTION
NetUserEnum(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD Level,
    IN DWORD Filter,
    OUT LPBYTE *Buffer,
    IN DWORD PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    Retrieve information about each user on a server.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    Level - Level of information required. level 0, 1, 2, 3, 10,
        and 20 are valid

    Filter - Returns the user accounts of the type specified here. Combination
        of the following types may be specified as filter parameter.

        #define FILTER_TEMP_DUPLICATE_ACCOUNT           (0x0001)
        #define FILTER_NORMAL_ACCOUNT                   (0x0002)
        #define FILTER_INTERDOMAIN_TRUST_ACCOUNT        (0x0008)
        #define FILTER_WORKSTATION_TRUST_ACCOUNT        (0x0010)
        #define FILTER_SERVER_TRUST_ACCOUNT             (0x0020)

    Buffer - Returns a pointer to the return information structure.
        Caller must deallocate buffer using NetApiBufferFree.

    PrefMaxLen - Prefered maximum length of returned data.

    EntriesRead - Returns the actual enumerated element count.

    EntriesLeft - Returns the total entries available to be enumerated.

    ResumeHandle -  Used to continue an existing search.  The handle should
        be zero on the first call and left unchanged for subsequent calls.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    NTSTATUS CachedStatus;

    BUFFER_DESCRIPTOR BufferDescriptor;

    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE  DomainHandle = NULL;
    SAM_HANDLE BuiltinDomainHandle = NULL;
    PSID DomainId = NULL;
    ULONG TotalRemaining = 0;

    SAM_ENUMERATE_HANDLE EnumHandle;
    PSAM_RID_ENUMERATION EnumBuffer = NULL;
    DWORD CountReturned = 0;
    BOOL AllDone = FALSE;

    SAM_ENUMERATE_HANDLE LocalEnumHandle;
    DWORD LocalResumeHandle;

    DWORD SamFilter;
    DWORD SamPrefMaxLen;
    DWORD NetUserBytesAlreadyReturned;
    DWORD SamBytesAlreadyReturned;

    DWORD Mode = SAM_SID_COMPATIBILITY_ALL;

#define USERACCOUNTCONTROL( _f )    ( \
            ( ( (_f) & FILTER_TEMP_DUPLICATE_ACCOUNT ) ? \
                        USER_TEMP_DUPLICATE_ACCOUNT : 0 ) | \
            ( ( (_f) & FILTER_NORMAL_ACCOUNT ) ? \
                        USER_NORMAL_ACCOUNT : 0 ) | \
            ( ( (_f) & FILTER_INTERDOMAIN_TRUST_ACCOUNT ) ? \
                        USER_INTERDOMAIN_TRUST_ACCOUNT : 0 ) | \
            ( ( (_f) & FILTER_WORKSTATION_TRUST_ACCOUNT ) ? \
                        USER_WORKSTATION_TRUST_ACCOUNT : 0 ) | \
            ( ( (_f) & FILTER_SERVER_TRUST_ACCOUNT ) ? \
                        USER_SERVER_TRUST_ACCOUNT : 0 ) \
        )


    //
    // Pick up the resume handle.
    //
    // Do this early to ensure we don't scrog the ResumeHandle in
    //  case we go downlevel.
    //

    if ( ARGUMENT_PRESENT( ResumeHandle ) ) {
        LocalResumeHandle = *ResumeHandle;
    } else {
        LocalResumeHandle = 0;
    }

    EnumHandle = (SAM_ENUMERATE_HANDLE) LocalResumeHandle;

    //
    // Initialization
    //

    *Buffer = NULL;
    *EntriesRead = 0;
    *EntriesLeft = 0;
    RtlZeroMemory(
        &BufferDescriptor,
        sizeof(BUFFER_DESCRIPTOR)
        );

    SamFilter = USERACCOUNTCONTROL( Filter );


    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetUserEnum: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    Status = SamGetCompatibilityMode(SamServerHandle,
                                     &Mode);
    if (NT_SUCCESS(Status)) {
        if ( (Mode == SAM_SID_COMPATIBILITY_STRICT)
          && ( Level == 3  || Level == 20 ) ) {
              //
              // These info levels return RID's
              //
              Status = STATUS_NOT_SUPPORTED;
          }
    }
    if (!NT_SUCCESS(Status)) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Validate Level parameter
    //


    switch (Level) {
    case 1:
    case 2:
    case 3:
    case 11:

        //
        // Open the Builtin Domain.
        //

        NetStatus = UaspOpenDomain( SamServerHandle,
                                    DOMAIN_GET_ALIAS_MEMBERSHIP,
                                    FALSE,  // Builtin Domain
                                    &BuiltinDomainHandle,
                                    NULL ); // DomainId

        if ( NetStatus != NERR_Success ) {
            goto Cleanup;
        }

    case 0:
    case 10:
    case 20:
        break;

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;

    }

    //
    // Open the Account Domain.
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_LIST_ACCOUNTS |
                                    DOMAIN_READ_OTHER_PARAMETERS,
                                TRUE,   // Account Domain
                                &DomainHandle,
                                &DomainId );

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }



    //
    // Get the total number of users from SAM
    //
    //
    // the only way to get the total number of specified accounts is
    // enumerate the specified accounts till there is no more accounts
    // and add all CountReturned.
    //

    TotalRemaining = 0;
    LocalEnumHandle = EnumHandle;

    SamPrefMaxLen = UserpComputeSamPrefMaxLen(
                        Level,
                        PrefMaxLen,
                        0,  // NetUserBytesAlreadyReturned,
                        0 );// SamBytesAlreadyReturned

    SamBytesAlreadyReturned = SamPrefMaxLen;

    do {
        NTSTATUS LocalStatus;
        PSAM_RID_ENUMERATION LocalEnumBuffer = NULL;
        DWORD LocalCountReturned;

        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(("Calling Enumerate phase 1: PrefLen %ld\n", SamPrefMaxLen ));
        }

        Status = SamEnumerateUsersInDomain(
                        DomainHandle,
                        &LocalEnumHandle,
                        SamFilter,
                        (PVOID *) &LocalEnumBuffer,
                        SamPrefMaxLen,
                        &LocalCountReturned
                    );

        if ( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );

            if(LocalEnumBuffer != NULL ) {

                Status =  SamFreeMemory( LocalEnumBuffer );
                NetpAssert( NT_SUCCESS( Status ) );
            }

            goto Cleanup;
        }

        //
        // aggrigate total count.
        //


        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(("Enumerate phase 1: Returned %ld entries\n", LocalCountReturned ));
        }
        TotalRemaining += LocalCountReturned;

        //
        // cache first enum buffer to use it in the loop below.
        //

        if( EnumBuffer == NULL ) {

            EnumBuffer = LocalEnumBuffer;
            EnumHandle = LocalEnumHandle;
            CountReturned = LocalCountReturned;
            CachedStatus = Status;

            // Subsequent calls can use a reasonably large buffer size.
            if ( SamPrefMaxLen < NETP_ENUM_GUESS ) {
                SamPrefMaxLen = NETP_ENUM_GUESS;
            }
        } else {

            LocalStatus =  SamFreeMemory( LocalEnumBuffer );
            NetpAssert( NT_SUCCESS( LocalStatus ) );
        }


    } while ( Status == STATUS_MORE_ENTRIES );


    //
    // Loop for each user
    //
    //

    NetUserBytesAlreadyReturned = 0;

    for ( ;; ) {

        DWORD i;

        //
        // use cached enum buffer if one available
        //

        if( EnumBuffer != NULL ) {

            Status = CachedStatus;
        } else {

            SamPrefMaxLen = UserpComputeSamPrefMaxLen(
                                Level,
                                PrefMaxLen,
                                NetUserBytesAlreadyReturned,
                                SamBytesAlreadyReturned );


            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint(("Calling Enumerate phase 2: PrefLen %ld\n", SamPrefMaxLen ));
            }
            Status = SamEnumerateUsersInDomain(
                            DomainHandle,
                            &EnumHandle,
                            SamFilter,
                            (PVOID *) &EnumBuffer,
                            SamPrefMaxLen,
                            &CountReturned );


            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint(("Enumerate phase 2: Returned %ld entries\n", CountReturned ));
            }

            SamBytesAlreadyReturned += SamPrefMaxLen;
        }

        if ( !NT_SUCCESS( Status ) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        if( Status != STATUS_MORE_ENTRIES ) {

            AllDone = TRUE;
        }

        for( i = 0; i < CountReturned; i++ ) {

            LPBYTE EndOfVariableData;
            LPBYTE FixedDataEnd;

            //
            // save return buffer end points.
            //

            EndOfVariableData = BufferDescriptor.EndOfVariableData;
            FixedDataEnd = BufferDescriptor.FixedDataEnd;

            //
            // Place another entry into the return buffer.
            //
            // Use 0xFFFFFFFF as PrefMaxLen to prevent this routine from
            // prematurely returning ERROR_MORE_DATA.  We'll calculate that
            // ourselves below.
            //

            NetStatus = UserpGetInfo(
                            DomainHandle,
                            DomainId,
                            BuiltinDomainHandle,
                            EnumBuffer[i].Name,
                            EnumBuffer[i].RelativeId,
                            Level,
                            0xFFFFFFFF,
                            &BufferDescriptor,
                            FALSE, // Not a 'get' operation
                            0 );

            if (NetStatus != NERR_Success) {

                //
                // We may have access to enumerate objects we don't have access
                //  to touch.  So, simply ignore those accounts we can't get
                //  information for.
                //

                if ( NetStatus == ERROR_ACCESS_DENIED ) {
                    continue;
                }
                goto Cleanup;
            }

            //
            // Only count this entry if it was added to the return buffer.
            //

            if ( (EndOfVariableData != BufferDescriptor.EndOfVariableData ) ||
                 (FixedDataEnd != BufferDescriptor.FixedDataEnd ) ) {

                (*EntriesRead)++;
            }

        }

        //
        // free up current EnumBuffer and get another EnumBuffer.
        //

        Status = SamFreeMemory( EnumBuffer );
        NetpAssert( NT_SUCCESS(Status) );
        EnumBuffer = NULL;

        if( AllDone == TRUE ) {
            NetStatus = NERR_Success;
            break;
        }

        //
        //  Check here if we've exceeded PrefMaxLen since here we know
        //  a valid resume handle.
        //


        NetUserBytesAlreadyReturned =
            ( BufferDescriptor.AllocSize -
                 ((DWORD)(BufferDescriptor.EndOfVariableData -
                          BufferDescriptor.FixedDataEnd)) );

        if ( NetUserBytesAlreadyReturned >= PrefMaxLen ) {

            LocalResumeHandle = EnumHandle;

            NetStatus = ERROR_MORE_DATA;
            goto Cleanup;
        }

    }

    //
    // Clean up.
    //

Cleanup:

    //
    // Set EntriesLeft to the number left to return plus those that
    //  we returned on this call.
    //

    if( TotalRemaining >= *EntriesRead ) {
        *EntriesLeft = TotalRemaining;
    }
    else {

        *EntriesLeft = *EntriesRead;
    }

    //
    // Free up all resources, we reopen them if the caller calls again.
    //

    if ( DomainHandle != NULL ) {
        UaspCloseDomain( DomainHandle );
    }

    if ( BuiltinDomainHandle != NULL ) {
        UaspCloseDomain( BuiltinDomainHandle );
    }

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    if ( DomainId != NULL ) {
        NetpMemoryFree( DomainId );
    }

    if ( EnumBuffer != NULL ) {
        Status = SamFreeMemory( EnumBuffer );
        NetpAssert( NT_SUCCESS(Status) );
    }

    //
    // If we're not returning data to the caller,
    //  free the return buffer.
    //

    if ( NetStatus != NERR_Success && NetStatus != ERROR_MORE_DATA ) {

        if( NetStatus != NERR_BufTooSmall ) {

            if ( BufferDescriptor.Buffer != NULL ) {
                MIDL_user_free( BufferDescriptor.Buffer );
                BufferDescriptor.Buffer = NULL;
            }
            *EntriesRead = 0;
            *EntriesLeft = 0;
        }
        else {
            NetpAssert( BufferDescriptor.Buffer == NULL );
            NetpAssert( *EntriesRead == 0 );
        }
    }

    //
    // Set the output parameters
    //

    *Buffer = BufferDescriptor.Buffer;

    if ( ARGUMENT_PRESENT( ResumeHandle ) ) {
        *ResumeHandle = LocalResumeHandle;
    }


    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(("NetUserEnum: PrefLen %ld Returned %ld\n", PrefMaxLen,
                 ( BufferDescriptor.AllocSize -
                      ((DWORD)(BufferDescriptor.EndOfVariableData -
                               BufferDescriptor.FixedDataEnd)) ) ));
    }

    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetUserEnum( (LPWSTR)ServerName,
                                   Level,
                                   Buffer,
                                   PrefMaxLen,
                                   EntriesRead,
                                   EntriesLeft,
                                   ResumeHandle );

    UASP_DOWNLEVEL_END;

    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "NetUserEnum: returning %ld\n", NetStatus ));
    }

    return NetStatus;

} // NetUserEnum


NET_API_STATUS NET_API_FUNCTION
NetUserGetInfo(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR UserName,
    IN DWORD Level,
    OUT LPBYTE *Buffer
    )

/*++

Routine Description:

    Retrieve information about a particular user.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    UserName - Name of the user to get information about.

    Level - Level of information required.

    Buffer - Returns a pointer to the return information structure.
        Caller must deallocate buffer using NetApiBufferFree.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    PSID DomainId = NULL;
    SAM_HANDLE BuiltinDomainHandle = NULL;
    BUFFER_DESCRIPTOR BufferDescriptor;

    ULONG RelativeId;           // Relative Id of the user
    UNICODE_STRING UserNameString;

    BufferDescriptor.Buffer = NULL;

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetUserGetInfo: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the Domain
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_LOOKUP,
                                TRUE,   // Account Domain
                                &DomainHandle,
                                &DomainId );

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // Open the Builtin Domain.
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_GET_ALIAS_MEMBERSHIP,
                                FALSE,  // Builtin Domain
                                &BuiltinDomainHandle,
                                NULL ); // DomainId

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // Validate the user name and get the relative ID.
    //

    NetStatus = UserpOpenUser( DomainHandle,
                               0,     // DesiredAccess
                               UserName,
                               NULL,  // UserHandle
                               &RelativeId );

    if (NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // Get the Information about the user.
    //

    RtlInitUnicodeString( &UserNameString, UserName );
    NetStatus = UserpGetInfo(
                    DomainHandle,
                    DomainId,
                    BuiltinDomainHandle,
                    UserNameString,
                    RelativeId,
                    Level,
                    0,      // PrefMaxLen
                    &BufferDescriptor,
                    TRUE,   // Is a 'get' operation
                    0 );    // don't filter account

    //
    // Clean up.
    //

Cleanup:

    //
    // If we're returning data to the caller,
    //  Don't free the return buffer.
    //

    if ( NetStatus == NERR_Success ) {
        *Buffer = BufferDescriptor.Buffer;
    } else {
        if ( BufferDescriptor.Buffer != NULL ) {
            MIDL_user_free( BufferDescriptor.Buffer );
        }
    }

    if ( DomainHandle != NULL ) {
        UaspCloseDomain( DomainHandle );
    }

    if ( BuiltinDomainHandle != NULL ) {
        UaspCloseDomain( BuiltinDomainHandle );
    }

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    if ( DomainId != NULL ) {
        NetpMemoryFree( DomainId );
    }

    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetUserGetInfo( (LPWSTR)ServerName, (LPWSTR)UserName, Level, Buffer );

    UASP_DOWNLEVEL_END;

    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "NetUserGetInfo: returning %ld\n", NetStatus ));
    }

    return NetStatus;

} // NetUserGetInfo


NET_API_STATUS NET_API_FUNCTION
NetUserSetInfo(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR UserName,
    IN DWORD Level,
    IN LPBYTE Buffer,
    OUT LPDWORD ParmError OPTIONAL  // Name required by NetpSetParmError
    )

/*++

Routine Description:

    Set the parameters on a user account in the user accounts database.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    UserName - Name of the user to modify.

    Level - Level of information provided.

    Buffer - A pointer to the buffer containing the user information
        structure.

    ParmError - Optional pointer to a DWORD to return the index of the
        first parameter in error when ERROR_INVALID_PARAMETER is returned.
        If NULL, the parameter is not returned on error.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    PSID DomainId = NULL;
    SAM_HANDLE BuiltinDomainHandle = NULL;
    ULONG UserRelativeId;

    //
    // Initialize
    //

    NetpSetParmError( PARM_ERROR_NONE );
    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetUserSetInfo: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the Account Domain
    //  DOMAIN_READ_PASSWORD_PARAMETERS is needed in those cases that we'll
    //  set the password on the account.
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_LOOKUP | DOMAIN_READ_PASSWORD_PARAMETERS,
                                TRUE,   // Account Domain
                                &DomainHandle,
                                &DomainId );

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // Open the Builtin Domain.
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_GET_ALIAS_MEMBERSHIP,
                                FALSE,  // Builtin Domain
                                &BuiltinDomainHandle,
                                NULL ); // DomainId

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // Get the relative ID of the user.  Don't open the user yet
    // since we don't know the desired access.
    //

    NetStatus = UserpOpenUser( DomainHandle,
                               0,     // DesiredAccess
                               UserName,
                               NULL,  // UserHandle
                               &UserRelativeId );

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // Change the user
    //

    NetStatus = UserpSetInfo(
                    DomainHandle,
                    DomainId,
                    NULL,       // UserHandle (let UserpSetInfo open the user)
                    BuiltinDomainHandle,
                    UserRelativeId,
                    UserName,
                    Level,
                    Buffer,
                    0xFFFFFFFF,     // set all requested fields
                    ParmError );

    //
    // Clean up.
    //

Cleanup:
    if ( DomainHandle != NULL ) {
        UaspCloseDomain( DomainHandle );
    }

    if ( BuiltinDomainHandle != NULL ) {
        UaspCloseDomain( BuiltinDomainHandle );
    }

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    if ( DomainId != NULL ) {
        NetpMemoryFree( DomainId );
    }

    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetUserSetInfo( (LPWSTR) ServerName,
                                      (LPWSTR) UserName,
                                      Level,
                                      Buffer,
                                      ParmError );

    UASP_DOWNLEVEL_END;


    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "NetUserSetInfo: returning %ld\n", NetStatus ));
    }

    return NetStatus;

} // NetUserSetInfo


NET_API_STATUS NET_API_FUNCTION
NetUserGetGroups(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR UserName,
    IN DWORD Level,
    OUT LPBYTE *Buffer,
    IN DWORD PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft
    )

/*++

Routine Description:

    Enumerate the groups that this user is a member of.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    UserName - The name of the user whose members are to be listed.

    Level - Level of information required (must be 0 or 1)

    Buffer - Returns a pointer to the return information structure.
        Caller must deallocate buffer using NetApiBufferFree.

    PrefMaxLen - Prefered maximum length of returned data.

    EntriesRead - Returns the actual enumerated element count.

    EntriesLeft - Returns the total entries available to be enumerated.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    BUFFER_DESCRIPTOR BufferDescriptor;
    DWORD FixedSize;        // The fixed size of each new entry.

    DWORD i;

    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE  DomainHandle = NULL;
    SAM_HANDLE  UserHandle = NULL;

    PUNICODE_STRING Names = NULL;           // Names corresponding to Ids
    ULONG GroupCount;

    PGROUP_MEMBERSHIP GroupAttributes = NULL;

    PULONG MemberIds = NULL;                // Sam returned MemberIds
    PULONG MemberGroupAttributes = NULL;    // Sam returned MemberAttributes;

    //
    // Validate Parameters
    //

    *EntriesRead = 0;
    *EntriesLeft = 0;
    BufferDescriptor.Buffer = NULL;

    switch (Level) {
    case 0:
        FixedSize = sizeof(GROUP_USERS_INFO_0);
        break;

    case 1:
        FixedSize = sizeof(GROUP_USERS_INFO_1);
        break;

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetUserGetGroups: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the Domain
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_LOOKUP,
                                TRUE,   // Account Domain
                                &DomainHandle,
                                NULL);  // DomainId

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // Open the user asking for USER_LIST_GROUPS access.
    //

    NetStatus = UserpOpenUser( DomainHandle,
                               USER_LIST_GROUPS,
                               UserName,
                               &UserHandle,
                               NULL);  // Relative Id

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // Get the membership from SAM
    //
    // This API is an odd one for SAM.  It returns all of the membership
    // information in a single call.
    //

    Status = SamGetGroupsForUser( UserHandle, &GroupAttributes, &GroupCount );

    if ( !NT_SUCCESS( Status ) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint((
                "NetUserGetGroups: SamGetGroupsForUser returned %lX\n",
                Status ));
        }
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Handle the case where there is nothing to return.
    //

    if ( GroupCount == 0 ) {
        NetStatus = NERR_Success;
        goto Cleanup;
    }

    //
    // Convert the returned relative IDs to user names.
    //

    //
    // Allocate a buffer for converting relative ids to user names
    //

    MemberIds = NetpMemoryAllocate( GroupCount * sizeof(ULONG) );

    if ( MemberIds == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    MemberGroupAttributes = NetpMemoryAllocate( GroupCount * sizeof(ULONG) );

    if ( MemberGroupAttributes == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Allocate another buffer for store attributes of the groups
    // we returning.
    //

    //
    // Copy the relative IDs returned from SAM to the allocated buffer.
    //

    for ( i=0; i < GroupCount; i++ ) {
        MemberIds[*EntriesLeft] = GroupAttributes[i].RelativeId;
        MemberGroupAttributes[*EntriesLeft] = GroupAttributes[i].Attributes;
        (*EntriesLeft)++;
    }

    //
    // Convert the relative IDs to names
    //

    Status = SamLookupIdsInDomain( DomainHandle,
                                   *EntriesLeft,
                                   MemberIds,
                                   &Names,
                                   NULL ); // NameUse
    if ( !NT_SUCCESS( Status ) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint((
                "NetUserGetGroups: SamLookupIdsInDomain returned %lX\n",
                Status ));
        }
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Determine the number of entries that will fit in the caller's
    // buffer.
    //

    for ( i=0; i < *EntriesLeft; i++ ) {
        DWORD Size;
        PGROUP_USERS_INFO_0 grui0;

        //
        // Compute the size of the next entry
        //

        Size = FixedSize + Names[i].Length + sizeof(WCHAR);

        //
        // Ensure the return buffer is big enough.
        //

        Size = ROUND_UP_COUNT( Size, ALIGN_WCHAR );

        NetStatus = NetpAllocateEnumBuffer(
                        &BufferDescriptor,
                        FALSE,      // Is an enumeration routine.
                        PrefMaxLen,
                        Size,
                        GrouppMemberRelocationRoutine,
                        Level );

        if ( NetStatus != NERR_Success ) {
            goto Cleanup;
        }

        //
        // Copy the data into the buffer
        //

        grui0 = (PGROUP_USERS_INFO_0) BufferDescriptor.FixedDataEnd;
        BufferDescriptor.FixedDataEnd += FixedSize ;

        NetpAssert( offsetof( GROUP_USERS_INFO_0, grui0_name ) ==
                    offsetof( GROUP_USERS_INFO_1, grui1_name ) );

        if ( !NetpCopyStringToBuffer(
                  Names[i].Buffer,
                  Names[i].Length/sizeof(WCHAR),
                  BufferDescriptor.FixedDataEnd,
                  (LPWSTR *)&BufferDescriptor.EndOfVariableData,
                  &grui0->grui0_name) ) {

            NetStatus = NERR_InternalError;
            goto Cleanup;
        }

        if ( Level == 1 ) {
            ((PGROUP_USERS_INFO_1)grui0)->grui1_attributes =
                    MemberGroupAttributes[i];
        }

        (*EntriesRead)++;

    }

    NetStatus = NERR_Success ;

    //
    // Clean up.
    //

Cleanup:

    //
    // Free any resources used locally
    //

    if( MemberIds != NULL ) {
        NetpMemoryFree( MemberIds );
    }

    if( MemberGroupAttributes != NULL ) {
        NetpMemoryFree( MemberGroupAttributes );
    }

    if ( Names != NULL ) {
        Status = SamFreeMemory( Names );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if ( UserHandle != NULL ) {
        (VOID) SamCloseHandle( UserHandle );
    }

    if ( GroupAttributes != NULL ) {
        Status = SamFreeMemory( GroupAttributes );
        NetpAssert( NT_SUCCESS(Status) );
    }

    UaspCloseDomain( DomainHandle );

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    //
    // If we're not returning data to the caller,
    //  free the return buffer.
    //

    if ( NetStatus != NERR_Success && NetStatus != ERROR_MORE_DATA ) {
        if ( BufferDescriptor.Buffer != NULL ) {
            MIDL_user_free( BufferDescriptor.Buffer );
            BufferDescriptor.Buffer = NULL;
        }
        *EntriesLeft = 0;
        *EntriesRead = 0;
    }
    *Buffer = BufferDescriptor.Buffer;

    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetUserGetGroups( (LPWSTR)ServerName,
                                        (LPWSTR)UserName,
                                        Level,
                                        Buffer,
                                        PrefMaxLen,
                                        EntriesRead,
                                        EntriesLeft );

    UASP_DOWNLEVEL_END;


    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "NetUserGetGroups: returning %ld\n", NetStatus ));
    }


    return NetStatus;

} // NetUserGetGroups


NET_API_STATUS NET_API_FUNCTION
NetUserSetGroups (
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR UserName,
    IN DWORD Level,
    IN LPBYTE Buffer,
    IN DWORD NewGroupCount
    )

/*++

Routine Description:

    Set the list of groups that is user is a member of.

    The groups specified by "Buffer" are called new groups.  The groups
    that the user is currently a member of are called old groups.
    Groups which are on both the old and new list are called common groups.

    The SAM API allows only one member to be added or deleted at a time.
    This API allows all of the groups this user is a member of to be
    specified en-masse.  This API is careful to always leave the group
    membership in the SAM database in a reasonable state.
    It does by merging the list of
    old and new groups, then only changing those memberships which absolutely
    need changing.

    Group membership is restored to its previous state (if possible) if
    an error occurs during changing the group membership.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    UserName - Name of the user to modify.

    Level - Level of information provided.  Must be 0 or 1.

    Buffer - A pointer to the buffer containing an array of NewGroupCount
        group membership information structures.

    NewGroupCount - Number of entries in Buffer.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAM_HANDLE UserHandle = NULL;
    ULONG UserRelativeId;

    DWORD FixedSize;

    PULONG  NewRelativeIds = NULL;   // Relative Ids of a list of new groups
    PSID_NAME_USE NewNameUse = NULL; // Name usage of a list of new groups
    PUNICODE_STRING NewNameStrings = NULL;// Names of a list of new groups

    //
    // Define an internal group membership list structure.
    //
    // This structure defines a list of new group memberships to be added,
    //      group memberships whose attributes merely need to be changed,
    //      and group memberships which need to be deleted.
    //
    // The list is maintained in relative ID sorted order.
    //

    struct _GROUP_DESCRIPTION {
        struct _GROUP_DESCRIPTION * Next;  // Next entry in linked list;

        ULONG   RelativeId;     // Relative ID of this group

        SAM_HANDLE GroupHandle; // Group Handle of this group

        enum _Action {          // Action taken for this group membership
            AddMember,              // Add membership to group
            RemoveMember,           // Remove membership from group
            SetAttributesMember,    // Change the membership's attributes
            IgnoreMember            // Ignore this membership
        } Action;

        BOOL    Done;           // True if this action has been taken

        ULONG NewAttributes;    // Attributes to set for the membership

        ULONG OldAttributes;    // Attributes to restore on a recovery

    } *GroupList = NULL, *CurEntry, **Entry, *TempEntry;

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetUserSetGroups: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }


    //
    // Open the Domain
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_LOOKUP,
                                TRUE,   // Account Domain
                                &DomainHandle,
                                NULL);  // DomainId

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // Open the user
    //

    NetStatus = UserpOpenUser( DomainHandle,
                               USER_LIST_GROUPS,
                               UserName,
                               &UserHandle,
                               &UserRelativeId );

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // Validate the level
    //

    switch (Level) {
    case 0:
        FixedSize = sizeof( GROUP_USERS_INFO_0 );
        break;
    case 1:
        FixedSize = sizeof( GROUP_USERS_INFO_1 );
        break;

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    //
    // Build the list of new groups
    //

    if ( NewGroupCount > 0 ) {

        DWORD NewIndex;             // Index to the current New group

        //
        // Allocate a buffer big enough to contain all the string variables
        //  for the new group names.
        //

        NewNameStrings = NetpMemoryAllocate( NewGroupCount *
            sizeof(UNICODE_STRING));

        if ( NewNameStrings == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Fill in the list of group name strings for each new group.
        //

        NetpAssert( offsetof( GROUP_USERS_INFO_0, grui0_name ) ==
                    offsetof( GROUP_USERS_INFO_1, grui1_name ) );

        for ( NewIndex=0; NewIndex<NewGroupCount; NewIndex++ ) {
            LPWSTR GroupName;

            GroupName =
                ((PGROUP_USERS_INFO_0)(Buffer+FixedSize*NewIndex))->grui0_name;

            RtlInitUnicodeString( &NewNameStrings[NewIndex], GroupName );
        }

        //
        // Convert the group names to relative Ids.
        //

        Status = SamLookupNamesInDomain( DomainHandle,
                                         NewGroupCount,
                                         NewNameStrings,
                                         &NewRelativeIds,
                                         &NewNameUse );

        if ( !NT_SUCCESS( Status )) {
            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint((
                    "NetUserSetGroups: SamLookupNamesInDomain returned %lX\n",
                    Status ));
            }

            if ( Status == STATUS_NONE_MAPPED ) {
                NetStatus = NERR_GroupNotFound;
                goto Cleanup;
            }

            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        //
        // Build a group entry for each of the new groups.
        //  The list is maintained in RelativeId sorted order.
        //

        for ( NewIndex=0; NewIndex<NewGroupCount; NewIndex++ ) {

            //
            // Ensure the new group name is really a group
            //  One cannot become the member of a user!!!
            //

            if (NewNameUse[NewIndex] != SidTypeGroup) {
                NetStatus = NERR_GroupNotFound;
                goto Cleanup;
            }

            //
            // Find the place to put the new entry
            //

            Entry = &GroupList;
            while ( *Entry != NULL &&
                (*Entry)->RelativeId < NewRelativeIds[NewIndex] ) {

                Entry = &( (*Entry)->Next );
            }

            //
            // If this is not a duplicate entry, allocate a new group structure
            //  and fill it in.
            //
            // Just ignore duplicate relative Ids.
            //

            if ( *Entry == NULL ||
                (*Entry)->RelativeId > NewRelativeIds[NewIndex] ) {

                CurEntry =
                    NetpMemoryAllocate( sizeof(struct _GROUP_DESCRIPTION) );

                if ( CurEntry == NULL ) {
                    NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }

                CurEntry->Next = *Entry;
                CurEntry->RelativeId = NewRelativeIds[NewIndex];
                CurEntry->Action = AddMember;
                CurEntry->Done = FALSE;
                CurEntry->GroupHandle = NULL;

                CurEntry->NewAttributes = ( Level == 1 ) ?
                    ((PGROUP_USERS_INFO_1)Buffer)[NewIndex].grui1_attributes :
                    SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT |
                        SE_GROUP_ENABLED;

                *Entry = CurEntry;
            }
        }

    }

    //
    //  Merge the old groups into the list.
    //

    {
        ULONG OldIndex;                     // Index to current entry
        ULONG OldCount;                     // Total Number of entries
        PGROUP_MEMBERSHIP GroupAttributes = NULL;

        //
        // Determine the old group membership
        //

        Status = SamGetGroupsForUser(
                    UserHandle,
                    &GroupAttributes,
                    &OldCount );

        if ( !NT_SUCCESS( Status ) ) {
            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint((
                    "NetUserSetGroups: SamGetGroupsForUser returned %lX\n",
                    Status ));
            }
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        //
        // Merge each old group into the list
        //

        for ( OldIndex=0; OldIndex < OldCount; OldIndex++) {

            //
            // Find the place to put the new entry
            //

            Entry = &GroupList ;
            while ( *Entry != NULL &&
                (*Entry)->RelativeId < GroupAttributes[OldIndex].RelativeId ) {

                Entry = &( (*Entry)->Next );
            }

            //
            // If this entry is not already in the list,
            //   this is a group membership which exists now but should
            //   be deleted.
            //

            if( *Entry == NULL ||
                (*Entry)->RelativeId > GroupAttributes[OldIndex].RelativeId){

                CurEntry =
                    NetpMemoryAllocate(sizeof(struct _GROUP_DESCRIPTION));

                if ( CurEntry == NULL ) {
                    Status = SamFreeMemory( GroupAttributes );
                    NetpAssert( NT_SUCCESS(Status) );

                    NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }

                CurEntry->Next = *Entry;
                CurEntry->RelativeId = GroupAttributes[OldIndex].RelativeId;
                CurEntry->Action = RemoveMember;
                CurEntry->Done = FALSE;
                CurEntry->OldAttributes = GroupAttributes[OldIndex].Attributes;
                CurEntry->GroupHandle = NULL;

                *Entry = CurEntry;

            //
            // Handle the case where this group is already in the list
            //

            } else {

                //
                // Watch out for SAM returning the same group twice.
                //

                if ( (*Entry)->Action != AddMember ) {
                    Status = SamFreeMemory( GroupAttributes );
                    NetpAssert( NT_SUCCESS(Status) );

                    NetStatus = NERR_InternalError;
                    goto Cleanup;
                }

                //
                // If this is info level 1 and the requested attributes are
                //  different than the current attributes,
                //      Remember to change the attributes.
                //

                if ( Level == 1 && (*Entry)->NewAttributes !=
                    GroupAttributes[OldIndex].Attributes ) {

                    (*Entry)->OldAttributes =
                        GroupAttributes[OldIndex].Attributes;

                    (*Entry)->Action = SetAttributesMember;

                //
                // This is either info level 0 or the level 1 attributes
                //  are the same as the existing attributes.
                //
                // In either case, this group membership is already set
                // up properly and we should ignore this entry for the
                // rest of this routine.
                //

                } else {
                    (*Entry)->Action = IgnoreMember;
                }
            }

        }
    }

    //
    // Loop through the list opening all of the groups
    //
    // Ask for add and remove access for BOTH added and removed memberships.
    // One access is required to do the operation initially.  The other access
    // is required to undo the operation during recovery.
    //

    for ( CurEntry = GroupList; CurEntry != NULL ; CurEntry=CurEntry->Next ) {
        if ( CurEntry->Action == AddMember || CurEntry->Action == RemoveMember){
            Status = SamOpenGroup(
                        DomainHandle,
                        GROUP_ADD_MEMBER | GROUP_REMOVE_MEMBER,
                        CurEntry->RelativeId,
                        &CurEntry->GroupHandle );

            if ( !NT_SUCCESS( Status ) ) {
                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint((
                        "NetUserSetGroups: SamOpenGroup returned %lX\n",
                        Status ));
                }
                NetStatus = NetpNtStatusToApiStatus( Status );
                goto Cleanup;
            }

        }
    }

    //
    // Loop through the list adding membership to all new groups.
    //  We do this in a separate loop to minimize the damage that happens
    //  should we get an error and not be able to recover.
    //

    for ( CurEntry = GroupList; CurEntry != NULL ; CurEntry=CurEntry->Next ) {
        if ( CurEntry->Action == AddMember ) {
            Status = SamAddMemberToGroup( CurEntry->GroupHandle,
                                          UserRelativeId,
                                          CurEntry->NewAttributes );

            //
            // For level 0, if the default attributes were incompatible,
            //  try these attributes.
            //

            if ( Level == 0 && Status == STATUS_INVALID_GROUP_ATTRIBUTES ) {
                Status = SamAddMemberToGroup( CurEntry->GroupHandle,
                                              UserRelativeId,
                                              SE_GROUP_ENABLED_BY_DEFAULT |
                                                 SE_GROUP_ENABLED );
            }

            if ( !NT_SUCCESS( Status ) ) {
                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint((
                        "NetUserSetGroups: SamAddMemberToGroup returned %lX\n",
                        Status ));
                }
                NetStatus = NetpNtStatusToApiStatus( Status );
                goto Cleanup;
            }

            CurEntry->Done = TRUE;

        }
    }

    //
    // Loop through the list deleting membership from all old groups
    //  and changing the membership attributes of all common groups.
    //

    for ( CurEntry = GroupList; CurEntry != NULL ; CurEntry=CurEntry->Next ) {

        if ( CurEntry->Action == RemoveMember ) {
            Status = SamRemoveMemberFromGroup( CurEntry->GroupHandle,
                                               UserRelativeId);

        } else if ( CurEntry->Action == SetAttributesMember ) {
            Status = SamSetMemberAttributesOfGroup( CurEntry->GroupHandle,
                                                    UserRelativeId,
                                                    CurEntry->NewAttributes);

        }

        if ( !NT_SUCCESS( Status ) ) {
            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint((
                    "NetUserSetGroups: SamRemoveMemberFromGroup (or SetMemberAttributes) returned %lX\n",
                    Status ));
            }
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        CurEntry->Done = TRUE;
    }

    NetStatus = NERR_Success;

    //
    // Clean up.
    //

Cleanup:

    //
    // Walk the group list cleaning up any damage we've done
    //

    for ( CurEntry = GroupList; CurEntry != NULL ; ) {

        if ( NetStatus != NERR_Success && CurEntry->Done ) {
            switch (CurEntry->Action) {
            case AddMember:
                Status =  SamRemoveMemberFromGroup( CurEntry->GroupHandle,
                                                    UserRelativeId );
                NetpAssert( NT_SUCCESS(Status) );

                break;

            case RemoveMember:
                Status = SamAddMemberToGroup( CurEntry->GroupHandle,
                                              UserRelativeId,
                                              CurEntry->OldAttributes );
                NetpAssert( NT_SUCCESS(Status) );

                break;

            case SetAttributesMember:
                Status = SamSetMemberAttributesOfGroup(CurEntry->GroupHandle,
                                                       UserRelativeId,
                                                       CurEntry->OldAttributes);
                NetpAssert( NT_SUCCESS(Status) );

                break;

            default:
                break;
            }
        }

        if (CurEntry->GroupHandle != NULL) {
            (VOID) SamCloseHandle( CurEntry->GroupHandle );
        }

        TempEntry = CurEntry;
        CurEntry = CurEntry->Next;
        NetpMemoryFree( TempEntry );
    }

    //
    // Free up any locally used resources.
    //

    if ( NewNameStrings != NULL ) {
        NetpMemoryFree( NewNameStrings );
    }

    if ( NewRelativeIds != NULL ) {
        Status = SamFreeMemory( NewRelativeIds );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if ( NewNameUse != NULL ) {
        Status = SamFreeMemory( NewNameUse );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if (UserHandle != NULL) {
        (VOID) SamCloseHandle( UserHandle );
    }

    UaspCloseDomain( DomainHandle );

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetUserSetGroups( (LPWSTR)ServerName,
                                        (LPWSTR)UserName,
                                        Level,
                                        Buffer,
                                        NewGroupCount );

    UASP_DOWNLEVEL_END;

    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "NetUserSetGroups: returning %ld\n", NetStatus ));
    }

    return NetStatus;

} // NetUserSetGroups


NET_API_STATUS NET_API_FUNCTION
NetUserGetLocalGroups(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR UserName,
    IN DWORD Level,
    IN DWORD Flags,
    OUT LPBYTE *Buffer,
    IN DWORD PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft
    )

/*++

Routine Description:

    Enumerate the local groups that this user is a member of.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    UserName - The name of the user whose members are to be listed.
        The UserName can be of the form <UserName> in which case the
        UserName is expected to be found on ServerName.  The UserName can also
        be of the form <DomainName>\<UserName> in which case <DomainName> is
        expected to be trusted by ServerName and <UserName> is expected to be to
        be found on that domain.

    Level - Level of information required (must be 0)

    Flags - Indicates if indirect local group membership is to be
            included.

    Buffer - Returns a pointer to the return information structure.
        Caller must deallocate buffer using NetApiBufferFree.

    PrefMaxLen - Prefered maximum length of returned data.

    EntriesRead - Returns the actual enumerated element count.

    EntriesLeft - Returns the total entries available to be enumerated.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    BUFFER_DESCRIPTOR BufferDescriptor;
    DWORD FixedSize;        // The fixed size of each new entry.

    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE  DomainHandle = NULL;
    SAM_HANDLE  UsersDomainHandle = NULL;
    SAM_HANDLE  BuiltinDomainHandle = NULL;
    SAM_HANDLE  UserHandle = NULL;
    PSID DomainId = NULL ;
    PSID DomainIdToUse;
    PSID UsersDomainId = NULL ;
    PSID *UserSidList = NULL;
    ULONG PartialCount = 0;

    LPCWSTR OrigUserName = UserName;
    PWCHAR BackSlash;

    PUNICODE_STRING Names = NULL;           // Names corresponding to Ids
    PULONG Aliases = NULL;

    ULONG GroupCount = 0 ;
    ULONG GroupIndex;
    PGROUP_MEMBERSHIP GroupMembership = NULL;

    PSID *UserSids = NULL;
    ULONG UserSidCount = 0;
    ULONG UserRelativeId = 0;

    //
    // Validate Parameters
    //

    *EntriesRead = 0;
    *EntriesLeft = 0;
    BufferDescriptor.Buffer = NULL;
    if (Flags & ~LG_INCLUDE_INDIRECT) {
        NetStatus = ERROR_INVALID_PARAMETER;   // unknown flag
        goto Cleanup;
    }

    switch (Level) {
    case 0:
        FixedSize = sizeof(LOCALGROUP_USERS_INFO_0);
        break;

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetUserGetLocalGroups: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }


    //
    // Open the Domains (Account & Builtin)
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_LOOKUP | DOMAIN_GET_ALIAS_MEMBERSHIP,
                                TRUE,   // Account Domain
                                &DomainHandle,
                                &DomainId);

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DOMAIN_GET_ALIAS_MEMBERSHIP,
                                FALSE,  // Builtin Domain
                                &BuiltinDomainHandle,
                                NULL ); // DomainId

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // Parse the <DomainName>\<UserName>
    //

    BackSlash = wcschr( UserName, L'\\' );



    //
    // If the global group of the user are to be taken into consideration,
    //  get the global groups now.
    //
    if ( Flags & LG_INCLUDE_INDIRECT ) {
        SAM_HANDLE  DomainHandleToUse;

        //
        // Handle the case where no domain is specified
        //

        if ( BackSlash == NULL ) {
            DomainHandleToUse = DomainHandle;
            DomainIdToUse = DomainId;

        //
        // Handle the case where a domain name was specified
        //

        } else {

            DWORD UsersDomainNameLength;
            WCHAR UsersDomainName[DNLEN+1];

            //
            // Grab the domain name
            //

            UsersDomainNameLength = (DWORD)(BackSlash - UserName);
            if ( UsersDomainNameLength == 0 ||
                 UsersDomainNameLength > DNLEN ) {

                NetStatus = NERR_DCNotFound;
                goto Cleanup;
            }

            RtlCopyMemory( UsersDomainName, UserName, UsersDomainNameLength*sizeof(WCHAR) );
            UsersDomainName[UsersDomainNameLength] = L'\0';
            UserName = BackSlash+1;

            //
            // Open a handle to the specified domain's SAM.
            //

            NetStatus = UaspOpenDomainWithDomainName(
                            UsersDomainName,
                            DOMAIN_LOOKUP,
                            TRUE,       // Account Domain
                            &UsersDomainHandle,
                            &UsersDomainId );

            if ( NetStatus != NERR_Success ) {
                goto Cleanup;
            }

            DomainHandleToUse = UsersDomainHandle;
            DomainIdToUse = UsersDomainId;

        }


        //
        // Open the user asking for USER_LIST_GROUPS access.
        //

        NetStatus = UserpOpenUser( DomainHandleToUse,
                                   USER_LIST_GROUPS,
                                   UserName,
                                   &UserHandle,
                                   &UserRelativeId);  // Relative Id

        if ( NetStatus != NERR_Success ) {
            goto Cleanup;
        }

        //
        // Get the group membership from SAM, since we are
        // interested in indirect alias membership via group membership.
        //
        // This API is an odd one for SAM.  It returns all of the membership
        // information in a single call.
        //

        Status = SamGetGroupsForUser( UserHandle, &GroupMembership, &GroupCount );

        if ( !NT_SUCCESS( Status ) ) {
            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint((
                    "NetUserGetGroups: SamGetGroupsForUser returned %lX\n",
                    Status ));
            }
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }
    }


    //
    // Allocate a buffer to point to the SIDs we're interested in
    // alias membership for.
    //

    UserSids = (PSID *) NetpMemoryAllocate( (GroupCount+1) * sizeof(PSID) );

    if ( UserSids == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory( UserSids, (GroupCount+1) * sizeof(PSID) );


    //
    // If no domain is specified,
    //  just grab the SID of the user account from SAM.
    //

    if ( BackSlash == NULL ) {

        //
        // Get the rid of the account
        //

        if ( UserRelativeId == 0 ) {

            NetStatus = UserpOpenUser( DomainHandle,
                                       0,
                                       UserName,
                                       NULL,
                                       &UserRelativeId);  // Relative Id

            if ( NetStatus != NERR_Success ) {
                goto Cleanup;
            }
        }

        //
        // Add the User's Sid to the Array of Sids.
        //

        NetStatus = NetpSamRidToSid( DomainHandle,
                                     UserRelativeId,
                                    &UserSids[UserSidCount] );

        if ( NetStatus != NERR_Success ) {
            goto Cleanup;
        }

        UserSidCount ++;

    //
    // If a domain name is specified,
    //  use LookupAccountName to translate the name to a SID.
    //
    // Don't open the user account.  We typically don't have access to do that.
    // Newer version of NT don't allow anything over the NULL session.
    //

    } else {

            //
            // Translate the name to a SID.
            //

            NetStatus = AliaspNamesToSids ( ServerName,
                                            TRUE,   // Only allow users
                                            1,
                                            (LPWSTR *)&OrigUserName,
                                            &UserSidList );

            if ( NetStatus != NERR_Success ) {
                if ( NetStatus == ERROR_NO_SUCH_MEMBER ) {
                    NetStatus = NERR_UserNotFound;
                }
                goto Cleanup;
            }

            //
            // Add the User's Sid to the Array of Sids.
            //

            UserSids[UserSidCount] = UserSidList[0];
            UserSidList[0] = NULL;
            UserSidCount ++;


    }


    //
    // Add each group the user is a member of to the array of Sids.
    // Note that GroupCount would still be zero if LG_INCLUDE_INDIRECT isn't
    // specified.
    //

    for ( GroupIndex = 0; GroupIndex < GroupCount; GroupIndex ++ ) {

        NetStatus = NetpSamRidToSid( UserHandle,
                                     GroupMembership[GroupIndex].RelativeId,
                                    &UserSids[UserSidCount] );

        if ( NetStatus != NERR_Success ) {
            goto Cleanup;
        }

        UserSidCount ++;
    }


    //
    // Find out which aliases in the ACCOUNT domain this user is a member of.
    //

    Status = SamGetAliasMembership( DomainHandle,
                                    UserSidCount,
                                    UserSids,
                                    &PartialCount,
                                    &Aliases );

    if ( !NT_SUCCESS(Status) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint((
                "UserpGetUserPriv: SamGetAliasMembership returns %lX\n",
                Status ));
        }
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    if (PartialCount > 0)
    {
        //
        // Convert the RIDs to names
        //

        Status = SamLookupIdsInDomain( DomainHandle,
                                       PartialCount,
                                       Aliases,
                                       &Names,
                                       NULL ); // NameUse
        if ( !NT_SUCCESS( Status ) ) {
            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint((
                    "NetUserGetGroups: SamLookupIdsInDomain returned %lX\n",
                    Status ));
            }
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        NetStatus = AliaspPackBuf( Level,
                                   PrefMaxLen,
                                   PartialCount,
                                   EntriesRead,
                                   &BufferDescriptor,
                                   FixedSize,
                                   Names) ;

        if (NetStatus != NERR_Success && NetStatus != ERROR_MORE_DATA)
            goto Cleanup;

        //
        // free up and reset pointers that need to be reused
        //

        Status = SamFreeMemory( Names );
        NetpAssert( NT_SUCCESS(Status) );
        Names = NULL ;

        Status = SamFreeMemory( Aliases );
        NetpAssert( NT_SUCCESS(Status) );
        Aliases = NULL ;

        *EntriesLeft = PartialCount ;
    }

    //
    // Find out which aliases in the BUILTIN domain this user is a member of.
    //

    Status = SamGetAliasMembership( BuiltinDomainHandle,
                                    UserSidCount,
                                    UserSids,
                                    &PartialCount,
                                    &Aliases );

    if ( !NT_SUCCESS(Status) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint((
                "UserpGetUserPriv: SamGetAliasMembership returns %lX\n",
                Status ));
        }
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Convert the RIDs to names
    //

    Status = SamLookupIdsInDomain( BuiltinDomainHandle,
                                   PartialCount,
                                   Aliases,
                                   &Names,
                                   NULL ); // NameUse
    if ( !NT_SUCCESS( Status ) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint((
                "NetUserGetGroups: SamLookupIdsInDomain returned %lX\n",
                Status ));
        }
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    NetStatus = AliaspPackBuf( Level,
                               PrefMaxLen,
                               PartialCount,
                               EntriesRead,
                               &BufferDescriptor,
                               FixedSize,
                               Names) ;

    *EntriesLeft += PartialCount ;

    //
    // Clean up.
    //

Cleanup:

    //
    // Free any resources used locally
    //

    if ( DomainId != NULL ) {
        NetpMemoryFree( DomainId );
    }
    if ( UsersDomainId != NULL ) {
        NetpMemoryFree( UsersDomainId );
    }

    if ( Names != NULL ) {
        Status = SamFreeMemory( Names );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if ( UserHandle != NULL ) {
        (VOID) SamCloseHandle( UserHandle );
    }

    if ( GroupMembership != NULL ) {
        Status = SamFreeMemory( GroupMembership );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if ( UserSids != NULL ) {

        for ( GroupIndex = 0; GroupIndex < UserSidCount; GroupIndex ++ ) {
            NetpMemoryFree( UserSids[GroupIndex] );
        }

        NetpMemoryFree( UserSids );
    }

    if ( UserSidList != NULL ) {
        AliaspFreeSidList ( 1, UserSidList );
    }

    if ( Aliases != NULL ) {
        Status = SamFreeMemory( Aliases );
        NetpAssert( NT_SUCCESS(Status) );
    }


    if ( BuiltinDomainHandle != NULL ) {
        UaspCloseDomain( BuiltinDomainHandle );
    }

    if ( DomainHandle != NULL ) {
        UaspCloseDomain( DomainHandle );
    }

    if ( UsersDomainHandle != NULL ) {
        UaspCloseDomain( UsersDomainHandle );
    }

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }


    //
    // If we're not returning data to the caller,
    //  free the return buffer.
    //

    if ( NetStatus != NERR_Success && NetStatus != ERROR_MORE_DATA ) {
        if ( BufferDescriptor.Buffer != NULL ) {
            MIDL_user_free( BufferDescriptor.Buffer );
            BufferDescriptor.Buffer = NULL;
        }
        *EntriesLeft = 0;
        *EntriesRead = 0;
    }
    *Buffer = BufferDescriptor.Buffer;

    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "NetUserGetGroups: returning %ld\n", NetStatus ));
    }


    return NetStatus;

} // NetUserGetLocalGroups

NET_API_STATUS NET_API_FUNCTION
AliaspPackBuf(
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    IN DWORD EntriesCount,
    OUT LPDWORD EntriesRead,
    BUFFER_DESCRIPTOR *BufferDescriptor,
    DWORD FixedSize,
    PUNICODE_STRING Names)
{

    NET_API_STATUS NetStatus = NERR_Success ;
    ULONG i ;

    //
    // Determine the number of entries that will fit in the caller's
    // buffer.
    //

    for ( i=0; i < EntriesCount; i++ ) {
        DWORD Size;
        PLOCALGROUP_USERS_INFO_0 lgrui0;

        //
        // Compute the size of the next entry
        //

        Size = FixedSize + Names[i].Length + sizeof(WCHAR);

        //
        // Ensure the return buffer is big enough.
        //

        Size = ROUND_UP_COUNT( Size, ALIGN_WCHAR );

        NetStatus = NetpAllocateEnumBuffer(
                        BufferDescriptor,
                        FALSE,      // Is an enumeration routine.
                        PrefMaxLen,
                        Size,
                        AliaspMemberRelocationRoutine,
                        Level );

        if ( NetStatus != NERR_Success ) {
            break ;
        }

        //
        // Copy the data into the buffer
        //

        lgrui0 = (PLOCALGROUP_USERS_INFO_0) BufferDescriptor->FixedDataEnd;
        BufferDescriptor->FixedDataEnd += FixedSize ;

        if ( !NetpCopyStringToBuffer(
                  Names[i].Buffer,
                  Names[i].Length/sizeof(WCHAR),
                  BufferDescriptor->FixedDataEnd,
                  (LPWSTR *)&(BufferDescriptor->EndOfVariableData),
                  &lgrui0->lgrui0_name) ) {

            NetStatus = NERR_InternalError;
            break ;
        }

        (*EntriesRead)++;

    }

    return NetStatus ;
}


NET_API_STATUS NET_API_FUNCTION
NetUserModalsGet(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE *Buffer
    )

/*++

Routine Description:

    Retrieve global information for all users and groups in the user
    account database.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    Level - Level of information required. 0, 1, and 2 are valid.

    Buffer - Returns a pointer to the return information structure.
        Caller must deallocate buffer using NetApiBufferFree.

Return Value:

    Error code for the operation.

--*/

{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    PSID DomainId = NULL;

    ACCESS_MASK DesiredAccess;

    DWORD Size;     // Size of returned information

    PDOMAIN_PASSWORD_INFORMATION DomainPassword = NULL;
    PDOMAIN_LOGOFF_INFORMATION DomainLogoff = NULL;
    PDOMAIN_SERVER_ROLE_INFORMATION DomainServerRole = NULL;
    PDOMAIN_REPLICATION_INFORMATION DomainReplication = NULL;
    PDOMAIN_NAME_INFORMATION DomainName = NULL;
    PDOMAIN_LOCKOUT_INFORMATION DomainLockout = NULL;

    //
    // Validate Level
    //

    *Buffer = NULL;

    switch (Level) {
    case 0:
        DesiredAccess =
            DOMAIN_READ_OTHER_PARAMETERS | DOMAIN_READ_PASSWORD_PARAMETERS ;
        break;

    case 1:
        DesiredAccess = DOMAIN_READ_OTHER_PARAMETERS;
        break;

    case 2:
        DesiredAccess = DOMAIN_READ_OTHER_PARAMETERS;
        break;

    case 3:
        DesiredAccess = DOMAIN_READ_PASSWORD_PARAMETERS;
        break;

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetUserModalsGet: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the Domain
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DesiredAccess,
                                TRUE,   // Account Domain
                                &DomainHandle,
                                &DomainId );

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }


    //
    // Get the desired information from SAM and determine the size of
    //  our return information.
    //

    switch (Level) {
    case 0:

        Status = SamQueryInformationDomain(
                    DomainHandle,
                    DomainPasswordInformation,
                    (PVOID *)&DomainPassword );

        if ( !NT_SUCCESS( Status ) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        Status = SamQueryInformationDomain(
                    DomainHandle,
                    DomainLogoffInformation,
                    (PVOID *)&DomainLogoff );

        if ( !NT_SUCCESS( Status ) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        Size = sizeof( USER_MODALS_INFO_0 );

        break;

    case 1:

        Status = SamQueryInformationDomain(
                    DomainHandle,
                    DomainServerRoleInformation,
                    (PVOID *)&DomainServerRole );

        if ( !NT_SUCCESS( Status ) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        Status = SamQueryInformationDomain(
                    DomainHandle,
                    DomainReplicationInformation,
                    (PVOID *)&DomainReplication );

        if ( !NT_SUCCESS( Status ) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        Size = sizeof( USER_MODALS_INFO_1 ) +
            DomainReplication->ReplicaSourceNodeName.Length + sizeof(WCHAR);
        break;

    case 2:

        Status = SamQueryInformationDomain(
                    DomainHandle,
                    DomainNameInformation,
                    (PVOID *)&DomainName );

        if ( !NT_SUCCESS( Status ) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        Size = sizeof( USER_MODALS_INFO_2 ) +
            DomainName->DomainName.Length + sizeof(WCHAR) +
            RtlLengthSid( DomainId );

        break;

    case 3:

        Status = SamQueryInformationDomain(
                    DomainHandle,
                    DomainLockoutInformation,
                    (PVOID *)&DomainLockout );

        if ( !NT_SUCCESS( Status ) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        Size = sizeof( USER_MODALS_INFO_3 );

        break;

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;


    }

    //
    // Allocate the return buffer
    //

    Size = ROUND_UP_COUNT( Size, ALIGN_WCHAR );

    *Buffer = MIDL_user_allocate( Size );

    if ( *Buffer == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Fill in the return buffer
    //

    switch (Level) {
    case 0: {
        PUSER_MODALS_INFO_0 usrmod0 = (PUSER_MODALS_INFO_0) *Buffer;

        usrmod0->usrmod0_min_passwd_len = DomainPassword->MinPasswordLength;

        usrmod0->usrmod0_max_passwd_age =
            NetpDeltaTimeToSeconds( DomainPassword->MaxPasswordAge );

        usrmod0->usrmod0_min_passwd_age =
            NetpDeltaTimeToSeconds( DomainPassword->MinPasswordAge );

        usrmod0->usrmod0_force_logoff =
            NetpDeltaTimeToSeconds( DomainLogoff->ForceLogoff );

        usrmod0->usrmod0_password_hist_len =
            DomainPassword->PasswordHistoryLength;

        break;

    }

    case 1: {
        PUSER_MODALS_INFO_1 usrmod1 = (PUSER_MODALS_INFO_1) *Buffer;
        LPWSTR EndOfVariableData = (LPWSTR) (*Buffer + Size);


        switch (DomainServerRole->DomainServerRole) {

        case DomainServerRolePrimary:
            usrmod1->usrmod1_role = UAS_ROLE_PRIMARY;
            break;

        case DomainServerRoleBackup:
            usrmod1->usrmod1_role = UAS_ROLE_BACKUP;
            break;

        default:
            NetStatus = NERR_InternalError;
            goto Cleanup;
        }

        if ( !NetpCopyStringToBuffer(
                DomainReplication->ReplicaSourceNodeName.Buffer,
                DomainReplication->ReplicaSourceNodeName.Length/sizeof(WCHAR),
                *Buffer + sizeof(USER_MODALS_INFO_1),
                &EndOfVariableData,
                &usrmod1->usrmod1_primary) ) {

            NetStatus = NERR_InternalError;
            goto Cleanup;

        }

        break;

    }

    case 2: {
        PUSER_MODALS_INFO_2 usrmod2 = (PUSER_MODALS_INFO_2) *Buffer;
        LPWSTR EndOfVariableData = (LPWSTR) (*Buffer + Size);

        //
        // Copy text first size it has more stringent alignment requirements
        //

        if ( !NetpCopyStringToBuffer(
                DomainName->DomainName.Buffer,
                DomainName->DomainName.Length/sizeof(WCHAR),
                *Buffer + sizeof(USER_MODALS_INFO_2),
                &EndOfVariableData,
                &usrmod2->usrmod2_domain_name) ) {

            NetStatus = NERR_InternalError;
            goto Cleanup;

        }

        if ( !NetpCopyDataToBuffer(
                DomainId,
                RtlLengthSid( DomainId ),
                *Buffer + sizeof(USER_MODALS_INFO_2),
                (LPBYTE *)&EndOfVariableData,
                (LPBYTE *)&usrmod2->usrmod2_domain_id,
                sizeof(BYTE) ) ) {

            NetStatus = NERR_InternalError;
            goto Cleanup;

        }

        break;

    }

    case 3: {
        PUSER_MODALS_INFO_3 usrmod3 = (PUSER_MODALS_INFO_3) *Buffer;

        usrmod3->usrmod3_lockout_duration =
            NetpDeltaTimeToSeconds( DomainLockout->LockoutDuration );

        usrmod3->usrmod3_lockout_observation_window =
            NetpDeltaTimeToSeconds( DomainLockout->LockoutObservationWindow );

        usrmod3->usrmod3_lockout_threshold = DomainLockout->LockoutThreshold;

        break;

    }

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;

    }

    NetStatus = NERR_Success;

    //
    // Clean up.
    //

Cleanup:
    if (DomainPassword != NULL) {
        Status = SamFreeMemory( DomainPassword );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if (DomainLogoff != NULL) {
        Status = SamFreeMemory( DomainLogoff );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if (DomainServerRole != NULL) {
        Status = SamFreeMemory( DomainServerRole );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if (DomainReplication != NULL) {
        Status = SamFreeMemory( DomainReplication );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if (DomainName != NULL) {
        Status = SamFreeMemory( DomainName );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if ( DomainLockout != NULL ) {
        Status = SamFreeMemory( DomainLockout );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if ( DomainId != NULL ) {
        NetpMemoryFree( DomainId );
    }

    if ( DomainHandle != NULL ) {
        UaspCloseDomain( DomainHandle );
    }

    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetUserModalsGet( (LPWSTR)ServerName, Level, Buffer );

    UASP_DOWNLEVEL_END;

    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "NetUserModalsGet: returning %ld\n", NetStatus ));
    }

    return NetStatus;

} // NetUserModalsGet



NET_API_STATUS NET_API_FUNCTION
NetUserModalsSet(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD Level,
    IN LPBYTE Buffer,
    OUT LPDWORD ParmError OPTIONAL  // Name required by NetpSetParmError
    )

/*++

Routine Description:

    Sets global information for all users and group in the user account.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer
        or string specifies the local machine.

    Level - Level of information provided.

    Buffer - A pointer to the buffer containing the user information
        structure.

    ParmError - Optional pointer to a DWORD to return the index of the
        first parameter in error when ERROR_INVALID_PARAMETER is returned.
        If NULL, the parameter is not returned on error.

Return Value:

    Error code for the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;

    ACCESS_MASK DesiredAccess;
    DWORD UasSamIndex;

    BOOL LSAServerRoleSet = FALSE;
    BOOL BuiltinDomainServerRoleSet = FALSE;

    //
    // Each SAM Information Class is described here.  If multiple fields
    // can be set in the same information class, each field is set in a
    // common copy of the information class strcuture.
    //

    struct _SAM_INFORMATION_CLASS {

        //
        // Sam's DomainInformation class for this class.
        //

        DOMAIN_INFORMATION_CLASS DomainInformationClass;

        //
        // The size of this information class structure.
        //

        DWORD SamSize;

        //
        // The state of this information class.  As we decide to use this
        // information class, actually change it, and possibly restore
        // its old value, we change the state so later stages of this routine
        // can handle each entry.
        //

        enum {
            UTS_NOT_USED,   // No fields are being used
            UTS_USED,       // At least one field is to be changed
            UTS_READ,       // This info class has been read from SAM
            UTS_DONE,       // This info class has been changed in SAM
            UTS_RECOVERED   // This info class has be reverted to old values.
        } State;

        //
        // Before this routine changes anything, it gets the old value for
        // each of the information classes.  This old value is used for
        // recovery in the event that an error occurs.  That is, we will
        // attempt to put the old information back if we aren't successful
        // in changing all the information to the new values.
        //
        // The old information is also used in the case where a single
        // information class contains multiple fields and we're only changing
        // a subset of those fields.
        //

        PVOID OldInformation;

        //
        // The new field values are stored in this instance of the information
        // class.
        //

        PVOID NewInformation;

        //
        // The DesiredAccess mask includes both the access to read and the
        // access to write the appropriate DomainInformationClass.
        //

        ACCESS_MASK DesiredAccess;

    } SamInfoClass[] = {

    //
    // Define a SAM_INFORMATION_CLASS for each information class possibly
    // used.
    //
    // The order of the entries in this array must match the order of
    // the SAM_* defines above.
    //

    /* SAM_LogoffClass */ {
        DomainLogoffInformation, sizeof( DOMAIN_LOGOFF_INFORMATION ),
        UTS_NOT_USED, NULL, NULL,
        DOMAIN_READ_OTHER_PARAMETERS | DOMAIN_WRITE_OTHER_PARAMETERS
    },

    /* SAM_NameClass */ {
        DomainNameInformation, sizeof( DOMAIN_NAME_INFORMATION ),
        UTS_NOT_USED, NULL, NULL,
        DOMAIN_READ_OTHER_PARAMETERS | DOMAIN_WRITE_OTHER_PARAMETERS
    },

    /* SAM_PasswordClass */ {
        DomainPasswordInformation, sizeof( DOMAIN_PASSWORD_INFORMATION),
        UTS_NOT_USED, NULL, NULL,
        DOMAIN_READ_PASSWORD_PARAMETERS | DOMAIN_WRITE_PASSWORD_PARAMS
    },

    /* SAM_ReplicationClass */ {
        DomainReplicationInformation, sizeof( DOMAIN_REPLICATION_INFORMATION ),
        UTS_NOT_USED, NULL, NULL,
        DOMAIN_READ_OTHER_PARAMETERS | DOMAIN_ADMINISTER_SERVER
    },

    /* SAM_ServerRoleClass */ {
        DomainServerRoleInformation, sizeof( DOMAIN_SERVER_ROLE_INFORMATION ),
        UTS_NOT_USED, NULL, NULL,
        DOMAIN_READ_OTHER_PARAMETERS | DOMAIN_ADMINISTER_SERVER
    },

    /* Sam_LockoutClass */ {
        DomainLockoutInformation, sizeof( DOMAIN_LOCKOUT_INFORMATION ),
        UTS_NOT_USED, NULL, NULL,
        DOMAIN_READ_PASSWORD_PARAMETERS | DOMAIN_WRITE_PASSWORD_PARAMS
    }
    };

    //
    // Define several macros for accessing the various fields of the UAS
    // structure.  Each macro takes an index into the UserUasSamTable
    // array and returns the value.
    //

#define GET_UAS_MODAL_STRING_POINTER( _i ) \
        (*((LPWSTR *)(Buffer + UserUasSamTable[_i].UasOffset)))

#define GET_UAS_MODAL_DWORD( _i ) \
        (*((DWORD *)(Buffer + UserUasSamTable[_i].UasOffset)))

    //
    // Define a macro which returns a pointer the appropriate SamInfoClass
    // structure given an index into the UserUasSamTable.
    //

#define SAM_MODAL_CLASS( _i ) \
        SamInfoClass[ UserUasSamTable[_i].Class ]

    //
    // Define a macro to return a pointer to the appropriate field in the
    // new sam structure.
    //
    // The caller should coerce the pointer as appropriate.
    //

#define GET_SAM_MODAL_FIELD_POINTER( _i ) \
    (((LPBYTE)(SAM_MODAL_CLASS(_i).NewInformation)) + \
        UserUasSamTable[_i].SamOffset)

    //
    // Initialize
    //

    NetpSetParmError( PARM_ERROR_NONE );

    //
    // Go through the list of valid fields determining if the info level
    // is valid and computing the desired access to the domain.
    //

    DesiredAccess = 0;
    for ( UasSamIndex=0 ;
        UasSamIndex<sizeof(UserUasSamTable)/sizeof(UserUasSamTable[0]);
        UasSamIndex++ ){

        //
        // If this field isn't one we're changing, just skip to the next one
        //

        if ( Level != UserUasSamTable[UasSamIndex].UasLevel ) {
            continue;
        }

        //
        // Validate the UAS field based on the field type.
        //

        switch (UserUasSamTable[UasSamIndex].ModalsFieldType ) {

        //
        // If this is a PARMNUM_ALL and the caller passed in a
        // NULL pointer to a string, he doesn't want to change the string.
        //
        // Testing for this now allows us to completely ignore a
        // particular SAM information level if absolutely no fields
        // change in that information level.
        //

        case UMT_STRING:
            if ( GET_UAS_MODAL_STRING_POINTER( UasSamIndex ) == NULL ) {

                continue;
            }
            break;

        //
        // Ensure unsigned shorts are really in range.
        //

        case UMT_USHORT:
            if ( GET_UAS_MODAL_DWORD(UasSamIndex) > USHRT_MAX ) {

                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint((
                        "NetUserModalsSet: ushort too big %lx Index:%ld\n",
                        GET_UAS_MODAL_DWORD(UasSamIndex),
                        UasSamIndex ));
                }
                NetpSetParmError( UserUasSamTable[UasSamIndex].UasParmNum );
                NetStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }

        //
        // Some values are always valid
        //

        case UMT_ULONG:
        case UMT_DELTA:
            break;

        //
        // Ensure the role is a recognized one.
        //

        case UMT_ROLE:
            switch ( GET_UAS_MODAL_DWORD(UasSamIndex) ) {
            case UAS_ROLE_PRIMARY:
            case UAS_ROLE_BACKUP:
            case UAS_ROLE_MEMBER:
                break;

            default:
                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint((
                        "NetUserModalsSet: invalid role %lx Index:%ld\n",
                        GET_UAS_MODAL_DWORD(UasSamIndex),
                        UasSamIndex ));
                }
                NetpSetParmError( UserUasSamTable[UasSamIndex].UasParmNum );
                NetStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }

            break;

        //
        // All cases are explicitly handled.
        //

        default:
            NetStatus = NERR_InternalError;
            goto Cleanup;

        }

        //
        // Flag that this information class is to be set and
        // accumulate the desired access to do all this functionality.
        //

        SAM_MODAL_CLASS(UasSamIndex).State = UTS_USED;
        DesiredAccess |= SAM_MODAL_CLASS(UasSamIndex).DesiredAccess;

    }

    //
    // Check to be sure the user specified a valid Level.
    //
    // The search of the UserUasSamTable should have resulted in
    // at least one match if the arguments are valid.
    //

    if ( DesiredAccess == 0 ) {
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    //
    // Connect to the SAM server
    //

    NetStatus = UaspOpenSam( ServerName,
                             FALSE,  // Don't try null session
                             &SamServerHandle );

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetUserModalsSet: Cannot UaspOpenSam %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the domain asking for accumulated desired access
    //

    NetStatus = UaspOpenDomain( SamServerHandle,
                                DesiredAccess,
                                TRUE,   // Account Domain
                                &DomainHandle,
                                NULL );  // DomainId

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // For each field we're going to change,
    //       Get the current value of the field
    //       Determine what the new value will be.
    //
    // The old values will be used later in error recovery and when multiple
    // fields are changed in SAM with one information level.
    //

    for ( UasSamIndex=0 ;
        UasSamIndex<sizeof(UserUasSamTable)/sizeof(UserUasSamTable[0]);
        UasSamIndex++ ) {

        //
        // If this field isn't one we're changing, just skip to the next one
        //

        if ( Level != UserUasSamTable[UasSamIndex].UasLevel ) {
            continue;
        }

        //
        // Handle field types that have some special attributes.
        //

        switch (UserUasSamTable[UasSamIndex].ModalsFieldType ) {

        //
        // If the caller passed in a
        // NULL pointer to a string, he doesn't want to change the string.
        //

        case UMT_STRING:
            if ( GET_UAS_MODAL_STRING_POINTER( UasSamIndex ) == NULL ) {
                continue;
            }
            break;

        //
        // Other field types don't have any special case handling.
        //

        default:
            break;

        }

        //
        // ASSERT: This field type is set via a SAM information class
        //

        //
        // If we've not previously gotten this information class
        //    from SAM, do so now.
        //
        // If an information class has multiple fields, then multiple
        // entries in the UserUasSamTable will share the same old
        // information class.
        //

        if ( SAM_MODAL_CLASS(UasSamIndex).State == UTS_USED ) {

            //
            // Allocate space for the New information
            //

            SAM_MODAL_CLASS(UasSamIndex).State = UTS_READ;

            SAM_MODAL_CLASS(UasSamIndex).NewInformation = NetpMemoryAllocate(
                SAM_MODAL_CLASS(UasSamIndex).SamSize );

            if ( SAM_MODAL_CLASS(UasSamIndex).NewInformation == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            //
            // Get this information class from SAM.
            //

            Status = SamQueryInformationDomain(
                        DomainHandle,
                        SAM_MODAL_CLASS(UasSamIndex).DomainInformationClass,
                        &SAM_MODAL_CLASS(UasSamIndex).OldInformation );

            if ( !NT_SUCCESS(Status) ) {
                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint((
                        "NetUserModalsSet: Error from"
                        " SamQueryInformationDomain %lx Index:%ld\n",
                        Status,
                        UasSamIndex ));
                }
                NetStatus = NetpNtStatusToApiStatus( Status );
                goto Cleanup;
            }

            //
            // Initialize the new SAM info class structure with the old
            // values.
            //

            NetpMoveMemory( SAM_MODAL_CLASS(UasSamIndex).NewInformation,
                            SAM_MODAL_CLASS(UasSamIndex).OldInformation,
                            SAM_MODAL_CLASS(UasSamIndex).SamSize );

        }

        //
        // Set the SAM field in the new information class structure to
        //  the UAS requested value.
        //

        switch ( UserUasSamTable[UasSamIndex].ModalsFieldType ) {

        //
        // Handle values of type string
        //

        case UMT_STRING:
            RtlInitUnicodeString(
                           (PUNICODE_STRING) GET_SAM_MODAL_FIELD_POINTER(UasSamIndex),
                           GET_UAS_MODAL_STRING_POINTER(UasSamIndex) );
            break;

        //
        // Convert delta time to its SAM counterpart
        //

        case UMT_DELTA:

            *((PLARGE_INTEGER) GET_SAM_MODAL_FIELD_POINTER(UasSamIndex)) =
                NetpSecondsToDeltaTime( GET_UAS_MODAL_DWORD(UasSamIndex) );
            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint((
                    "UserpsetInfo: Index: %ld Setting DeltaTime %lx %lx %lx\n",
                    UasSamIndex,
                    ((PLARGE_INTEGER) GET_SAM_MODAL_FIELD_POINTER(UasSamIndex))
                        ->HighPart,
                    ((PLARGE_INTEGER) GET_SAM_MODAL_FIELD_POINTER(UasSamIndex))
                        ->LowPart,
                    GET_UAS_MODAL_DWORD(UasSamIndex) ));
            }


            break;

        //
        // Copy the unsigned short to the SAM structure
        //

        case UMT_USHORT:
            *((PUSHORT)GET_SAM_MODAL_FIELD_POINTER(UasSamIndex)) =
                (USHORT)GET_UAS_MODAL_DWORD(UasSamIndex);
            break;

        //
        // Copy the unsigned long to the SAM structure
        //

        case UMT_ULONG:
            *((PULONG)GET_SAM_MODAL_FIELD_POINTER(UasSamIndex)) =
                (ULONG)GET_UAS_MODAL_DWORD(UasSamIndex);
            break;

        //
        // Ensure the role is a recognized one.
        //

        case UMT_ROLE:


            switch ( GET_UAS_MODAL_DWORD(UasSamIndex) ) {
            case UAS_ROLE_PRIMARY:
                *((PDOMAIN_SERVER_ROLE)GET_SAM_MODAL_FIELD_POINTER(UasSamIndex)) =
                    DomainServerRolePrimary;
                break;
            case UAS_ROLE_BACKUP:
                *((PDOMAIN_SERVER_ROLE)GET_SAM_MODAL_FIELD_POINTER(UasSamIndex)) =
                    DomainServerRoleBackup;
                break;

            default:
                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint((
                        "NetUserModalsSet: invalid role %lx Index:%ld\n",
                        GET_UAS_MODAL_DWORD(UasSamIndex),
                        UasSamIndex ));
                }
                NetpSetParmError( UserUasSamTable[UasSamIndex].UasParmNum );
                NetStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }

            break;


        //
        // All types should have been handled above.
        //

        default:
            NetStatus = NERR_InternalError;
            goto Cleanup;

        }

    }

    //
    // Set the new values of the fields
    //
    // For role change, I should stop/start the SAM server as appropriate.
    // The UI will stop/start the NetLogon service. ??
    //

    for ( UasSamIndex=0 ;
        UasSamIndex<sizeof(UserUasSamTable)/sizeof(UserUasSamTable[0]);
        UasSamIndex++ ){

        //
        // Make the changes to the Sam Database now.
        //

        if ( SAM_MODAL_CLASS(UasSamIndex).State == UTS_READ ) {

            // if the information class is DomainServerRoleInformation
            // we need to update the ServerRole in LSA first then in SAM.

            if( SAM_MODAL_CLASS(UasSamIndex).DomainInformationClass ==
                    DomainServerRoleInformation ) {

                NetStatus = UaspLSASetServerRole(
                                ServerName,
                                SAM_MODAL_CLASS(UasSamIndex).NewInformation );

                if( NetStatus != NERR_Success ) {

                    IF_DEBUG( UAS_DEBUG_USER ) {
                        NetpKdPrint((
                            "NetUserModalsSet: Error from"
                            " UaspLSASetServerRole %lx Index:%ld\n",
                            NetStatus,
                            UasSamIndex ));
                    }
                    NetpSetParmError( UserUasSamTable[UasSamIndex].UasParmNum );
                    goto Cleanup;
                }

                LSAServerRoleSet = TRUE;

                NetStatus = UaspBuiltinDomainSetServerRole(
                                SamServerHandle,
                                SAM_MODAL_CLASS(UasSamIndex).NewInformation );

                if( NetStatus != NERR_Success ) {

                    IF_DEBUG( UAS_DEBUG_USER ) {
                        NetpKdPrint((
                            "NetUserModalsSet: Error from"
                            " UaspBuiltinDomainSetServerRole %lx Index:%ld\n",
                            NetStatus,
                            UasSamIndex ));
                    }
                    NetpSetParmError( UserUasSamTable[UasSamIndex].UasParmNum );
                    goto Cleanup;
                }

                BuiltinDomainServerRoleSet = TRUE;
            }

            Status = SamSetInformationDomain(
                        DomainHandle,
                        SAM_MODAL_CLASS(UasSamIndex).DomainInformationClass,
                        SAM_MODAL_CLASS(UasSamIndex).NewInformation );

            if ( !NT_SUCCESS(Status) ) {
                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint((
                        "NetUserModalsSet: Error from"
                        " SamSetInformationDomain %lx Index:%ld\n",
                        Status,
                        UasSamIndex ));
                }
                NetpSetParmError( UserUasSamTable[UasSamIndex].UasParmNum );
                NetStatus = NetpNtStatusToApiStatus( Status );
                goto Cleanup;
            }

            //
            // Mark this Entry as having been done
            //

            SAM_MODAL_CLASS(UasSamIndex).State = UTS_DONE ;

        }

    }

    NetStatus = NERR_Success;

    //
    // Clean up.
    //

Cleanup:

    //
    // need to revert the LSA server role when we are unsuccessful to
    // set the info completely.
    //

    if( NetStatus != NERR_Success && LSAServerRoleSet ) {

#ifdef notdef

        NetpAssert( !UaspLSASetServerRole(
                        ServerName,
                        SamInfoClass[SAM_ServerRoleClass].OldInformation ) );
#endif

    }

    //
    // revert server role in builtin domain
    //

    if( NetStatus != NERR_Success && BuiltinDomainServerRoleSet ) {

#ifdef notdef

        NetpAssert( !UaspBuiltinDomainSetServerRole(
                        SamServerHandle,
                        SamInfoClass[SAM_ServerRoleClass].OldInformation ) );
#endif

    }

    //
    // Loop through the UserUasSamTable cleaning up anything that
    // needs cleaning.
    //

    for ( UasSamIndex=0 ;
        UasSamIndex<sizeof(UserUasSamTable)/sizeof(UserUasSamTable[0]);
        UasSamIndex++ ) {

        //
        // If we've not been able to change everything and
        // this information class has been changed above,  change it
        // back to the old value here.  Ignore any error codes.  We
        // will report the original error to the caller.
        //

        if ( NetStatus != NERR_Success &&
             SAM_MODAL_CLASS(UasSamIndex).State == UTS_DONE ) {

            Status = SamSetInformationDomain(
                        DomainHandle,
                        SAM_MODAL_CLASS(UasSamIndex).DomainInformationClass,
                        SAM_MODAL_CLASS(UasSamIndex).OldInformation );
            NetpAssert( NT_SUCCESS(Status) );

            SAM_MODAL_CLASS(UasSamIndex).State = UTS_RECOVERED ;
        }


        //
        // Free any allocated Old information class.
        //

        if ( SAM_MODAL_CLASS(UasSamIndex).OldInformation != NULL ) {
            Status =
                SamFreeMemory( SAM_MODAL_CLASS(UasSamIndex).OldInformation );
            NetpAssert( NT_SUCCESS(Status) );

            SAM_MODAL_CLASS(UasSamIndex).OldInformation = NULL;
        }

        //
        // Free any allocated New information class.
        //

        if ( SAM_MODAL_CLASS(UasSamIndex).NewInformation != NULL ) {
            NetpMemoryFree( SAM_MODAL_CLASS(UasSamIndex).NewInformation );
            SAM_MODAL_CLASS(UasSamIndex).NewInformation = NULL;
        }

    }

    if ( DomainHandle != NULL ) {
        UaspCloseDomain( DomainHandle );
    }
    if ( SamServerHandle != NULL ) {
        (VOID) SamCloseHandle( SamServerHandle );
    }

    //
    // Handle downlevel.
    //

    UASP_DOWNLEVEL_BEGIN( ServerName, NetStatus )

        NetStatus = RxNetUserModalsSet( (LPWSTR) ServerName, Level, Buffer, ParmError );

    UASP_DOWNLEVEL_END;

    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "NetUserModalsSet: returning %ld\n", NetStatus ));
    }


    return NetStatus;

} // NetUserModalsSet





NET_API_STATUS NET_API_FUNCTION
NetUserChangePassword(
    IN LPCWSTR DomainName,
    IN LPCWSTR UserName,
    IN LPCWSTR OldPassword,
    IN LPCWSTR NewPassword
    )

/*++

Routine Description:

    Changes a users password.

Arguments:

    DomainName - A pointer to a string containing the name of the domain or
        remote server on which to change the password.  The name is assuemd
        to be a domain name unless it begins with "\\".  If no domain can be
        located by that name, it is prepended with "\\" and tried as a server
        name.
        If this parameter is not present the domain of the logged on
        user is used.

    UserName - Name of the user who's password is to be changed.

        If this parameter is not present, the logged on user is used.

    OldPassword - NULL terminated string containing the user's old password

    NewPassword - NULL terminated string containing the user's new password.

Return Value:

    Error code for the operation.

--*/
{
    NTSTATUS Status;
    HANDLE LsaHandle = NULL;
    NET_API_STATUS NetStatus = 0;
    PMSV1_0_CHANGEPASSWORD_REQUEST ChangeRequest = NULL;
    PMSV1_0_CHANGEPASSWORD_RESPONSE ChangeResponse = NULL;
    STRING PackageName;
    ULONG PackageId;
    ULONG RequestSize;
    ULONG ResponseSize = 0;
    PBYTE Where;
    NTSTATUS ProtocolStatus;
    PSECURITY_SEED_AND_LENGTH SeedAndLength;
    UCHAR Seed;
    PUNICODE_STRING LsaUserName = NULL;
    PUNICODE_STRING LsaDomainName = NULL;
    UNICODE_STRING UserNameU;
    UNICODE_STRING DomainNameU;

    //
    // If a user name and domain were not supplied, generate them now.
    //

    if ((DomainName == NULL) || (UserName == NULL)) {
        Status = LsaGetUserName(
                    &LsaUserName,
                    &LsaDomainName
                    );
        if (!NT_SUCCESS(Status)) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }
    }

    if (UserName == NULL) {
        UserNameU = *LsaUserName;
    } else {
        RtlInitUnicodeString(
            &UserNameU,
            UserName
            );
    }

    if (DomainName == NULL) {
        DomainNameU = *LsaDomainName;
    } else {
        RtlInitUnicodeString(
            &DomainNameU,
            DomainName
            );
    }


    //
    // Calculate the request size
    //

    RequestSize = sizeof(MSV1_0_CHANGEPASSWORD_REQUEST) +
                    UserNameU.Length + sizeof(WCHAR) +
                    DomainNameU.Length + sizeof(WCHAR);


    if (ARGUMENT_PRESENT(OldPassword)) {
        RequestSize += (wcslen(OldPassword)+1) * sizeof(WCHAR);
    } else {
        NetStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (ARGUMENT_PRESENT(NewPassword)) {
        RequestSize += (wcslen(NewPassword)+1) * sizeof(WCHAR);
    } else {
        NetStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }



    //
    // Connect to the LSA
    //

    Status = LsaConnectUntrusted(
                &LsaHandle
                );

    if (!NT_SUCCESS(Status)) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    RtlInitString(
        &PackageName,
        MSV1_0_PACKAGE_NAME
        );

    Status = LsaLookupAuthenticationPackage(
                LsaHandle,
                &PackageName,
                &PackageId
                );
    if (!NT_SUCCESS(Status)) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Allocate the request buffer
    //

    ChangeRequest = NetpMemoryAllocate( RequestSize );
    if (ChangeRequest == NULL) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;

    }


    //
    // Build up the request message
    //

    ChangeRequest->MessageType = MsV1_0ChangePassword;

    ChangeRequest->DomainName = DomainNameU;

    ChangeRequest->AccountName = UserNameU;

    RtlInitUnicodeString(
        &ChangeRequest->OldPassword,
        OldPassword
        );

    //
    // Limit passwords to 127 bytes so we can run-encode them.
    //

    if (ChangeRequest->OldPassword.Length > 127) {
        NetStatus = ERROR_PASSWORD_RESTRICTION;
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &ChangeRequest->NewPassword,
        NewPassword
        );

    if (ChangeRequest->NewPassword.Length > 127) {
        NetStatus = ERROR_PASSWORD_RESTRICTION;
        goto Cleanup;
    }


    //
    // Marshall the buffer pointers.  We run-encode the passwords so
    // we don't have cleartext password lying around the pagefile.
    //

    Where = (PBYTE) (ChangeRequest+1);

    ChangeRequest->DomainName.Buffer = (LPWSTR) Where;
    RtlCopyMemory(
        Where,
        DomainNameU.Buffer,
        ChangeRequest->DomainName.MaximumLength
        );
    Where += ChangeRequest->DomainName.MaximumLength;


    ChangeRequest->AccountName.Buffer = (LPWSTR) Where;
    RtlCopyMemory(
        Where,
        UserNameU.Buffer,
        ChangeRequest->AccountName.MaximumLength
        );
    Where += ChangeRequest->AccountName.MaximumLength;


    ChangeRequest->OldPassword.Buffer = (LPWSTR) Where;
    RtlCopyMemory(
        Where,
        OldPassword,
        ChangeRequest->OldPassword.MaximumLength
        );
    Where += ChangeRequest->OldPassword.MaximumLength;

    //
    // Run encode the passwords so they don't lie around the page file.
    //

    Seed = 0;
    RtlRunEncodeUnicodeString(
        &Seed,
        &ChangeRequest->OldPassword
        );
    SeedAndLength = (PSECURITY_SEED_AND_LENGTH) &ChangeRequest->OldPassword.Length;
    SeedAndLength->Seed = Seed;

    ChangeRequest->NewPassword.Buffer = (LPWSTR) Where;
    RtlCopyMemory(
        Where,
        NewPassword,
        ChangeRequest->NewPassword.MaximumLength
        );
    Where += ChangeRequest->NewPassword.MaximumLength;

    Seed = 0;
    RtlRunEncodeUnicodeString(
        &Seed,
        &ChangeRequest->NewPassword
        );
    SeedAndLength = (PSECURITY_SEED_AND_LENGTH) &ChangeRequest->NewPassword.Length;
    SeedAndLength->Seed = Seed;

    //
    // Since we are running in the caller's process, we most certainly are
    // impersonating him/her.
    //

    ChangeRequest->Impersonating = TRUE;

    //
    // Call the MSV1_0 package to change the password.
    //

    Status = LsaCallAuthenticationPackage(
                LsaHandle,
                PackageId,
                ChangeRequest,
                RequestSize,
                (PVOID *) &ChangeResponse,
                &ResponseSize,
                &ProtocolStatus
                );

    if (!NT_SUCCESS(Status)) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }
    if (!NT_SUCCESS(ProtocolStatus)) {
        NetStatus = NetpNtStatusToApiStatus( ProtocolStatus );
        goto Cleanup;
    }

    NetStatus = ERROR_SUCCESS;

Cleanup:
    if (LsaHandle != NULL) {
        NtClose(LsaHandle);
    }
    if (ChangeRequest != NULL) {
        RtlZeroMemory( ChangeRequest, RequestSize );
        NetpMemoryFree( ChangeRequest );
    }
    if (ChangeResponse != NULL) {
        LsaFreeReturnBuffer( ChangeResponse );
    }

    if (LsaUserName != NULL) {
        LsaFreeMemory(LsaUserName->Buffer);
        LsaFreeMemory(LsaUserName);
    }
    if (LsaDomainName != NULL) {
        LsaFreeMemory(LsaDomainName->Buffer);
        LsaFreeMemory(LsaDomainName);
    }

    return(NetStatus);

}


/*lint +e614 */
/*lint +e740 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\uastest2.c ===
///**************************************************************
///          Microsoft LAN Manager                              *
///        Copyright(c) Microsoft Corp., 1990-92                *
///**************************************************************
//
//  This program is designed to do functional testing on the following
//  APIs:
//      NetGroupAdd
//      NetGroupDel
//      NetGroupGetInfo
//      NetGroupSetInfo
//      NetGroupEnum
//      NetGroupAddUser
//      NetGroupDelUsers
//      NetGroupGetUsers
//      NetUserGetGroups
//      NetUserSetGroups
//
//  Note: This assumes UASTEST1 was run previously which
//  leaves two users, User1 & User2, defined on the NET.ACC.
//
//

#include <nt.h> // TIME definition
#include <ntrtl.h>      // TIME definition
#include <nturtl.h>     // TIME definition
#define NOMINMAX        // Avoid redefinition of min and max in stdlib.h
#include        <windef.h>
#include        <winbase.h>

#include        <stdio.h>
#include        <stdlib.h>
#include        <string.h>
#include        <lmcons.h>
#include        <lmapibuf.h>
#include        <netlib.h>
#include        <netdebug.h>
#include        <lmaccess.h>
#include        <lmerr.h>
#include <ntsam.h>

#include        "uastest.h"
#include "accessp.h"
#include "netlogon.h"
#include "logonp.h"

#define GROUP1      L"GROUP1"
#define GROUP2      L"GROUP2"
#define GROUP3      L"GROUP3"
#define GROUP4      L"GROUP4"
#define GROUP_COMMENT     L"This Group is added for demo"
#define PARM_COMMENT    L"This comment was added by SetInfo (level 1002)"

#define DEFAULT_GROUP_ATTR  ( SE_GROUP_MANDATORY |  \
                              SE_GROUP_ENABLED_BY_DEFAULT )

#define GROUP_ATTR          DEFAULT_GROUP_ATTR

LPWSTR group[] = {
    GROUP1, GROUP2, GROUP3, GROUP4 };



DWORD  group_count;

LPWSTR DefaultGroup;




void
clean_up()
{
    PUSER_INFO_0 UserInfo0;
    PGROUP_INFO_0 GroupInfo0;
    int Failed = 0;

    //
    // Expects Only four groups to be present Group1 thru Group4
    //

    err = 0;
    if (err = NetGroupDel(server, GROUP1))
        if (err != NERR_GroupNotFound) {
            error_exit(
                FAIL, "Cleanup GroupDel wrong status",
                GROUP1 );
            Failed = 1;
        }

    err = 0;
    if (err = NetGroupDel(server, GROUP2))
        if (err != NERR_GroupNotFound) {
            error_exit(
                FAIL, "Cleanup GroupDel wrong status",
                GROUP2 );
            Failed = 1;
        }

    err = 0;
    if (err = NetGroupDel(server, GROUP3))
        if (err != NERR_GroupNotFound) {
            error_exit(
                FAIL, "Cleanup GroupDel wrong status",
                GROUP3 );
            Failed = 1;
        }

    err = 0;
    if (err = NetGroupDel(server, GROUP4))
        if (err != NERR_GroupNotFound) {
            error_exit(
                FAIL, "Cleanup GroupDel wrong status",
                GROUP4 );
            Failed = 1;
        }

    if (!Failed) {
        error_exit(PASS, "Successful clean up of groups", NULL );
    }

    //
    // count the existing number of Groups in the database
    //

    err = NetGroupEnum(server, 0, (LPBYTE *)&GroupInfo0, 0xffffffff,
                &nread, &total, NULL);
    if (err)
        error_exit(FAIL, "Initial Enumeration Failed", NULL);
    else
        group_count = total;

    (VOID)NetApiBufferFree( GroupInfo0 );

    //
    // also verify that USER1 and USER2 exist in database
    //

    if (err = NetUserGetInfo(server, USER1, 0, (LPBYTE *)&UserInfo0)) {
        exit_flag = 1;
        error_exit( FAIL, "Test aborted. user not in database",
                USER1 );
    } else {
        (VOID)NetApiBufferFree( UserInfo0 );
    }

    if (err = NetUserGetInfo(server, USER2, 0, (LPBYTE *)&UserInfo0)) {
        exit_flag = 1;
        error_exit( FAIL, "Test aborted. user not in database",
                USER2 );
    } else {
        (VOID)NetApiBufferFree( UserInfo0 );
    }

}




void
add_group_l1(namep)
    LPWSTR namep;
{
    GROUP_INFO_1 GroupInfo1;

    GroupInfo1.grpi1_name = namep;
    GroupInfo1.grpi1_comment = GROUP_COMMENT;

    if (err = NetGroupAdd(server, 1, (char * ) &GroupInfo1, NULL )) {
        error_exit(FAIL, "GroupAdd (level 1) failed", namep );
    } else {
        error_exit(PASS, "Group added successfully", namep);
    }
}


void
add_group_l2(namep)
    LPWSTR namep;
{
    GROUP_INFO_2 GroupInfo2;

    GroupInfo2.grpi2_name = namep;
    GroupInfo2.grpi2_comment = GROUP_COMMENT;
    GroupInfo2.grpi2_attributes = GROUP_ATTR;

    if (err = NetGroupAdd(server, 2, (char * ) &GroupInfo2, NULL )) {
        error_exit(FAIL, "GroupAdd (level 2) failed", namep );
    } else {
        error_exit(PASS, "Group added successfully", namep);
    }
}

void
test_add_del()
{
    GROUP_INFO_0 GroupInfo0;

    //
    // delete a non-existent group
    //

    if (err = NetGroupDel(server, GROUP1)) {
        if (err != NERR_GroupNotFound)
            error_exit(FAIL, "Delete of non-existent group wrong status",
                       GROUP1 );
        else
            error_exit(PASS, "Delete of non-existent group denied",
                       GROUP1 );

        err = 0;
    } else
        error_exit(FAIL, "Delete of non-existent group succeeded",
                   GROUP1 );

    //
    // add group level 0
    //

    GroupInfo0.grpi0_name = GROUP1;
    if (err = NetGroupAdd(server, 0, (LPBYTE)&GroupInfo0, NULL))
        error_exit(FAIL, "Add of group (Level 0) failed", GROUP1 );
    else
        error_exit(PASS, "Group added successfully (level 0)", GROUP1);

    //
    // delete group added level 0
    //

    if (err = NetGroupDel(server, GROUP1))
        error_exit(FAIL, "Delete of group failed", GROUP1 );
    else
        error_exit(PASS, "Group deleted successfully", GROUP1 );

    //
    // add group level 1
    //

    error_exit(ACTION, "Try to Add group at Level 1", GROUP1 );
    add_group_l1(GROUP1);

    //
    // delete group added level 1
    //

    if (err = NetGroupDel(server, GROUP1))
        error_exit(FAIL, "Delete of group failed", GROUP1 );
    else
        error_exit(PASS, "group deleted successfully", GROUP1 );

    //
    // add group level 2
    //

    error_exit(ACTION, "Try to Add group at Level 2", GROUP1 );
    add_group_l2(GROUP1);

    //
    // delete group added level 2
    //

    if (err = NetGroupDel(server, GROUP1))
        error_exit(FAIL, "Delete of group failed", GROUP1 );
    else
        error_exit(PASS, "group deleted successfully", GROUP1 );

    //
    // add group 1 l0
    //

    GroupInfo0.grpi0_name = GROUP1;
    if (err = NetGroupAdd(server, 0, (LPBYTE)&GroupInfo0, NULL))
        error_exit(FAIL, "Second Add of group (level 0) failed", GROUP1 );
    else
        error_exit(PASS, "Group added successfully (level 0)", GROUP1 );

    //
    // add duplicate
    //

    if (err = NetGroupAdd(server, 0, (LPBYTE)&GroupInfo0, NULL)) {
        if (err != NERR_GroupExists)
            error_exit(FAIL, "Adding of duplicate group Wrong", GROUP1 );
        else {
            err = 0;
            error_exit(PASS, "Adding of Duplicate Group denied", GROUP1);
        }
    } else
        error_exit(FAIL, "Add of duplicate group succeeded", GROUP1 );

    //
    // add group 2 l0
    //

    GroupInfo0.grpi0_name = GROUP2;
    if (err = NetGroupAdd(server, 0, (LPBYTE)&GroupInfo0, NULL))
        error_exit(FAIL, "Second Add of group (level 0) failed", GROUP2);
    else
        error_exit(PASS, "Group added successfully (level 0)", GROUP2 );

    //
    // add group 3 l1
    //

    error_exit(ACTION, "Try to Add group at Level 1", GROUP3);
    add_group_l1(GROUP3);

    //
    // add group 4 l1
    //

    error_exit(ACTION, "Try to Add group at Level 1", GROUP4);
    add_group_l1(GROUP4);
}

//
//  set_info_l1 NetGroupSetInfo call on named group. First a
//          call is issued to a bogus group and then to
//          the requested group
//
void
set_info_l1(namep)
    LPWSTR namep;
{
    GROUP_INFO_1 GroupInfo1;

    GroupInfo1.grpi1_name = namep;
    GroupInfo1.grpi1_comment = namep;

    //
    // first attempt on an invalid group
    //

    err = NetGroupSetInfo(server, NOTTHERE, 1, (LPBYTE)&GroupInfo1, NULL );

    if (err == 0) {
        error_exit(FAIL, "SetInfo (Level 1) succeed on non-existent group",
            NULL );
    } else if (err != NERR_GroupNotFound) {
        error_exit(FAIL, "SetInfo (Level 1) on non-existent group wrong",
            NULL);
    } else {
        error_exit(PASS, "SetInfo (Level 1) denied on non-existent group",
            NULL );
    }

    if (_wcsicmp(NOTTHERE, namep) == 0)
        return;

    //
    // now attempt on a valid group
    //

    if (err = NetGroupSetInfo(server, namep, 1, (LPBYTE)&GroupInfo1, NULL )){
        error_exit(FAIL, "SetInfo (Level 1) failed", namep);
    } else
        error_exit(PASS, "SetInfo (Level 1) succeeded", namep);
}

//
//  set_info_l2 NetGroupSetInfo call on named group. First a
//          call is issued to a bogus group and then to
//          the requested group
//
void
set_info_l2(namep)
    LPWSTR namep;
{
    GROUP_INFO_2 GroupInfo2;

    GroupInfo2.grpi2_name = namep;
    GroupInfo2.grpi2_comment = namep;
    GroupInfo2.grpi2_attributes = GROUP_ATTR;

    //
    // first attempt on an invalid group
    //

    err = NetGroupSetInfo(server, NOTTHERE, 2, (LPBYTE)&GroupInfo2, NULL );

    if (err == 0) {
        error_exit(FAIL, "SetInfo (Level 2) succeed on non-existent group",
            NULL );
    } else if (err != NERR_GroupNotFound) {
        error_exit(FAIL, "SetInfo (Level 2) on non-existent group wrong",
            NULL);
    } else {
        error_exit(PASS, "SetInfo (Level 2) denied on non-existent group",
            NULL );
    }

    if (_wcsicmp(NOTTHERE, namep) == 0)
        return;

    //
    // now attempt on a valid group
    //

    if (err = NetGroupSetInfo(server, namep, 2, (LPBYTE)&GroupInfo2, NULL )){
        error_exit(FAIL, "SetInfo (Level 2) failed", namep);
    } else
        error_exit(PASS, "SetInfo (Level 2) succeeded", namep);
}

void
set_group_comment(namep, buf)
    LPWSTR   namep;
    LPWSTR   buf;
{
    GROUP_INFO_1002 GroupComment;

    GroupComment.grpi1002_comment = buf;

    if (err = NetGroupSetInfo(server, namep, 1002, (LPBYTE)&GroupComment,NULL)){
        error_exit(FAIL, "SetInfo (Level 1002) failed\n", namep);
    } else
        error_exit(PASS, "SetInfo (Level 1002) succeeded\n", namep);
}



void
set_group_attributes(namep)
    LPWSTR   namep;
{
    GROUP_INFO_1005 GroupComment;

    GroupComment.grpi1005_attributes = GROUP_ATTR;

    if (err = NetGroupSetInfo(server, namep, 1005, (LPBYTE)&GroupComment,NULL)){
        error_exit(FAIL, "SetInfo (Level 1005) failed\n", namep);
    } else
        error_exit(PASS, "SetInfo (Level 1005) succeeded\n", namep);
}



//
//  verify_enum     ACTION - Verify that NetGroupEnum (level 0/1) returned all
//          the special groups (USERS, ADMINS, GUESTS) and the
//          groups added for this test (GROUP1 - GROUP4).
//

void
verify_enum(level, GroupEnum)
short   level;
LPBYTE GroupEnum;
{
    GROUP_INFO_0 *GroupInfo0;
    GROUP_INFO_1 *GroupInfo1;
    GROUP_INFO_2 *GroupInfo2;
    LPWSTR name;
    unsigned short  found = 0;

    //
    // number of groups read should be group_count + 4 (added for this test)
    //

    if (nread != group_count + 4) {
        error_exit(FAIL, "Number of Groups read Incorrect", NULL );
        printf("UASTEST2: Read = %u  Expected = %u\n", nread, group_count + 4);
    }

    if (total != group_count + 4) {
        error_exit(FAIL, "Total Number of Groups returned Incorrect",NULL);
        printf("UASTEST2: Total = %u  Expected = %u\n", total, group_count + 4);
    }

    if ((nread == total) & (err == 0)) {
        if (level == 0)
            GroupInfo0 = (GROUP_INFO_0 * ) GroupEnum;
        else if (level == 1)
            GroupInfo1 = (GROUP_INFO_1 * ) GroupEnum;
        else
            GroupInfo2 = (GROUP_INFO_2 * ) GroupEnum;

        while (nread--) {
            if (level == 0)
                name = GroupInfo0->grpi0_name;
            else if (level == 1)
                name = GroupInfo1->grpi1_name;
            else
                name = GroupInfo2->grpi2_name;

            if ( (_wcsicmp(name, GROUP1) == 0) ||
                (_wcsicmp(name, GROUP2) == 0) ||
                (_wcsicmp(name, GROUP3) == 0) ||
                (_wcsicmp(name, GROUP4) == 0) ) {

                found++;
                error_exit(PASS, "Found group added for this test", name);

            }
            if (level == 0)
                GroupInfo0++;
            else if (level == 1)
                GroupInfo1++;
            else
                GroupInfo2++;
        }
    }

    if (found != 4)
        error_exit(FAIL, "Unable to find ALL 4 groups", NULL);
    else
        printf("UASTEST2: PASS - Found %u groups\n", found);
}


//
//  validate_enum_l0    NetGroupEnum at level 0
//

void
validate_enum_l0()
{
    PGROUP_INFO_0 GroupInfo0;
    if (err =  NetGroupEnum(server, 0, (LPBYTE *)&GroupInfo0, 0xffffffff, &nread, &total, NULL ))
        error_exit(FAIL, "NetGroupEnum (Level 0) failed", NULL );
    else
        error_exit(PASS, "Successful enumeration (level 0) of groups",
                    NULL);

    verify_enum(0, (LPBYTE)GroupInfo0);
    (VOID)NetApiBufferFree( GroupInfo0 );
}


//
//  validate_enum_l1    NetGroupEnum at level 1
//

void
validate_enum_l1()
{
    PGROUP_INFO_1 GroupInfo1;
    if (err =  NetGroupEnum(server, 1, (LPBYTE *)&GroupInfo1, 0xffffffff, &nread, &total, NULL ))
        error_exit(FAIL, "NetGroupEnum (Level 1) failed", NULL);
    else
        error_exit(PASS, "NetGroupEnum (Level 1) succeeded", NULL);

    verify_enum(1, (LPBYTE)GroupInfo1);
    (VOID)NetApiBufferFree( GroupInfo1 );
}


//
//  validate_enum_l2    NetGroupEnum at level 2
//

void
validate_enum_l2()
{
    PGROUP_INFO_2 GroupInfo2;
    if (err =  NetGroupEnum(server, 2, (LPBYTE *)&GroupInfo2, 0xffffffff, &nread, &total, NULL ))
        error_exit(FAIL, "NetGroupEnum (Level 2) failed", NULL);
    else
        error_exit(PASS, "NetGroupEnum (Level 2) succeeded", NULL);

    verify_enum(2, (LPBYTE)GroupInfo2);
    (VOID)NetApiBufferFree( GroupInfo2 );
}





void
test_get_set_enum_info()
{
    int i;
    PGROUP_INFO_0 GroupInfo0;
    PGROUP_INFO_1 GroupInfo1;
    PGROUP_INFO_2 GroupInfo2;

    //
    // get info for non-existent group
    //

    error_exit(ACTION, "Try GetInfo (Level 0) on Non-Existent Group", NULL);
    if (err = NetGroupGetInfo(server, NOTTHERE, 0, (LPBYTE *) &GroupInfo0)) {
        if (err != NERR_GroupNotFound)
            error_exit(FAIL, "GetInfo (Level 0) on non-existent group",
                       NULL );
        else {
            err = 0;
            error_exit(
                PASS, "GetInfo (Level 0) on non-existent group denied",
                NULL );
        }
    } else {
        error_exit(FAIL, "GetInfo (Level 0) succeed on non-existent group",
                NULL );
        (VOID)NetApiBufferFree( GroupInfo0 );
    }

    //
    // get info group1 Level 0
    //

    error_exit(ACTION, "Try GetInfo (Level 0)", GROUP1);
    if (err = NetGroupGetInfo(server, GROUP1, 0, (LPBYTE * ) & GroupInfo0))
        error_exit(FAIL, "GroupGetInfo (Level 0) failed", GROUP1);
    else {
        error_exit(PASS, "GroupGetInfo (Level 0) succeeded", GROUP1);

        //
        // verify data from GetInfo
        //

        if (_wcsicmp(GROUP1, GroupInfo0->grpi0_name) != 0)
            error_exit(FAIL, "GroupGetInfo (Level 0) returned wrong name",              GROUP1 );
        else
            error_exit(PASS, "Group name matched correctly", GROUP1);
        (VOID)NetApiBufferFree( GroupInfo0 );
    }

    //
    // get info group1 Level 1
    //

    error_exit(ACTION, "Try GetInfo (Level 1)", GROUP1);
    if (err = NetGroupGetInfo(server, GROUP1, 1, (LPBYTE *)&GroupInfo1))
        error_exit(FAIL, "GroupGetInfo (Level 1) failed", GROUP1);
    else {
        error_exit(PASS, "GroupGetInfo (Level 1) succeeded", GROUP1);

        //
        // verify data from GetInfo
        //

        if (_wcsicmp(GROUP1, GroupInfo1->grpi1_name) != 0)
            error_exit(FAIL, "GroupGetInfo (Level 1) returned wrong name",
                GROUP1);
        else
            error_exit(PASS, "Group name matched correctly", GROUP1);

        //
        // verify devault values
        //

        if (_wcsicmp(GroupInfo1->grpi1_comment, L"") != 0)
            error_exit(
                FAIL, "GroupGetInfo (Level 1) wrong default comment",
                GROUP1 );
        else
            error_exit(PASS, "Default Comment (\"\") matched correctly",
                       GROUP1);

        (VOID)NetApiBufferFree( GroupInfo1 );
    }

    //
    // get info group1 Level 2
    //

    error_exit(ACTION, "Try GetInfo (Level 2)", GROUP1);
    if (err = NetGroupGetInfo(server, GROUP1, 2, (LPBYTE *)&GroupInfo2))
        error_exit(FAIL, "GroupGetInfo (Level 2) failed", GROUP1);
    else {
        error_exit(PASS, "GroupGetInfo (Level 2) succeeded", GROUP1);

        //
        // verify data from GetInfo
        //

        if (_wcsicmp(GROUP1, GroupInfo2->grpi2_name) != 0)
            error_exit(FAIL, "GroupGetInfo (Level 2) returned wrong name",
                GROUP1);
        else
            error_exit(PASS, "Group name matched correctly", GROUP1);

        //
        // verify default values
        //

        if (_wcsicmp(GroupInfo2->grpi2_comment, L"") != 0)
            error_exit(
                FAIL, "GroupGetInfo (Level 1) wrong default comment",
                GROUP1 );
        else
            error_exit(PASS, "Default Comment (\"\") matched correctly",
                       GROUP1);

        if (GroupInfo2->grpi2_attributes != DEFAULT_GROUP_ATTR) {
            error_exit(
                FAIL, "GroupGetInfo (Level 2) wrong default attributes",
                GROUP1 );

            printf( "UASTEST2: FAIL - %ld should be %ld \n",
                        GroupInfo2->grpi2_attributes, DEFAULT_GROUP_ATTR );
        } else {
            error_exit(PASS, "Default attributes matched correctly",
                       GROUP1);
        }

        (VOID)NetApiBufferFree( GroupInfo2 );
    }

    //
    // get info group3 Level 1
    //

    error_exit(ACTION, "Try GetInfo (Level 1)", GROUP3);
    if (err = NetGroupGetInfo(server, GROUP3, 1, (LPBYTE *)&GroupInfo1))
        error_exit(FAIL, "GroupGetInfo (Level 1) failed", GROUP3);
    else {
        error_exit(PASS, "GroupGetInfo (Level 1) succeeded", GROUP3);

        //
        // verify set values
        //

        if (_wcsicmp(GroupInfo1->grpi1_name, GROUP3) != 0)
            error_exit(
                FAIL, "GroupGetInfo (Level 1) name mismatch",
                GROUP3);
        else {
            error_exit(PASS, "Group name matched correctly", GROUP3);
        }

        if (_wcsicmp(GroupInfo1->grpi1_comment, GROUP_COMMENT) != 0) {
            error_exit(FAIL, "GroupGetInfo (Level 1) comment mismatch",
                       GROUP3);

            printf( "UASTEST2: FAIL - '" );
            PrintUnicode( GroupInfo1->grpi1_comment );
            printf("' should be '" );
            PrintUnicode( GROUP_COMMENT );
            printf( "'\n");

        } else
            error_exit(PASS, "Comment matched correctly", GROUP3);

        (VOID)NetApiBufferFree( GroupInfo1 );
    }

    //
    // set info on nonexistent
    //

    error_exit(ACTION, "Try SetInfo (Level 1) on Non-Existent Group",
              NULL);
    set_info_l1(NOTTHERE);

    //
    // set info group1
    //

    error_exit(ACTION, "Try SetInfo (Level 1)", GROUP1);
    set_info_l1(GROUP1);

    //
    // verify group1 setinfo
    //

    error_exit(ACTION, "Verify SetInfo results", GROUP1 );
    if (err = NetGroupGetInfo(server, GROUP1, 1, (LPBYTE *)&GroupInfo1))
        error_exit(FAIL, "Second GroupGetInfo (Level 1) failed", GROUP1);
    else {
        error_exit(PASS, "Second GroupGetInfo (Level 1) succeeded",GROUP1);

        //
        // verify devault values
        //

        if (_wcsicmp(GroupInfo1->grpi1_comment, GROUP1) != 0) {
            error_exit(FAIL, "comment mismatch", GROUP1);
            printf( "UASTEST2: FAIL - '" );
            PrintUnicode( GroupInfo1->grpi1_comment );
            printf("' should be '" );
            PrintUnicode( GROUP1 );
            printf( "'\n");

        } else
            error_exit(PASS, "Comment matched correctly", GROUP1);

        (VOID)NetApiBufferFree( GroupInfo1 );
    }

    //
    // set info group2 level 1
    //

    error_exit(ACTION, "Try SetInfo (Level 1)", GROUP2);
    set_info_l1(GROUP2);
    error_exit(ACTION, "Verify SetInfo results", GROUP2);

    //
    // verify group2 setinfo
    //

    if (err = NetGroupGetInfo(server, GROUP2, 1, (LPBYTE *)&GroupInfo1))
        error_exit(FAIL, "Second GroupGetInfo (Level 1) failed", GROUP2);
    else {
        error_exit(PASS, "Second GroupGetInfo (Level 1) succeeded",GROUP2);

        //
        // verify devault values
        //

        if (_wcsicmp(GroupInfo1->grpi1_comment, GROUP2) != 0) {
            error_exit(FAIL, "comment mismatch", GROUP2);

            printf( "UASTEST2: FAIL - '" );
            PrintUnicode( GroupInfo1->grpi1_comment );
            printf("' should be '" );
            PrintUnicode( GROUP2 );
            printf( "'\n");
        } else
            error_exit(PASS, "Comment matched correctly", GROUP2);

        (VOID)NetApiBufferFree( GroupInfo1 );
    }

    //
    // set info group2 level 2
    //

    error_exit(ACTION, "Try SetInfo (Level 2)", GROUP2);
    set_info_l2(GROUP2);
    error_exit(ACTION, "Verify SetInfo results", GROUP2);

    //
    // verify group2 setinfo level 2
    //

    if (err = NetGroupGetInfo(server, GROUP2, 2, (LPBYTE *)&GroupInfo2))
        error_exit(FAIL, "Second GroupGetInfo (Level 2) failed", GROUP2);
    else {
        error_exit(PASS, "Second GroupGetInfo (Level 2) succeeded",GROUP2);

        //
        // verify devault values
        //

        if (_wcsicmp(GroupInfo2->grpi2_comment, GROUP2) != 0) {
            error_exit(FAIL, "comment mismatch", GROUP2);

            printf( "UASTEST2: FAIL - '" );
            PrintUnicode( GroupInfo2->grpi2_comment );
            printf("' should be '" );
            PrintUnicode( GROUP2 );
            printf( "'\n");
        } else
            error_exit(PASS, "Comment matched correctly", GROUP2);

        if (GroupInfo2->grpi2_attributes != GROUP_ATTR)
            error_exit(
                FAIL, "GroupGetInfo (Level 2) wrong default attributes",
                GROUP2 );
        else
            error_exit(PASS, "Default attributes (\"\") matched correctly",
                       GROUP2);

        (VOID)NetApiBufferFree( GroupInfo2 );
    }

    //
    // set comment using level 1002
    //

    set_group_comment(GROUP2, PARM_COMMENT);
    if (err = NetGroupGetInfo(server, GROUP2, 1, (LPBYTE *)&GroupInfo1))
        error_exit(FAIL, "Second GroupGetInfo (Level 1) failed", GROUP2);
    else {
        error_exit(PASS, "Second GroupGetInfo (Level 1) succeeded",GROUP2);

        //
        // verify devault values
        //

        if (_wcsicmp(GroupInfo1->grpi1_comment, PARM_COMMENT) != 0) {
            error_exit(FAIL, "comment mismatch", GROUP2);

            printf( "UASTEST2: FAIL - '" );
            PrintUnicode( GroupInfo1->grpi1_comment );
            printf("' should be '" );
            PrintUnicode( PARM_COMMENT );
            printf( "'\n");
        } else
            error_exit(PASS, "Second Comment matched correctly",GROUP2);

        (VOID)NetApiBufferFree( GroupInfo1 );
    }

    error_exit(ACTION, "Try SetInfo (Level 1002) on GROUP1 - GROUP4",NULL);
    for (i = 0; i < 4; i++)
        set_group_comment(group[i], group[i]);

    //
    // set group attributes using level 1005
    //

    set_group_attributes(GROUP2);
    if (err = NetGroupGetInfo(server, GROUP2, 2, (LPBYTE *)&GroupInfo2))
        error_exit(FAIL, "Second GroupGetInfo (Level 2) failed", GROUP2);
    else {
        error_exit(PASS, "Second GroupGetInfo (Level 2) succeeded",GROUP2);

        //
        // verify default values
        //

        if (GroupInfo2->grpi2_attributes != GROUP_ATTR) {
            error_exit(FAIL, "attributes mismatch", GROUP2);

            printf( "UASTEST2: FAIL - %ld should be %ld \n",
                        GroupInfo2->grpi2_attributes, GROUP_ATTR );
        } else
            error_exit(PASS, "group attributes matched correctly",GROUP2);

        (VOID)NetApiBufferFree( GroupInfo2 );
    }

    error_exit(ACTION, "Try SetInfo (Level 1005) on GROUP1 - GROUP4",NULL);
    for (i = 0; i < 4; i++)
        set_group_attributes(group[i]);

    //
    // enum all level 0
    //

    error_exit(
        ACTION,
        "Enumerate Groups (Level 0) and find those added for test",
        NULL);
    validate_enum_l0();

    //
    // enum all level 1
    //

    error_exit(
        ACTION,
        "Enumerate Groups (Level 1) and find those added for test",
        NULL);
    validate_enum_l1();

    //
    // enum all level 2
    //

    error_exit(
        ACTION,
        "Enumerate Groups (Level 2) and find those added for test",
        NULL);
    validate_enum_l2();

}



//
//  test_group_users    Test NetGroupSetUsers & NetGroupGetUsers
//

void
test_group_users()
{
    register int    i;
    GROUP_USERS_INFO_0 gu0;
    GROUP_USERS_INFO_0 gu0Array[2];

    PGROUP_USERS_INFO_0 GroupUser0;
    PGROUP_USERS_INFO_1 GroupUser1;


    //
    // add non-exist user to group
    //

    gu0.grui0_name = NOTTHERE;

    if (err = NetGroupSetUsers(server, GROUP1, 0, (char * ) & gu0, 1)) {
        if (err != NERR_UserNotFound)
            error_exit(FAIL, "NetGroupSetUsers on non-existent user wrong",
                       GROUP1 );
        else
            error_exit(PASS,
                       "NetGroupSetUsers on non-existent user denied",
                       GROUP1 );
    } else
        error_exit(FAIL, "NetGroupSetUsers on non-existent user succeded",
                       GROUP1 );

    //
    // add user to non-exist group
    //

    gu0.grui0_name = USER1;

    if (err = NetGroupSetUsers(server, NOTTHERE, 0, (char * ) & gu0, 1)) {
        if (err != NERR_GroupNotFound)
            error_exit(FAIL, "NetGroupSetUsers on non-existent group wrong",
                        NULL );
        else
            error_exit(PASS, "NetGroupSetUsers on non-existent group denied",
                        NULL );
    } else
        error_exit(FAIL, "NetGroupSetUsers on non-existent group succeded",
                        NULL );

    //
    // add user to group1
    //

    gu0.grui0_name = USER1;

    if (err = NetGroupSetUsers(server, GROUP1, 0, (char * ) & gu0, 1))
        error_exit(FAIL, "NetGroupSetUsers unable to add USER1 to GROUP1",                  NULL );
    else
        error_exit(PASS, "NetGroupSetUsers added USER1 to GROUP1 successfully",                     NULL );

    //
    // getuser non-exist group
    //

    if (err = NetGroupGetUsers(server, NOTTHERE, 0, (LPBYTE *)&GroupUser0,
                    0xffffffff, &nread, &total, NULL)) {
        if (err != NERR_GroupNotFound)
            error_exit(FAIL, "NetGroupGetUsers on non-existent group wrong",                    NULL );
        else
            error_exit(PASS, "NetGroupGetUsers on non-existent group denied",                   NULL );
    } else {
        error_exit(FAIL, "NetGroupGetUsers on non-existent group succeded",                     NULL );
        (VOID)NetApiBufferFree( GroupUser0 );
    }


    //
    // getuser on group2 with no user
    //

    if (err = NetGroupGetUsers(server, GROUP2, 0, (LPBYTE *)&GroupUser0,
                    0xffffffff, &nread, &total, NULL))
        error_exit(FAIL, "NetGroupGetUsers on group with no users failed",
                   GROUP2 );
    else {
        error_exit(PASS, "NetGroupGetUsers on group with no users succeded",
                    GROUP2 );

        if ((nread != total) || (nread != 0))
            error_exit(
                FAIL, "NetGroupGetUsers returned non-zero number of users",
                GROUP2);
        else
            error_exit(
                PASS, "NetGroupGetUsers returned zero number of users",
                GROUP2);

        (VOID)NetApiBufferFree( GroupUser0 );
    }

    //
    // getuser on group1 with user
    //

    if (err = NetGroupGetUsers(server, GROUP1, 0, (LPBYTE *)&GroupUser0,
                    0xffffffff, &nread, &total, NULL ))
        error_exit(FAIL, "NetGroupGetUsers on group with users failed",
                    GROUP1);
    else {
        error_exit(PASS, "NetGroupGetUsers on group with users succeded",
                    GROUP1);

        if ((nread != total) || (nread != 1)) {
            printf( "nread: %ld total: %ld\n", nread, total );
            error_exit(
                FAIL, "NetGroupGetUsers returned wrong number of users",
                GROUP1);
        } else
            error_exit(
                PASS, "NetGroupGetUsers returned correct number of users",
                GROUP1);

        if ( nread > 0 ) {
            if (_wcsicmp( GroupUser0->grui0_name, USER1) != 0)
                error_exit(FAIL, "NetGroupGetUsers returned wrong user",
                    GROUP1);
            else
                error_exit(
                    PASS, "NetGroupGetUsers returned USER1 (correct user)",
                    GROUP1);
        }

        (VOID)NetApiBufferFree( GroupUser0 );
    }

    //
    // getuser on group1 with user level 1
    //

    if (err = NetGroupGetUsers(server, GROUP1, 1, (LPBYTE *)&GroupUser1,
                    0xffffffff, &nread, &total, NULL ))
        error_exit(FAIL, "NetGroupGetUsers on group with users failed",
                    GROUP1);
    else {
        error_exit(PASS, "NetGroupGetUsers on group with users succeded",
                    GROUP1);

        if ((nread != total) || (nread != 1)) {
            printf( "nread: %ld total: %ld\n", nread, total );
            error_exit(
                FAIL, "NetGroupGetUsers returned wrong number of users",
                GROUP1);
        } else
            error_exit(
                PASS, "NetGroupGetUsers returned correct number of users",
                GROUP1);

        if ( nread > 0 ) {
            if (_wcsicmp( GroupUser1->grui1_name, USER1) != 0)
                error_exit(FAIL, "NetGroupGetUsers returned wrong user",
                    GROUP1);
            else
                error_exit(
                    PASS, "NetGroupGetUsers returned USER1 (correct user)",
                    GROUP1);
        }

        (VOID)NetApiBufferFree( GroupUser1 );
    }

    //
    // delete user from group
    //

    if (err = NetGroupDelUser(server, GROUP1, USER1))
        error_exit(FAIL, "NetGroupDelUser (USER1, GROUP1) failed", NULL);
    else
        error_exit(
            PASS, "NetGroupDelUser deleted USER1 from GROUP1 successfully",
             NULL);

    //
    // verify delete of user
    //

    if (err = NetGroupGetUsers(server, GROUP1, 0, (LPBYTE *)&GroupUser0,
                    0xffffffff, &nread, &total, NULL ))
        error_exit(FAIL, "NetGroupGetUsers failed", GROUP1 );
    else {
        if ((nread != total) && (nread != 0))
            error_exit(FAIL, "NetGroupGetUsers returned non-zero",GROUP1);

        (VOID)NetApiBufferFree( GroupUser0 );
    }

    //
    // add all users (USER1 and USER2) to all groups
    //

    for (i = 0; i < 4; i++) {
        gu0Array[0].grui0_name = USER1;
        gu0Array[1].grui0_name = USER2;
        if (err = NetGroupSetUsers(server, group[i], 0, (char * ) gu0Array, 2))
            error_exit(FAIL, "Adding of USER1 and USER2 as member", group[i]);
        else
            error_exit(PASS, "USER1 and USER2 added to as member successfully",
                    group[i]);

    }

    //
    // verify for one group
    //

    if (err = NetGroupGetUsers(server, GROUP1, 0, (LPBYTE *)&GroupUser0,
                    0xffffffff, &nread, &total, NULL))
        error_exit(FAIL, "NetGroupGetUsers after mass add failed", GROUP1);

    else {
        PGROUP_USERS_INFO_0 TempGroupUser0;
        error_exit(PASS, "NetGroupGetUsers after mass add succeeded",
            GROUP1);
        if ((nread != total) || (nread != 2)) {
            printf( "nread: %ld total: %ld\n", nread, total );
            error_exit(
                FAIL, "NetGroupGetUsers after mass add wrong # of users",
                GROUP1 );
        }


        TempGroupUser0 = GroupUser0;
        if (_wcsicmp(TempGroupUser0->grui0_name, USER1) == 0) {
            TempGroupUser0++;
            if (nread < 2 || _wcsicmp(TempGroupUser0->grui0_name, USER2) != 0)
                error_exit(
                    FAIL, "NetGroupGetUsers after mass add missing USER2",
                    GROUP1);
            else
                error_exit(PASS, "Found both USER1 and USER2", GROUP1);
        } else if (_wcsicmp(TempGroupUser0->grui0_name, USER2) == 0) {
            TempGroupUser0++;
            if (nread < 2 || _wcsicmp(TempGroupUser0->grui0_name, USER1) != 0)
                error_exit(
                    FAIL, "NetGroupGetUsers after mass add missing USER1",
                    GROUP1 );
            else
                error_exit(PASS, "Found both USER1 and USER2",
                    GROUP1);
        } else {
            error_exit(
                FAIL, "NetGroupGetUsers after mass add incorrect users returned",
                GROUP1);
        }

        (VOID)NetApiBufferFree( GroupUser0 );
    }
}

//
//  verfiy_ul0      verify the information returned by NetUserGetGroups
//

void
verify_ul0(
    PGROUP_INFO_0 GroupInfo0
    )
{
    LPWSTR name;
    unsigned short  found = 0;

    if (nread != 5) {
        printf("UASTEST2: FAIL - Incorrect number of users read %ld s.b. 5\n",
                nread );
        TEXIT;
    }

    if (total != 5) {
        printf("UASTEST2: FAIL - Incorrect total number of users returned %ld s.b. 5\n", total );
        TEXIT;
    }

    //
    // note that USER1 must have been added with USER privs hence
    // it will be member of USER group as well as GROUP1 thru GROUP4
    // since that was done in previous test
    //
    // Note: "Users" is spelled "None" on a workstation.
    //

    if ((nread == total) && (err == 0)) {
        while (nread--) {
            if (_wcsicmp(GroupInfo0->grpi0_name, DefaultGroup ) == 0 ) {
                printf("UASTEST2: Found membership in automatic group %ws\n",
                        DefaultGroup );
                found++;
            } else {
                name = GroupInfo0->grpi0_name;
                if ( (_wcsicmp(name, GROUP1) == 0) ||
                    (_wcsicmp(name, GROUP2) == 0) ||
                    (_wcsicmp(name, GROUP3) == 0) ||
                    (_wcsicmp(name, GROUP4) == 0) ) {
                    found++;
                    error_exit(PASS, "Found group added for this test", name);
                }
            }
            GroupInfo0++;
        }
    }

    if (found != 5)
        error_exit(FAIL, "Unable to find ALL 5 Groups", NULL );
    else
        printf("UASTEST2: PASS - Found %u groups\n", found);

}


//
//  verfiy_ul1      verify the information returned by NetUserGetGroups
//

void
verify_ul1(
    PGROUP_INFO_1 GroupInfo1
    )
{
    LPWSTR name;
    unsigned short  found = 0;

    if (nread != 5) {
        printf("UASTEST2: FAIL - Incorrect number of users read\n");
        TEXIT;
    }

    if (total != 5) {
        printf("UASTEST2: FAIL - Incorrect total number of users returned\n");
        TEXIT;
    }

    //
    // note that USER1 must have been added with USERS privs hence
    // it will be member of USERS group as well as GROUP1 thru GROUP4
    // since that was done in previous test
    //

    if ((nread == total) && (err == 0)) {
        while (nread--) {
            if (_wcsicmp(GroupInfo1->grpi1_name, DefaultGroup) == 0) {
                printf("UASTEST2: Found membership in automatic group %ws\n",
                        DefaultGroup );
                found++;
            } else {
                name = GroupInfo1->grpi1_name;
                if ( (_wcsicmp(name, GROUP1) == 0) ||
                    (_wcsicmp(name, GROUP2) == 0) ||
                    (_wcsicmp(name, GROUP3) == 0) ||
                    (_wcsicmp(name, GROUP4) == 0) ) {
                    found++;
                    error_exit(PASS, "Found group added for this test", name);
                }
            }
            GroupInfo1++;
        }
    }

    if (found != 5)
        error_exit(FAIL, "Unable to find ALL 5 Groups", NULL );
    else
        printf("UASTEST2: PASS - Found %u groups\n", found);

}




//
//  verify_del_user verifies the buffer returned by NetUserGetGroups
//          after NetGroupDelUser calls
//

void
verify_del_l0(
    PGROUP_INFO_0 GroupInfo0
    )
{

    if (nread != 1) {
        printf("UASTEST2: Incorrect number of users read\n");
        TEXIT;
    }

    if (total != 1) {
        printf("UASTEST2: Incorrect total number of users returned\n");
        TEXIT;
    }

    if ((nread == 1) && (total == 1) && (err == 0)) {
        if (_wcsicmp(GroupInfo0->grpi0_name, DefaultGroup ) == 0) {
            printf(
                "UASTEST2: PASS - Automatic membership in %ws confirmed\n",
                DefaultGroup );
        } else {
            error_exit(FAIL, "Invalid membership in group\n",
                       GroupInfo0->grpi0_name);
        }
    }
}


//
//  test_user_group     Test NetUserGetGroups & NetUserSetGroups
//

void
test_user_group()
{
    GROUP_INFO_0 GroupInfo0[5];
    PGROUP_INFO_0 GroupInfo0Ret;
    PGROUP_INFO_1 GroupInfo1Ret;


    //
    // get groups on invalid user
    //

    if (err = NetUserGetGroups(server, NOTTHERE, 0, (LPBYTE *)&GroupInfo0Ret,
                    0xffffffff, &nread, &total)) {
        if (err != NERR_UserNotFound)
            error_exit(
                FAIL, "NetUserGetGroups for non-existent user wrong",
                NULL );
        else
            error_exit(
                PASS, "NetUserGetGroups for non-existent user denied",
                NULL );
    } else {
        error_exit(
                FAIL, "NetUserGetGroups succeeded for non-existent user",
                NULL );
        (VOID)NetApiBufferFree( GroupInfo0Ret );
    }

    //
    // get groups for user1 level 0
    //

    if (err = NetUserGetGroups(server, USER1, 0, (LPBYTE *)&GroupInfo0Ret,
                    0xffffffff, &nread, &total))
        error_exit(FAIL, "NetUserGetGroups failed (level 0)", USER1 );
    else {
        error_exit(PASS, "NetUserGetGroups succeeded (level 0)", USER1 );
        error_exit(ACTION, "Verify results of NetUserGetGroups (level 0)", USER1);
        verify_ul0( GroupInfo0Ret );
        (VOID)NetApiBufferFree( GroupInfo0Ret );
    }

    //
    // get groups for user1 level 1
    //

    if (err = NetUserGetGroups(server, USER1, 1, (LPBYTE *)&GroupInfo1Ret,
                    0xffffffff, &nread, &total))
        error_exit(FAIL, "NetUserGetGroups failed (level 1)", USER1 );
    else {
        error_exit(PASS, "NetUserGetGroups succeeded (level 1)", USER1 );
        error_exit(ACTION, "Verify results of NetUserGetGroups (level 1)", USER1);
        verify_ul1( GroupInfo1Ret );
        (VOID)NetApiBufferFree( GroupInfo1Ret );
    }

    //
    // delete user from groups
    //

    if (err = NetGroupDelUser(server, GROUP1, USER1))
        error_exit(
            FAIL, "NetGroupDelUser unable to delete USER1 from GROUP1",
            GROUP1 );
    else
        error_exit(
            PASS, "NetGroupDelUser successfully deleted USER1 from GROUP1",
            GROUP1);

    if (err = NetGroupDelUser(server, GROUP2, USER1))
        error_exit(
            FAIL, "NetGroupDelUser unable to delete USER1 from GROUP2",
            GROUP2 );
    else
        error_exit(
            PASS, "NetGroupDelUser successfully deleted USER1 from GROUP2",
            GROUP2 );

    if (err = NetGroupDelUser(server, GROUP3, USER1))
        error_exit(
            FAIL, "NetGroupDelUser unable to delete USER1 from GROUP3",
            GROUP3 );
    else
        error_exit(
            PASS, "NetGroupDelUser successfully deleted USER1 from GROUP3",
            GROUP3 );

    if (err = NetGroupDelUser(server, GROUP4, USER1))
        error_exit(
            FAIL, "NetGroupDelUser unable to delete USER1 from GROUP4",
            GROUP4 );
    else
        error_exit(
            PASS, "NetGroupDelUser successfully deleted USER1 from GROUP4",
            GROUP4 );


    //
    // get groups for user1
    //

    if (err = NetUserGetGroups(server, USER1, 0, (LPBYTE *)&GroupInfo0Ret,
                    0xffffffff, &nread, &total))
        error_exit(
            FAIL, "NetUserGetGroups for USER1 failed", USER1 );
    else {
        error_exit(PASS, "NetUserGetGroups for USER1 succeeded", USER1 );
        error_exit(ACTION, "Verify results after NetGroupDelUser", USER1);
        verify_del_l0( GroupInfo0Ret );
        (VOID)NetApiBufferFree( GroupInfo0Ret );
    }

    //
    // set groups for invalid user
    //

    GroupInfo0[0].grpi0_name = GROUP1;
    GroupInfo0[1].grpi0_name = GROUP2;
    GroupInfo0[2].grpi0_name = GROUP3;
    GroupInfo0[3].grpi0_name = GROUP4;

    if (err = NetUserSetGroups(server, NOTTHERE, 0, (LPBYTE)&GroupInfo0, 4 )) {
        if (err != NERR_UserNotFound)
            error_exit(
                FAIL, "NetUserSetGroups for non-existent user wrong",
                NULL );
        else
            error_exit(
                PASS, "NetUserSetGroups for non-existent user denied",
                NULL );
    } else
        error_exit(
            FAIL, "NetUserSetGroups for non-existent user succeeded",
            NULL );

    //
    // set groups for valid user
    //

    GroupInfo0[0].grpi0_name = GROUP1;
    GroupInfo0[1].grpi0_name = GROUP2;
    GroupInfo0[2].grpi0_name = GROUP3;
    GroupInfo0[3].grpi0_name = GROUP4;
    GroupInfo0[4].grpi0_name = DefaultGroup;

    if (err = NetUserSetGroups(server, USER1, 0, (LPBYTE)&GroupInfo0, 5 )) {
        error_exit(FAIL, "NetUserSetGroups for USER1 failed", NULL );
    } else
        error_exit(PASS, "NetUserSetGroups for USER1 succeeded", NULL );

    //
    // verify set of groups
    //

    if (err = NetUserGetGroups(server, USER1, 0, (LPBYTE *)&GroupInfo0Ret,
                    0xffffffff, &nread, &total))
        error_exit(FAIL, "NetUserGetGroups for USER1 failed", NULL );
    else {
        error_exit(PASS, "NetUserGetGroups for USER1 succeeded", NULL );

        printf("UASTEST2: Verify results of NetUserSetGroups on USER1\n");
        verify_ul0( GroupInfo0Ret );
        (VOID)NetApiBufferFree( GroupInfo0Ret );
    }
}


void
main(argc, argv)
int argc;
char    **argv;
{
    NT_PRODUCT_TYPE NtProductType;
    testname = "UASTEST2";

    if (argv[1] != NULL)
        server = NetpLogonOemToUnicode(argv[1]);
    if (argc > 1)
        exit_flag = 1;

    //
    // On WinNt, a user is added to group "None" by default.
    // On LanManNt, a user is added to group "Users" by default.
    //

    if ( RtlGetNtProductType( &NtProductType ) ) {
        if ( NtProductType == NtProductLanManNt ) {
            DefaultGroup = L"Users";
        } else {
            DefaultGroup = L"None";
        }
    } else {
        printf("UASTEST2: FAIL: cannot determine product type\n");
        DefaultGroup = L"None";
    }

#ifdef UASP_LIBRARY
    printf( "Calling UaspInitialize\n");
    if (err = UaspInitialize()) {
        error_exit( FAIL, "UaspInitiailize failed", NULL  );
    }
#endif // UASP_LIBRARY

    printf("\n");
    printf("******** Starting UASTEST2: NetGroup API tests ********\n");
    clean_up();
    printf("UASTEST2: test_add_del() ... started\n");
    test_add_del();
    printf("UASTEST2: test_get_set_enum_info() ... started\n");
    test_get_set_enum_info();
    printf("UASTEST2: test_group_users() ... started\n");
    test_group_users();
    printf("UASTEST2: test_user_group() ... started\n");
    test_user_group();
    printf("******** Completed UASTEST2: NetGroup API tests ********\n");
    printf("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\api\alert.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    Alert.c

Abstract:

    This file contains NetAlertRaise().
    for the NetAlert API.

Author:

    John Rogers (JohnRo) 03-Apr-1992

Environment:

    User Mode - Win32

Revision History:

    04-Apr-1992 JohnRo
        Created NetAlertRaise() API from RitaW's AlTest (alerter svc test).
    06-Apr-1992 JohnRo
        Added/improved error checking.
    08-May-1992 JohnRo
        Quiet normal debug output.
    08-May-1992 JohnRo
        Use <prefix.h> equates.

--*/


// These must be included first:

#include <windows.h>    // DWORD, CreateFile(), etc.
#include <lmcons.h>     // IN, NET_API_STATUS, etc.

// These may be included in any order:

#include <lmalert.h>    // My prototype, ALERTER_MAILSLOT, LPSTD_ALERT, etc.
#include <lmerr.h>      // NO_ERROR, NERR_NoRoom, etc.
#include <netdebug.h>   // NetpKdPrint(()), FORMAT_ equates, etc.
#include <prefix.h>     // PREFIX_ equates.
#include <string.h>     // memcpy().
#include <strucinf.h>   // NetpAlertStructureInfo().
#include <timelib.h>    // time_now().
#include <tstr.h>       // TCHAR_EOS.


#if DBG
#define IF_DEBUG( anything )  if (FALSE)
#else
#define IF_DEBUG( anything )  if (FALSE)
#endif


NET_API_STATUS NET_API_FUNCTION
NetAlertRaise(
    IN LPCWSTR AlertType,
    IN LPVOID  Buffer,
    IN DWORD   BufferSize
    )
/*++

Routine Description:

    This routine raises an alert to notify the Alerter service by writing to
    the Alerter service mailslot.

Arguments:

    AlertType - Supplies the name of the alert event which could be one
        of the three the Alerter service supports: ADMIN, USER, or PRINTING.
        The ALERT_xxx_EVENT equates are used to provide these strings.

    Buffer - Supplies the data to be written to the alert mailslot.
        This must begin with a STD_ALERT structure.

    BufferSize - Supplies the size in number of bytes of Buffer.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/
{
    NET_API_STATUS ApiStatus;
    HANDLE FileHandle;
    DWORD MaxTotalSize;
    DWORD NumberOfBytesWritten;
    DWORD RequiredFixedSize;

    //
    // Check for caller errors.
    //
    if (AlertType == NULL) {
        return (ERROR_INVALID_PARAMETER);
    } else if ( (*AlertType) == TCHAR_EOS ) {
        return (ERROR_INVALID_PARAMETER);
    } else if (Buffer == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    ApiStatus = NetpAlertStructureInfo(
            (LPWSTR)AlertType,
            & MaxTotalSize,
            & RequiredFixedSize);

    if (ApiStatus != NO_ERROR) {
        return (ApiStatus);
    }
    if (BufferSize < ( sizeof(STD_ALERT) + RequiredFixedSize) ) {
        return (ERROR_INVALID_PARAMETER);
    } else if (BufferSize > MaxTotalSize) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Open the Alerter mailslot to write to it.
    //
    FileHandle = CreateFile(
            ALERTER_MAILSLOT,
            GENERIC_WRITE,
            FILE_SHARE_WRITE | FILE_SHARE_READ,
            (LPSECURITY_ATTRIBUTES) NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL );                      // no template file.

    if (FileHandle == INVALID_HANDLE_VALUE) {

        ApiStatus = (NET_API_STATUS) GetLastError();
        IF_DEBUG( ALERT ) {
            NetpKdPrint(( PREFIX_NETAPI
                "NetAlertRaise: Problem with opening mailslot "
                FORMAT_API_STATUS "\n", ApiStatus ));
        }
        return (ApiStatus);
    }

    IF_DEBUG( ALERT ) {
        NetpKdPrint(( PREFIX_NETAPI "NetAlertRaise: "
                "Successfully opened the mailslot.  Message (partial) is:\n"));
        NetpDbgHexDump( Buffer, NetpDbgReasonable(BufferSize) );
    }

    //
    // Write alert notification to mailslot to be read by Alerter service.
    //
    if (WriteFile(
            FileHandle,
            Buffer,
            BufferSize,
            &NumberOfBytesWritten,
            NULL                      // no overlapped structure.
            ) == FALSE) {

        ApiStatus = (NET_API_STATUS) GetLastError();
        NetpKdPrint(( PREFIX_NETAPI "NetAlertRaise: Error " FORMAT_API_STATUS
                " writing to mailslot.\n", ApiStatus ));
    } else {

        NetpAssert( NumberOfBytesWritten == BufferSize );
        IF_DEBUG(ALERT) {
            NetpKdPrint(( PREFIX_NETAPI "NetAlertRaise: "
                    "Successful in writing to mailslot; length "
                    FORMAT_DWORD ", bytes written " FORMAT_DWORD "\n",
                    BufferSize, NumberOfBytesWritten));
        }
    }

    (VOID) CloseHandle(FileHandle);
    return (NO_ERROR);

} // NetAlertRaise



NET_API_STATUS NET_API_FUNCTION
NetAlertRaiseEx(
    IN LPCWSTR AlertType,
    IN LPVOID  VariableInfo,
    IN DWORD   VariableInfoSize,
    IN LPCWSTR ServiceName
    )

/*++

Routine Description:

    This routine raises an alert to notify the Alerter service by writing to
    the Alerter service mailslot.

Arguments:

    AlertType - Supplies the name of the alert event which could be one
        of the three the Alerter service supports: ADMIN, USER, or PRINTING.
        The ALERT_xxx_EVENT equates are used to provide these strings.

    VariableInfo - Supplies the variable length portion of the alert
        notification.

    VariableInfoSize - Supplies the size in number of bytes of the variable
        portion of the notification.

    ServiceName - Supplies the name of the service which raised the alert.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/
{

#define TEMP_VARIABLE_SIZE (512-sizeof(STD_ALERT))

    BYTE AlertMailslotBuffer[TEMP_VARIABLE_SIZE + sizeof(STD_ALERT)];
    LPSTD_ALERT Alert = (LPSTD_ALERT) AlertMailslotBuffer;
    NET_API_STATUS ApiStatus;
    DWORD DataSize = VariableInfoSize + sizeof(STD_ALERT);

    //
    // Check for caller errors.
    //
    if (AlertType == NULL) {
        return (ERROR_INVALID_PARAMETER);
    } else if ( (*AlertType) == TCHAR_EOS ) {
        return (ERROR_INVALID_PARAMETER);
    } else if (VariableInfo == NULL) {
        return (ERROR_INVALID_PARAMETER);
    } else if (VariableInfoSize > TEMP_VARIABLE_SIZE) {
        return (NERR_NoRoom);
    } else if (ServiceName == NULL) {
        return (ERROR_INVALID_PARAMETER);
    } else if ( (*ServiceName) == TCHAR_EOS ) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Copy variable portion to end of our buffer.
    //
    (VOID) memcpy(ALERT_OTHER_INFO(Alert), VariableInfo, VariableInfoSize);

    //
    // Store current time in seconds since 1970.
    //
    Alert->alrt_timestamp = (DWORD) time_now();

    //
    // Put alert event name into AlertMailslotBuffer
    //
    (VOID) STRCPY(Alert->alrt_eventname, AlertType);

    //
    // Put service name into AlertMailslotBuffer
    //
    (VOID) STRCPY(Alert->alrt_servicename, ServiceName);

    //
    // Write alert notification to mailslot to be read by Alerter service
    //
    ApiStatus = NetAlertRaise(
            AlertType,
            Alert,                   // buffer
            DataSize );              // buffer size

    return (ApiStatus);

} // NetAlertRaiseEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\access\userp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    userp.c

Abstract:

    Internal routines for supporting the NetUser API functions

Author:

    Cliff Van Dyke (cliffv) 26-Mar-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    17-Apr-1991 (cliffv)
        Incorporated review comments.

    17-Jan-1992 (madana)
        Added a new entry in the UserpUasSamTable to support account
        rename.

    20-Jan-1992 (madana)
        Sundry API changes.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef DOMAIN_ALL_ACCESS // defined in both ntsam.h and ntwinapi.h
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>

#include <windef.h>
#include <winbase.h>
#include <lmcons.h>

#include <access.h>
#include <accessp.h>
#include <align.h>
#include <limits.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <netdebug.h>
#include <netlib.h>
#include <netlibnt.h>
#include <secobj.h>
#include <stddef.h>
#include <uasp.h>

/*lint -e614 */  /* Auto aggregate initializers need not be constant */

// Lint complains about casts of one structure type to another.
// That is done frequently in the code below.
/*lint -e740 */  /* don't complain about unusual cast */



ULONG
UserpSizeOfLogonHours(
    IN DWORD UnitsPerWeek
    )

/*++

Routine Description:

    This routine calculates the size in bytes of a logon hours string
    given the number of Units per Week.

Parameters:

    UnitsPerWeek - The number of bits in the logon hours string.

Return Values:

    None.

--*/

{

    //
    // Calculate the number of bytes in the array, rounding up to the
    // nearest number of UCHARs needed to store that many bits.
    //

    return((UnitsPerWeek + 8 * sizeof(UCHAR) - 1) / (8 * sizeof(UCHAR)));
} // UserpSizeOfLogonHours



NET_API_STATUS
UserpGetUserPriv(
    IN SAM_HANDLE BuiltinDomainHandle,
    IN SAM_HANDLE UserHandle,
    IN ULONG UserRelativeId,
    IN PSID DomainId,
    OUT LPDWORD Priv,
    OUT LPDWORD AuthFlags
    )

/*++

Routine Description:

    Determines the Priv and AuthFlags for the specified user.

Arguments:

    BuiltinDomainHandle - A Handle to the Builtin Domain.  This handle
        must grant DOMAIN_GET_ALIAS_MEMBERSHIP access.

    UserHandle - A handle to the user.  This handle must grant
        USER_LIST_GROUPS access.

    UserRelativeId - Relative ID of the user to query.

    DomainId - Domain Sid of the Domain this user belongs to

    Priv - Returns the Lanman 2.0 Privilege level for the specified user.

    AuthFlags - Returns the Lanman 2.0 Authflags for the specified user.


Return Value:

    Status of the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    PGROUP_MEMBERSHIP GroupMembership = NULL;
    ULONG GroupCount;
    ULONG GroupIndex;
    PSID *UserSids = NULL;
    ULONG UserSidCount = 0;
    ULONG AliasCount;
    PULONG Aliases = NULL;


    //
    // Determine all the groups this user is a member of
    //

    Status = SamGetGroupsForUser( UserHandle,
                                  &GroupMembership,
                                  &GroupCount);

    if ( !NT_SUCCESS(Status) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint((
                "UserpGetUserPriv: SamGetGroupsForUser returns %lX\n",
                Status ));
        }
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Allocate a buffer to point to the SIDs we're interested in
    // alias membership for.
    //

    UserSids = (PSID *) NetpMemoryAllocate( (GroupCount+1) * sizeof(PSID) );

    if ( UserSids == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Add the User's Sid to the Array of Sids.
    //

    NetStatus = NetpSamRidToSid( UserHandle,
                                 UserRelativeId,
                                &UserSids[0] );

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    UserSidCount ++;



    //
    // Add each group the user is a member of to the array of Sids.
    //

    for ( GroupIndex = 0; GroupIndex < GroupCount; GroupIndex ++ ) {

        NetStatus = NetpSamRidToSid( UserHandle,
                                     GroupMembership[GroupIndex].RelativeId,
                                    &UserSids[GroupIndex+1] );

        if ( NetStatus != NERR_Success ) {
            goto Cleanup;
        }

        UserSidCount ++;
    }


    //
    // Find out which aliases in the builtin domain this user is a member of.
    //

    Status = SamGetAliasMembership( BuiltinDomainHandle,
                                    UserSidCount,
                                    UserSids,
                                    &AliasCount,
                                    &Aliases );

    if ( !NT_SUCCESS(Status) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint((
                "UserpGetUserPriv: SamGetAliasMembership returns %lX\n",
                Status ));
        }
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Convert the alias membership to priv and auth flags
    //

    NetpAliasMemberToPriv(
                 AliasCount,
                 Aliases,
                 Priv,
                 AuthFlags );

    NetStatus = NERR_Success;

    //
    // Free Locally used resources.
    //
Cleanup:
    if ( Aliases != NULL ) {
        Status = SamFreeMemory( Aliases );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if ( GroupMembership != NULL ) {
        Status = SamFreeMemory( GroupMembership );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if ( UserSids != NULL ) {

        for ( GroupIndex = 0; GroupIndex < UserSidCount; GroupIndex ++ ) {
            NetpMemoryFree( UserSids[GroupIndex] );
        }

        NetpMemoryFree( UserSids );
    }

    return NetStatus;
}


NET_API_STATUS
UserpGetDacl(
    IN SAM_HANDLE UserHandle,
    OUT PACL *UserDacl,
    OUT LPDWORD UserDaclSize OPTIONAL
    )
/*++

Routine Description:

    Get the DACL for a particular user record in SAM.

Arguments:

    UserHandle - A Handle to the particular user.

    UserDacl - Returns a pointer to the DACL for the user.  The caller
        should free this buffer using NetpMemoryFree.
        Will return NULL if there is no DACL for this user.

    UserDaclSize - Returns the size (in bytes) of the UserDacl.

Return Value:

    Status of the operation.

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    BOOLEAN DaclPresent;
    PACL Dacl;
    BOOLEAN DaclDefaulted;
    ACL_SIZE_INFORMATION AclSize;


    //
    // Get the Discretionary ACL (DACL) for the user
    //

    Status = SamQuerySecurityObject(
                UserHandle,
                DACL_SECURITY_INFORMATION,
                &SecurityDescriptor );

    if ( ! NT_SUCCESS( Status ) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint((
                "UserpGetDacl: SamQuerySecurityObject returns %lX\n",
                Status ));
        }
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    Status = RtlGetDaclSecurityDescriptor(
                    SecurityDescriptor,
                    &DaclPresent,
                    &Dacl,
                    &DaclDefaulted );


    if ( ! NT_SUCCESS( Status ) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint((
                "UserpGetDacl: RtlGetDaclSecurityObject returns %lX\n",
                Status ));
        }
        NetStatus = NERR_InternalError;
        goto Cleanup;
    }

    //
    // If there is no DACL, simply tell the caller
    //

    if ( !DaclPresent || Dacl == NULL ) {
        NetStatus = NERR_Success;
        *UserDacl = NULL;
        if ( UserDaclSize != NULL ) {
            *UserDaclSize = 0;
        }
        goto Cleanup;
    }


    //
    // Determine the size of the DACL so we can copy it
    //

    Status = RtlQueryInformationAcl(
                        Dacl,
                        &AclSize,
                        sizeof(AclSize),
                        AclSizeInformation );

    if ( ! NT_SUCCESS( Status ) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint((
                "UserpGetDacl: RtlQueryInformationAcl returns %lX\n",
                Status ));
        }
        NetStatus = NERR_InternalError;
        goto Cleanup;
    }

    //
    // Copy the DACL to an allocated buffer.
    //

    *UserDacl = NetpMemoryAllocate( AclSize.AclBytesInUse );

    if ( *UserDacl == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    NetpMoveMemory( *UserDacl, Dacl, AclSize.AclBytesInUse );

    if ( UserDaclSize != NULL ) {
        *UserDaclSize = AclSize.AclBytesInUse;
    }
    NetStatus = NERR_Success;


    //
    // Cleanup
    //

Cleanup:
    if ( SecurityDescriptor != NULL ) {
        Status = SamFreeMemory( SecurityDescriptor );
        NetpAssert( NT_SUCCESS(Status) );
    }

    return NetStatus;

}



NET_API_STATUS
UserpSetDacl(
    IN SAM_HANDLE UserHandle,
    IN PACL Dacl
    )
/*++

Routine Description:

    Set the specified Dacl on the specified SAM user record.

Arguments:

    UserHandle - A handle to the user to modify.

    Dacl - The DACL to set on the user.

Return Value:

    Status code.

--*/
{
    NTSTATUS Status;
    PUCHAR SecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH];

    //
    // Initialize a security descriptor to contain a pointer to the
    // DACL.
    //

    Status = RtlCreateSecurityDescriptor(
                SecurityDescriptor,
                SECURITY_DESCRIPTOR_REVISION );

    if (!NT_SUCCESS(Status) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint((
                "UserpSetDacl: RtlCreateSecurityDescriptor rets %lX\n",
                Status ));
        }
        return NetpNtStatusToApiStatus( Status );
    }

    Status = RtlSetDaclSecurityDescriptor(
                    (PSECURITY_DESCRIPTOR) SecurityDescriptor,
                    (BOOLEAN) TRUE,       // Dacl is present
                    Dacl,
                    (BOOLEAN) FALSE );    // Dacl wasn't defaulted

    if (!NT_SUCCESS(Status) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint((
                "UserpSetDacl: RtlSetDaclSecurityDescriptor rets %lX\n",
                Status ));
        }
        return NetpNtStatusToApiStatus( Status );
    }

    //
    // Set this new security descriptor on the user
    //

    Status = SamSetSecurityObject(
                UserHandle,
                DACL_SECURITY_INFORMATION,
                SecurityDescriptor );


    if ( !NT_SUCCESS(Status) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "NetUserAdd: SamSetSecurityObject rets %lX\n",
                      Status ));
        }
        return NetpNtStatusToApiStatus( Status );
    }

    return NERR_Success;


}



NET_API_STATUS
UserpOpenUser(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN LPCWSTR UserName,
    OUT PSAM_HANDLE UserHandle OPTIONAL,
    OUT PULONG RelativeId OPTIONAL
    )

/*++

Routine Description:

    Open a Sam User by Name

Arguments:

    DomainHandle - Supplies the Domain Handle.

    DesiredAccess - Supplies access mask indicating desired access to user.

    UserName - User name of the user.

    UserHandle - Returns a handle to the user.  If NULL, user is not
        actually opened (merely the relative ID is returned).

    RelativeId - Returns the relative ID of the user.  If NULL the relative
        Id is not returned.

Return Value:

    Error code for the operation.

--*/

{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    //
    // Variables for converting names to relative IDs
    //

    UNICODE_STRING NameString;
    PSID_NAME_USE NameUse = NULL;
    PULONG LocalRelativeId = NULL;

    //
    // Convert user name to relative ID.
    //

    RtlInitUnicodeString( &NameString, UserName );
    Status = SamLookupNamesInDomain( DomainHandle,
                                     1,
                                     &NameString,
                                     &LocalRelativeId,
                                     &NameUse );

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_NONE_MAPPED ) {
            NetStatus = NERR_UserNotFound;
        } else {
            NetStatus = NetpNtStatusToApiStatus( Status );
        }
        goto Cleanup;
    }

    if ( *NameUse != SidTypeUser ) {
        NetStatus = NERR_UserNotFound;
        goto Cleanup;
    }

    //
    // Open the user
    //

    if ( UserHandle != NULL ) {
        Status = SamOpenUser( DomainHandle,
                              DesiredAccess,
                              *LocalRelativeId,
                              UserHandle);

        if ( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }
    }

    //
    // Return the relative Id if it's wanted.
    //

    if ( RelativeId != NULL ) {
        *RelativeId = *LocalRelativeId;
    }
    NetStatus = NERR_Success;


    //
    // Cleanup
    //

Cleanup:
    if ( LocalRelativeId != NULL ) {
        Status = SamFreeMemory( LocalRelativeId );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if ( NameUse != NULL ) {
        Status = SamFreeMemory( NameUse );
        NetpAssert( NT_SUCCESS(Status) );
    }
    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "UserpOpenUser: %wZ: returns %ld\n",
                  &NameString, NetStatus ));
    }

    return NetStatus;

} // UserpOpenUser


VOID
UserpRelocationRoutine(
    IN DWORD Level,
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN PTRDIFF_T Offset
    )

/*++

Routine Description:

   Routine to relocate the pointers from the fixed portion of an enumeration
   buffer to the string portion of an enumeration buffer.  It is called
   as a callback routine from NetpAllocateEnumBuffer when it re-allocates
   such a buffer.  NetpAllocateEnumBuffer copied the fixed portion and
   string portion into the new buffer before calling this routine.

Arguments:

    Level - Level of information in the  buffer.

    BufferDescriptor - Description of the new buffer.

    Offset - Offset to add to each pointer in the fixed portion.

Return Value:

    Returns the error code for the operation.

--*/

{
    DWORD EntryCount;
    DWORD EntryNumber;
    DWORD FixedSize;
    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "UserpRelocationRoutine: entering\n" ));
    }

    //
    // Compute the number of fixed size entries
    //

    switch (Level) {
    case 0:
        FixedSize = sizeof(USER_INFO_0);
        break;

    case 1:
        FixedSize = sizeof(USER_INFO_1);
        break;

    case 2:
        FixedSize = sizeof(USER_INFO_2);
        break;

    case 3:
        FixedSize = sizeof(USER_INFO_3);
        break;

    case 10:
        FixedSize = sizeof(USER_INFO_10);
        break;

    case 11:
        FixedSize = sizeof(USER_INFO_11);
        break;

    case 20:
        FixedSize = sizeof(USER_INFO_20);
        break;

    default:
        NetpAssert( FALSE );
        return;

    }

    EntryCount =
        (DWORD)((BufferDescriptor->FixedDataEnd - BufferDescriptor->Buffer)) /
        FixedSize;

    //
    // Loop relocating each field in each fixed size structure
    //

#define DO_ONE( _type, _fieldname ) \
    RELOCATE_ONE( ((_type)TheStruct)->_fieldname, Offset)

    for ( EntryNumber=0; EntryNumber<EntryCount; EntryNumber++ ) {

        LPBYTE TheStruct = BufferDescriptor->Buffer + FixedSize * EntryNumber;

        switch ( Level ) {
        case 3:
            DO_ONE( PUSER_INFO_3, usri3_profile );
            DO_ONE( PUSER_INFO_3, usri3_home_dir_drive );

            /* Drop through to case 2 */

        case 2:
            DO_ONE( PUSER_INFO_2, usri2_full_name );
            DO_ONE( PUSER_INFO_2, usri2_usr_comment );
            DO_ONE( PUSER_INFO_2, usri2_parms );
            DO_ONE( PUSER_INFO_2, usri2_workstations );
            DO_ONE( PUSER_INFO_2, usri2_logon_hours );
            DO_ONE( PUSER_INFO_2, usri2_logon_server );

            /* Drop through to case 1 */

        case 1:
            DO_ONE( PUSER_INFO_1, usri1_home_dir );
            DO_ONE( PUSER_INFO_1, usri1_comment );
            DO_ONE( PUSER_INFO_1, usri1_script_path );
            /* Drop through to case 0 */

        case 0:
            DO_ONE( PUSER_INFO_0, usri0_name );
            break;

        case 11:
            DO_ONE( PUSER_INFO_11, usri11_home_dir );
            DO_ONE( PUSER_INFO_11, usri11_parms );
            DO_ONE( PUSER_INFO_11, usri11_logon_server );
            DO_ONE( PUSER_INFO_11, usri11_workstations );
            DO_ONE( PUSER_INFO_11, usri11_home_dir );
            DO_ONE( PUSER_INFO_11, usri11_logon_hours );

            /* Drop through to case 10 */

        case 10:
            DO_ONE( PUSER_INFO_10, usri10_name );
            DO_ONE( PUSER_INFO_10, usri10_comment );
            DO_ONE( PUSER_INFO_10, usri10_usr_comment );
            DO_ONE( PUSER_INFO_10, usri10_full_name );
            break;

        case 20:
            DO_ONE( PUSER_INFO_20, usri20_name );
            DO_ONE( PUSER_INFO_20, usri20_full_name );
            DO_ONE( PUSER_INFO_20, usri20_comment );
            break;

        default:
            NetpAssert( FALSE );
            return;


        }

    }

    return;

} // UserpRelocationRoutine


NET_API_STATUS
UserpGetInfo(
    IN SAM_HANDLE DomainHandle,
    IN PSID DomainId,
    IN SAM_HANDLE BuiltinDomainHandle OPTIONAL,
    IN UNICODE_STRING UserName,
    IN ULONG UserRelativeId,
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN BOOL IsGet,
    IN DWORD SamFilter
    )

/*++

Routine Description:

   Get the information on one user and fill that information into an
   allocated buffer.

Arguments:

    DomainHandle - Domain Handle for the Account domain.

    DomainId - Domain Id corresponding to DomainHandle

    BuiltinDomainHandle - Domain Handle for the builtin domain.  Need only be
        specified for info level 1, 2, 3, and 11.

    UserName - User name of the user to query.

    UserRelativeId - Relative ID of the user to query.

    Level - Level of information required. level 0, 1, 2, 3, 10, 11 and 20
        are valid.

    PrefMaxLen - Callers prefered maximum length

    BufferDescriptor - Points to a structure which describes the allocated
        buffer.  On the first call, pass in BufferDescriptor->Buffer set
        to NULL.  On subsequent calls (in the 'enum' case), pass in the
        structure just as it was passed back on a previous call.

        The caller must deallocate the BufferDescriptor->Buffer using
        MIDL_user_free if it is non-null.

    IsGet - True iff this is a 'get' call and not an 'enum' call.

Return Value:

    Error code for the operation.

    If this is an Enum call, the status can be ERROR_MORE_DATA implying that
    the Buffer has grown to PrefMaxLen and that this much data should
    be returned to the caller.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    SAM_HANDLE UserHandle = NULL;
    USER_ALL_INFORMATION *UserAll = NULL;
    UNICODE_STRING LogonServer;

    ACCESS_MASK  DesiredAccess;
    ULONG RequiredFields;
    PACL UserDacl = NULL;

    ULONG RidToReturn = UserRelativeId; 

    DWORD Size;                 // The size of the info returned for this user
    DWORD FixedSize;            // The size of the info returned for this user
    LPBYTE NewStruct;           // Pointer to fixed portion of new structure

    PSID   UserSid = NULL;      // sid of the user

    DWORD  password_expired;

    //
    // Variables describes membership in the special groups.
    //

    DWORD Priv;
    DWORD AuthFlags;



    //
    // Validate Level parameter and remember the fixed size of each returned
    //  array entry.
    //
    RtlInitUnicodeString( &LogonServer, L"\\\\*" );

    switch (Level) {

    case 0:
        FixedSize = sizeof(USER_INFO_0);
        DesiredAccess = 0;

        RequiredFields = 0;
        break;

    case 1:
        FixedSize = sizeof(USER_INFO_1);
        DesiredAccess = USER_LIST_GROUPS | USER_READ_GENERAL |
            USER_READ_LOGON | USER_READ_ACCOUNT | READ_CONTROL;

        RequiredFields = USER_ALL_USERNAME |
                         USER_ALL_PASSWORDLASTSET |
                         USER_ALL_HOMEDIRECTORY |
                         USER_ALL_ADMINCOMMENT |
                         USER_ALL_USERACCOUNTCONTROL |
                         USER_ALL_SCRIPTPATH ;

        break;

    case 2:
        FixedSize = sizeof(USER_INFO_2);
        DesiredAccess = USER_LIST_GROUPS | USER_READ_GENERAL |
            USER_READ_LOGON | USER_READ_ACCOUNT | READ_CONTROL |
            USER_READ_PREFERENCES;

        RequiredFields = USER_ALL_FULLNAME |
                         USER_ALL_USERCOMMENT |
                         USER_ALL_PARAMETERS |
                         USER_ALL_WORKSTATIONS |
                         USER_ALL_LASTLOGON |
                         USER_ALL_LASTLOGOFF |
                         USER_ALL_ACCOUNTEXPIRES |
                         USER_ALL_LOGONHOURS |
                         USER_ALL_BADPASSWORDCOUNT |
                         USER_ALL_LOGONCOUNT |
                         USER_ALL_COUNTRYCODE |
                         USER_ALL_CODEPAGE |
                         USER_ALL_USERNAME |
                         USER_ALL_PASSWORDLASTSET |
                         USER_ALL_HOMEDIRECTORY |
                         USER_ALL_ADMINCOMMENT |
                         USER_ALL_USERACCOUNTCONTROL |
                         USER_ALL_SCRIPTPATH ;

        break;

    case 3:
        FixedSize = sizeof(USER_INFO_3);
        DesiredAccess = USER_LIST_GROUPS | USER_READ_GENERAL |
            USER_READ_LOGON | USER_READ_ACCOUNT | READ_CONTROL |
            USER_READ_PREFERENCES;

        RequiredFields = USER_ALL_USERID |
                         USER_ALL_PRIMARYGROUPID |
                         USER_ALL_PROFILEPATH |
                         USER_ALL_HOMEDIRECTORYDRIVE |
                         USER_ALL_PASSWORDMUSTCHANGE |
                         USER_ALL_FULLNAME |
                         USER_ALL_USERCOMMENT |
                         USER_ALL_PARAMETERS |
                         USER_ALL_WORKSTATIONS |
                         USER_ALL_LASTLOGON |
                         USER_ALL_LASTLOGOFF |
                         USER_ALL_ACCOUNTEXPIRES |
                         USER_ALL_LOGONHOURS |
                         USER_ALL_BADPASSWORDCOUNT |
                         USER_ALL_LOGONCOUNT |
                         USER_ALL_COUNTRYCODE |
                         USER_ALL_CODEPAGE |
                         USER_ALL_USERNAME |
                         USER_ALL_PASSWORDLASTSET |
                         USER_ALL_HOMEDIRECTORY |
                         USER_ALL_ADMINCOMMENT |
                         USER_ALL_USERACCOUNTCONTROL |
                         USER_ALL_SCRIPTPATH ;

        break;

    case 4:
        FixedSize = sizeof(USER_INFO_4);
        DesiredAccess = USER_LIST_GROUPS | USER_READ_GENERAL |
            USER_READ_LOGON | USER_READ_ACCOUNT | READ_CONTROL |
            USER_READ_PREFERENCES;

        RequiredFields = USER_ALL_USERID |
                         USER_ALL_PRIMARYGROUPID |
                         USER_ALL_PROFILEPATH |
                         USER_ALL_HOMEDIRECTORYDRIVE |
                         USER_ALL_PASSWORDMUSTCHANGE |
                         USER_ALL_FULLNAME |
                         USER_ALL_USERCOMMENT |
                         USER_ALL_PARAMETERS |
                         USER_ALL_WORKSTATIONS |
                         USER_ALL_LASTLOGON |
                         USER_ALL_LASTLOGOFF |
                         USER_ALL_ACCOUNTEXPIRES |
                         USER_ALL_LOGONHOURS |
                         USER_ALL_BADPASSWORDCOUNT |
                         USER_ALL_LOGONCOUNT |
                         USER_ALL_COUNTRYCODE |
                         USER_ALL_CODEPAGE |
                         USER_ALL_USERNAME |
                         USER_ALL_PASSWORDLASTSET |
                         USER_ALL_HOMEDIRECTORY |
                         USER_ALL_ADMINCOMMENT |
                         USER_ALL_USERACCOUNTCONTROL |
                         USER_ALL_SCRIPTPATH ;

        break;

    case 10:
        FixedSize = sizeof(USER_INFO_10);
        DesiredAccess = USER_READ_GENERAL;

        RequiredFields = USER_ALL_USERNAME |
                         USER_ALL_ADMINCOMMENT |
                         USER_ALL_USERCOMMENT |
                         USER_ALL_FULLNAME ;
        break;

    case 11:
        FixedSize = sizeof(USER_INFO_11);
        DesiredAccess = USER_LIST_GROUPS | USER_READ_GENERAL | USER_READ_LOGON |
            USER_READ_ACCOUNT | USER_READ_PREFERENCES;

        RequiredFields = USER_ALL_USERNAME |
                         USER_ALL_ADMINCOMMENT |
                         USER_ALL_USERCOMMENT |
                         USER_ALL_FULLNAME |
                         USER_ALL_PASSWORDLASTSET |
                         USER_ALL_HOMEDIRECTORY |
                         USER_ALL_PARAMETERS |
                         USER_ALL_LASTLOGON |
                         USER_ALL_LASTLOGOFF |
                         USER_ALL_BADPASSWORDCOUNT |
                         USER_ALL_LOGONCOUNT |
                         USER_ALL_COUNTRYCODE |
                         USER_ALL_WORKSTATIONS |
                         USER_ALL_LOGONHOURS |
                         USER_ALL_CODEPAGE ;
        break;

    case 20:
        FixedSize = sizeof(USER_INFO_20);
        DesiredAccess =  USER_READ_GENERAL | USER_READ_ACCOUNT | READ_CONTROL;

        RequiredFields = USER_ALL_USERNAME |
                         USER_ALL_FULLNAME |
                         USER_ALL_ADMINCOMMENT |
                         USER_ALL_USERACCOUNTCONTROL;
        break;

    case 23:
        FixedSize = sizeof(USER_INFO_23);
        DesiredAccess =  USER_READ_GENERAL | USER_READ_ACCOUNT | READ_CONTROL;

        RequiredFields = USER_ALL_USERNAME |
                         USER_ALL_FULLNAME |
                         USER_ALL_ADMINCOMMENT |
                         USER_ALL_USERACCOUNTCONTROL;
        break;

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    //
    // Validate that the level is supported
    //
    if ( Level == 3 || Level == 20 ) {

        ULONG Mode;
        Status = SamGetCompatibilityMode(DomainHandle, &Mode);
        if (!NT_SUCCESS(Status)) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }
        switch (Mode) {
        case SAM_SID_COMPATIBILITY_STRICT:
            NetStatus = ERROR_NOT_SUPPORTED;
            goto Cleanup;
        case SAM_SID_COMPATIBILITY_LAX:
            RidToReturn = 0;
            break;
        }
    }

    //
    // if we need to filter this account then query
    // USER_ALL_USERACCOUNTCONTROL also.
    //

    if( SamFilter ) {

        DesiredAccess |= USER_READ_ACCOUNT;
        RequiredFields |= USER_ALL_USERACCOUNTCONTROL;
    }

    //
    // Open the User account if need be
    //

    if ( DesiredAccess != 0 ) {

        Status = SamOpenUser( DomainHandle,
                              DesiredAccess,
                              UserRelativeId,
                              &UserHandle);

        if ( !NT_SUCCESS(Status) ) {
            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint(( "UserpGetInfo: SamOpenUser returns %lX\n",
                          Status ));
            }
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

    }

    //
    // Get all the information we need about the user
    //

    if ( RequiredFields != 0 ) {

        Status = SamQueryInformationUser( UserHandle,
                                          UserAllInformation,
                                          (PVOID *)&UserAll );

        if ( ! NT_SUCCESS( Status ) ) {
            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint((
                    "UserpGetInfo: SamQueryInformationUser returns %lX\n",
                    Status ));
            }
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        if ( (UserAll->WhichFields & RequiredFields) != RequiredFields ) {
#if DBG
            NetpKdPrint(( "UserpGetInfo: WhichFields: %lX RequireFields: %lX\n",
                          UserAll->WhichFields,
                          RequiredFields ));
#endif // DBG
            NetStatus = ERROR_ACCESS_DENIED;
            goto Cleanup;

        }

        //
        // check the account type to filter this account.
        //

        if( (SamFilter != 0) &&
                ((UserAll->UserAccountControl & SamFilter) == 0)) {

            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint(( "UserpGetInfo: %wZ is skipped \n", &UserName ));
            }

            NetStatus = NERR_Success ;
            goto Cleanup;
        }
    }

    //
    // Level 1, 2 and 3 use the User's DACL to figure out the usriX_flags field.
    //

    if ((Level == 1) || 
        (Level == 2) || 
        (Level == 3) || 
        (Level == 4) || 
        (Level == 20) || 
        (Level == 23) ) {


        //
        // Get the DACL for this user.
        //

        NetStatus = UserpGetDacl( UserHandle, &UserDacl, NULL );

        if ( NetStatus != NERR_Success ) {
            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint((
                    "UserpGetInfo: UserpGetDacl returns %ld\n",
                    NetStatus ));
            }
            goto Cleanup;
        }

    }

    //
    // Determine the Priv and AuthFlags
    //

    if (Level == 1 || Level == 2 || Level == 3 || Level == 4 || Level == 11 ) {

        //
        //

        NetStatus = UserpGetUserPriv(
                     BuiltinDomainHandle,
                     UserHandle,
                     UserRelativeId,
                     DomainId,
                     &Priv,
                     &AuthFlags );

        if ( NetStatus != NERR_Success ) {
            goto Cleanup;
        }

    }

    //
    // Construct the user's SID if necessary
    //
    if (  (Level == 4) 
       || (Level == 23) ) {

        NetStatus = NetpSamRidToSid(UserHandle,
                                    UserRelativeId,
                                   &UserSid);

        if ( NetStatus != NERR_Success ) {
            goto Cleanup;
        }
    }

    //
    // Determine if the account has expired
    //
    if (  (Level == 3)
       || (Level == 4) ) {

           //
           // If the password is currently expired,
           //  indicate so.
           //
           LARGE_INTEGER CurrentTime;
           (VOID) NtQuerySystemTime( &CurrentTime );

           if ( CurrentTime.QuadPart
                >= UserAll->PasswordMustChange.QuadPart ) {
               password_expired = TRUE;
           } else {
               password_expired = FALSE;
           }
    }

    //
    // Determine the total size of the return information.
    //

    Size = FixedSize;
    switch (Level) {
    case 0:
        Size += UserName.Length + sizeof(WCHAR);
        break;

    case 4:
        NetpAssert( NULL != UserSid );
        Size += RtlLengthSid(UserSid);

        /* Drop through to case 3 */

    case 3:
        Size += UserAll->ProfilePath.Length + sizeof(WCHAR) +
                UserAll->HomeDirectoryDrive.Length + sizeof(WCHAR);

        /* Drop through to case 2 */

    case 2:
        Size += UserAll->FullName.Length + sizeof(WCHAR) +
                UserAll->UserComment.Length + sizeof(WCHAR) +
                UserAll->Parameters.Length + sizeof(WCHAR) +
                UserAll->WorkStations.Length + sizeof(WCHAR) +
                LogonServer.Length + sizeof(WCHAR) +
                UserpSizeOfLogonHours( UserAll->LogonHours.UnitsPerWeek );

        /* Drop through to case 1 */

    case 1:
        Size += UserAll->UserName.Length + sizeof(WCHAR) +
                UserAll->HomeDirectory.Length + sizeof(WCHAR) +
                UserAll->AdminComment.Length + sizeof(WCHAR) +
                UserAll->ScriptPath.Length + sizeof(WCHAR);

        break;

    case 10:
        Size += UserAll->UserName.Length + sizeof(WCHAR) +
                UserAll->AdminComment.Length + sizeof(WCHAR) +
                UserAll->UserComment.Length + sizeof(WCHAR) +
                UserAll->FullName.Length + sizeof(WCHAR);

        break;

    case 11:
        Size += UserAll->UserName.Length + sizeof(WCHAR) +
                UserAll->AdminComment.Length + sizeof(WCHAR) +
                UserAll->UserComment.Length + sizeof(WCHAR) +
                UserAll->FullName.Length + sizeof(WCHAR) +
                UserAll->HomeDirectory.Length + sizeof(WCHAR) +
                UserAll->Parameters.Length + sizeof(WCHAR) +
                UserAll->WorkStations.Length + sizeof(WCHAR) +
                LogonServer.Length + sizeof(WCHAR) +
                UserpSizeOfLogonHours( UserAll->LogonHours.UnitsPerWeek );

        break;

    case 23:

        NetpAssert( NULL != UserSid );
        Size += RtlLengthSid(UserSid);

        /* Drop through to case 20 */


    case 20:
        Size += UserAll->UserName.Length + sizeof(WCHAR) +
                UserAll->FullName.Length + sizeof(WCHAR) +
                UserAll->AdminComment.Length + sizeof(WCHAR);

        break;

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;

    }

    //
    // Ensure there is buffer space for this information.
    //

    Size = ROUND_UP_COUNT( Size, ALIGN_DWORD );

    NetStatus = NetpAllocateEnumBuffer(
                    BufferDescriptor,
                    IsGet,
                    PrefMaxLen,
                    Size,
                    UserpRelocationRoutine,
                    Level );

    if (NetStatus != NERR_Success) {

        //
        // NetpAllocateEnumBuffer returns ERROR_MORE_DATA if this
        // entry doesn't fit into the buffer.
        //

        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "UserpGetInfo: NetpAllocateEnumBuffer returns %ld\n",
                NetStatus ));
        }

        goto Cleanup;
    }

//
// Define macros to make copying bytes and zero terminated strings less
//  repetitive.
//

#define COPY_BYTES( _type, _fieldname, _inptr, _length, _align ) \
    if ( !NetpCopyDataToBuffer( \
                (_inptr), \
                (_length), \
                BufferDescriptor->FixedDataEnd, \
                &BufferDescriptor->EndOfVariableData, \
                (LPBYTE*)&((_type)NewStruct)->_fieldname, \
                _align ) ){ \
    \
        NetStatus = NERR_InternalError; \
        IF_DEBUG( UAS_DEBUG_USER ) { \
            NetpKdPrint(( "UserpGetInfo: NetpCopyData returns %ld\n", \
                NetStatus )); \
        } \
        goto Cleanup; \
    }


#define COPY_STRING( _type, _fieldname, _string ) \
    if ( !NetpCopyStringToBuffer( \
                    (_string).Buffer, \
                    (_string).Length/sizeof(WCHAR), \
                    BufferDescriptor->FixedDataEnd, \
                    (LPWSTR *)&BufferDescriptor->EndOfVariableData, \
                    &((_type)NewStruct)->_fieldname) ) { \
    \
        NetStatus = NERR_InternalError; \
        IF_DEBUG( UAS_DEBUG_USER ) { \
            NetpKdPrint(( "UserpGetInfo: NetpCopyString returns %ld\n", \
                NetStatus )); \
        } \
        goto Cleanup; \
    }

    //
    // Place this entry into the return buffer.
    //
    // Fill in the information.  The array of fixed entries is
    // placed at the beginning of the allocated buffer.  The strings
    // pointed to by these fixed entries are allocated starting at
    // the end of the allocate buffer.
    //

    NewStruct = BufferDescriptor->FixedDataEnd;
    BufferDescriptor->FixedDataEnd += FixedSize;

    switch ( Level ) {
    case 4: 
        {
            //
            // USER_INFO_2, below, is a subset of USER_INFO_4, so fill in our 
            // structures here and then fall through
            //
            PUSER_INFO_4 usri4 = (PUSER_INFO_4) NewStruct;

            NetpAssert( NULL != UserSid );
            COPY_BYTES( PUSER_INFO_4,
                        usri4_user_sid,
                        UserSid,
                        RtlLengthSid(UserSid),
                        ALIGN_DWORD );
    
            usri4->usri4_primary_group_id = UserAll->PrimaryGroupId;

            COPY_STRING( PUSER_INFO_4, usri4_profile, UserAll->ProfilePath );

            COPY_STRING( PUSER_INFO_4,
                         usri4_home_dir_drive,
                         UserAll->HomeDirectoryDrive );

            NetpAssert(  (password_expired == TRUE) 
                      || (password_expired == FALSE));

            usri4->usri4_password_expired = password_expired;

            //
            // Fall through the level 3
            //
        }

    case 3:
        {
            //
            // since _USER_INFO_2 structure is subset of _USER_INFO_3,
            // full-up the _USER_INFO_3 only fields first and then  fall
            // through for the common fields.
            //
            if ( Level == 3 ) {

                PUSER_INFO_3 usri3 = (PUSER_INFO_3) NewStruct;
    
                NetpAssert( UserRelativeId == UserAll->UserId );
                usri3->usri3_user_id = RidToReturn;
    
                usri3->usri3_primary_group_id = UserAll->PrimaryGroupId;
    
                COPY_STRING( PUSER_INFO_3, usri3_profile, UserAll->ProfilePath );
    
                COPY_STRING( PUSER_INFO_3,
                             usri3_home_dir_drive,
                             UserAll->HomeDirectoryDrive );
    
                NetpAssert(  (password_expired == TRUE) 
                          || (password_expired == FALSE));
    
                usri3->usri3_password_expired = password_expired;
            }
        }

        //
        // FALL THROUGH FOR OTHER _USER_INFO_3 FIELDS
        //


    case 2:
        {

            PUSER_INFO_2 usri2 = (PUSER_INFO_2) NewStruct;

            usri2->usri2_auth_flags = AuthFlags;

            COPY_STRING( PUSER_INFO_2,
                         usri2_full_name,
                         UserAll->FullName );

            COPY_STRING( PUSER_INFO_2,
                         usri2_usr_comment,
                         UserAll->UserComment);

            COPY_STRING( PUSER_INFO_2,
                         usri2_parms,
                         UserAll->Parameters );

            COPY_STRING( PUSER_INFO_2,
                         usri2_workstations,
                         UserAll->WorkStations);

            if ( !RtlTimeToSecondsSince1970( &UserAll->LastLogon,
                                             &usri2->usri2_last_logon) ) {
                usri2->usri2_last_logon = 0;
            }

            if ( !RtlTimeToSecondsSince1970( &UserAll->LastLogoff,
                                             &usri2->usri2_last_logoff) ) {
                usri2->usri2_last_logoff = 0;
            }

            if ( !RtlTimeToSecondsSince1970( &UserAll->AccountExpires,
                                             &usri2->usri2_acct_expires) ) {
                usri2->usri2_acct_expires = TIMEQ_FOREVER;
            }

            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint(( "UserpGetInfo: Account Expries %lx %lx %lx\n",
                            UserAll->AccountExpires.HighPart,
                            UserAll->AccountExpires.LowPart,
                            usri2->usri2_acct_expires));
            }


            usri2->usri2_max_storage = USER_MAXSTORAGE_UNLIMITED;

            usri2->usri2_units_per_week = UserAll->LogonHours.UnitsPerWeek;

            IF_DEBUG( UAS_DEBUG_USER ) {
                DWORD k;
                NetpDbgDisplayDword( "UserpGetInfo: units_per_week",
                                      usri2->usri2_units_per_week );
                NetpKdPrint(( "UserpGetInfo: LogonHours %lx\n",
                              UserAll->LogonHours.LogonHours));


                for ( k=0;
                      k<UserpSizeOfLogonHours(
                        UserAll->LogonHours.UnitsPerWeek);
                      k++ ) {
                    NetpKdPrint(( "%d ",
                        UserAll->LogonHours.LogonHours[k] ));
                }
                NetpKdPrint(( "\n" ));
            }





            COPY_BYTES( PUSER_INFO_2,
                        usri2_logon_hours,
                        UserAll->LogonHours.LogonHours,
                        UserpSizeOfLogonHours(
                            UserAll->LogonHours.UnitsPerWeek ),
                        sizeof(UCHAR) );
            BufferDescriptor->EndOfVariableData =
                ROUND_DOWN_POINTER( BufferDescriptor->EndOfVariableData,
                                    ALIGN_WCHAR );

            usri2->usri2_bad_pw_count = UserAll->BadPasswordCount;
            usri2->usri2_num_logons = UserAll->LogonCount;

            COPY_STRING( PUSER_INFO_2,
                         usri2_logon_server,
                         LogonServer );

            usri2->usri2_country_code = UserAll->CountryCode;
            usri2->usri2_code_page = UserAll->CodePage;

            /* Drop through to case 1 */
        }

    case 1:
        {
            PUSER_INFO_1 usri1 = (PUSER_INFO_1) NewStruct;

            COPY_STRING( PUSER_INFO_1, usri1_name, UserAll->UserName );
            usri1->usri1_password = NULL;

            usri1->usri1_password_age =
                NetpGetElapsedSeconds( &UserAll->PasswordLastSet );

            usri1->usri1_priv = Priv;

            COPY_STRING( PUSER_INFO_1, usri1_home_dir, UserAll->HomeDirectory );
            COPY_STRING( PUSER_INFO_1, usri1_comment, UserAll->AdminComment);


            usri1->usri1_flags = NetpAccountControlToFlags(
                                    UserAll->UserAccountControl,
                                    UserDacl );

            COPY_STRING( PUSER_INFO_1, usri1_script_path, UserAll->ScriptPath);

            break;
        }

    case 0:

        COPY_STRING( PUSER_INFO_0, usri0_name, UserName );
        break;

    case 10:

        COPY_STRING( PUSER_INFO_10, usri10_name, UserAll->UserName );
        COPY_STRING( PUSER_INFO_10, usri10_comment, UserAll->AdminComment );
        COPY_STRING( PUSER_INFO_10, usri10_usr_comment, UserAll->UserComment );
        COPY_STRING( PUSER_INFO_10, usri10_full_name, UserAll->FullName );

        break;

    case 11:
        {
            PUSER_INFO_11 usri11 = (PUSER_INFO_11) NewStruct;

            COPY_STRING( PUSER_INFO_11, usri11_name, UserAll->UserName );
            COPY_STRING( PUSER_INFO_11, usri11_comment, UserAll->AdminComment );
            COPY_STRING(PUSER_INFO_11, usri11_usr_comment,UserAll->UserComment);
            COPY_STRING( PUSER_INFO_11, usri11_full_name, UserAll->FullName );

            usri11->usri11_priv = Priv;
            usri11->usri11_auth_flags = AuthFlags;

            usri11->usri11_password_age =
                NetpGetElapsedSeconds( &UserAll->PasswordLastSet );


            COPY_STRING(PUSER_INFO_11, usri11_home_dir, UserAll->HomeDirectory);
            COPY_STRING( PUSER_INFO_11, usri11_parms, UserAll->Parameters );

            if ( !RtlTimeToSecondsSince1970( &UserAll->LastLogon,
                                             &usri11->usri11_last_logon) ) {
                usri11->usri11_last_logon = 0;
            }

            if ( !RtlTimeToSecondsSince1970( &UserAll->LastLogoff,
                                             &usri11->usri11_last_logoff) ) {
                usri11->usri11_last_logoff = 0;
            }

            usri11->usri11_bad_pw_count = UserAll->BadPasswordCount;
            usri11->usri11_num_logons = UserAll->LogonCount;

            COPY_STRING( PUSER_INFO_11, usri11_logon_server, LogonServer );

            usri11->usri11_country_code = UserAll->CountryCode;

            COPY_STRING( PUSER_INFO_11,
                         usri11_workstations,
                         UserAll->WorkStations );

            usri11->usri11_max_storage = USER_MAXSTORAGE_UNLIMITED;
            usri11->usri11_units_per_week = UserAll->LogonHours.UnitsPerWeek;

            COPY_BYTES( PUSER_INFO_11,
                        usri11_logon_hours,
                        UserAll->LogonHours.LogonHours,
                        UserpSizeOfLogonHours(
                            UserAll->LogonHours.UnitsPerWeek ),
                        sizeof(UCHAR) );
            BufferDescriptor->EndOfVariableData =
                ROUND_DOWN_POINTER( BufferDescriptor->EndOfVariableData,
                                    ALIGN_WCHAR );

            usri11->usri11_code_page = UserAll->CodePage;

            break;
        }

    case 23:
        {
            //
            // Since USER_INFO_23 has the same fields as USER_INFO_20 with the
            // exception of the RID and SID fields, copy in the SID here and
            // then fall through for the rest of the fields
            //
            PUSER_INFO_23 usri23 = (PUSER_INFO_23) NewStruct;
            NetpAssert( NULL != UserSid );
    
            COPY_BYTES( PUSER_INFO_23,
                        usri23_user_sid,
                        UserSid,
                        RtlLengthSid(UserSid),
                        ALIGN_DWORD );
    
            //
            // Fall through the level 20
            //
        }

    case 20:
        {

            PUSER_INFO_20 usri20 = (PUSER_INFO_20) NewStruct;

            COPY_STRING( PUSER_INFO_20, usri20_name, UserAll->UserName );

            COPY_STRING( PUSER_INFO_20, usri20_full_name, UserAll->FullName );

            COPY_STRING( PUSER_INFO_20, usri20_comment, UserAll->AdminComment );

            if ( Level == 20 ) {
                usri20->usri20_user_id = RidToReturn;
            }

            usri20->usri20_flags = NetpAccountControlToFlags(
                                    UserAll->UserAccountControl,
                                    UserDacl );

            break;

        }

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;

    }

    NetStatus = NERR_Success ;

    //
    // Clean up.
    //

Cleanup:

    //
    // Free Sam information buffers
    //

    if ( UserAll != NULL ) {
        Status = SamFreeMemory( UserAll );
        NetpAssert( NT_SUCCESS(Status) );
    }

    if ( UserHandle != NULL ) {
        (VOID) SamCloseHandle( UserHandle );
    }

    if ( UserDacl != NULL ) {
        NetpMemoryFree( UserDacl );
    }

    if ( UserSid ) {
        NetpMemoryFree( UserSid );
    }

    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "UserpGetInfo: returning %ld\n", NetStatus ));
    }

    return NetStatus;

} // UserpGetInfo



//
// Each field in the SAM USER_ALL_INFORMATION structure (and each pseudo field)
// is described here.

struct _SAM_FIELD_DESCRIPTION {
    //
    // Non-zero to indicate which field in the SAM USER_ALL_INFORMATION
    // structure is being set.

    DWORD WhichField;

    //
    // Define the value to return in ParmError if this field is bad.
    //

    DWORD UasParmNum;

    //
    // Describe the byte offset of the field in the SAM USER_ALL_INFORMATION
    // structure.
    //

    DWORD SamOffset;

    //
    // The DesiredAccess mask includes both the access to read and the
    // access to write the appropriate field in the USER_ALL_INFORMATION
    //

    ACCESS_MASK DesiredAccess;

} SamFieldDescription[] =
{

#define SAM_UserNameField           0
    {   USER_ALL_USERNAME, USER_NAME_PARMNUM,
        offsetof(USER_ALL_INFORMATION, UserName),
        USER_WRITE_ACCOUNT
    },

#define SAM_FullNameField           1
    {   USER_ALL_FULLNAME, USER_FULL_NAME_PARMNUM,
        offsetof(USER_ALL_INFORMATION, FullName),
        USER_WRITE_ACCOUNT
    },

#define SAM_PrimaryGroupIdField     2
    {   USER_ALL_PRIMARYGROUPID, USER_PRIMARY_GROUP_PARMNUM,
        offsetof(USER_ALL_INFORMATION, PrimaryGroupId),
        USER_LIST_GROUPS | READ_CONTROL | WRITE_DAC |
            USER_WRITE_ACCOUNT
    },

#define SAM_AdminCommentField       3
    {   USER_ALL_ADMINCOMMENT, USER_COMMENT_PARMNUM,
        offsetof(USER_ALL_INFORMATION, AdminComment),
        USER_WRITE_ACCOUNT
    },

#define SAM_UserCommentField        4
    {   USER_ALL_USERCOMMENT, USER_USR_COMMENT_PARMNUM,
        offsetof(USER_ALL_INFORMATION, UserComment),
        USER_WRITE_PREFERENCES
    },

#define SAM_HomeDirectoryField      5
    {   USER_ALL_HOMEDIRECTORY, USER_HOME_DIR_PARMNUM,
        offsetof(USER_ALL_INFORMATION, HomeDirectory),
        USER_WRITE_ACCOUNT
    },

#define SAM_HomeDirectoryDriveField 6
    {   USER_ALL_HOMEDIRECTORYDRIVE, USER_HOME_DIR_DRIVE_PARMNUM,
        offsetof(USER_ALL_INFORMATION, HomeDirectoryDrive),
        USER_WRITE_ACCOUNT
    },

#define SAM_ScriptPathField         7
    {   USER_ALL_SCRIPTPATH, USER_SCRIPT_PATH_PARMNUM,
        offsetof(USER_ALL_INFORMATION, ScriptPath),
        USER_WRITE_ACCOUNT
    },

#define SAM_ProfilePathField        8
    {   USER_ALL_PROFILEPATH, USER_PROFILE_PARMNUM,
        offsetof(USER_ALL_INFORMATION, ProfilePath),
        USER_WRITE_ACCOUNT
    },

#define SAM_WorkstationsField       9
    {   USER_ALL_WORKSTATIONS, USER_WORKSTATIONS_PARMNUM,
        offsetof(USER_ALL_INFORMATION, WorkStations),
        USER_WRITE_ACCOUNT
    },

#define SAM_LogonHoursField        10
    {   USER_ALL_LOGONHOURS, USER_LOGON_HOURS_PARMNUM,
        offsetof(USER_ALL_INFORMATION, LogonHours.LogonHours),
        USER_WRITE_ACCOUNT
    },

#define SAM_UnitsPerWeekField      11
    {   USER_ALL_LOGONHOURS, USER_UNITS_PER_WEEK_PARMNUM,
        offsetof(USER_ALL_INFORMATION, LogonHours.UnitsPerWeek),
        USER_WRITE_ACCOUNT
    },

#define SAM_AccountExpiresField    12
    {   USER_ALL_ACCOUNTEXPIRES, USER_ACCT_EXPIRES_PARMNUM,
        offsetof(USER_ALL_INFORMATION, AccountExpires),
        USER_WRITE_ACCOUNT
    },

#define SAM_UserAccountControlField 13
    {   USER_ALL_USERACCOUNTCONTROL, USER_FLAGS_PARMNUM,
        offsetof(USER_ALL_INFORMATION, UserAccountControl),
        USER_WRITE_ACCOUNT | USER_READ_ACCOUNT | READ_CONTROL | WRITE_DAC
    },

#define SAM_ParametersField         14
    {   USER_ALL_PARAMETERS, USER_PARMS_PARMNUM,
        offsetof(USER_ALL_INFORMATION, Parameters),
        USER_WRITE_ACCOUNT
    },

#define SAM_CountryCodeField        15
    {   USER_ALL_COUNTRYCODE, USER_COUNTRY_CODE_PARMNUM,
        offsetof(USER_ALL_INFORMATION, CountryCode),
        USER_WRITE_PREFERENCES
    },

#define SAM_CodePageField           16
    {   USER_ALL_CODEPAGE, USER_CODE_PAGE_PARMNUM,
        offsetof(USER_ALL_INFORMATION, CodePage),
        USER_WRITE_PREFERENCES
    },

#define SAM_ClearTextPasswordField  17
    {   USER_ALL_NTPASSWORDPRESENT, USER_PASSWORD_PARMNUM,
        offsetof(USER_ALL_INFORMATION, NtPassword),
        USER_FORCE_PASSWORD_CHANGE
    },

#define SAM_PasswordExpiredField    18
    {   USER_ALL_PASSWORDEXPIRED, PARM_ERROR_UNKNOWN,
        offsetof(USER_ALL_INFORMATION, PasswordExpired),
        USER_FORCE_PASSWORD_CHANGE
    },

#define SAM_OwfPasswordField        19
    {   USER_ALL_LMPASSWORDPRESENT | USER_ALL_OWFPASSWORD,
            USER_PASSWORD_PARMNUM,
        offsetof(USER_ALL_INFORMATION, LmPassword),
        USER_FORCE_PASSWORD_CHANGE
    },

    //
    // The following levels are pseudo levels which merely define the
    //  access required to set a particuler UAS field.

#define SAM_AuthFlagsField          20
    {   0, PARM_ERROR_UNKNOWN,
        0,
        USER_LIST_GROUPS
    },

#define SAM_MaxStorageField         21
    {   0, USER_MAX_STORAGE_PARMNUM,
        0,
        USER_READ_GENERAL
    },
};

//
// Relate the NetUser API fields to the SAM API fields.
//
// This table contains as much information as possible to describe the
// relationship between fields in the NetUser API and the SAM API.
//

struct _UAS_SAM_TABLE {

    //
    // Describe the field types for UAS and SAM.
    //

    enum {
        UT_STRING,          // UAS is LPWSTR. SAM is UNICODE_STRING.
        UT_BOOLEAN,         // UAS is DWORD.  SAM is BOOLEAN.
        UT_USHORT,          // UAS is DWORD.  SAM is USHORT.
        UT_ULONG,           // UAS is DWORD.  SAM is ULONG.
        UT_TIME,            // UAS is seconds since 1970.  SAM is LARGE_INTEGER.
        UT_PRIV,            // Special case
        UT_ACCOUNT_CONTROL, // Special case
        UT_AUTH_FLAGS,      // Special case
        UT_MAX_STORAGE,     // Special case
        UT_OWF_PASSWORD,    // Special case
        UT_LOGON_HOURS,     // Special case
        UT_UNITS_PER_WEEK,  // Special case
        UT_CREATE_FULLNAME  // Special case
    } FieldType;

    //
    // The NetUser API detail level this field is in.
    //

    DWORD UasLevel;

    //
    // Index to the structure describing the Sam Field being changed.
    //

    DWORD SamField;


    //
    // Describe the byte offset of the field in the appropriate UAS
    // and SAM structures.
    //

    DWORD UasOffset;

} UserpUasSamTable[] =

{
    // Rename an account at info level 0 only.

    { UT_STRING, 0, SAM_UserNameField,
        offsetof(USER_INFO_1, usri1_name) },



    { UT_STRING, 1, SAM_ClearTextPasswordField,
        offsetof(USER_INFO_1, usri1_password) },

    { UT_STRING, 2, SAM_ClearTextPasswordField,
        offsetof(USER_INFO_2, usri2_password) },

    { UT_STRING, 3, SAM_ClearTextPasswordField,
        offsetof(USER_INFO_3, usri3_password) },

    { UT_STRING, 4, SAM_ClearTextPasswordField,
        offsetof(USER_INFO_4, usri4_password) },

    { UT_STRING, 1003, SAM_ClearTextPasswordField,
        offsetof(USER_INFO_1003, usri1003_password) },



    { UT_OWF_PASSWORD, 21, SAM_OwfPasswordField,
        offsetof(USER_INFO_21, usri21_password[0]) },

    { UT_OWF_PASSWORD, 22, SAM_OwfPasswordField,
        offsetof(USER_INFO_22, usri22_password[0]) },



    { UT_PRIV, 1, SAM_AuthFlagsField,
        offsetof(USER_INFO_1, usri1_priv) },

    { UT_PRIV, 2, SAM_AuthFlagsField,
        offsetof(USER_INFO_2, usri2_priv) },

    { UT_PRIV, 22, SAM_AuthFlagsField,
        offsetof(USER_INFO_22, usri22_priv) },


#ifdef notdef
    //
    // usri3_priv is totally ignored for info level three.  The field is
    // supplied for compatibility with LM 2.x only and LM 2.x never uses
    // info level 3.
    //
    { UT_PRIV, 3, SAM_AuthFlagsField,
        offsetof(USER_INFO_3, usri3_priv) },
#endif // notdef

    { UT_PRIV, 1005, SAM_AuthFlagsField,
        offsetof(USER_INFO_1005, usri1005_priv) },



    { UT_STRING, 1, SAM_HomeDirectoryField,
        offsetof(USER_INFO_1, usri1_home_dir) },

    { UT_STRING, 2, SAM_HomeDirectoryField,
        offsetof(USER_INFO_2, usri2_home_dir) },

    { UT_STRING, 22, SAM_HomeDirectoryField,
        offsetof(USER_INFO_22, usri22_home_dir) },


    { UT_STRING, 3, SAM_HomeDirectoryField,
        offsetof(USER_INFO_3, usri3_home_dir) },

    { UT_STRING, 4, SAM_HomeDirectoryField,
        offsetof(USER_INFO_4, usri4_home_dir) },

    { UT_STRING, 1006, SAM_HomeDirectoryField,
        offsetof(USER_INFO_1006, usri1006_home_dir) },


    { UT_STRING, 1, SAM_AdminCommentField,
        offsetof(USER_INFO_1, usri1_comment) },

    { UT_STRING, 2, SAM_AdminCommentField,
        offsetof(USER_INFO_2, usri2_comment) },

    { UT_STRING, 22, SAM_AdminCommentField,
        offsetof(USER_INFO_22, usri22_comment) },


    { UT_STRING, 3, SAM_AdminCommentField,
        offsetof(USER_INFO_3, usri3_comment) },

    { UT_STRING, 4, SAM_AdminCommentField,
        offsetof(USER_INFO_4, usri4_comment) },

    { UT_STRING, 1007, SAM_AdminCommentField,
        offsetof(USER_INFO_1007, usri1007_comment) },


    { UT_ACCOUNT_CONTROL, 1, SAM_UserAccountControlField,
        offsetof(USER_INFO_1, usri1_flags) },

    { UT_ACCOUNT_CONTROL, 2, SAM_UserAccountControlField,
        offsetof(USER_INFO_2, usri2_flags) },

    { UT_ACCOUNT_CONTROL, 22, SAM_UserAccountControlField,
        offsetof(USER_INFO_22, usri22_flags) },


    { UT_ACCOUNT_CONTROL, 3, SAM_UserAccountControlField,
        offsetof(USER_INFO_3, usri3_flags) },

    { UT_ACCOUNT_CONTROL, 4, SAM_UserAccountControlField,
        offsetof(USER_INFO_4, usri4_flags) },

    { UT_ACCOUNT_CONTROL, 1008, SAM_UserAccountControlField,
        offsetof(USER_INFO_1008, usri1008_flags) },


    { UT_STRING, 1, SAM_ScriptPathField,
        offsetof(USER_INFO_1, usri1_script_path) },

    { UT_STRING, 2, SAM_ScriptPathField,
        offsetof(USER_INFO_2, usri2_script_path) },

    { UT_STRING, 22, SAM_ScriptPathField,
        offsetof(USER_INFO_22, usri22_script_path) },


    { UT_STRING, 3, SAM_ScriptPathField,
        offsetof(USER_INFO_3, usri3_script_path) },

    { UT_STRING, 4, SAM_ScriptPathField,
        offsetof(USER_INFO_4, usri4_script_path) },

    { UT_STRING, 1009, SAM_ScriptPathField,
        offsetof(USER_INFO_1009, usri1009_script_path) },


    { UT_AUTH_FLAGS, 2, SAM_AuthFlagsField,
        offsetof(USER_INFO_2, usri2_auth_flags) },

    { UT_AUTH_FLAGS, 22, SAM_AuthFlagsField,
        offsetof(USER_INFO_22, usri22_auth_flags) },


#ifdef notdef
    //
    // usri3_auth_flags is totally ignored for info level three.  The field is
    // supplied for compatibility with LM 2.x only and LM 2.x never uses
    // info level 3.
    //
    { UT_AUTH_FLAGS, 3, SAM_AuthFlagsField,
        offsetof(USER_INFO_3, usri3_auth_flags) },

    { UT_AUTH_FLAGS, 4, SAM_AuthFlagsField,
        offsetof(USER_INFO_4, usri4_auth_flags) },
#endif // notdef

    { UT_AUTH_FLAGS, 1010, SAM_AuthFlagsField,
        offsetof(USER_INFO_1010, usri1010_auth_flags) },



    { UT_CREATE_FULLNAME, 1, SAM_FullNameField,
        offsetof(USER_INFO_1, usri1_name) },

    { UT_STRING, 2, SAM_FullNameField,
        offsetof(USER_INFO_2, usri2_full_name) },

    { UT_STRING, 22, SAM_FullNameField,
        offsetof(USER_INFO_22, usri22_full_name) },


    { UT_STRING, 3, SAM_FullNameField,
        offsetof(USER_INFO_3, usri3_full_name) },

    { UT_STRING, 4, SAM_FullNameField,
        offsetof(USER_INFO_4, usri4_full_name) },

    { UT_STRING, 1011, SAM_FullNameField,
        offsetof(USER_INFO_1011, usri1011_full_name) },



    { UT_STRING, 2, SAM_UserCommentField,
        offsetof(USER_INFO_2, usri2_usr_comment) },

    { UT_STRING, 22, SAM_UserCommentField,
        offsetof(USER_INFO_22, usri22_usr_comment) },


    { UT_STRING, 3, SAM_UserCommentField,
        offsetof(USER_INFO_3, usri3_usr_comment) },

    { UT_STRING, 4, SAM_UserCommentField,
        offsetof(USER_INFO_4, usri4_usr_comment) },

    { UT_STRING, 1012, SAM_UserCommentField,
        offsetof(USER_INFO_1012, usri1012_usr_comment) },


    { UT_STRING, 2, SAM_ParametersField,
        offsetof(USER_INFO_2, usri2_parms) },

    { UT_STRING, 22, SAM_ParametersField,
        offsetof(USER_INFO_22, usri22_parms) },


    { UT_STRING, 3, SAM_ParametersField,
        offsetof(USER_INFO_3, usri3_parms) },

    { UT_STRING, 4, SAM_ParametersField,
        offsetof(USER_INFO_4, usri4_parms) },

    { UT_STRING, 1013, SAM_ParametersField,
        offsetof(USER_INFO_1013, usri1013_parms) },


    { UT_STRING, 2, SAM_WorkstationsField,
        offsetof(USER_INFO_2, usri2_workstations) },

    { UT_STRING, 22, SAM_WorkstationsField,
        offsetof(USER_INFO_22, usri22_workstations) },


    { UT_STRING, 3, SAM_WorkstationsField,
        offsetof(USER_INFO_3, usri3_workstations) },

    { UT_STRING, 4, SAM_WorkstationsField,
        offsetof(USER_INFO_4, usri4_workstations) },

    { UT_STRING, 1014, SAM_WorkstationsField,
        offsetof(USER_INFO_1014, usri1014_workstations) },


    { UT_TIME, 2, SAM_AccountExpiresField,
        offsetof(USER_INFO_2, usri2_acct_expires) },

    { UT_TIME, 22, SAM_AccountExpiresField,
        offsetof(USER_INFO_22, usri22_acct_expires) },


    { UT_TIME, 3, SAM_AccountExpiresField,
        offsetof(USER_INFO_3, usri3_acct_expires) },

    { UT_TIME, 4, SAM_AccountExpiresField,
        offsetof(USER_INFO_4, usri4_acct_expires) },

    { UT_TIME, 1017, SAM_AccountExpiresField,
        offsetof(USER_INFO_1017, usri1017_acct_expires) },


#ifdef notdef // lm 2.1 gets this wrong when adding BDC accounts
    { UT_MAX_STORAGE, 2, SAM_MaxStorageField,
        offsetof(USER_INFO_2, usri2_max_storage) },

    { UT_MAX_STORAGE, 22, SAM_MaxStorageField,
        offsetof(USER_INFO_22, usri22_max_storage) },

    { UT_MAX_STORAGE, 3, SAM_MaxStorageField,
        offsetof(USER_INFO_3, usri3_max_storage) },

    { UT_MAX_STORAGE, 4, SAM_MaxStorageField,
        offsetof(USER_INFO_4, usri4_max_storage) },

#endif // notdef

    { UT_MAX_STORAGE, 1018, SAM_MaxStorageField,
        offsetof(USER_INFO_1018, usri1018_max_storage) },


    { UT_UNITS_PER_WEEK, 2, SAM_UnitsPerWeekField,
        offsetof(USER_INFO_2, usri2_units_per_week) },

    { UT_UNITS_PER_WEEK, 22, SAM_UnitsPerWeekField,
        offsetof(USER_INFO_22, usri22_units_per_week) },


    { UT_UNITS_PER_WEEK, 3, SAM_UnitsPerWeekField,
        offsetof(USER_INFO_3, usri3_units_per_week) },

    { UT_UNITS_PER_WEEK, 4, SAM_UnitsPerWeekField,
        offsetof(USER_INFO_4, usri4_units_per_week) },

    { UT_UNITS_PER_WEEK, 1020, SAM_UnitsPerWeekField,
        offsetof(USER_INFO_1020, usri1020_units_per_week) },


    { UT_LOGON_HOURS, 2, SAM_LogonHoursField,
        offsetof(USER_INFO_2, usri2_logon_hours) },

    { UT_LOGON_HOURS, 22, SAM_LogonHoursField,
        offsetof(USER_INFO_22, usri22_logon_hours) },


    { UT_LOGON_HOURS, 3, SAM_LogonHoursField,
        offsetof(USER_INFO_3, usri3_logon_hours) },

    { UT_LOGON_HOURS, 4, SAM_LogonHoursField,
        offsetof(USER_INFO_4, usri4_logon_hours) },

    { UT_LOGON_HOURS, 1020, SAM_LogonHoursField,
        offsetof(USER_INFO_1020, usri1020_logon_hours) },


    { UT_USHORT, 2, SAM_CountryCodeField,
        offsetof(USER_INFO_2, usri2_country_code) },

    { UT_USHORT, 22, SAM_CountryCodeField,
        offsetof(USER_INFO_22, usri22_country_code) },


    { UT_USHORT, 3, SAM_CountryCodeField,
        offsetof(USER_INFO_3, usri3_country_code) },

    { UT_USHORT, 4, SAM_CountryCodeField,
        offsetof(USER_INFO_4, usri4_country_code) },

    { UT_USHORT, 1024, SAM_CountryCodeField,
        offsetof(USER_INFO_1024, usri1024_country_code) },


    { UT_USHORT, 2, SAM_CodePageField,
        offsetof(USER_INFO_2, usri2_code_page) },

    { UT_USHORT, 22, SAM_CodePageField,
        offsetof(USER_INFO_22, usri22_code_page) },


    { UT_USHORT, 3, SAM_CodePageField,
        offsetof(USER_INFO_3, usri3_code_page) },

    { UT_USHORT, 4, SAM_CodePageField,
        offsetof(USER_INFO_4, usri4_code_page) },

    { UT_USHORT, 1025, SAM_CodePageField,
        offsetof(USER_INFO_1025, usri1025_code_page) },



    { UT_ULONG, 3, SAM_PrimaryGroupIdField,
        offsetof(USER_INFO_3, usri3_primary_group_id) },

    { UT_ULONG, 4, SAM_PrimaryGroupIdField,
        offsetof(USER_INFO_4, usri4_primary_group_id) },

    { UT_ULONG, 1051, SAM_PrimaryGroupIdField,
        offsetof(USER_INFO_1051, usri1051_primary_group_id) },



    { UT_STRING, 3, SAM_ProfilePathField,
        offsetof(USER_INFO_3, usri3_profile) },

    { UT_STRING, 4, SAM_ProfilePathField,
        offsetof(USER_INFO_4, usri4_profile) },

    { UT_STRING, 1052, SAM_ProfilePathField,
        offsetof(USER_INFO_1052, usri1052_profile) },

    { UT_STRING, 3, SAM_HomeDirectoryDriveField,
        offsetof(USER_INFO_3, usri3_home_dir_drive) },

    { UT_STRING, 4, SAM_HomeDirectoryDriveField,
        offsetof(USER_INFO_4, usri4_home_dir_drive) },

    { UT_STRING, 1053, SAM_HomeDirectoryDriveField,
        offsetof(USER_INFO_1053, usri1053_home_dir_drive) },


    { UT_BOOLEAN, 3, SAM_PasswordExpiredField,
        offsetof(USER_INFO_3, usri3_password_expired) },

    { UT_BOOLEAN, 4, SAM_PasswordExpiredField,
        offsetof(USER_INFO_4, usri4_password_expired) },

};


NET_API_STATUS
UserpSetInfo(
    IN SAM_HANDLE DomainHandle,
    IN PSID DomainId,
    IN SAM_HANDLE UserHandle OPTIONAL,
    IN SAM_HANDLE BuiltinDomainHandle OPTIONAL,
    IN ULONG UserRelativeId,
    IN LPCWSTR UserName,
    IN DWORD Level,
    IN LPBYTE Buffer,
    IN ULONG WhichFieldsMask,
    OUT LPDWORD ParmError OPTIONAL // Name required by NetpSetParmError
    )

/*++

Routine Description:

    Set the parameters on a user account in the user accounts database.

Arguments:

    DomainHandle - Domain Handle for the domain.

    PSID DomainId - Domain Sid for DomainHandle

    UserHandle - User Handle of the already open group.  If one is not
        specified, one will be openned then closed.  If one is specified,
        it must be open with adequate access.

    BuiltinDomainHandle - Domain Handle for the builtin domain.  Need only be
        specified for info level 1, 2, 3, 22, 1005 and 1010.  Need not
        be specified when a user is created.

    UserRelativeId - Relative Id of the user.

    UserName - Name of the user to set.

    Level - Level of information provided.

    Buffer - A pointer to the buffer containing the user information
        structure.

    ParmError - Optional pointer to a DWORD to return the index of the
        first parameter in error when ERROR_INVALID_PARAMETER is returned.
        If NULL, the parameter is not returned on error.

Return Value:

    Error code for the operation.

    NOTE: LogonServer field that is passed in UAS set structure is never
            used or validated. It is simply ignored.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    SAM_HANDLE LocalUserHandle = NULL;
    ACCESS_MASK DesiredAccess;
    DWORD UasSamIndex;


    USER_ALL_INFORMATION UserAll;

    //
    // Value of Fields from UAS structure (used for validation)
    //

    DWORD UasUserFlags;
    DWORD NewPriv;
    DWORD NewAuthFlags;

    BOOL ValidatePriv = FALSE;
    BOOL ValidateAuthFlags = FALSE;

    USHORT UasUnitsPerWeek;


    //
    // Variables for changing the DACL on the user.
    //

    PACL OldUserDacl = NULL;
    PACL NewUserDacl = NULL;

    BOOL UserDaclChanged = FALSE;
    BOOL HandleUserDacl = FALSE;
    USHORT AceIndex;
    PSID UserSid = NULL;


    //
    // Define several macros for accessing the various fields of the UAS
    // structure.  Each macro takes an index into the UserpUasSamTable
    // array and returns the value.
    //

#define GET_UAS_STRING_POINTER( _i ) \
        (*((LPWSTR *)(Buffer + UserpUasSamTable[_i].UasOffset)))

#define GET_UAS_DWORD( _i ) \
        (*((DWORD *)(Buffer + UserpUasSamTable[_i].UasOffset)))

#define GET_UAS_FIELD_ADDRESS( _i ) \
        (Buffer + UserpUasSamTable[_i].UasOffset)


    //
    // Define a macro which returns a pointer the appropriate
    // SamFieldDescription structure given an index into the UserpUasSamTable.
    //

#define SAM_FIELD( _i ) \
        SamFieldDescription[ UserpUasSamTable[_i].SamField ]


    //
    // Initialize
    //

    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "UserpSetInfo: entered \n" ));
    }

    NetpSetParmError( PARM_ERROR_NONE );
    RtlZeroMemory( &UserAll, sizeof(UserAll) );


    //
    // Go through the list of valid info levels determining if the info level
    // is valid and computing the desired access to the user and copying the
    // UAS information into the SAM structure.
    //

    DesiredAccess = 0;
    for ( UasSamIndex=0 ;
        UasSamIndex<sizeof(UserpUasSamTable)/sizeof(UserpUasSamTable[0]);
        UasSamIndex++ ){

        LPBYTE SamField;


        //
        // If this field isn't one we're changing, just skip to the next one
        //

        if ( Level != UserpUasSamTable[UasSamIndex].UasLevel ) {
            continue;
        }


        //
        // Set up a pointer to the appropriate field in SAM's structure.
        //

        if ( SAM_FIELD(UasSamIndex).WhichField != 0 ) {
            SamField = ((LPBYTE)(&UserAll)) + SAM_FIELD(UasSamIndex).SamOffset;
        } else {
            SamField = NULL;
        }


        //
        // Validate the UAS field based on the field type.
        //

        switch ( UserpUasSamTable[UasSamIndex].FieldType ) {

        //
        // Default the fullname of the account to be the user name when
        // the user is created using level 1.
        //
        // Ignore this entry if not a "create" operation.
        //
        case UT_CREATE_FULLNAME:

            if ( UserHandle == NULL ) {
                continue;
            }

            /* DROP THROUGH to the UT_STRING case */

        //
        // If this is a PARMNUM_ALL and the caller passed in a
        // NULL pointer to a string, he doesn't want to change the string.
        //

        case UT_STRING:

            if ( GET_UAS_STRING_POINTER( UasSamIndex ) == NULL ) {
                continue;
            }

            RtlInitUnicodeString(
                        (PUNICODE_STRING) SamField,
                        GET_UAS_STRING_POINTER(UasSamIndex) );

            break;


        //
        // Just save the UnitsPerWeek until UT_LOGON_HOURS can handle
        // both fields at once.
        //
        // Sam gets confused if we pass in one field without the other.
        //

        case UT_UNITS_PER_WEEK:

            UasUnitsPerWeek = (USHORT) GET_UAS_DWORD(UasSamIndex);

            //
            // If this is a create at info level 2 (e.g., dowlevel client),
            //  assume the caller specified UNITS_PER_WEEK.
            //
            // We don't special case SetInfo at level 2 because we don't
            //  want to corrupt the value assuming he did a query followed
            //  by a set.
            //

            if ( Level == 2 && UserHandle != NULL ) {
                UasUnitsPerWeek = UNITS_PER_WEEK;
            }

            if ( UasUnitsPerWeek > USHRT_MAX ) {
                NetpSetParmError( SAM_FIELD(UasSamIndex).UasParmNum );
                NetStatus = ERROR_INVALID_PARAMETER;
                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint((
                        "UserpSetInfo: Ushort too big Index:%ld Value:%ld\n",
                        UasSamIndex,
                        UasUnitsPerWeek ));
                }
                goto Cleanup;
            }

            //
            // Ignore this field completely for now.
            //  Let UT_LOGON_HOURS define the desired access and Whichfields.
            continue;

        //
        // If the caller passed in a NULL pointer to the logon hours
        //  he doesn't want to change the logon hours.
        //

        case UT_LOGON_HOURS:

            if ( GET_UAS_STRING_POINTER( UasSamIndex ) == NULL ) {
                continue;
            }

            *((PUCHAR *)SamField) = (PUCHAR)GET_UAS_STRING_POINTER(UasSamIndex);
            UserAll.LogonHours.UnitsPerWeek = UasUnitsPerWeek;
            break;


        //
        // If the user is setting max storage, require him to set
        //  it to USER_MAXSTORAGE_UNLIMITED since SAM doesn't support
        //  max storage.
        //

        case UT_MAX_STORAGE:
            if ( GET_UAS_DWORD(UasSamIndex) != USER_MAXSTORAGE_UNLIMITED ) {

                NetpSetParmError( USER_MAX_STORAGE_PARMNUM );
                NetStatus = ERROR_INVALID_PARAMETER;
                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint(( "UserpSetInfo: Max storage is invalid\n" ));
                }
                goto Cleanup;
            }

            // 'break' to make sure the user exists.
            break;


        //
        // Handle Account control
        //
        // Ensure all the required bits are on and only valid bits
        //  are on.
        //

        case UT_ACCOUNT_CONTROL: {

            UasUserFlags = GET_UAS_DWORD(UasSamIndex);

            if ((UasUserFlags & ~UF_SETTABLE_BITS) != 0 ) {

                NetpSetParmError( USER_FLAGS_PARMNUM );
                NetStatus = ERROR_INVALID_PARAMETER;
                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint((
                        "UserpSetInfo: Invalid account control bits (1) \n" ));
                }
                goto Cleanup;
            }

            //
            // If none of the account type bit is set in the usri_flag,
            // means that the caller does not want to change its account type.
            // break out now, and we will set the appropriate account
            // bit when we set the usri_flag.
            //

            if ( UasUserFlags & UF_ACCOUNT_TYPE_MASK ) {

                //
                // Account Types bits are exclusive, so make sure that
                // precisely one Account Type bit is set.
                //

                if ( !JUST_ONE_BIT( UasUserFlags & UF_ACCOUNT_TYPE_MASK )) {

                    NetpSetParmError( USER_FLAGS_PARMNUM );
                    NetStatus = ERROR_INVALID_PARAMETER;
                    IF_DEBUG( UAS_DEBUG_USER ) {
                        NetpKdPrint((
                            "UserpSetInfo: Invalid account control bits (2) \n" ));
                    }
                    goto Cleanup;
                }

            }


            //
            // If this is a 'create' operation,
            //  and the user has asked for the SAM defaults.
            //  we have no reason to change the DACL
            //

            if ( UserHandle != NULL &&
                 (UasUserFlags & UF_PASSWD_CANT_CHANGE) == 0 ) {
                break;
            }

            //
            // In all other cases, update the DACL to match the callers request.
            //

            HandleUserDacl = TRUE;
            break;

        }

        //
        // Copy a boolean to the SAM structure.
        //

        case UT_BOOLEAN:

            *((PBOOLEAN)SamField) = (BOOLEAN)
                (GET_UAS_DWORD(UasSamIndex)) ? TRUE : FALSE;
            break;


        //
        // Ensure unsigned shorts are really in range and
        //  copy it to the SAM structure.
        //

        case UT_USHORT:

            if ( GET_UAS_DWORD(UasSamIndex) > USHRT_MAX ) {
                NetpSetParmError( SAM_FIELD(UasSamIndex).UasParmNum );
                NetStatus = ERROR_INVALID_PARAMETER;
                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint((
                        "UserpSetInfo: Ushort too big Index:%ld Value:%ld\n",
                        UasSamIndex,
                        GET_UAS_DWORD(UasSamIndex) ));
                }
                goto Cleanup;
            }

            *((PUSHORT)SamField) = (USHORT) GET_UAS_DWORD(UasSamIndex);
            break;

        //
        // Copy the unsigned long to the SAM structure
        //

        case UT_ULONG:

            *((PULONG)SamField) = (ULONG)GET_UAS_DWORD(UasSamIndex);
            break;

        //
        // Convert time to its SAM counterpart
        //

        case UT_TIME:

            //
            // PREFIX:  SamField can only be NULL due to a programming error
            // by setting the UserpUasSamTable table incorrectly. This
            // assert catches the problem.
            //
            NetpAssert(NULL != SamField);
            if ( GET_UAS_DWORD(UasSamIndex) == TIMEQ_FOREVER ) {

                ((PLARGE_INTEGER) SamField)->LowPart = 0;
                ((PLARGE_INTEGER) SamField)->HighPart = 0;

            } else {
                RtlSecondsSince1970ToTime(
                    GET_UAS_DWORD(UasSamIndex),
                    (PLARGE_INTEGER) SamField );
            }

            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint(( "UserpSetInfo: Index: %ld Time %lx %lx %lx\n",
                            UasSamIndex,
                            ((PLARGE_INTEGER) SamField)->HighPart,
                            ((PLARGE_INTEGER) SamField)->LowPart,
                            GET_UAS_DWORD(UasSamIndex) ));
            }

            break;


        //
        // Copy the OWF password to the SAM structure.
        //
        case UT_OWF_PASSWORD:

            ((PUNICODE_STRING) SamField)->Buffer =
                (LPWSTR) (GET_UAS_FIELD_ADDRESS( UasSamIndex ));

            ((PUNICODE_STRING) SamField)->Length =
                    ((PUNICODE_STRING) SamField)->MaximumLength =
                        LM_OWF_PASSWORD_LENGTH;

            //
            // set that the LmPasswordField field to TRUE to indicate
            // that we filled LmPassword field.
            //

            UserAll.LmPasswordPresent = TRUE;
            UserAll.NtPasswordPresent = FALSE;


            break;


        //
        // Ensure the specified privilege is valid.
        //

        case UT_PRIV:

            NewPriv = GET_UAS_DWORD(UasSamIndex);

            if ( (NewPriv & ~USER_PRIV_MASK) != 0 ) {
                NetpSetParmError( SAM_FIELD(UasSamIndex).UasParmNum );
                NetStatus = ERROR_INVALID_PARAMETER;
                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint(( "UserpSetInfo: Invalid priv %ld\n", NewPriv ));
                }
                goto Cleanup;
            }
            ValidatePriv = TRUE;
            break;


        //
        // Ensure the specified operator flags is valid.
        //

        case UT_AUTH_FLAGS:

            NewAuthFlags = GET_UAS_DWORD(UasSamIndex);
            if ( (NewAuthFlags & ~AF_SETTABLE_BITS) != 0 ) {
                NetpSetParmError( SAM_FIELD(UasSamIndex).UasParmNum );
                NetStatus = ERROR_INVALID_PARAMETER;
                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint(( "UserpSetInfo: Invalid auth_flag %lx\n",
                                  NewAuthFlags ));
                }
                goto Cleanup;
            }
            ValidateAuthFlags = TRUE;
            break;

        //
        // All valid cases were explicitly checked above.
        //

        default:
            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint((
                    "UserpSetInfo: Invalid field type on initial scan."
                    " Index:%ld\n", UasSamIndex ));
            }

            NetStatus = NERR_InternalError;
            goto Cleanup;
        }

        //
        //
        // Accumulate the desired access to do all this functionality.

        DesiredAccess |= SAM_FIELD(UasSamIndex).DesiredAccess;

        //
        // Accumalate which fields are being changed in the
        //  USER_ALL_INFORMATION structure.

        UserAll.WhichFields |= SAM_FIELD(UasSamIndex).WhichField;

    }

    //
    // Check to be sure the user specified a valid Level.
    //
    // The search of the UserpUasSamTable should have resulted in
    // at least one match if the arguments are valid.
    //

    if ( DesiredAccess == 0 ) {
        NetpSetParmError( PARM_ERROR_UNKNOWN );
        NetStatus = ERROR_INVALID_PARAMETER;
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "UserpSetInfo: Desired Access == 0\n" ));
        }
        goto Cleanup;
    }

    //
    // Open the user asking for accumulated desired access
    //
    // If a UserHandle was passed in, use it.
    //

    if ( ARGUMENT_PRESENT( UserHandle ) ) {
        LocalUserHandle = UserHandle;
    } else {

        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint(( "UserpSetInfo: Desired Access %lX\n", DesiredAccess ));
        }

        NetStatus = UserpOpenUser( DomainHandle,
                                   DesiredAccess,
                                   UserName,
                                   &LocalUserHandle,
                                   &UserRelativeId );

        if ( NetStatus != NERR_Success ) {
            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint(( "UserpSetInfo: UserpOpenUser returns %ld\n",
                    NetStatus ));
            }
            goto Cleanup;
        }

    }

    //
    // If an ordinary user created this user (SamCreateUser2InDomain),
    // we must mask off the fields which a user cannot set.
    //
    UserAll.WhichFields &= WhichFieldsMask;


    //
    // Handle Account control
    //
    // Set the individual bits.  Notice that I don't change any of
    //  the bits which aren't defined by the UAS API.
    //

    if ( UserAll.WhichFields & USER_ALL_USERACCOUNTCONTROL ) {

        USER_CONTROL_INFORMATION *UserControl = NULL;

        //
        // Use the current value of UserAccountControl as the proposed
        //  new value of UserAccountControl.
        //

        Status = SamQueryInformationUser( LocalUserHandle,
                                          UserControlInformation,
                                          (PVOID *)&UserControl);

        if ( ! NT_SUCCESS( Status ) ) {
            IF_DEBUG( UAS_DEBUG_USER ) {
                NetpKdPrint((
                    "UserpGetInfo: SamQueryInformationUser returns %lX\n",
                    Status ));
            }
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        UserAll.UserAccountControl = UserControl->UserAccountControl;

        Status = SamFreeMemory( UserControl );
        NetpAssert( NT_SUCCESS(Status) );

        //
        // Leave all bits not defined by the UAS API alone,
        // including account type bits.
        //

        UserAll.UserAccountControl &= ~(USER_ACCOUNT_DISABLED |
                        USER_HOME_DIRECTORY_REQUIRED |
                        USER_PASSWORD_NOT_REQUIRED |
                        USER_DONT_EXPIRE_PASSWORD |
                        USER_ACCOUNT_AUTO_LOCKED |
                        USER_MNS_LOGON_ACCOUNT   |
                        USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED |
                        USER_SMARTCARD_REQUIRED |
                        USER_TRUSTED_FOR_DELEGATION |
                        USER_NOT_DELEGATED |
                        USER_USE_DES_KEY_ONLY |
                        USER_DONT_REQUIRE_PREAUTH |
                        USER_PASSWORD_EXPIRED
                        );

        if (UasUserFlags & UF_ACCOUNTDISABLE) {
            UserAll.UserAccountControl |= USER_ACCOUNT_DISABLED;
        }

        if (UasUserFlags & UF_HOMEDIR_REQUIRED) {
            UserAll.UserAccountControl |= USER_HOME_DIRECTORY_REQUIRED;
        }

        if (UasUserFlags & UF_PASSWD_NOTREQD) {
            UserAll.UserAccountControl |= USER_PASSWORD_NOT_REQUIRED;
        }

        if (UasUserFlags & UF_DONT_EXPIRE_PASSWD) {
            UserAll.UserAccountControl |= USER_DONT_EXPIRE_PASSWORD;
        }

        if (UasUserFlags & UF_LOCKOUT) {
            UserAll.UserAccountControl |= USER_ACCOUNT_AUTO_LOCKED;
        }

        if (UasUserFlags & UF_MNS_LOGON_ACCOUNT) {
            UserAll.UserAccountControl |= USER_MNS_LOGON_ACCOUNT;
        }

        if (UasUserFlags & UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED) {
           (UserAll.UserAccountControl) |= USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED;
        }

        if (UasUserFlags & UF_SMARTCARD_REQUIRED) {
           (UserAll.UserAccountControl) |= USER_SMARTCARD_REQUIRED;
        }

        if (UasUserFlags & UF_TRUSTED_FOR_DELEGATION) {
           (UserAll.UserAccountControl) |= USER_TRUSTED_FOR_DELEGATION;
        }

        if (UasUserFlags & UF_NOT_DELEGATED) {
           (UserAll.UserAccountControl) |= USER_NOT_DELEGATED;
        }

        if (UasUserFlags & UF_USE_DES_KEY_ONLY) {
           (UserAll.UserAccountControl) |= USER_USE_DES_KEY_ONLY;
        }

        if (UasUserFlags & UF_DONT_REQUIRE_PREAUTH) {
           (UserAll.UserAccountControl) |= USER_DONT_REQUIRE_PREAUTH;
        }

        if (UasUserFlags & UF_PASSWORD_EXPIRED) {
           (UserAll.UserAccountControl) |= USER_PASSWORD_EXPIRED;
        }

        if (UasUserFlags & UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION) {
           (UserAll.UserAccountControl) |= USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION;
        }


        //
        // Set the account type bit.
        //
        // If no account type bit is set in user specified flag,
        //  then leave this bit as it is.
        //

        if( UasUserFlags & UF_ACCOUNT_TYPE_MASK ) {
            ULONG NewSamAccountType;
            ULONG OldSamAccountType;

            OldSamAccountType =
                (UserAll.UserAccountControl) & USER_ACCOUNT_TYPE_MASK;


            //
            // Determine what the new account type should be.
            //

            if ( UasUserFlags & UF_TEMP_DUPLICATE_ACCOUNT ) {
                NewSamAccountType = USER_TEMP_DUPLICATE_ACCOUNT;

            } else if ( UasUserFlags & UF_NORMAL_ACCOUNT ) {
                NewSamAccountType = USER_NORMAL_ACCOUNT;

            } else if (UasUserFlags & UF_INTERDOMAIN_TRUST_ACCOUNT){
                NewSamAccountType = USER_INTERDOMAIN_TRUST_ACCOUNT;

            } else if (UasUserFlags & UF_WORKSTATION_TRUST_ACCOUNT){
                NewSamAccountType = USER_WORKSTATION_TRUST_ACCOUNT;

            } else if ( UasUserFlags & UF_SERVER_TRUST_ACCOUNT ) {
                NewSamAccountType = USER_SERVER_TRUST_ACCOUNT;

            } else {

                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint((
                        "UserpSetInfo: Invalid account type (3)\n"));
                }

                NetStatus = NERR_InternalError;
                goto Cleanup;
            }

#ifdef notdef
            //
            // If we are not creating this user,
            //  and either the old or the new account type is a machine account,
            //  don't allow the account type to change.
            //
            // Allow changes between 'normal' and 'temp_duplicate'
            //
            if ( UserHandle == NULL &&
                 NewSamAccountType != OldSamAccountType &&
                 ((OldSamAccountType & USER_MACHINE_ACCOUNT_MASK) ||
                 (NewSamAccountType & USER_MACHINE_ACCOUNT_MASK))) {

                NetpSetParmError( USER_FLAGS_PARMNUM );
                NetStatus = ERROR_INVALID_PARAMETER;
                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint((
                        "UserpSetInfo: Attempt to change account "
                        " type Old: %lx New: %lx\n",
                        OldSamAccountType,
                        NewSamAccountType ));
                }
                goto Cleanup;
            }
#endif // notdef

            //
            // Use the new Account Type.
            //

            UserAll.UserAccountControl &= ~USER_ACCOUNT_TYPE_MASK;
            UserAll.UserAccountControl |= NewSamAccountType;

        //
        //  If SAM has none of its bits set,
        //      set USER_NORMAL_ACCOUNT.
        //
        } else if ((UserAll.UserAccountControl & USER_ACCOUNT_TYPE_MASK) == 0 ){
            UserAll.UserAccountControl |= USER_NORMAL_ACCOUNT;
        }

    }

    //
    // Validate the usriX_priv and usrix_auth_flags fields
    //

    if ( ValidatePriv || ValidateAuthFlags ) {

        DWORD OldPriv, OldAuthFlags;


        //
        // If this is a 'create' operation, just mandate that
        //  the values be reasonable.  These reasonable values
        //  are what UserpGetUserPriv probably would return, unless
        //  of course someone puts the 'user' group in one of the
        //  aliases.
        //

        if ( UserHandle != NULL ) {
            OldPriv = USER_PRIV_USER;
            OldAuthFlags = 0;

        //
        // On a 'set' operation, just get the previous values.
        //

        } else {

            NetStatus = UserpGetUserPriv(
                            BuiltinDomainHandle,
                            LocalUserHandle,
                            UserRelativeId,
                            DomainId,
                            &OldPriv,
                            &OldAuthFlags
                            );

            if ( NetStatus != NERR_Success ) {
                goto Cleanup;
            }
        }


        //
        // Ensure AUTH_FLAGS isn't being changed.
        //

        if ( ValidateAuthFlags ) {
            if ( NewAuthFlags != OldAuthFlags ) {
                NetpSetParmError( USER_AUTH_FLAGS_PARMNUM );
                NetStatus = ERROR_INVALID_PARAMETER;
                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint((
                        "UserpSetInfo: Old AuthFlag %ld New AuthFlag %ld\n",
                        OldAuthFlags,
                        NewAuthFlags ));
                }
                goto Cleanup;
            }
        }


        //
        // Ensure PRIV isn't being changed.
        //

        if ( ValidatePriv ) {
            if ( NewPriv != OldPriv ) {
                NetpSetParmError( USER_PRIV_PARMNUM );
                NetStatus = ERROR_INVALID_PARAMETER;
                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint((
                        "UserpSetInfo: Old Priv %ld New Priv %ld\n",
                        OldPriv,
                        NewPriv ));
                }
                goto Cleanup;
            }
        }

    }



    //
    // Handle changes to the User Dacl
    //

    if ( HandleUserDacl ) {
        DWORD DaclSize;
        PACCESS_ALLOWED_ACE Ace;
        SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

        //
        // Build the sid for the user
        //

        NetStatus = NetpSamRidToSid(
                        LocalUserHandle,
                        UserRelativeId,
                        &UserSid
                        );

        if (NetStatus != NERR_Success) {
            goto Cleanup;
        }


        //
        // Get the DACL for the user record.
        //

        NetStatus = UserpGetDacl( LocalUserHandle,
                                  &OldUserDacl,
                                  &DaclSize );

        if ( NetStatus != NERR_Success ) {
            goto Cleanup;
        }

        //
        // If there is no DACL, just ignore that fact.
        //

        if ( OldUserDacl != NULL ) {
            SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
            DWORD WorldSid[sizeof(SID)/sizeof(DWORD) + SID_MAX_SUB_AUTHORITIES ];

            //
            // Build a copy of the world SID for later comparison.
            //

            RtlInitializeSid( (PSID) WorldSid, &WorldSidAuthority, 1 );
            *(RtlSubAuthoritySid( (PSID)WorldSid,  0 )) = SECURITY_WORLD_RID;


            //
            //  Make a copy of the DACL that reflect the new UAS field.
            //
            NewUserDacl = NetpMemoryAllocate( DaclSize );

            if ( NewUserDacl == NULL ) {
                IF_DEBUG( UAS_DEBUG_USER ) {
                    NetpKdPrint(( "UserpSetInfo: no DACL memory %ld\n",
                        DaclSize ));
                }
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            NetpMoveMemory( NewUserDacl, OldUserDacl, DaclSize );

            //
            // The UF_PASSWD_CANT_CHANGE bit is implemented by the
            // ACL on the user object in SAM.  When
            // UF_PASSWD_CANT_CHANGE is on, the ACL doesn't allow
            // World or the user himself USER_CHANGE_PASSWORD access.
            // We set/clear the USER_CHANGE_PASSWORD access
            // bit in the ACEs for the user and for World. This leaves
            // Administrators and Account Operators with
            // USER_ALL_ACCESS access.
            //
            // If the DACL for the user has been set by anyone
            // other than the NetUser APIs, this action may
            // not accurately reflect whether the password can
            // be changed.  We silently ignore ACLs we don't
            // recognize.
            //


            //
            // Point Ace to the first ACE.
            //

            for (   AceIndex = 0;
                    AceIndex < NewUserDacl->AceCount;
                    AceIndex++ ) {

                Status = RtlGetAce(
                            NewUserDacl,
                            AceIndex,
                            (PVOID) &Ace
                            );
                if ( !NT_SUCCESS(Status) ) {
                    break;
                }

                //
                // If the sid in the ACE matches either the world SID
                // or the User's SID, modify the access mask.
                //

                if ( RtlEqualSid(
                        &Ace->SidStart,
                        (PSID)WorldSid) ||
                     RtlEqualSid(
                        &Ace->SidStart,
                        UserSid) ) {

                    //
                    // Twiddle the USER_CHANGE_PASSWORD access bit.
                    //

                    if ( Ace->Mask & USER_CHANGE_PASSWORD ) {
                        if ( UasUserFlags & UF_PASSWD_CANT_CHANGE ) {
                            Ace->Mask &= ~USER_CHANGE_PASSWORD;
                            UserDaclChanged = TRUE;
                        }
                    } else {
                        if ( (UasUserFlags & UF_PASSWD_CANT_CHANGE) == 0 ) {
                            Ace->Mask |= USER_CHANGE_PASSWORD;
                            UserDaclChanged = TRUE;
                        }
                    }

                }

            }


            //
            // Set the DACL if it needs to be.
            //

            if ( UserDaclChanged ) {

                NetStatus = UserpSetDacl( LocalUserHandle, NewUserDacl );
                if ( NetStatus != NERR_Success ) {
                    goto Cleanup;
                }

            }
        }
    }




    //
    // If there is anything changed in the 'UserAll' structure,
    //  tell SAM about the changes.
    //

    //
    // N.B.  Because some of the NET fields are not treated as SAM fields
    // (UT_PRIV and UT_MAX_STORAGE), there may be nothing to change.  However,
    // for app compat, continue to call SamSetInformationUser
    //

    Status = SamSetInformationUser(
                LocalUserHandle,
                UserAllInformation,
                &UserAll );

    if ( !NT_SUCCESS(Status) ) {
        IF_DEBUG( UAS_DEBUG_USER ) {
            NetpKdPrint((
                "UserpSetInfo: SamSetInformationUser returns %lX\n",
                Status ));
        }
        NetpSetParmError( PARM_ERROR_UNKNOWN );
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }


    NetStatus = NERR_Success;

    //
    // Clean up.
    //

Cleanup:


    //
    // If we've changed the DACL on the user and we've not been able
    //  to change everything, put the DACL back as we found it.
    //

    if ( NetStatus != NERR_Success && UserDaclChanged ) {
        NET_API_STATUS NetStatus2;

        NetStatus2 = UserpSetDacl( LocalUserHandle, OldUserDacl );
        ASSERT( NetStatus2 == NERR_Success );

    }

    //
    // If a handle to the user was opened by this routine,
    //  close it.
    //

    if (!ARGUMENT_PRESENT( UserHandle ) && LocalUserHandle != NULL) {
        (VOID) SamCloseHandle( LocalUserHandle );
    }


    //
    // Free any locally used recources.
    //

    if ( NewUserDacl != NULL ) {
        NetpMemoryFree( NewUserDacl );
    }

    if ( OldUserDacl != NULL ) {
        NetpMemoryFree( OldUserDacl );
    }

    if ( UserSid != NULL ) {
        NetpMemoryFree( UserSid );

    }

    IF_DEBUG( UAS_DEBUG_USER ) {
        NetpKdPrint(( "UserpSetInfo: returning %ld\n", NetStatus ));
    }

    return NetStatus;

} // UserpSetInfo



NET_API_STATUS
NetpSamRidToSid(
    IN SAM_HANDLE SamHandle,
    IN ULONG RelativeId,
    OUT PSID *Sid
    )
/*++

Routine Description:

    Given a Rid returned from a Sam Handle, return the SID for that account.

Arguments:

    SamHandle - a valid SAM handle
    
    RelativeId - a RID obtained from a SAM call that used SamHandle

    Sid - Returns a pointer to an allocated buffer containing the resultant
          Sid.  Free this buffer using NetpMemoryFree.

Return Value:

    0 - if successful
    
    NERR_UserNotFound if the Rid could not be mapped to a SID

    a resource error, otherwise    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSID     SamSid;
    DWORD    err = 0;

    NtStatus = SamRidToSid(SamHandle,
                           RelativeId,
                           &SamSid);

    if (NT_SUCCESS(NtStatus)) {
        ULONG Length = RtlLengthSid(SamSid);
        (*Sid) = NetpMemoryAllocate(Length);
        if ((*Sid)) {
            RtlCopySid(Length, (*Sid), SamSid);
        } else {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        SamFreeMemory(SamSid);
    } else if ( STATUS_NOT_FOUND == NtStatus ) {
        // This is unexpected -- the user RID could not be
        // found
        err = NERR_UserNotFound;
    } else {
        // a resource error occurred
        err = RtlNtStatusToDosError(NtStatus);
    }

    return err;

}

/*lint +e614 */
/*lint +e740 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\api\audstub.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    AudStub.c

Abstract:

    This module contains stubs for the NetAudit APIs.

Author:

    John Rogers (JohnRo) 29-Oct-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    29-Oct-1991 JohnRo
        Implement remote NetAudit APIs.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // DEVLEN, NET_API_STATUS, etc.

// These may be included in any order:

#include <lmaudit.h>            // NetAudit APIs.
#include <rxaudit.h>            // RxNetAudit APIs.
#include <winerror.h>           // ERROR_ equates.


NET_API_STATUS NET_API_FUNCTION
NetAuditClear (
    IN  LPCWSTR UncServerName OPTIONAL,
    IN  LPCWSTR backupfile OPTIONAL,
    IN  LPCWSTR reserved OPTIONAL
    )

{
    if ( (UncServerName == NULL) || (*UncServerName == '\0') ) {
        return (ERROR_NOT_SUPPORTED);
    }

    return (RxNetAuditClear(
            (LPWSTR)UncServerName,
            (LPWSTR)backupfile,
            (LPWSTR)reserved));

} // NetAuditClear



NET_API_STATUS NET_API_FUNCTION
NetAuditRead (
    IN  LPCWSTR  UncServerName OPTIONAL,
    IN  LPCWSTR  reserved1 OPTIONAL,
    IN  LPHLOG   auditloghandle,
    IN  DWORD    offset,
    IN  LPDWORD  reserved2 OPTIONAL,
    IN  DWORD   reserved3,
    IN  DWORD   offsetflag,
    OUT LPBYTE  *bufptr,
    IN  DWORD   prefmaxlen,
    OUT LPDWORD bytesread,
    OUT LPDWORD totalavailable
    )
{
    if ( (UncServerName == NULL) || (*UncServerName == '\0') ) {
        return (ERROR_NOT_SUPPORTED);
    }

    return (RxNetAuditRead(
            (LPWSTR)UncServerName,
            (LPWSTR)reserved1,
            auditloghandle,
            offset,
            reserved2,
            reserved3,
            offsetflag,
            bufptr,
            prefmaxlen,
            bytesread,
            totalavailable));

} // NetAuditRead


NET_API_STATUS NET_API_FUNCTION
NetAuditWrite (
    IN  DWORD   type,
    IN  LPBYTE  buf,
    IN  DWORD   numbytes,
    IN  LPCWSTR reserved1 OPTIONAL,
    IN  LPBYTE  reserved2 OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(type);
    UNREFERENCED_PARAMETER(buf);
    UNREFERENCED_PARAMETER(numbytes);
    UNREFERENCED_PARAMETER(reserved1);
    UNREFERENCED_PARAMETER(reserved2);

    return (ERROR_NOT_SUPPORTED);

} // NetAuditWrite
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\api\apisubs.c ===
/*++

Copyright (c) 1990-1992  Microsoft Corporation

Module Name:

    apisubs.c

Abstract:

    Subroutines for LAN Manager APIs.

Author:

    Chuck Lenzmeier (chuckl) 25-Jul-90

Revision History:

    08-Sept-1992    Danl
        Dll Cleanup routines used to be called for DLL_PROCESS_DETACH.
        Thus they were called for FreeLibrary or ExitProcess reasons.
        Now they are only called for the case of a FreeLibrary.  ExitProcess
        will automatically clean up process resources.

    03-Aug-1992     JohnRo
        Use FORMAT_ and PREFIX_ equates.

--*/

// These must be included first:
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define NOMINMAX                // Avoid stdlib.h vs. windows.h warnings.
#include <windows.h>
#include <lmcons.h>
#include <ntsam.h>
#include <netdebug.h>

// These may be included in any order:
#include <accessp.h>
#include <configp.h>
#include <lmerr.h>
#include <netdebug.h>
#include <netlib.h>
#include <prefix.h>     // PREFIX_ equates.
#include <secobj.h>
#include <stdarg.h>
#include <stdio.h>
#include <rpcutil.h>
#include <thread.h>
#include <stdlib.h>
#include <netbios.h>
#include <dfsp.h>
#include <winsock2.h>  // needed by dsgetdcp.h
#include <dsgetdc.h>   // needed by dsgetdcp.h
#include <dsgetdcp.h>  // DCNameInitialize/Close


BOOLEAN
NetapipInitialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN LPVOID lpReserved OPTIONAL
    )
{
    //
    // Handle attaching netapi.dll to a new process.
    //

    if (Reason == DLL_PROCESS_ATTACH) {

        NET_API_STATUS NetStatus;
        NTSTATUS Status;

        if ( !DisableThreadLibraryCalls( DllHandle ) )
        {
            NetpKdPrint((
                    PREFIX_NETAPI "DisableThreadLibraryCalls failed: "
                    FORMAT_API_STATUS "\n", GetLastError()));
        }

        //
        // Initialize Netbios
        //

        NetbiosInitialize(DllHandle);

        //
        // Initialize the NetGetDCName PDC Name cache
        //

        if (( NetStatus = DCNameInitialize()) != NERR_Success) {
            NetpKdPrint(( "[netapi.dll] Failed initialize DCName APIs%lu\n",
                          NetStatus));
            return FALSE;
        }

        //
        // Initialize the NetDfsXXX API Critical Section
        //
        InitializeCriticalSection( &NetDfsApiCriticalSection );
        NetDfsApiInitialize();

    //
    // When DLL_PROCESS_DETACH and lpReserved is NULL, then a FreeLibrary
    // call is being made.  If lpReserved is Non-NULL, and ExitProcess is
    // in progress.  These cleanup routines will only be called when
    // a FreeLibrary is being called.  ExitProcess will automatically
    // clean up all process resources, handles, and pending io.
    //
    } else if ((Reason == DLL_PROCESS_DETACH) &&
               (lpReserved == NULL)) {

        NetbiosDelete();

        DCNameClose();

        //
        // Delete the NetDfsXXX API critical section
        //
        DeleteCriticalSection( &NetDfsApiCriticalSection );
    }

    return TRUE;

} // NetapipInitialize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\api\canonapi.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    canonapi.c

Abstract:

    This file contains the remotable API wrappers for the canonicalization
    functions. Now that remotable canonicalization has been moved into the
    server service, these canonicalization routines (in NETAPI.DLL) simply
    decide whether a function should be remoted or runs the local routine

    The canonicalization functions have been split into these wrappers, the
    local versions and the remote RPC routines to avoid the cylical dependency
    of SRVSVC.DLL/.LIB and NETAPI.DLL/.LIB

    Contents:
        NetpListCanonicalize
        NetpListTraverse
        NetpNameCanonicalize
        NetpNameCompare
        NetpNameValidate
        NetpPathCanonicalize
        NetpPathCompare
        NetpPathType

Author:

    Richard L Firth (rfirth) 15-May-1992

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lmcons.h>
#include <lmerr.h>
#include <tstring.h>
#include <icanon.h>
#include <netcan.h>


NET_API_STATUS
NET_API_FUNCTION
NetpListCanonicalize(
    IN  LPTSTR  ServerName OPTIONAL,
    IN  LPTSTR  List,
    IN  LPTSTR  Delimiters OPTIONAL,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    OUT LPDWORD OutCount,
    OUT LPDWORD PathTypes,
    IN  DWORD   PathTypesLen,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Converts a list to its canonical form. If ServerName is non-NULL then the
    RPC function is called (in SRVSVC.DLL) else the local worker function (in
    NETLIB.LIB)

Arguments:

    ServerName      - where to remote this function. May be NULL
    List            - input list to canonicalize
    Delimiters      - optional list of delimiter characters. May be NULL
    Outbuf          - place to write output
    OutbufLen       - length of Outbuf
    OutCount        - returned number of items in Outbuf
    PathTypes       - returned list of types of entries in Outbuf
    PathTypesLen    - size of PathTypes array
    Flags           - control flags

Return Value:

    NET_API_STATUS

--*/

{
    NET_API_STATUS status = 0;
    DWORD location;
    TCHAR serverName[MAX_PATH];
    DWORD val;
    BOOL nullDelimiter = FALSE;
    TCHAR ch;

    //
    // validate parameters
    //

    try {
        if (ARGUMENT_PRESENT(ServerName)) {
            val = STRLEN(ServerName);
        }
        if (ARGUMENT_PRESENT(Delimiters)) {
            val = STRLEN(Delimiters);
            nullDelimiter = (val == 0);
        } else {
            nullDelimiter = TRUE;
        }
        val = STRLEN(List);

        //
        // if Delimiters is a NULL pointer or NUL string, then List is a
        // NULL-NULL input list
        //

        if (nullDelimiter) {
            LPTSTR str = List + val + 1;

            do {
                val = STRLEN(str);
                str += val + 1;
            } while ( val );
        }
        ch = *((TCHAR volatile *)Outbuf);
        *Outbuf = ch;
        ch = *((TCHAR volatile *)(Outbuf + OutbufLen/sizeof(*Outbuf) - sizeof(*Outbuf)));
        *(Outbuf + OutbufLen/sizeof(*Outbuf) - sizeof(*Outbuf)) = ch;
        *OutCount = 0;
        if (ARGUMENT_PRESENT(PathTypes)) {
            PathTypes[0] = 0;
            PathTypes[PathTypesLen - 1] = 0;
        } else if ((Flags & INLC_FLAGS_MASK_NAMETYPE) == NAMETYPE_PATH) {

            //
            // NAMETYPE_PATH and NULL PathTypes is illegal
            //

            status = ERROR_INVALID_PARAMETER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = ERROR_INVALID_PARAMETER;
    }
    if (status) {
        return status;
    }
    if (Flags & INLC_FLAGS_MASK_RESERVED) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // call client-side RPC routine or local canonicalization routine
    //

    status = NetpIsRemote(ServerName, &location, serverName, 0);
    if (status != NERR_Success) {
        return status;
    }

    //
    // due to historic precedent, we don't remote this function
    //

    if (location == ISREMOTE) {
        return ERROR_NOT_SUPPORTED;
    } else {
        return NetpwListCanonicalize(List,
                                        Delimiters,
                                        Outbuf,
                                        OutbufLen,
                                        OutCount,
                                        PathTypes,
                                        PathTypesLen,
                                        Flags
                                        );
    }
}


LPTSTR
NET_API_FUNCTION
NetpListTraverse(
    IN  LPTSTR  Reserved OPTIONAL,
    IN  LPTSTR* pList,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    This just calls the local traverse function

Arguments:

    Reserved    - MBZ
    pList       - pointer to list to traverse
    Flags       - MBZ

Return Value:

    LPTSTR

--*/

{
    return NetpwListTraverse(Reserved, pList, Flags);
}


NET_API_STATUS
NET_API_FUNCTION
NetpNameCanonicalize(
    IN  LPTSTR  ServerName OPTIONAL,
    IN  LPTSTR  Name,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Canonicalizes a name

Arguments:

    ServerName  - where to run this API
    Name        - name to canonicalize
    Outbuf      - where to put canonicalized name
    OutbufLen   - length of Outbuf
    NameType    - type of name to canonicalize
    Flags       - control flags

Return Value:

    NET_API_STATUS

--*/

{
    NET_API_STATUS status = 0;
    DWORD location;
    TCHAR serverName[MAX_PATH];
    DWORD val;
    TCHAR ch;

    //
    // validate parameters
    //

    try {
        if (ARGUMENT_PRESENT(ServerName)) {
            val = STRLEN(ServerName);
        }
        if (ARGUMENT_PRESENT(Name)) {
            val = STRLEN(Name);
        }
        if (ARGUMENT_PRESENT(Outbuf)) {
            ch = *((TCHAR volatile *)Outbuf);
            *Outbuf = ch;
            ch = *((TCHAR volatile *)(Outbuf + OutbufLen/sizeof(*Outbuf) - sizeof(*Outbuf)));
            *(Outbuf + OutbufLen/sizeof(*Outbuf) - sizeof(*Outbuf)) = ch;
        } else {
            status = ERROR_INVALID_PARAMETER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = ERROR_INVALID_PARAMETER;
    }
    if (status) {
        return status;
    }
    if (Flags & INNCA_FLAGS_RESERVED) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // call client-side RPC routine or local canonicalization routine
    //

    status = NetpIsRemote(ServerName, &location, serverName, 0);
    if (status != NERR_Success) {
        return status;
    }
    if (location == ISREMOTE) {
        return NetpsNameCanonicalize(serverName,
                                        Name,
                                        Outbuf,
                                        OutbufLen,
                                        NameType,
                                        Flags
                                        );
    } else {
        return NetpwNameCanonicalize(Name, Outbuf, OutbufLen, NameType, Flags);
    }
}


LONG
NET_API_FUNCTION
NetpNameCompare(
    IN  LPTSTR  ServerName OPTIONAL,
    IN  LPTSTR  Name1,
    IN  LPTSTR  Name2,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Compares two names. Must be of same type

Arguments:

    ServerName  - where to run this API
    Name1       - 1st name to compare
    Name2       - 2nd
    NameType    - type of names
    Flags       - control flags

Return Value:

    LONG

--*/

{
    NET_API_STATUS status = 0;
    DWORD location;
    TCHAR serverName[MAX_PATH];
    DWORD val;

    //
    // validate parameters
    //

    try {
        if (ARGUMENT_PRESENT(ServerName)) {
            val = STRLEN(ServerName);
        }
        val = STRLEN(Name1);
        val = STRLEN(Name2);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = ERROR_INVALID_PARAMETER;
    }
    if (status) {
        return ERROR_INVALID_PARAMETER;
    }
    if (Flags & INNC_FLAGS_RESERVED) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // call client-side RPC routine or local canonicalization routine
    //

    status = NetpIsRemote(ServerName, &location, serverName, 0);
    if (status != NERR_Success) {
        return status;
    }
    if (location == ISREMOTE) {
        return NetpsNameCompare(serverName, Name1, Name2, NameType, Flags);
    } else {
        return NetpwNameCompare(Name1, Name2, NameType, Flags);
    }
}


NET_API_STATUS
NET_API_FUNCTION
NetpNameValidate(
    IN  LPTSTR  ServerName OPTIONAL,
    IN  LPTSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Validates a name - checks whether a name of a certain type conforms to
    canonicalization rules for that name type. Canonicalization rules mean
    character set, name syntax and length

Arguments:

    ServerName  - where to perform this function
    Name        - name to validate
    NameType    - what type of name it is
    Flags       - MBZ

Return Value:

    NET_API_STATUS

--*/

{
    NET_API_STATUS status = 0;
    DWORD location;
    TCHAR serverName[MAX_PATH];
    DWORD val;

    //
    // validate parameters
    //

    try {
        if (ARGUMENT_PRESENT(ServerName)) {
            val = STRLEN(ServerName);
        }
        if (ARGUMENT_PRESENT(Name)) {
            val = STRLEN(Name);
        } else {
            status = ERROR_INVALID_PARAMETER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = ERROR_INVALID_PARAMETER;
    }
    if (status) {
        return status;
    }
    if (Flags & INNV_FLAGS_RESERVED) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // call client-side RPC routine or local canonicalization routine
    //

    status = NetpIsRemote(ServerName, &location, serverName, 0);
    if (status != NERR_Success) {
        return status;
    }
    if (location == ISREMOTE) {
        return NetpsNameValidate(serverName, Name, NameType, Flags);
    } else {
        return NetpwNameValidate(Name, NameType, Flags);
    }
}


NET_API_STATUS
NET_API_FUNCTION
NetpPathCanonicalize(
    IN  LPTSTR  ServerName OPTIONAL,
    IN  LPTSTR  PathName,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  LPTSTR  Prefix OPTIONAL,
    IN OUT LPDWORD PathType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Canonicalizes a directory path or a device name

Arguments:

    ServerName  - where to run this API
    PathName    - path to canonicalize
    Outbuf      - where to write the canonicalized version
    OutbufLen   - length of Outbuf in bytes
    Prefix      - optional prefix which will be prepended to Path
    PathType    - the type of path to canonicalize. May be different at output
    Flags       - control flags

Return Value:

    NET_API_STATUS

--*/

{
    NET_API_STATUS status = 0;
    DWORD location;
    TCHAR serverName[MAX_PATH];
    DWORD val;
    TCHAR ch;

    //
    // validate parameters
    //

    try {
        if (ARGUMENT_PRESENT(ServerName)) {
            val = STRLEN(ServerName);
        }
        if (ARGUMENT_PRESENT(PathName)) {
            val = STRLEN(PathName);
        }
        if (ARGUMENT_PRESENT(Prefix)) {
            val = STRLEN(Prefix);
        }
        if (ARGUMENT_PRESENT(Outbuf)) {
            ch = *((TCHAR volatile *)Outbuf);
            *Outbuf = ch;
            ch = *((TCHAR volatile *)(Outbuf+OutbufLen/sizeof(*Outbuf) - sizeof(*Outbuf)));
            *(Outbuf+OutbufLen/sizeof(*Outbuf) - sizeof(*Outbuf)) = ch;
        } else {
            status = ERROR_INVALID_PARAMETER;
        }
        val = *PathType ^ 0xf0f0f0f0;
        *PathType = val ^ 0xf0f0f0f0;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = ERROR_INVALID_PARAMETER;
    }
    if (status) {
        return status;
    }
    if (Flags & INPCA_FLAGS_RESERVED) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // call client-side RPC routine or local canonicalization routine
    //

    status = NetpIsRemote(ServerName, &location, serverName, 0);
    if (status != NERR_Success) {
        return status;
    }
    if (location == ISREMOTE) {
        return NetpsPathCanonicalize(serverName,
                                        PathName,
                                        Outbuf,
                                        OutbufLen,
                                        Prefix,
                                        PathType,
                                        Flags
                                        );
    } else {
        return NetpwPathCanonicalize(PathName,
                                        Outbuf,
                                        OutbufLen,
                                        Prefix,
                                        PathType,
                                        Flags
                                        );
    }
}


LONG
NET_API_FUNCTION
NetpPathCompare(
    IN  LPTSTR  ServerName OPTIONAL,
    IN  LPTSTR  PathName1,
    IN  LPTSTR  PathName2,
    IN  DWORD   PathType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Compares two paths. The paths are assumed to be of the same type

Arguments:

    ServerName  - where to run this API
    PathName1   - 1st path to compare
    PathName2   - 2nd
    PathType    - types of paths
    Flags       - control flags

Return Value:

    LONG

--*/

{
    NET_API_STATUS status = 0;
    DWORD location;
    TCHAR serverName[MAX_PATH];
    DWORD val;

    //
    // validate parameters
    //

    try {
        if (ARGUMENT_PRESENT(ServerName)) {
            val = STRLEN(ServerName);
        }
        if (ARGUMENT_PRESENT(PathName1)) {
            val = STRLEN(PathName1);
        }
        if (ARGUMENT_PRESENT(PathName2)) {
            val = STRLEN(PathName2);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = ERROR_INVALID_PARAMETER;
    }
    if (status) {
        return status;
    }
    if (Flags & INPC_FLAGS_RESERVED) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // call client-side RPC routine or local canonicalization routine
    //

    status = NetpIsRemote(ServerName, &location, serverName, 0);
    if (status != NERR_Success) {
        return status;
    }
    if (location == ISREMOTE) {
        return NetpsPathCompare(serverName, PathName1, PathName2, PathType, Flags);
    } else {
        return NetpwPathCompare(PathName1, PathName2, PathType, Flags);
    }
}


NET_API_STATUS
NET_API_FUNCTION
NetpPathType(
    IN  LPTSTR  ServerName OPTIONAL,
    IN  LPTSTR  PathName,
    OUT LPDWORD PathType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Determines the type of a path

Arguments:

    ServerName  - where to run this API
    PathName    - to find type of
    PathType    - returned path type
    Flags       - control flags

Return Value:

    NET_API_STATUS

--*/

{
    NET_API_STATUS status = 0;
    DWORD location;
    TCHAR serverName[MAX_PATH];
    DWORD val;

    //
    // validate parameters
    //

    try {
        if (ARGUMENT_PRESENT(ServerName)) {
            val = STRLEN(ServerName);
        }
        if (ARGUMENT_PRESENT(PathName)) {
            val = STRLEN(PathName);
        } else {
            val = 0;
        }
        if (!val || (val > MAX_PATH - 1)) {
            status = ERROR_INVALID_NAME;
        }
        *PathType = 0;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = ERROR_INVALID_PARAMETER;
    }
    if (status) {
        return status;
    }
    if (Flags & INPT_FLAGS_RESERVED) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // call client-side RPC routine or local canonicalization routine
    //

    status = NetpIsRemote(ServerName, &location, serverName, 0);
    if (status != NERR_Success) {
        return status;
    }
    if (location == ISREMOTE) {
        return NetpsPathType(serverName, PathName, PathType, Flags);
    } else {
        return NetpwPathType(PathName, PathType, Flags);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\api\confstub.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    ConfStub.c

Abstract:

    This module contains stubs for the NetConfig APIs.

Author:

    John Rogers (JohnRo) 23-Oct-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    23-Oct-1991 JohnRo
        Created.
    28-Oct-1991 JohnRo
        Use <winerror.h> if <lmerr.h> isn't needed.
    20-Nov-1991 JohnRo
        Work with old or new lmconfig.h for now (based on REVISED_CONFIG_APIS).
    02-Dec-1991 JohnRo
        Implement local NetConfig APIs.
    11-Mar-1992 JohnRo
        Fixed bug in get all where array wasn't terminated.
        Added real NetConfigSet() handling.
    21-Oct-1992 JohnRo
        RAID 9357: server mgr: can't add to alerts list on downlevel.

--*/

// These must be included first:

#include <nt.h>                 // IN, etc.  (Only needed by temporary config.h)
#include <ntrtl.h>              // (Only needed by temporary config.h)
#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // DEVLEN, NET_API_STATUS, etc.
#include <netdebug.h>           // (Needed by config.h)

// These may be included in any order:

#include <config.h>             // NetpOpenConfigData(), etc.
#include <lmapibuf.h>           // NetApiBufferFree().
#include <lmerr.h>              // NERR_ and ERROR_ equates.
#include <lmconfig.h>           // NetConfig APIs.
#include <netlib.h>             // NetpMemoryReallocate().
#include <rxconfig.h>           // RxNetConfig APIs.
#include <tstring.h>            // STRSIZE(), TCHAR_EOS, etc.


#define INITIAL_ALLOC_AMOUNT    512  // arbitrary
#define INCR_ALLOC_AMOUNT       512  // arbitrary


NET_API_STATUS NET_API_FUNCTION
NetConfigGet (
    IN LPCWSTR UncServerName OPTIONAL,
    IN LPCWSTR Component,
    IN LPCWSTR Parameter,
#ifdef REVISED_CONFIG_APIS
    OUT LPBYTE *BufPtr
#else
    OUT LPBYTE *BufPtr,
    OUT LPDWORD TotalAvailable
#endif
    )

{
    NET_API_STATUS Status;
    LPNET_CONFIG_HANDLE ConfigHandle;
    BOOL TryDownLevel;

#ifndef REVISED_CONFIG_APIS
    UNREFERENCED_PARAMETER(TotalAvailable);
#endif

    *BufPtr = NULL;  // Check caller and make error handling easier.

    Status = NetpOpenConfigData(
            & ConfigHandle,
            (LPWSTR)UncServerName,
            (LPWSTR)Component,
            TRUE);              // just want read-only access

    if (Status != NERR_Success) {

        Status = NetpHandleConfigFailure(
                "NetConfigGet",  // debug name
                Status,          // result of NetpOpenConfigData
                (LPWSTR)UncServerName,
                & TryDownLevel);

        if (TryDownLevel) {
            return (RxNetConfigGet(
                    (LPWSTR)UncServerName,
                    (LPWSTR)Component,
                    (LPWSTR)Parameter,
                    BufPtr));
        } else {
            return (Status);    // result of NetpHandleConfigFailure
        }
    }

    Status = NetpGetConfigValue(
            ConfigHandle,
            (LPWSTR)Parameter,          // keyword
            (LPTSTR *) (LPVOID) BufPtr);     // alloc and set ptr

    if (Status == NERR_Success) {
        Status = NetpCloseConfigData( ConfigHandle );
        NetpAssert(Status == NERR_Success);
    } else {
        NetpAssert(*BufPtr == NULL);
        (void) NetpCloseConfigData( ConfigHandle );
    }

    return (Status);

} // NetConfigGet



NET_API_STATUS NET_API_FUNCTION
NetConfigGetAll (
    IN LPCWSTR UncServerName OPTIONAL,
    IN LPCWSTR Component,
#ifdef REVISED_CONFIG_APIS
    OUT LPBYTE *BufPtr
#else
    OUT LPBYTE *BufPtr,
    OUT LPDWORD TotalAvailable
#endif
    )

{
    DWORD BufSize;                      // Bytes allocated at *BufPtr (so far).
    DWORD BufUsed;                      // Bytes used      at *BufPtr (so far).
    LPNET_CONFIG_HANDLE ConfigHandle;
    BOOL FirstTime;
    LPVOID NewBuffPtr;
    NET_API_STATUS Status;
    BOOL TryDownLevel;

#ifndef REVISED_CONFIG_APIS
    UNREFERENCED_PARAMETER(TotalAvailable);
#endif

    *BufPtr = NULL;  // Check caller and make error handling easier.

    Status = NetpOpenConfigData(
            & ConfigHandle,
            (LPWSTR)UncServerName,
            (LPWSTR)Component,
            TRUE);                      // just want read-only access

    if (Status != NERR_Success) {

        Status = NetpHandleConfigFailure(
                "NetConfigGetAll",      // debug name
                Status,                 // result of NetpOpenConfigData
                (LPWSTR)UncServerName,
                & TryDownLevel);

        if (TryDownLevel) {
            return (RxNetConfigGetAll(
                    (LPWSTR)UncServerName,
                    (LPWSTR)Component,
                    BufPtr));

        } else {
            return (Status);            // result of NetpHandleConfigFailure
        }
    }

    // Even if there aren't any entries, we'll need to store a null at
    // end of array.  So allocate initial one now.
    BufSize = INITIAL_ALLOC_AMOUNT;
    NewBuffPtr = NetpMemoryReallocate(
            (LPVOID) *BufPtr,           // old address
            BufSize);                   // new size
    if (NewBuffPtr == NULL) { // out of memory
        (void) NetpCloseConfigData( ConfigHandle );
        return (ERROR_NOT_ENOUGH_MEMORY);
    }
    *BufPtr = NewBuffPtr;
    BufUsed = 0;

    // Loop once per entry (at least once if no entries).
    FirstTime = TRUE;
    do {
        LPTSTR KeywordBuffer;
        LPTSTR ValueBuffer;

        Status = NetpEnumConfigSectionValues(
                ConfigHandle,
                & KeywordBuffer,        // Alloc and set ptr.
                & ValueBuffer,          // Alloc and set ptr.
                FirstTime);

        FirstTime = FALSE;

        if (Status == NERR_Success) {

            DWORD SrcSize =
                    (STRLEN(KeywordBuffer) + 1 + STRLEN(ValueBuffer) + 1)
                    * sizeof(TCHAR);
            if (BufSize < (BufUsed+SrcSize) ) {
                if (SrcSize <= INCR_ALLOC_AMOUNT) {
                    BufSize += INCR_ALLOC_AMOUNT;
                } else {
                    BufSize += SrcSize;
                }
                NewBuffPtr = NetpMemoryReallocate(
                    (LPVOID) *BufPtr, /* old address */
                    BufSize);  /* new size */
                if (NewBuffPtr == NULL) { /* out of memory */
                    (void) NetpCloseConfigData( ConfigHandle );
                    return (ERROR_NOT_ENOUGH_MEMORY);
                }
                *BufPtr = NewBuffPtr;
            }

#define AddString( lptstrSrc, CharCount ) \
            { \
                LPTSTR lptstrDest; \
                NetpAssert( CharCount > 0 ); \
                lptstrDest = (LPTSTR)NetpPointerPlusSomeBytes( *BufPtr, BufUsed); \
                NetpAssert( lptstrDest != NULL ); \
                (void) STRNCPY( lptstrDest, lptstrSrc, CharCount ); \
                BufUsed += (CharCount * sizeof(TCHAR) ); \
                NetpAssert( BufUsed <= BufSize ); \
            }

            AddString( KeywordBuffer, STRLEN(KeywordBuffer) );
            (void) NetApiBufferFree( KeywordBuffer );

            AddString( TEXT("="), 1 );

            AddString( ValueBuffer, STRLEN(ValueBuffer) );
            (void) NetApiBufferFree( ValueBuffer );

#define AddNullChar( ) \
    { \
        AddString( TEXT(""), 1 ); \
    }

            AddNullChar();              // Terminate this entry.

        }

    } while (Status == NERR_Success);

    if (Status == NERR_CfgParamNotFound) {
        AddNullChar();                  // Terminate the array.
        Status = NetpCloseConfigData( ConfigHandle );
        NetpAssert(Status == NERR_Success);
    } else {
        NetpAssert( Status != NO_ERROR );
        NetpAssert( *BufPtr != NULL );
        NetpMemoryFree( *BufPtr );
        *BufPtr = NULL;
        (void) NetpCloseConfigData( ConfigHandle );
    }

    return (Status);

} // NetConfigGetAll



NET_API_STATUS NET_API_FUNCTION
NetConfigSet (
    IN LPCWSTR UncServerName OPTIONAL,
    IN LPCWSTR Reserved1 OPTIONAL,
    IN LPCWSTR Component,
    IN DWORD Level,
    IN DWORD Reserved2,
    IN LPBYTE Buf,
    IN DWORD Reserved3
    )
{
    LPCONFIG_INFO_0 Info = (LPVOID) Buf;
    LPNET_CONFIG_HANDLE ConfigHandle;
    NET_API_STATUS Status;
    BOOL TryDownLevel;

    if (Buf == NULL) {
        return (ERROR_INVALID_PARAMETER);
    } else if (Level != 0) {
        return (ERROR_INVALID_LEVEL);
    } else if (Info->cfgi0_key == NULL) {
        return (ERROR_INVALID_PARAMETER);
    } else if (Info->cfgi0_data == NULL) {
        return (ERROR_INVALID_PARAMETER);
    } else if (Reserved1 != NULL) {
        return (ERROR_INVALID_PARAMETER);
    } else if (Reserved2 != 0) {
        return (ERROR_INVALID_PARAMETER);
    } else if (Reserved3 != 0) {
        return (ERROR_INVALID_PARAMETER);
    }

    Status = NetpOpenConfigData(
            & ConfigHandle,
            (LPWSTR)UncServerName,
            (LPWSTR)Component,
            FALSE);             // don't want _read-only _access

    if (Status != NERR_Success) {

        Status = NetpHandleConfigFailure(
                "NetConfigSet",  // debug name
                Status,          // result of NetpOpenConfigData
                (LPWSTR)UncServerName,
                & TryDownLevel);

        if (TryDownLevel) {
            return (RxNetConfigSet(
                    (LPWSTR)UncServerName,
                    (LPWSTR)Reserved1,
                    (LPWSTR)Component,
                    Level,
                    Reserved2,
                    Buf,
                    Reserved3));
        } else {
            return (Status);    // result of NetpHandleConfigFailure
        }
    }

    Status = NetpSetConfigValue(
            ConfigHandle,
            Info->cfgi0_key,    // keyword
            Info->cfgi0_data);  // new value

    if (Status == NERR_Success) {
        Status = NetpCloseConfigData( ConfigHandle );
        NetpAssert(Status == NERR_Success);
    } else {
        (void) NetpCloseConfigData( ConfigHandle );
    }

    return (Status);

} // NetConfigSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\api\apibuff.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    ApiBuff.c

Abstract:

    This module contains routines for allocating and freeing API buffers.

Author:

    John Rogers (JohnRo) 25-Jan-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    Parts of the commentary for this file are extracted from material written
    by Alec Barker (AlecB@Microsoft).

Revision History:

    15-Mar-91 JohnRo
        Use <netdebug.h> and netlib routines.
    25-Apr-1991 JohnRo
        Call MIDL_user_allocate and MIDL_user_free.  Delete tabs.
    03-Dec-1991 JohnRo
        Added public NetApiBufferAllocate, NetApiBufferReallocate, and
        NetApiBufferSize APIs.
        Make sure buffers are aligned for worst case use.
    10-May-1992 JohnRo
        Treat alloc and realloc of size zero as non-error (return NULL ptr).
        Use <prefix.h> equates.
        Include my own prototypes so compiler can check them.
    18-May-1992 JohnRo
        RAID 9258: return non-null pointer when allocating zero bytes.

--*/

// These must be included first:

#include <windef.h>     // IN, LPVOID, etc.
#include <lmcons.h>     // NET_API_FUNCTION, etc.
#include <rpc.h>        // rpc prototypes

// These may be included in any order:

#include <align.h>      // POINTER_IS_ALIGNED(), ALIGN_WORST.
#include <lmapibuf.h>   // My prototypes.
#include <netdebug.h>   // NetpAssert(), NetpKdPrint(()), FORMAT_.
#include <prefix.h>     // PREFIX_ equates.
#include <rpcutil.h>    // MIDL_user_allocate(), etc.
#include <winerror.h>   // NO_ERROR and ERROR_ equates.


NET_API_STATUS NET_API_FUNCTION
NetApiBufferAllocate(
    IN DWORD ByteCount,
    OUT LPVOID * Buffer
    )

/*++

Routine Description:

    NetApiBufferAllocate is an internal function that allocates buffers
    which the APIs will return to the application.  (Usually these are for
    get-info operations.)

Arguments:

    ByteCount - Supplies the size (in bytes) that must be allocated for this
        buffer.  This may be zero, in which case a non-null pointer is
        passed-back and NO_ERROR is returned.

    Buffer - On return a pointer to the allocated area is returned in the
        address pointed to by Buffer.  (This is set to NULL on error.)
        The allocated area is guaranteed to be worst-case aligned for any
        use whatsoever.

Return Value:

    NET_API_STATUS - NO_ERROR if size is zero or memory was allocated.
        ERROR_NOT_ENOUGH_MEMORY if memory is not available.
        ERROR_INVALID_PARAMETER if a parameter is in error.

--*/

{

    if (Buffer == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Allocate the space.  Note that MIDL_user_allocate must allow zero
    // bytes to be allocated.
    //
    *Buffer = MIDL_user_allocate(ByteCount);

    if (*Buffer == NULL) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }
    NetpAssert( POINTER_IS_ALIGNED( *Buffer, ALIGN_WORST) );

    return (NO_ERROR);

} // NetApiBufferAllocate



NET_API_STATUS NET_API_FUNCTION
NetApiBufferFree (
    IN LPVOID Buffer
    )

/*++

Routine Description:

    NetApiBufferFree is called to deallocate memory which was acquired by
    a previous Net API call (e.g. NetApiBufferAllocate, NetWkstaGetInfo, and
    so on).

Arguments:

    Buffer - Supplies a pointer to an API information buffer previously
        returned on a Net API call.  (This would have been allocated by
        NetapipAllocateBuffer on behalf of one of the end-user Net API calls,
        e.g. NetWkstaGetInfo.)

Return Value:

    NET_API_STATUS.  Returns NO_ERROR if Buffer is null or memory was freed.
        Returns ERROR_INVALID_PARAMETER if Buffer points to an unaligned area.

--*/

{
    if (Buffer == NULL) {
        return (NO_ERROR);
    }

    if ( !POINTER_IS_ALIGNED( Buffer, ALIGN_WORST ) ) {
        NetpKdPrint(( PREFIX_NETAPI "NetApiBufferFree: unaligned input ptr: "
                FORMAT_LPVOID "!\n", (LPVOID) Buffer ));
        return (ERROR_INVALID_PARAMETER);
    }

    MIDL_user_free(Buffer);

    return (NO_ERROR);

} // NetApiBufferFree


NET_API_STATUS NET_API_FUNCTION
NetApiBufferReallocate(
    IN LPVOID OldBuffer OPTIONAL,
    IN DWORD NewByteCount,
    OUT LPVOID * NewBuffer
    )
{
    LPVOID NewPointer;

    if ( (OldBuffer==NULL) && (NewByteCount==0) ) {
        *NewBuffer = NULL;
        return (NO_ERROR);
    }

    NewPointer = (void *)MIDL_user_reallocate(  // may alloc, realloc, or free.
            (void *) OldBuffer,
            (unsigned long) NewByteCount);

    if (NewByteCount == 0) {                    // free
        *NewBuffer = NULL;
        return (NO_ERROR);
    } else if (NewPointer == NULL) {            // out of memory
        *NewBuffer = OldBuffer;                 // (don't lose old buffer)
        return (ERROR_NOT_ENOUGH_MEMORY);
    } else {                                    // alloc or realloc
        *NewBuffer = NewPointer;
        return (NO_ERROR);
    }

    /*NOTREACHED*/


} // NetApiBufferReallocate


NET_API_STATUS NET_API_FUNCTION
NetApiBufferSize(
    IN LPVOID Buffer,
    OUT LPDWORD ByteCount
    )
{
    DWORD AllocedSize;

    if ( (Buffer==NULL) || (ByteCount==NULL) ) {
        return (ERROR_INVALID_PARAMETER);
    } else if (POINTER_IS_ALIGNED( ByteCount, ALIGN_DWORD ) == FALSE) {
        return (ERROR_INVALID_PARAMETER);
    } else if (POINTER_IS_ALIGNED( Buffer, ALIGN_WORST ) == FALSE) {
        // Caller didn't get this pointer from us!
        return (ERROR_INVALID_PARAMETER);
    }

    AllocedSize = (unsigned long)MIDL_user_size(
            (void *) Buffer);

    NetpAssert( AllocedSize > 0 );

    *ByteCount = AllocedSize;
    return (NO_ERROR);


} // NetApiBufferSize



NET_API_STATUS NET_API_FUNCTION
NetapipBufferAllocate (
    IN DWORD ByteCount,
    OUT LPVOID * Buffer
    )

/*++

Routine Description:

    NetapipBufferAllocate is an old internal function that allocates buffers
    which the APIs will return to the application.  All calls to this routine
    should eventually be replaced by calls to NetApiBufferAllocate.

Arguments:

    (Same as NetApiBufferAllocate.)

Return Value:

    (Same as NetApiBufferAllocate.)

--*/

{
    return (NetApiBufferAllocate( ByteCount, Buffer ));

} // NetapipBufferAllocate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\api\errstub.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ErrStub.c

Abstract:

    This module contains stubs for the NetErrorLog APIs.

Author:

    John Rogers (JohnRo) 11-Nov-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    11-Nov-1991 JohnRo
        Implement downlevel NetErrorLog APIs.

--*/


// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // DEVLEN, NET_API_STATUS, etc.
#include <lmerrlog.h>           // NetErrorLog APIs; needed by rxerrlog.h.

// These may be included in any order:

#include <rxerrlog.h>           // RxNetErrorLog APIs.
#include <winerror.h>           // ERROR_ equates.


NET_API_STATUS NET_API_FUNCTION
NetErrorLogClear (
    IN LPCWSTR UncServerName OPTIONAL,
    IN LPCWSTR BackupFile OPTIONAL,
    IN LPBYTE  Reserved OPTIONAL
    )

{
    if ( (UncServerName == NULL) || (*UncServerName == '\0') ) {
        return (ERROR_NOT_SUPPORTED);
    }

    return (RxNetErrorLogClear(
            (LPWSTR)UncServerName,
            (LPWSTR)BackupFile,
            Reserved));

} // NetErrorLogClear



NET_API_STATUS NET_API_FUNCTION
NetErrorLogRead (
    IN LPCWSTR   UncServerName OPTIONAL,
    IN LPWSTR    Reserved1 OPTIONAL,
    IN LPHLOG    ErrorLogHandle,
    IN DWORD     Offset,
    IN LPDWORD   Reserved2 OPTIONAL,
    IN DWORD     Reserved3,
    IN DWORD     OffsetFlag,
    OUT LPBYTE * BufPtr,
    IN DWORD     PrefMaxSize,
    OUT LPDWORD  BytesRead,
    OUT LPDWORD  TotalAvailable
    )
{
    if ( (UncServerName == NULL) || (*UncServerName == '\0') ) {
        return (ERROR_NOT_SUPPORTED);
    }

    return (RxNetErrorLogRead(
            (LPWSTR)UncServerName,
            Reserved1,
            ErrorLogHandle,
            Offset,
            Reserved2,
            Reserved3,
            OffsetFlag,
            BufPtr,
            PrefMaxSize,
            BytesRead,
            TotalAvailable));

} // NetErrorLogRead


NET_API_STATUS NET_API_FUNCTION
NetErrorLogWrite (
    IN LPBYTE  Reserved1 OPTIONAL,
    IN DWORD   Code,
    IN LPCWSTR Component,
    IN LPBYTE  Buffer,
    IN DWORD   NumBytes,
    IN LPBYTE  MsgBuf,
    IN DWORD   StrCount,
    IN LPBYTE  Reserved2 OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(Reserved1);
    UNREFERENCED_PARAMETER(Code);
    UNREFERENCED_PARAMETER(Component);
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(NumBytes);
    UNREFERENCED_PARAMETER(MsgBuf);
    UNREFERENCED_PARAMETER(StrCount);
    UNREFERENCED_PARAMETER(Reserved2);

    return (ERROR_NOT_SUPPORTED);

} // NetErrorLogWrite
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\api\isremote.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    isremote.c

Abstract:

    Contains the NetpIsRemote routine. This checks if a computer name
    designates the local machine

Author:

    Richard L Firth (rfirth) 24th April 1991

Revision History:

    01-Nov-1991 JohnRo
        Fixed RAID 3414: allow explicit local server name.  (NetpIsRemote was
        not canonizaling the computer name from NetWkstaGetInfo, so it was
        always saying that the local computer name was remote if it wasn't
        already canonicalized.)

    07-Jun-1991 rfirth
        * Changed name of routine to conform to Nt naming conventions

        * Added LocalOrRemote parameter - returning just ISLOCAL or ISREMOTE
          is not sufficient - we can return error codes too

        * Added CanonicalizedName parameter - now passes back canonicalized
          name if requested. This is because, usually, subsequent routines call
          to NetRemoteComputerSupports which performs minimal checking on the
          name. Ergo, if we hand it a canonicalized name (which we have to do
          with this routine anyway) it can't complain. Can it?

        * NetpIsRemote no longer a NET_API_FUNCTION

        * Made semantics of CanonicalizedName orhogonal - if NULL or NUL passed
          in as ComputerName, caller still gets back the local computer name
          IF CanonicalizedName NOT NULL AND IF THE REDIRECTOR HAS BEEN STARTED
--*/

#include "nticanon.h"


NET_API_STATUS
NetpIsRemote(
    IN  LPTSTR  ComputerName OPTIONAL,
    OUT LPDWORD LocalOrRemote,
    OUT LPTSTR  CanonicalizedName OPTIONAL,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Determines whether a computer name designates this machine or a renote
    one. Values of ComputerName which equate to the local machine are:

        NULL pointer to name
        pointer to NULL name
        pointer to non-NULL name which is lexically equivalent to this
        machine's name

    NB. This routine expects that the canonicalized version of ComputerName
        will fit into the buffer pointed at by CanonicalizedName. Since this
        is an INTERNAL function, this assumption is deemed valid

Arguments:

    IN  LPTSTR  ComputerName OPTIONAL
                    Pointer to computer name to check. May assume any of
                    the above forms
                    If a non-NULL string is passed in, then it may have
                    preceeding back-slashes. This is kind of expected since
                    this routine is called by remotable APIs and it is they
                    who specify that the form a computer name is \\<name>

    OUT LPDWORD LocalOrRemote
                    Points to the DWORD where the specifier for the
                    symbolic location will be returned. MUST NOT BE NULL. On
                    return will be one of:
                        ISLOCAL     The name defined by ComputerName specifies
                                    the local machine specifically or by default
                                    (ie. was NULL)
                        ISREMOTE    The name defined by ComputerName was non-NULL
                                    and was not the name of this machine

    OUT LPTSTR  CanonicalizedName OPTIONAL
                    Pointer to caller's buffer into which a copy of the
                    canonicalized name will be placed if requested. This
                    can then be used in subsequent calls, with the knowledge
                    that no further checking of the computer name is required.
                    Note that the format of this buffer will be \\<computername>
                    on return. The contents of this buffer will not be
                    modified unless this routine returns success

    IN  DWORD   Flags
                    A bitmap. Flags are:

                        NIRFLAG_MAPLOCAL    if set, will map (ie canonicalize)
                                            the NULL local name to this
                                            computer's name proper. Used in
                                            conjunction with CanonicalizedName
                                            This stops extraneous calls to
                                            NetpNameCanonicalize with the
                                            inherited CanonicalizedName
                                            parameter. See below for elucidation

Return Value:

    NET_API_STATUS
        Success = NERR_Success
        Failure = return code from:
                    NetpNameCanonicalize
                    NetWkstaGetInfo
                    NetpNameCompare
--*/

{
    LPBYTE  wksta_buffer_pointer;
    BOOL    map_local_name = FALSE;
    LONG    result;
    NET_API_STATUS  rc;

    TCHAR   name[MAX_PATH];     // canonicalized version of ComputerName
    LPTSTR  wksta_name_uncanon; // our computer name (from NetWkstaGetInfo)
    TCHAR   wksta_name_canon[MAX_PATH]; // our computer name (from canon)
    LPTSTR  canonicalized_name; // as returned to caller


    //
    // Assert that we have a valid pointer in LocalOrRemote
    //

    //
    // Once again, shouldn't have to do this, since this routine is internal
    // and there is no interpretation about inputs. However, lets catch any
    // possible problems...
    //

    NetpAssert(ARGUMENT_PRESENT(LocalOrRemote));

#ifdef CANONDBG
    DbgPrint("NetpIsRemote(%s, %x, %x, %x)\n",
        ComputerName,
        LocalOrRemote,
        CanonicalizedName,
        Flags
        );
#endif

    //
    // NB. It is important to check this case first, before we call any Netp
    // routines since these could call back to this routine and we may get
    // stuck in an infinite loop
    //

    if (!ARGUMENT_PRESENT(ComputerName) || (*ComputerName == TCHAR_EOS)) {

        //
        // in this case its probably an internal call from one of our routines
        // and we want to return as quickly as possible. This will be borne out
        // by the NIRFLAG_MAPLOCAL flag being reset in the Flags parameter
        //

        //
        // A note about NIRFLAG_MAPLOCAL
        // This routine makes local calls to NetpNameValidate and
        // NetpNameCompare. If the NIRFLAG_MAPLOCAL flag is not reset then
        // these routines in turn will cause the local name to be returned
        // (because they always pass in non-NULL CanonicalizedName parameter)
        // which in most cases is inefficient, since the name won't be used
        // so we always say (in the Netp routines) that we don't want local
        // name canonicalization
        // Therefore, if (local) name canonicalization is implied by non-NULL
        // CanonicalizedName, verify this by checking Flags.NIRFLAG_MAPLOCAL
        // If it, too, is set then local name canonicalization is performed
        //

        if (!ARGUMENT_PRESENT(CanonicalizedName) || !(Flags & NIRFLAG_MAPLOCAL)) {
            *LocalOrRemote = ISLOCAL;
#ifdef CANONDBG
            DbgPrint("NetpIsRemote(%s) - returning early\n", ComputerName);
#endif
            return NERR_Success;
        } else {

            //
            // signify that the input name was NULL or NUL string but that the
            // caller wants a canonicalized name returned (from NetWkstaGetInfo)
            //

            map_local_name = TRUE;
        }
    } else {

        //
        // if the computername starts with \\ or // or any combination thereof,
        // skip the path separators - the canonicalization routines expect
        // computer names NOT to have these.
        //

        if (IS_PATH_SEPARATOR(ComputerName[0]) && IS_PATH_SEPARATOR(ComputerName[1])) {
            ComputerName += 2;
        }

        //
        // here's a use for canonicalization (!): ensure that we have been passed
        // a real and proper computer name and not some pale imitation
        //

        rc = NetpNameCanonicalize(
                NULL,                   // performed here, on our own premises
                ComputerName,           // this is input
                name,                   // this is output
                sizeof(name),           // how much buffer we have
                NAMETYPE_COMPUTER,      // what we think it is
                INNCA_FLAGS_FULL_BUFLEN // say that o/p buffer must be large
                                        // enough for maximum-sized computer
                                        // name. Why? you ask, well its a fair
                                        // cop - the reason is that we can't
                                        // get into trouble on the one time that
                                        // we exercise the maximum requirement
                );
        if (rc) {
            return rc;  // duff name (?)
        } else {
            canonicalized_name = name;
        }
    }

    //
    // get the name of this machine from the redirector. If we can't get the
    // name for whatever reason, return the error code.
    //

    if (rc = NetWkstaGetInfo(NULL, 100, &wksta_buffer_pointer)) {
#ifdef CANONDBG
        DbgPrint("error: NetWkstaGetInfo returns %lu\n", rc);
#endif
        return rc;  // didn't work
    }

    wksta_name_uncanon =
            ((LPWKSTA_INFO_100) wksta_buffer_pointer)->wki100_computername;

#ifdef CANONDBG
    DbgPrint("NetWkstaGetInfo returns level 100 computer name (uncanon)= %s\n",
            wksta_name_uncanon);
#endif
    rc = NetpNameCanonicalize(
            NULL,                       // performed here, on our own premises
            wksta_name_uncanon,         // this is input
            wksta_name_canon,           // this is output
            sizeof(wksta_name_canon),   // how much buffer we have
            NAMETYPE_COMPUTER,          // what we think it is
            INNCA_FLAGS_FULL_BUFLEN     // say that o/p buffer must be large
                                        // enough for maximum-sized computer
                                        // name. Why? you ask, well its a fair
                                        // cop - the reason is that we can't
                                        // get into trouble on the one time that
                                        // we exercise the maximum requirement
            );
    NetpAssert( rc == NERR_Success );

    //
    // compare our name and the name passed to us. NetpNameCompare returns
    // 0 if the names match else 1 or -1 (a la strcmp)
    //

    //
    // if the caller gave us a NULL computer name but wants a canonicalized
    // name output then get a pointer to the canonicalized name from
    // NetWkstaGetInfo
    //

    if (map_local_name) {
        canonicalized_name = wksta_name_canon;
    } else {

        //
        // otherwise, we have a non-NULL computername to compare with this
        // computer's name
        //

        result = NetpNameCompare(
                    NULL,   // performed here, on our own premises
                    name,   // canonicalized version of passed name
                    wksta_name_canon,  // name of our computer
                    NAMETYPE_COMPUTER,
                    INNC_FLAGS_NAMES_CANONICALIZED
                    );
    }

    //
    // if the specified name equates to our computer name then its still local
    //

    *LocalOrRemote = (DWORD)((result == 0) ? ISLOCAL : ISREMOTE);

    //
    // if the caller specified that the canonicalized name be returned, then
    // give it to 'em. Note that the returned name is prefixed with \\ - it
    // is assumed the name is then used in a call to eg NetRemoteComputerSupports
    //

    if (ARGUMENT_PRESENT(CanonicalizedName)) {
        STRCPY(CanonicalizedName, TEXT("\\\\"));
        STRCAT(CanonicalizedName, canonicalized_name);
    }

    //
    // free the buffer created by NetWkstaGetInfo
    //

    NetApiBufferFree(wksta_buffer_pointer);

    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\api\makefile.inc ===
PRIVLIB= $(O)\netapi32p.lib
$(O)\netapi32.lib : $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\netapi32p.def $(LIBRARY_OBJS)
   -lib -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\netapi32p.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\netapi32p.def: netapi32.def
    $(C_PREPROCESSOR) $** -DPRIVATE= > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\api\getstats.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    getstats.c

Abstract:

    Tests NT-level NetStatisticsGet API

Author:

    Richard L Firth (rfirth) 08-Aug-1991

Revision History:

    09-May-1992 rfirth
        Change to use new redirector/wksta statistics

    08-Aug-1991 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <lmcons.h>
#include <lmstats.h>
#include <lmsname.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <tstring.h>

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

void main(int, char**);
void usage(void);

void main(int argc, char** argv) {
    LPTSTR  service_name;
    LPTSTR  server_name = NULL;
    DWORD   level = 0;
    DWORD   options = 0;
    LPBYTE  buffer;
    NET_API_STATUS  rc;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            ++*argv;
            switch (tolower(**argv)) {
            case 'c':
                options = STATSOPT_CLR;
                break;

            case 'h':
            case '?':
                usage();
                break;

            case 'l':
                level = (DWORD)atoi(++*argv);
                break;

            case 'w':
                service_name = SERVICE_WORKSTATION;
                break;

            case 's':
                service_name = SERVICE_SERVER;
                break;

            default:
                printf("error: bad flag: '%c'\n", **argv);
                usage();
            }
        } else if (server_name) {

            //
            // allow the user to enter a service name. This allows us to expand
            // the test to cover other services which may be included in future
            //

            service_name = *argv;
        } else {
            server_name = *argv;
        }
    }
    rc = NetStatisticsGet(server_name, service_name, level, options, &buffer);
    if (rc != NERR_Success) {
        printf("error: NetStatisticsGet returns %u\n", rc);
        exit(2);
    } else {
        if (!STRCMP(service_name, SERVICE_SERVER)) {
            printf("Server statistics for %s:\n"
                   "Time stats started............................: %u\n"
                   "Number of file opens..........................: %u\n"
                   "Number of device opens........................: %u\n"
                   "Number of print jobs spooled..................: %u\n"
                   "Number of server session started..............: %u\n"
                   "Number of sessions auto disconnected..........: %u\n"
                   "Number of server sessions failed with error...: %u\n"
                   "Number of password violations.................: %u\n"
                   "Number of server system errors................: %u\n"
                   "Number of bytes sent to net (low).............: %u\n"
                   "Number of bytes sent to net (high)............: %u\n"
                   "Number of bytes received from net (low).......: %u\n"
                   "Number of bytes received from net (high)......: %u\n"
                   "Average response time.........................: %u\n"
                   "Number of failures to allocate buffer.........: %u\n"
                   "Number of failures to allocate big buf........: %u\n",
                    server_name,
                    ((LPSTAT_SERVER_0)buffer)->sts0_start,
                    ((LPSTAT_SERVER_0)buffer)->sts0_fopens,
                    ((LPSTAT_SERVER_0)buffer)->sts0_devopens,
                    ((LPSTAT_SERVER_0)buffer)->sts0_jobsqueued,
                    ((LPSTAT_SERVER_0)buffer)->sts0_sopens,
                    ((LPSTAT_SERVER_0)buffer)->sts0_stimedout,
                    ((LPSTAT_SERVER_0)buffer)->sts0_serrorout,
                    ((LPSTAT_SERVER_0)buffer)->sts0_pwerrors,
                    ((LPSTAT_SERVER_0)buffer)->sts0_permerrors,
                    ((LPSTAT_SERVER_0)buffer)->sts0_syserrors,
                    ((LPSTAT_SERVER_0)buffer)->sts0_bytessent_low,
                    ((LPSTAT_SERVER_0)buffer)->sts0_bytessent_high,
                    ((LPSTAT_SERVER_0)buffer)->sts0_bytesrcvd_low,
                    ((LPSTAT_SERVER_0)buffer)->sts0_bytesrcvd_high,
                    ((LPSTAT_SERVER_0)buffer)->sts0_avresponse,
                    ((LPSTAT_SERVER_0)buffer)->sts0_reqbufneed,
                    ((LPSTAT_SERVER_0)buffer)->sts0_bigbufneed
                    );
        } else if (!STRCMP(service_name, SERVICE_WORKSTATION)) {
            printf("Workstation statistics for %s:\n"
#ifdef LM20_WORKSTATION_STATISTICS
                   "Time stats started..............................: %u\n"
                   "Total NCBs issued by redirector.................: %u\n"
                   "Total NCBs issued by server.....................: %u\n"
                   "Total NCBs issued by apps.......................: %u\n"
                   "Failed NCBs issued by redirector................: %u\n"
                   "Failed NCBs issued by server....................: %u\n"
                   "Failed NCBs issued by apps......................: %u\n"
                   "NCBs issued by redir failing before completion..: %u\n"
                   "NCBs issued by server failing before completion.: %u\n"
                   "NCBs issued by apps failing before completion...: %u\n"
                   "Number of sessions started......................: %u\n"
                   "Number of sessions failed to connect............: %u\n"
                   "Number of sessions failed after connecting......: %u\n"
                   "Number of uses..................................: %u\n"
                   "Number of failed uses...........................: %u\n"
                   "Number of auto reconnections....................: %u\n"
                   "Number of bytes sent to net (high)..............: %u\n"
                   "Number of bytes sent to net (low)...............: %u\n"
                   "Number of bytes received from net (high)........: %u\n"
                   "Number of bytes received from net (low).........: %u\n"
                   "Number of server bytes sent to net (high).......: %u\n"
                   "Number of server bytes sent to net (low)........: %u\n"
                   "Number of server bytes received from net (high).: %u\n"
                   "Number of server bytes received from net (low)..: %u\n"
                   "Number of app bytes sent to net (high)..........: %u\n"
                   "Number of app bytes sent to net (low)...........: %u\n"
                   "Number of app bytes received from net (high)....: %u\n"
                   "Number of app bytes received from net (low).....: %u\n"
                   "Number of failures to allocate buffer...........: %u\n"
                   "Number of failures to allocate big buf..........: %u\n",
                   server_name,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_start,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_numNCB_r,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_numNCB_s,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_numNCB_a,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_fiNCB_r,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_fiNCB_s,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_fiNCB_a,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_fcNCB_r,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_fcNCB_s,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_fcNCB_a,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_sesstart,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_sessfailcon,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_sessbroke,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_uses,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_usefail,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_autorec,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_bytessent_r_hi,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_bytessent_r_lo,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_bytesrcvd_r_hi,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_bytesrcvd_r_lo,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_bytessent_s_hi,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_bytessent_s_lo,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_bytesrcvd_s_hi,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_bytesrcvd_s_lo,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_bytessent_a_hi,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_bytessent_a_lo,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_bytesrcvd_a_hi,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_bytesrcvd_a_lo,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_reqbufneed,
                   ((LPSTAT_WORKSTATION_0)buffer)->stw0_bigbufneed
#else
                   "Bytes Received....................: %08x%08x\n"
                   "SMBs Received.....................: %08x%08x\n"
                   "Paging Read Bytes Requested.......: %08x%08x\n"
                   "Non-paging Read Bytes Requested...: %08x%08x\n"
                   "Cache Read Bytes Requested........: %08x%08x\n"
                   "Network Read Bytes Requested......: %08x%08x\n"
                   "Bytes Transmitted.................: %08x%08x\n"
                   "SMBs Transmitted..................: %08x%08x\n"
                   "Paging Write Bytes Requested......: %08x%08x\n"
                   "Non-paging Write Bytes Requested..: %08x%08x\n"
                   "Cache Write Bytes Requested.......: %08x%08x\n"
                   "Network Write Bytes Requested.....: %08x%08x\n"
                   "Read Operations...................: %u\n"
                   "Random Read Operations............: %u\n"
                   "Read SMBs.........................: %u\n"
                   "Large Read SMBs...................: %u\n"
                   "Small Read SMBs...................: %u\n"
                   "Write Operations..................: %u\n"
                   "Random Write Operations...........: %u\n"
                   "Write SMBs........................: %u\n"
                   "Large Write SMBs..................: %u\n"
                   "Small Write SMBs..................: %u\n"
                   "Raw Reads Denied..................: %u\n"
                   "Raw Writes Dennied................: %u\n"
                   "Network Errors....................: %u\n"
                   "Sessions..........................: %u\n"
                   "Reconnects........................: %u\n"
                   "Core Connects.....................: %u\n"
                   "Lanman 2.0 Connects...............: %u\n"
                   "Lanman 2.1 Connects...............: %u\n"
                   "Lanman NT Connects................: %u\n"
                   "Server Disconnects................: %u\n"
                   "Hung Sessions.....................: %u\n"
                   "Current Commands..................: %u\n",
                   server_name,
                   ((LPSTAT_WORKSTATION_0)buffer)->BytesReceived.HighPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->BytesReceived.LowPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->SmbsReceived.HighPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->SmbsReceived.LowPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->PagingReadBytesRequested.HighPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->PagingReadBytesRequested.LowPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->NonPagingReadBytesRequested.HighPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->NonPagingReadBytesRequested.LowPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->CacheReadBytesRequested.HighPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->CacheReadBytesRequested.LowPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->NetworkReadBytesRequested.HighPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->NetworkReadBytesRequested.LowPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->BytesTransmitted.HighPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->BytesTransmitted.LowPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->SmbsTransmitted.HighPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->SmbsTransmitted.LowPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->PagingWriteBytesRequested.HighPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->PagingWriteBytesRequested.LowPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->NonPagingWriteBytesRequested.HighPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->NonPagingWriteBytesRequested.LowPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->CacheWriteBytesRequested.HighPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->CacheWriteBytesRequested.LowPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->NetworkWriteBytesRequested.HighPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->NetworkWriteBytesRequested.LowPart,
                   ((LPSTAT_WORKSTATION_0)buffer)->ReadOperations,
                   ((LPSTAT_WORKSTATION_0)buffer)->RandomReadOperations,
                   ((LPSTAT_WORKSTATION_0)buffer)->ReadSmbs,
                   ((LPSTAT_WORKSTATION_0)buffer)->LargeReadSmbs,
                   ((LPSTAT_WORKSTATION_0)buffer)->SmallReadSmbs,
                   ((LPSTAT_WORKSTATION_0)buffer)->WriteOperations,
                   ((LPSTAT_WORKSTATION_0)buffer)->RandomWriteOperations,
                   ((LPSTAT_WORKSTATION_0)buffer)->WriteSmbs,
                   ((LPSTAT_WORKSTATION_0)buffer)->LargeWriteSmbs,
                   ((LPSTAT_WORKSTATION_0)buffer)->SmallWriteSmbs,
                   ((LPSTAT_WORKSTATION_0)buffer)->RawReadsDenied,
                   ((LPSTAT_WORKSTATION_0)buffer)->RawWritesDenied,
                   ((LPSTAT_WORKSTATION_0)buffer)->NetworkErrors,
                   ((LPSTAT_WORKSTATION_0)buffer)->Sessions,
                   ((LPSTAT_WORKSTATION_0)buffer)->Reconnects,
                   ((LPSTAT_WORKSTATION_0)buffer)->CoreConnects,
                   ((LPSTAT_WORKSTATION_0)buffer)->Lanman20Connects,
                   ((LPSTAT_WORKSTATION_0)buffer)->Lanman21Connects,
                   ((LPSTAT_WORKSTATION_0)buffer)->LanmanNtConnects,
                   ((LPSTAT_WORKSTATION_0)buffer)->ServerDisconnects,
                   ((LPSTAT_WORKSTATION_0)buffer)->HungSessions,
                   ((LPSTAT_WORKSTATION_0)buffer)->CurrentCommands
#endif
                   );
        } else {
            printf("warning: don't know how to display info for service %s\n", service_name);
        }
        NetApiBufferFree(buffer);
        exit(0);
    }
}

void usage() {
    printf("usage: GetStats -w|-s -c -l# [\\\\ServerName] [optional_service_name]\n"
           "where: -w : gets WorkStation statistics\n"
           "       -s : gets Server      statistics\n"
           "       -c : clears statistics\n"
           "       -l#: level of information required (API=MBZ, default)\n"
           );
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\api\supports.c ===
/*++

Copyright (c) 1991-92 Microsoft Corporation

Module Name:

    Supports.c

Abstract:

    This module determines which optional features that a given remote
    machine supports.  These features are of interest to the RpcXlate
    code, among other people.

Author:

    John Rogers (JohnRo) 28-Mar-1991

Environment:

    Only runs under NT, although the interface is portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    28-Mar-1991 Johnro
        Created.
    02-Apr-1991 JohnRo
        Moved NetpRdrFsControlTree to <netlibnt.h>.
    06-May-1991 JohnRo
        Implement UNICODE.
    26-Jul-1991 JohnRo
        Quiet DLL stub debug output.
    31-Oct-1991 JohnRo
        RAID 3414: allow explicit local server name.
        Also allow use of NetRemoteComputerSupports() for local computer.
        Minor UNICODE work.
    08-May-1992 JohnRo
        Use <prefix.h> equates.
    22-Sep-1992 JohnRo
        RAID 6739: Browser too slow when not logged into browsed domain.

--*/

// These must be included first:

#include <nt.h>         // IN, NULL, etc.
#include <windef.h>     // DWORD, LPDWORD, LPTSTR, TCHAR, etc.
#include <lmcons.h>     // NET_API_STATUS, NET_API_FUNCTION.

// These may be included in any order:

#include <debuglib.h>   // IF_DEBUG().
#include <icanon.h>     // NetpIsRemote(), NIRFLAG_ stuff, IS equates.
#include <lmerr.h>      // NERR_Success, etc.
#include <lmremutl.h>   // My prototype, SUPPORTS_ equates.
#include <names.h>      // NetpIsRemoteNameValid().
#include <netdebug.h>   // NetpAssert().
#include <netlib.h>     // NetpMemoryAllocate(), NetpMemoryFree().
#include <netlibnt.h>   // NetpRdrFsControlTree().
#include <ntddnfs.h>    // LMR_TRANSACTION, etc.
#include <prefix.h>     // PREFIX_ equates.
#include <tstring.h>    // STRCAT(), STRCPY(), STRLEN().
#include <lmuse.h>              // USE_IPC

NET_API_STATUS NET_API_FUNCTION
NetRemoteComputerSupports(
    IN LPCWSTR UncServerName OPTIONAL,   // Must start with "\\".
    IN DWORD OptionsWanted,             // Set SUPPORT_ bits wanted.
    OUT LPDWORD OptionsSupported        // Supported features, masked.
    )

#define SHARE_SUFFIX            (LPTSTR) TEXT("\\IPC$")
#define SHARE_SUFFIX_LEN        5

#ifdef UNICODE
#define LOCAL_FLAGS             ( SUPPORTS_REMOTE_ADMIN_PROTOCOL \
                                | SUPPORTS_RPC \
                                | SUPPORTS_SAM_PROTOCOL \
                                | SUPPORTS_UNICODE \
                                | SUPPORTS_LOCAL )
#else // not UNICODE
#define LOCAL_FLAGS             ( SUPPORTS_REMOTE_ADMIN_PROTOCOL \
                                | SUPPORTS_RPC \
                                | SUPPORTS_SAM_PROTOCOL \
                                | SUPPORTS_LOCAL )
#endif // not UNICODE

/*++

Routine Description:

    NetRemoteComputerSupports queries the redirector about a given remote
    system.  This is done to find out which optional features the remote
    system supports.  The features of interest are Unicode, RPC, and the
    Remote Admin Protocol.

    This will establish a connection if one doesn't already exist.

Arguments:

    UncServerName - Gives name of remote server to query.  This must begin
        with "\\".

    OptionsWanted - Gives a set of bits indicating which features the caller is
        interested in.  (At least one bit must be on.)

    OptionsSupported - Points to a DWORD which will be set with set of bits
        indicating which of the features selected by OptionsWanted are actually
        implemented on the computer with UncServerName.  (All other bits in this
        DWORD will be set to 0.)  The value of OptionsSupported is undefined if
        the return value is not NERR_Success.

Return Value:

    NET_API_STATUS.

--*/


{
    NET_API_STATUS Status;
    DWORD TempSupported = 0;

    IF_DEBUG(SUPPORTS) {
        NetpKdPrint(( PREFIX_NETAPI "NetRemoteComputerSupports: input mask is "
                FORMAT_HEX_DWORD ".\n", OptionsWanted));
    }

    // Error check what caller gave us.
    if (OptionsSupported == NULL) {
        return (ERROR_INVALID_PARAMETER);
    } else if (OptionsWanted == 0) {
        // Not what caller really intended, probably.
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Handle no name given (implies local computer).
    //
    if ( (UncServerName==NULL) || ((*UncServerName) == (TCHAR) '\0') ) {

        TempSupported = LOCAL_FLAGS & OptionsWanted;

    } else {

        TCHAR CanonServerName[MAX_PATH];
        DWORD LocalOrRemote;    // Will be set to ISLOCAL or ISREMOTE.

        //
        // Name was given.  Canonicalize it and check if it's remote.
        //
        Status = NetpIsRemote(
            (LPWSTR)UncServerName,      // input: uncanon name
            & LocalOrRemote,    // output: local or remote flag
            CanonServerName,    // output: canon name
            0);                 // flags: normal
        IF_DEBUG(SUPPORTS) {
            NetpKdPrint(( PREFIX_NETAPI
                    "NetRemoteComputerSupports: canon status is "
                    FORMAT_API_STATUS ", Lcl/rmt=" FORMAT_HEX_DWORD
                    ", canon buf is '" FORMAT_LPTSTR "'.\n",
                    Status, LocalOrRemote, CanonServerName));
        }
        if (Status != NERR_Success) {
            return (Status);
        }

        if (LocalOrRemote == ISLOCAL) {

            //
            // Explicit local name given.
            //
            TempSupported = LOCAL_FLAGS & OptionsWanted;

        } else {

            //
            // Explicit remote name given.
            //

            DWORD RedirCapabilities;
            PLMR_CONNECTION_INFO_2 RedirConnInfo;
            DWORD RedirConnInfoSize = sizeof(LMR_CONNECTION_INFO_2)
                    + ( (MAX_PATH+1 + MAX_PATH+1) * sizeof(TCHAR) );

            PLMR_REQUEST_PACKET RedirRequest;
            DWORD RedirRequestSize = sizeof(LMR_REQUEST_PACKET);

            LPTSTR TreeConnName;

            // Build tree connect name.
            TreeConnName =
                NetpMemoryAllocate(
                    (STRLEN(CanonServerName) + SHARE_SUFFIX_LEN + 1)
                    * sizeof(TCHAR) );
            if (TreeConnName == NULL) {
                return (ERROR_NOT_ENOUGH_MEMORY);
            }
            (void) STRCPY(TreeConnName, CanonServerName);
            (void) STRCAT(TreeConnName, SHARE_SUFFIX);
            NetpAssert(NetpIsRemoteNameValid(TreeConnName));

            // Alloc fsctl buffers.
            RedirConnInfo = NetpMemoryAllocate(RedirConnInfoSize);
            if (RedirConnInfo == NULL) {
                NetpMemoryFree(TreeConnName);
                return (ERROR_NOT_ENOUGH_MEMORY);
            }
            RedirRequest = NetpMemoryAllocate(RedirRequestSize);
            if (RedirRequest == NULL) {
                NetpMemoryFree(RedirConnInfo);
                NetpMemoryFree(TreeConnName);
                return (ERROR_NOT_ENOUGH_MEMORY);
            }

            RedirRequest->Level = 2;
            RedirRequest->Type = GetConnectionInfo;
            RedirRequest->Version = REQUEST_PACKET_VERSION;

            // Open tree conn (which will establish connection with the remote
            // server if one doesn't already exist) and do the FSCTL.
            Status = NetpRdrFsControlTree(
                    TreeConnName,                       // \\server\IPC$
                    NULL,                               // No transport.
                    USE_IPC,                            // Connection type
                    FSCTL_LMR_GET_CONNECTION_INFO,      // fsctl func code
                    NULL,                               // security descriptor
                    RedirRequest,                       // in buffer
                    RedirRequestSize,                   // in buffer size
                    RedirConnInfo,                      // out buffer
                    RedirConnInfoSize,                  // out buffer size
                    FALSE);                     // not a "null session" API.

            IF_DEBUG(SUPPORTS) {
                NetpKdPrint(( PREFIX_NETAPI
                        "NetRemoteComputerSupports: back from fsctl, "
                        "status is " FORMAT_API_STATUS ".\n", Status));
            }

            // Handle remote machine not found.
            if (Status != NERR_Success) {
                NetpMemoryFree(RedirConnInfo);
                NetpMemoryFree(RedirRequest);
                NetpMemoryFree(TreeConnName);
                return (Status);
            }
            RedirCapabilities = RedirConnInfo->Capabilities;

            IF_DEBUG(SUPPORTS) {
                NetpKdPrint(( PREFIX_NETAPI
                        "NetRemoteComputerSupports: redir mask is "
                        FORMAT_HEX_DWORD ".\n", RedirCapabilities));
            }

            NetpMemoryFree(RedirConnInfo);
            NetpMemoryFree(RedirRequest);
            NetpMemoryFree(TreeConnName);

            if (OptionsWanted & SUPPORTS_REMOTE_ADMIN_PROTOCOL) {
                if (RedirCapabilities & CAPABILITY_REMOTE_ADMIN_PROTOCOL) {
                    TempSupported |= SUPPORTS_REMOTE_ADMIN_PROTOCOL;
                }
            }
            if (OptionsWanted & SUPPORTS_RPC) {
                if (RedirCapabilities & CAPABILITY_RPC) {
                    TempSupported |= SUPPORTS_RPC;
                }
            }
            if (OptionsWanted & SUPPORTS_SAM_PROTOCOL) {
                if (RedirCapabilities & CAPABILITY_SAM_PROTOCOL) {
                    TempSupported |= SUPPORTS_SAM_PROTOCOL;
                }
            }
            if (OptionsWanted & SUPPORTS_UNICODE) {
                if (RedirCapabilities & CAPABILITY_UNICODE) {
                    TempSupported |= SUPPORTS_UNICODE;
                }
            }

        }
    }

    IF_DEBUG(SUPPORTS) {
        NetpKdPrint(( PREFIX_NETAPI "NetRemoteComputerSupports: output mask is "
                FORMAT_HEX_DWORD ".\n", TempSupported));
    }

    // Make sure we don't tell caller anything he/she didn't want to know.
    NetpAssert( (TempSupported & (~OptionsWanted)) == 0);

    // Tell caller what we know.
    *OptionsSupported = TempSupported;

    return (NERR_Success);

} // NetRemoteComputerSupports
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\api\notify.c ===
/*++

Copyright (c) 1998-1998  Microsoft Corporation

Module Name:

    notify.c

Abstract:

    This module contains the implemention of the change notification functions

Author:

    Mac McLain      (MacM)      04-Feb-1998

Environment:

    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:


Revision History:

--*/

// These must be included first:
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>     // IN, LPVOID, etc.
#include <lmcons.h>     // NET_API_FUNCTION, etc.
#include <lmerr.h>      // LM Error codes
#include <ntlsa.h>      // Lsa change notification function prototypes
#include <lmconfig.h>   // Function prototypes
#include <winbase.h>    // CreateEvent...
#include <netlibnt.h>   // NetpNtStatusToApiStatus
//
// We dynamically load secur32.dll, in order to call the lsa policy change notification functions
// Keep it in sync with the definition in ntlsa.h
//
typedef NTSTATUS (* POLCHANGENOTIFYFN )( POLICY_NOTIFICATION_INFORMATION_CLASS, HANDLE );

NET_API_STATUS
NET_API_FUNCTION
NetRegisterDomainNameChangeNotification(
    PHANDLE NotificationEventHandle
    )
/*++

Routine Description:

    This function is used to register a notification for a domain name change.
    The waitable event that is returned gets signalled when ever the flat or
    dns domain name is changed.

Arguments:

    NotificationHandle - Where the handle to the created notification event is
        returned.


Return Value:

    NERR_Success - Success
    ERROR_INVALID_PARAMETER - A NULL NotificationEventHandle was given


--*/
{
    NTSTATUS Status;
    HANDLE EventHandle;
    DWORD Err = NERR_Success;

    if ( NotificationEventHandle == NULL ) {

        return( ERROR_INVALID_PARAMETER );
    }

    EventHandle = CreateEvent( NULL, FALSE, FALSE, NULL );

    if ( EventHandle == NULL ) {

        Err = GetLastError();

    } else {

        Status = LsaRegisterPolicyChangeNotification( PolicyNotifyDnsDomainInformation,
                                                      EventHandle );

        //
        // If the function was successful, return the event handle.  Otherwise,
        // close the event
        //
        if ( !NT_SUCCESS( Status ) ) {

            CloseHandle( EventHandle );
            Err = NetpNtStatusToApiStatus( Status );

        } else {

            *NotificationEventHandle = EventHandle;
        }


    }

    return( Err );
}




NET_API_STATUS
NET_API_FUNCTION
NetUnregisterDomainNameChangeNotification(
    HANDLE NotificationEventHandle
    )
/*++

Routine Description:

    This function is used to unregister a previously registered notification
    for a domain name change.

    The input handle is closed.

Arguments:

    NotificationHandle - The notification event handle to unregister


Return Value:

    NERR_Success - Success

    ERROR_INVALID_PARAMETER - A NULL NotificationEventHandle was given


--*/
{
    NTSTATUS Status;
    DWORD Err = NERR_Success;

    //
    // Parameter check
    //
    if ( NotificationEventHandle == NULL ) {

        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Unregister the event
    //
    Status = LsaUnregisterPolicyChangeNotification( PolicyNotifyDnsDomainInformation,
                                                    NotificationEventHandle );

    Err = NetpNtStatusToApiStatus( Status );

    //
    // If the unregister was successful, close the event handle
    //
    if ( Err == NERR_Success ) {

        CloseHandle( NotificationEventHandle );

    }


    return( Err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\dosprint\dosprint.c ===
/*++

Copyright (c) 1991-1993 Microsoft Corporation

Module Name:

    dosprint.c

Abstract:

    This module provides the ANSI mapping layer from the old DosPrint APIs to
    the new all singing all dancing beautiful Print APIs.  (The UNICODE mapping
    layer is in DosPrtW.c in this directory.)

Author:

    Dave Snipp (DaveSn) 26-Apr-1991

Revision History:

    09-Jul-1992 JohnRo
        RAID 10324: net print vs. UNICODE.
        Fixed many wrong error codes.
        Use PREFIX_ equates.
        Use offsetof() as provided by implmentation, not our own (nonportable).
        Made changes suggested by PC-LINT, including one bug fix.
    03-Oct-1992 JohnRo
        RAID 3556: DosPrintQGetInfo(from downlevel) level 3, rc=124. (4&5 too.)
        RAID 8333: view printer queues hangs DOS LM enh client.
        Make sure data type in job level 1 is null terminated.
        Fixed job submitted times.
        Fixed DosPrintQEnumA level 5 array bug.
        Fixed DosPrintJobEnumA levels 2 and 3.
        Also implemented DosPrintJobGetInfo levels 0, 1, and 3.
        Fixed bug calling OpenPrinter with wrong char set here and there.
        Fixed job comment field (was set to document by mistake).
        Fixed error code if GlobalAlloc fails.
        Avoid compiler warnings due to new winspool.h.
    04-Dec-1992 JohnRo
        RAID 1661: downlevel to NT DosPrintDestEnum not supported.
        Added code to track down empty queue name.
        Quiet normal debug output.
        Avoid const vs. volatile compiler warnings.
        Avoid new compiler warnings.
        Made changes suggested by PC-LINT 5.0
    08-Feb-1993 JohnRo
        RAID 10164: Data misalignment error during XsDosPrintQGetInfo().
    22-Mar-1993 JohnRo
        RAID 2974: NET PRINT says NT printer is held when it isn't.
        DosPrint API cleanup: reduced this file to just ANSI wrappers.
        Made more changes suggested by PC-LINT 5.0
        Added some IN and OUT keywords.
        Clarified many debug messages.
    07-Apr-1993 JohnRo
        RAID 5670: "NET PRINT \\server\share" gives err 124 (bad level) on NT.
    11-May-1993 JohnRo
        RAID 9942: workaround Windows For Workgroups (WFW) bug in DosPrintQEnum.
        Also fixed "NET PRINT \\server\share" and "NET SHARE printshare /DEL"
        GP faults.

--*/


#define NOMINMAX
#define NOSERVICE       // Avoid <winsvc.h> vs. <lmsvc.h> conflicts.
#include <windows.h>

#include <lmcons.h>

#include <dosprint.h>   // My prototypes.
#include <dosprtp.h>    // My prototypes.
#include <lmapibuf.h>   // NetApiBufferFree(), etc.
#include <netdebug.h>   // DBGSTATIC, NetpKdPrint(()), etc.
#include <prefix.h>     // PREFIX_ equates.
#include <stddef.h>     // offsetof().
#include <string.h>     // memcpy(), strncpy().
#include <tstring.h>    // NetpAlloc{type}From{type}.
#include <winerror.h>   // NO_ERROR, ERROR_ equates.
#include "convprt.h"    // Netp* print helpers


#define MAX_WORD        (  (WORD) (~0) )


SPLERR SPLENTRY DosPrintQGetInfoA(
    IN LPSTR    pszServer OPTIONAL,
    IN LPSTR    pszQueueName,
    IN WORD     uLevel,
    OUT PBYTE   pbBuf,
    IN WORD     cbBuf,
    OUT PUSHORT pcbNeeded
    )
{
    DWORD   cbBufW;
    DWORD   rc;
    USHORT  cbNeeded;
    LPWSTR  QueueNameW = NULL;
    LPWSTR  ServerNameW = NULL;
    LPVOID  TempBufferW = NULL;

    QueueNameW = NetpAllocWStrFromStr( pszQueueName );
    if (QueueNameW == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    // Compute wide buff size.
    cbBufW = cbBuf * sizeof(WCHAR);
    if ( cbBufW > (DWORD) MAX_WORD ) {
        cbBufW = (DWORD) MAX_WORD;
    }

    rc = NetApiBufferAllocate(
            cbBuf * sizeof(WCHAR),
            (LPVOID *) (LPVOID) &TempBufferW );
    if (rc != NO_ERROR) {
        goto Cleanup;
    }

    //
    // Process the API (locally or remotely) and get results (with
    // UNICODE strings).
    //
    rc = DosPrintQGetInfoW(
            ServerNameW,
            QueueNameW,
            uLevel,
            TempBufferW,
            (WORD) cbBufW,
            (PUSHORT) &cbNeeded);
    *pcbNeeded = cbNeeded;  

    //
    // Convert results back from UNICODE.
    //
    if (rc == NO_ERROR) {
        LPBYTE StringAreaA = (LPBYTE)pbBuf + cbBuf;

        // Translate UNICODE strings back to ANSI.
        rc = NetpConvertPrintQCharSet(
                uLevel,
                FALSE,          // not add or setinfo API
                TempBufferW, // from info
                pbBuf,      // to info
                FALSE,      // no, don't convert to UNICODE.
                & StringAreaA );   // conv strings and update ptr

        if (rc == ERROR_MORE_DATA)
        {
            *pcbNeeded = (USHORT)cbBufW ; // Unicode call succeeded but no room to go
                                    // Ansi. we know the Unicode buffer size is
                                    // definitely good enough. This is temporary
                    // fix.
        }
    }

Cleanup:
    if (QueueNameW != NULL) {
        (VOID) NetApiBufferFree( QueueNameW );
    }
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }
    if (TempBufferW != NULL) {
        (VOID) NetApiBufferFree( TempBufferW );
    }
    return rc;
}


SPLERR SPLENTRY DosPrintJobGetInfoA(
    IN LPSTR    pszServer OPTIONAL,
    IN BOOL     bRemote,
    IN WORD     uJobId,
    IN WORD     uLevel,
    OUT PBYTE   pbBuf,
    IN WORD     cbBuf,
    OUT PUSHORT pcbNeeded
    )
{
    DWORD   cbBufW;
    DWORD   rc;
    USHORT  cbNeeded;
    LPWSTR  ServerNameW = NULL;
    LPVOID  TempBufferW = NULL;

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    // Compute wide buff size.
    cbBufW = cbBuf * sizeof(WCHAR);
    if ( cbBufW > (DWORD) MAX_WORD ) {
        cbBufW = (DWORD) MAX_WORD;
    }

    rc = NetApiBufferAllocate(
            cbBufW,
            (LPVOID *) (LPVOID) &TempBufferW );
    if (rc != NO_ERROR) {
        goto Cleanup;
    }

    // Process the API (local or remote) and get results (with UNICODE strings).
    rc = DosPrintJobGetInfoW(
            ServerNameW,
            bRemote,
            uJobId,
            uLevel,
            TempBufferW,
            (WORD) cbBufW,
            &cbNeeded);
    *pcbNeeded = cbNeeded;  

    if (rc == NO_ERROR) {
        LPBYTE StringAreaA = (LPBYTE)pbBuf + cbBuf;

        // Translate UNICODE strings back to ANSI.
        rc = NetpConvertPrintJobCharSet(
                uLevel,
                FALSE,          // not add or setinfo API
                TempBufferW, // from info
                pbBuf,      // to info
                FALSE,      // no, don't convert to UNICODE.
                & StringAreaA );   // conv strings and update ptr
    }

Cleanup:
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }
    if (TempBufferW != NULL) {
        (VOID) NetApiBufferFree( TempBufferW );
    }
    return (rc);
}

SPLERR SPLENTRY DosPrintJobDelA(
    LPSTR   pszServer,
    BOOL    bRemote,
    WORD    uJobId
)
{
    DWORD   rc;
    LPWSTR  ServerNameW = NULL;

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    rc = DosPrintJobDelW( ServerNameW, bRemote, uJobId );

Cleanup:
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }

    return (rc);
}

SPLERR SPLENTRY DosPrintJobContinueA(
    LPSTR   pszServer,
    BOOL    bRemote,
    WORD    uJobId
)
{
    DWORD   rc;
    LPWSTR  ServerNameW = NULL;

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    rc = DosPrintJobContinueW( ServerNameW, bRemote, uJobId );

Cleanup:
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }

    return (rc);
}

SPLERR SPLENTRY DosPrintJobPauseA(
    IN LPSTR pszServer,
    IN BOOL  bRemote,
    IN WORD  uJobId
    )
{
    DWORD   rc;
    LPWSTR  ServerNameW = NULL;

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    rc = DosPrintJobPauseW( ServerNameW, bRemote, uJobId );

Cleanup:
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }

    return rc;
}

SPLERR SPLENTRY DosPrintJobEnumA(
    IN LPSTR    pszServer OPTIONAL,
    IN LPSTR    pszQueueName,
    IN WORD     uLevel,
    OUT PBYTE   pbBuf,
    IN WORD     cbBuf,
    OUT PWORD   pcReturned,
    OUT PWORD   pcTotal
    )
{
    DWORD   cbBufW;
    DWORD   rc;
    LPWSTR  QueueNameW = NULL;
    LPWSTR  ServerNameW = NULL;
    LPVOID  TempBufferW = NULL;

    QueueNameW = NetpAllocWStrFromStr( pszQueueName );
    if (QueueNameW == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    // Compute wide buff size.
    cbBufW = cbBuf * sizeof(WCHAR);
    if ( cbBufW > (DWORD) MAX_WORD ) {
        cbBufW = (DWORD) MAX_WORD;
    }

    rc = NetApiBufferAllocate(
            cbBufW,
            (LPVOID *) (LPVOID) &TempBufferW );
    if (rc != NO_ERROR) {
        goto Cleanup;
    }

    // Process API (local/remote), get UNICODE results.
    rc = DosPrintJobEnumW(
            ServerNameW,
            QueueNameW,
            uLevel,
            TempBufferW,
            (WORD) cbBufW,
            pcReturned,
            pcTotal);

    if (rc == NO_ERROR) {
        LPBYTE StringAreaA = (LPBYTE)pbBuf + cbBuf;

        // Translate UNICODE strings back to ANSI.
        rc = NetpConvertPrintJobArrayCharSet(
                    uLevel,
                    FALSE,      // not add or setinfo API
                    TempBufferW, // from info
                    pbBuf,      // to info
                    FALSE,      // no, don't convert to UNICODE.
                    & StringAreaA,     // conv strings and update ptr
                    (DWORD) (*pcTotal) );
    }

Cleanup:
    if (QueueNameW != NULL) {
        (VOID) NetApiBufferFree( QueueNameW );
    }
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }
    if (TempBufferW != NULL) {
        (VOID) NetApiBufferFree( TempBufferW );
    }

    return (rc);
}


SPLERR SPLENTRY
DosPrintDestEnumA(
    IN LPSTR pszServer OPTIONAL,
    IN WORD uLevel,
    OUT PBYTE pbBuf,
    IN WORD cbBuf,
    OUT PUSHORT pcReturned,
    OUT PUSHORT pcTotal
    )
{
    DWORD   cbBufW;
    WORD    cReturned, cTotal;
    DWORD   rc;
    LPWSTR  ServerNameW = NULL;
    LPVOID  TempBufferW = NULL;

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    // Compute wide buff size.
    cbBufW = cbBuf * sizeof(WCHAR);
    if ( cbBufW > (DWORD) MAX_WORD ) {
        cbBufW = (DWORD) MAX_WORD;
    }

    rc = NetApiBufferAllocate(
            cbBufW,
            (LPVOID *) (LPVOID) &TempBufferW );
    if (rc != NO_ERROR) {
        goto Cleanup;
    }

    // Invoke wide-char version of API, which will do local or downlevel for us.
    rc = DosPrintDestEnumW(
            ServerNameW,
            uLevel,
            TempBufferW,
            (WORD) cbBufW,
            &cReturned,
            &cTotal);
    *pcReturned = (USHORT)cReturned;
    *pcTotal = (USHORT)cTotal;

    // Convert from wide chars for caller.
    if (rc == NO_ERROR) {
        LPBYTE StringAreaA = (LPBYTE)pbBuf + cbBuf;

        // Translate UNICODE strings back to ANSI.
        rc = NetpConvertPrintDestArrayCharSet(
                uLevel,
                FALSE,          // not add or setinfo API
                TempBufferW, // from info
                pbBuf,      // to info
                FALSE,      // no, don't convert to UNICODE.
                & StringAreaA,     // conv strings and update ptr
                cTotal );
    }

Cleanup:
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }
    if (TempBufferW != NULL) {
        (VOID) NetApiBufferFree( TempBufferW );
    }
    return (rc);
}

SPLERR SPLENTRY DosPrintDestControlA(
    IN LPSTR   pszServer OPTIONAL,
    IN LPSTR   pszDevName,
    IN WORD    uControl
    )
{
    LPWSTR  DestNameW = NULL;
    DWORD   rc;
    LPWSTR  ServerNameW = NULL;

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    DestNameW = NetpAllocWStrFromStr( pszDevName );
    if (DestNameW == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    rc = DosPrintDestControlW(ServerNameW, DestNameW, uControl);

Cleanup:
    if (DestNameW != NULL) {
        (VOID) NetApiBufferFree( DestNameW );
    }
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }
    return (rc);

} // DosPrintDestControlA


SPLERR SPLENTRY DosPrintDestGetInfoA(
    IN  LPSTR   pszServer OPTIONAL,
    IN  LPSTR   pszName,
    IN  WORD    uLevel,
    OUT PBYTE   pbBuf,
    IN  WORD    cbBuf,
    OUT PUSHORT pcbNeeded
    )
{
    DWORD   cbBufW;
    DWORD   rc;
    LPWSTR  DestNameW = NULL;
    LPWSTR  ServerNameW = NULL;
    LPVOID  TempBufferW = NULL;

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    DestNameW = NetpAllocWStrFromStr( pszName );
    if (DestNameW == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    // Compute wide buff size.
    cbBufW = cbBuf * sizeof(WCHAR);
    if ( cbBufW > (DWORD) MAX_WORD ) {
        cbBufW = (DWORD) MAX_WORD;
    }

    rc = NetApiBufferAllocate(
            cbBufW,
            (LPVOID *) (LPVOID) &TempBufferW );
    if (rc != NO_ERROR) {
        goto Cleanup;
    }

    // Process the API (local or remote) and get results (with UNICODE strings).
    rc = DosPrintDestGetInfoW(
            ServerNameW,
            DestNameW,
            uLevel,
            TempBufferW,
            (WORD) cbBufW,
            pcbNeeded);  

    if (rc == NO_ERROR) {  
        LPBYTE StringAreaA = (LPBYTE)pbBuf + cbBuf;

        // Translate UNICODE strings back to ANSI.
        rc = NetpConvertPrintDestCharSet(
                uLevel,
                FALSE,          // not add or setinfo API
                TempBufferW, // from info
                pbBuf,      // to info
                FALSE,      // no, don't convert to UNICODE.
                & StringAreaA );   // conv strings and update ptr
    }

Cleanup:
    if (DestNameW != NULL) {
        (VOID) NetApiBufferFree( DestNameW );
    }
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }
    if (TempBufferW != NULL) {
        (VOID) NetApiBufferFree( TempBufferW );
    }
    return (rc);
}

SPLERR SPLENTRY DosPrintDestAddA(
    IN LPSTR   pszServer OPTIONAL,
    IN WORD    uLevel,
    IN PBYTE   pbBuf,
    IN WORD    cbBuf
    )
{
    DWORD   cbBufW;
    DWORD   rc;
    LPWSTR  ServerNameW = NULL;
    LPBYTE  StringAreaW;
    LPVOID  TempBufferW = NULL;

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    // Compute wide buff size.
    cbBufW = cbBuf * sizeof(WCHAR);
    if ( cbBufW > (DWORD) MAX_WORD ) {
        cbBufW = (DWORD) MAX_WORD;
    }

    rc = NetApiBufferAllocate(
            cbBufW,
            (LPVOID *) (LPVOID) &TempBufferW );
    if (rc != NO_ERROR) {
        goto Cleanup;
    }

    StringAreaW = (LPBYTE)TempBufferW + cbBufW;

    rc = NetpConvertPrintDestCharSet(
            uLevel,
            TRUE,               // yes, is add or setinfo API
            pbBuf,              // from info
            TempBufferW,        // to info
            TRUE,               // yes, convert to UNICODE.
            & StringAreaW );    // conv strings and update ptr
    if (rc != NO_ERROR) {
        goto Cleanup;
    }

    rc = DosPrintDestAddW(
            ServerNameW,
            uLevel,
            TempBufferW,
            (WORD) cbBufW);


Cleanup:
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }
    if (TempBufferW != NULL) {
        (VOID) NetApiBufferFree( TempBufferW );
    }
    return (rc);
}


SPLERR SPLENTRY DosPrintDestSetInfoA(
    IN LPSTR   pszServer OPTIONAL,
    IN LPSTR   pszName,
    IN WORD    uLevel,
    IN PBYTE   pbBuf,
    IN WORD    cbBuf,
    IN WORD    uParmNum
    )
{
    DWORD   cbBufW;
    LPWSTR  DestNameW = NULL;
    DWORD   rc;
    LPWSTR  ServerNameW = NULL;
    LPBYTE  StringAreaW;
    LPVOID  TempBufferW = NULL;

    if (pszServer && *pszServer) {

        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    DestNameW = NetpAllocWStrFromStr( pszName );
    if (DestNameW == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    // Compute wide buff size.
    cbBufW = cbBuf * sizeof(WCHAR);
    if ( cbBufW > (DWORD) MAX_WORD ) {
        cbBufW = (DWORD) MAX_WORD;
    }

    rc = NetApiBufferAllocate(
            cbBufW,
            (LPVOID *) (LPVOID) &TempBufferW );
    if (rc != NO_ERROR) {
        goto Cleanup;
    }

    StringAreaW = (LPBYTE)TempBufferW + cbBufW;

    rc = NetpConvertPrintDestCharSet(
            uLevel,
            TRUE,               // yes, is add or setinfo API
            pbBuf,              // from info
            TempBufferW,        // to info
            TRUE,               // yes, convert to UNICODE.
            & StringAreaW );    // conv strings and update ptr
    if (rc != NO_ERROR) {
        goto Cleanup;
    }

    rc = DosPrintDestSetInfoW(
            ServerNameW,
            DestNameW,
            uLevel,
            TempBufferW,
            (WORD) cbBufW,
            uParmNum);

Cleanup:
    if (DestNameW != NULL) {
        (VOID) NetApiBufferFree( DestNameW );
    }
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }
    if (TempBufferW != NULL) {
        (VOID) NetApiBufferFree( TempBufferW );
    }
    return (rc);
}

SPLERR SPLENTRY DosPrintDestDelA(
    IN LPSTR   pszServer OPTIONAL,
    IN LPSTR   pszPrinterName
    )
{
    LPWSTR  PrinterNameW = NULL;
    DWORD   rc;
    LPWSTR  ServerNameW = NULL;

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    PrinterNameW = NetpAllocWStrFromStr( pszPrinterName );
    if (PrinterNameW == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    rc = DosPrintDestDelW(
            ServerNameW,
            PrinterNameW);

Cleanup:
    if (PrinterNameW != NULL) {
        (VOID) NetApiBufferFree( PrinterNameW );
    }
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }
    return (rc);
}

SPLERR SPLENTRY DosPrintQEnumA(
    IN LPSTR    pszServer OPTIONAL,
    IN WORD     uLevel,
    OUT PBYTE   pbBuf,
    IN WORD     cbBuf,
    OUT PUSHORT pcReturned,
    OUT PUSHORT pcTotal
    )
{
    DWORD   cbBufW;
    DWORD   rc;
    LPWSTR  ServerNameW = NULL;
    LPVOID  TempBufferW = NULL;  // queue structure with UNICODE strings.

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    // Compute wide buff size.
    cbBufW = cbBuf * sizeof(WCHAR);
    if ( cbBufW > (DWORD) MAX_WORD ) {
        cbBufW = (DWORD) MAX_WORD;
    }

    rc = NetApiBufferAllocate(
            cbBufW,
            (LPVOID *) (LPVOID) &TempBufferW );
    if (rc != NO_ERROR) {
        goto Cleanup;
    }

    // Process local/remote, get UNICODE results.
    rc = DosPrintQEnumW(
            ServerNameW,
            uLevel,
            TempBufferW,
            (WORD) cbBufW,
            pcReturned,
            pcTotal);

    // Convert back to UNICODE.
    if (rc == NO_ERROR) {
        LPBYTE StringAreaA = (LPBYTE)pbBuf + cbBuf;
        rc = (DWORD) NetpConvertPrintQArrayCharSet(
            uLevel,
            FALSE,              // not add or setinfo API
            TempBufferW,        // from info
            pbBuf,              // to info
            FALSE,              // no, not converting to UNICODE
            &StringAreaA,       // string area; update ptr
            *pcReturned );      // Q count

    }


Cleanup:

    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }
    if (TempBufferW != NULL) {
        (VOID) NetApiBufferFree( TempBufferW );
    }


    return (rc);
}

SPLERR SPLENTRY DosPrintQSetInfoA(
    IN LPSTR   pszServer OPTIONAL,
    IN LPSTR   pszQueueName,
    IN WORD    uLevel,
    IN PBYTE   pbBuf,
    IN WORD    cbBuf,
    IN WORD    uParmNum
    )
{
    DWORD   cbBufW;
    LPWSTR  QueueNameW = NULL;
    DWORD   rc;
    LPWSTR  ServerNameW = NULL;
    LPBYTE  StringAreaW;
    LPVOID  TempBufferW = NULL;

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    QueueNameW = NetpAllocWStrFromStr( pszQueueName );
    if (QueueNameW == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    // Compute wide buff size.
    cbBufW = cbBuf * sizeof(WCHAR);
    if ( cbBufW > (DWORD) MAX_WORD ) {
        cbBufW = (DWORD) MAX_WORD;
    }

    rc = NetApiBufferAllocate(
            cbBufW,
            (LPVOID *) (LPVOID) &TempBufferW );
    if (rc != NO_ERROR) {
        goto Cleanup;
    }

    StringAreaW = (LPBYTE)TempBufferW + cbBufW;

    rc = NetpConvertPrintQCharSet(
            uLevel,
            TRUE,               // yes, is add or setinfo API
            pbBuf,              // from info
            TempBufferW,        // to info
            TRUE,               // yes, convert to UNICODE.
            & StringAreaW );    // conv strings and update ptr
    if (rc != NO_ERROR) {
        goto Cleanup;
    }

    rc = DosPrintQSetInfoW(
            ServerNameW,
            QueueNameW,
            uLevel,
            TempBufferW,
            (WORD) cbBufW,
            uParmNum);

Cleanup:
    if (QueueNameW != NULL) {
        (VOID) NetApiBufferFree( QueueNameW );
    }
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }
    if (TempBufferW != NULL) {
        (VOID) NetApiBufferFree( TempBufferW );
    }
    return (rc);
}

SPLERR SPLENTRY DosPrintQPauseA(
    IN LPSTR   pszServer OPTIONAL,
    IN LPSTR   pszQueueName
    )
{
    LPWSTR  QueueNameW = NULL;
    DWORD   rc;
    LPWSTR  ServerNameW = NULL;

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    QueueNameW = NetpAllocWStrFromStr( pszQueueName );
    if (QueueNameW == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    rc = DosPrintQPauseW(ServerNameW, QueueNameW);

Cleanup:
    if (QueueNameW != NULL) {
        (VOID) NetApiBufferFree( QueueNameW );
    }
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }
    return (rc);
}

SPLERR SPLENTRY DosPrintQContinueA(
    IN LPSTR   pszServer OPTIONAL,
    IN LPSTR   pszQueueName
    )
{
    LPWSTR  QueueNameW = NULL;
    DWORD   rc;
    LPWSTR  ServerNameW = NULL;

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    QueueNameW = NetpAllocWStrFromStr( pszQueueName );
    if (QueueNameW == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    rc = DosPrintQContinueW( ServerNameW, QueueNameW );

Cleanup:
    if (QueueNameW != NULL) {
        (VOID) NetApiBufferFree( QueueNameW );
    }
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }
    return (rc);
}

SPLERR SPLENTRY DosPrintQPurgeA(
    IN LPSTR   pszServer OPTIONAL,
    IN LPSTR   pszQueueName
    )
{
    LPWSTR  QueueNameW = NULL;
    DWORD   rc;
    LPWSTR  ServerNameW = NULL;

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    QueueNameW = NetpAllocWStrFromStr( pszQueueName );
    if (QueueNameW == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    rc = DosPrintQPurgeW(ServerNameW, QueueNameW);

Cleanup:
    if (QueueNameW != NULL) {
        (VOID) NetApiBufferFree( QueueNameW );
    }
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }
    return (rc);
}

SPLERR SPLENTRY DosPrintQAddA(
    IN LPSTR   pszServer OPTIONAL,
    IN WORD    uLevel,
    IN PBYTE   pbBuf,
    IN WORD    cbBuf
    )
{
    DWORD   cbBufW;
    DWORD   rc;
    LPWSTR  ServerNameW = NULL;
    LPBYTE  StringAreaW;
    LPVOID  TempBufferW = NULL;

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    // Compute wide buff size.
    cbBufW = cbBuf * sizeof(WCHAR);
    if ( cbBufW > (DWORD) MAX_WORD ) {
        cbBufW = (DWORD) MAX_WORD;
    }

    rc = NetApiBufferAllocate(
            cbBufW,
            (LPVOID *) (LPVOID) &TempBufferW );
    if (rc != NO_ERROR) {
        goto Cleanup;
    }

    StringAreaW = (LPBYTE)TempBufferW + cbBufW;

    rc = NetpConvertPrintQCharSet(
            uLevel,
            TRUE,               // yes, is add or setinfo API
            pbBuf,              // from info
            TempBufferW,        // to info
            TRUE,               // yes, convert to UNICODE.
            & StringAreaW );    // conv strings and update ptr
    if (rc != NO_ERROR) {
        goto Cleanup;
    }

    rc = DosPrintQAddW(
            ServerNameW,
            uLevel,
            TempBufferW,
            (WORD) cbBufW );

Cleanup:
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }
    if (TempBufferW != NULL) {
        (VOID) NetApiBufferFree( TempBufferW );
    }
    return (rc);
}

SPLERR SPLENTRY DosPrintQDelA(
    IN LPSTR   pszServer OPTIONAL,
    IN LPSTR   pszQueueName
    )
{
    LPWSTR  QueueNameW = NULL;
    DWORD   rc;
    LPWSTR  ServerNameW = NULL;

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    QueueNameW = NetpAllocWStrFromStr( pszQueueName );
    if (QueueNameW == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    rc = DosPrintQDelW(ServerNameW, QueueNameW);

Cleanup:
    if (QueueNameW != NULL) {
        (VOID) NetApiBufferFree( QueueNameW );
    }
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }
    return (rc);
}

SPLERR SPLENTRY DosPrintJobSetInfoA(
    IN LPSTR   pszServer OPTIONAL,
    IN BOOL    bRemote,
    IN WORD    uJobId,
    IN WORD    uLevel,
    IN PBYTE   pbBuf,
    IN WORD    cbBuf,
    IN WORD    uParmNum
    )
{
    DWORD   cbBufW;
    DWORD   rc;
    LPWSTR  ServerNameW = NULL;
    LPBYTE  StringAreaW;
    LPVOID  TempBufferW = NULL;  // job structure with UNICODE strings.

    if (pszServer && *pszServer) {
        ServerNameW = NetpAllocWStrFromStr( pszServer );
        if (ServerNameW == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    // Compute wide buff size.
    cbBufW = cbBuf * sizeof(WCHAR);
    if ( cbBufW > (DWORD) MAX_WORD ) {
        cbBufW = (DWORD) MAX_WORD;
    }

    rc = NetApiBufferAllocate(
            cbBufW,
            (LPVOID *) (LPVOID) &TempBufferW );
    if (rc != NO_ERROR) {
        goto Cleanup;
    }

    StringAreaW = (LPBYTE)TempBufferW + cbBufW;

    // Translate ANSI strings to UNICODE.
    rc = NetpConvertPrintJobCharSet(
            uLevel,
            TRUE,           // yes, is add or setinfo API
            TempBufferW, // from info
            pbBuf,      // to info
            TRUE,       // yes, convert to UNICODE.
            & StringAreaW );   // conv strings and update ptr
    if (rc != NO_ERROR) {
        goto Cleanup;
    }

    // Process the actual API.
    rc = DosPrintJobSetInfoW(
            ServerNameW,
            bRemote,
            uJobId,
            uLevel,
            TempBufferW,
            (WORD) cbBufW,
            uParmNum);

Cleanup:
    if (ServerNameW != NULL) {
        (VOID) NetApiBufferFree( ServerNameW );
    }
    if (TempBufferW != NULL) {
        (VOID) NetApiBufferFree( TempBufferW );
    }
    return (rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\api\svcstats.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    SvcStats.c

Abstract:

    Contains Net statistics routines for net DLL:

        NetStatisticsGet

Author:

    Richard L Firth (rfirth) 12-05-1991

Revision History:

    21-Jan-1992 rfirth
        Call wrapper routines, not rpc client-side stubs

    12-05-1991 rfirth
        Created

--*/

#include <windows.h>
#include <lmcons.h>
#include <lmstats.h>
#include <lmsname.h>
#include <tstring.h>
#include <netstats.h>   // private statistics routines in server and wksta services



NET_API_STATUS
NET_API_FUNCTION
NetStatisticsGet(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Service,
    IN  DWORD   Level,
    IN  DWORD   Options,
    OUT LPBYTE* Buffer
    )

/*++

Routine Description:

    Returns statistics to the caller from the specified service. Only SERVER
    and WORKSTATION are currently supported.

Arguments:

    ServerName  - where to run this API
    Service     - name of service to get stats from
    Level       - of information required. MBZ
    Options     - various flags. Currently, only bit 0 (clear) is supported
    Buffer      - pointer to pointer to returned buffer

Return Value:

    NET_API_STATUS
        Success - NERR_Success

        Failure - ERROR_INVALID_LEVEL
                    Level not 0

                  ERROR_INVALID_PARAMETER
                    Unsupported options requested

                  ERROR_NOT_SUPPORTED
                    Service is not SERVER or WORKSTATION

                  ERROR_ACCESS_DENIED
                    Caller doesn't have necessary access rights for request

--*/

{
    //
    // set the caller's buffer pointer to known value. This will kill the
    // calling app if it gave us a bad pointer and didn't use try...except
    //

    *Buffer = NULL;

    //
    // leave other parameter validation to specific stats function
    //

    if (!STRICMP(Service, SERVICE_WORKSTATION)) {
        return NetWkstaStatisticsGet(ServerName, Level, Options, Buffer);
    } else if (!STRICMP(Service, SERVICE_SERVER)) {
        return NetServerStatisticsGet(ServerName, Level, Options, Buffer);
    } else {
        return ERROR_NOT_SUPPORTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\dosprint\convprt.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    ConvPrt.c

Abstract:

    This module contains:

        NetpConvertPrintDestArrayCharSet
        NetpConvertPrintDestCharSet
        NetpConvertPrintJobArrayCharSet
        NetpConvertPrintJobCharSet
        NetpConvertPrintQArrayCharSet
        NetpConvertPrintQCharSet

    This routines may be used for UNICODE-to-ANSI conversion, or
    ANSI-to-UNICODE conversion.  The routines assume the structures are
    in native format for both input and output.

Author:

    Jonathan Schwartz (JSchwart)  01-Feb-2001

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    Beware that many of the parameters to the functions in this file
    are implicitly used by the various COPY_ and CONVERT_ macros:

        IN LPVOID FromInfo
        OUT LPVOID ToInfo
        IN BOOL ToUnicode
        IN OUT LPBYTE * ToStringAreaPtr

Revision History:

    01-Feb-2001 JSchwart
        Created.
--*/

NET_API_STATUS
NetpConvertPrintDestCharSet(
    IN     DWORD    Level,
    IN     BOOL     AddOrSetInfoApi,
    IN     LPVOID   FromInfo,
    OUT    LPVOID   ToInfo,
    IN     BOOL     ToUnicode,
    IN OUT LPBYTE * ToStringAreaPtr OPTIONAL
    );

NET_API_STATUS
NetpConvertPrintDestArrayCharSet(
    IN     DWORD    Level,
    IN     BOOL     AddOrSetInfoApi,
    IN     LPVOID   FromInfo,
    OUT    LPVOID   ToInfo,
    IN     BOOL     ToUnicode,
    IN OUT LPBYTE * ToStringAreaPtr OPTIONAL,
    IN     DWORD    DestCount
    );

NET_API_STATUS
NetpConvertPrintJobCharSet(
    IN     DWORD    Level,
    IN     BOOL     AddOrSetInfoApi,
    IN     LPVOID   FromInfo,
    OUT    LPVOID   ToInfo,
    IN     BOOL     ToUnicode,
    IN OUT LPBYTE * ToStringAreaPtr OPTIONAL
    );

NET_API_STATUS
NetpConvertPrintJobArrayCharSet(
    IN     DWORD    Level,
    IN     BOOL     AddOrSetInfoApi,
    IN     LPVOID   FromInfo,
    OUT    LPVOID   ToInfo,
    IN     BOOL     ToUnicode,
    IN OUT LPBYTE * ToStringAreaPtr OPTIONAL,
    IN     DWORD    JobCount
    );

NET_API_STATUS
NetpConvertPrintQArrayCharSet(
    IN     DWORD    Level,
    IN     BOOL     AddOrSetInfoApi,
    IN     LPVOID   FromInfo,
    OUT    LPVOID   ToInfo,
    IN     BOOL     ToUnicode,
    IN OUT LPBYTE * ToStringAreaPtr OPTIONAL,
    IN     DWORD    QCount
    );

NET_API_STATUS
NetpConvertPrintQCharSet(
    IN     DWORD    Level,
    IN     BOOL     AddOrSetInfoApi,
    IN     LPVOID   FromInfo,
    OUT    LPVOID   ToInfo,
    IN     BOOL     ToUnicode,
    IN OUT LPBYTE * ToStringAreaPtr OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\dosprint\convprt.c ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    ConvPrt.c

Abstract:

    This module contains:

        NetpConvertPrintDestArrayCharSet
        NetpConvertPrintDestCharSet
        NetpConvertPrintJobArrayCharSet
        NetpConvertPrintJobCharSet
        NetpConvertPrintQArrayCharSet
        NetpConvertPrintQCharSet

    This routines may be used for UNICODE-to-ANSI conversion, or
    ANSI-to-UNICODE conversion.  The routines assume the structures are
    in native format for both input and output.

Author:

    John Rogers (JohnRo) 20-Jul-1992

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    Beware that many of the parameters to the functions in this file
    are implicitly used by the various COPY_ and CONVERT_ macros:

        IN LPVOID FromInfo
        OUT LPVOID ToInfo
        IN BOOL ToUnicode
        IN OUT LPBYTE * ToStringAreaPtr

Revision History:

    20-Jul-1992 JohnRo
        Created for RAID 10324: net print vs. UNICODE.
    16-Dec-1992 JohnRo
        DosPrint API cleanup.
        Allow use of these routines for setinfo APIs.
        Added NetpConvertPrintQArrayCharSet.
    07-Apr-1993 JohnRo
        RAID 5670: "NET PRINT \\server\share" gives err 124 (bad level) on NT.
    14-Apr-1993 JohnRo
        RAID 6167: avoid _access violation or assert with WFW print server.

    01-Feb-2001 JSchwart
        Moved from netlib

--*/

// These must be included first:

#include <nt.h>         // NTSTATUS
#include <ntrtl.h>      // RtlUnicodeToOemN
#include <windef.h>     // IN, DWORD, etc.
#include <lmcons.h>     // NET_API_STATUS.

// These may be included in any order:

#include <align.h>      // POINTER_IS_ALIGNED(), ALIGN_ equates.
#include <debuglib.h>   // IF_DEBUG().
#include <netdebug.h>   // NetpAssert(), NetpKdPrint(()), etc.
#include <prefix.h>     // PREFIX_ equates.
#include <string.h>     // memcpy().
#include <strucinf.h>   // My prototypes.
#include <tstring.h>    // NetpCopy{type}To{type}().
#include <rxprint.h>    // Print structures
#include "convprt.h"    // Prototypes
#include "dosprtp.h"    // NetpIsPrintQLevelValid


VOID
NetpCopyWStrToStrDBCSN(
    OUT LPSTR  Dest,            // string in default LAN codepage
    IN  LPWSTR Src,
    IN  DWORD MaxStringSize
    );


#define COPY_DWORD( typedefRoot, fieldName ) \
    { \
        if (ToUnicode) { \
            P ## typedefRoot ## A srcStruct = FromInfo; \
            P ## typedefRoot ## W destStruct = ToInfo; \
            NetpAssert( sizeof( destStruct->fieldName ) == sizeof( DWORD ) ); \
            NetpAssert( sizeof(  srcStruct->fieldName ) == sizeof( DWORD ) ); \
            destStruct->fieldName = srcStruct->fieldName; \
        } else { \
            P ## typedefRoot ## W srcStruct = FromInfo; \
            P ## typedefRoot ## A destStruct = ToInfo; \
            NetpAssert( sizeof( destStruct->fieldName ) == sizeof( DWORD ) ); \
            NetpAssert( sizeof(  srcStruct->fieldName ) == sizeof( DWORD ) ); \
            destStruct->fieldName = srcStruct->fieldName; \
        } \
    }

#define COPY_WORD( typedefRoot, fieldName ) \
    { \
        if (ToUnicode) { \
            P ## typedefRoot ## A srcStruct = FromInfo; \
            P ## typedefRoot ## W destStruct = ToInfo; \
            NetpAssert( sizeof( destStruct->fieldName ) == sizeof( WORD ) ); \
            NetpAssert( sizeof(  srcStruct->fieldName ) == sizeof( WORD ) ); \
            destStruct->fieldName = srcStruct->fieldName; \
        } else { \
            P ## typedefRoot ## W srcStruct = FromInfo; \
            P ## typedefRoot ## A destStruct = ToInfo; \
            NetpAssert( sizeof( destStruct->fieldName ) == sizeof( WORD ) ); \
            NetpAssert( sizeof(  srcStruct->fieldName ) == sizeof( WORD ) ); \
            destStruct->fieldName = srcStruct->fieldName; \
        } \
    }

#define COPY_FIXED_PART_WITHOUT_STRUCT( dataType ) \
    { \
        (VOID) memcpy( \
                ToInfo,   /* dest */ \
                FromInfo, /* src */ \
                sizeof( dataType ) );  /* size */ \
    }

#define CONVERT_CHAR_ARRAY( typedefRoot, fieldName ) \
    { \
        if (ToUnicode) { \
            P ## typedefRoot ## A structA = FromInfo; \
            P ## typedefRoot ## W structW = ToInfo; \
            NetpCopyStrToWStr( \
                    structW->fieldName,  /* dest */ \
                    structA->fieldName); /* src */ \
        } else { \
            P ## typedefRoot ## A structA = ToInfo; \
            P ## typedefRoot ## W structW = FromInfo; \
            NetpCopyWStrToStrDBCSN( \
                    structA->fieldName,         /* dest */ \
                    structW->fieldName,         /* src */ \
                    sizeof(structA->fieldName));/*max bytes to copy*/ \
        } \
    }

#define CONVERT_OPTIONAL_STRING( typedefRoot, fieldName ) \
    { \
        NetpAssert( ToStringAreaPtr != NULL ); \
        NetpAssert( (*ToStringAreaPtr) != NULL ); \
        if (ToUnicode) { \
            P ## typedefRoot ## A structA = FromInfo; \
            P ## typedefRoot ## W structW = ToInfo; \
            LPSTR Src = structA->fieldName; \
            NetpAssert( POINTER_IS_ALIGNED(*ToStringAreaPtr, ALIGN_WCHAR) ); \
            if (Src == NULL) { \
                structW->fieldName = NULL; \
            } else { \
                LPWSTR Dest; \
                DWORD DestSize; \
                DestSize = (strlen(Src)+1) * sizeof(WCHAR); \
                Dest = (LPVOID) ( (*ToStringAreaPtr) - DestSize ); \
                *ToStringAreaPtr = (LPVOID) Dest; \
                structW->fieldName = Dest; \
                NetpCopyStrToWStr( Dest, Src ); \
            } \
        } else { \
            P ## typedefRoot ## W structW = FromInfo; \
            P ## typedefRoot ## A structA = ToInfo; \
            LPWSTR Src = structW->fieldName; \
            if (Src == NULL) { \
                structA->fieldName = NULL; \
            } else { \
                LPSTR Dest; \
                DWORD DestSize; \
                DestSize = (NetpUnicodeToDBCSLen(Src)+1); \
                Dest = (LPVOID) ( (*ToStringAreaPtr) - DestSize ); \
                *ToStringAreaPtr = (LPVOID) Dest; \
                structA->fieldName = Dest; \
                NetpCopyWStrToStrDBCS( Dest, Src ); \
            } \
        } \
    }

#define CONVERT_OPTIONAL_STRING_TO_REQ( typedefRoot, fieldName ) \
    { \
        NetpAssert( ToStringAreaPtr != NULL ); \
        NetpAssert( (*ToStringAreaPtr) != NULL ); \
        if (ToUnicode) { \
            P ## typedefRoot ## A structA = FromInfo; \
            P ## typedefRoot ## W structW = ToInfo; \
            LPWSTR Dest; \
            DWORD DestSize; \
            LPSTR Src = structA->fieldName; \
            NetpAssert( POINTER_IS_ALIGNED(*ToStringAreaPtr, ALIGN_WCHAR) ); \
            if (Src == NULL) { \
                Src = ""; \
            } \
            DestSize = (strlen(Src)+1) * sizeof(WCHAR); \
            Dest = (LPVOID) ( (*ToStringAreaPtr) - DestSize ); \
            *ToStringAreaPtr = (LPVOID) Dest; \
            structW->fieldName = Dest; \
            NetpCopyStrToWStr( Dest, Src ); \
        } else { \
            P ## typedefRoot ## A structA = ToInfo; \
            P ## typedefRoot ## W structW = FromInfo; \
            LPSTR Dest; \
            DWORD DestSize; \
            LPWSTR Src = structW->fieldName; \
            if (Src == NULL) { \
                Src = L""; \
            } \
            DestSize = (NetpUnicodeToDBCSLen(Src)+1); \
            Dest = (LPVOID) ( (*ToStringAreaPtr) - DestSize ); \
            *ToStringAreaPtr = (LPVOID) Dest; \
            structA->fieldName = Dest; \
            NetpCopyWStrToStrDBCS( Dest, Src ); \
        } \
    }

#define CONVERT_CHAR_ARRAY_WITHOUT_STRUCT( ) \
    { \
        if (ToUnicode) { \
            NetpCopyStrToWStr( ToInfo, FromInfo ); \
        } else { \
            NetpCopyWStrToStrDBCS( ToInfo, FromInfo ); \
        } \
    }

#define CONVERT_CHAR_PTR_WITHOUT_STRUCT( ) \
    { \
        if (ToUnicode) { \
            NetpCopyStrToWStr( ToInfo, FromInfo ); \
        } else { \
            NetpCopyWStrToStrDBCS( ToInfo, FromInfo ); \
        } \
    }

NET_API_STATUS
NetpConvertPrintDestCharSet(
    IN     DWORD    Level,
    IN     BOOL     AddOrSetInfoApi,
    IN     LPVOID   FromInfo,
    OUT    LPVOID   ToInfo,
    IN     BOOL     ToUnicode,
    IN OUT LPBYTE * ToStringAreaPtr OPTIONAL
    )
{
    IF_DEBUG( CONVPRT ) {
        NetpKdPrint(( PREFIX_NETLIB "NetpConvertPrintDestCharSet: "
                "level " FORMAT_DWORD ":\n", Level ));
    }

    if ( (FromInfo == NULL) || (ToInfo == NULL) ) {
        return (ERROR_INVALID_PARAMETER);
    }

    switch (Level) {

    case 0 :
        //
        // No structure for this level.
        // Only field is name, which is in the fixed part itself.
        //
        CONVERT_CHAR_ARRAY_WITHOUT_STRUCT( );

        break;

    case 1 :
        CONVERT_CHAR_ARRAY(      PRDINFO, szName );
        CONVERT_CHAR_ARRAY(      PRDINFO, szUserName );
        COPY_WORD(               PRDINFO, uJobId );
        COPY_WORD(               PRDINFO, fsStatus );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRDINFO, pszStatus );
        COPY_WORD(               PRDINFO, time );

        break;

    case 2 :
        //
        // No structure for this level.
        // Only field is pointer to name.
        //
        CONVERT_CHAR_PTR_WITHOUT_STRUCT( );

        break;

    case 3 :
        CONVERT_OPTIONAL_STRING_TO_REQ( PRDINFO3, pszPrinterName );
        CONVERT_OPTIONAL_STRING( PRDINFO3, pszUserName );
        CONVERT_OPTIONAL_STRING( PRDINFO3, pszLogAddr );
        COPY_WORD(               PRDINFO3, uJobId );
        COPY_WORD(               PRDINFO3, fsStatus );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRDINFO3, pszStatus );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRDINFO3, pszComment );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRDINFO3, pszDrivers );
        COPY_WORD(               PRDINFO3, time );
        // No need to copy pad1.

        break;

    default :
        return (ERROR_INVALID_LEVEL);
    }

    return (NO_ERROR);

} // NetpConvertPrintDestCharSet


NET_API_STATUS
NetpConvertPrintDestArrayCharSet(
    IN     DWORD    Level,
    IN     BOOL     AddOrSetInfoApi,
    IN     LPVOID   FromInfo,
    OUT    LPVOID   ToInfo,
    IN     BOOL     ToUnicode,
    IN OUT LPBYTE * ToStringAreaPtr OPTIONAL,
    IN     DWORD    DestCount
    )
{
    NET_API_STATUS ApiStatus;
    DWORD DestsLeft;
    DWORD FromEntrySize, ToEntrySize;
    LPVOID FromDest = FromInfo;
    LPVOID ToDest   = ToInfo;

    if ( (FromInfo == NULL) || (ToInfo == NULL) ) {
        return (ERROR_INVALID_PARAMETER);
    }

    ApiStatus = NetpPrintDestStructureInfo (
            Level,
            PARMNUM_ALL,
            TRUE,              // yes, we want native sizes.
            AddOrSetInfoApi,
            (ToUnicode ? sizeof(CHAR) : sizeof(WCHAR) ),  // FROM char size
            NULL,              // don't need data desc 16
            NULL,              // don't need data desc 32
            NULL,              // don't need data desc SMB
            NULL,              // don't need max total size
            & FromEntrySize,   // yes, we want fixed entry size
            NULL );            // don't need string size
    if (ApiStatus != NO_ERROR) {
        return (ApiStatus);
    }
    NetpAssert( FromEntrySize > 0 );

    ApiStatus = NetpPrintDestStructureInfo (
            Level,
            PARMNUM_ALL,
            TRUE,              // yes, we want native sizes.
            AddOrSetInfoApi,
            (ToUnicode ? sizeof(WCHAR) : sizeof(CHAR) ),  // TO char size
            NULL,              // don't need data desc 16
            NULL,              // don't need data desc 32
            NULL,              // don't need data desc SMB
            NULL,              // don't need max total size
            & ToEntrySize,     // yes, we want fixed entry size
            NULL );            // don't need string size
    NetpAssert( ApiStatus == NO_ERROR );
    NetpAssert( ToEntrySize > 0 );

    for (DestsLeft = DestCount; DestsLeft>0; --DestsLeft) {

        ApiStatus = NetpConvertPrintDestCharSet(
                Level,   // info level (for print Dest APIs)
                AddOrSetInfoApi,
                FromDest,
                ToDest,
                ToUnicode,
                ToStringAreaPtr ); // update and move string area

        //
        // This can only fail because of bad parameters.  If that's
        // the case, every call in this loop will fail so bail out.
        //
        if (ApiStatus != NO_ERROR)
        {
            NetpAssert( ApiStatus == NO_ERROR );
            break;
        }

        FromDest = (((LPBYTE) FromDest) + FromEntrySize);
        ToDest   = (((LPBYTE) ToDest)   + ToEntrySize  );
    }

    return (NO_ERROR);

} // NetpConvertPrintDestArrayCharSet


NET_API_STATUS
NetpConvertPrintJobCharSet(
    IN     DWORD    Level,
    IN     BOOL     AddOrSetInfoApi,
    IN     LPVOID   FromInfo,
    OUT    LPVOID   ToInfo,
    IN     BOOL     ToUnicode,
    IN OUT LPBYTE * ToStringAreaPtr OPTIONAL
    )
{
    IF_DEBUG( CONVPRT ) {
        NetpKdPrint(( PREFIX_NETLIB "NetpConvertPrintJobCharSet: "
                "level " FORMAT_DWORD ":\n", Level ));
    }

    if ( (FromInfo == NULL) || (ToInfo == NULL) ) {
        return (ERROR_INVALID_PARAMETER);
    }

    switch (Level) {
    case 0 :
        COPY_FIXED_PART_WITHOUT_STRUCT( WORD );

        break;

    case 1 :
        COPY_WORD(               PRJINFO, uJobId );
        CONVERT_CHAR_ARRAY(      PRJINFO, szUserName );
        CONVERT_CHAR_ARRAY(      PRJINFO, szNotifyName );
        CONVERT_CHAR_ARRAY(      PRJINFO, szDataType );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRJINFO, pszParms );
        COPY_WORD(               PRJINFO, uPosition );
        COPY_WORD(               PRJINFO, fsStatus );
        CONVERT_OPTIONAL_STRING( PRJINFO, pszStatus );
        COPY_DWORD(              PRJINFO, ulSubmitted );
        COPY_DWORD(              PRJINFO, ulSize );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRJINFO, pszComment );

        break;

    case 2 :

        COPY_WORD(               PRJINFO2, uJobId );
        COPY_WORD(               PRJINFO2, uPriority );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRJINFO2, pszUserName );
        COPY_WORD(               PRJINFO2, uPosition );
        COPY_WORD(               PRJINFO2, fsStatus );
        COPY_DWORD(              PRJINFO2, ulSubmitted );
        COPY_DWORD(              PRJINFO2, ulSize );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRJINFO2, pszComment );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRJINFO2, pszDocument );

        break;

    case 3 :
        COPY_WORD(               PRJINFO3, uJobId );
        COPY_WORD(               PRJINFO3, uPriority );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRJINFO3, pszUserName );
        COPY_WORD(               PRJINFO3, uPosition );
        COPY_WORD(               PRJINFO3, fsStatus );
        COPY_DWORD(              PRJINFO3, ulSubmitted );
        COPY_DWORD(              PRJINFO3, ulSize );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRJINFO3, pszComment );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRJINFO3, pszDocument );
        CONVERT_OPTIONAL_STRING( PRJINFO3, pszNotifyName );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRJINFO3, pszDataType );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRJINFO3, pszParms );
        CONVERT_OPTIONAL_STRING( PRJINFO3, pszStatus );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRJINFO3, pszQueue );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRJINFO3, pszQProcName );
        CONVERT_OPTIONAL_STRING( PRJINFO3, pszDriverName );

#if DBG
        {
            if (ToUnicode) {
                PPRJINFO3A p3 = FromInfo;
                NetpAssert( p3->pDriverData == NULL );
            } else {
                PPRJINFO3W p3 = FromInfo;
                NetpAssert( p3->pDriverData == NULL );
            }
        }
#endif

        CONVERT_OPTIONAL_STRING( PRJINFO3, pszPrinterName );

        break;

    default :
        return (ERROR_INVALID_LEVEL);
    }

    return (NO_ERROR);

} // NetpConvertPrintJobCharSet


NET_API_STATUS
NetpConvertPrintJobArrayCharSet(
    IN     DWORD    Level,
    IN     BOOL     AddOrSetInfoApi,
    IN     LPVOID   FromInfo,
    OUT    LPVOID   ToInfo,
    IN     BOOL     ToUnicode,
    IN OUT LPBYTE * ToStringAreaPtr OPTIONAL,
    IN     DWORD    JobCount
    )
{
    NET_API_STATUS ApiStatus;
    DWORD FromEntrySize, ToEntrySize;
    LPVOID FromJob = FromInfo;   // job structure
    DWORD JobsLeft;
    LPVOID ToJob = ToInfo;   // job structure

    if ( (FromInfo == NULL) || (ToInfo == NULL) ) {
        return (ERROR_INVALID_PARAMETER);
    }

    ApiStatus = NetpPrintJobStructureInfo (
            Level,
            PARMNUM_ALL,
            TRUE,              // yes, we want native sizes.
            AddOrSetInfoApi,
            (ToUnicode ? sizeof(CHAR) : sizeof(WCHAR) ),  // FROM char size
            NULL,              // don't need data desc 16
            NULL,              // don't need data desc 32
            NULL,              // don't need data desc SMB
            NULL,              // don't need max total size
            & FromEntrySize,   // yes, we want fixed entry size
            NULL );            // don't need string size
    if (ApiStatus != NO_ERROR) {
        return (ApiStatus);
    }
    NetpAssert( FromEntrySize > 0 );

    ApiStatus = NetpPrintJobStructureInfo (
            Level,
            PARMNUM_ALL,
            TRUE,              // yes, we want native sizes.
            AddOrSetInfoApi,
            (ToUnicode ? sizeof(WCHAR) : sizeof(CHAR) ),  // TO char size
            NULL,              // don't need data desc 16
            NULL,              // don't need data desc 32
            NULL,              // don't need data desc SMB
            NULL,              // don't need max total size
            & ToEntrySize,     // yes, we want fixed entry size
            NULL );            // don't need string size
    NetpAssert( ApiStatus == NO_ERROR );
    NetpAssert( ToEntrySize > 0 );

    for (JobsLeft = JobCount; JobsLeft>0; --JobsLeft) {

        ApiStatus = NetpConvertPrintJobCharSet(
                Level,   // info level (for print job APIs)
                AddOrSetInfoApi,
                FromJob,
                ToJob,
                ToUnicode,
                ToStringAreaPtr ); // update and move string area

        //
        // This can only fail because of bad parameters.  If that's
        // the case, every call in this loop will fail so bail out.
        //
        if (ApiStatus != NO_ERROR)
        {
            NetpAssert( ApiStatus == NO_ERROR );
            break;
        }

        FromJob = (((LPBYTE) FromJob) + FromEntrySize);
        ToJob   = (((LPBYTE) ToJob  ) + ToEntrySize  );

        if ((LPBYTE)*ToStringAreaPtr < (LPBYTE)ToJob)
            return (ERROR_MORE_DATA) ;
    }

    return (NO_ERROR);

} // NetpConvertPrintJobArrayCharSet



NET_API_STATUS
NetpConvertPrintQCharSet(
    IN     DWORD    Level,
    IN     BOOL     AddOrSetInfoApi,
    IN     LPVOID   FromInfo,
    OUT    LPVOID   ToInfo,
    IN     BOOL     ToUnicode,
    IN OUT LPBYTE * ToStringAreaPtr OPTIONAL
    )
{
    NET_API_STATUS ApiStatus;
    DWORD FromEntrySize, ToEntrySize;

    IF_DEBUG( CONVPRT ) {
        NetpKdPrint(( PREFIX_NETLIB "NetpConvertPrintQCharSet: "
                "level " FORMAT_DWORD ":\n", Level ));
    }

    if ( (FromInfo == NULL) || (ToInfo == NULL) ) {
        return (ERROR_INVALID_PARAMETER);
    }

    ApiStatus = NetpPrintQStructureInfo (
            Level,
            PARMNUM_ALL,
            TRUE,              // yes, we want native sizes.
            AddOrSetInfoApi,
            (ToUnicode ? sizeof(WCHAR) : sizeof(CHAR) ),  // TO char size
            NULL,              // don't need data desc 16
            NULL,              // don't need data desc 32
            NULL,              // don't need data desc SMB
            NULL,              // don't need aux desc 16
            NULL,              // don't need aux desc 32
            NULL,              // don't need aux desc SMB
            NULL,              // don't need max total size
            & ToEntrySize,     // yes, we want fixed entry size
            NULL );            // don't need string size
    if (ApiStatus != NO_ERROR) {
        return (ApiStatus);
    }
    NetpAssert( ToEntrySize > 0 );

    ApiStatus = NetpPrintQStructureInfo (
            Level,
            PARMNUM_ALL,
            TRUE,              // yes, we want native sizes.
            AddOrSetInfoApi,
            (ToUnicode ? sizeof(CHAR) : sizeof(WCHAR) ),  // FROM char size
            NULL,              // don't need data desc 16
            NULL,              // don't need data desc 32
            NULL,              // don't need data desc SMB
            NULL,              // don't need aux desc 16
            NULL,              // don't need aux desc 32
            NULL,              // don't need aux desc SMB
            NULL,              // don't need max total size
            & FromEntrySize,     // yes, we want fixed entry size
            NULL );            // don't need string size
    NetpAssert( ApiStatus == NO_ERROR );
    NetpAssert( FromEntrySize > 0 );

    switch (Level) {

    case 0 :
        //
        // No structure for this level.
        // Only field is queue name, which is in the fixed part itself.
        //
        CONVERT_CHAR_ARRAY_WITHOUT_STRUCT( );

        break;

    case 1 :  /*FALLTHROUGH*/
    case 2 :

        CONVERT_CHAR_ARRAY(      PRQINFO, szName );
        // No need to copy pad1.
        COPY_WORD(               PRQINFO, uPriority );
        COPY_WORD(               PRQINFO, uStartTime );
        COPY_WORD(               PRQINFO, uUntilTime );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRQINFO, pszSepFile );
        CONVERT_OPTIONAL_STRING( PRQINFO, pszPrProc );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRQINFO, pszDestinations );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRQINFO, pszParms );
        CONVERT_OPTIONAL_STRING_TO_REQ( PRQINFO, pszComment );
        COPY_WORD(               PRQINFO, fsStatus );
        COPY_WORD(               PRQINFO, cJobs );

        if (Level == 2) {
            NET_API_STATUS ApiStatus;
            LPVOID FromArray, ToArray;  // job structures
            DWORD JobCount;

            if (ToUnicode) {
                PPRQINFOA pq = FromInfo;
                JobCount = pq->cJobs;
            } else {
                PPRQINFOW pq = FromInfo;
                JobCount = pq->cJobs;
            }

            FromArray = ( ((LPBYTE) FromInfo) + FromEntrySize );
            ToArray   = ( ((LPBYTE) ToInfo  ) + ToEntrySize   );

            ApiStatus = NetpConvertPrintJobArrayCharSet(
                    1,   // job info level
                    AddOrSetInfoApi,
                    FromArray,
                    ToArray,
                    ToUnicode,
                    ToStringAreaPtr,   // update and move string area
                    JobCount );
            if ( ApiStatus != NO_ERROR )
                return (ApiStatus) ;
        }

        break;

    case 3 :  /*FALLTHROUGH*/
    case 4 :

        {

            CONVERT_OPTIONAL_STRING_TO_REQ( PRQINFO3, pszName );
            COPY_WORD(               PRQINFO3, uPriority );
            COPY_WORD(               PRQINFO3, uStartTime );
            COPY_WORD(               PRQINFO3, uUntilTime );
            // No need to copy pad3.
            CONVERT_OPTIONAL_STRING_TO_REQ( PRQINFO3, pszSepFile );
            CONVERT_OPTIONAL_STRING( PRQINFO3, pszPrProc );
            CONVERT_OPTIONAL_STRING_TO_REQ( PRQINFO3, pszParms );
            CONVERT_OPTIONAL_STRING_TO_REQ( PRQINFO3, pszComment );
            COPY_WORD(               PRQINFO3, fsStatus );
            COPY_WORD(               PRQINFO3, cJobs );
            CONVERT_OPTIONAL_STRING( PRQINFO3, pszPrinters );
            CONVERT_OPTIONAL_STRING( PRQINFO3, pszDriverName );

#if DBG
            if (ToUnicode) {
                PPRQINFO3A pq = FromInfo;
                NetpAssert( pq->pDriverData == NULL );
            } else {
                PPRQINFO3W pq = FromInfo;
                NetpAssert( pq->pDriverData == NULL );
            }
#endif

            if (Level == 4) {

                NET_API_STATUS ApiStatus;
                LPVOID FromFirstJob,ToFirstJob;   // job structures
                DWORD JobCount;

                FromFirstJob = ( ((LPBYTE) FromInfo) + FromEntrySize );
                ToFirstJob   = ( ((LPBYTE) ToInfo  ) + ToEntrySize   );

                if (ToUnicode) {
                    PPRQINFO3A pq = FromInfo;
                    JobCount = pq->cJobs;
                } else {
                    PPRQINFO3W pq = FromInfo;
                    JobCount = pq->cJobs;
                }

                ApiStatus = NetpConvertPrintJobArrayCharSet(
                        2,  // job info level
                        AddOrSetInfoApi,
                        FromFirstJob,
                        ToFirstJob,
                        ToUnicode,
                        ToStringAreaPtr,
                        JobCount );

                NetpAssert( ApiStatus == NO_ERROR );
            }
        }

        break;


    case 5 :
        //
        // No structure for this level.
        // Only field is queue name, which is just a pointer in the fixed part.
        //
        CONVERT_CHAR_PTR_WITHOUT_STRUCT( );

        break;

    default :
        return (ERROR_INVALID_LEVEL);
    }

    return (NO_ERROR);

} // NetpConvertPrintQCharSet


NET_API_STATUS
NetpConvertPrintQArrayCharSet(
    IN     DWORD    QLevel,
    IN     BOOL     AddOrSetInfoApi,
    IN     LPVOID   FromInfo,
    OUT    LPVOID   ToInfo,
    IN     BOOL     ToUnicode,
    IN OUT LPBYTE * ToStringAreaPtr OPTIONAL,
    IN     DWORD    QCount
    )
{
    NET_API_STATUS ApiStatus;
    DWORD FromQEntrySize, ToQEntrySize;
    DWORD FromJobEntrySize, ToJobEntrySize;
    LPVOID FromQ = FromInfo;   // Q structure
    DWORD JobLevel;
    DWORD QsLeft;
    LPVOID ToQ = ToInfo;   // Q structure

    if ( (FromInfo == NULL) || (ToInfo == NULL) ) {
        return (ERROR_INVALID_PARAMETER);
    }

    ApiStatus = NetpPrintQStructureInfo (
            QLevel,
            PARMNUM_ALL,
            TRUE,              // yes, we want native sizes.
            AddOrSetInfoApi,
            (ToUnicode ? sizeof(CHAR) : sizeof(WCHAR) ),  // FROM char size
            NULL,              // don't need data desc 16
            NULL,              // don't need data desc 32
            NULL,              // don't need data desc SMB
            NULL,              // don't need aux desc 16
            NULL,              // don't need aux desc 32
            NULL,              // don't need aux desc SMB
            NULL,              // don't need max total size
            & FromQEntrySize,  // yes, we want fixed entry size
            NULL );            // don't need string size
    if (ApiStatus != NO_ERROR) {
        return (ApiStatus);
    }
    NetpAssert( FromQEntrySize > 0 );

    ApiStatus = NetpPrintQStructureInfo (
            QLevel,
            PARMNUM_ALL,
            TRUE,              // yes, we want native sizes.
            AddOrSetInfoApi,
            (ToUnicode ? sizeof(WCHAR) : sizeof(CHAR) ),  // TO char size
            NULL,              // don't need data desc 16
            NULL,              // don't need data desc 32
            NULL,              // don't need data desc SMB
            NULL,              // don't need aux desc 16
            NULL,              // don't need aux desc 32
            NULL,              // don't need aux desc SMB
            NULL,              // don't need max total size
            & ToQEntrySize,    // yes, we want fixed entry size
            NULL );            // don't need string size
    NetpAssert( ApiStatus == NO_ERROR );
    NetpAssert( ToQEntrySize > 0 );

    // Figure-out job-level associated with this queue info level.
    switch (QLevel) {
    case 2:
        JobLevel = 1;
        break;
    case 4:
        JobLevel = 2;
        break;
    default:
       // No jobs for this Q info level.
       JobLevel = (DWORD)-1;
    }

    if (JobLevel != (DWORD)-1) {
        ApiStatus = NetpPrintJobStructureInfo (
                JobLevel,
                PARMNUM_ALL,
                TRUE,              // yes, we want native sizes.
                AddOrSetInfoApi,
                (ToUnicode ? sizeof(CHAR) : sizeof(WCHAR) ),  // FROM char size
                NULL,              // don't need data desc 16
                NULL,              // don't need data desc 32
                NULL,              // don't need data desc SMB
                NULL,              // don't need max total size
                & FromJobEntrySize,    // yes, we want fixed entry size
                NULL );            // don't need string size
        NetpAssert( ApiStatus == NO_ERROR );
        NetpAssert( FromJobEntrySize > 0 );

        ApiStatus = NetpPrintJobStructureInfo (
                JobLevel,
                PARMNUM_ALL,
                TRUE,              // yes, we want native sizes.
                AddOrSetInfoApi,
                (ToUnicode ? sizeof(WCHAR) : sizeof(CHAR) ),  // TO char size
                NULL,              // don't need data desc 16
                NULL,              // don't need data desc 32
                NULL,              // don't need data desc SMB
                NULL,              // don't need max total size
                & ToJobEntrySize,    // yes, we want fixed entry size
                NULL );            // don't need string size
        NetpAssert( ApiStatus == NO_ERROR );
        NetpAssert( ToJobEntrySize > 0 );
    }

    for (QsLeft = QCount; QsLeft>0; --QsLeft) {

        DWORD JobCount;

        // Convert 1 queue structure and 0 or more job structures.
        ApiStatus = NetpConvertPrintQCharSet(
                QLevel,   // info level (for print Q APIs)
                AddOrSetInfoApi,
                FromQ,
                ToQ,
                ToUnicode,
                ToStringAreaPtr ); // update and move string area

        if (ApiStatus != NO_ERROR)
        {
            NetpAssert( ApiStatus == NO_ERROR);
            break;
        }

        // Bump pointers to start of next fixed queue structure.
        // To do this, we need to find out how many jobs there are.
        JobCount = NetpJobCountForQueue(
                QLevel,         // Q info level
                FromQ,          // Q fixed structure
                !ToUnicode );   // does input have UNICODE strings?

        // Bump past this queue structure.
        FromQ = (((LPBYTE) FromQ) + FromQEntrySize);
        ToQ   = (((LPBYTE) ToQ  ) + ToQEntrySize  );

        // Bump past jobs (if any).
        if (JobCount > 0) {
            NetpAssert( JobLevel != (DWORD)-1 );
            FromQ = ( ((LPBYTE) FromQ) + (FromJobEntrySize * JobCount) );
            ToQ   = ( ((LPBYTE) ToQ  ) + (ToJobEntrySize   * JobCount) );
        }

    }

    return (NO_ERROR);

} // NetpConvertPrintQArrayCharSet


VOID
NetpCopyWStrToStrDBCSN(
    OUT LPSTR  Dest,
    IN  LPWSTR Src,
    IN  DWORD  MaxBytesInString
    )

/*++

Routine Description:

    NetpCopyWStrToStr copies characters from a source string
    to a destination, converting as it copies them.

Arguments:

    Dest - is an LPSTR indicating where the converted characters are to go.
        This string will be in the default codepage for the LAN.

    Src - is in LPWSTR indicating the source string.

    MaxBytesInString - indicates the maximum number of bytes to copy

Return Value:

    None.

--*/

{
    NTSTATUS NtStatus;
    LONG Index;

    NetpAssert( Dest != NULL );
    NetpAssert( Src != NULL );
    NetpAssert( ((LPVOID)Dest) != ((LPVOID)Src) );
    NetpAssert( ROUND_UP_POINTER( Src, ALIGN_WCHAR ) == Src );

    NtStatus = RtlUnicodeToOemN(
        Dest,                             // Destination string
        MaxBytesInString-1,               // Destination string length
        &Index,                           // Last char in translated string
        Src,                              // Source string
        wcslen(Src)*sizeof(WCHAR)         // Length of source string
    );

    Dest[Index] = '\0';

    NetpAssert( NT_SUCCESS(NtStatus) );

} // NetpCopyWStrToStrDBCSN


DWORD
NetpJobCountForQueue(
    IN DWORD QueueLevel,
    IN LPVOID Queue,
    IN BOOL HasUnicodeStrings
    )
{
    NetpAssert( NetpIsPrintQLevelValid( QueueLevel, FALSE ) );
    NetpAssert( Queue != NULL );

    if (QueueLevel == 2) {
        if (HasUnicodeStrings) {
            PPRQINFOW pq = Queue;
            return (pq->cJobs);
        } else {
            PPRQINFOA pq = Queue;
            return (pq->cJobs);
        }
    } else if (QueueLevel == 4) {
        if (HasUnicodeStrings) {
            PPRQINFO3W pq = Queue;
            return (pq->cJobs);
        } else {
            PPRQINFO3A pq = Queue;
            return (pq->cJobs);
        }
    } else {
        return (0);
    }
    /*NOTREACHED*/

} // NetpJobCountForQueue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\dosprint\dosprtp.c ===
/*++

Copyright (c) 1992-1993 Microsoft Corporation

Module Name:

    DosPrtP.c

Abstract:

    This contains macros and prototypes private to the DosPrint APIs.

Author:

    John Rogers (JohnRo) 02-Oct-1992

Notes:

Revision History:

    02-Oct-1992 JohnRo
        Created for RAID 3556: DosPrintQGetInfo(from downlevel) level 3, rc=124.
        (4&5 too.)
    08-Feb-1993 JohnRo
        RAID 10164: Data misalignment error during XsDosPrintQGetInfo().
        DosPrint API cleanup: avoid const vs. volatile compiler warnings.
        Extracted job count routine to netlib for use by convprt.c stuff.
        Added some IN and OUT keywords.
    24-Mar-1993 JohnRo
        RAID 2974: NET PRINT says NT printer is held when it isn't.
    17-May-1993 JohnRo
        FindLocalJob() should use INVALID_HANDLE_VALUE for consistentcy.
        Use NetpKdPrint() where possible.
    29-Mar-1995 AlbertT
        Support for pause/resume/purge printer queue added.

--*/


#ifndef UNICODE
#error "RxPrint APIs assume RxRemoteApi uses wide characters."
#endif

#define NOMINMAX
#define NOSERVICE       // Avoid <winsvc.h> vs. <lmsvc.h> conflicts.
#include <windows.h>

#include <lmcons.h>     // NET_API_STATUS.
#include <netdebug.h>   // NetpKdPrint(), etc.

#ifdef _WINSPOOL_
#error "Include of winspool.h moved, make sure it doesn't get UNICODE."
#endif

#undef UNICODE
#undef TEXT
#define TEXT(quote) quote
#include <winspool.h>
#undef TEXT
#define TEXT(quote) __TEXT(quote)
#define UNICODE

#ifndef _WINSPOOL_
#error "Oops, winspool.h changed, make sure this code is still OK."
#endif


#include <dosprtp.h>    // prototypes
#include <lmapibuf.h>   // NetApiBufferFree(), etc.
#include <lmerr.h>      // NO_ERROR, NERR_, and ERROR_ equates.
#include <lmshare.h>    // SHARE_INFO_2, STYPE_ equates, etc.
#include <prefix.h>     // PREFIX_ equates.
#include <rxprint.h>    // PPRQINFOW, etc.
#include <string.h>     // strrchr().
#include <tstring.h>    // NetpAlloc{type}From{type}.
#include <wchar.h>      // wscrchr().
#include "myspool.h"

NET_API_STATUS
CommandALocalPrinterW(
    IN LPWSTR PrinterName,
    IN DWORD  Command     //  PRINTER_CONTROL_PAUSE, etc.
    )
{
    NET_API_STATUS    ApiStatus;
    HANDLE            PrinterHandle = INVALID_HANDLE_VALUE;
    PRINTER_DEFAULTSW pd = { NULL, NULL, PRINTER_ACCESS_ADMINISTER };

    if ( !MyOpenPrinterW(PrinterName, &PrinterHandle, &pd)) {
        ApiStatus = GetLastError();
        goto Cleanup;
    }

    if ( !MySetPrinterW(
            PrinterHandle,
            0,              // info level
            NULL,           // no job structure
            Command) ) {

        ApiStatus = GetLastError();

        NetpKdPrint(( PREFIX_DOSPRINT
                "CommandALocalPrinterW: FAILED COMMAND " FORMAT_DWORD
                " for printer " FORMAT_LPWSTR ", api status " FORMAT_API_STATUS
                ".\n", Command, PrinterName, ApiStatus ));

        goto Cleanup;

    } else {
        ApiStatus = NO_ERROR;
    }


Cleanup:
    if (PrinterHandle != INVALID_HANDLE_VALUE) {
        (VOID) MyClosePrinter(PrinterHandle);
    }

    return (ApiStatus);

} // CommandALocalPrinterW


NET_API_STATUS
CommandALocalJobA(
    IN HANDLE  PrinterHandle, OPTIONAL
    IN LPWSTR LocalServerNameW,
    IN LPSTR  LocalServerNameA,
    IN DWORD   JobId,
    IN DWORD   Level,
    IN LPBYTE  pJob,
    IN DWORD   Command     //  JOB_CONTROL_PAUSE, etc.
    )

/*++

Routine Description:

    Sends a command to a Job based on a JobId.  If a PrintHandle
    is passed in, it is used; otherwise a temporary one is opened
    and used instead.

    This is the ansi version--pJob must be ansi.  The LocalSeverName
    can be passed in either ansi or UNICODE.

Arguments:

    PrinterHandle - Print handle to use, may be NULL.  If it is
        is NULL, then LocalServerName should point to the printer
        name that should be opened.

    LocalServerNameW - Used only if PrintHandle is NULL.

    LocalServerNameA - Used only if PrintHandle and LocalServerNamwW are NULL.

    JobId - Job that should be modified

    Level - Specifies pJob info level

    pJob - Information to set about job, level specified by Level
        ** WARNING ** This is an ANSI structure.

    Command - Command to execute on job

Return Value:

    Return code, may be a win32 error code (!?)

--*/

{
    NET_API_STATUS ApiStatus;
    HANDLE         PrinterHandleClose = INVALID_HANDLE_VALUE;

    //
    // If a print handle wasn't passed in, open one ourselves.
    // We store it in PrinterHandleClose so that we can close it later.
    //
    if ( PrinterHandle == NULL ) {

        if ( LocalServerNameW ){
            if ( !MyOpenPrinterW( LocalServerNameW, &PrinterHandle, NULL )) {

                ApiStatus = GetLastError();
                goto Cleanup;
            }
        } else {
            if ( !MyOpenPrinterA( LocalServerNameA, &PrinterHandle, NULL )) {

                ApiStatus = GetLastError();
                goto Cleanup;
            }
        }
        PrinterHandleClose = PrinterHandle;
    }

    if ( !MySetJobA(
            PrinterHandle,
            JobId,
            Level,
            pJob,
            Command) ) {

        ApiStatus = GetLastError();

        NetpKdPrint(( PREFIX_DOSPRINT
                "CommandALocalJobA: FAILED COMMAND " FORMAT_DWORD " for job "
                FORMAT_DWORD ", api status " FORMAT_API_STATUS ".\n",
                Command, JobId, ApiStatus ));

        goto Cleanup;

    } else {
        ApiStatus = NO_ERROR;
    }


Cleanup:
    if (PrinterHandleClose != INVALID_HANDLE_VALUE) {
        (VOID) MyClosePrinter(PrinterHandle);
    }

    return (ApiStatus);

} // CommandALocalJobA


LPSTR
FindQueueNameInPrinterNameA(
    IN LPCSTR PrinterName
    )
{
    LPSTR QueueName;
    NetpAssert( PrinterName != NULL );

    QueueName = strrchr( PrinterName, '\\');

    if (QueueName) {
        ++QueueName;   // Skip past the backslash.
    } else {
        QueueName = (LPSTR) PrinterName;
    }
    NetpAssert( QueueName != NULL );
    return (QueueName);
}


LPWSTR
FindQueueNameInPrinterNameW(
    IN LPCWSTR PrinterName
    )
{
    LPWSTR QueueName;
    NetpAssert( PrinterName != NULL );

    QueueName = wcsrchr( PrinterName, L'\\');
    if (QueueName) {
        ++QueueName;   // Skip past the backslash.
    } else {
        QueueName = (LPWSTR) PrinterName;
    }
    NetpAssert( QueueName != NULL );
    return (QueueName);
}


WORD
PrjStatusFromJobStatus(
    IN DWORD JobStatus
    )
{
    WORD PrjStatus = 0;

    if (JobStatus & JOB_STATUS_SPOOLING)

        PrjStatus |= PRJ_QS_SPOOLING;

    if (JobStatus & JOB_STATUS_PAUSED)

        PrjStatus |= PRJ_QS_PAUSED;

    if (JobStatus & JOB_STATUS_PRINTING)

        PrjStatus |= PRJ_QS_PRINTING;

    if (JobStatus & JOB_STATUS_ERROR)

        PrjStatus |= PRJ_ERROR;

    return (PrjStatus);

} // PrjStatusFromJobStatus


WORD
PrqStatusFromPrinterStatus(
    IN DWORD PrinterStatus
    )
{
    WORD PrqStatus;

    if (PrinterStatus & PRINTER_STATUS_PAUSED) {

        PrqStatus = PRQ_PAUSED;

    } else if (PrinterStatus & PRINTER_STATUS_ERROR) {

        PrqStatus = PRQ_ERROR;

    } else if (PrinterStatus & PRINTER_STATUS_PENDING_DELETION) {

        PrqStatus = PRQ_PENDING;

    } else {

        PrqStatus = PRQ_ACTIVE;

    }

    return (PrqStatus);

} // PrqStatusFromPrinterStatus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\dosprint\dosspool.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    dosspool.c

Abstract:

    Contains the entry points for the functions that live in a
    separate DLL. The entry points are made available here, but
    will not load the WINSPOOL.DRV until it is needed.

    Contains:

Author:

    Congpa You (CongpaY)    22-Jan-1993

Environment:

Notes:

Revision History:

--*/
#include <windows.h>
#include <netdebug.h>           // NetpAssert()
#include "dosspool.h"
#include "myspool.h"

/*
 * global defines.
 */

#define WINSPOOL_DLL_NAME           TEXT("WINSPOOL.DRV")

/*
 * global data.
 *
 * here we store handles to the MPRUI dll and pointers to the function
 * all of below is protect in multi threaded case with MprLoadLibSemaphore.
 */

HINSTANCE                  vhWinspoolDll = NULL ;

PF_ClosePrinter                 pfClosePrinter                  = NULL ;
PF_EnumJobsA                    pfEnumJobsA                     = NULL ;
PF_EnumPrintersA                pfEnumPrintersA                 = NULL ;
PF_GetJobA                      pfGetJobA                       = NULL ;
PF_GetPrinterA                  pfGetPrinterA                   = NULL ;
PF_OpenPrinterA                 pfOpenPrinterA                  = NULL ;
PF_OpenPrinterW                 pfOpenPrinterW                  = NULL ;
PF_SetJobA                      pfSetJobA                       = NULL ;
PF_SetPrinterW                  pfSetPrinterW                   = NULL ;
PF_GetPrinterDriverA            pfGetPrinterDriverA             = NULL;

/*
 * global functions
 */
BOOL MakeSureDllIsLoaded(void) ;

/*******************************************************************

    NAME:   GetFileNameA

    SYNOPSIS:   Gets the filename part from a fully qualified path


    HISTORY:
    MuhuntS  06-Feb-1996    Created

********************************************************************/
LPSTR
GetFileNameA(
    LPSTR   pPathName
    )
{
    LPSTR   pSlash = pPathName, pTemp;

    if ( pSlash ) {

        while ( pTemp = strchr(pSlash, '\\') )
            pSlash = pTemp+1;

        if ( !*pSlash )
            pSlash = NULL;

        NetpAssert(pSlash != NULL);
    }

    return pSlash;
}

/*******************************************************************

    NAME:   GetDependentFileNameA

    SYNOPSIS:   Gets the dependent filename to send to Win95. Normally just
                the file name part. But for ICM files this would be
                Color\<filename>


    HISTORY:
    MuhuntS  23-Apr-1997    Created

********************************************************************/
LPSTR
GetDependentFileNameA(
    LPSTR   pPathName
    )
{
    LPSTR   pRet = GetFileNameA(pPathName), p;

    if (pRet)
    {
        DWORD   dwLen = strlen(pRet);

        p = pRet+dwLen-4;

        if ( dwLen > 3                      &&
             ( !_stricmp(p, ".ICM")     ||
               !_stricmp(p, ".ICC") )       &&
             (p = pRet - 7) > pPathName     &&
             !_strnicmp(p, "\\Color\\", 7) ) {

            pRet = p + 1;
        }
    }

    return pRet;
}


/*******************************************************************

    NAME:   MyClosePrinter

    SYNOPSIS:   calls thru to the superset function

    HISTORY:
    CongpaY  22-Jan-1993    Created

********************************************************************/

BOOL MyClosePrinter (HANDLE hPrinter)
{
    PF_ClosePrinter pfTemp;

    // if function has not been used before, get its address.
    if (pfClosePrinter == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureDllIsLoaded())
        {
            return(FALSE) ;
        }

        pfTemp = (PF_ClosePrinter)
                          GetProcAddress(vhWinspoolDll,
                                         "ClosePrinter") ;

        if (pfTemp == NULL)
        {
            return(FALSE);
        }
        else
        {
            pfClosePrinter = pfTemp;
        }

    }

    return ((*pfClosePrinter)(hPrinter));
}

/*******************************************************************

    NAME:   MyEnumJobs

    SYNOPSIS:   calls thru to the superset function

    NOTES: This is defined ANSI version. If change to UNICODE version
           in the future, you should change the code to make it call
           UNICODE version!!!

    HISTORY:
    CongpaY  22-Jan-1993    Created

********************************************************************/

BOOL MyEnumJobs (HANDLE hPrinter,
                      DWORD  FirstJob,
                      DWORD  NoJobs,
                      DWORD  Level,
                      LPBYTE pJob,
                      DWORD  cbBuf,
                      LPDWORD pcbNeeded,
                      LPDWORD pcReturned)
{
    PF_EnumJobsA pfTemp;

    // if function has not been used before, get its address.
    if (pfEnumJobsA == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureDllIsLoaded())
        {
            return(FALSE) ;
        }

        pfTemp = (PF_EnumJobsA)
                          GetProcAddress(vhWinspoolDll,
                                         "EnumJobsA") ;

        if (pfTemp == NULL)
        {
            return(FALSE);
        }
        else
        {
            pfEnumJobsA = pfTemp;
        }
    }

    return ((*pfEnumJobsA)(hPrinter,
                           FirstJob,
                           NoJobs,
                           Level,
                           pJob,
                           cbBuf,
                           pcbNeeded,
                           pcReturned));
}

/*******************************************************************

    NAME:   MyEnumPrinters

    SYNOPSIS:   calls thru to the superset function

    HISTORY:
    CongpaY  22-Jan-1993    Created

********************************************************************/

BOOL  MyEnumPrinters(DWORD    Flags,
                           LPSTR    Name,
                           DWORD    Level,
                           LPBYTE   pPrinterEnum,
                           DWORD    cbBuf,
                           LPDWORD  pcbNeeded,
                           LPDWORD  pcReturned)

{
    PF_EnumPrintersA pfTemp;

    // if function has not been used before, get its address.
    if (pfEnumPrintersA == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureDllIsLoaded())
        {
            return(FALSE) ;
        }

        pfTemp = (PF_EnumPrintersA)
                          GetProcAddress(vhWinspoolDll,
                                         "EnumPrintersA") ;

        if (pfTemp == NULL)
        {
            return(TRUE);
        }
        else
            pfEnumPrintersA = pfTemp;
    }

    return ((*pfEnumPrintersA)(Flags,
                               Name,
                               Level,
                               pPrinterEnum,
                               cbBuf,
                               pcbNeeded,
                               pcReturned));
}

/*******************************************************************

    NAME:   MyGetJobA

    SYNOPSIS:   calls thru to the superset function

    HISTORY:
    CongpaY  22-Jan-1993    Created

********************************************************************/

BOOL MyGetJobA(HANDLE hPrinter,
               DWORD  JobId,
               DWORD  Level,
               LPBYTE pJob,
               DWORD  cbBuf,
               LPDWORD pcbNeeded)
{
    PF_GetJobA pfTemp;

    // if function has not been used before, get its address.
    if (pfGetJobA == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureDllIsLoaded())
        {
            return(FALSE) ;
        }

        pfTemp = (PF_GetJobA)
                          GetProcAddress(vhWinspoolDll,
                                         "GetJobA") ;

        if (pfTemp == NULL)
        {
            return(FALSE);
        }
        else
            pfGetJobA = pfTemp;
    }

    return ((*pfGetJobA)(hPrinter,
                         JobId,
                         Level,
                         pJob,
                         cbBuf,
                         pcbNeeded));
}

/*******************************************************************

    NAME:   MyGetPrinter

    SYNOPSIS:   calls thru to the superset function

    HISTORY:
    CongpaY  22-Jan-1993    Created

********************************************************************/

BOOL MyGetPrinter (HANDLE hPrinter,
                         DWORD  Level,
                         LPBYTE pPrinter,
                         DWORD  cbBuf,
                         LPDWORD pcbNeeded)
{
    PF_GetPrinterA  pfTemp;
    LPSTR           pszDriverName = NULL;
    DWORD           cbDriverName = 0;
    BOOL            bRet;

    // if function has not been used before, get its address.
    if (pfGetPrinterA == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureDllIsLoaded())
        {
            return(FALSE) ;
        }

        pfTemp = (PF_GetPrinterA)
                          GetProcAddress(vhWinspoolDll,
                                         "GetPrinterA") ;

        if (pfTemp == NULL)
        {
            return(FALSE);
        }
        else
            pfGetPrinterA = pfTemp;
    }

    //
    // Win95 driver name could be different than NT. If it is different AND
    // the win95 driver with the different name is installed we want to send
    // that name to Win9x client
    //
    if ( Level == 2 ) {
        DWORD dwNeeded = 0;

        // Check the size of the name and make sure that we copy the printer driver name to the
        // beginning of the buffer.  The previous code would let the GetPrinterDriver call determine
        // where to put it which could result in the strcpy copying data from one string on top of another
        // if the call used the end of the buffer like we plan on using.  We address this by doing an STRNCPY to 
        // make sure we don't start doing an infinite copy and also make sure our buffers don't overlap with
        // an assert.
        bRet = MyGetPrinterDriver(hPrinter,
                                WIN95_ENVIRONMENT,
                                1,
                                NULL,
                                0,
                                &dwNeeded);
        
        if( dwNeeded <= cbBuf )
        {
            if( MyGetPrinterDriver( hPrinter,
                                    WIN95_ENVIRONMENT,
                                    1,
                                    pPrinter,
                                    dwNeeded,
                                    pcbNeeded ))
            {
                pszDriverName   = ((LPDRIVER_INFO_1A)pPrinter)->pName;
                cbDriverName    = (strlen(pszDriverName) + 1) * sizeof(CHAR);
                NetpAssert( pszDriverName + cbDriverName < pPrinter + cbBuf - cbDriverName );
                strncpy((LPSTR)(pPrinter + cbBuf - cbDriverName), pszDriverName, cbDriverName);
                pszDriverName = (LPSTR)(pPrinter + cbBuf - cbDriverName);
            } else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                //
                // DRIVER_INFO_1 has pDriverName only. So if we fail with
                // insufficient buffer GetPrinter is guaranteed to fail too.
                // If we use a different level that may not be TRUE
                //
                cbDriverName = *pcbNeeded - sizeof(DRIVER_INFO_1A);
            }
        }
        else
        {
            cbDriverName = dwNeeded - sizeof(DRIVER_INFO_1A);
        }
    }

    if( cbBuf > cbDriverName )
    {
        bRet = pfGetPrinterA(hPrinter, Level, pPrinter, cbBuf-cbDriverName, pcbNeeded);
    }
    else
    {
        bRet = pfGetPrinterA(hPrinter, Level, pPrinter, 0, pcbNeeded);
    }

    if ( Level != 2 )
        return bRet;

    if ( bRet ) {

        if ( pszDriverName ) {

            ((LPPRINTER_INFO_2A)pPrinter)->pDriverName = pszDriverName;
            *pcbNeeded += cbDriverName;
        }
    } else if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {

        *pcbNeeded += cbDriverName;
    }

    return bRet;
}


/*******************************************************************

    NAME:   MyOpenPrinterA

    SYNOPSIS:   calls thru to the superset function

    HISTORY:
    CongpaY  22-Jan-1993    Created

********************************************************************/

BOOL MyOpenPrinterA(LPSTR               pPrinterName,
                    LPHANDLE            phPrinter,
                    LPPRINTER_DEFAULTSA pDefault)

{
    PF_OpenPrinterA pfTemp;

    // if function has not been used before, get its address.
    if (pfOpenPrinterA == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureDllIsLoaded())
        {
            return(FALSE) ;
        }

        pfTemp = (PF_OpenPrinterA)
                          GetProcAddress(vhWinspoolDll,
                                         "OpenPrinterA") ;

        if (pfTemp == NULL)
        {
            return(FALSE);
        }
        else
            pfOpenPrinterA = pfTemp;
    }

    return ((*pfOpenPrinterA)(pPrinterName,
                              phPrinter,
                              pDefault));
}


/*******************************************************************

    NAME:   MyOpenPrinterW

    SYNOPSIS:   calls thru to the superset function

    HISTORY:
    CongpaY  22-Jan-1993    Created

********************************************************************/

BOOL MyOpenPrinterW (LPWSTR              pPrinterName,
                     LPHANDLE            phPrinter,
                     LPPRINTER_DEFAULTSW pDefault)

{
    PF_OpenPrinterW pfTemp;

    // if function has not been used before, get its address.
    if (pfOpenPrinterW == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureDllIsLoaded())
        {
            return(FALSE) ;
        }

        pfTemp = (PF_OpenPrinterW)
                          GetProcAddress(vhWinspoolDll,
                                         "OpenPrinterW") ;

        if (pfTemp == NULL)
        {
            return(FALSE);
        }
        else
            pfOpenPrinterW = pfTemp;
    }

    return ((*pfOpenPrinterW)(pPrinterName,
                              phPrinter,
                              pDefault));
}
/*******************************************************************

    NAME:   MySetJobA

    SYNOPSIS:   calls thru to the superset function

    HISTORY:
    CongpaY  22-Jan-1993    Created
    AlbertT  24-Mar-1995    AddedLevel and pJob

********************************************************************/

BOOL MySetJobA (HANDLE hPrinter,
                DWORD  JobId,
                DWORD  Level,
                LPBYTE pJob,
                DWORD  Command)

{
    PF_SetJobA pfTemp;

    // if function has not been used before, get its address.
    if (pfSetJobA == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureDllIsLoaded())
        {
            return(FALSE) ;
        }

        pfTemp = (PF_SetJobA)
                          GetProcAddress(vhWinspoolDll,
                                         "SetJobA") ;

        if (pfTemp == NULL)
        {
            return(FALSE);
        }
        else
            pfSetJobA = pfTemp;
    }

    return ((*pfSetJobA)(hPrinter,
                         JobId,
                         Level,
                         pJob,
                         Command));
}

/*******************************************************************

    NAME:   MySetPrinterW

    SYNOPSIS:   calls thru to the superset function

    HISTORY:
    AlbertT  23-Mar-1995    Created

********************************************************************/

BOOL MySetPrinterW(HANDLE hPrinter,
                   DWORD  Level,
                   LPBYTE pPrinter,
                   DWORD  Command)

{
    PF_SetPrinterW pfTemp;

    // if function has not been used before, get its address.
    if (pfSetPrinterW == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureDllIsLoaded())
        {
            return(FALSE) ;
        }

        pfTemp = (PF_SetPrinterW)
                          GetProcAddress(vhWinspoolDll,
                                         "SetPrinterW") ;

        if (pfTemp == NULL)
        {
            return(FALSE);
        }
        else
            pfSetPrinterW = pfTemp;
    }

    return ((*pfSetPrinterW)(hPrinter,
                            Level,
                            pPrinter,
                            Command));
}

/*******************************************************************

    NAME:   MyGetPrinterDriver

    SYNOPSIS:   calls thru to the superset function

    HISTORY:
    MuhuntS  06-Feb-1996    Created

********************************************************************/

BOOL
MyGetPrinterDriver(
    HANDLE      hPrinter,
    LPSTR       pEnvironment,
    DWORD       Level,
    LPBYTE      pDriver,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded
    )
{
    //
    // if function has not been used before, get its address.
    //
    if ( !pfGetPrinterDriverA ) {

        //
        // If dll is not loaded yet load it
        //
        if ( !MakeSureDllIsLoaded() ) {

            return FALSE;
        }

        (FARPROC) pfGetPrinterDriverA = GetProcAddress(vhWinspoolDll,
                                                       "GetPrinterDriverA");

        if ( !pfGetPrinterDriverA )
            return FALSE;
    }

    return ((*pfGetPrinterDriverA)(hPrinter,
                                   pEnvironment,
                                   Level,
                                   pDriver,
                                   cbBuf,
                                   pcbNeeded));
}

/*******************************************************************

    NAME:   MakeSureDllIsLoaded

    SYNOPSIS:   loads the WINSPOOL dll if need.

    EXIT:   returns TRUE if dll already loaded, or loads
        successfully. Returns false otherwise. Caller
        should call GetLastError() to determine error.

    NOTES:      it is up to the caller to call EnterLoadLibCritSect
                before he calls this.

    HISTORY:
        chuckc  29-Jul-1992    Created
        congpay 22-Jan-1993    Modified.

********************************************************************/

BOOL MakeSureDllIsLoaded(void)
{
    HINSTANCE handle ;

    // if already load, just return TRUE
    if (vhWinspoolDll != NULL)
        return TRUE ;

    // load the library. if it fails, it would have done a SetLastError.
    handle = LoadLibrary(WINSPOOL_DLL_NAME);
    if (handle == NULL)
       return FALSE ;

    // we are cool.
    vhWinspoolDll = handle ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\dosprint\dosprtw.c ===
/*++

Copyright (c) 1991-1993 Microsoft Corporation

Module Name:

    DosPrtW.c

Abstract:

    This module provides the UNICODE mapping layer from the old DosPrint APIs
    to the new all singing all dancing beautiful Print APIs.  (The ANSI
    mapping layer is in DosPrint.c)

Author:

    Dave Snipp (DaveSn) 26-Apr-1991

Revision History:

    09-Jul-1992 JohnRo
        Created this file (from DaveSn's DosPrint.c) for RAID 10324: net print
        vs. UNICODE.
    05-Oct-1992 JohnRo
        RAID 3556: DosPrintQGetInfo(from downlevel) level 3, rc=124.  (4&5 too.)
        RAID 3580: lmsvcs.exe: access violation from OS/2 DosPrintJobGetInfo.
        RAID 8333: view printer queues hangs DOS LM enh client.
        Make sure data type in job level 1 is null terminated.
        Fixed job submitted times.
        Fixed error code if GlobalAlloc fails.
        Fixed memory leak in DosPrintQGetInfoW.
        Fixed DosPrintQEnumW level 5 array bug.
        Fixed DosPrintJobEnumW levels 2 and 3.
    25-Nov-1992 JohnRo
        RAID 1661: downlevel to NT DosPrintDestEnum not supported.
        Added code to track down empty queue name.
        Quiet normal debug output.
        Avoid const vs. volatile compiler warnings.
        Avoid other new compiler warnings.
    08-Feb-1993 JohnRo
        RAID 10164: Data misalignment error during XsDosPrintQGetInfo().
    22-Mar-1993 JohnRo
        RAID 2974: NET PRINT says NT printer is held when it isn't.
    11-May-1993 JohnRo
        RAID 9942: fix queue name in job info level 3.
    14-May-1993 JohnRo
        RAID 9961: DosPrintDestEnum returns NO_ERROR to downlevel but
        pcReturned=0; should return NERR_DestNotFound.
        Fixed data type returned from PrjInfoFixedSizeW().
    18-May-1993 JohnRo
        DosPrintQGetInfoW underestimates number of bytes needed.
        Use NetpKdPrint() where possible.
        Made changes suggested by PC-LINT.
    04-Jun-1993 JohnRo
        RAID 10222: DosPrintQEnumW returns ERROR_INVALID_USER_BUFFER
        when queue is empty.
        Made changes suggested by PC-LINT 5.0
    08-Jul-1993 JohnRo
        RAID 15509: GetJob() API sometimes returned TRUE, even on error case.
        Also added some >64KB checks.
        Added some assert checks...
    13-Jul-1993 JohnRo
        Intermittent empty print queue (was buggy after some MyEnumJobs calls).
    29-Mar-1995 AlbertT
        Support for pause/resume/purge printer queue added.
        SetJobInfo 1 comment field (translated into document name) support
        added so that chicago clients can set the doc name.

--*/


#ifndef UNICODE
#error "RxPrint APIs assume RxRemoteApi uses wide characters."
#endif

#define NOMINMAX
#define NOSERVICE       // Avoid <winsvc.h> vs. <lmsvc.h> conflicts.
#include <windows.h>

//#include <lm.h>
#include <netdebug.h>

#include <string.h>
#include <align.h>


#ifdef _WINSPOOL_
#error "Include of winspool.h moved, make sure it doesn't get UNICODE."
#endif

#undef UNICODE
#undef TEXT
#define TEXT(quote) quote
#include <winspool.h>
#undef TEXT
#define TEXT(quote) __TEXT(quote)
#define UNICODE

#ifndef _WINSPOOL_
#error "Oops, winspool.h changed, make sure this code is still OK."
#endif


#include <dosprint.h>
#include <dosprtp.h>    // CommandALocalJob(), etc.
#include <lmapibuf.h>   // NetApiBufferFree(), etc.
#include <lmerr.h>      // NO_ERROR, NERR_, and ERROR_ equates.
#include <lmshare.h>    // LPSHARE_INFO_1, STYPE_ equates, etc.
#include <prefix.h>     // PREFIX_ equates.
#include <stddef.h>     // offsetof().
#include <timelib.h>    // NetpSystemTimeToGmtTime().
#include <tstring.h>    // WCSSIZE(), NetpNCopy{type}To{type}.
#include <wchar.h>      // wsclen(), wcscpy(), etc.
#include "myspool.h"


#define STR_CONV_SIZE(psz)      ( (strlen(psz)+1) * sizeof(WCHAR) )

// NULL_STR_CONV_SIZE: Compute size needed for converted string, which
// is possibly a null pointer but downlevel really wants ptr to null char.
#define NULL_STR_CONV_SIZE(psz) ( (psz) ? STR_CONV_SIZE(psz) : sizeof(WCHAR) )


#define ARRAY_END      ((DWORD) -1)

#define MAX_WORD        (  (WORD) (~0) )


#define MY_PROTOCOL_LIMIT_ERROR         ERROR_NOT_ENOUGH_MEMORY

#define WIN95_DRIVER_SHARE              "\\print$\\WIN40\\0"


VOID
NetpSetJobCountForQueue(
    IN     DWORD  QueueLevel,
    IN OUT LPVOID Queue,
    IN     BOOL   HasUnicodeStrings,
    IN     DWORD  JobCount
    );


DBGSTATIC LPWSTR
PackAnsiStringsToW(
   LPSTR *pSource,
   LPBYTE pDest,
   CONST DWORD *DestOffsets,
   LPWSTR pEnd
)
{
   // Make sure our end pointer is WCHAR aligned or we'll fault later
   ROUND_DOWN_POINTER( pEnd, ALIGN_WCHAR );
   
   while (*DestOffsets != ARRAY_END) {
      if (*pSource) {
         pEnd-=(strlen(*pSource) + 1);

         // Copy the string and convert chars while we're at it.
         NetpCopyStrToWStr(pEnd, *pSource);

         *(LPWSTR *)(pDest+*DestOffsets) = pEnd;
      } else {
         --pEnd;             // need 1 char for this.
         *pEnd = L'\0';
         *(LPWSTR *)(pDest+*DestOffsets) = pEnd;
      }
      pSource++;
      DestOffsets++;
   }

   return pEnd;
}

DBGSTATIC DWORD
PrjInfoFixedSizeW(
    IN DWORD Level  // assumed valid
    )
{
    switch (Level) {

    case 0:
        return sizeof(WORD);    // job number.
    case 1:
        return (sizeof(PRJINFOW));
    case 2:
        return (sizeof(PRJINFO2W));
    case 3:
        return (sizeof(PRJINFO3W));
    default:
        NetpAssert( FALSE );
        return (0);
    }
    /*NOTREACHED*/
}

DBGSTATIC DWORD
GetPrjInfoSizeW(
    IN DWORD Level,
    IN LPJOB_INFO_2 pJob,
    IN LPCWSTR QueueNameW
)
{
    NetpAssert( pJob != NULL );
    switch (Level) {

    case 0:

        return sizeof(WORD);    // job number.

    case 1:

        return sizeof(PRJINFOW) +
               NULL_STR_CONV_SIZE( (LPSTR) (pJob->pParameters) ) +
               NULL_STR_CONV_SIZE( (LPSTR) (pJob->pStatus) ) +
               NULL_STR_CONV_SIZE( (LPSTR) (pJob->pDocument) );  // fake pszComment

    case 2:

        return sizeof(PRJINFO2W) +
               NULL_STR_CONV_SIZE( (LPSTR) (pJob->pUserName) ) +
               NULL_STR_CONV_SIZE( (LPSTR) (pJob->pDocument) ) +  // fake pszComment
               NULL_STR_CONV_SIZE( (LPSTR) (pJob->pDocument) );

    case 3:

            NetpAssert( QueueNameW != NULL );

            return sizeof(PRJINFO3W) +
                   NULL_STR_CONV_SIZE( (LPSTR) (pJob->pUserName) ) +
                   NULL_STR_CONV_SIZE( (LPSTR) (pJob->pDocument) ) + // fake pszComment
                   NULL_STR_CONV_SIZE( (LPSTR) (pJob->pDocument) ) +
                   NULL_STR_CONV_SIZE( (LPSTR) (pJob->pNotifyName) ) +
                   NULL_STR_CONV_SIZE( (LPSTR) (pJob->pDatatype) ) +
                   NULL_STR_CONV_SIZE( (LPSTR) (pJob->pParameters) ) +
                   NULL_STR_CONV_SIZE( (LPSTR) (pJob->pStatus) ) +
                   WCSSIZE( QueueNameW ) +  // pszQueue
                   NULL_STR_CONV_SIZE( (LPSTR) (pJob->pPrintProcessor) ) +
                   NULL_STR_CONV_SIZE( (LPSTR) (pJob->pParameters) ) +
                   NULL_STR_CONV_SIZE( (LPSTR) (pJob->pDriverName) ) +                   
                   NULL_STR_CONV_SIZE( (LPSTR) (pJob->pPrinterName) );

    default:
        NetpKdPrint(( PREFIX_DOSPRINT
                "GetPrjInfoSizeW: invalid level!\n" ));
        return 0;

    }
    /*NOTREACHED*/
}

// Print job info string table (for level 1).
DBGSTATIC CONST DWORD PrjInfo1StringsW[]={
                        offsetof(PRJINFOW, pszParms),
                        offsetof(PRJINFOW, pszStatus),
                        offsetof(PRJINFOW, pszComment),
                        ARRAY_END};

// Print job info string table (for level 2).
DBGSTATIC CONST DWORD PrjInfo2StringsW[]={
                        offsetof(PRJINFO2W, pszUserName),
                        offsetof(PRJINFO2W, pszComment),
                        offsetof(PRJINFO2W, pszDocument),
                        (DWORD) -1};

// Print job info string table (for items which level 3 has on top of level 2).
DBGSTATIC CONST DWORD PrjInfo3StringsW[]={
                        offsetof(PRJINFO3W, pszNotifyName),
                        offsetof(PRJINFO3W, pszDataType),
                        offsetof(PRJINFO3W, pszParms),
                        offsetof(PRJINFO3W, pszStatus),
                        offsetof(PRJINFO3W, pszQProcName),
                        offsetof(PRJINFO3W, pszQProcParms),
                        offsetof(PRJINFO3W, pszDriverName),
                        offsetof(PRJINFO3W, pszPrinterName),
                        (DWORD) -1};

DBGSTATIC LPWSTR
CopyJobToPrjInfoW(
    IN DWORD Level,
    IN LPJOB_INFO_2 pJob,
    IN LPCWSTR QueueNameW,
    OUT PBYTE pBuffer,
    IN OUT LPWSTR pEnd
    )
{
    LPSTR *pSourceStrings;
    NET_API_STATUS rc;

    NetpAssert( pBuffer != NULL );
    NetpAssert( pEnd != NULL );
    NetpAssert( pJob != NULL );

    switch (Level) {

    case 0:

        {
            PWORD pJobIds = (PWORD) pBuffer;
            *pJobIds = (WORD)pJob->JobId;
        }
        break;

    case 1:
        {
            LPSTR SourceStrings[sizeof(PrjInfo1StringsW)/sizeof(DWORD)];
            PPRJINFOW pPrjInfo = (LPVOID) pBuffer;

            pSourceStrings=SourceStrings;
            *pSourceStrings++ = (LPSTR) (pJob->pParameters);
            *pSourceStrings++ = (LPSTR) (pJob->pStatus);
            *pSourceStrings++ = (LPSTR) (pJob->pDocument);  // fake pszComment

            pEnd = PackAnsiStringsToW(
                    SourceStrings,
                    (LPBYTE) (LPVOID) pPrjInfo,
                    PrjInfo1StringsW,
                    pEnd);

            pPrjInfo->uJobId = (WORD)pJob->JobId;

            if (pJob->pUserName)
                (VOID) NetpNCopyStrToWStr(
                        (LPWSTR) (pPrjInfo->szUserName),
                        (LPSTR) (pJob->pUserName),
                        LM20_UNLEN+1);
            else
                pPrjInfo->szUserName[0] = L'\0';

            if (pJob->pNotifyName)
                (VOID) NetpNCopyStrToWStr(
                        (LPWSTR) (pPrjInfo->szNotifyName),
                        (LPSTR) (pJob->pNotifyName),
                        LM20_CNLEN+1);
            else
                pPrjInfo->szNotifyName[0] = L'\0';

            if (pJob->pDatatype) {
                (VOID) NetpNCopyStrToWStr(
                        (LPWSTR) (pPrjInfo->szDataType),
                        (LPSTR) (pJob->pDatatype),
                        DTLEN+1);
                pPrjInfo->szDataType[DTLEN] = L'\0';
            } else {
                pPrjInfo->szDataType[0] = L'\0';
            }

            pPrjInfo->uPosition = (WORD)pJob->Position;

            pPrjInfo->fsStatus = PrjStatusFromJobStatus( pJob->Status );

            rc = NetpSystemTimeToGmtTime(
                    &pJob->Submitted,
                    &pPrjInfo->ulSubmitted );
            NetpAssert( rc == NO_ERROR );

            pPrjInfo->ulSize = pJob->Size;
        }
        break;

    case 2:  /*FALLTHROUGH*/
    case 3:
        {
            PPRJINFO2W pPrjInfo = (LPVOID) pBuffer;
            LPSTR SourceStrings[sizeof(PrjInfo2StringsW)/sizeof(DWORD)];

            pSourceStrings=SourceStrings;
            *pSourceStrings++ = (LPSTR) (pJob->pUserName);
            *pSourceStrings++ = (LPSTR) (pJob->pDocument);  // fake pszComment
            *pSourceStrings++ = (LPSTR) (pJob->pDocument);

            pEnd = PackAnsiStringsToW(
                    SourceStrings,
                    (LPBYTE) (LPVOID) pPrjInfo,
                    PrjInfo2StringsW,
                    pEnd);

            pPrjInfo->uJobId = (WORD)pJob->JobId;
            pPrjInfo->uPriority = (WORD)pJob->Priority;

            pPrjInfo->uPosition = (WORD)pJob->Position;

            pPrjInfo->fsStatus = PrjStatusFromJobStatus( pJob->Status );

            rc = NetpSystemTimeToGmtTime(
                    &pJob->Submitted,
                    &pPrjInfo->ulSubmitted );
            NetpAssert( rc == NO_ERROR );

            pPrjInfo->ulSize = pJob->Size;
        }

        if (Level == 3) {
            PPRJINFO3W pPrjInfo = (LPVOID) pBuffer;
            LPSTR SourceStrings[sizeof(PrjInfo3StringsW)/sizeof(DWORD)];

            //
            // Copy queue name first, as it is already right char set.
            //
            NetpAssert( QueueNameW != NULL );
            pEnd-=(wcslen(QueueNameW) + 1);

            (VOID) wcscpy(pEnd, QueueNameW);

            pPrjInfo->pszQueue = pEnd;

            //
            // Copy and convert other strings.
            //
            pSourceStrings=SourceStrings;
            *pSourceStrings++ = (LPSTR) (pJob->pNotifyName);
            *pSourceStrings++ = (LPSTR) (pJob->pDatatype);
            *pSourceStrings++ = (LPSTR) (pJob->pParameters);
            *pSourceStrings++ = (LPSTR) (pJob->pStatus);
            *pSourceStrings++ = (LPSTR) (pJob->pPrintProcessor);
            *pSourceStrings++ = (LPSTR) (pJob->pParameters);
            *pSourceStrings++ = (LPSTR) (pJob->pDriverName);
            *pSourceStrings++ = (LPSTR) (pJob->pPrinterName);

            pEnd = PackAnsiStringsToW(
                    SourceStrings,
                    (LPBYTE) (LPVOID) pPrjInfo,
                    PrjInfo3StringsW,
                    pEnd);

            pPrjInfo->pDriverData = NULL;
        }

        break;

    default:
        NetpKdPrint(( PREFIX_DOSPRINT
                "CopyJobToPrjInfoW: invalid level!\n" ));

    }

    return pEnd;
}

DBGSTATIC DWORD
GetPrqInfoSizeW(
    IN DWORD Level,
    IN LPCWSTR QueueNameW,
    IN LPPRINTER_INFO_2 pPrinter
    )
{
    NetpAssert( QueueNameW != NULL );
    NetpAssert( (*QueueNameW) != L'\0' );

    switch (Level) {

    case 0:

        return ( (LM20_QNLEN+1) * sizeof(WCHAR) );

    case 1: /*FALLTHROUGH*/
    case 2:

        return sizeof(PRQINFOW) +
                NULL_STR_CONV_SIZE( pPrinter->pSepFile ) +
                NULL_STR_CONV_SIZE( pPrinter->pPrintProcessor ) +
                NULL_STR_CONV_SIZE( pPrinter->pPortName ) +
                NULL_STR_CONV_SIZE( pPrinter->pParameters ) +
                NULL_STR_CONV_SIZE( pPrinter->pComment );

    case 3: /*FALLTHROUGH*/
    case 4:

        NetpAssert( QueueNameW != NULL );

        return sizeof(PRQINFO3W) +
                WCSSIZE( QueueNameW ) +   // pszName
                NULL_STR_CONV_SIZE( pPrinter->pSepFile ) +
                NULL_STR_CONV_SIZE( pPrinter->pPrintProcessor ) +
                NULL_STR_CONV_SIZE( pPrinter->pParameters ) +
                NULL_STR_CONV_SIZE( pPrinter->pComment ) +
                NULL_STR_CONV_SIZE( pPrinter->pPortName ) +
                NULL_STR_CONV_SIZE( pPrinter->pDriverName );                

    case 5:

        NetpAssert( QueueNameW != NULL );

        return sizeof(LPWSTR) +
                WCSSIZE( QueueNameW );    // pszName

    default:
        NetpKdPrint(( PREFIX_DOSPRINT
                "GetPrqInfoSizeW: invalid level!\n" ));

    }

    return 0;
}

DBGSTATIC DWORD
GetDrvInfoSizeW(
    IN  DWORD               Level,
    IN  LPDRIVER_INFO_3A    pDriverInfo3,
    IN  LPCSTR              pUNCSharePath,
    OUT LPDWORD             pdwDependentFileCount
    )
{
    LPSTR   psz;
    DWORD   dwSize;

    switch (Level) {
        case 52:
            dwSize = sizeof(PRQINFO52W) +
                     NULL_STR_CONV_SIZE(pDriverInfo3->pName) +
                     NULL_STR_CONV_SIZE(GetFileNameA(pDriverInfo3->pDriverPath)) +
                     NULL_STR_CONV_SIZE(GetFileNameA(pDriverInfo3->pDataFile)) +
                     NULL_STR_CONV_SIZE(GetFileNameA(pDriverInfo3->pConfigFile)) +
                     NULL_STR_CONV_SIZE(GetFileNameA(pDriverInfo3->pHelpFile)) +
                     NULL_STR_CONV_SIZE(pDriverInfo3->pDefaultDataType) +
                     NULL_STR_CONV_SIZE(pDriverInfo3->pMonitorName) +
                     NULL_STR_CONV_SIZE(pUNCSharePath);

            *pdwDependentFileCount = 0;
            for ( psz = pDriverInfo3->pDependentFiles;
                  psz && *psz ; psz += strlen(psz) + 1 ) {

                dwSize += NULL_STR_CONV_SIZE(GetDependentFileNameA(psz));
                (*pdwDependentFileCount)++;
            }

            //
            // For the '\0's
            //
            dwSize += (MAX_DEPENDENT_FILES-*pdwDependentFileCount)*sizeof(WCHAR);
            return dwSize;

        default:
            NetpKdPrint(( PREFIX_DOSPRINT "GetDrvInfoSizeW: invalid level!\n" ));

    }
    return 0;

}

DBGSTATIC DWORD
PrqInfoFixedSizeW(
    IN DWORD Level  // assumed valid
    )
{
    switch (Level) {
    case 0:
        return ( (LM20_QNLEN+1) * sizeof(WCHAR) );
    case 1: /*FALLTHROUGH*/
    case 2:
        return (sizeof(PRQINFOW));
    case 3: /*FALLTHROUGH*/
    case 4:
        return (sizeof(PRQINFO3W));
    case 5:
        return (sizeof(LPWSTR));
    default:
        NetpAssert( FALSE );   // Level should be valid!
        return (0);
    }
    /*NOTREACHED*/
}

// String table for Q levels 1,2
DBGSTATIC CONST DWORD PrqInfo1StringsW[]={
                        offsetof(PRQINFOW, pszSepFile),
                        offsetof(PRQINFOW, pszPrProc),
                        offsetof(PRQINFOW, pszDestinations),
                        offsetof(PRQINFOW, pszParms),
                        offsetof(PRQINFOW, pszComment),
                        ARRAY_END};

// String table for Q levels 3,4.
DBGSTATIC CONST DWORD PrqInfo3StringsW[]={
                        offsetof(PRQINFO3W, pszSepFile),
                        offsetof(PRQINFO3W, pszPrProc),
                        offsetof(PRQINFO3W, pszParms),
                        offsetof(PRQINFO3W, pszComment),
                        offsetof(PRQINFO3W, pszPrinters),
                        offsetof(PRQINFO3W, pszDriverName),
                        (DWORD) -1};

// Print driver info3 string table (for level 52)
DBGSTATIC CONST DWORD PrqInfo52StringsW[]={
                        offsetof(PRQINFO52W, pszModelName),
                        offsetof(PRQINFO52W, pszDriverName),
                        offsetof(PRQINFO52W, pszDataFileName),
                        offsetof(PRQINFO52W, pszMonitorName),
                        offsetof(PRQINFO52W, pszDriverPath),
                        offsetof(PRQINFO52W, pszDefaultDataType),
                        offsetof(PRQINFO52W, pszHelpFile),
                        offsetof(PRQINFO52W, pszConfigFile),
                        offsetof(PRQINFO52W, pszDependentNames[0]),
                        offsetof(PRQINFO52W, pszDependentNames[1]),
                        offsetof(PRQINFO52W, pszDependentNames[2]),
                        offsetof(PRQINFO52W, pszDependentNames[3]),
                        offsetof(PRQINFO52W, pszDependentNames[4]),
                        offsetof(PRQINFO52W, pszDependentNames[5]),
                        offsetof(PRQINFO52W, pszDependentNames[6]),
                        offsetof(PRQINFO52W, pszDependentNames[7]),
                        offsetof(PRQINFO52W, pszDependentNames[8]),
                        offsetof(PRQINFO52W, pszDependentNames[9]),
                        offsetof(PRQINFO52W, pszDependentNames[10]),
                        offsetof(PRQINFO52W, pszDependentNames[11]),
                        offsetof(PRQINFO52W, pszDependentNames[12]),
                        offsetof(PRQINFO52W, pszDependentNames[13]),
                        offsetof(PRQINFO52W, pszDependentNames[14]),
                        offsetof(PRQINFO52W, pszDependentNames[15]),
                        offsetof(PRQINFO52W, pszDependentNames[16]),
                        offsetof(PRQINFO52W, pszDependentNames[17]),
                        offsetof(PRQINFO52W, pszDependentNames[18]),
                        offsetof(PRQINFO52W, pszDependentNames[19]),
                        offsetof(PRQINFO52W, pszDependentNames[20]),
                        offsetof(PRQINFO52W, pszDependentNames[21]),
                        offsetof(PRQINFO52W, pszDependentNames[22]),
                        offsetof(PRQINFO52W, pszDependentNames[23]),
                        offsetof(PRQINFO52W, pszDependentNames[24]),
                        offsetof(PRQINFO52W, pszDependentNames[25]),
                        offsetof(PRQINFO52W, pszDependentNames[26]),
                        offsetof(PRQINFO52W, pszDependentNames[27]),
                        offsetof(PRQINFO52W, pszDependentNames[28]),
                        offsetof(PRQINFO52W, pszDependentNames[29]),
                        offsetof(PRQINFO52W, pszDependentNames[30]),
                        offsetof(PRQINFO52W, pszDependentNames[31]),
                        offsetof(PRQINFO52W, pszDependentNames[32]),
                        offsetof(PRQINFO52W, pszDependentNames[33]),
                        offsetof(PRQINFO52W, pszDependentNames[34]),
                        offsetof(PRQINFO52W, pszDependentNames[35]),
                        offsetof(PRQINFO52W, pszDependentNames[36]),
                        offsetof(PRQINFO52W, pszDependentNames[37]),
                        offsetof(PRQINFO52W, pszDependentNames[38]),
                        offsetof(PRQINFO52W, pszDependentNames[39]),
                        offsetof(PRQINFO52W, pszDependentNames[40]),
                        offsetof(PRQINFO52W, pszDependentNames[41]),
                        offsetof(PRQINFO52W, pszDependentNames[42]),
                        offsetof(PRQINFO52W, pszDependentNames[43]),
                        offsetof(PRQINFO52W, pszDependentNames[44]),
                        offsetof(PRQINFO52W, pszDependentNames[45]),
                        offsetof(PRQINFO52W, pszDependentNames[46]),
                        offsetof(PRQINFO52W, pszDependentNames[47]),
                        offsetof(PRQINFO52W, pszDependentNames[48]),
                        offsetof(PRQINFO52W, pszDependentNames[49]),
                        offsetof(PRQINFO52W, pszDependentNames[50]),
                        offsetof(PRQINFO52W, pszDependentNames[51]),
                        offsetof(PRQINFO52W, pszDependentNames[52]),
                        offsetof(PRQINFO52W, pszDependentNames[53]),
                        offsetof(PRQINFO52W, pszDependentNames[54]),
                        offsetof(PRQINFO52W, pszDependentNames[55]),
                        offsetof(PRQINFO52W, pszDependentNames[56]),
                        offsetof(PRQINFO52W, pszDependentNames[57]),
                        offsetof(PRQINFO52W, pszDependentNames[58]),
                        offsetof(PRQINFO52W, pszDependentNames[59]),
                        offsetof(PRQINFO52W, pszDependentNames[60]),
                        offsetof(PRQINFO52W, pszDependentNames[61]),
                        offsetof(PRQINFO52W, pszDependentNames[62]),
                        offsetof(PRQINFO52W, pszDependentNames[63]),
                        (DWORD) -1};

DBGSTATIC LPWSTR
CopyPrinterToPrqInfoW(
    IN LPPRINTER_INFO_2 pPrinter,
    IN DWORD Level,
    OUT LPBYTE pBuffer,
    IN LPCWSTR QueueNameW,
    OUT LPWSTR pEnd
    )
{
    LPSTR *pSourceStrings;

    NetpAssert( pEnd != NULL );
    NetpAssert( QueueNameW != NULL );
    NetpAssert( (*QueueNameW) != L'\0' );

    switch (Level) {

    case 0:
        (VOID) wcsncpy(
                (LPWSTR) (LPVOID) pBuffer,
                QueueNameW,
                LM20_QNLEN);
        break;

    case 1: /*FALLTHROUGH*/
    case 2:

        {
            LPSTR SourceStrings[sizeof(PrqInfo1StringsW)/sizeof(DWORD)];
            PPRQINFOW pPrqInfo = (LPVOID) pBuffer;

            pSourceStrings=SourceStrings;
            *pSourceStrings++ = pPrinter->pSepFile;
            *pSourceStrings++ = pPrinter->pPrintProcessor;
            *pSourceStrings++ = pPrinter->pPortName;
            *pSourceStrings++ = pPrinter->pParameters;
            *pSourceStrings++ = pPrinter->pComment;

            pEnd = PackAnsiStringsToW(
                    SourceStrings,
                    (LPBYTE) (LPVOID) pPrqInfo,
                    PrqInfo1StringsW,
                    pEnd);

            NetpAssert( QueueNameW != NULL );

            (VOID) wcsncpy(
                    pPrqInfo->szName,  // dest
                    QueueNameW,        // src
                    LM20_QNLEN);     // char count
            pPrqInfo->szName[LM20_QNLEN] = (USHORT)0;

            pPrqInfo->uPriority = (WORD)pPrinter->Priority;
            pPrqInfo->uStartTime = (WORD)pPrinter->StartTime;
            pPrqInfo->uUntilTime = (WORD)pPrinter->UntilTime;

            pPrqInfo->fsStatus = PrqStatusFromPrinterStatus( pPrinter->Status );

            pPrqInfo->cJobs = (WORD)pPrinter->cJobs;
        }

        break;

    case 3: /*FALLTHROUGH*/
    case 4:
        {
            LPSTR SourceStrings[sizeof(PrqInfo3StringsW)/sizeof(DWORD)];
            PPRQINFO3W pPrqInfo = (LPVOID) pBuffer;

            //
            // Copy queue name first, as it is already right char set.
            //
            NetpAssert( QueueNameW != NULL );
            pEnd-=(wcslen(QueueNameW) + 1);

            (VOID) wcscpy(pEnd, QueueNameW);

            pPrqInfo->pszName = pEnd;

            //
            // Copy and convert other strings.
            //
            pSourceStrings=SourceStrings;
            *pSourceStrings++ = pPrinter->pSepFile;
            *pSourceStrings++ = pPrinter->pPrintProcessor;
            *pSourceStrings++ = pPrinter->pParameters;
            *pSourceStrings++ = pPrinter->pComment;
            *pSourceStrings++ = pPrinter->pPortName;  // pszPrinters
            *pSourceStrings++ = pPrinter->pDriverName;

            pEnd = PackAnsiStringsToW(
                    SourceStrings,
                    (LPBYTE) (LPVOID) pPrqInfo,
                    PrqInfo3StringsW,
                    pEnd);

            pPrqInfo->uPriority = (WORD)pPrinter->Priority;
            pPrqInfo->uStartTime = (WORD)pPrinter->StartTime;
            pPrqInfo->uUntilTime = (WORD)pPrinter->UntilTime;

            pPrqInfo->fsStatus = PrqStatusFromPrinterStatus( pPrinter->Status );

            pPrqInfo->cJobs = (WORD)pPrinter->cJobs;
            pPrqInfo->pDriverData = NULL;  

            // Note: if level is 4, caller will add array of jobs after this.

            break;
        }

    case 5:
        NetpAssert( QueueNameW != NULL );

        pEnd -= (wcslen( QueueNameW ) + 1);
        * (LPWSTR *) pBuffer = pEnd;

        (VOID) wcscpy(
                pEnd,           // dest
                QueueNameW );   // src


        break;

    default:
        NetpKdPrint(( PREFIX_DOSPRINT
                "CopyPrinterToPrqInfoW: invalid level!\n" ));

    }

    return pEnd;
}

DBGSTATIC LPWSTR
CopyDriverToPrqInfoW(
    IN  LPDRIVER_INFO_3A    pDriver3,
    IN  DWORD               dwDependentFileCount,
    IN  LPSTR               pUNCSharePath,
    IN  DWORD               Level,
    OUT LPBYTE              pBuffer,
    OUT LPWSTR              pEnd
    )
{
    LPSTR   *pSourceStrings;
    LPSTR   psz;

    NetpAssert( pEnd != NULL );
    NetpAssert(MAX_DEPENDENT_FILES == 64);

    switch (Level) {

    case 52:
        {
            PPRQINFO52W pPrqInfo = (LPVOID) pBuffer;
            LPSTR SourceStrings[sizeof(PrqInfo52StringsW)/sizeof(DWORD)];

            ZeroMemory((LPBYTE)SourceStrings, sizeof(SourceStrings));

            pSourceStrings=SourceStrings;
            *pSourceStrings++ = pDriver3->pName;
            *pSourceStrings++ = GetFileNameA(pDriver3->pDriverPath);
            *pSourceStrings++ = GetFileNameA(pDriver3->pDataFile);
            *pSourceStrings++ = GetFileNameA(pDriver3->pMonitorName);
            *pSourceStrings++ = pUNCSharePath;
            *pSourceStrings++ = GetFileNameA(pDriver3->pDefaultDataType);
            *pSourceStrings++ = GetFileNameA(pDriver3->pHelpFile);
            *pSourceStrings++ = GetFileNameA(pDriver3->pConfigFile);

            for ( psz = pDriver3->pDependentFiles ;
                  psz && *psz ; psz += strlen(psz) + 1 ) {

                *pSourceStrings++ = GetDependentFileNameA(psz);
            }

            pEnd = PackAnsiStringsToW(
                    SourceStrings,
                    (LPBYTE) (LPVOID)pPrqInfo,
                    PrqInfo52StringsW,
                    pEnd);

            pPrqInfo->uVersion = (WORD)pDriver3->cVersion;
            pPrqInfo->cDependentNames = (WORD)dwDependentFileCount;
        }

        break;


    default:
        NetpKdPrint(( PREFIX_DOSPRINT
                "CopyPrinterToPrqInfoW: invalid level!\n" ));

    }

    return pEnd;
}

DBGSTATIC NET_API_STATUS
ComputeSpaceNeededForJobs(
    IN  LPCWSTR          QueueNameW,
    IN  DWORD            QLevel,
    IN  HANDLE           PrinterHandle,
    OUT LPDWORD          pcbNeeded
    )
{
    NET_API_STATUS ApiStatus;
    DWORD          cJobs;
    DWORD          cbJobs;
    DWORD          cbNeeded = 0;
    DWORD          JobLevel;
    LPJOB_INFO_2   pJob = NULL;
    LPJOB_INFO_2   pJobs = NULL;

    NetpAssert( (QLevel==2) || (QLevel==4) );
    NetpAssert( QueueNameW != NULL );

    if (QLevel==2) {
        JobLevel = 1;
    } else {
        JobLevel = 2;
    }


    if (!MyEnumJobs(PrinterHandle, 0, (DWORD) -1, 2, NULL, 0, &cbJobs, &cJobs)) {

        ApiStatus = (NET_API_STATUS) GetLastError();
        if (ApiStatus == ERROR_INSUFFICIENT_BUFFER) {

            pJobs = (LPVOID) GlobalAlloc(GMEM_FIXED, cbJobs);
            if (pJobs == NULL) {

                ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

        } else {
            NetpKdPrint(( PREFIX_DOSPRINT
                    "ComputeSpaceNeededForJobs: got error " FORMAT_API_STATUS
                    " from MyEnumJobs(first).\n", ApiStatus ));
            goto Cleanup;
        }
    }

    if (!MyEnumJobs(PrinterHandle, 0, (DWORD) -1, 2, (LPBYTE)pJobs, cbJobs,
                              &cbJobs, &cJobs)) {

        ApiStatus = (NET_API_STATUS) GetLastError();
        NetpAssert( ApiStatus != ERROR_INSUFFICIENT_BUFFER );
        NetpKdPrint(( PREFIX_DOSPRINT
                "ComputeSpaceNeededForJobs: got error " FORMAT_API_STATUS
                " from MyEnumJobs(second)\n", ApiStatus ));
        goto Cleanup;
    }

    if (cJobs == 0) {
        cbNeeded = 0;
        ApiStatus = NO_ERROR;
        goto Cleanup;
    }
    if (pJobs == NULL) {
        NetpKdPrint(( PREFIX_DOSPRINT
                "ComputeSpaceNeededForJobs: never allocated array!\n" ));
        ApiStatus = NERR_InternalError;
        goto Cleanup;
    }

    pJob=pJobs;

    while (cJobs--) {
        cbNeeded+=GetPrjInfoSizeW(JobLevel, pJob++, QueueNameW);
    }

    *pcbNeeded=(WORD)cbNeeded;  // final byte count for this queue's jobs.

    ApiStatus = NO_ERROR;

Cleanup:
    if (pJobs != NULL) {
        (VOID) GlobalFree(pJobs);
    }

    *pcbNeeded = cbNeeded;  // final byte count for this queue's jobs.

    return (ApiStatus);

} // ComputeSpaceNeededForJobs

DBGSTATIC NET_API_STATUS
AppendJobsToPrqW(
    IN LPCWSTR QueueNameW,
    IN DWORD QLevel,
    IN HANDLE PrinterHandle,
    OUT LPBYTE pbBuf,
    IN DWORD cbBuf,
    IN LPVOID pEnd,
    OUT LPVOID * pNewEnd,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned,
    IN BOOL AllowPartialData
    )
{
    DWORD cJobs;
    DWORD cbJobs;
    DWORD cbNeeded = 0;
    DWORD cbPrj;
    DWORD JobLevel;
    DWORD rc;
    DWORD JobSize;
    DWORD BytesLeft;
    DWORD JobsStored;
    LPJOB_INFO_2 pJob = NULL;
    LPJOB_INFO_2 pJobs = NULL;

    NetpAssert( (QLevel==2) || (QLevel==4) );
    NetpAssert( QueueNameW != NULL );

    if (QLevel==2) {
        cbPrj = sizeof(PRJINFOW);
        JobLevel = 1;
    } else {
        cbPrj = sizeof(PRJINFO2W);
        JobLevel = 2;
    }


    if (!MyEnumJobs(PrinterHandle, 0, (DWORD) -1, 2, NULL, 0, &cbJobs, pcReturned)) {

        rc = GetLastError();
        if (rc == ERROR_INSUFFICIENT_BUFFER) {

            pJobs = (LPVOID) GlobalAlloc(GMEM_FIXED, cbJobs);
            if (pJobs == NULL) {

                rc = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

        } else {
            NetpKdPrint(( PREFIX_DOSPRINT
                    "AppendJobsToPrqW: got error " FORMAT_API_STATUS
                    " from MyEnumJobs(first)\n", rc ));
            goto Cleanup;
        }
    }

    if (!MyEnumJobs(PrinterHandle, 0, (DWORD) -1, 2, (LPBYTE)pJobs, cbJobs,
                              &cbJobs, pcReturned)) {

        rc = GetLastError();
        NetpAssert( rc != ERROR_INSUFFICIENT_BUFFER );
        NetpKdPrint(( PREFIX_DOSPRINT
                "AppendJobsToPrqW: got error " FORMAT_API_STATUS
                " from MyEnumJobs(second)\n", rc ));
        goto Cleanup;
    }

    if (*pcReturned == 0) {
        cbNeeded = 0;
        rc = NO_ERROR;
        goto Cleanup;
    }
    if (pJobs == NULL) {
        NetpKdPrint(( PREFIX_DOSPRINT
                "AppendJobsToPrqW: never allocated array!\n" ));
        rc = NERR_InternalError;
        goto Cleanup;
    }

    cJobs = *pcReturned;
    pJob=pJobs;

    while (cJobs--)
        cbNeeded+=GetPrjInfoSizeW(JobLevel, pJob++, QueueNameW);

    *pcbNeeded = cbNeeded;  // final byte count for this queue's jobs.

    if (cbNeeded <= cbBuf) {

        cJobs = *pcReturned;
        pJob=pJobs;
        while (cJobs--) {
            pEnd = CopyJobToPrjInfoW(JobLevel, pJob++, QueueNameW,
                    pbBuf,
                    pEnd);
            pbBuf += cbPrj;  // Note: Wasn't DWORD aligned
        }
        rc = NO_ERROR;

    } else {

        //
        //  See if the user wants to receive as much data as we can fit.
        //

        if( AllowPartialData == TRUE ) {

            cJobs = *pcReturned;
            pJob = pJobs;
            JobsStored = 0;
            BytesLeft = cbBuf;

            while( cJobs-- ) {

                JobSize = GetPrjInfoSizeW( JobLevel,
                                           pJob,
                                           QueueNameW );

                if( JobSize <= BytesLeft ) {

                    //
                    //  This job will fit.  Add it in.
                    //

                    pEnd = CopyJobToPrjInfoW( JobLevel,
                                              pJob++,
                                              QueueNameW,
                                              pbBuf,
                                              pEnd );

                    pbBuf += cbPrj;  // Note: Wasn't DWORD aligned
                    BytesLeft -= JobSize;
                    JobsStored++;

                } else {

                    //
                    //  The buffer is full.
                    //

                    break;
                }
            }

            if( JobsStored != 0 ) {

                //
                //  Return what we were able to store.
                //

                *pcReturned = JobsStored;
                rc = NO_ERROR;

            } else {

                rc = NERR_BufTooSmall;
            }

        } else {

            rc = NERR_BufTooSmall;
        }
    }

Cleanup:
    if (pJobs != NULL) {
        (VOID) GlobalFree(pJobs);
    }

    *pcbNeeded = cbNeeded;  // final byte count for this queue's jobs.

    if (pNewEnd != NULL) {
        *pNewEnd = pEnd;
    }

    return (rc);

}

SPLERR SPLENTRY DosPrintQGetInfoW(
    LPWSTR  pszServer,
    LPWSTR  pszQueueName,
    WORD    uLevel,
    PBYTE   pbBuf,
    WORD    cbBuf,
    PUSHORT pcbNeeded
   )
{
    DWORD               cJobsReturned;
    LPWSTR              pEnd;
    DWORD               rc;
    HANDLE              hPrinter = INVALID_HANDLE_VALUE;
    LPPRINTER_INFO_2    pPrinter = NULL;
    LPDRIVER_INFO_3A    pDriver = NULL;
    CHAR                szDriverDir[MAX_PATH];
    DWORD               cbNeeded = 0, dwDependentFileCount;
    DWORD               cbNeededForJobs;

    if (pszServer && *pszServer) {
        rc = RxPrintQGetInfo(pszServer, pszQueueName, uLevel, pbBuf,
                               cbBuf, &cbNeeded);
        if (cbNeeded > MAX_WORD) {
            rc = MY_PROTOCOL_LIMIT_ERROR;
            goto Cleanup;
        }
        *pcbNeeded = (USHORT)cbNeeded;
        goto Cleanup;
    }

    *pcbNeeded = 0;  // in case an error occurs.
    if ( !NetpIsPrintQLevelValid( uLevel, FALSE ) ) {
        rc = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }
    if ( (pszQueueName==NULL) || ((*pszQueueName)==L'\0') ) {
        rc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if ( !MyOpenPrinterW( pszQueueName, &hPrinter, NULL) ) {

        rc = GetLastError();
        if ( rc == ERROR_INVALID_PRINTER_NAME )
            rc = NERR_QNotFound;
        goto Cleanup;

    }

    //
    // Level 52 is meant for point and print from a Windows 95 clients
    // can't use with other clients since no environment info is passed
    //
    if ( uLevel == 52 ) {

        cbNeeded = sizeof(szDriverDir)-2;
        szDriverDir[0] = szDriverDir[1] = '\\';
        if ( !GetComputerNameA(szDriverDir+2, &cbNeeded) ) {

            rc = GetLastError();
            goto Cleanup;
        }

        if ( strlen(szDriverDir) + strlen(WIN95_DRIVER_SHARE) + 1
                                                    > sizeof(szDriverDir) ) {

            rc = ERROR_NOT_ENOUGH_MEMORY;
            NetpAssert( rc != NO_ERROR ); // Always break
            goto Cleanup;
        }

        strcat(szDriverDir, WIN95_DRIVER_SHARE);

        (VOID)MyGetPrinterDriver(hPrinter, WIN95_ENVIRONMENT, 3,
                                 NULL, 0, &cbNeeded);
        rc = GetLastError();
        if ( rc != ERROR_INSUFFICIENT_BUFFER )
            goto Cleanup;

        pDriver = (LPVOID) GlobalAlloc(GMEM_FIXED, cbNeeded);
        if ( !pDriver ) {

            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        if ( !MyGetPrinterDriver(hPrinter, WIN95_ENVIRONMENT, 3,
                                 (LPVOID)pDriver, cbNeeded, &cbNeeded) ) {

            rc = GetLastError();
            goto Cleanup;
        }

        cbNeeded=GetDrvInfoSizeW(uLevel, pDriver,
                                 szDriverDir, &dwDependentFileCount);
        if ( dwDependentFileCount > MAX_DEPENDENT_FILES ) {

            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    } else {

        if (!MyGetPrinter(hPrinter, 2, NULL, 0, &cbNeeded)) {

            rc = GetLastError();
            if (rc == ERROR_INSUFFICIENT_BUFFER) {

                pPrinter = (LPVOID) GlobalAlloc(GMEM_FIXED, cbNeeded);
                if (pPrinter == NULL) {

                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }
            } else {
                goto Cleanup;
            }

        }

        if (!MyGetPrinter(hPrinter, 2, (LPBYTE)pPrinter, cbNeeded, &cbNeeded)) {

            rc = GetLastError();
            goto Cleanup;
        }

        // How much for just the queue structure and its strings?
        cbNeeded=GetPrqInfoSizeW(uLevel, pszQueueName, pPrinter);
    }


    if (cbNeeded > MAX_WORD) {
        rc = MY_PROTOCOL_LIMIT_ERROR;
        goto Cleanup;
    }
    *pcbNeeded = (WORD)cbNeeded;  // Tell caller the size (so far).

    //
    // Build the queue structure itself.
    //
    if (cbNeeded <= (DWORD) cbBuf) {

        if ( uLevel == 52 ) {

            ZeroMemory(pbBuf, cbNeeded);
            pEnd = CopyDriverToPrqInfoW(pDriver, dwDependentFileCount,
                                        szDriverDir, uLevel, pbBuf,
                                        (LPWSTR) (pbBuf+cbBuf) );
        } else {

            pEnd = CopyPrinterToPrqInfoW(pPrinter, uLevel, pbBuf, pszQueueName,
                                         (LPWSTR) (pbBuf+cbBuf) );
        }

    } else {

        //
        // Too small.  Well, need to find total size before we can tell caller.
        //
        if ( (uLevel==2) || (uLevel==4) ) {
            rc = ComputeSpaceNeededForJobs(
                    pszQueueName,
                    uLevel,             // Q info level
                    hPrinter,
                    & cbNeededForJobs );
            if (rc != NO_ERROR) {
                goto Cleanup;
            }
            cbNeeded += cbNeededForJobs;
        }
        if (cbNeeded > MAX_WORD) {
            rc = MY_PROTOCOL_LIMIT_ERROR;
            goto Cleanup;
        }
        rc = NERR_BufTooSmall;
        goto Cleanup;
    }

    //
    // Append jobs if necessary.
    //

    if ( (uLevel==2) || (uLevel==4) ) {
        DWORD cbPrq = PrqInfoFixedSizeW( uLevel );

        rc = AppendJobsToPrqW(
                pszQueueName,
                uLevel,             // Q info level
                hPrinter,
                pbBuf + cbPrq,      // put first job here
                cbBuf - cbNeeded,   // bytes avail for jobs
                pEnd,               // str area
                NULL,               // don't need new pEnd
                & cbNeededForJobs,
                & cJobsReturned,
                cbBuf == MAX_WORD ? TRUE : FALSE );  // If the buffer is at its max, get what we can.

        if( cbNeeded + cbNeededForJobs > MAX_WORD ) {
            *pcbNeeded = MAX_WORD;
        } else {
            *pcbNeeded = (USHORT) (cbNeeded + cbNeededForJobs);
        }

        //
        // Update job count in queue structure, as it may be out of date.
        //

        NetpSetJobCountForQueue(
                uLevel,                 // queue info level
                pbBuf,                  // queue structure to update
                TRUE,                   // yes, UNICODE strings
                cJobsReturned );        // actual job count

        if (rc != NO_ERROR) {
            goto Cleanup;
        }

    }

    rc = NO_ERROR;

Cleanup:

    if (hPrinter != INVALID_HANDLE_VALUE) {
        (VOID) MyClosePrinter( hPrinter );
    }

    if (pPrinter) {
        (VOID) GlobalFree( pPrinter );
    }

    if (pDriver) {

        (VOID) GlobalFree( pDriver );
    }

    return rc;
}


SPLERR SPLENTRY DosPrintJobGetInfoW(
    LPWSTR  pszServer,
    BOOL    bRemote,
    WORD    uJobId,
    WORD    uLevel,
    PBYTE   pbBuf,
    WORD    cbBuf,
    PUSHORT pcbNeeded
)
{
    DWORD               cb;
    HANDLE              hPrinter = INVALID_HANDLE_VALUE;
    LPSTR               QueueNameA = NULL;
    LPWSTR              QueueNameW = NULL;
    LPJOB_INFO_2        pJob = NULL;
    LPWSTR              pEnd;
    DWORD               rc;
    DWORD               cbNeeded = 0;

    if (bRemote) {
        rc = RxPrintJobGetInfo(pszServer, uJobId, uLevel, pbBuf,
                                 cbBuf, &cbNeeded);
        *pcbNeeded = (USHORT)cbNeeded;
        return rc;
    }

    *pcbNeeded = 0;  // in case an error occurs.

    if ( !NetpIsPrintJobLevelValid( uLevel, FALSE ) ) {
        rc = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    //
    // The 3.51 spooler has been changed to accept Get/SetJobs on the
    // local server handle.  We will still do security checks against
    // the Job's security descriptor.  This also avoids the costly
    // FindLocalJob() call.
    //
    if (!MyOpenPrinterW( pszServer, &hPrinter, NULL)) {
        rc = GetLastError();
        NetpKdPrint((PREFIX_DOSPRINT "DosPrintJobSetInfoW: "
                "MyOpenPrinter( NULL, &hPrinter, NULL ) failed"
                FORMAT_API_STATUS "\n", rc ));

        hPrinter = INVALID_HANDLE_VALUE;
        goto Cleanup;
    }
    NetpAssert( hPrinter != INVALID_HANDLE_VALUE );

    //
    // Note: this should really call MyGetJobW, since it looks
    // like the code later thunks from ansi back to unicode.
    //
    if (!MyGetJobA(hPrinter, uJobId, 2, NULL, 0, &cb)) {

        rc=GetLastError();

        NetpAssert( rc != NO_ERROR );
        if (rc == ERROR_INSUFFICIENT_BUFFER) {

            pJob = (LPVOID) GlobalAlloc(GMEM_FIXED, cb);
            if (pJob == NULL) {
                rc = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            if ( !MyGetJobA(hPrinter, uJobId, 2, (LPBYTE)pJob, cb, &cb) ) {
                rc=GetLastError();
                NetpAssert( rc != NO_ERROR );
                goto Cleanup;
            }

        } else {
            if (rc == ERROR_INVALID_PARAMETER) {
                rc = NERR_JobNotFound;
            }
            goto Cleanup;  // Job deleted?  Not enough mem?
        }

    }
    if (pJob == NULL) {
        NetpKdPrint((PREFIX_DOSPRINT "DosPrintJobGetInfoW: "
                "*** STILL INVALID RESULT FROM MyGetJob, pJob IS NULL!\n" ));
        rc = NERR_InternalError;
        goto Cleanup;
    }

    NetpAssert( pJob != NULL );
    NetpAssert( pJob->pPrinterName != NULL );
    QueueNameA = FindQueueNameInPrinterNameA(
            (pJob->pPrinterName) );
    NetpAssert( QueueNameA != NULL );
    QueueNameW = NetpAllocWStrFromStr( QueueNameA );
    if (QueueNameW == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    NetpAssert( QueueNameW != NULL );

    cb=GetPrjInfoSizeW(uLevel, pJob, QueueNameW);

    *pcbNeeded=(WORD)cb;

    if (cb > (DWORD) cbBuf) {
        rc = NERR_BufTooSmall;
        goto Cleanup;
    }

    pEnd = (LPVOID) (pbBuf+cbBuf);

    (VOID) CopyJobToPrjInfoW(uLevel, pJob, QueueNameW, pbBuf, pEnd);

    rc = NO_ERROR;

Cleanup:

    if (hPrinter != INVALID_HANDLE_VALUE) {
        (VOID) MyClosePrinter( hPrinter );
    }
    if (pJob != NULL) {
        (VOID) GlobalFree( pJob );
    }
    if (QueueNameW != NULL) {
        (VOID) NetApiBufferFree( QueueNameW );
    }

    return (rc);

}

SPLERR SPLENTRY DosPrintJobDelW(
    LPWSTR  pszServer,
    BOOL    bRemote,
    WORD    uJobId
)
{

    if (bRemote)
        return RxPrintJobDel(pszServer, uJobId);

    return (CommandALocalJobA(NULL, pszServer, NULL, uJobId, 0, NULL, JOB_CONTROL_CANCEL ) );
}

SPLERR SPLENTRY DosPrintJobContinueW(
    LPWSTR  pszServer,
    BOOL    bRemote,
    WORD    uJobId
)
{

    if (bRemote)
        return RxPrintJobContinue(pszServer, uJobId);

    return (CommandALocalJobA(NULL, pszServer, NULL, uJobId, 0, NULL, JOB_CONTROL_RESUME ) );
}

SPLERR SPLENTRY DosPrintJobPauseW(
   LPWSTR pszServer,
   BOOL   bRemote,
   WORD  uJobId
)
{

    if (bRemote)
        return RxPrintJobPause(pszServer, uJobId);

    return (CommandALocalJobA(NULL, pszServer, NULL, uJobId, 0, NULL, JOB_CONTROL_PAUSE ) );
}

SPLERR SPLENTRY DosPrintJobEnumW(
    LPWSTR  pszServer,
    LPWSTR  pszQueueName,
    WORD    uLevel,
    PBYTE   pbBuf,
    WORD    cbBuf,
    PWORD   pcReturned,
    PWORD   pcTotal
)
{
    DWORD               cbPrinter;
    LPJOB_INFO_2        pJob = NULL;
    LPJOB_INFO_2        pJobs;
    DWORD               cb, cbJobs, cReturned, cJobs;
    HANDLE              hPrinter = INVALID_HANDLE_VALUE;
    LPWSTR              pEnd;
    DWORD               rc;
    DWORD               cTotal;

    if (pszServer && *pszServer) {
        rc = RxPrintJobEnum(pszServer, pszQueueName, uLevel, pbBuf,
                              cbBuf, &cReturned, &cTotal);
        *pcReturned = (WORD)cReturned;
        *pcTotal = (WORD)cTotal;
        goto Cleanup;
    }

    *pcReturned=0;
    *pcTotal = 0;

    if ( !NetpIsPrintJobLevelValid( uLevel, FALSE ) ) {
        rc = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    if (!MyOpenPrinterW( pszQueueName, &hPrinter, NULL)) {
        rc = GetLastError();
        goto Cleanup;
    }
    NetpAssert( hPrinter != INVALID_HANDLE_VALUE );

    if (!MyEnumJobs(hPrinter, 0, (DWORD) -1, 2, NULL, 0, &cbJobs, &cReturned)) {

        rc = GetLastError();
        NetpAssert( rc != NO_ERROR );
        if (rc == ERROR_INSUFFICIENT_BUFFER) {

            if (pJob = (LPVOID) GlobalAlloc(GMEM_FIXED, cbJobs)) {

                if (!MyEnumJobs(hPrinter, 0, (DWORD) -1, 2, (LPBYTE)pJob, cbJobs,
                              &cbJobs, &cReturned)) {

                    rc = GetLastError();
                    NetpAssert( rc != NO_ERROR );
                    NetpAssert( rc != ERROR_INSUFFICIENT_BUFFER );  
                    NetpKdPrint(( PREFIX_DOSPRINT
                            "DosPrintJobEnumW: got error " FORMAT_API_STATUS
                            " from MyEnumJobs(first)\n", rc ));
                    goto Cleanup;
                }
            } else {

                rc = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
        } else {
            NetpKdPrint(( PREFIX_DOSPRINT
                    "DosPrintJobEnumW: got error " FORMAT_API_STATUS
                    " from MyEnumJobs(first)\n", rc ));
            goto Cleanup;
        }
    }

    if (cReturned == 0) {
        *pcReturned = 0;
        *pcTotal = 0;
        rc = NO_ERROR;
        goto Cleanup;
    }
    if (pJob == NULL) {
        NetpKdPrint(( PREFIX_DOSPRINT
                "DosPrintJobEnumW: never allocated array!\n" ));
        rc = NERR_InternalError;
        goto Cleanup;
    }


    *pcTotal = (WORD)cReturned;

    cb=0;
    cJobs=cReturned;
    pJobs=pJob;
    while (cJobs--)
        cb+=GetPrjInfoSizeW(uLevel, pJobs++, pszQueueName);

    if (cb <= (DWORD) cbBuf) {

        DWORD cbFixedPortion = PrjInfoFixedSizeW( uLevel );
        NetpAssert( cbFixedPortion != 0 );  // level already checked!

        pEnd = (LPWSTR)(pbBuf+cbBuf);

        cJobs=cReturned;
        pJobs=pJob;

        while (cJobs--) {

            pEnd = CopyJobToPrjInfoW(uLevel, pJobs++,
                    pszQueueName,
                    pbBuf, pEnd);
            pbBuf += cbFixedPortion;
        }

        *pcReturned = (WORD)cReturned;
        rc = NO_ERROR;

    } else {

        rc = NERR_BufTooSmall;
        goto Cleanup;
    }

Cleanup:

    if (hPrinter != INVALID_HANDLE_VALUE) {
        (VOID) MyClosePrinter( hPrinter );
    }
    if (pJob != NULL) {
        (VOID) GlobalFree( pJob );
    }

    return rc;
}

SPLERR SPLENTRY
DosPrintDestEnumW(
    IN LPWSTR pszServer OPTIONAL,
    IN WORD uLevel,
    OUT PBYTE pbBuf,
    IN WORD cbBuf,
    OUT PUSHORT pcReturned,
    OUT PUSHORT pcTotal
    )
{
    DWORD   cReturned=0, cTotal=0, rc;

    if (pszServer && *pszServer) {
        rc = RxPrintDestEnum(pszServer, uLevel, pbBuf, cbBuf,
                               &cReturned, &cTotal);
        *pcReturned = (USHORT)cReturned;
        *pcTotal = (USHORT)cTotal;
        return rc;
    }

    // Stub for local dest enum - no entries, dest not found.
    *pcReturned = 0;
    *pcTotal = 0;
    return ERROR_NOT_SUPPORTED;
}

SPLERR SPLENTRY DosPrintDestControlW(
            LPWSTR  pszServer,
            LPWSTR  pszDevName,
            WORD    uControl
)
{
    if (pszServer && *pszServer)
        return RxPrintDestControl(pszServer, pszDevName, uControl);

    return ERROR_NOT_SUPPORTED;
}


SPLERR SPLENTRY DosPrintDestGetInfoW(
            LPWSTR  pszServer,
            LPWSTR  pszName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcbNeeded
)
{
    DWORD   cbNeeded = 0, rc;

    if (pszServer && *pszServer) {
        rc = RxPrintDestGetInfo(pszServer, pszName, uLevel, pbBuf,
                                  cbBuf, &cbNeeded);
        *pcbNeeded = (USHORT)cbNeeded;
        return rc;
    }

    return ERROR_NOT_SUPPORTED;
}

SPLERR SPLENTRY DosPrintDestAddW(
            LPWSTR  pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf
)
{
    if (pszServer && *pszServer)
        return RxPrintDestAdd(pszServer, uLevel, pbBuf, cbBuf);

    return ERROR_NOT_SUPPORTED;
}

SPLERR SPLENTRY DosPrintDestSetInfoW(
            LPWSTR  pszServer,
            LPWSTR  pszName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            WORD    uParmNum
)
{
    if (pszServer && *pszServer)
        return RxPrintDestSetInfo(pszServer, pszName, uLevel, pbBuf,
                                  cbBuf, uParmNum);

    return ERROR_NOT_SUPPORTED;
}

SPLERR SPLENTRY DosPrintDestDelW(
            LPWSTR  pszServer,
            LPWSTR  pszPrinterName
)
{
    if (pszServer && *pszServer)
        return RxPrintDestDel(pszServer, pszPrinterName);

    return ERROR_NOT_SUPPORTED;
}

SPLERR SPLENTRY DosPrintQEnumW(
            LPWSTR  pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcReturned,
            PUSHORT pcTotal
)
{
    DWORD               cJobsReturned;
    DWORD               Total, cbNeeded, rc;
    HANDLE              hPrinter = INVALID_HANDLE_VALUE;
    DWORD               i;
    DWORD               JobFixedEntrySize = 0;
    DWORD               JobLevel;
    LPSHARE_INFO_1      pShareInfo = NULL;
    DWORD               cbPrinter;
    LPPRINTER_INFO_2    pPrinter = NULL;
    BOOL                BufferTooSmall=FALSE;
    DWORD               cReturned = 0;
    DWORD               cTotal = 0;
#if DBG
    LPVOID              OutputBufferStart = pbBuf;
#endif
    LPVOID              pEnd;
    DWORD               SharesRead;

    if ( !NetpIsPrintQLevelValid( uLevel, FALSE ) ) {
        rc = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    if (pszServer && *pszServer) {
        rc = RxPrintQEnum(pszServer, uLevel, pbBuf, cbBuf, &cReturned, &cTotal);
        *pcReturned = (USHORT)cReturned;
        *pcTotal = (USHORT)cTotal;
        goto Cleanup;
    }

    *pcReturned = 0;
    *pcTotal = 0;

    rc=NetShareEnum(
            NULL,
            1,
            (LPBYTE *)(LPVOID)&pShareInfo,
            MAX_PREFERRED_LENGTH,
            &SharesRead,
            &Total,
            NULL);
    if (rc != NO_ERROR) {

        NetpKdPrint((PREFIX_DOSPRINT "DosPrintQEnumW: NetShareEnum returned "
                FORMAT_API_STATUS "\n", rc));
        goto Cleanup;
    }

    pEnd = (pbBuf + cbBuf);

    if (uLevel==2) {
        JobLevel = 1;
        JobFixedEntrySize = PrjInfoFixedSizeW( JobLevel );
    } else if (uLevel == 4) {
        JobLevel = 2;
        JobFixedEntrySize = PrjInfoFixedSizeW( JobLevel );
    }

    for (i=0; i<SharesRead; i++) {

        if (pShareInfo[i].shi1_type != STYPE_PRINTQ) {
            continue;
        }

        NetpAssert( pShareInfo[i].shi1_netname != NULL );
        NetpAssert( (*pShareInfo[i].shi1_netname) != L'\0' );
        if (STRLEN( pShareInfo[i].shi1_netname ) > LM20_QNLEN) {
            continue;
        }

        if ( !MyOpenPrinterW(pShareInfo[i].shi1_netname, &hPrinter, NULL)) {
            rc = (NET_API_STATUS) GetLastError();
            NetpKdPrint(( PREFIX_DOSPRINT
                    "DosPrintQEnumW: MyOpenPrinter failed, status "
                    FORMAT_API_STATUS ".\n", rc ));
            NetpAssert( rc != NO_ERROR );
            goto Cleanup;
        }
        NetpAssert( hPrinter != INVALID_HANDLE_VALUE );

        if (!MyGetPrinter(hPrinter, 2, NULL, 0, &cbPrinter)) {

            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                rc = (NET_API_STATUS) GetLastError();
                NetpKdPrint(( PREFIX_DOSPRINT
                        "DosPrintQEnumW: MyGetPrinter(first) failed, status "
                        FORMAT_API_STATUS ".\n", rc ));
                NetpAssert( rc != NO_ERROR );
                goto Cleanup;
            }
        }
        NetpAssert( cbPrinter != 0 );

        pPrinter = (LPVOID) GlobalAlloc(GMEM_FIXED, cbPrinter);
        if (pPrinter == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        if ( !MyGetPrinter(hPrinter, 2, (LPBYTE)pPrinter,
                cbPrinter, &cbPrinter)) {
            rc = (NET_API_STATUS) GetLastError();
            NetpKdPrint(( PREFIX_DOSPRINT
                    "DosPrintQEnumW: MyGetPrinter(second) failed, status "
                    FORMAT_API_STATUS ".\n", rc ));
            NetpAssert( rc != NO_ERROR );
            goto Cleanup;
        }

        cbNeeded=GetPrqInfoSizeW(uLevel,
                pShareInfo[i].shi1_netname, // Q nam
                pPrinter);
        NetpAssert( cbNeeded > 0 );
        NetpAssert( cbNeeded <= (DWORD) MAX_WORD );

        if ( (!BufferTooSmall) && ((DWORD)cbBuf >= cbNeeded) ) {

            LPVOID pbQueue = pbBuf;
            //
            // Handle queue structure itself.
            //
            pEnd = CopyPrinterToPrqInfoW(pPrinter,
                      uLevel,
                      pbBuf,
                      pShareInfo[i].shi1_netname,
                      pEnd);

            pbBuf += PrqInfoFixedSizeW( uLevel );
            cbBuf -= (WORD) cbNeeded;

            //
            // Append job structures if needed.
            //
            if ( (uLevel==2) || (uLevel==4) ) {    // info level includes jobs

                NetpAssert( pbBuf < (LPBYTE) pEnd );
                rc = AppendJobsToPrqW(
                        pShareInfo[i].shi1_netname,
                        uLevel,    // Q info level
                        hPrinter,
                        pbBuf,  // first job here
                        cbBuf,  // bytes avail
                        pEnd,   // str area
                        & pEnd, // set new end ptr
                        & cbNeeded,
                        & cJobsReturned,
                        FALSE );            // Only accept all the data.
                if (rc == NERR_BufTooSmall) {
                    BufferTooSmall = TRUE;  // continue, as we need pcTotal...
                } else if (rc != NO_ERROR) {
                    goto Cleanup;
                } else {  // Must be NO_ERROR.
                    NetpAssert( cbNeeded <= (DWORD) MAX_WORD );
                    NetpAssert( pbBuf < (LPBYTE) pEnd );
                    NetpAssert( JobFixedEntrySize !=0 );

                    pbBuf += (JobFixedEntrySize * cJobsReturned);
                    cbBuf -= (WORD) cbNeeded;
                    (*pcReturned)++;

                    // Correct possible out of date
                    // job count in queue structure.
                    NetpSetJobCountForQueue(
                            uLevel,
                            pbQueue,
                            TRUE, // yes, UNICODE strs
                            cJobsReturned );
                }

            } else {  // info level does not include jobs

                (*pcReturned)++;
            }

        } else {  // not enough mem for Q struct

            BufferTooSmall = TRUE;
            // Continue, as we want to compute pcTotal for subsequent queues.
        }

        (*pcTotal)++;

        NetpAssert( pPrinter != NULL );
        (VOID) GlobalFree(pPrinter);
        pPrinter = NULL;

        NetpAssert( hPrinter != INVALID_HANDLE_VALUE );
        (VOID) MyClosePrinter(hPrinter);
        hPrinter = INVALID_HANDLE_VALUE;

    } // for each share

Cleanup:

    if (hPrinter != INVALID_HANDLE_VALUE) {
        (VOID) MyClosePrinter( hPrinter );
    }
    if (pPrinter != NULL) {
        (VOID) GlobalFree( pPrinter );
    }
    if (pShareInfo != NULL) {
        (VOID) NetApiBufferFree(pShareInfo);
    }

    if (BufferTooSmall) {
        rc = NERR_BufTooSmall;
    }

    return (rc);
}

SPLERR SPLENTRY DosPrintQSetInfoW(
            LPWSTR  pszServer,
            LPWSTR  pszQueueName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            WORD    uParmNum
)
{
    if (pszServer && *pszServer)
        return RxPrintQSetInfo(pszServer, pszQueueName, uLevel, pbBuf,
                               cbBuf, uParmNum);

    return ERROR_NOT_SUPPORTED;
}

SPLERR SPLENTRY DosPrintQPauseW(
            LPWSTR  pszServer,
            LPWSTR  pszQueueName
)
{
    if (pszServer && *pszServer)
        return RxPrintQPause(pszServer, pszQueueName);

    return (CommandALocalPrinterW( pszQueueName, PRINTER_CONTROL_PAUSE ) );
}

SPLERR SPLENTRY DosPrintQContinueW(
            LPWSTR  pszServer,
            LPWSTR  pszQueueName
)
{
    if (pszServer && *pszServer)
        return RxPrintQContinue(pszServer, pszQueueName);

    return (CommandALocalPrinterW( pszQueueName, PRINTER_CONTROL_RESUME ) );
}

SPLERR SPLENTRY DosPrintQPurgeW(
            LPWSTR  pszServer,
            LPWSTR  pszQueueName
)
{
    if (pszServer && *pszServer)
        return RxPrintQPurge(pszServer, pszQueueName);

    return (CommandALocalPrinterW( pszQueueName, PRINTER_CONTROL_PURGE ) );
}

SPLERR SPLENTRY DosPrintQAddW(
            LPWSTR  pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf
)
{
    if (pszServer && *pszServer)
        return RxPrintQAdd(pszServer, uLevel, pbBuf, cbBuf);

    return ERROR_NOT_SUPPORTED;
}

SPLERR SPLENTRY DosPrintQDelW(
            LPWSTR  pszServer,
            LPWSTR  pszQueueName
)
{
    if (pszServer && *pszServer)
        return RxPrintQDel(pszServer, pszQueueName);

    return ERROR_NOT_SUPPORTED;
}

SPLERR SPLENTRY DosPrintJobSetInfoW(
            LPWSTR  pszServer,
            BOOL    bRemote,
            WORD    uJobId,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            WORD    uParmNum
)
{
    if (bRemote)
        return RxPrintJobSetInfo(pszServer, uJobId, uLevel, pbBuf,
                                 cbBuf, uParmNum);

    //
    // Hack for Chicago: support Level 1, ParmNum 0xb so that jobs
    // are set with the comment field.
    //
    if (uLevel == 1 && uParmNum == PRJ_COMMENT_PARMNUM) {

        HANDLE hPrinter = INVALID_HANDLE_VALUE;
        CHAR szDocument[MAX_PATH];
        PJOB_INFO_1 pJob = NULL;
        DWORD cbJob;
        SPLERR rc;

        //
        // Allocate maximum size of JOB_INFO_1A.  Later, this
        // should be moved into the spooler's header file.
        //
        cbJob = sizeof(JOB_INFO_1) + 6 * MAX_PATH;

        pJob = (PJOB_INFO_1) GlobalAlloc(GMEM_FIXED, cbJob);

        if (pJob == NULL) {
            rc = GetLastError();
            goto Cleanup;
        }

        //
        // The 3.51 spooler has been changed to accept Get/SetJobs on the
        // local server handle.  We will still do security checks against
        // the Job's security descriptor.  This also avoids the costly
        // FindLocalJob() call.
        //
        if (!MyOpenPrinterW( pszServer, &hPrinter, NULL)) {
            rc = GetLastError();
            NetpKdPrint((PREFIX_DOSPRINT "DosPrintJobSetInfoW: "
                    "MyOpenPrinter( NULL, &hPrinter, NULL ) failed"
                    FORMAT_API_STATUS "\n", rc ));

            hPrinter = INVALID_HANDLE_VALUE;
            goto Cleanup;
        }
        NetpAssert( hPrinter != INVALID_HANDLE_VALUE );

        //
        // We need to get a copy of the old job info.  Later, the
        // spooler should be changed to allow "don't change" values.
        //
        if (!MyGetJobA( hPrinter, uJobId, 1, (PBYTE)pJob, cbJob, &cbJob )) {
            rc = GetLastError();
            NetpKdPrint((PREFIX_DOSPRINT "DosPrintJobSetInfoW: "
                    "MyGetJob failed" FORMAT_API_STATUS "\n", rc ));

            goto Cleanup;
        }

        //
        // Put in new document name.
        //
        NetpNCopyWStrToStr( szDocument,
                            (LPWSTR)pbBuf,
                            sizeof( szDocument ) / sizeof( szDocument[0] ));

        pJob->pDocument = szDocument;

        //
        // Don't try and change the position, since this requires
        // admin access (and isn't necessary).
        //
        pJob->Position = JOB_POSITION_UNSPECIFIED;

        rc = CommandALocalJobA( hPrinter, NULL, NULL, uJobId, 1, (PBYTE)pJob, 0 );

        if (rc) {
            NetpKdPrint((PREFIX_DOSPRINT "DosPrintJobSetInfoW: "
                    "CommandALocalJobA failed " FORMAT_API_STATUS "\n", rc ));
        }

Cleanup:
        if (pJob) {
            GlobalFree( pJob );
        }
        if (hPrinter != INVALID_HANDLE_VALUE) {
            MyClosePrinter( hPrinter );
        }
        return rc;
    }

    return ERROR_NOT_SUPPORTED;
}


VOID
NetpSetJobCountForQueue(
    IN     DWORD  QueueLevel,
    IN OUT LPVOID Queue,
    IN     BOOL   HasUnicodeStrings,
    IN     DWORD  JobCount
    )
{
    NetpAssert( NetpIsPrintQLevelValid( QueueLevel, FALSE ) );
    NetpAssert( Queue != NULL );

    if (QueueLevel == 2) {
        if (HasUnicodeStrings) {
            PPRQINFOW pq = Queue;
            pq->cJobs = (WORD) JobCount;
        } else {
            PPRQINFOA pq = Queue;
            pq->cJobs = (WORD) JobCount;
        }
    } else if (QueueLevel == 4) {
        if (HasUnicodeStrings) {
            PPRQINFO3W pq = Queue;
            pq->cJobs = (WORD) JobCount;
        } else {
            PPRQINFO3A pq = Queue;
            pq->cJobs = (WORD) JobCount;
        }
    } else {
        NetpAssert( FALSE );  // Should never get here!
    }


} // NetpSetJobCountForQueue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\dosprint\dosspool.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    dosspool.h

Abstract:

    Prototypes and manifests to support dosspool.C.

Author:

    congpay    22-Jan-1993

Environment:

Notes:

Revision History:

    22-Jan-1993     congpay Created

--*/
#include <winspool.h>

typedef
BOOL
(*PF_ClosePrinter)(
    HANDLE hPrinter
);

typedef
BOOL
(*PF_EnumJobsA)(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

typedef
BOOL
(*PF_EnumPrintersA)(
    DWORD   Flags,
    LPSTR   Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

typedef
BOOL
(*PF_GetJobA)(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
);

typedef
BOOL
(*PF_GetPrinterA)(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

typedef
BOOL
(*PF_OpenPrinterA)(
   LPSTR    pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTSA pDefault
);

typedef
BOOL
(*PF_OpenPrinterW)(
   LPWSTR   pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTSW pDefault
);

typedef
BOOL
(*PF_SetJobA)(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
);

typedef
BOOL
(*PF_SetPrinterW)(
    HANDLE hPrinter,
    DWORD  Level,
    LPBYTE pPrinter,
    DWORD  Command
);

typedef
BOOL
(*PF_GetPrinterDriverA)(
    HANDLE  hPrinter,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriver,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\accessp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    accessp.h

Abstract:

    Internal routines shared by NetUser API and Netlogon service.  These
    routines convert from SAM specific data formats to UAS specific data
    formats.

Author:

    Cliff Van Dyke (cliffv) 29-Aug-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

NET_API_STATUS
UaspInitialize(
    VOID
    );

VOID
UaspFlush(
    VOID
    );

VOID
UaspClose(
    VOID
    );

VOID
NetpGetAllowedAce(
    IN PACL Dacl,
    IN PSID Sid,
    OUT PVOID *Ace
    );

DWORD
NetpAccountControlToFlags(
    IN DWORD UserAccountControl,
    IN PACL UserDacl
    );

ULONG
NetpDeltaTimeToSeconds(
    IN LARGE_INTEGER DeltaTime
    );

LARGE_INTEGER
NetpSecondsToDeltaTime(
    IN ULONG Seconds
    );

VOID
NetpAliasMemberToPriv(
    IN ULONG AliasCount,
    IN PULONG AliasMembership,
    OUT LPDWORD Priv,
    OUT LPDWORD AuthFlags
    );

DWORD
NetpGetElapsedSeconds(
    IN PLARGE_INTEGER Time
    );

VOID
NetpConvertWorkstationList(
    IN OUT PUNICODE_STRING WorkstationList
    );

NET_API_STATUS
NetpSamRidToSid(
    IN SAM_HANDLE SamHandle,
    IN ULONG RelativeId,
    OUT PSID *Sid
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\access.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    access.h

Abstract:

    Structure definitions for Level 99 info levels for the NetUser and
    NetGroup APIs.

Author:

    Cliff Van Dyke (cliffv) 26-Aug-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\configp.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ConfigP.c

Abstract:

    This header file defines the private data structure used by the
    net config helpers.

Author:

    John Rogers (JohnRo) 26-Nov-1991

Environment:

    Only runs under NT.

Revision History:

    26-Nov-1991 JohnRo
        Created this file, to prepare for revised config handlers.
    22-Mar-1992 JohnRo
        Added support for using the real Win32 registry.
        Added support for FAKE_PER_PROCESS_RW_CONFIG handling.
    06-May-1992 JohnRo
        Enable win32 registry at last.
    12-Apr-1993 JohnRo
        RAID 5483: server manager: wrong path given in repl dialog.
--*/

#ifndef CONFIGP_H
#define CONFIGP_H


////////////////////////////// INCLUDES //////////////////////////////////


#include <lmcons.h>             // NET_API_STATUS, UNCLEN.
#include <winreg.h>             // HKEY.


////////////////////////////// EQUATES //////////////////////////////////


#define MAX_CLASS_NAME_LENGTH           ( 32 )


/////////////////////////// NET_CONFIG_HANDLE ///////////////////////////////


//
// LPNET_CONFIG_HANDLE is typedef'ed as LPVOID in config.h, which makes it
// an "opaque" type.  We translate it into a pointer to a NET_CONFIG_HANDLE
// structure:
//

typedef struct _NET_CONFIG_HANDLE {

    HKEY WinRegKey;             // Handle to section.

    DWORD LastEnumIndex;        // Most recent enum index.

    //
    // Server name if remote, TCHAR_EOS if local.
    //
    TCHAR UncServerName[MAX_PATH+1];

} NET_CONFIG_HANDLE;


////////////////////////////// ROUTINES AND MACROS ////////////////////////////


NET_API_STATUS
NetpGetWinRegConfigMaxSizes (
    IN  HKEY    WinRegHandle,
    OUT LPDWORD MaxKeywordSize OPTIONAL,
    OUT LPDWORD MaxValueSize OPTIONAL
    );

NET_API_STATUS
NetpGetConfigMaxSizes(
    IN NET_CONFIG_HANDLE * ConfigHandle,
    OUT LPDWORD MaxKeywordSize OPTIONAL,
    OUT LPDWORD MaxValueSize OPTIONAL
    );


///////////////////////////// THAT'S ALL, FOLKS! /////////////////////////////


#endif // ndef CONFIGP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\dosprint\myspool.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    myspool.h

Abstract:

    Prototypes and manifests for the functions used in dosprint.c, dosprtw.c
    and dosprtp.c.

Author:

    congpay    25-Jan-1993

Environment:

Notes:

Revision History:

    25-Jan-1993     congpay Created

--*/

#define WIN95_ENVIRONMENT       "Windows 4.0"

BOOL
MyClosePrinter(
    HANDLE hPrinter
);


BOOL
MyEnumJobs(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);


BOOL
MyEnumPrinters(
    DWORD   Flags,
    LPSTR   Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
MyGetJobA(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
);


BOOL
MyGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
MyOpenPrinterA(
   LPSTR    pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTSA pDefault
);


BOOL
MyOpenPrinterW(
   LPWSTR   pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTSW pDefault
);

BOOL
MySetJobA(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
);

BOOL
MySetPrinterW(
    HANDLE hPrinter,
    DWORD  Level,
    LPBYTE pPrinter,
    DWORD  Command
);

BOOL
MyGetPrinterDriver(
    HANDLE      hPrinter,
    LPSTR       pEnvironment,
    DWORD       Level,
    LPBYTE      pDriver,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded
    );

LPSTR
GetFileNameA(
    LPSTR   pPathName
    );

LPSTR
GetDependentFileNameA(
    LPSTR   pPathName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\debuglib.h ===
/*++

Copyright (c) 1990-1993 Microsoft Corporation

Module Name:

    DebugLib.h

Abstract:

    This include file defines the portable NetLib's debug stuff.

Author:

    John Rogers (JohnRo) 03-Apr-1991

Revision History:

    03-Apr-1991 JohnRo
        Created (copied stuff from LarryO's rdr/debug.h).
    13-Apr-1991 JohnRo
        Added debug flag for CONVSRV routine.
    16-Apr-1991 JohnRo
        Added NETLIB_DEBUG_ALL for use by RxTest.
    01-May-1991 JohnRo
        Added NETLIB_DEBUG_PACKSTR.
    02-May-1991 JohnRo
        Added NETLIB_DEBUG_PREFMAX.
    25-Jul-1991 JohnRo
        Quiet DLL stub debug output.  Delete unused DEBUG equate.
    26-Jul-1991 JohnRo
        Added NETLIB_DEBUG_SUPPORTS (this "API" is mostly used in DLL stubs).
    15-Aug-1991 JohnRo
        Implement downlevel NetWksta APIs.
    18-Oct-1991 JohnRo
        Implement remote NetSession APIs.
    30-Dec-1991 JohnRo
        Implemented NetLock helpers.
    06-May-1992 JohnRo
        Added NetpGetLocalDomainId() for PortUAS.
    10-May-1992 JohnRo
        Added debug prints to mem alloc code.
    10-May-1992 JohnRo
        Added debug output to translate service name routine.
    10-Jun-1992 JohnRo
        RAID 10324: net print vs. UNICODE.
        Added separate bit for RPC cache dumps.
    17-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
    09-Oct-1992 JohnRo
        Do full syntax checks in NetpIsUncComputerName etc.
        Help PC-LINT a little with different IF_DEBUG() macros.
    08-Feb-1993 JohnRo
        Made changes suggested by PC-LINT 5.0

--*/

#ifndef _DEBUGLIB_
#define _DEBUGLIB_


#include <windef.h>


// Debug trace level bits:

// NetpNtStatusToApiStatus:
#define NETLIB_DEBUG_NTSTATUS 0x00000001

// NetpRdrFsControlTree:
#define NETLIB_DEBUG_RDRFSCTL 0x00000002

// NetpConvertServerInfo:
#define NETLIB_DEBUG_CONVSRV  0x00000004

// NetpPackStr, NetpCopyStringToBuffer, NetpCopyDataToBuffer:
#define NETLIB_DEBUG_PACKSTR  0x00000008

// NetpAdjustPreferedMaximum:
#define NETLIB_DEBUG_PREFMAX  0x00000010

// RPC trace output (see also _RPCCACHE below)
#define NETLIB_DEBUG_RPC      0x00000020

// Security object helpers trace output
#define NETLIB_DEBUG_SECURITY 0x00000040

// Config file helpers trace output
#define NETLIB_DEBUG_CONFIG   0x00000080

// All net API DLL stubs (used by NetRpc.h):
#define NETLIB_DEBUG_DLLSTUBS 0x00000100

// NetRemoteComputerSupports ("API" mostly used by DLL stubs):
#define NETLIB_DEBUG_SUPPORTS 0x00000200

// NetBIOS helpers trace output
#define NETLIB_DEBUG_NETBIOS  0x00000400

// NetpConvertWkstaInfo:
#define NETLIB_DEBUG_CONVWKS  0x00000800

// Netp routines in accessp.c
#define NETLIB_DEBUG_ACCESSP  0x00001000

// NetpXxxxxStructureInfo:
#define NETLIB_DEBUG_STRUCINF 0x00002000

// NetpXxxxxLock routines:
#define NETLIB_DEBUG_NETLOCK  0x00004000

// NetpLogon routines:
#define NETLIB_DEBUG_LOGON    0x00008000

// NetpGetLocalDomainId:
#define NETLIB_DEBUG_DOMAINID 0x00010000

// NetpMemory{Allocate,Free,Reallocate}:
#define NETLIB_DEBUG_MEMALLOC 0x00020000

// NetpTranslateServiceName
#define NETLIB_DEBUG_XLATESVC 0x00040000

// RPC cache dump output (see also _RPC above)
#define NETLIB_DEBUG_RPCCACHE 0x00080000

// Print structure char set conversion
#define NETLIB_DEBUG_CONVPRT  0x00100000

// time_now and other time.c functions:
#define NETLIB_DEBUG_TIME     0x00200000

// NetpIsUncComputerNameValid etc:
#define NETLIB_DEBUG_NAMES    0x00400000


#define NETLIB_DEBUG_ALL      0xFFFFFFFF


/*lint -save -e767 */  // Don't complain about different definitions
#if DBG

extern DWORD NetlibpTrace;

#define IF_DEBUG(Function) if (NetlibpTrace & NETLIB_DEBUG_ ## Function)

#else

#define IF_DEBUG(Function) \
    /*lint -save -e506 */  /* don't complain about constant values here */ \
    if (FALSE) \
    /*lint -restore */

#endif // DBG
/*lint -restore */  // Resume checking for different macro definitions

#endif // _DEBUGLIB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\dlwksta.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    DlWksta.h

Abstract:

    This is a private header file for the NT/LAN handling of old wksta info
    levels.  This contains prototypes for the NetpConvertWkstaInfo etc APIs and
    old info level structures (in 32-bit format).

Author:

    John Rogers (JohnRo) 08-Aug-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    08-Aug-1991 JohnRo
        Created, building from DanHi's port1632.h & mapsupp.h and my DlServer.h.
    13-Sep-1991 JohnRo
        Correct UNICODE use.
    01-Apr-1992 JohnRo
        Level 402 does not have other domains any more.

--*/

#ifndef _DLWKSTA_
#define _DLWKSTA_


// These must be included first:
#include <windef.h>             // IN, LPTSTR, LPVOID, TCHAR, etc.
#include <lmcons.h>             // NET_API_STATUS, various LEN equates.

// These may be included in any order:
#include <lmwksta.h>            // PWKSTA_INFO_101.
#include <netdebug.h>           // NetpAssert().
#include <stddef.h>             // offsetof().


#define MAX_OTH_DOMAINS 4


/////////////////////////////////////
// Structures for old info levels: //
/////////////////////////////////////


typedef struct _WKSTA_INFO_0 {
    DWORD   wki0_reserved_1;
    DWORD   wki0_reserved_2;
    LPTSTR  wki0_root;
    LPTSTR  wki0_computername;
    LPTSTR  wki0_username;
    LPTSTR  wki0_langroup;
    DWORD   wki0_ver_major;
    DWORD   wki0_ver_minor;
    DWORD   wki0_reserved_3;
    DWORD   wki0_charwait;
    DWORD   wki0_chartime;
    DWORD   wki0_charcount;
    DWORD   wki0_reserved_4;
    DWORD   wki0_reserved_5;
    DWORD   wki0_keepconn;
    DWORD   wki0_keepsearch;
    DWORD   wki0_maxthreads;
    DWORD   wki0_maxcmds;
    DWORD   wki0_reserved_6;
    DWORD   wki0_numworkbuf;
    DWORD   wki0_sizworkbuf;
    DWORD   wki0_maxwrkcache;
    DWORD   wki0_sesstimeout;
    DWORD   wki0_sizerror;
    DWORD   wki0_numalerts;
    DWORD   wki0_numservices;
    DWORD   wki0_errlogsz;
    DWORD   wki0_printbuftime;
    DWORD   wki0_numcharbuf;
    DWORD   wki0_sizcharbuf;
    LPTSTR  wki0_logon_server;
    LPTSTR  wki0_wrkheuristics;
    DWORD  wki0_mailslots;
} WKSTA_INFO_0, *PWKSTA_INFO_0, *LPWKSTA_INFO_0;      /* wksta_info_0 */

#define DL_REM_wksta_info_0 "DDzzzzDDDDDDDDDDDDDDDDDDDDDDDDzzD"


typedef struct _WKSTA_INFO_1 {
    DWORD   wki1_reserved_1;
    DWORD   wki1_reserved_2;
    LPTSTR  wki1_root;
    LPTSTR  wki1_computername;
    LPTSTR  wki1_username;
    LPTSTR  wki1_langroup;
    DWORD   wki1_ver_major;
    DWORD   wki1_ver_minor;
    DWORD   wki1_reserved_3;
    DWORD   wki1_charwait;
    DWORD   wki1_chartime;
    DWORD   wki1_charcount;
    DWORD   wki1_reserved_4;
    DWORD   wki1_reserved_5;
    DWORD   wki1_keepconn;
    DWORD   wki1_keepsearch;
    DWORD   wki1_maxthreads;
    DWORD   wki1_maxcmds;
    DWORD   wki1_reserved_6;
    DWORD   wki1_numworkbuf;
    DWORD   wki1_sizworkbuf;
    DWORD   wki1_maxwrkcache;
    DWORD   wki1_sesstimeout;
    DWORD   wki1_sizerror;
    DWORD   wki1_numalerts;
    DWORD   wki1_numservices;
    DWORD   wki1_errlogsz;
    DWORD   wki1_printbuftime;
    DWORD   wki1_numcharbuf;
    DWORD   wki1_sizcharbuf;
    LPTSTR  wki1_logon_server;
    LPTSTR  wki1_wrkheuristics;
    DWORD   wki1_mailslots;
    LPTSTR  wki1_logon_domain;
    LPTSTR  wki1_oth_domains;
    DWORD   wki1_numdgrambuf;
} WKSTA_INFO_1, *PWKSTA_INFO_1, *LPWKSTA_INFO_1;  /* wksta_info_1 */

// Take advantage of the fact that level 0 is subset of level 1.
#define DL_REM_wksta_info_1             DL_REM_wksta_info_0 "zzD"


typedef struct _WKSTA_INFO_10 {
    LPTSTR  wki10_computername;
    LPTSTR  wki10_username;
    LPTSTR  wki10_langroup;
    DWORD   wki10_ver_major;
    DWORD   wki10_ver_minor;
    LPTSTR  wki10_logon_domain;
    LPTSTR  wki10_oth_domains;
} WKSTA_INFO_10, *PWKSTA_INFO_10, *LPWKSTA_INFO_10;      /* wksta_info_10 */

#define DL_REM_wksta_info_10            "zzzDDzz"


////////////////////////////////////
// Equates for various maximums:  //
//   _LENGTH for character counts //
//   _SIZE for byte counts        //
////////////////////////////////////

// This number is from the LM 2.0 NetCons.h file, where it is called
// WRKHEUR_COUNT:
#define LM20_WRKHEUR_COUNT              54

#define MAX_WKSTA_0_STRING_LENGTH \
        (LM20_PATHLEN+1 + MAX_PATH+1 + LM20_UNLEN+1 + LM20_DNLEN+1 \
        + MAX_PATH+1 + LM20_WRKHEUR_COUNT+1)
#define MAX_WKSTA_0_STRING_SIZE \
        (MAX_WKSTA_0_STRING_LENGTH * sizeof(TCHAR))
#define MAX_WKSTA_0_TOTAL_SIZE \
        (MAX_WKSTA_0_STRING_SIZE + sizeof(WKSTA_INFO_0))

#define MAX_WKSTA_1_STRING_LENGTH \
        ( MAX_WKSTA_0_STRING_LENGTH + LM20_DNLEN+1 + LM20_DNLEN+1 )
#define MAX_WKSTA_1_STRING_SIZE \
        (MAX_WKSTA_1_STRING_LENGTH * sizeof(TCHAR))
#define MAX_WKSTA_1_TOTAL_SIZE \
        (MAX_WKSTA_1_STRING_SIZE + sizeof(WKSTA_INFO_1))

#define MAX_WKSTA_10_STRING_LENGTH \
        (MAX_PATH+1 + LM20_UNLEN+1 + LM20_DNLEN+1 \
        + LM20_DNLEN+1 + LM20_DNLEN+1 )
#define MAX_WKSTA_10_STRING_SIZE \
        (MAX_WKSTA_10_STRING_LENGTH * sizeof(TCHAR))
#define MAX_WKSTA_10_TOTAL_SIZE \
        (MAX_WKSTA_10_STRING_SIZE + sizeof(WKSTA_INFO_10))

#define MAX_WKSTA_100_STRING_LENGTH \
        (MAX_PATH+1 + LM20_DNLEN+1)
#define MAX_WKSTA_100_STRING_SIZE \
        (MAX_WKSTA_100_STRING_LENGTH * sizeof(TCHAR))
#define MAX_WKSTA_100_TOTAL_SIZE \
        (MAX_WKSTA_100_STRING_SIZE + sizeof(WKSTA_INFO_100))

#define MAX_WKSTA_101_STRING_LENGTH \
        (MAX_WKSTA_100_STRING_LENGTH + LM20_PATHLEN+1)
#define MAX_WKSTA_101_STRING_SIZE \
        (MAX_WKSTA_101_STRING_LENGTH * sizeof(TCHAR))
#define MAX_WKSTA_101_TOTAL_SIZE \
        (MAX_WKSTA_101_STRING_SIZE + sizeof(WKSTA_INFO_101))

#define MAX_WKSTA_102_STRING_LENGTH \
        (MAX_WKSTA_101_STRING_LENGTH)
#define MAX_WKSTA_102_STRING_SIZE \
        (MAX_WKSTA_102_STRING_LENGTH * sizeof(TCHAR))
#define MAX_WKSTA_102_TOTAL_SIZE \
        (MAX_WKSTA_102_STRING_SIZE + sizeof(WKSTA_INFO_102))

#define MAX_WKSTA_302_STRING_LENGTH \
        (LM20_WRKHEUR_COUNT+1 + (MAX_OTH_DOMAINS * (LM20_DNLEN+1)))
#define MAX_WKSTA_302_STRING_SIZE \
        (MAX_WKSTA_302_STRING_LENGTH * sizeof(TCHAR))
#define MAX_WKSTA_302_TOTAL_SIZE \
        (MAX_WKSTA_302_STRING_SIZE + sizeof(WKSTA_INFO_302))

#define MAX_WKSTA_402_STRING_LENGTH \
        (LM20_WRKHEUR_COUNT+1)
#define MAX_WKSTA_402_STRING_SIZE \
        (MAX_WKSTA_402_STRING_LENGTH * sizeof(TCHAR))
#define MAX_WKSTA_402_TOTAL_SIZE \
        (MAX_WKSTA_402_STRING_SIZE + sizeof(WKSTA_INFO_402))

#define MAX_WKSTA_502_STRING_LENGTH 0
#define MAX_WKSTA_502_STRING_SIZE   0
#define MAX_WKSTA_502_TOTAL_SIZE    (sizeof(WKSTA_INFO_502))


/////////////////////////////////////
// Info level conversion routines: //
/////////////////////////////////////

// Add prototypes for other routines here, in alphabetical order.

NET_API_STATUS
NetpConvertWkstaInfo (
    IN DWORD FromLevel,
    IN LPVOID FromInfo,
    IN BOOL FromNative,
    IN DWORD ToLevel,
    OUT LPVOID ToInfo,
    IN DWORD ToFixedLength,
    IN DWORD ToStringLength,
    IN BOOL ToNative,
    IN OUT LPTSTR * ToStringAreaPtr OPTIONAL
    );


/////////////////////////////////////////////////////////////////////
// Macro to make sure offsets of field in two structures are same: //
/////////////////////////////////////////////////////////////////////

#define CHECK_WKSTA_OFFSETS(one_level, other_level, fieldname) \
    NetpAssert( offsetof(WKSTA_INFO_ ## one_level,             \
                        sv## one_level ## _ ## fieldname)       \
                == offsetof(WKSTA_INFO_ ## other_level,        \
                        sv## other_level ## _ ## fieldname) )


/////////////////////////////////////////////////////////////////
// Macros to check if an info level is "old" (LM 2.x) or "new" //
// (32-bit, NT, and/or portable LanMan).                       //
/////////////////////////////////////////////////////////////////

#define NetpIsOldWkstaInfoLevel(L) \
        ( ((L)==0) || ((L)==1) || ((L)==10) )

// Note that the new "setinfo levels" aren't included in this list.
#define NetpIsNewWkstaInfoLevel(L) \
        ( ((L)==100) || ((L)==101) || ((L)==102) \
        || ((L)==302) || ((L)==402) || ((L)==502) )



#endif // ndef _DLWKSTA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\dfsp.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       dfsp.h
//
//  Contents:   Declares private types, macros, and data needed by the
//              NetDfsXXX public APIs.
//
//  Classes:    None
//
//  Functions:  None
//
//  History:    Feb 19, 1996    Milans created
//
//-----------------------------------------------------------------------------

#ifndef _NET_DFS_P_
#define _NET_DFS_P_

extern CRITICAL_SECTION NetDfsApiCriticalSection;

VOID
NetDfsApiInitialize(void);

#endif // _NET_DFS_P_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\dlserver.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    DlServer.h

Abstract:

    This is a private header file for the NT/LAN handling of old server info
    levels.  This contains prototypes for the NetpMergeServerOs2 etc APIs and
    old info level structures (in 32-bit format).

Author:

    John Rogers (JohnRo) 18-Apr-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    This code assumes that the info levels are subsets of each other.

Revision History:

    18-Apr-1991 JohnRo
        Created.
    19-Apr-1991 JohnRo
        Moved SV_MAX_SRV_HEUR_LEN to <lmserver.h>.
    23-Apr-1991 JohnRo
        Deleted FromLength parm from NetpConvertServerInfo.
    23-Apr-1991 JohnRo
        <remdef.h> is not needed by this file.
    25-Apr-1991 JohnRo
        Added DL_REM_ descriptors.
    02-Mar-1991 JohnRo
        Added CHECK_SERVER_OFFSETS() macro.  NetpConvertServerInfo must not
        alloc space, as it makes enum arrays impossible.  Changed to CliffV's
        size means bytes (vs. length meaning characters) naming convention.
    06-May-1991 JohnRo
        Added NetpIsOldServerInfoLevel() and NetpIsNewServerInfoLevel().
    09-May-1991 JohnRo
        Added pad info for SERVER_INFO_2.
    19-May-1991 JohnRo
        Clean up LPBYTE vs. LPTSTR handling, as suggested by PC-LINT.
    23-May-1991 JohnRo
        Added sv403_autopath support.
    19-Jun-1991 JohnRo
        Changed svX_disc to be signed (for info levels 2 and 3).
        Added svX_licenses (also levels 2 and 3).
    07-Aug-1991 JohnRo
        Implement downlevel NetWksta APIs.
    13-Sep-1991 JohnRo
        Made changes toward UNICODE.  (Use LPTSTR in structures.)
    17-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
    26-Aug-1992 JohnRo
        RAID 4463: NetServerGetInfo(level 3) to downlevel: assert in convert.c.

--*/

#ifndef _DLSERVER_
#define _DLSERVER_


// These must be included first:
#include <windef.h>             // IN, LPTSTR, LPVOID, TCHAR, etc.
#include <lmcons.h>             // NET_API_STATUS, various LEN equates.

// These may be included in any order:
#include <lmserver.h>           // SV_MAX_SRV_HEUR_LEN, SERVER_INFO_100.
#include <netdebug.h>           // NetpAssert().
#include <stddef.h>             // offsetof().


/////////////////////////////////////
// Structures for old info levels: //
/////////////////////////////////////

typedef struct _SERVER_INFO_0 {
    LPTSTR   sv0_name;
} SERVER_INFO_0, *PSERVER_INFO_0, *LPSERVER_INFO_0;

#define DL_REM16_server_info_0  "B16"
#define DL_REM32_server_info_0  "z"


typedef struct _SERVER_INFO_1 {
    LPTSTR  sv1_name;
    DWORD   sv1_version_major;
    DWORD   sv1_version_minor;
    DWORD   sv1_type;
    LPTSTR  sv1_comment;
} SERVER_INFO_1, *PSERVER_INFO_1, *LPSERVER_INFO_1;

#define DL_REM16_server_info_1  DL_REM16_server_info_0 "BBDz"
#define DL_REM32_server_info_1  DL_REM32_server_info_0 "DDDz"


typedef struct _SERVER_INFO_2 {
    LPTSTR  sv2_name;
    DWORD   sv2_version_major;
    DWORD   sv2_version_minor;
    DWORD   sv2_type;
    LPTSTR  sv2_comment;
    DWORD   sv2_ulist_mtime;
    DWORD   sv2_glist_mtime;
    DWORD   sv2_alist_mtime;
    DWORD   sv2_users;
    LONG    sv2_disc;
    LPTSTR  sv2_alerts;
    DWORD   sv2_security;
    DWORD   sv2_auditing;
    DWORD   sv2_numadmin;
    DWORD   sv2_lanmask;
    DWORD   sv2_hidden;
    DWORD   sv2_announce;
    DWORD   sv2_anndelta;
    LPTSTR  sv2_guestacct;
    DWORD   sv2_licenses;
    LPTSTR  sv2_userpath;
    DWORD   sv2_chdevs;
    DWORD   sv2_chdevq;
    DWORD   sv2_chdevjobs;
    DWORD   sv2_connections;
    DWORD   sv2_shares;
    DWORD   sv2_openfiles;
    DWORD   sv2_sessopens;
    DWORD   sv2_sessvcs;
    DWORD   sv2_sessreqs;
    DWORD   sv2_opensearch;
    DWORD   sv2_activelocks;
    DWORD   sv2_numreqbuf;
    DWORD   sv2_sizreqbuf;
    DWORD   sv2_numbigbuf;
    DWORD   sv2_numfiletasks;
    DWORD   sv2_alertsched;
    DWORD   sv2_erroralert;
    DWORD   sv2_logonalert;
    DWORD   sv2_accessalert;
    DWORD   sv2_diskalert;
    DWORD   sv2_netioalert;
    DWORD   sv2_maxauditsz;
    LPTSTR  sv2_srvheuristics;
} SERVER_INFO_2, *PSERVER_INFO_2, *LPSERVER_INFO_2;

#define DL_REM16_server_info_2  DL_REM16_server_info_1 "JJJWWzWWWWWWWB21BzWWWWWWWWWWWWWWWWWWWWWWz"
#define DL_REM32_server_info_2  DL_REM32_server_info_1 "GGGDXzDDDDDDDzDzDDDDDDDDDDDDDDDDDDDDDDz"


typedef struct _SERVER_INFO_3 {
    LPTSTR  sv3_name;
    DWORD   sv3_version_major;
    DWORD   sv3_version_minor;
    DWORD   sv3_type;
    LPTSTR  sv3_comment;
    DWORD   sv3_ulist_mtime;
    DWORD   sv3_glist_mtime;
    DWORD   sv3_alist_mtime;
    DWORD   sv3_users;
    LONG    sv3_disc;
    LPTSTR  sv3_alerts;
    DWORD   sv3_security;
    DWORD   sv3_auditing;
    DWORD   sv3_numadmin;
    DWORD   sv3_lanmask;
    DWORD   sv3_hidden;
    DWORD   sv3_announce;
    DWORD   sv3_anndelta;
    LPTSTR  sv3_guestacct;
    DWORD   sv3_licenses;
    LPTSTR  sv3_userpath;
    DWORD   sv3_chdevs;
    DWORD   sv3_chdevq;
    DWORD   sv3_chdevjobs;
    DWORD   sv3_connections;
    DWORD   sv3_shares;
    DWORD   sv3_openfiles;
    DWORD   sv3_sessopens;
    DWORD   sv3_sessvcs;
    DWORD   sv3_sessreqs;
    DWORD   sv3_opensearch;
    DWORD   sv3_activelocks;
    DWORD   sv3_numreqbuf;
    DWORD   sv3_sizreqbuf;
    DWORD   sv3_numbigbuf;
    DWORD   sv3_numfiletasks;
    DWORD   sv3_alertsched;
    DWORD   sv3_erroralert;
    DWORD   sv3_logonalert;
    DWORD   sv3_accessalert;
    DWORD   sv3_diskalert;
    DWORD   sv3_netioalert;
    DWORD   sv3_maxauditsz;
    LPTSTR  sv3_srvheuristics;
    DWORD   sv3_auditedevents;
    DWORD   sv3_autoprofile;
    LPTSTR  sv3_autopath;
} SERVER_INFO_3, *PSERVER_INFO_3, *LPSERVER_INFO_3;

#define DL_REM16_server_info_3  DL_REM16_server_info_2 "DWz"
#define DL_REM32_server_info_3  DL_REM32_server_info_2 "DDz"


#define sv2_pad1  sv2_licenses
#define sv3_pad1  sv3_licenses


////////////////////////////////////
// Equates for various maximums:  //
//   _LENGTH for character counts //
//   _SIZE for byte counts        //
////////////////////////////////////

#define MAX_LEVEL_0_STRING_LENGTH (LM20_CNLEN+1)
#define MAX_LEVEL_0_STRING_SIZE \
        (MAX_LEVEL_0_STRING_LENGTH * sizeof(TCHAR))
#define MAX_LEVEL_0_TOTAL_SIZE \
        (MAX_LEVEL_0_STRING_SIZE + sizeof(SERVER_INFO_0))

#define MAX_LEVEL_1_STRING_LENGTH (LM20_CNLEN+1 + LM20_MAXCOMMENTSZ+1)
#define MAX_LEVEL_1_STRING_SIZE \
        (MAX_LEVEL_1_STRING_LENGTH * sizeof(TCHAR))
#define MAX_LEVEL_1_TOTAL_SIZE \
        (MAX_LEVEL_1_STRING_SIZE + sizeof(SERVER_INFO_1))

#define MAX_LEVEL_2_STRING_LENGTH \
        (LM20_CNLEN+1 + LM20_MAXCOMMENTSZ+1 + ALERTSZ+1 + LM20_UNLEN+1 + PATHLEN+1 \
        + SV_MAX_SRV_HEUR_LEN+1)
#define MAX_LEVEL_2_STRING_SIZE \
        (MAX_LEVEL_2_STRING_LENGTH * sizeof(TCHAR))
#define MAX_LEVEL_2_TOTAL_SIZE \
        (MAX_LEVEL_2_STRING_SIZE + sizeof(SERVER_INFO_2))

#define MAX_LEVEL_3_STRING_LENGTH \
        (MAX_LEVEL_2_STRING_SIZE + PATHLEN+1)
#define MAX_LEVEL_3_STRING_SIZE \
        (MAX_LEVEL_3_STRING_LENGTH * sizeof(TCHAR))
#define MAX_LEVEL_3_TOTAL_SIZE \
        (MAX_LEVEL_3_STRING_SIZE + sizeof(SERVER_INFO_3))

#define MAX_LEVEL_100_STRING_LENGTH \
        (CNLEN+1)
#define MAX_LEVEL_100_STRING_SIZE \
        (MAX_LEVEL_100_STRING_LENGTH * sizeof(TCHAR))
#define MAX_LEVEL_100_TOTAL_SIZE \
        (MAX_LEVEL_100_STRING_SIZE + sizeof(SERVER_INFO_100))

#define MAX_LEVEL_101_STRING_LENGTH \
        (MAX_LEVEL_100_STRING_LENGTH + MAXCOMMENTSZ+1)
#define MAX_LEVEL_101_STRING_SIZE \
        (MAX_LEVEL_101_STRING_LENGTH * sizeof(TCHAR))
#define MAX_LEVEL_101_TOTAL_SIZE \
        (MAX_LEVEL_101_STRING_SIZE + sizeof(SERVER_INFO_101))

#define MAX_LEVEL_102_STRING_LENGTH \
        (MAX_LEVEL_101_STRING_LENGTH + PATHLEN+1)
#define MAX_LEVEL_102_STRING_SIZE \
        (MAX_LEVEL_102_STRING_LENGTH * sizeof(TCHAR))
#define MAX_LEVEL_102_TOTAL_SIZE \
        (MAX_LEVEL_102_STRING_SIZE + sizeof(SERVER_INFO_102))

#define MAX_LEVEL_402_STRING_LENGTH \
        (ALERTSZ+1 + LM20_UNLEN+1 + SV_MAX_SRV_HEUR_LEN+1)
#define MAX_LEVEL_402_STRING_SIZE \
        (MAX_LEVEL_402_STRING_LENGTH * sizeof(TCHAR))
#define MAX_LEVEL_402_TOTAL_SIZE \
        (MAX_LEVEL_402_STRING_SIZE + sizeof(SERVER_INFO_402))

#define MAX_LEVEL_403_STRING_LENGTH \
        (MAX_LEVEL_402_STRING_LENGTH + PATHLEN+1)
#define MAX_LEVEL_403_STRING_SIZE \
        (MAX_LEVEL_403_STRING_LENGTH * sizeof(TCHAR))
#define MAX_LEVEL_403_TOTAL_SIZE \
        (MAX_LEVEL_403_STRING_SIZE + sizeof(SERVER_INFO_403))

#define MAX_LEVEL_502_STRING_LENGTH 0
#define MAX_LEVEL_502_STRING_SIZE \
        (MAX_LEVEL_502_STRING_LENGTH * sizeof(TCHAR))
#define MAX_LEVEL_502_TOTAL_SIZE \
        (MAX_LEVEL_502_STRING_SIZE + sizeof(SERVER_INFO_502))


/////////////////////////////////////
// Info level conversion routines: //
/////////////////////////////////////

// Add prototypes for other routines here, in alphabetical order.

NET_API_STATUS
NetpConvertServerInfo (
    IN DWORD FromLevel,
    IN LPVOID FromInfo,
    IN BOOL FromNative,
    IN DWORD ToLevel,
    OUT LPVOID ToInfo,
    IN DWORD ToFixedLength,
    IN DWORD ToStringLength,
    IN BOOL ToNative,
    IN OUT LPTSTR * ToStringAreaPtr OPTIONAL
    );


/////////////////////////////////////////////////////////////////////
// Macro to make sure offsets of field in two structures are same: //
/////////////////////////////////////////////////////////////////////

#define CHECK_SERVER_OFFSETS(one_level, other_level, fieldname) \
    NetpAssert( offsetof(SERVER_INFO_ ## one_level,             \
                        sv## one_level ## _ ## fieldname)       \
                == offsetof(SERVER_INFO_ ## other_level,        \
                        sv## other_level ## _ ## fieldname) )


/////////////////////////////////////////////////////////////////
// Macros to check if an info level is "old" (LM 2.x) or "new" //
// (32-bit, NT, and/or portable LanMan).                       //
/////////////////////////////////////////////////////////////////

#define NetpIsOldServerInfoLevel(L) \
        ( ((L)==0) || ((L)==1) || ((L)==2) || ((L)==3) )
#define NetpIsNewServerInfoLevel(L) \
        ( ((L)==100) || ((L)==101) || ((L)==102) \
        || ((L)==402) || ((L)==403) \
        || ((L)==502) || ((L)==503) || ((L)==599) )


#endif // ndef _DLSERVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\luidate.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lui.h

Abstract:

    This file maps the LM 2.x include file name to the appropriate NT include
    file name, and does any other mapping required by this include file.

Author:

    Dan Hinsley (danhi) 8-Jun-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

--*/

SHORT LUI_ParseDateTime(PCHAR inbuf, time_t * time, PUSHORT parselen,
	USHORT reserved);

SHORT LUI_ParseTimeSinceStartOfDay(PCHAR inbuf, time_t * time, PUSHORT parselen,
	USHORT reserved);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\filesec.h ===
DWORD
NetpGetFileSecurity(
    LPWSTR                  lpFileName,
    SECURITY_INFORMATION    RequestedInformation,
    PSECURITY_DESCRIPTOR    *pSecurityDescriptor,
    LPDWORD                 pnLength
    );

DWORD
NetpSetFileSecurity (
    LPWSTR                   lpFileName,
    SECURITY_INFORMATION     SecurityInformation,
    PSECURITY_DESCRIPTOR     pSecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\dnssrv.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dnssrv.h

Abstract:

    Routines for processing SRV DNS records.

Author:

    Cliff Van Dyke (cliffv) 28-Feb-1997

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/



//
// Externally visible procedures.
//

NET_API_STATUS
NetpSrvOpen(
    IN LPSTR DnsRecordName,
    IN DWORD DnsQueryFlags,
    OUT PHANDLE SrvContextHandle
    );

NET_API_STATUS
NetpSrvProcessARecords(
    IN PDNS_RECORD DnsARecords,
    IN LPSTR DnsHostName OPTIONAL,
    IN ULONG Port,
    OUT PULONG SockAddressCount,
    OUT LPSOCKET_ADDRESS *SockAddresses
    );

NET_API_STATUS
NetpSrvNext(
    IN HANDLE SrvContextHandle,
    OUT PULONG SockAddressCount OPTIONAL,
    OUT LPSOCKET_ADDRESS *SockAddresses OPTIONAL,
    OUT LPSTR *DnsHostName OPTIONAL
    );

VOID
NetpSrvClose(
    IN HANDLE SrvContextHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\lmadtool.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lmadtool.h

Abstract:

    Contains constants and function prototypes for the Remotable Network
    Administration tools.

Author:

    Dan Lafferty (danl)     27-Sept-1991

Environment:

    User Mode -Win32 and Win16

Revision History:

    27-Sept-1991     danl
        created

--*/
//
// Defines
//

#define TYPE_USER       1L
#define TYPE_GROUP      2L
#define TYPE_INVALID    3L
#define TYPE_UNKNOWN    4L

//
// File Security API.
//
// (must #include \nt\public\sdk\inc\seapi.h)
// (must #include \nt\private\inc\seopaque.h)
//

DWORD
NetpSetFileSecurityA (
    IN LPSTR                    ServerName OPTIONAL,
    IN LPSTR                    lpFileName,
    IN PSECURITY_INFORMATION    pSecurityInformation,
    IN PSECURITY_DESCRIPTOR     pSecurityDescriptor
    );


DWORD
NetpSetFileSecurityW (
    IN LPWSTR                   ServerName OPTIONAL,
    IN LPWSTR                   lpFileName,
    IN PSECURITY_INFORMATION    pSecurityInformation,  
    IN PSECURITY_DESCRIPTOR     pSecurityDescriptor
    );

DWORD
NetpGetFileSecurityA(
    IN  LPSTR                   ServerName OPTIONAL,
    IN  LPSTR                   lpFileName,
    IN  PSECURITY_INFORMATION   pRequestedInformation,
    OUT PSECURITY_DESCRIPTOR    *pSecurityDescriptor,
    OUT LPDWORD                 pnLength
    );

DWORD
NetpGetFileSecurityW(
    IN  LPWSTR                  ServerName OPTIONAL,
    IN  LPWSTR                  lpFileName,
    IN  PSECURITY_INFORMATION   pRequestedInformation,
    OUT PSECURITY_DESCRIPTOR    *pSecurityDescriptor,
    OUT LPDWORD                 pnLength
    );

//
// Name From Sid API
//

typedef struct _NAME_INFOA {
    LPSTR               Name;
    DWORD               NameUse;
} NAME_INFOA, *PNAME_INFOA, *LPNAME_INFOA;

typedef struct _NAME_INFOW {
    LPWSTR              Name;
    DWORD               NameUse;
} NAME_INFOW, *PNAME_INFOW, *LPNAME_INFOW;


#ifdef UNICODE

#define NAME_INFO       NAME_INFOW
#define PNAME_INFO      PNAME_INFOW
#define LPNAME_INFO     LPNAME_INFOW

#else

#define NAME_INFO       NAME_INFOA
#define PNAME_INFO      PNAME_INFOA
#define LPNAME_INFO     LPNAME_INFOA

#endif // UNICODE


DWORD
NetpGetNameFromSidA (
    IN      LPSTR           ServerName,
    IN      DWORD           SidCount,
    IN      PSID            SidPtr,
    OUT     LPDWORD         NameCount,
    OUT     LPNAME_INFOA    *NameInfo
    );

DWORD
NetpGetNameFromSidW (
    IN      LPWSTR          ServerName,
    IN      DWORD           SidCount,
    IN      PSID            SidPtr,
    OUT     LPDWORD         NameCount,
    OUT     LPNAME_INFOW    *NameInfo
    );

#ifdef UNICODE

#define NetpGetNameFromSid  NetpGetNameFromSidW

#else

#define NetpGetNameFromSid  NetpGetNameFromSidA

#endif // UNICODE


//
// User, Group, UserModals API
//
// (This includes the ability to get a SID from a NAME)
//

//
//
// USER INFO
//
//

DWORD
NetpUserGetInfoA (
    IN  LPSTR   servername OPTIONAL,
    IN  LPSTR   username,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

DWORD
NetpUserGetInfoW (
    IN  LPWSTR  servername OPTIONAL,
    IN  LPWSTR  username,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

DWORD
NetpUserSetInfoA (
    IN  LPSTR   servername OPTIONAL,
    IN  LPSTR   username,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err OPTIONAL
    );

DWORD
NetpUserSetInfoW (
    IN  LPWSTR  servername OPTIONAL,
    IN  LPWSTR  username,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err OPTIONAL
    );

//
//
// GROUP INFO
//
//

DWORD
NetpGroupGetInfoA (
    IN  LPSTR   servername OPTIONAL,
    IN  LPSTR   groupname,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

DWORD
NetpGroupGetInfoW (
    IN  LPWSTR  servername OPTIONAL,
    IN  LPWSTR  groupname,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

DWORD
NetpGroupSetInfoA (
    IN  LPSTR   servername OPTIONAL,
    IN  LPSTR   groupname,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err OPTIONAL
    );

DWORD
NetpGroupSetInfoW (
    IN  LPWSTR  servername OPTIONAL,
    IN  LPWSTR  groupname,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err OPTIONAL
    );

//
//
// USER_MODALS INFO
//
//


DWORD
NetpUserModalsGetA (
    IN  LPSTR   servername OPTIONAL,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

DWORD
NetpUserModalsGetW (
    IN  LPWSTR  servername OPTIONAL,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

DWORD
NetpUserModalsSetA (
    IN  LPSTR   servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err OPTIONAL
    );

DWORD
NetpUserModalsSetW (
    IN  LPWSTR  servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err OPTIONAL
    );


#ifdef UNICODE

#define NetpUserGetInfo     NetpUserGetInfoW
#define NetpUserSetInfo     NetpUserSetInfoW
#define NetpGroupGetInfo    NetpGroupGetInfoW
#define NetpGroupSetInfo    NetpGroupSetInfoW
#define NetpUserModalsGet   NetpUserModalsGetW
#define NetpUserModalsSet   NetpUserModalsSetW

#else

#define NetpUserGetInfo     NetpUserGetInfoA
#define NetpUserSetInfo     NetpUserSetInfoA
#define NetpGroupGetInfo    NetpGroupGetInfoA
#define NetpGroupSetInfo    NetpGroupSetInfoA
#define NetpUserModalsGet   NetpUserModalsGetA
#define NetpUserModalsSet   NetpUserModalsSetA

#endif //UNICODE


//
// EventLog
//

typedef LPBYTE  ADT_HANDLE, *PADT_HANDLE;

DWORD
NetpCloseEventLog (
    IN	ADT_HANDLE  hEventLog
    );

DWORD
NetpClearEventLogA (
    IN	ADT_HANDLE  hEventLog,
    IN	LPSTR	    lpBackupFileName
    );

DWORD
NetpOpenEventLogA (
    IN	LPSTR	        lpUNCServerName,
    IN	LPSTR	        lpModuleName,
    OUT PADT_HANDLE     lpEventHandle
    );

DWORD
NetpReadEventLogA (
    IN	ADT_HANDLE  hEventLog,
    IN	DWORD	    dwReadFlags,
    IN	DWORD	    dwRecordOffset,
    OUT	LPVOID	    lpBuffer,
    IN	DWORD	    nNumberOfBytesToRead,
    OUT DWORD	    *pnBytesRead,
    OUT DWORD	    *pnMinNumberOfBytesNeeded
    );

DWORD
NetpWriteEventLogEntryA (
    IN	ADT_HANDLE  hEventLog,
    IN	WORD	    wType,
    IN	DWORD	    dwEventID,
    IN	PSID	    lpUserSid	    OPTIONAL,
    IN	WORD	    wNumStrings,
    IN	DWORD	    dwDataSize,
    IN	LPSTR	    *lpStrings      OPTIONAL,
    IN	LPVOID	    lpRawData	    OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\dosprtp.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    DosPrtP.h

Abstract:

    This contains macros and prototypes private to the DosPrint APIs.

Author:

    John Rogers (JohnRo) 02-Oct-1992

Environment:

Notes:

    All of the RxPrint APIs are wide-character APIs, regardless of
    whether or not UNICODE is defined.  This allows the net/dosprint/dosprint.c
    code to use the winspool APIs (which are currently ANSI APIs, despite their
    prototypes using LPTSTR in some places).

Revision History:

    02-Oct-1992 JohnRo
        Created for RAID 3556: DosPrintQGetInfo (from downlevel) level=3 rc=124.
    22-Mar-1993 JohnRo
        RAID 2974: NET PRINT says NT printer is held when it isn't.
        DosPrint API cleanup.
        Made changes suggested by PC-LINT 5.0
        Added some IN and OUT keywords.
    07-Apr-1993 JohnRo
        RAID 5670: "NET PRINT \\server\share" gives err 124 (bad level) on NT.
        Also quiet normal debug output.

--*/


#ifndef _DOSPRTP_
#define _DOSPRTP_


#ifndef PREFIX_DOSPRINT
#define PREFIX_DOSPRINT PREFIX_NETLIB
#endif


// In DosPrtP.c, Unicode version:
NET_API_STATUS
CommandALocalPrinterW(
    IN LPWSTR  PrinterName,
    IN DWORD   Command     //  PRINTER_CONTROL_PAUSE, etc.
    );

// In DosPrtP.c, Ansi version:
NET_API_STATUS
CommandALocalJobA(
    IN HANDLE  PrinterHandle, OPTIONAL
    IN LPWSTR LocalServerNameW,
    IN LPSTR  LocalServerNameA,
    IN DWORD   JobId,
    IN DWORD   Level,
    IN LPBYTE  pJob,
    IN DWORD   Command     //  JOB_CONTROL_PAUSE, etc.
    );

// In DosPrtP.c:
// Note: FindLocalJob() calls SetLastError() to indicate the cause of an error.
HANDLE
FindLocalJob(
    IN DWORD JobId
    );


// In DosPrtP.c:
LPSTR
FindQueueNameInPrinterNameA(
    IN LPCSTR PrinterName
    );


// In DosPrtP.c:
LPWSTR
FindQueueNameInPrinterNameW(
    IN LPCWSTR PrinterName
    );


// BOOL
// NetpIsPrintDestLevelValid(
//     IN DWORD Level,          // Info level
//     IN BOOL SetInfo          // Are setinfo levels allowed?
//     );
//
#define NetpIsPrintDestLevelValid(Level,SetInfo) \
    /*lint -save -e506 */  /* don't complain about constant values here */ \
    ( ( (SetInfo) && ((Level)==3) ) \
      || ( (Level) <= 3 ) ) \
    /*lint -restore */


// BOOL
// NetpIsPrintJobLevelValid(
//     IN DWORD Level,          // Info level
//     IN BOOL SetInfo          // Are setinfo levels allowed?
//     );
//
#define NetpIsPrintJobLevelValid(Level,SetInfo) \
    /*lint -save -e506 */  /* don't complain about constant values here */ \
    ( ( (SetInfo) && (((Level)==1) || ((Level)==3)) ) \
      || ( (Level) <= 3 ) ) \
    /*lint -restore */


// BOOL
// NetpIsPrintQLevelValid(
//     IN DWORD Level,          // Info level
//     IN BOOL SetInfo          // Are setinfo levels allowed?
//     );
//
#define NetpIsPrintQLevelValid(Level,SetInfo) \
    /*lint -save -e506 */  /* don't complain about constant values here */ \
    ( ( (SetInfo) && (((Level)==1) || ((Level)==3)) ) \
      || ( (Level) <= 5 ) || ( (Level) == 52 ) ) \
    /*lint -restore */


// In DosPrtP.c:
DWORD
NetpJobCountForQueue(
    IN DWORD QueueLevel,
    IN LPVOID Queue,
    IN BOOL HasUnicodeStrings
    );


// In DosPrtP.c:
WORD
PrjStatusFromJobStatus(
    IN DWORD JobStatus
    );


// In DosPrtP.c:
WORD
PrqStatusFromPrinterStatus(
    IN DWORD PrinterStatus
    );


#endif // _DOSPRTP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\luitext.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1990		**/ 
/*****************************************************************/ 

/*
 * File:	luitext.h
 *			include file for text strings FIXED into
 *			the LUI library
 * Project:	LANMAN 2.0
 * Authors:	chuckc
 * Remarks:	(none)
 * History:	July 89, chuckc, created
 */

extern char LUI_txt_yes[] ;
extern char LUI_txt_no[] ;

extern char LUI_txt_am[] ;
extern char LUI_txt_pm[] ;

extern char LUI_txt_net[] ;
extern char LUI_txt_help[] ;

extern char LUI_txt_january[] ;
extern char LUI_txt_february[] ;
extern char LUI_txt_march[] ;
extern char LUI_txt_april[] ;
extern char LUI_txt_may[] ;
extern char LUI_txt_june[] ;
extern char LUI_txt_july[] ;
extern char LUI_txt_august[] ;
extern char LUI_txt_september[] ;
extern char LUI_txt_october[] ;
extern char LUI_txt_november[] ;
extern char LUI_txt_december[] ;

extern char LUI_txt_monday[] ;
extern char LUI_txt_tuesday[] ;
extern char LUI_txt_wednesday[] ;
extern char LUI_txt_thursday[] ;
extern char LUI_txt_friday[] ;
extern char LUI_txt_saturday[] ;
extern char LUI_txt_sunday[] ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\luiint.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    luiint.h

Abstract:

    This file contains the prototypes/manifests used internally by the LUI
    library.

Author:

    Dan Hinsley (danhi) 8-Jun-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

--*/
///////////////////////////////// search lists //////////////////////////////
//   USAGE
//	 we typically declare a data list associating message numbers with
//	 data values, and partially initialize a search list associating
//	 strings with data values. We then complete this search list by passing
//       it together with the data list to a 'setup' function (see SERACH.C).
//  	 
//   CONVENTIONS
// 	 the data lists are terminated with a zero message number, search lists
// 	 terminated with a NULL search string.
//
//   EXAMPLE of USE (for weeks)
//
//   static searchlist_data week_data[] = {	/* strings from message file */
//       {APE2_GEN_SUNDAY_ABBREV,	0},
//       {APE2_GEN_MONDAY_ABBREV,	1},
//       {APE2_GEN_TUESDAY_ABBREV,	2},
//       {APE2_GEN_WEDNSDAY_ABBREV,	3},
//       {APE2_GEN_THURSDAY_ABBREV,	4},
//       {APE2_GEN_FRIDAY_ABBREV,	5},
//       {APE2_GEN_SATURDAY_ABBREV,	6},
//       {APE2_GEN_SUNDAY,		0},
//       {APE2_GEN_MONDAY,		1},
//       {APE2_GEN_TUESDAY,		2},
//       {APE2_GEN_WEDNSDAY,	3},
//       {APE2_GEN_THURSDAY,		4},
//       {APE2_GEN_FRIDAY,		5},
//       {APE2_GEN_SATURDAY,		6},
//       {0,0} 
//   } ;
//
//   #define DAYS_IN_WEEK 	(7)
//   #define NUM_DAYS_LIST 	(sizeof(week_data)/sizeof(week_data[0])+
//				DAYS_IN_WEEK)
//
//   /* 
//    * NOTE - we init the first 7 always recognised days
//    *        and get the rest from the message file 
//    */
//   static searchlist 	week_list[NUM_DAYS_LIST + DAYS_IN_WEEK] = {
//   	{LUI_txt_sunday,0},
//   	{LUI_txt_monday,1},
//   	{LUI_txt_tuesday,2},
//   	{LUI_txt_wednesday,3},
//   	{LUI_txt_thursday,4},
//   	{LUI_txt_friday,5},
//   	{LUI_txt_saturday,6},
//   } ;	

/*-- types for search lists  --*/

/* asssociate message number with value - eg. APE2_GEN_FRIDAY has value 5 */
typedef struct search_list_data {
    SHORT msg_no ;	
    SHORT value ;
} searchlist_data ;

/* associate search strings with values - eg. "Friday" has value 5 */
typedef struct search_list {
    char *		s_str ;
    SHORT		val ;
} searchlist ;

/*-- function prototypes for search lists --*/

USHORT ILUI_setup_list(
    char *buffer,
    USHORT bufsiz,
    USHORT offset,
    PUSHORT bytesread,
    searchlist_data sdata[],
    searchlist slist[]
    ) ;

USHORT  ILUI_traverse_slist( 
    PCHAR pszStr,
    searchlist * slist,
    SHORT * pusVal) ;

USHORT LUI_GetMsgIns(
    PCHAR *istrings, 
    USHORT nstrings, 
    PSZ msgbuf,
    USHORT bufsize, 
    ULONG msgno, 
    unsigned int *msglen );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\ncberr.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ncberr.h

Abstract:

    This file contains the text for ncb error messages.

Author:

    Yi-HsinS (Yi-Hsin Sung) 21-Aug-1991

Revision History:

Notes:

    This file is used to generate a LAN Manager error message file.

    See lmcons.h for range of error codes in use by LAN Manager components.

--*/

#ifndef NCBERR_INCLUDED
#define NCBERR_INCLUDED

#define NRCERR_BASE   5300


#define NRCerr_GOODRET	   (NRCERR_BASE + 0)	/* @E
       *
       * The network control block (NCB) request completed successfully.
       * The NCB is the data.
       */
#define NRCerr_BUFLEN	   (NRCERR_BASE + 1)	/* @E
       *
       * Illegal network control block (NCB) buffer length on SEND DATAGRAM,
       * SEND BROADCAST, ADAPTER STATUS, or SESSION STATUS.
       * The NCB is the data.
       */
#define NRCerr_DESCRIPTOR  (NRCERR_BASE + 2)	/* @E
       *
       * The data descriptor array specified in the network control block (NCB) is
       * invalid.  The NCB is the data.
       */
#define NRCerr_ILLCMD	   (NRCERR_BASE + 3)	/* @E
       *
       * The command specified in the network control block (NCB) is illegal.
       * The NCB is the data.
       */
#define NRCerr_INVCORR	   (NRCERR_BASE + 4)	/* @E
       *
       * The message correlator specified in the network control block (NCB) is
       * invalid.  The NCB is the data.
       */
#define NRCerr_CMDTMO	   (NRCERR_BASE + 5)	/* @E
       *
       * A network control block (NCB) command timed-out.  The session may have
       * terminated abnormally.  The NCB is the data.
       */
#define NRCerr_INCOMP	   (NRCERR_BASE + 6)	/* @E
       *
       * An incomplete network control block (NCB) message was received.
       * The NCB is the data.
       */
#define NRCerr_BADDR	   (NRCERR_BASE + 7)	/* @E
       *
       * The buffer address specified in the network control block (NCB) is illegal.
       * The NCB is the data.
       */
#define NRCerr_SNUMOUT	   (NRCERR_BASE + 8)	/* @E
       *
       * The session number specified in the network control block (NCB) is not active.
       * The NCB is the data.
       */
#define NRCerr_NORES	   (NRCERR_BASE + 9)	/* @E
       *
       * No resource was available in the network adapter.
       * The network control block (NCB) request was refused.  The NCB is the data.
       */
#define NRCerr_SCLOSED	   (NRCERR_BASE + 10)	 /* @E
       *
       * The session specified in the network control block (NCB) was closed.
       * The NCB is the data.
       */
#define NRCerr_CMDCAN	   (NRCERR_BASE + 11)	 /* @E
       *
       * The network control block (NCB) command was canceled.
       * The NCB is the data.
       */
#define NRCerr_MESSSEG	   (NRCERR_BASE + 12)	 /* @E
       *
       * The message segment specified in the network control block (NCB) is
       * illogical.  The NCB is the data.
       */
#define NRCerr_DUPNAME	   (NRCERR_BASE + 13)	 /* @E
       *
       * The name already exists in the local adapter name table.
       * The network control block (NCB) request was refused.  The NCB is the data.
       */
#define NRCerr_NAMTFUL	   (NRCERR_BASE + 14)	 /* @E
       *
       * The network adapter name table is full.
       * The network control block (NCB) request was refused.  The NCB is the data.
       */
#define NRCerr_ACTSES	   (NRCERR_BASE + 15)	 /* @E
       *
       * The network name has active sessions and is now de-registered.
       * The network control block (NCB) command completed.  The NCB is the data.
       */
#define NRCerr_RECVLOOKAHD (NRCERR_BASE + 16)	 /* @E
       *
       * A previously issued Receive Lookahead command is active
       * for this session.  The network control block (NCB) command was rejected.
       * The NCB is the data.
       */
#define NRCerr_LOCTFUL	   (NRCERR_BASE + 17)	 /* @E
       *
       * The local session table is full. The network control block (NCB) request was refused.
       * The NCB is the data.
       */
#define NRCerr_REMTFUL	   (NRCERR_BASE + 18)	 /* @E
       *
       * A network control block (NCB) session open was rejected.  No LISTEN is outstanding
       * on the remote computer.  The NCB is the data.
       */
#define NRCerr_ILLNN	   (NRCERR_BASE + 19)	 /* @E
       *
       * The name number specified in the network control block (NCB) is illegal.
       * The NCB is the data.
       */
#define NRCerr_NOCALL	   (NRCERR_BASE + 20)	 /* @E
       *
       * The call name specified in the network control block (NCB) cannot be found or
       * did not answer.  The NCB is the data.
       */
#define NRCerr_NOWILD	   (NRCERR_BASE + 21)	 /* @E
       *
       * The name specified in the network control block (NCB) was not found.  Cannot put '*' or
       * 00h in the NCB name.  The NCB is the data.
       */
#define NRCerr_INUSE	   (NRCERR_BASE + 22)	 /* @E
       *
       * The name specified in the network control block (NCB) is in use on a remote adapter.
       * The NCB is the data.
       */
#define NRCerr_NAMERR	   (NRCERR_BASE + 23)	 /* @E
       *
       * The name specified in the network control block (NCB) has been deleted.
       * The NCB is the data.
       */
#define NRCerr_SABORT	   (NRCERR_BASE + 24)	 /* @E
       *
       * The session specified in the network control block (NCB) ended abnormally.
       * The NCB is the data.
       */
#define NRCerr_NAMCONF	   (NRCERR_BASE + 25)	 /* @E
       *
       * The network protocol has detected two or more identical
       * names on the network.	The network control block (NCB) is the data.
       */
#define NRCerr_INVRMDEV    (NRCERR_BASE + 26)	 /* @E
       *
       * An unexpected protocol packet was received.  There may be an
       * incompatible remote device.  The network control block (NCB) is the data.
       */
#define NRCerr_IFBUSY	   (NRCERR_BASE + 33)	 /* @E
       *
       * The NetBIOS interface is busy.
       * The network control block (NCB) request was refused.  The NCB is the data.
       */
#define NRCerr_TOOMANY	   (NRCERR_BASE + 34)	 /* @E
       *
       * There are too many network control block (NCB) commands outstanding.
       * The NCB request was refused.  The NCB is the data.
       */
#define NRCerr_BRIDGE	   (NRCERR_BASE + 35)	 /* @E
       *
       * The adapter number specified in the network control block (NCB) is illegal.
       * The NCB is the data.
       */
#define NRCerr_CANOCCR	   (NRCERR_BASE + 36)	 /* @E
       *
       * The network control block (NCB) command completed while a cancel was occurring.
       * The NCB is the data.
       */
#define NRCerr_RESNAME	   (NRCERR_BASE + 37)	 /* @E
       *
       * The name specified in the network control block (NCB) is reserved.
       * The NCB is the data.
       */
#define NRCerr_CANCEL	   (NRCERR_BASE + 38)	 /* @E
       *
       * The network control block (NCB) command is not valid to cancel.
       * The NCB is the data.
       */
#define NRCerr_MULT	   (NRCERR_BASE + 51)	 /* @E
       *
       * There are multiple network control block (NCB) requests for the same session.
       * The NCB request was refused.  The NCB is the data.
       */
#define NRCerr_MALF	   (NRCERR_BASE + 52)	 /* @E
       *
       * There has been a network adapter error. The only NetBIOS
       * command that may be issued is an NCB RESET. The network control block (NCB) is
       * the data.
       */
#define NRCerr_MAXAPPS	   (NRCERR_BASE + 54)	 /* @E
       *
       * The maximum number of applications was exceeded.
       * The network control block (NCB) request was refused.  The NCB is the data.
       */
#define NRCerr_NORESOURCES (NRCERR_BASE + 56)	 /* @E
       *
       * The requested resources are not available.
       * The network control block (NCB) request was refused.  The NCB is the data.
       */
#define NRCerr_SYSTEM	   (NRCERR_BASE + 64)	 /* @E
       *
       * A system error has occurred.
       * The network control block (NCB) request was refused.  The NCB is the data.
       */
#define NRCerr_ROM	   (NRCERR_BASE + 65)	 /* @E
       *
       * A ROM checksum failure has occurred.
       * The network control block (NCB) request was refused.  The NCB is the data.
       */
#define NRCerr_RAM	   (NRCERR_BASE + 66)	 /* @E
       *
       * A RAM test failure has occurred.
       * The network control block (NCB) request was refused.  The NCB is the data.
       */
#define NRCerr_DLF	   (NRCERR_BASE + 67)	 /* @E
       *
       * A digital loopback failure has occurred.
       * The network control block (NCB) request was refused.  The NCB is the data.
       */						     */
#define NRCerr_ALF	   (NRCERR_BASE + 68)	 /* @E
       *
       * An analog loopback failure has occurred.
       * The network control block (NCB) request was refused.  The NCB is the data.
       */
#define NRCerr_IFAIL	   (NRCERR_BASE + 69)	 /* @E
       *
       * An interface failure has occurred.
       * The network control block (NCB) request was refused.  The NCB is the data.
       */
#define NRCerr_DEFAULT	   (NRCERR_BASE + 70)	 /* @E
       *
       * An unrecognized network control block (NCB) return code was received.
       * The NCB is the data.
       */
#define NRCerr_ADPTMALFN   (NRCERR_BASE + 80)	/* @E
       *
       * A network adapter malfunction has occurred.
       * The network control block (NCB) request was refused.  The NCB is the data.
       */
#define NRCerr_PENDING	   (NRCERR_BASE + 81)	/* @E
       *
       * The network control block (NCB) command is still pending.
       * The NCB is the data.
       */

#endif // NCBERR_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\netstats.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    netstats.h

Abstract:

    Contains prototypes for private net stats routines

Author:

    Richard L Firth (rfirth) 21-Jan-1992

Revision History:

--*/

NET_API_STATUS
NetWkstaStatisticsGet(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    IN  DWORD   Options,
    OUT LPBYTE* Buffer
    );

NET_API_STATUS
NetServerStatisticsGet(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    IN  DWORD   Options,
    OUT LPBYTE* Buffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\ntfrsapi.h ===
/*++ BUILD Version: 0001    Increment if a change has global effects

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    ntfrsapi.h

Abstract:

    Header file for the application programmer's interfaces to the
    File Replication Service (NtFrs) that support they system volumes
    and DC Promotion / Demotion.

Environment:

    User Mode - Win32

Notes:

--*/
#ifndef _NTFRSAPI_H_
#define _NTFRSAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Pull in public headers for compat.
//
#include <frsapip.h>

//
// If a file or dir create has a name that starts with the following GUID
// then FRS does not replicate the created file or dir.  Note:  For dirs
// this means that the directory is never entered in the FRS directory filter
// table so FRS will never replicate the dir (even after it is renamed) or
// any changes to the dir (like ACLs or added streams or attrib changes) or
// any children created under the dir.
//
#define  NTFRS_REPL_SUPPRESS_PREFIX  L"2ca04e7e-44c8-4076-8890a424b8ad193e"


DWORD
WINAPI
NtFrsApi_PrepareForPromotionW(
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function prepares the NtFrs service on this machine for
    promotion by stopping the service, deleting old promotion
    state in the registry, and restarting the service.

    This function is not idempotent and isn't MT safe.

Arguments:

    None.

Return Value:

    Win32 Status
--*/


DWORD
WINAPI
NtFrsApi_PrepareForDemotionUsingCredW(
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,   OPTIONAL
    IN HANDLE ClientToken,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:
    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function prepares the NtFrs service on this machine for
    demotion by stopping the service, deleting old demotion
    state in the registry, and restarting the service.

    This function is not idempotent and isn't MT safe.

Arguments:

    Credentials -- Credentionals to use in ldap binding call, if supplied.

    ClientToken -- Impersonation token to use if no Credentials supplied.


Return Value:
    Win32 Status
--*/


DWORD
WINAPI
NtFrsApi_PrepareForDemotionW(
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function prepares the NtFrs service on this machine for
    demotion by stopping the service, deleting old demotion
    state in the registry, and restarting the service.

    This function is not idempotent and isn't MT safe.

Arguments:

    None.

Return Value:

    Win32 Status
--*/


#define NTFRSAPI_SERVICE_STATE_IS_UNKNOWN   (00)
#define NTFRSAPI_SERVICE_PROMOTING          (10)
#define NTFRSAPI_SERVICE_DEMOTING           (20)
#define NTFRSAPI_SERVICE_DONE               (99)



DWORD
WINAPI
NtFrsApi_StartPromotionW(
    IN PWCHAR   ParentComputer,                         OPTIONAL
    IN PWCHAR   ParentAccount,                          OPTIONAL
    IN PWCHAR   ParentPassword,                         OPTIONAL
    IN DWORD    DisplayCallBack(IN PWCHAR Display),     OPTIONAL
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG),     OPTIONAL
    IN PWCHAR   ReplicaSetName,
    IN PWCHAR   ReplicaSetType,
    IN DWORD    ReplicaSetPrimary,
    IN PWCHAR   ReplicaSetStage,
    IN PWCHAR   ReplicaSetRoot
    );
/*++
Routine Description:

    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function kicks off a thread that updates the sysvol information
    in the registry and initiates the seeding process. The thread tracks
    the progress of the seeding and periodically informs the caller.

    The threads started by NtFrsApi_StartPromotionW can be forcefully
    terminated with NtFrsApi_AbortPromotionW.

    The threads started by NtFrsApi_StartPromotionW can be waited on
    with NtFrsApi_WaitForPromotionW.

Arguments:

    ParentComputer      - An RPC-bindable name of the computer that is
                          supplying the Directory Service (DS) with its
                          initial state. The files and directories for
                          the system volume are replicated from this
                          parent computer.
    ParentAccount       - A logon account on ParentComputer.
    ParentPassword      - The logon account's password on ParentComputer.
    DisplayCallBack     - Called periodically with a progress display.
    ReplicaSetName      - Name of the replica set.
    ReplicaSetType      - Type of replica set (enterprise or domain)
    ReplicaSetPrimary   - Is this the primary member of the replica set?
                        - 1 = primary; 0 = not.
    ReplicaSetStage     - Staging path.
    ReplicaSetRoot      - Root path.

Return Value:

    Win32 Status
--*/




DWORD
WINAPI
NtFrsApi_StartDemotionW(
    IN PWCHAR   ReplicaSetName,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function kicks off a thread that stops replication of the
    system volume on this machine by telling the NtFrs service on
    this machine to tombstone the system volume's replica set.

    The threads started by NtFrsApi_StartDemotionW can be forcefully
    terminated with NtFrsApi_AbortDemotionW.

    The threads started by NtFrsApi_StartDemotionW can be waited on
    with NtFrsApi_WaitForDemotionW.

Arguments:

    ReplicaSetName      - Name of the replica set.

Return Value:

    Win32 Status
--*/




DWORD
WINAPI
NtFrsApi_WaitForPromotionW(
    IN DWORD    TimeoutInMilliSeconds,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function waits for the seeding to finish or to stop w/error.

Arguments:

    TimeoutInMilliSeconds    - Timeout in milliseconds for waiting for
                               seeding to finish. INFINITE if no timeout.

Return Value:

    Win32 Status
--*/




DWORD
WINAPI
NtFrsApi_WaitForDemotionW(
    IN DWORD    TimeoutInMilliSeconds,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function waits for the tombstoning to finish or to stop w/error.

Arguments:

    TimeoutInMilliSeconds    - Timeout in milliseconds for waiting for
                               seeding to finish. INFINITE if no timeout.

Return Value:

    Win32 Status
--*/




DWORD
WINAPI
NtFrsApi_CommitPromotionW(
    IN DWORD    TimeoutInMilliSeconds,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    WARNING - This function assumes the caller will reboot the system
    soon after this call!

    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function waits for the seeding to finish, stops the service,
    and commits the state in the registry. On reboot, the NtFrs Service
    updates the DS on this machine with the information in the registry.

Arguments:

    TimeoutInMilliSeconds    - Timeout in milliseconds for waiting for
                               seeding to finish. INFINITE if no timeout.

Return Value:

    Win32 Status
--*/




DWORD
WINAPI
NtFrsApi_CommitDemotionW(
    IN DWORD    TimeoutInMilliSeconds,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    WARNING - This function assumes the caller will reboot the system
    soon after this call!

    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function waits for the tombstoning to finish, tells the service
    to forcibly delete the system volumes' replica sets, stops the service,
    and commits the state in the registry. On reboot, the NtFrs Service
    updates the DS on this machine with the information in the registry.

Arguments:

    TimeoutInMilliSeconds    - Timeout in milliseconds for waiting for
                               tombstoning to finish. INFINITE if no timeout.

Return Value:

    Win32 Status
--*/




DWORD
WINAPI
NtFrsApi_AbortPromotionW(
    VOID
    );
/*++
Routine Description:

    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function aborts the seeding process by stopping the service,
    deleting the promotion state out of the registry, cleaning up
    the active threads and the active RPC calls, and finally resetting
    the service to its pre-seeding state.

Arguments:

    None.

Return Value:

    Win32 Status
--*/




DWORD
WINAPI
NtFrsApi_AbortDemotionW(
    VOID
    );
/*++
Routine Description:

    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.

    During demotion, NtFrsApi_StartDemotionW stops replication of
    the system volume on this machine by telling the NtFrs service
    on this machine to tombstone the system volume's replica set.

    This function aborts the tombstoning process by stopping the service,
    deleting the demotion state out of the registry, cleaning up
    the active threads and the active RPC calls, and finally resetting
    the service to its pre-tombstoning state.

Arguments:

    None.

Return Value:

    Win32 Status
--*/




//
// Type of internal information returned by NtFrsApi_InfoW()
//
#define NTFRSAPI_INFO_TYPE_MIN       (0)
#define NTFRSAPI_INFO_TYPE_VERSION   (0)
#define NTFRSAPI_INFO_TYPE_SETS      (1)
#define NTFRSAPI_INFO_TYPE_DS        (2)
#define NTFRSAPI_INFO_TYPE_MEMORY    (3)
#define NTFRSAPI_INFO_TYPE_IDTABLE   (4)
#define NTFRSAPI_INFO_TYPE_OUTLOG    (5)
#define NTFRSAPI_INFO_TYPE_INLOG     (6)
#define NTFRSAPI_INFO_TYPE_THREADS   (7)
#define NTFRSAPI_INFO_TYPE_STAGE     (8)
#define NTFRSAPI_INFO_TYPE_CONFIGTABLE    (9)

#define NTFRSAPI_INFO_TYPE_MAX       (10)

//
// Internal constants
//
#define NTFRSAPI_DEFAULT_INFO_SIZE  (32 * 1024)
#define NTFRSAPI_MINIMUM_INFO_SIZE  ( 1 * 1024)

//
// Opaque information from NtFrs.
// Parse with NtFrsApi_InfoLineW().
// Free with NtFrsApi_InfoFreeW();
//
typedef struct _NTFRSAPI_INFO {
    ULONG   Major;
    ULONG   Minor;
    ULONG   NtFrsMajor;
    ULONG   NtFrsMinor;
    ULONG   SizeInChars;
    ULONG   Flags;
    ULONG   TypeOfInfo;
    ULONG   TotalChars;
    ULONG   CharsToSkip;
    ULONG   OffsetToLines;
    ULONG   OffsetToFree;
    CHAR    Lines[1];
} NTFRSAPI_INFO, *PNTFRSAPI_INFO;
//
// RPC Blob must be at least this size
//
#define NTFRSAPI_INFO_HEADER_SIZE   (5 * sizeof(ULONG))

//
// NtFrsApi Information Flags
//
#define NTFRSAPI_INFO_FLAGS_VERSION (0x00000001)
#define NTFRSAPI_INFO_FLAGS_FULL    (0x00000002)




DWORD
WINAPI
NtFrsApi_InfoW(
    IN     PWCHAR  ComputerName,       OPTIONAL
    IN     ULONG   TypeOfInfo,
    IN     ULONG   SizeInChars,
    IN OUT PVOID   *NtFrsApiInfo
    );
/*++
Routine Description:
    Return a buffer full of the requested information. The information
    can be extracted from the buffer with NtFrsApi_InfoLineW().

    *NtFrsApiInfo should be NULL on the first call. On subsequent calls,
    *NtFrsApiInfo will be filled in with more data if any is present.
    Otherwise, *NtFrsApiInfo is set to NULL and the memory is freed.

    The SizeInChars is a suggested size; the actual memory usage
    may be different. The function chooses the memory usage if
    SizeInChars is 0.

    The format of the returned information can change without notice.

Arguments:
    ComputerName     - Poke the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.

    TypeOfInfo      - See the constants beginning with NTFRSAPI_INFO_
                      in ntfrsapi.h.

    SizeInChars     - Suggested memory usage; actual may be different.
                      0 == Function chooses memory usage

    NtFrsApiInfo    - Opaque. Parse with NtFrsApi_InfoLineW().
                      Free with NtFrsApi_InfoFreeW();

Return Value:
    Win32 Status
--*/




DWORD
WINAPI
NtFrsApi_InfoLineW(
    IN      PNTFRSAPI_INFO  NtFrsApiInfo,
    IN OUT  PVOID           *InOutLine
    );
/*++
Routine Description:
    Extract the wchar lines of information from NtFrsApiInformation.

    Returns the address of the next L'\0' terminated line of information.
    NULL if none.

Arguments:
    NtFrsApiInfo    - Opaque. Returned by NtFrsApi_InfoW().
                      Parse with NtFrsApi_InfoLineW().
                      Free with NtFrsApi_InfoFreeW().

Return Value:
    Win32 Status
--*/




BOOL
WINAPI
NtFrsApi_InfoMoreW(
    IN  PNTFRSAPI_INFO  NtFrsApiInfo
    );
/*++
Routine Description:
    All of the information may not have fit in the buffer. The additional
    information can be fetched by calling NtFrsApi_InfoW() again with the
    same NtFrsApiInfo struct. NtFrsApi_InfoW() will return NULL in
    NtFrsApiInfo if there is no more information.

    However, the information returned in subsequent calls to _InfoW() may be
    out of sync with the previous information. If the user requires a
    coherent information set, then the information buffer should be freed
    with NtFrsApi_InfoFreeW() and another call made to NtFrsApi_InfoW()
    with an increased SizeInChars. Repeat the procedure until
    NtFrsApi_InfoMoreW() returns FALSE.

Arguments:
    NtFrsApiInfo - Opaque. Returned by NtFrsApi_InfoW().
                   Parse with NtFrsApi_InfoLineW().
                   Free with NtFrsApi_InfoFreeW().

Return Value:
    TRUE    - The information buffer does *NOT* contain all of the info.
    FALSE   - The information buffer does contain all of the info.
--*/




DWORD
WINAPI
NtFrsApi_InfoFreeW(
    IN  PVOID   *NtFrsApiInfo
    );
/*++
Routine Description:
    Free the information buffer allocated by NtFrsApi_InfoW();

Arguments:
    NtFrsApiInfo - Opaque. Returned by NtFrsApi_InfoW().
                   Parse with NtFrsApi_InfoLineW().
                   Free with NtFrsApi_InfoFreeW().

Return Value:
    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_DeleteSysvolMember(
    IN          PSEC_WINNT_AUTH_IDENTITY_W pCreds,
    IN          PWCHAR   BindingDC,
    IN          PWCHAR   NTDSSettingsDn,
    IN OPTIONAL PWCHAR   ComputerDn

    );
/*++
Routine Description:
    This API is written to be called from NTDSUTIL.EXE to remove
    FRS member and subscriber object for a server that is being
    removed (without dcpromo-demote) from the list of DCs.

Arguments:

    pCreds         p Credentials used to bind to the DS.
    BindingDC      - Name of a DC to perform the delete on.
    NTDSSettingsDn - Dn of the "NTDS Settings" object for the server
                     that is being removed from the sysvol replica set.
    ComputerDn     - Dn of the computer object for the server that is 
                     being removed from the sysvol replica set.

Return Value:

    Win32 Status
--*/


#ifdef __cplusplus
}
#endif

#endif  _NTFRSAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\netsetup.h ===
/*++

Copyright (c) 1997 - 1997  Microsoft Corporation

Module Name:

    netsetup.h

Abstract:

    Definitions and prototypes for the Net setup apis, for joining/unjoinging
    domains and promoting/demoting servers

Author:

    Mac McLain   (MacM)     19-Feb-1997

Environment:

    User mode only.

Revision History:

--*/
#ifndef __NETSETUP_H__
#define __NETSETUP_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>


#define NETSETUPP_CONNECT_IPC       0x00000001
#define NETSETUPP_DISCONNECT_IPC    0x00000002
#define NETSETUPP_NULL_SESSION_IPC  0x00000010

#define NETSETUPP_CREATE            0
#define NETSETUPP_DELETE            1
#define NETSETUPP_RENAME            2


#define NETSETUP_SVC_STOPPED    0x00000001
#define NETSETUP_SVC_STARTED    0x00000002
#define NETSETUP_SVC_ENABLED    0x00000004
#define NETSETUP_SVC_DISABLED   0x00000008
#define NETSETUP_SVC_MANUAL     0x00000010


#define NETSETUPP_SVC_NETLOGON  0x00000001
#define NETSETUPP_SVC_TIMESVC   0x00000002

#define NETSETUP_IGNORE_JOIN    0x80000000

//
// Helpful macros
//

//
// Determines whether a bit flag is turned on or not
//
#define FLAG_ON(flag,bits)        ((flag) & (bits))

//
// Determine whether the client is joined to a domain or not given the LSAs
// primary domain information
//
#define IS_CLIENT_JOINED(plsapdinfo)                                        \
((plsapdinfo)->Sid != NULL && (plsapdinfo)->Name.Length != 0 ? TRUE : FALSE)

//
// Log routines
//

void
NetSetuppOpenLog();

void
NetSetuppCloseLog();

void
NetpLogPrintHelper(
    IN LPCSTR Format,
    ...);

#define NetpLog(x) NetpLogPrintHelper x

//
// Procedure forwards
//

NET_API_STATUS
NET_API_FUNCTION
NetpMachineValidToJoin(
    IN  LPWSTR      lpMachine,
	IN  BOOL        fJoiningDomain
    );

NET_API_STATUS
NET_API_FUNCTION
NetpChangeMachineName(
    IN  LPWSTR      lpCurrentMachine,
    IN  LPWSTR      lpNewHostName,
    IN  LPWSTR      lpDomain,
    IN  LPWSTR      lpAccount,
    IN  LPWSTR      lpPassword,
    IN  DWORD       fJoinOpts
);

NET_API_STATUS
NET_API_FUNCTION
NetpUnJoinDomain(
    IN  PPOLICY_PRIMARY_DOMAIN_INFO pPolicyPDI,
    IN  LPWSTR                      lpAccount,
    IN  LPWSTR                      lpPassword,
    IN  DWORD                       fJoinOpts
    );

NET_API_STATUS
NET_API_FUNCTION
NetpGetLsaPrimaryDomain(
    IN  LSA_HANDLE                          PolicyHandle,  OPTIONAL
    IN  LPWSTR                              lpServer,      OPTIONAL
    OUT PPOLICY_PRIMARY_DOMAIN_INFO        *ppPolicyPDI,
#if(_WIN32_WINNT >= 0x0500)
    OUT PPOLICY_DNS_DOMAIN_INFO            *ppPolicyDns,
#endif
    OUT PLSA_HANDLE                         pPolicyHandle  OPTIONAL
    );

NET_API_STATUS
NET_API_FUNCTION
NetpBrowserCheckDomain(
    IN LPWSTR NewDomainName
    );

NET_API_STATUS
NET_API_FUNCTION
NetpCheckNetBiosNameNotInUse(
    IN  LPWSTR  pszName,
    IN  BOOLEAN MachineName,
    IN  BOOLEAN UniqueName
    );

NET_API_STATUS
NET_API_FUNCTION
NetpCheckDomainNameIsValid(
    IN  LPWSTR  lpName,
    IN  LPWSTR  lpAccount,
    IN  LPWSTR  lpPassword,
    IN  BOOL    fShouldExist
    );

NET_API_STATUS
NET_API_FUNCTION
NetpValidateName(
    IN  LPWSTR              lpMachine,
    IN  LPWSTR              lpName,
    IN  LPWSTR              lpAccount,      OPTIONAL
    IN  LPWSTR              lpPassword,     OPTIONAL
    IN  NETSETUP_NAME_TYPE  NameType
    );

NET_API_STATUS
NET_API_FUNCTION
NetpGetJoinInformation(
    IN   LPWSTR                 lpServer OPTIONAL,
    OUT  LPWSTR                *lpNameBuffer,
    OUT  PNETSETUP_JOIN_STATUS  BufferType
    );

NET_API_STATUS
NET_API_FUNCTION
NetpDoDomainJoin(
    IN  LPWSTR      lpMachine,
    IN  LPWSTR      lpDomain,
    IN  LPWSTR      lpMachineAccountOU,
    IN  LPWSTR      lpAccount,
    IN  LPWSTR      lpPassword,
    IN  DWORD       fJoinOpts
    );

NET_API_STATUS
NET_API_FUNCTION
NetpGetListOfJoinableOUs(
    IN LPWSTR Domain,
    IN LPWSTR Account,
    IN LPWSTR Password,
    OUT PULONG Count,
    OUT PWSTR **OUs
    );

NET_API_STATUS
NET_API_FUNCTION
NetpGetNewMachineName(
    OUT PWSTR *NewMachineName
    );

NET_API_STATUS
NET_API_FUNCTION
NetpSetDnsComputerNameAsRequired(
    IN PWSTR DnsDomainName
    );

EXTERN_C
NET_API_STATUS
NET_API_FUNCTION
NetpUpgradePreNT5JoinInfo( VOID );

NET_API_STATUS
NET_API_FUNCTION
NetpSeparateUserAndDomain(
    IN  LPCWSTR  szUserAndDomain,
    OUT LPWSTR*  pszUser,
    OUT LPWSTR*  pszDomain
    );

NET_API_STATUS
NET_API_FUNCTION
NetpGetMachineAccountName(
    IN  LPCWSTR  szMachineName,
    OUT LPWSTR*  pszMachineAccountName
    );

NET_API_STATUS
NET_API_FUNCTION
NetpManageIPCConnect(
    IN  LPWSTR  lpServer,
    IN  LPWSTR  lpAccount,
    IN  LPWSTR  lpPassword,
    IN  ULONG   fOptions
    );

NET_API_STATUS
NET_API_FUNCTION
NetpControlServices(
    IN  DWORD       SvcOpts,
    IN  DWORD       Services
    );
VOID
NetpAvoidNetlogonSpnSet(
    BOOL AvoidSet
    );

NET_API_STATUS
NetpQueryService(
    IN  LPWSTR ServiceName,
    OUT SERVICE_STATUS *ServiceStatus,
    OUT LPQUERY_SERVICE_CONFIG *ServiceConfig
    );

DWORD
NetpCrackNamesStatus2Win32Error(
    DWORD dwStatus
    );

#endif // __NETSETUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\mapsupp.h ===
/*++

Copyright (c) 1989-91  Microsoft Corporation

Module Name:

    MapSupp.h

Abstract:

    These are support routines used by the 16/32 mapping layer for the LanMan
    API.

Author:

    Dan Hinsley (DanHi) 10-Apr-1991

Environment:

    These routines are statically linked in the caller's executable and
    are callable from user mode.

Revision History:

    10-Apr-1991 DanHi
        Created.
    18-Aug-1991 JohnRo
        Implement downlevel NetWksta APIs.  (Moved to NetLib, etc.)

--*/

#ifndef _MAPSUPP_
#define _MAPSUPP_


//
// Structure used by the NetpMoveStrings function
//

typedef struct _MOVESTRING_ {
    DWORD Source;               // May be MOVESTRING_END_MARKER.
    DWORD Destination;          // May be MOVESTRING_END_MARKER.
} MOVESTRING, *PMOVESTRING, *LPMOVESTRING;

#define MOVESTRING_END_MARKER  ( (DWORD) -1 )


//
// macro,  This for loop is used lots of places, so I've
// centralized it here.  The idea is that is builds the Levelxxx names
// based on the Dest and Src parameters (destination level, source level)
// using token pasting.  So the macro looks like bad, but once you see
// what it's doing, the invocation in the code is easier reading.
//
// example:
//
//  BUILD_LENGTH_ARRAY(BytesRequired, 10, 101, Wksta)
//
//        expands to
//
//  for (i = 0; NetpWksta10_101[i].Source != MOVESTRING_END_MARKER; i++) {
//        if (*((PCHAR) pLevel101 + NetpWksta10_101[i].Source)) {
//            Level10_101_Length[i] =
//                STRLEN(*((PCHAR *) ((PCHAR) pLevel101 +
//                    NetpWksta10_101[i].Source))) + 1;
//            BytesRequired += Level10_101_Length[i];
//        }
//        else {
//            Level10_101_Length[i] = 0;
//        }
//  }
//
// The construct *((PCHAR *) ((PCHAR) pLevel101 + NetpWksta10_101[i].Source))
// takes a pointer to a lanman structure (pLevel101) and an offset into
// that structure (NetpWksta10_101[i].Source) that points to an LPSTR in the
// structure, and creates the LPSTR that can be used by strxxx functions.
//

#define BUILD_LENGTH_ARRAY(BytesRequired, Dest, Src, Kind) \
\
    for (i = 0; Netp##Kind##Dest##_##Src##[i].Source != MOVESTRING_END_MARKER; i++) { \
        if ( * ( LPTSTR* ) ( (LPBYTE) pLevel##Src + Netp##Kind##Dest##_##Src##[i].Source ) ) {\
            Level##Dest##_##Src##_Length[i] = \
                STRLEN(*( LPTSTR* )( (LPBYTE) pLevel##Src + Netp##Kind##Dest##_##Src##[i].Source )) + 1;\
            BytesRequired += Level##Dest##_##Src##_##Length[i] * sizeof( TCHAR ); \
        } else { \
            Level##Dest##_##Src##_Length[i] = 0; \
        } \
    }

BOOL
NetpMoveStrings(
    IN OUT LPTSTR * Floor,
    IN LPTSTR pInputBuffer,
    OUT LPTSTR pOutputBuffer,
    IN LPMOVESTRING MoveStringArray,
    IN DWORD * MoveStringLenght
    );


/////////////////////////////////////////////////
// Data structures for use by NetpMoveStrings: //
/////////////////////////////////////////////////


extern MOVESTRING NetpServer2_102[];

extern MOVESTRING NetpServer2_402[];

extern MOVESTRING NetpServer3_403[];

//
// Enhancement: These are the same as NetpServer2_102, except the two fields are
//                reversed, ie source<->destination.  Should I bother with
//                making NetpMoveStrings be able to work with a single structure
//                and a switch?
//

extern MOVESTRING NetpServer102_2[];

extern MOVESTRING NetpServer402_2[];

extern MOVESTRING NetpServer403_3[];


extern MOVESTRING NetpWksta10_101[];

extern MOVESTRING NetpWksta10_User_1[];

// To build wksta_info_0

extern MOVESTRING NetpWksta0_101[];

extern MOVESTRING NetpWksta0_User_1[];

extern MOVESTRING NetpWksta0_402[];

// To build wksta_info_1 (incremental over wksta_info_0)

extern MOVESTRING NetpWksta1_User_1[];


// To build wksta_info_101/302/402 from wksta_info_0

extern MOVESTRING NetpWksta101_0[];

extern MOVESTRING NetpWksta402_0[];


#endif /* _MAPSUPP_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\netrpc.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    NetRpc.c

Abstract:

    This header file contains macros which are used by the Net (NT/LAN) code
    to remote APIs.  These macros try using RPC, and have a fallback which
    allows the use of RpcXlate (RPC translate) to a downlevel server.

    There are three macros:

    NET_REMOTE_TRY_RPC

        Sets up to allow a call to an RPC routine in the context of an
        exception handler.  It then falls into code provided by the caller,
        which must actually attempt the RPC call.  This code must, in any
        case, set a NET_API_STATUS variable.

    NET_REMOTE_RPC_FAILED

        Handles the exception.  It then determines whether or not it is
        worthwhile attempting to invoke a downlevel API.  If so, it falls
        into code provided by the caller, which may call the appropriate
        downlevel routine.  In any event, the code which is "fallen-into"
        must set the same NET_API_STATUS variable as above.

        For all but the service controller APIs, this gets passed a flag
        of NET_REMOTE_FLAG_NORMAL.  The service controller APIs must give
        NET_REMOTE_FLAG_SVC_CTRL to ensure that the correct error codes are
        generated and to avoid possible infinite loops.

    NET_REMOTE_END

        Indicates the end of the exception handler code.  Falls into code
        with the NET_API_STATUS variable set.

    The caller *must* invoke all three macros, in the order given in these
    examples.  Also, the macros must not be followed by semicolons; they are
    *not* statements.

Example:

    NET_API_STATUS NET_API_FUNCTION
    NetServerGetInfo(
        IN LPTSTR UncServerName,
        IN DWORD Level,
        OUT LPBYTE *BufPtr

    {
        NET_API_STATUS apiStatus;

        *BufPtr = NULL;     // Must be NULL so RPC knows to fill it in.

        NET_REMOTE_TRY_RPC

            //
            // Call RPC version of the API.
            //
            apiStatus = NetrServerGetInfo (
                    UncServerName,
                    Level,
                    (LPSERVER_INFO) BufPtr);

        //
        // Handle RPC failures.  This will set apiStatus if it can't
        // call the downlevel code.
        //
        NET_REMOTE_RPC_FAILED(
                "NetServerGetInfo",
                UncServerName,
                apiStatus,
                NET_REMOTE_FLAG_NORMAL,
                SERVICE_SERVER )

            //
            // Call downlevel version of the API.
            //
            apiStatus = RxNetServerGetInfo (
                    UncServerName,
                    Level,
                    BufPtr);

        NET_REMOTE_END

        return (apiStatus);
    } // NetServerGetInfo

    Note that the calling code must set the same status variable in two
    places:

        - Between NET_REMOTE_TRY_RPC and NET_REMOTE_RPC_FAILED.
        - Between NET_REMOTE_RPC_FAILED and NET_REMOTE_END.

    The NET_REMOTE_RPC_FAILED macro will also set the status variable if
    RPC failed and the remote machine doesn't support remoting of downlevel
    APIs.

    Another example, of an API without downlevel support:

    NET_API_STATUS
    NetSomeNewApi( IN LPTSTR UncServerName )
    {
        NET_API_STATUS stat;

        NET_REMOTE_TRY_RPC

            //
            // Call RPC version of the API.
            //
            stat = NetrSomeNewApi( UncServerName );

        NET_REMOTE_RPC_FAILED(
                "NetSomeNewApi",
                UncServerName,
                stat,
                NET_REMOTE_FLAG_NORMAL,
                SERVICE_WORKSTATION )

            //
            // This API doesn't exist in downlevel servers.
            //
            stat = ERROR_NOT_SUPPORTED;

        NET_REMOTE_END
        return (stat);
    } // NetSomeNewApi

Author:

    John Rogers (JohnRo) 10-Jul-1991

Environment:

    User mode - WIN32
    Requires RPC support and exception handlers.
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    This file requires WinDef.h, NetDebug.h, Rpc.h, and
    possibly others.

Revision History:

    10-Jul-1991 JohnRo
        Created these macros by copying code which I worked on in
        SvcDlls/SrvSvc/Client/SrvStubs.c.
    23-Jul-1991 JohnRo
        Really use ServiceName parameter.
    25-Jul-1991 JohnRo
        Quiet DLL stub debug output.
    31-Oct-1991 JohnRo
        RAID 3414: handle explicit local server name.
        Also move RPC error handling code from these macros to netlib routine.
        Expanded Environmeent comments above.
    07-Nov-1991 JohnRo
        RAID 4186: assert in RxNetShareAdd and other DLL stub problems.
    17-Jan-1992 JohnRo
        Added NET_REMOTE_RPC_FAILED_W for UNICODE-only server names.
    08-Apr-1992 JohnRo
        Clarify that ServiceName parameter is OPTIONAL.
    12-Jan-1993 JohnRo
        RAID 1586: incorporated DanL's loop change as workaround for MIDL
        bug which causes NetReplSetInfo to fail after the service stops.
    ??-???-1993 RajA
        Added NERR_TryDownLevel for LM/UNIX support.
    19-Apr-1993 JohnRo
        Fixed a bug in RajA's version of NET_REMOTE_RPC_FAILED_W.
        Added change history entry on behalf of RajA.
        Changed to NT tab convention (no hard tabs; spaces every 4 cols).
        Made changes suggested by PC-LINT 5.0

--*/


#ifndef _NETRPC_
#define _NETRPC_


#include <lmerr.h>      // NERR_TryDownLevel.


// Values for Flags below:
#define NET_REMOTE_FLAG_NORMAL          0x00000000
#define NET_REMOTE_FLAG_SVC_CTRL        0x00000001


NET_API_STATUS
NetpHandleRpcFailure(
    IN LPDEBUG_STRING DebugName,
    IN RPC_STATUS RpcStatus,
    IN LPTSTR ServerNameValue OPTIONAL,
    IN LPTSTR ServiceName OPTIONAL,
    IN DWORD Flags,             // NET_REMOTE_FLAG_ stuff.
    OUT LPBOOL TryDownLevel
    );

#define NET_REMOTE_TRY_RPC \
    { \
    INT  RetryCount = 1; \
    BOOL TryDownLevel = FALSE; \
    Retry: \
    RpcTryExcept {
        /*
        ** Fall into code which tries RPC call to remote machine.
        */

#define NET_REMOTE_RPC_FAILED(DebugName, \
        ServerNameValue, \
        ApiStatusVar, \
        Flags, \
        ServiceName ) \
        if (ApiStatusVar == NERR_TryDownLevel) \
                TryDownLevel = TRUE; \
    } \
    RpcExcept (1) { /* exception handler */ \
 \
        RPC_STATUS RpcStatus; \
 \
        RpcStatus = RpcExceptionCode(); \
 \
        if (RpcStatus == RPC_S_CALL_FAILED_DNE) { \
            RetryCount--; \
            if (RetryCount == 0) { \
                goto Retry; \
            } \
        } \
        RetryCount = 1; \
 \
        ApiStatusVar = NetpHandleRpcFailure( \
                DebugName, \
                RpcStatus, \
                (LPTSTR) ServerNameValue, \
                ServiceName, \
                Flags, \
                & TryDownLevel); \
 \
    } /* exception handler */ \
    RpcEndExcept \
    if (TryDownLevel) {

            /*
            ** Caller would insert a call to some RxNet routine
            ** here, for downlevel support.
            */

#define NET_REMOTE_END \
        }        /* If TryDownLevel */ \
   } /* global scope */

        /*
        ** Fall into code with ApiStatusVar set.
        */


#endif // _NETRPC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\nticanon.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nticanon.h

Abstract:

    Header file for canonicalization routines - includes all other required
    headers

Author:

    Richard Firth (rfirth) 16-May-1991

Revision History:

    18-Sep-1991 JohnRo
        <tstring.h> now needs LPSTR and so on from <windef.h>.

--*/

#ifndef _NTICANON_H_INCLUDED
#define _NTICANON_H_INCLUDED

//
// Allow all 'static' items to be seen by the debugger in debug version
//

#if DBG
#define STATIC
#else
#define STATIC static
#endif

//
// system-level include files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <string.h>
#include <tstring.h>
#include <ctype.h>

//
// subsystem-level include files
//

#include <lmcons.h>
#include <lmwksta.h>
#include <lmapibuf.h>
#include <netlib.h>
#include <nturtl.h>
#include <lmerr.h>      // includes winerror.h
#include <winbase.h>

//
// component-level include files
//

#include <icanon.h>     // I_Net canonicalization prototypes
#include <apinums.h>    // API numbers for RxRemoteApi
#include <remdef.h>     // remote API parameter descriptor strings
#include <rx.h>         // RxRemoteApi
#include <netdebug.h>   // various Net related debugging functions
#include <lmremutl.h>   // NetRemoteComputerSupports...
#include <rpc.h>        // RPC definitions
#include <rpcutil.h>
#include <netcan.h>     // Netpw RPC canonicalization worker routines

//
// module-level include files
//

#include "assert.h"
#include "token.h"
#include "validc.h"

//
// externals
//

extern
LPTSTR
strtail(
    IN  LPTSTR  str1,
    IN  LPTSTR  str2
    );

extern
NET_API_STATUS
CanonicalizePathName(
    IN  LPTSTR  PathPrefix OPTIONAL,
    IN  LPTSTR  PathName,
    OUT LPTSTR  Buffer,
    IN  DWORD   BufferSize,
    OUT LPDWORD RequiredSize OPTIONAL
    );

//
// miscellaneous component-wide manifests
//

#endif  // _NTICANON_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\portuas.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    PORTUAS.H

Abstract:

    Header file for UAS->SAM porting runtime function.

Author:

    Shanku Niyogi (W-SHANKN)  29-Oct-1991

Revision History:

    29-Oct-1991     w-shankn
        Created.
    20-Oct-1992 JohnRo
        RAID 9020 ("prompt on conflicts" version).
    30-Jul-1993 JohnRo
        RAID NTISSUE 2260: PortUAS returns a NetUserAdd error=1379 with local
        group.

--*/

#ifndef _PORTUAS_
#define _PORTUAS_


//
// Equates for name prompt reasons.
//
#define REASON_CONFLICT_WITH_USERNAME   ((DWORD) 1)
#define REASON_CONFLICT_WITH_GROUP      ((DWORD) 2)
#define REASON_CONFLICT_WITH_DOMAIN     ((DWORD) 3)
#ifdef FAT8
#define REASON_NAME_LONG_FOR_TEMP_REG   ((DWORD) 4)
#endif
#define REASON_BAD_NAME_SYNTAX          ((DWORD) 5)
#define REASON_CONFLICT_WITH_LOCALGROUP ((DWORD) 6)


//
// Function prototype.
//

NET_API_STATUS
PortUas(
    IN LPTSTR UasPathName
    );


#endif // _PORTUAS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rapgtpt.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RapGtPt.h

Abstract:

    This header file contains the Remote Admin Protocol (RAP) get and put
    macros.  These encapsulate handling of alignment differences and byte
    order differences between the native machine and the RAP protocol.

Author:

    John Rogers (JohnRo) 14-Jul-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    14-Jul-1991 JohnRo
        Created this header file.

--*/

#ifndef _RAPGTPT_
#define _RAPGTPT_


// These must be included first:

#include <windef.h>             // BOOL, CHAR, DWORD, IN, LPBYTE, etc.


// These may be included in any order:

#include <smbgtpt.h>            // SmbPutUshort(), etc.


//
// DWORD
// RapGetDword(
//     IN LPBYTE Ptr,  // Assumed aligned if Native is true.
//     IN BOOL Native
//     );
//
#define RapGetDword(Ptr,Native)            \
    ( (Native)                             \
    ? ( * (LPDWORD) (LPVOID) (Ptr) )       \
    : (SmbGetUlong( (LPDWORD) (Ptr) ) ) )

//
// WORD
// RapGetWord(
//     IN LPBYTE Ptr,  // Assumed aligned if Native is true.
//     IN BOOL Native
//     );
//
#define RapGetWord(Ptr,Native)             \
    ( (Native)                             \
    ? ( * (LPWORD) (LPVOID) (Ptr) )        \
    : (SmbGetUshort( (LPWORD) (Ptr) ) ) )

//
// VOID
// RapPutDword(
//     OUT LPBYTE Ptr,  // Assumed aligned if Native is true.
//     IN DWORD Value,
//     IN BOOL Native
//     );
//
#define RapPutDword(Ptr,Value,Native)                        \
    {                                                        \
        if (Native) {                                        \
            * (LPDWORD) (LPVOID) (Ptr) = (DWORD) (Value);    \
        } else {                                             \
            SmbPutUlong( (LPDWORD) (Ptr), (DWORD) (Value) ); \
        }                                                    \
    }

//
// VOID
// RapPutWord(
//     OUT LPBYTE Ptr,  // Assumed aligned if Native is true.
//     IN WORD Value,
//     IN BOOL Native
//     );
//
#define RapPutWord(Ptr,Value,Native)                         \
    {                                                        \
        if (Native) {                                        \
            * (LPWORD) (LPVOID) (Ptr) = (WORD) (Value);      \
        } else {                                             \
            SmbPutUshort( (LPWORD) (Ptr), (WORD) (Value) );  \
        }                                                    \
    }

//
// DWORD_PTR
// RapGetDword_Ptr(
//     IN LPBYTE Ptr,  // Assumed aligned if Native is true.
//     IN BOOL Native
//     );
//
#ifdef _WIN64
#define RapGetDword_Ptr(Ptr,Native)        \
    ( (Native)                             \
    ? ( * (PDWORD_PTR) (LPVOID) (Ptr) )   \
    : (((DWORD_PTR) SmbGetUlong( (LPDWORD) (Ptr) )) \
    | (((DWORD_PTR) SmbGetUlong( (LPDWORD) (Ptr) )) << 32) \
       ) )
#else
#define RapGetDword_Ptr(Ptr,Native)        \
    ( (Native)                             \
    ? ( * (PDWORD_PTR) (LPVOID) (Ptr) )   \
    : (((DWORD_PTR) SmbGetUlong( (LPDWORD) (Ptr) )) \
       ) )
#endif

//
// VOID
// RapPutDword_Ptr(
//     OUT LPBYTE Ptr,  // Assumed aligned if Native is true.
//     IN DWORD_PTR Value,
//     IN BOOL Native
//     );
//
#ifdef _WIN64
#define RapPutDword_Ptr(Ptr,Value,Native)                    \
    {                                                        \
        RapPutDword(Ptr, (DWORD)(DWORD_PTR) Value, Native);  \
        RapPutDword( ((LPDWORD) Ptr + 1), (DWORD)((DWORD_PTR) Value >> 32), Native);  \
    }
#else
#define RapPutDword_Ptr(Ptr,Value,Native)                    \
    {                                                        \
        RapPutDword(Ptr, (DWORD)(DWORD_PTR) Value, Native);  \
    }
#endif

#endif // ndef _RAPGTPT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxaudit.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RxAudit.h

Abstract:

    Prototypes for down-level remoted RxNetAudit routines

Author:

    Richard Firth (rfirth) 28-May-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    <windef.h>, <lmcons.h>, and <lmaudit.h> must be included before this file.

Revision History:

    28-May-1991 RFirth
        Created dummy version of this file.
    04-Nov-1991 JohnRo
        Implement remote NetAudit APIs.

--*/


#ifndef _RXAUDIT_
#define _RXAUDIT_


// API handlers (called by API stubs), in alphabetical order:

NET_API_STATUS
RxNetAuditClear (
    IN  LPTSTR  server,
    IN  LPTSTR  backupfile OPTIONAL,
    IN  LPTSTR  service OPTIONAL
    );

NET_API_STATUS
RxNetAuditRead (
    IN  LPTSTR  server,
    IN  LPTSTR  service OPTIONAL,
    IN  LPHLOG  auditloghandle,
    IN  DWORD   offset,
    IN  LPDWORD reserved1 OPTIONAL,
    IN  DWORD   reserved2,
    IN  DWORD   offsetflag,
    OUT LPBYTE  *bufptr,
    IN  DWORD   prefmaxlen,
    OUT LPDWORD bytesread,
    OUT LPDWORD totalavailable  // approximate!!!
    );

NET_API_STATUS
RxNetAuditWrite (
    IN  DWORD   type,
    IN  LPBYTE  buf,
    IN  DWORD   numbytes,
    IN  LPTSTR  service OPTIONAL,
    IN  LPBYTE  reserved OPTIONAL
    );


// Private copy-and-convert routines, in aplhabetical order:

NET_API_STATUS
RxpConvertAuditArray(
    IN LPVOID InputArray,
    IN DWORD InputByteCount,
    OUT LPBYTE * OutputArray,  // will be alloc'ed (free w/ NetApiBufferFree).
    OUT LPDWORD OutputByteCount
    );

VOID
RxpConvertAuditEntryVariableData(
    IN DWORD EntryType,
    IN LPVOID InputVariablePtr,
    OUT LPVOID OutputVariablePtr,
    IN DWORD InputVariableSize,
    OUT LPDWORD OutputVariableSize
    );

#endif  // _RXAUDIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rapdebug.h ===
/*++

Copyright (c) 1990,91 Microsoft Corporation

Module Name:

    RapDebug.h

Abstract:

    This include file defines Rap's debug stuff.

Author:

    John Rogers (JohnRo) 29-Apr-1991

Revision History:

    29-Apr-1991 JohnRo
        Created (copied stuff from LarryO's rdr/debug.h).
    29-May-1991 JohnRo
        Added RapTotalSize debug flag.
    11-Jul-1991 JohnRo
        Added support for RapStructureAlignment() and RapParmNumDescriptor().

--*/

#ifndef _RAPDEBUG_
#define _RAPDEBUG_


#include <windef.h>             // DWORD, FALSE, TRUE.


// Debug trace level bits:

// RapConvertSingleEntry:
#define RAP_DEBUG_CONVERT  0x00000001

// RapParmNumDescriptor:
#define RAP_DEBUG_PARMNUM  0x00000080

// RapStructureAlignment:
#define RAP_DEBUG_STRUCALG 0x00000100

// RapTotalSize:
#define RAP_DEBUG_TOTALSIZ 0x00001000

#define RAP_DEBUG_ALL      0xFFFFFFFF


#if DBG

extern DWORD RappTrace;

#define DEBUG if (TRUE)

#define IF_DEBUG(Function) if (RappTrace & RAP_DEBUG_ ## Function)

#else

#define DEBUG if (FALSE)

#define IF_DEBUG(Function) if (FALSE)

#endif // DBG

#endif // _RAPDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rx.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    Rx.h

Abstract:

    This is the public header file for the NT version of RpcXlate.
    This mainly contains prototypes for the RxNetXxx routines and
    RxRemoteApi.

Author:

    John Rogers (JohnRo) 01-Apr-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    01-Apr-1991 JohnRo
        Created.
    03-Apr-1991 JohnRo
        Moved API handlers into per-group header files (e.g. RxServer.h).
    03-May-1991 JohnRo
        Changed RxRemoteApi to use three data desc versions.  Use Unicode.
        Also pass it UNC server name (\\stuff) for ease of use.
        Don't use NET_API_FUNCTION for non-APIs.
    14-May-1991 JohnRo
        Pass 3 aux descriptors to RxRemoteApi.
    16-Aug-1991 rfirth
        Changed prototype (NoPermissionRequired to Flags) & added some defines
    06-May-1993 JohnRo
        RAID 8849: Export RxRemoteApi for DEC and others.

--*/

#ifndef _RX_
#define _RX_


// These must be included first:
#include <windef.h>             // IN, LPTSTR, LPVOID, etc.
#include <lmcons.h>             // NET_API_STATUS.

// These may be included in any order:
#include <rap.h>                // LPDESC.

#include <lmremutl.h>   // RxRemoteApi, NO_PERMISSION_REQUIRED, etc.


#define RAP_CONVERSION_FACTOR   2               // 16-bit data to 32-bit
#define RAP_CONVERSION_FRACTION 3    // Actually the factor is 2 and 1/3


#endif // ndef _RX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxchdev.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    rxchdev.h

Abstract:

    Prototypes for down-level remoted RxNetCharDev routines

Author:

    Richard Firth (rfirth) 28-May-1991

Revision History:

    28-May-1991 rfirth
        Created

--*/

NET_API_STATUS
RxNetCharDevControl(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  DeviceName,
    IN  DWORD   Opcode
    );

NET_API_STATUS
RxNetCharDevEnum(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    );

NET_API_STATUS
RxNetCharDevGetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  DeviceName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxconfig.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    RxConfig.h

Abstract:

    Prototypes for down-level remoted RxNetConfig routines

Author:

    Richard Firth (rfirth) 28-May-1991

Revision History:

    28-May-1991 RFirth
        Created dummy version of this file.
    23-Oct-1991 JohnRo
        Implement remote NetConfig APIs.
    14-Oct-1992 JohnRo
        RAID 9357: server mgr: can't add to alerts list on downlevel.

--*/

#ifndef _RXCONFIG_
#define _RXCONFIG_

NET_API_STATUS
RxNetConfigGet (
    IN  LPTSTR  server,
    IN  LPTSTR  component,
    IN  LPTSTR  parameter,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS
RxNetConfigGetAll (
    IN  LPTSTR  server,
    IN  LPTSTR  component,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS
RxNetConfigSet (
    IN  LPTSTR  UncServerName,
    IN  LPTSTR  reserved1 OPTIONAL,
    IN  LPTSTR  component,
    IN  DWORD   level,
    IN  DWORD   reserved2,
    IN  LPBYTE  buf,
    IN  DWORD   reserved3
    );

#endif  // _RXCONFIG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxaccess.h ===
/*++

Copyright (c) 1990-1992  Microsoft Corporation

Module Name:

    rxaccess.h

Abstract:

    Prototypes for down-level remoted RxNetAccess routines

Author:

    Richard L Firth (rfirth) 28-May-1991

Revision History:

    28-May-1991 RFirth
        Created
    08-Sep-1992 JohnRo
        Fix NET_API_FUNCTION references.  (NetAccess routines are just #define'd
        as RxNetAccess routines in lmaccess.h, so we need NET_API_FUNCTION here
        too!)

--*/

NET_API_STATUS NET_API_FUNCTION
RxNetAccessAdd(
    IN  LPCWSTR  ServerName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
RxNetAccessCheck(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName,
    IN  LPTSTR  ResourceName,
    IN  DWORD   Operation,
    OUT LPDWORD Result
    );

NET_API_STATUS NET_API_FUNCTION
RxNetAccessDel(
    IN  LPCWSTR  ServerName,
    IN  LPCWSTR  ResourceName
    );

NET_API_STATUS NET_API_FUNCTION
RxNetAccessEnum(
    IN  LPCWSTR  ServerName,
    IN  LPCWSTR  BasePath,
    IN  DWORD   Recursive,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
RxNetAccessGetInfo(
    IN  LPCWSTR  ServerName,
    IN  LPCWSTR  ResourceName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    );

NET_API_STATUS NET_API_FUNCTION
RxNetAccessGetUserPerms(
    IN  LPCWSTR  ServerName,
    IN  LPCWSTR  UserName,
    IN  LPCWSTR  ResourceName,
    OUT LPDWORD Perms
    );

NET_API_STATUS NET_API_FUNCTION
RxNetAccessSetInfo(
    IN  LPCWSTR  ServerName,
    IN  LPCWSTR  ResourceName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxcanon.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rxcanon.h

Abstract:

    Contains prototypes for down-level canonicalization function wrappers

        RxNetpPathType
        RxNetpPathCanonicalize
        RxNetpPathCompare
        RxNetpNameValidate
        RxNetpNameCanonicalize
        RxNetpNameCompare
        RxNetpListCanonicalize

Author:

    Richard L Firth (rfirth) 22-Jan-1992

Revision History:

--*/

NET_API_STATUS
RxNetpPathType(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName,
    OUT LPDWORD PathType,
    IN  DWORD   Flags
    );

NET_API_STATUS
RxNetpPathCanonicalize(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName,
    IN  LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  LPTSTR  Prefix OPTIONAL,
    IN OUT LPDWORD PathType,
    IN  DWORD   Flags
    );

LONG
RxNetpPathCompare(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName1,
    IN  LPTSTR  PathName2,
    IN  DWORD   PathType,
    IN  DWORD   Flags
    );

NET_API_STATUS
RxNetpNameValidate(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

NET_API_STATUS
RxNetpNameCanonicalize(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

LONG
RxNetpNameCompare(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name1,
    IN  LPTSTR  Name2,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

NET_API_STATUS
RxNetpListCanonicalize(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  List,
    IN  LPTSTR  Delimiters,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    OUT LPDWORD OutCount,
    OUT LPDWORD PathTypes,
    IN  DWORD   PathTypesLen,
    IN  DWORD   Flags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxconn.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RxConn.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the remote (downlevel) connection APIs.

Author:

    John Rogers (JohnRo) 16-Jul-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include <windef.h> and <lmcons.h> before this file.

Revision History:

    19-Jul-1991 JohnRo
        Implement downlevel NetConnectionEnum.

--*/


#ifndef _RXCONN_
#define _RXCONN_


NET_API_STATUS
RxNetConnectionEnum (
    IN LPTSTR UncServerName,
    IN LPTSTR Qualifier,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PrefMaxSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    );


#endif // _RXCONN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxerrlog.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RxErrLog.h

Abstract:

    Prototypes for down-level remoted RxNetErrorLog routines.

Author:

    Richard Firth (rfirth) 28-May-1991

Notes:

    You must include <windef.h>, <lmcons.h>, and <lmerrlog.h> before this file.

Revision History:

    28-May-1991 RFirth
        Created dummy version of this file.
    11-Nov-1991 JohnRo
        Implement remote NetErrorLog APIs.
        Created real version of this file.  Added revision history.
    12-Nov-1991 JohnRo
        Added RxpConvertErrorLogArray().

--*/


#ifndef _RXERRLOG_
#define _RXERRLOG_


// API handlers (called by API stubs), in alphabetical order:


NET_API_STATUS
RxNetErrorLogClear (
    IN LPTSTR UncServerName,
    IN LPTSTR BackupFile OPTIONAL,
    IN LPBYTE Reserved OPTIONAL
    );

NET_API_STATUS
RxNetErrorLogRead (
    IN LPTSTR UncServerName,
    IN LPTSTR Reserved1 OPTIONAL,
    IN LPHLOG ErrorLogHandle,
    IN DWORD Offset,
    IN LPDWORD Reserved2 OPTIONAL,
    IN DWORD Reserved3,
    IN DWORD OffsetFlag,
    OUT LPBYTE * BufPtr,
    IN DWORD PrefMaxSize,
    OUT LPDWORD BytesRead,
    OUT LPDWORD TotalBytes
    );

#if 0
NET_API_STATUS
RxNetErrorLogWrite (
    IN LPBYTE Reserved1 OPTIONAL,
    IN DWORD Code,
    IN LPTSTR Component,
    IN LPBYTE Buffer,
    IN DWORD NumBytes,
    IN LPBYTE MsgBuf,
    IN DWORD StrCount,
    IN LPBYTE Reserved2 OPTIONAL
    );
#endif // 0


// Private routine(s), in alphabetical order:

NET_API_STATUS
RxpConvertErrorLogArray(
    IN LPVOID InputArray,
    IN DWORD InputByteCount,
    OUT LPBYTE * OutputArrayPtr, // will be alloc'ed (free w/ NetApiBufferFree).
    OUT LPDWORD OutputByteCountPtr
    );

#endif // _RXERRLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxgroup.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    rxgroup.h

Abstract:

    Prototypes for down-level remoted RxNetGroup routines

Author:

    Richard L Firth (rfirth) 28-May-1991

Revision History:

    28-May-1991 rfirth
        Created

--*/

NET_API_STATUS
RxNetGroupAdd(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    );

NET_API_STATUS
RxNetGroupAddUser(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  GroupName,
    IN  LPTSTR  UserName
    );

NET_API_STATUS
RxNetGroupDel(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  GroupName
    );

NET_API_STATUS
RxNetGroupDelUser(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  GroupName,
    IN  LPTSTR  UserName
    );

NET_API_STATUS
RxNetGroupEnum(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT PDWORD_PTR ResumeHandle OPTIONAL
    );

NET_API_STATUS
RxNetGroupGetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  GroupName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    );

NET_API_STATUS
RxNetGroupGetUsers(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  GroupName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT PDWORD_PTR ResumeHandle OPTIONAL
    );

NET_API_STATUS
RxNetGroupSetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  GroupName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    );

NET_API_STATUS
RxNetGroupSetUsers(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  GroupName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    IN  DWORD   Entries
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxlgenum.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    rxlgenum.h

Abstract:

    Prototypes for down-level remoted RxNetLogonEnum routines

Author:

    Richard Firth (rfirth) 28-May-1991

Revision History:

    28-May-1991 RFirth
        Created

--*/

NET_API_STATUS
RxNetLogonEnum(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   BufLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxdomain.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RxDomain.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the remote (downlevel) domain APIs.

Author:

    John Rogers (JohnRo) 16-Jul-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include <windef.h> and <lmcons.h> before this file.

Revision History:

    16-Jul-1991 JohnRo
        Implement downlevel NetGetDCName.

--*/

//
// User Class
//

#ifndef _RXDOMAIN_
#define _RXDOMAIN_


NET_API_STATUS
RxNetGetDCName (
    IN LPTSTR UncServerName,
    IN LPTSTR DomainName OPTIONAL,
    OUT LPBYTE *BufPtr
    );

NET_API_STATUS
RxNetLogonEnum (
    IN LPTSTR UncServerName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PrefMaxSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    );

#endif // _RXDOMAIN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxmsg.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    rxmsg.h

Abstract:

    Prototypes for down-level remoted RxNetMessage routines

Author:

    Richard Firth (rfirth) 28-May-1991

Revision History:

    28-May-1991 RFirth
        Created

--*/

NET_API_STATUS
RxNetMessageBufferSend(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Recipient,
    IN  LPTSTR  Sender OPTIONAL,
    IN  LPBYTE  Buffer,
    IN  DWORD   BufLen
    );

NET_API_STATUS
RxNetMessageNameAdd(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  MessageName
    );

NET_API_STATUS
RxNetMessageNameDel(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  MessageName
    );

NET_API_STATUS
RxNetMessageNameEnum(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    );

NET_API_STATUS
RxNetMessageNameGetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  MessageName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxfile.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RxFile.h

Abstract:

    This header file contains prototypes for the RpcXlate versions of the
    NetFile APIs.

Author:

    John Rogers (JohnRo) 20-Aug-1991

Environment:

    User Mode - Win32

Notes:

    You must include <windef.h> and <lmcons.h> before this file.

Revision History:

    20-Aug-1991 JohnRo
        Created.

--*/

#ifndef _RXFILE_
#define _RXFILE_

NET_API_STATUS
RxNetFileClose (
    IN LPTSTR UncServerName,
    IN DWORD FileId
    );

NET_API_STATUS
RxNetFileEnum (
    IN LPTSTR UncServerName,
    IN LPTSTR BasePath OPTIONAL,
    IN LPTSTR UserName OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PrefMaxSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT PDWORD_PTR  ResumeHandle OPTIONAL
    );

NET_API_STATUS
RxNetFileGetInfo (
    IN LPTSTR UncServerName,
    IN DWORD FileId,
    IN DWORD Level,
    OUT LPBYTE *BufPtr
    );

#endif // _RXFILE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxremutl.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RxRemUtl.h

Abstract:

    This file contains types and prototypes for RpcXlate (Rx) remote utility
    APIs.

Author:

    John Rogers (JohnRo) 03-Apr-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include <windef.h> and <lmcons.h> before this file.

Revision History:

    03-Apr-1991 JohnRo
        Created.
    10-Apr-1991 JohnRo
        Use transitional Unicode types.
    16-Apr-1991 JohnRo
        Don't include windef.h and lmcons.h directly, to avoid conflicts with
        MIDL-generated code.
    03-May-1991 JohnRo
        Don't use NET_API_FUNCTION for non-APIs.

--*/

#ifndef _RXREMUTL_
#define _RXREMUTL_



////////////////////////////////////////////////////////////////
// Individual routines, for APIs which can't be table driven: //
////////////////////////////////////////////////////////////////

// Add prototypes for other APIs here, in alphabetical order.

NET_API_STATUS
RxNetRemoteTOD (
    IN LPTSTR UncServerName,
    OUT LPBYTE *BufPtr
    );

#endif // ndef _RXREMUTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxpdebug.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RxpDebug.h

Abstract:

    This is a private header file for the NT version of RpcXlate.
    This file contains equates and related items for debugging use only.

Author:

    John Rogers (JohnRo) 17-Jul-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    30-Jul-1991 JohnRo
        Implement downlevel NetWksta APIs.
    21-Aug-1991 JohnRo
        Downlevel NetFile APIs.
    10-Sep-1991 JohnRo
        Downlevel NetService APIs.  Deleted unused DEBUG equate.
    15-Oct-1991 JohnRo
        Implement remote NetSession APIs.
    22-Oct-1991 JohnRo
        Implement remote NetConfig APIs.
    05-Nov-1991 JohnRo
        Implement remote NetAudit APIs.
    12-Nov-1991 JohnRo
        Implement remote NetErrorLog APIs.

--*/

#ifndef _RXPDEBUG_
#define _RXPDEBUG_


#include <windef.h>             // DWORD, FALSE, TRUE, etc.


//
// Debug trace level bits for RxCommon routines:
//

// RxpConvertArgs:
#define RPCXLATE_DEBUG_CONVARGS 0x00000001

// RxpConvertBlock:
#define RPCXLATE_DEBUG_CONVBLK  0x00000002

// RxpConvertDataStructures:
#define RPCXLATE_DEBUG_CONVDATA 0x00000004

// RxpPackSendBuffer:
#define RPCXLATE_DEBUG_PACK     0x00000010

// RxpReceiveBufferConvert:
#define RPCXLATE_DEBUG_RCVCONV  0x00000020

// RxRemoteApi:
#define RPCXLATE_DEBUG_REMOTE   0x00000040

// RxpComputeRequestBufferSize:
#define RPCXLATE_DEBUG_REQSIZE  0x00000100

// RxpSetField:
#define RPCXLATE_DEBUG_SETFIELD 0x00000800

// RxpStartBuildingTransaction:
#define RPCXLATE_DEBUG_START    0x00001000

// RxpTransactSmb:
#define RPCXLATE_DEBUG_TRANSACT 0x00008000

//
// Debug trace level bits for RxApi routines:
//

// RxpNetAudit APIs:
#define RPCXLATE_DEBUG_AUDIT    0x00010000

// RxpNetConfig APIs:
#define RPCXLATE_DEBUG_CONFIG   0x00020000

// Domain APIs (RxNetGetDCName, RxNetLogonEnum):
#define RPCXLATE_DEBUG_DOMAIN   0x00040000

// RxNetErrorLog APIs:
#define RPCXLATE_DEBUG_ERRLOG   0x00080000

// RxNetFile APIs:
#define RPCXLATE_DEBUG_FILE     0x00100000

// RxNetPrintJob APIs:
#define RPCXLATE_DEBUG_PRTJOB   0x00200000

// RxNetPrintQ APIs:
#define RPCXLATE_DEBUG_PRTQ     0x00400000

// RxNetRemote APIs:
#define RPCXLATE_DEBUG_REMUTL   0x01000000

// RxNetServer APIs:
#define RPCXLATE_DEBUG_SERVER   0x02000000

// RxNetService APIs:
#define RPCXLATE_DEBUG_SERVICE  0x04000000

// RxNetSession APIs:
#define RPCXLATE_DEBUG_SESSION  0x08000000

// RxNetUse APIs:
#define RPCXLATE_DEBUG_USE      0x10000000

// RxNetWksta APIs:
#define RPCXLATE_DEBUG_WKSTA    0x40000000

//
// All debug flags on:
//
#define RPCXLATE_DEBUG_ALL      0xFFFFFFFF


#if DBG

extern DWORD RxpTrace;

#define IF_DEBUG(Function) if (RxpTrace & RPCXLATE_DEBUG_ ## Function)

#else

#define IF_DEBUG(Function) if (FALSE)

#endif // DBG


#endif // ndef _RXPDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxsess.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RxSess.h

Abstract:

    Prototypes for down-level remoted RxNetSession routines

Author:

    Richard Firth (rfirth) 28-May-1991

Notes:

    <lmshare.h> must be included before this file.

Revision History:

    28-May-1991 RFirth
        Created dummy file.
    17-Oct-1991 JohnRo
        Implement remote NetSession APIs.
    20-Nov-1991 JohnRo
        NetSessionGetInfo requires UncClientName and UserName.

--*/

#ifndef _RXSESS_
#define _RXSESS_


//
// Routines called by the DLL stubs:
//

NET_API_STATUS
RxNetSessionEnum (
    IN  LPTSTR      servername,
    IN  LPTSTR      clientname OPTIONAL,
    IN  LPTSTR      username OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS
RxNetSessionDel (
    IN  LPTSTR      servername,
    IN  LPTSTR      clientname,
    IN  LPTSTR      username
    );

NET_API_STATUS
RxNetSessionGetInfo (
    IN  LPTSTR      servername,
    IN  LPTSTR      UncClientName,
    IN  LPTSTR      UserName,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr
    );

//
// Private helpers for the above routines:
//

// Note that code in RxpConvertSessionInfo depends on these values:
#define SESSION_SUPERSET_LEVEL          2
#define SESSION_SUPERSET_INFO           SESSION_INFO_2
#define LPSESSION_SUPERSET_INFO         LPSESSION_INFO_2

VOID
RxpConvertSessionInfo (
    IN LPSESSION_SUPERSET_INFO InStructure,
    IN DWORD LevelWanted,
    OUT LPVOID OutStructure,
    IN LPVOID OutFixedDataEnd,
    IN OUT LPTSTR *StringLocation
    );

NET_API_STATUS
RxpCopyAndConvertSessions(
    IN LPSESSION_SUPERSET_INFO InStructureArray,
    IN DWORD InEntryCount,
    IN DWORD LevelWanted,
    IN LPTSTR ClientName OPTIONAL,
    IN LPTSTR UserName OPTIONAL,
    OUT LPVOID * OutStructureArrayPtr,  // alloc'ed (NULL if no match)
    OUT LPDWORD OutEntryCountPtr OPTIONAL  // 0 if no match.
    );

BOOL
RxpSessionMatches (
    IN LPSESSION_SUPERSET_INFO Candidate,
    IN LPTSTR ClientName OPTIONAL,
    IN LPTSTR UserName OPTIONAL
    );

//
// NET_API_STATUS
// RxpSessionMissingErrorCode(
//     IN LPTSTR ClientName OPTIONAL,
//     IN LPTSTR UserName OPTIONAL
//     );
//
#define RxpSessionMissingErrorCode( ClientName, UserName ) \
        ( ((UserName) != NULL) \
            ? NERR_UserNotFound \
            : ( ((ClientName) != NULL)  \
                ? NERR_ClientNameNotFound \
                : NERR_Success ) )

#endif // _RXSESS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxshare.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    rxshare.h

Abstract:

    Prototypes for RxNetShare remote down-level APIs

Author:

    Richard L Firth (rfirth) 28-May-1991

Revision History:

    28-May-1991 RFirth
        Created

--*/

NET_API_STATUS
RxNetShareAdd(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    );

NET_API_STATUS
RxNetShareCheck(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  DeviceName,
    OUT LPDWORD Type
    );

NET_API_STATUS
RxNetShareDel(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  NetName,
    IN  DWORD   Reserved
    );

NET_API_STATUS
RxNetShareEnum(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    );

NET_API_STATUS
RxNetShareGetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  NetName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    );

NET_API_STATUS
RxNetShareSetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  NetName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxstats.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    rxstats.h

Abstract:

    Prototypes for down-level remoted RxNetStatistics routines

Author:

    Richard L Firth (rfirth) 28-May-1991

Revision History:

    28-May-1991 rfirth
        Created

--*/

NET_API_STATUS
RxNetStatisticsGet(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  ServiceName,
    IN  DWORD   Level,
    IN  DWORD   Options,
    OUT LPBYTE* Buffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxsvc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RxSvc.h

Abstract:

    This header file contains prototypes for the RpcXlate versions of the
    NetService APIs.

Author:

    John Rogers (JohnRo) 10-Sep-1991

Environment:

    User Mode - Win32

Notes:

    You must include <windef.h> and <lmcons.h> before this file.

Revision History:

    10-Sep-1991 JohnRo
        Downlevel NetService APIs.

--*/

#ifndef _RXSVC_
#define _RXSVC_


NET_API_STATUS
RxNetServiceControl (
    IN LPTSTR UncServerName,
    IN LPTSTR Service,
    IN DWORD OpCode,
    IN DWORD Arg,
    OUT LPBYTE *BufPtr
    );

NET_API_STATUS
RxNetServiceEnum (
    IN LPTSTR UncServerName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PrefMaxSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    );

NET_API_STATUS
RxNetServiceGetInfo (
    IN LPTSTR UncServerName,
    IN LPTSTR Service,
    IN DWORD Level,
    OUT LPBYTE *BufPtr
    );

NET_API_STATUS
RxNetServiceInstall (
    IN LPTSTR UncServerName,
    IN LPTSTR Service,
    IN DWORD Argc,
    IN LPTSTR Argv[],
    OUT LPBYTE *BufPtr
    );


#endif // _RXSVC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxuse.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RxUse.h

Abstract:

    This is the public header file for the NT version of RpcXlate.
    This mainly contains prototypes for the RxNetUse routines.

Author:

    John Rogers (JohnRo) 17-Jun-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include <windef.h> and <lmcons.h> before this file.

Revision History:

    17-Jun-1991 JohnRo
        Created.
    18-Jun-1991 JohnRo
        Changed RxNetUse routines to use LPBYTE rather than LPVOID parameters,
        for consistency with NetUse routines.

--*/

#ifndef _RXUSE_
#define _RXUSE_



////////////////////////////////////////////////////////////////
// Individual routines, for APIs which can't be table driven: //
////////////////////////////////////////////////////////////////

// Add prototypes for other APIs here, in alphabetical order.

NET_API_STATUS
RxNetUseAdd (
    IN LPTSTR UncServerName,
    IN DWORD Level,
    IN LPBYTE UseInfoStruct,
    OUT LPDWORD ParmError OPTIONAL
    );

NET_API_STATUS
RxNetUseDel (
    IN LPTSTR UncServerName,
    IN LPTSTR UseName,
    IN DWORD ForceCond
    );

NET_API_STATUS
RxNetUseEnum (
    IN LPTSTR UncServerName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PreferedMaximumLength,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    );

NET_API_STATUS
RxNetUseGetInfo (
    IN LPTSTR UncServerName,
    IN LPTSTR UseName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr
    );

#endif // ndef _RXUSE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\rxwksta.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RxWksta.h

Abstract:

    This is the public header file for the NT version of RpcXlate.
    This mainly contains prototypes for the RxNetWksta routines.

Author:

    John Rogers (JohnRo) 17-Jun-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include <windef.h> and <lmcons.h> before this file.

Revision History:

    29-Jul-1991 JohnRo
        Implement downlevel NetWksta APIs.
    31-Jul-1991 JohnRo
        Added RxpGetWkstaInfoLevelEquivalent().
    11-Nov-1991 JohnRo
        Implement remote NetWkstaUserEnum().

--*/

#ifndef _RXWKSTA_
#define _RXWKSTA_


//
// Routines to be called from the DLL stubs:
//

NET_API_STATUS
RxNetWkstaGetInfo (
    IN LPTSTR UncServerName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr
    );

NET_API_STATUS
RxNetWkstaSetInfo (
    IN LPTSTR UncServerName,
    IN DWORD Level,
    IN LPBYTE Buffer,
    OUT LPDWORD ParmError OPTIONAL
    );

NET_API_STATUS
RxNetWkstaUserEnum (
    IN LPTSTR UncServerName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PrefMaxSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    );

//
// Private routines (only called by the above):
//

NET_API_STATUS
RxpGetWkstaInfoLevelEquivalent(
    IN DWORD FromLevel,
    OUT LPDWORD ToLevel,
    OUT LPBOOL IncompleteOutput OPTIONAL  // incomplete (except platform ID)
    );

NET_API_STATUS
RxpWkstaGetOldInfo (
    IN LPTSTR UncServerName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr
    );


#endif // ndef _RXWKSTA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\strucinf.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    StrucInf.h

Abstract:

    This is the header file for routines which return information about
    a given info level for a given category of API.

Author:

    John Rogers (JohnRo) 31-Jul-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include <windef.h>, <lmcons.h>, and <rap.h> before this file.

Revision History:

    31-Jul-1991 JohnRo
        Implement downlevel NetWksta APIs.
    20-Aug-1991 JohnRo
        Downlevel NetFile APIs.
    07-Sep-1991 JohnRo
        Downlevel NetService APIs.
    15-Oct-1991 JohnRo
        Implement remote NetSession APIs.
    07-Jan-1992 JohnRo
        Added replicator structures.
    06-Apr-1992 JohnRo
        Added alert structures.
    03-Jun-1992 JohnRo
        RAID 10324: net print vs. UNICODE.

--*/

#ifndef _STRUCINF_
#define _STRUCINF_


#include <rap.h>        // LPDESC.


// Each of these routines returns ERROR_INVALID_LEVEL or NO_ERROR.
// (Except NetpAlertStructureInfo, which returns NERR_NoSuchAlert or NO_ERROR.)

NET_API_STATUS
NetpAlertStructureInfo(
    IN LPTSTR AlertType,      // ALERT_xxx_EVENT string (see <lmalert.h>).
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL
    );

NET_API_STATUS
NetpFileStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    );

NET_API_STATUS
NetpPrintDestStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    IN BOOL AddOrSetInfoApi,
    IN DWORD CharSize, // size of chars wanted
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    );

NET_API_STATUS
NetpPrintJobStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    IN BOOL SetInfoApi,
    IN DWORD CharSize, // size of chars wanted
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    );

NET_API_STATUS
NetpPrintQStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    IN BOOL AddOrSetInfoApi,
    IN DWORD CharSize, // size of chars wanted
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDESC * AuxDesc16 OPTIONAL,
    OUT LPDESC * AuxDesc32 OPTIONAL,
    OUT LPDESC * AuxDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    );

NET_API_STATUS
NetpReplDirStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    );

NET_API_STATUS
NetpReplExportDirStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    );

NET_API_STATUS
NetpReplImportDirStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    );

NET_API_STATUS
NetpServiceStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    );

NET_API_STATUS
NetpSessionStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    );

NET_API_STATUS
NetpWkstaStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    );

#endif // ndef _STRUCINF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\thread.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Thread.h

Abstract:

    This module defines private types and macros for use in implementing
    a portable thread ID interface.

Author:

    John Rogers (JohnRo) 14-Jan-1992

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    14-Jan-1992 JohnRo
        Moved thread ID stuff into its own header file (for repl and
        netlock use).

--*/

#ifndef _THREAD_
#define _THREAD_


typedef DWORD_PTR NET_THREAD_ID;


#define FORMAT_NET_THREAD_ID    "0x%p"


NET_THREAD_ID
NetpCurrentThread(
    VOID
    );


#endif // ndef _THREAD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\timelib.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    timelib.h

Abstract:

    Include file for netlib time routines

Author:

    Dan Hinsley (danhi) 8-Jun-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

Revision History:

    29-Aug-1991     beng
        Renamed to "netlib0.h" to avoid collision with net\inc\netlib.h

    29-Oct-1991     danhi
        Moved from net\netcmd\map32\netlib0.h
    16-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
    01-Oct-1992 JohnRo
        RAID 3556: Added NetpSystemTimeToGmtTime() for DosPrint APIs.
    10-Jun-1993 JohnRo
        RAID 13080: Allow repl between different timezones.


--*/


#ifndef _TIMELIB_
#define _TIMELIB_


#ifdef NT_INCLUDED
#include <nturtl.h>
#endif


#include <time.h>
#include <winbase.h>    // LPSYSTEMTIME.
#include <lmcons.h>     // NET_API_STATUS.


int    net_gmtime(time_t * timp, struct tm *tb);
DWORD  time_now(VOID);

#define MAX_DATE_TIME_LEN       128


VOID
NetpGmtTimeToLocalTime(
    IN DWORD GmtTime,           // seconds since 1970 (GMT), or 0, or -1.
    OUT LPDWORD LocalTime       // seconds since 1970 (local), or, or -1.
    );


VOID
NetpLocalTimeToGmtTime(
    IN DWORD LocalTime,         // seconds since 1970 (local), or 0, or -1.
    OUT LPDWORD GmtTime         // seconds since 1970 (GMT), or 0, or -1.
    );


LONG
NetpLocalTimeZoneOffset(
    VOID
    );


NET_API_STATUS
NetpSystemTimeToGmtTime(
    IN LPSYSTEMTIME TimeStructure,
    OUT LPDWORD GmtTime         // seconds since 1970 (GMT).
    );

//
// Functions for getting the user - specific time format.
//
#define MAX_TIME_SIZE   80

typedef struct _NET_TIME_FORMAT {
    LPSTR       AMString;           // May be NULL if we couldn't allocate
    LPSTR       PMString;           // May be NULL if we couldn't allocate
    BOOL        TwelveHour;
    BOOL	    TimePrefix;         // For new time prefix
    BOOL        LeadingZero;
    LPSTR       DateFormat;         // May be NULL if we couldn't allocate
    LPSTR       TimeSeparator;      // May be NULL if we couldn't allocate
} NET_TIME_FORMAT, *LPNET_TIME_FORMAT;

VOID
NetpGetTimeFormat(
    LPNET_TIME_FORMAT   TimeFormat
    );


#endif // _TIMELIB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\messages\makefile.inc ===
$(O)\netmsg.mc: $(SDK_INC_PATH)\lmsvc.h \
           $(SDK_INC_PATH)\lmerr.h \
           $(SDK_INC_PATH)\lmerrlog.h \
           $(BASE_INC_PATH)\alertmsg.h \
           $(NET_INC_PATH)\msgtext.h \
           $(DS_INC_PATH)\apperr.h \
           $(DS_INC_PATH)\apperr2.h
    mapmsg NET NERR_BASE $(SDK_INC_PATH)\lmerr.h > $@
    mapmsg -a $@ NET ALERT_BASE $(BASE_INC_PATH)\alertmsg.h
    mapmsg -a $@ NET ALERT2_BASE $(BASE_INC_PATH)\alertmsg.h
    mapmsg -a $@ NET SERVICE_BASE $(SDK_INC_PATH)\lmsvc.h
    mapmsg -a $@ NET ERRLOG_BASE $(SDK_INC_PATH)\lmerrlog.h
    mapmsg -a $@ NET MTXT_BASE $(NET_INC_PATH)\msgtext.h
    mapmsg -a $@ NET APPERR_BASE $(DS_INC_PATH)\apperr.h
    mapmsg -a $@ NET APPERR2_BASE $(DS_INC_PATH)\apperr2.h
    mapmsg -a $@ NET NRCERR_BASE ..\inc\ncberr.h
    mapmsg -a $@ NET ERRLOG2_BASE $(SDK_INC_PATH)\lmerrlog.h
    mapmsg -a $@ NET SERVICE2_BASE $(SDK_INC_PATH)\lmsvc.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\token.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    token.h

Abstract:

    Flags and prototypes for GetToken.C

Author:

    Danny Glasser (dannygl) June 1989

Revision History:

    02 May 1991 rfirth
        32-bit version

--*/

//
// Non-component types: bits 0 through 2
//

#define TOKEN_TYPE_EOS              0x00000001L     // '\0'
#define TOKEN_TYPE_SLASH            0x00000002L     // '/' or '\\'
#define TOKEN_TYPE_COLON            0x00000004L     // ':'

//
// Component-based types: bits 31 through 11
//

#define TOKEN_TYPE_COMPONENT        0x80000000L     // path component
#define TOKEN_TYPE_WILDCARD         0x40000000L     // '?' and/or '*'
#define TOKEN_TYPE_WILDONE          0x20000000L     // "*"
#define TOKEN_TYPE_DOT              0x10000000L     // "."
#define TOKEN_TYPE_DOTDOT           0x08000000L     // ".."
#define TOKEN_TYPE_DRIVE            0x04000000L     // [A-Za-z]
#define TOKEN_TYPE_COMPUTERNAME     0x02000000L     // computername
#define TOKEN_TYPE_LPT              0x01000000L     // LPT[1-9]
#define TOKEN_TYPE_COM              0x00800000L     // COM[1-9]
#define TOKEN_TYPE_AUX              0x00400000L
#define TOKEN_TYPE_PRN              0x00200000L
#define TOKEN_TYPE_CON              0x00100000L
#define TOKEN_TYPE_NUL              0x00080000L
#define TOKEN_TYPE_DEV              0x00040000L
#define TOKEN_TYPE_SEM              0x00020000L
#define TOKEN_TYPE_SHAREMEM         0x00010000L
#define TOKEN_TYPE_QUEUES           0x00008000L
#define TOKEN_TYPE_PIPE             0x00004000L
#define TOKEN_TYPE_MAILSLOT         0x00002000L
#define TOKEN_TYPE_COMM             0x00001000L
#define TOKEN_TYPE_PRINT            0x00000800L

//
// Undefined types: bits 3 through 10
//

#define TOKEN_TYPE_UNDEFINED        0x000007F8L

//
// Useful combinations
//

#define TOKEN_TYPE_SYSNAME  (TOKEN_TYPE_SEM | TOKEN_TYPE_SHAREMEM \
                 | TOKEN_TYPE_QUEUES | TOKEN_TYPE_PIPE \
                 | TOKEN_TYPE_COMM | TOKEN_TYPE_PRINT)

#define TOKEN_TYPE_LOCALDEVICE  (TOKEN_TYPE_LPT | TOKEN_TYPE_COM \
                 | TOKEN_TYPE_AUX | TOKEN_TYPE_PRN \
                 | TOKEN_TYPE_CON | TOKEN_TYPE_NUL)

extern
DWORD
GetToken(
        LPTSTR  pszBegin,
        LPTSTR* ppszEnd,
        LPDWORD pflTokenType,
        DWORD   flFlags
        );

//
// Flags for GetToken()
//

#define GTF_8_DOT_3 0x00000001L

#define GTF_RESERVED    (~(GTF_8_DOT_3))

//
// IMPORTANT -  These variables are defined in the NETAPI.DLL global
//              data segment under OS/2.  Under DOS we need to define
//              them here.
//

#ifdef DOS3
extern USHORT   cbMaxPathLen;
extern USHORT   cbMaxPathCompLen;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\win16nt.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    win16nt.h

Abstract:

    This file contains data types for 16 bit windows on DOS that are not 
    included in windows.h, but are required for NT.

Author:

    Dan Lafferty (danl)     27-Sept-1991

Environment:

    User Mode -Win16

Revision History:

    27-Sept-1991     danl
        created

--*/

#ifndef _WIN16NT_
#define _WIN16NT_

//typedef DWORD SECURITY_DESCRIPTOR, *PSECURITY_DESCRIPTOR;
//typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;

typedef void *PVOID;

typedef PVOID PSID;
typedef unsigned short WCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef WCHAR *LPWSTR, *PWSTR;
typedef char   TCHAR;
typedef TCHAR   *LPTSTR;

typedef unsigned char UCHAR;
typedef UCHAR * PUCHAR; 
typedef unsigned short USHORT;
typedef USHORT  *PUSHORT;
typedef DWORD   ULONG;
typedef ULONG *PULONG;

//--------------------------------
// some NT stuff (from ntdef.h)
//

typedef char CHAR;
typedef CHAR *PCHAR;
typedef DWORD    NTSTATUS;
typedef NTSTATUS *PNTSTATUS;

typedef char CCHAR;
typedef CCHAR BOOLEAN;
typedef BOOLEAN *PBOOLEAN;

typedef struct _LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;

typedef LARGE_INTEGER LUID;

typedef LUID *PLUID;

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY 1
#endif

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} STRING;
typedef STRING *PSTRING;


//--------------------------------
//
//
typedef DWORD   NET_API_STATUS;

//typedef USHORT SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;

#define NET_API_FUNCTION

//**************************************************************************
// The following come from ntelfapi.h. and also exist in winnt.h (which is
// built from ntelfapi.h.  We need the same constants, but without the
// 32 bit windows stuff and without the nt stuff.  
// Perhaps this file should be built by gathering all this information from
// other files.
//
//
// Defines for the READ flags for Eventlogging
//
#define EVENTLOG_SEQUENTIAL_READ	0X0001
#define EVENTLOG_SEEK_READ		    0X0002
#define EVENTLOG_FORWARDS_READ		0X0004
#define EVENTLOG_BACKWARDS_READ		0X0008

//
// The types of events that can be logged.
//
#define EVENTLOG_ERROR_TYPE		0x0001
#define EVENTLOG_WARNING_TYPE		0x0002
#define EVENTLOG_INFORMATION_TYPE	0x0003

//**************************************************************************

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef IN
#define IN
#endif 

#ifndef OUT
#define OUT
#endif


#endif //_WIN16NT_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\traceapi.h ===
/*
 *===================================================================
 * Copyright (c) 1995, Microsoft Corporation
 *
 * File:    traceapi.h
 *
 * History:
 *      t-abolag    6-June-1995     created
 *
 * API functions exported by Trace DLL
 *===================================================================
 */

#ifndef _TRACEAPI_H_
#define _TRACEAPI_H_

DWORD FAR PASCAL TraceRegister(LPCSTR lpszService);

VOID FAR PASCAL  TraceDeregister(DWORD dwID);

VOID FAR PASCAL  TracePrintf(DWORD dwID,
                             LPCSTR lpszFormat,
                             ...);

VOID FAR PASCAL  TraceVprintf(DWORD dwID,
                              LPCSTR lpszFormat,
                              va_list arglist);

#endif /* _TRACEAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\argvw.c ===
/***
*argvw.c - create Unicode version of argv arguments
*
*       Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       processes program command line
*
*Revision History:
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <wchar.h>


/***
*void Parse_Cmdline(cmdstart, argv, lpstr, numargs, numbytes)
*
*Purpose:
*       Parses the command line and sets up the Unicode argv[] array.
*       On entry, cmdstart should point to the command line,
*       argv should point to memory for the argv array, lpstr
*       points to memory to place the text of the arguments.
*       If these are NULL, then no storing (only counting)
*       is done.  On exit, *numargs has the number of
*       arguments (plus one for a final NULL argument),
*       and *numbytes has the number of bytes used in the buffer
*       pointed to by args.
*
*Entry:
*       LPWSTR cmdstart - pointer to command line of the form
*           <progname><nul><args><nul>
*       TCHAR **argv - where to build argv array; NULL means don't
*                      build array
*       LPWSTR lpstr - where to place argument text; NULL means don't
*                      store text
*
*Exit:
*       no return value
*       INT *numargs - returns number of argv entries created
*       INT *numbytes - number of bytes used in args buffer
*
*Exceptions:
*
*******************************************************************************/

void Parse_Cmdline (
    LPWSTR cmdstart,
    LPWSTR*argv,
    LPWSTR lpstr,
    INT *numargs,
    INT *numbytes
    )
{
    LPWSTR p;
    WCHAR c;
    INT inquote;                    /* 1 = inside quotes */
    INT copychar;                   /* 1 = copy char to *args */
    WORD numslash;                  /* num of backslashes seen */

    *numbytes = 0;
    *numargs = 1;                   /* the program name at least */

    /* first scan the program name, copy it, and count the bytes */
    p = cmdstart;
    if (argv)
        *argv++ = lpstr;

    /* A quoted program name is handled here. The handling is much
       simpler than for other arguments. Basically, whatever lies
       between the leading double-quote and next one, or a terminal null
       character is simply accepted. Fancier handling is not required
       because the program name must be a legal NTFS/HPFS file name.
       Note that the double-quote characters are not copied, nor do they
       contribute to numbytes. */
    if (*p == TEXT('\"'))
    {
        /* scan from just past the first double-quote through the next
           double-quote, or up to a null, whichever comes first */
        while ((*(++p) != TEXT('\"')) && (*p != TEXT('\0')))
        {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;
        }
        /* append the terminating null */
        *numbytes += sizeof(WCHAR);
        if (lpstr)
            *lpstr++ = TEXT('\0');

        /* if we stopped on a double-quote (usual case), skip over it */
        if (*p == TEXT('\"'))
            p++;
    }
    else
    {
        /* Not a quoted program name */
        do {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;

            c = (WCHAR) *p++;

        } while (c > TEXT(' '));

        if (c == TEXT('\0'))
        {
            p--;
        }
        else
        {
            if (lpstr)
                *(lpstr - 1) = TEXT('\0');
        }
    }

    inquote = 0;

    /* loop on each argument */
    for ( ; ; )
    {
        if (*p)
        {
            while (*p == TEXT(' ') || *p == TEXT('\t'))
                ++p;
        }

        if (*p == TEXT('\0'))
            break;                  /* end of args */

        /* scan an argument */
        if (argv)
            *argv++ = lpstr;         /* store ptr to arg */
        ++*numargs;

        /* loop through scanning one argument */
        for ( ; ; )
        {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
                      2N+1 backslashes + " ==> N backslashes + literal "
                      N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == TEXT('\\'))
            {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == TEXT('\"'))
            {
                /* if 2N backslashes before, start/end quote, otherwise
                   copy literally */
                if (numslash % 2 == 0)
                {
                    if (inquote)
                        if (p[1] == TEXT('\"'))
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--)
            {
                if (lpstr)
                    *lpstr++ = TEXT('\\');
                *numbytes += sizeof(WCHAR);
            }

            /* if at end of arg, break loop */
            if (*p == TEXT('\0') || (!inquote && (*p == TEXT(' ') || *p == TEXT('\t'))))
                break;

            /* copy character into argument */
            if (copychar)
            {
                if (lpstr)
                        *lpstr++ = *p;
                *numbytes += sizeof(WCHAR);
            }
            ++p;
        }

        /* null-terminate the argument */

        if (lpstr)
            *lpstr++ = TEXT('\0');         /* terminate string */
        *numbytes += sizeof(WCHAR);
    }

}


/***
*CommandLineToArgvW - set up Unicode "argv" for C programs
*
*Purpose:
*       Read the command line and create the argv array for C
*       programs.
*
*Entry:
*       Arguments are retrieved from the program command line
*
*Exit:
*       "argv" points to a null-terminated list of pointers to UNICODE
*       strings, each of which is an argument from the command line.
*       The list of pointers is also located on the heap or stack.
*
*Exceptions:
*       Terminates with out of memory error if no memory to allocate.
*
*******************************************************************************/

LPWSTR* CommandLineToArgvW (LPCWSTR lpCmdLine, int*pNumArgs)
{
    LPWSTR*argv_U;
    LPWSTR  cmdstart;                 /* start of command line to parse */
    INT     numbytes;
    WCHAR   pgmname[MAX_PATH];

    if (pNumArgs == NULL) {
	SetLastError(ERROR_INVALID_PARAMETER);
	return NULL;
    }

    /* Get the program name pointer from Win32 Base */

    GetModuleFileName (NULL, pgmname, sizeof(pgmname) / sizeof(WCHAR));

    /* if there's no command line at all (won't happen from cmd.exe, but
       possibly another program), then we use pgmname as the command line
       to parse, so that argv[0] is initialized to the program name */
    cmdstart = (*lpCmdLine == TEXT('\0')) ? pgmname : (LPWSTR) lpCmdLine;

    /* first find out how much space is needed to store args */
    Parse_Cmdline (cmdstart, NULL, NULL, pNumArgs, &numbytes);

    /* allocate space for argv[] vector and strings */
    argv_U = (LPWSTR*) RtlAllocateHeap(RtlProcessHeap(),0,
		*pNumArgs * sizeof(LPWSTR) + numbytes);
    if (!argv_U) {
	SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return (NULL);
    }

    /* store args and argv ptrs in just allocated block */
    Parse_Cmdline (cmdstart, argv_U,
		   (LPWSTR) (((LPBYTE)argv_U) + *pNumArgs * sizeof(LPWSTR)),
                   pNumArgs, &numbytes);

    return (argv_U);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\inc\win16rtl.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntrtl.h

Abstract:

    Include file for NT runtime routines that are callable by both
    kernel mode code in the executive and user mode code in various
    NT subsystems.

Author:

    Steve Wood (stevewo) 31-Mar-1989

Environment:

    These routines are statically linked in the caller's executable and
    are callable in either kernel mode or user mode.

Revision History:

--*/

#ifndef _NTRTL_
#define _NTRTL_

//#include <win16nt.h>

//*************************************************************************
//
// Types from ntseapi.h

#ifdef remove
#include <ntseapi.h>
#endif //remove


typedef PVOID PSECURITY_DESCRIPTOR;     // winnt

typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;

typedef USHORT SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;

typedef struct _SID_IDENTIFIER_AUTHORITY {
    UCHAR Value[6];
} SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY;

typedef struct _SID_AND_ATTRIBUTES {
    PSID Sid;
    ULONG Attributes;
    } SID_AND_ATTRIBUTES, * PSID_AND_ATTRIBUTES;

typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    ULONG Attributes;
    } LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;


typedef ULONG ACCESS_MASK;      // winnt
typedef ACCESS_MASK *PACCESS_MASK;

typedef struct _GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
typedef GENERIC_MAPPING *PGENERIC_MAPPING;

typedef struct _ACL {
    UCHAR AclRevision;
    UCHAR Sbz1;
    USHORT AclSize;
    USHORT AceCount;
    USHORT Sbz2;
} ACL;
typedef ACL *PACL;

typedef enum _ACL_INFORMATION_CLASS {
    AclRevisionInformation = 1,
    AclSizeInformation
} ACL_INFORMATION_CLASS;


typedef struct _PRIVILEGE_SET {
    ULONG PrivilegeCount;
    ULONG Control;
    LUID_AND_ATTRIBUTES Privilege[ANYSIZE_ARRAY];
    } PRIVILEGE_SET, * PPRIVILEGE_SET;


//
//
//*************************************************************************


//
// Fast primitives to compare, move, and zero memory
//
#ifdef remove

ULONG
RtlCompareMemory (
    IN PVOID Source1,
    IN PVOID Source2,
    IN ULONG Length
    );

VOID
RtlMoveMemory (
   IN PVOID Destination,
   IN PVOID Source,
   IN ULONG Length
   );

VOID
RtlFillMemory (
   IN PVOID Destination,
   IN ULONG Length,
   IN UCHAR Fill
   );

VOID
RtlFillMemoryUlong (
   IN PVOID Destination,
   IN ULONG Length,
   IN ULONG Pattern
   );

VOID
RtlZeroMemory (
   IN PVOID Destination,
   IN ULONG Length
   );

#endif //remove


//
//  Security ID RTL routine definitions
//


BOOLEAN
RtlValidSid (
    IN PSID Sid
    );


BOOLEAN
RtlEqualSid (
    IN PSID Sid1,
    IN PSID Sid2
    );


BOOLEAN
RtlEqualPrefixSid (
    IN PSID Sid1,
    IN PSID Sid2
    );


ULONG
RtlLengthRequiredSid (
    IN ULONG SubAuthorityCount
    );

VOID
RtlInitializeSid (
    IN PSID Sid,
    IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN ULONG SubAuthorityCount
    );

PSID_IDENTIFIER_AUTHORITY
RtlIdentifierAuthoritySid (
    IN PSID Sid
    );

PULONG
RtlSubAuthoritySid (
    IN PSID Sid,
    IN ULONG SubAuthority
    );

PUCHAR
RtlSubAuthorityCountSid (
    IN PSID Sid
    );

ULONG
RtlLengthSid (
    IN PSID Sid
    );


NTSTATUS
RtlCopySid (
    IN ULONG DestinationSidLength,
    OUT PSID DestinationSid,
    IN PSID SourceSid
    );


NTSTATUS
RtlCopySidAndAttributesArray (
    IN ULONG ArrayLength,
    IN PSID_AND_ATTRIBUTES Source,
    IN ULONG TargetSidBufferSize,
    OUT PSID_AND_ATTRIBUTES TargetArrayElement,
    OUT PSID TargetSid,
    OUT PSID *NextTargetSid,
    OUT PULONG RemainingTargetSidSize
    );





//
// LUID RTL routine definitions
//


VOID
RtlCopyLuidAndAttributesArray (
    IN ULONG ArrayLength,
    IN PLUID_AND_ATTRIBUTES Source,
    OUT PLUID_AND_ATTRIBUTES Target
    );



//
//  ACCESS_MASK RTL routine definitions
//


BOOLEAN
RtlAreAllAccessesGranted(
    IN ACCESS_MASK GrantedAccess,
    IN ACCESS_MASK DesiredAccess
    );


BOOLEAN
RtlAreAnyAccessesGranted(
    IN ACCESS_MASK GrantedAccess,
    IN ACCESS_MASK DesiredAccess
    );

VOID
RtlMapGenericMask(
    IN OUT PACCESS_MASK AccessMask,
    IN PGENERIC_MAPPING GenericMapping
    );



//
//  ACL RTL routine definitions
//

BOOLEAN
RtlValidAcl (
    IN PACL Acl
    );

NTSTATUS
RtlCreateAcl (
    IN PACL Acl,
    IN ULONG AclLength,
    IN ULONG AclRevision
    );

NTSTATUS
RtlQueryInformationAcl (
    IN PACL Acl,
    OUT PVOID AclInformation,
    IN ULONG AclInformationLength,
    IN ACL_INFORMATION_CLASS AclInformationClass
    );

NTSTATUS
RtlSetInformationAcl (
    IN PACL Acl,
    IN PVOID AclInformation,
    IN ULONG AclInformationLength,
    IN ACL_INFORMATION_CLASS AclInformationClass
    );

NTSTATUS
RtlAddAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG StartingAceIndex,
    IN PVOID AceList,
    IN ULONG AceListLength
    );

NTSTATUS
RtlDeleteAce (
    IN OUT PACL Acl,
    IN ULONG AceIndex
    );

NTSTATUS
RtlGetAce (
    IN PACL Acl,
    IN ULONG AceIndex,
    OUT PVOID *Ace
    );


NTSTATUS
RtlAddAccessAllowedAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid
    );

NTSTATUS
RtlAddAccessDeniedAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid
    );

NTSTATUS
RtlAddAuditAccessAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid,
    IN BOOLEAN AuditSuccess,
    IN BOOLEAN AuditFailure
    );

BOOLEAN
RtlFirstFreeAce (
    IN PACL Acl,
    OUT PVOID *FirstFree
    );


//
//  SecurityDescriptor RTL routine definitions
//

NTSTATUS
RtlCreateSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Revision
    );


BOOLEAN
RtlValidSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );


ULONG
RtlLengthSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSTATUS
RtlGetControlSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR_CONTROL Control,
    OUT PULONG Revision
    );

NTSTATUS
RtlSetDaclSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOLEAN DaclPresent,
    IN PACL Dacl OPTIONAL,
    IN BOOLEAN DaclDefaulted OPTIONAL
    );


NTSTATUS
RtlGetDaclSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN DaclPresent,
    OUT PACL *Dacl,
    OUT PBOOLEAN DaclDefaulted
    );


NTSTATUS
RtlSetSaclSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOLEAN SaclPresent,
    IN PACL Sacl OPTIONAL,
    IN BOOLEAN SaclDefaulted OPTIONAL
    );


NTSTATUS
RtlGetSaclSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN SaclPresent,
    OUT PACL *Sacl,
    OUT PBOOLEAN SaclDefaulted
    );


NTSTATUS
RtlSetOwnerSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID Owner OPTIONAL,
    IN BOOLEAN OwnerDefaulted OPTIONAL
    );


NTSTATUS
RtlGetOwnerSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSID *Owner,
    OUT PBOOLEAN OwnerDefaulted
    );


NTSTATUS
RtlSetGroupSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID Group OPTIONAL,
    IN BOOLEAN GroupDefaulted OPTIONAL
    );


NTSTATUS
RtlGetGroupSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSID *Group,
    OUT PBOOLEAN GroupDefaulted
    );


NTSTATUS
RtlMakeSelfRelativeSD(
    IN PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    IN OUT PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    IN OUT PULONG BufferLength
    );

NTSTATUS
RtlAbsoluteToSelfRelativeSD(
    IN PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    IN OUT PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    IN OUT PULONG BufferLength
    );

NTSTATUS
RtlSelfRelativeToAbsoluteSD(
    IN OUT PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    IN OUT PULONG AbsoluteSecurityDescriptorSize,
    IN OUT PACL Dacl,
    IN OUT PULONG DaclSize,
    IN OUT PACL Sacl,
    IN OUT PULONG SaclSize,
    IN OUT PSID Owner,
    IN OUT PULONG OwnerSize,
    IN OUT PSID PrimaryGroup,
    IN OUT PULONG PrimaryGroupSize
    );

NTSTATUS
RtlNewSecurityGrantedAccess(
    IN ACCESS_MASK DesiredAccess,
    OUT PPRIVILEGE_SET Privileges,
    IN OUT PULONG Length,
    IN HANDLE Token OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PACCESS_MASK RemainingDesiredAccess
    );

#ifdef remove

typedef struct _MESSAGE_RESOURCE_ENTRY {
    USHORT Length;
    USHORT Reserved;
    UCHAR Text[ 1 ];
} MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY;

typedef struct _MESSAGE_RESOURCE_BLOCK {
    ULONG LowId;
    ULONG HighId;
    ULONG OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK;

typedef struct _MESSAGE_RESOURCE_DATA {
    ULONG NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks[ 1 ];
} MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA;

NTSTATUS
RtlFindMessage(
    IN PVOID DllHandle,
    IN ULONG MessageTableId,
    IN ULONG MessageLanguageId,
    IN ULONG MessageId,
    OUT PMESSAGE_RESOURCE_ENTRY *MessageEntry
    );

#endif //remove


//
// Routine for converting NT status codes to DOS/OS|2 equivalents.
//

ULONG
*RtlNtStatusToDosError (
   IN NTSTATUS Status
    );

#endif  // _NTRTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\lexor.c ===
/********************************************************************/
/**			Microsoft LAN Manager			   **/
/**		  Copyright(c) Microsoft Corp., 1987-1990	   **/
/********************************************************************/


#define INCL_NOCOMMON
#include <os2.h>
#include <stddef.h>
#include <stdio.h>
#include "netcmds.h"
#include "os2incl.h"
#include "os2cmd.h"

/*
 * LEXOR - identify the next input word.
 */
int lexor(register TOKSTACK *t)
{
    extern KEYTAB KeyTab[];
    KEYTAB *p;
    static int index = 0;

#ifdef DEBUG
    WriteToCon( TEXT("LEX (index=%d)  "),index);
#endif

    if ((t->node = ArgList[index]) == NULL)
    {
#ifdef DEBUG
	WriteToCon( TEXT("no more tokens (EOS)\n"));
#endif
	return(t->token = EOS);
    }
    ++index;

#ifdef DEBUG
    WriteToCon( TEXT("token is <%s>   "),t->node);
#endif

    /* see if there is a keyword match */
    for (p = KeyTab; p->text; ++p)
	if (!_tcsicmp(p->text, t->node))
	{
#ifdef DEBUG
	    WriteToCon( TEXT("matches <%s>, value %d\n"),p->text,p->key);
#endif
	    return(t->token = p->key);
	}

    /* no match found */
#ifdef DEBUG
    WriteToCon( TEXT("no match\n"));
#endif
    return(t->token = UNKNOWN);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\interpre.c ===
/********************************************************************/
/**			Microsoft LAN Manager			   **/
/**		  Copyright(c) Microsoft Corp., 1987-1990	   **/
/********************************************************************/

#ifndef DEBUG
#ifndef NDEBUG		// for assert()
#define NDEBUG		// for assert()
#endif
#endif


#define INCL_NOCOMMON
#include <os2.h>
#include <stdio.h>
#include <assert.h>
#include <process.h>
#include "netcmds.h"
#include "interpre.h"
#include <msystem.h>
#include "os2incl.h"
#include "os2cmd.h"

#define STACKSIZE   20
#define RECURSE     10

/*
 * XXSTKCHECK - checks the given expression. if true, then the stack
 * is ok, else stack overflow will occur.
 */
#define xxstkcheck(cond) if(!(cond))xxovfl()

TOKSTACK    *Tokptr, *Tokmax;
TOKSTACK    Tokstack[STACKSIZE];
int	    Condition = FALSE;
int	    S_orstack[INTER_OR * 3 * RECURSE];
XX_USERTYPE S_frstack[INTER_FRAME * RECURSE];

extern TCHAR *xxswitch[];

/* Function Prototypes. */

XX_USERTYPE		xx_parser(int, int *, int);
int			XX_USERLEX(TOKSTACK *);
void			xxinit(void);
void			xxovfl(void);
int			xxnext(void);

int			(*XXulex)(TOKSTACK *) = XX_USERLEX;
int			XXtoken = 0;
XX_USERTYPE		XXnode = 0;

extern	TCHAR	*Rule_strings[];
extern	SHORT	Index_strings[];
/*
**  XX_USERPARSE : this is what the user calls to parse a tree.
*/
XX_USERTYPE XX_USERPARSE(VOID)
    {
    xxinit();
    return(xx_parser(XX_START,S_orstack,0));
    }
/*
**  xx_parser : this is what we call to actually parse the tree
*/
XX_USERTYPE xx_parser(pc,or_ptr,fp)
    register	int	pc;
    register	int	*or_ptr;
    register	int	fp;
    {
    register	int	    type;
    register	TOKSTACK    *ptok;
		int	    *or_start = or_ptr;
		int	    fp_start = fp;

    S_frstack[fp] = (XX_USERTYPE) 1;
    while(1)
	{
#ifdef DEBUG
	WriteToCon(TEXT("Current PC = %3d  value = %4d  type is "),pc,XXvalues[pc]);
#endif
	switch(XXtype[pc])
	    {
	    case X_RULE :
#ifdef DEBUG
		WriteToCon( TEXT("X_RULE\n"));
#endif
		break;
	    case X_OR :
#ifdef DEBUG
		WriteToCon( TEXT("X_OR\n"));
#endif
		type = XXtype[pc + 1];
		/*
		**  before we go through the bother of pushing a backup place,
		**  if the a token or a check and the current token
		**  does not match the value, then immediately update the pc
		**  to have the value of the X_OR.
		**  otherwise, save all the current info.
		*/
		if( ((type == X_TOKEN) || (type == X_CHECK))
		    &&
		    (XXvalues[pc + 1] != (SHORT) XXtoken))
		    {
		    pc = XXvalues[pc];
		    continue;
		    }
		xxstkcheck(or_ptr < &S_orstack[DIMENSION(S_orstack) - 3]);
		*(or_ptr++) = XXvalues[pc];	/*  link to next subsection  */
		*(or_ptr++) = fp;		/*  the current frame ptr  */
		*(or_ptr++) = (int)(Tokptr - Tokstack); /* the Tokstack index */
		break;
	    case X_PROC :
#ifdef DEBUG
		WriteToCon( TEXT("X_PROC\n"));
#endif
		xxstkcheck(fp < (DIMENSION(S_frstack) - 1));
		if( ! (S_frstack[fp] = xx_parser(XXvalues[pc],or_ptr,fp)))
		    {
		    goto backout;
		    }
		fp++;
		break;
	    case X_CHECK :
#ifdef DEBUG
		WriteToCon( TEXT("X_CHECK\n"));
#endif
		if(XXtoken != XXvalues[pc])
		    {
		    goto backout;
		    }
		break;
	    case X_SWITCH :
#ifdef DEBUG
		WriteToCon( TEXT("X_SWITCH\n"));
#endif
		/* if "/anything" was in the grammar, we call this
		 * routine for an implementation defined switch
		 * check, passing the text of the string as an argument.
		 */
		if(!CheckSwitch(xxswitch[XXvalues[pc]]))
		    {
		    goto backout;
		    }
		break;
	    case X_ANY :
#ifdef DEBUG
		WriteToCon( TEXT("X_ANY\n"));
#endif
		/* match anything */
		xxstkcheck(fp < DIMENSION(S_frstack));
		S_frstack[fp++] = XXnode;   /*	must be here, read comment  */
		if (XXtoken == EOS)
		    goto backout;
		else
		    xxnext();
		break;
	    case X_TOKEN :
#ifdef DEBUG
		WriteToCon( TEXT("X_TOKEN\n"));
#endif
		xxstkcheck(fp < DIMENSION(S_frstack));
		/*
		**  we first save the node, then check the token, since
		**  if the tokens match, xxlex will get the next one and we'll
		**  lose the current one of interest.
		*/
		S_frstack[fp++] = XXnode;   /*	must be here, read comment  */
		if(XXvalues[pc] != (SHORT) XXtoken)
		    {
		    goto backout;
		    }
		else
		    xxnext();
		break;
	    case X_CONDIT :
#ifdef DEBUG
		WriteToCon( TEXT("X_CONDIT\n"));
#endif
		if( ! xxcondition(XXvalues[pc], &S_frstack[fp_start]))
		    {
		    goto backout;
		    }
		break;
	    case X_ACTION :
#ifdef DEBUG
		WriteToCon( TEXT("X_ACTION\n"));
#endif
		xxaction(XXvalues[pc],&S_frstack[fp_start]);
		break;
	    case X_ACCEPT :
#ifdef DEBUG
		WriteToCon( TEXT("X_ACCEPT\n"));
#endif
		return(S_frstack[fp_start]);
	    case X_DEFINE :
#ifdef DEBUG
		WriteToCon( TEXT("X_DEFINE\n"));
#endif
		break;
	    /*
	    **case X_PUSH :
#ifdef DEBUG
		WriteToCon( TEXT("X_PUSH\n"));
#endif
	    **	ppush(XXvalues[pc],S_frstack[fp_start]);
	    **	break;
	    */
	    default :
#ifdef DEBUG
		WriteToCon( TEXT("UNKNOWN\n"));
#endif
		assert(FALSE);
		break;
	    }
	pc++;
	continue;

backout:    /*	BACK OUT !!! recover an earlier state */

	if(or_ptr != or_start)
	    {
	    /*
	    **	reset the 'or' stack
	    */
	    Tokptr = ptok = Tokstack + *(--or_ptr);
	    XXtoken = ptok->token;
	    XXnode = ptok->node;
	    fp = *(--or_ptr);
	    pc = *(--or_ptr);
	    }
	else
	    {
	    return((XX_USERTYPE) 0);
	    }
	}
    }
/*
** xxinit - Clear the input stack and get the first token.
**/
VOID
xxinit(VOID)
    {
    register TOKSTACK *ptok;

    /*	fill the first one with a token  */
    Tokmax = Tokptr = ptok = &Tokstack[0];
    (*XXulex)(ptok);
    XXtoken = ptok->token;
    XXnode = ptok->node;
#ifdef DEBUG
    WriteToCon( TEXT("xxinit, new token value is %d\n"),XXtoken);
#endif
    }

/*
** XXOVFL - a common subexpression, used in xxstkcheck macro above
**/
VOID
xxovfl(VOID)
    {
    GenOutput(g_hStdErr, TEXT("PANIC: expression too complex, please simplify;"));
    }

/*
 * XXLEX - If a match occurs, get the next input token and return TRUE.
 * Otherwise return FALSE.  If backup has occured, the token  will be
 * fetched from the token stack.  Otherwise the user routine will be called.
 */
int
xxnext(VOID)
    {
    register TOKSTACK *ptok;

    ptok = ++Tokptr;
    xxstkcheck(ptok < &Tokstack[DIMENSION(Tokstack)]);
    if (ptok > Tokmax)
	{
	(*XXulex)(ptok);
	Tokmax++;
	}

    XXtoken = ptok->token;
    XXnode = ptok->node;
#ifdef DEBUG
    WriteToCon( TEXT("xxnext, new token value is %d\n"),XXtoken);
#endif
    return(1);
    }

#if XX_XACCLEX
XXlex(VOID)
    {
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\help.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/***
 *  help.c
 *      Functions that give access to the text in the file net.hlp
 *
 *  Format of the file net.hlp
 *
 *      History
 *      ??/??/??, stevero, initial code
 *      10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *      01/04/89, erichn, filenames now MAX_PATH LONG
 *      05/02/89, erichn, NLS conversion
 *      06/08/89, erichn, canonicalization sweep
 *      02/20/91, danhi, change to use lm 16/32 mapping layer
 ***/

/* Include files */

#define INCL_ERRORS
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#include <os2.h>
#include <lmcons.h>
#include <apperr.h>
#include <apperr2.h>
#include <lmerr.h>
#include <stdio.h>
#include <malloc.h>
#include "lui.h"
#include "netcmds.h"
#include "msystem.h"


/* Constants */

#define     ENTRY_NOT_FOUND     -1
#define     NEXT_RECORD         0
#define     WHITE_SPACE         TEXT("\t\n\x0B\x0C\r ")

#define     LINE_LEN            82
#define     OPTION_MAX_LEN      512
#define     DELS            TEXT(":,\n")

#define     CNTRL           (text[0] == DOT || text[0] == COLON || text[0] == POUND|| text[0] == DOLLAR)
#define     FCNTRL          (text[0] == DOT || text[0] == COLON)
#define     HEADER          (text[0] == PERCENT || text[0] == DOT || text[0] == BANG)
#define     ALIAS           (text[0] == PERCENT)
#define     ADDCOM          (text[0] == BANG)

/* Static variables */

TCHAR    text[LINE_LEN+1];
TCHAR    *options;           /* must be sure to malloc! */
TCHAR    *Arg_P[10];
FILE     *hfile;


/* Forward declarations */

int    find_entry( int, int, HANDLE, int *);
VOID   print_syntax( HANDLE, int );
VOID   print_help( int );
VOID   print_options( int );
VOID   seek_data( int, int );
LPWSTR skipwtspc( TCHAR FAR * );
LPWSTR fgetsW(LPWSTR buf, int len, FILE *fh);
DWORD  GetHelpFileName(LPTSTR HelpFileName, DWORD BufferLength);
DWORD  GetFileName(LPTSTR FileName, DWORD BufferLength, LPTSTR FilePartName);


/* help_help -
*/
VOID NEAR pascal
help_help( SHORT ali, SHORT amt)
{
    DWORD       err;
    int	        option_level = 1;
    int		r;
    int		found = 0;
    int		out_len = 0;
    int		offset;
    int		arg_cnt;
    int		k;
    SHORT	pind = 0;
    TCHAR	file_path[MAX_PATH];
    TCHAR	str[10];
    TCHAR	*Ap;
    TCHAR	*tmp;
    TCHAR	*stmp;
    TCHAR	*t2;
    HANDLE      outfile;

    if (!(options = malloc(OPTION_MAX_LEN + 1)))
        ErrorExit(ERROR_NOT_ENOUGH_MEMORY);
    *options = NULLC;

    Arg_P[0] = NET_KEYWORD;

    if (amt == USAGE_ONLY)
    {
	outfile = g_hStdErr;
    }
    else
    {
	outfile = g_hStdOut;
    }

    /* use offset to keep base of Arg_P relative to base of ArgList */
    offset = ali;

    /* increment ali in for loop so you can't get an ali of 0 */
    for (arg_cnt = 0; ArgList[ali++]; arg_cnt < 8 ? arg_cnt++ : 0)
    {
	str[arg_cnt] = (TCHAR)ali;
    }

    str[arg_cnt] = NULLC;
    str[arg_cnt+1] = NULLC;  /* just in case the last argument is the first found */


    if (err = GetHelpFileName(file_path, MAX_PATH))
    {
        ErrorExit(err);
    }

    /* 
       we need to open help files in binary mode
       because unicode text might contain 0x1a but
       it's not EOF.
    */
    if ( (hfile = _wfopen(file_path, L"rb")) == 0 )
    {
        ErrorExit(APE_HelpFileDoesNotExist);
    }

    if (!(fgetsW(text, LINE_LEN+1, hfile)))
    {
        ErrorExit(APE_HelpFileEmpty);
    }

    /* comment loop - read and ignore comments */
    while (!HEADER)
    {
	if (!fgetsW(text, LINE_LEN+1, hfile))
        {
	    ErrorExit(APE_HelpFileError);
        }
    }
    /* get the list of commands that net help provides help for that are
    not specifically net commands
    */
    /* ALIAS Loop */
    while (ALIAS) {
	/* the first token read from text is the Real Object (the non alias) */
	tmp = skipwtspc(&text[2]);
	Ap = _tcstok(tmp, DELS);

	/* get each alias for the obove object and compare it to the arg_cnt
	    number of args in ArgList */
	while ((tmp = _tcstok(NULL, DELS)) && arg_cnt) {
	    tmp = skipwtspc(tmp);

	    for (k = 0; k < arg_cnt; k++) {
		/* if there a match store the Objects real name in Arg_P */
		if (!_tcsicmp(tmp, ArgList[(int)(str[k]-1)])) {
		    if (!(Arg_P[((int)str[k])-offset] = _tcsdup(Ap)))
			ErrorExit(APE_HelpFileError);

		    /* delete the pointer to this argument from the list
		    of pointers so the number of compares is reduced */
		    stmp = &str[k];
		    *stmp++ = NULLC;
		    _tcscat(str, stmp);
		    arg_cnt--;
		    break;
		}
	    }
	}

	if (!fgetsW(text, LINE_LEN+1, hfile))
	    ErrorExit(APE_HelpFileError);

    }

    /* if there were any args that weren't aliased copy them into Arg_P */
    for (k = 0; k < arg_cnt; k++)
	Arg_P[((int)str[k])-offset] = ArgList[(int)(str[k]-1)];

    /* check for blank lines between alias declaration and command declarations */
    while (!HEADER) {
	if (!fgetsW(text, LINE_LEN+1, hfile))
	    ErrorExit(APE_HelpFileError);
    }

    while (ADDCOM) {
	if ((arg_cnt) && (!found)) {
	    tmp = skipwtspc(&text[2]);
	    t2 = _tcschr(tmp, NEWLINE);
	    *t2 = NULLC;
	    if (!_tcsicmp(tmp, Arg_P[1])) {
		pind = 1;
		found = -1;
	    }
	}
	if (!fgetsW(text, LINE_LEN+1, hfile))
	    ErrorExit(APE_HelpFileError);
    }

    /* check for blank lines between command declarations and data */
    while (!FCNTRL) {
	if (!fgetsW(text, LINE_LEN+1, hfile))
	    ErrorExit(APE_HelpFileError);
    }

    if (outfile == g_hStdOut) {
	if (amt == OPTIONS_ONLY)
	    InfoPrint(APE_Options);
	else
	    InfoPrint(APE_Syntax);
    }
    else {
	if (amt == OPTIONS_ONLY)
	    InfoPrintInsHandle(APE_Options, 0, g_hStdErr);
	else
	    InfoPrintInsHandle(APE_Syntax, 0, g_hStdErr);
    }

    ali = pind;
    GenOutput(outfile, TEXT("\r\n"));
    /* look for the specific entry (or path) and find its corresponding data */

    /* KKBUGFIX */
    /* U.S. bug.  find_entry strcat's to options but options is
                  uninitialized.  The U.S. version is lucky that the malloc
                  returns memory with mostly zeroes so this works.  With recent
                  changes things are a little different and a malloc returns
                  memory with no zeroes so find_entry overwrites the buffer.  */

    options[0] = '\0';

    while ((r = find_entry(option_level, ali, outfile, &out_len)) >= 0) {
	if (r) {
	    options[0] = NULLC;
	    if (Arg_P[++ali]) {
		option_level++;
		if (!fgetsW(text, LINE_LEN+1, hfile))
		    ErrorExit(APE_HelpFileError);
	    }
	    else {
		seek_data(option_level, 1);
		break;
	    }
	}
    }

    r = (r < 0) ? (option_level - 1) : r;

    switch(amt) {
	case ALL:
	    /* print the syntax data that was found for this level */
	    print_syntax(outfile, out_len);

	    print_help(r);
	    NetcmdExit(0);
	    break;
	case USAGE_ONLY:
	    print_syntax(outfile, out_len);
	    GenOutput(outfile, TEXT("\r\n"));
	    NetcmdExit(1);
	    break;
	case OPTIONS_ONLY:
	    //fflush( outfile );
	    print_options(r);
	    NetcmdExit(0);
	    break;
    }

}
/*   find_entry - each invocation of find_entry either finds a match at the
    specified level or advances through the file to the next entry at
    the specified level. If the level requested is greater than the
    next level read ENTRY_NOT_FOUND is returned. */

int
find_entry(
    int    level,
    int    ali,
    HANDLE out,
    int    *out_len
    )
{
    static  TCHAR     level_key[] = {TEXT(".0")};
    TCHAR     *tmp;
    TCHAR     *t2;

    level_key[1] = (TCHAR) (TEXT('0') + (TCHAR)level);
    if (level_key[1] > text[1])
	return (ENTRY_NOT_FOUND | ali);
    else {
	tmp = skipwtspc(&text[2]);
	t2 = _tcschr(tmp, NEWLINE);

        if (t2 == NULL)
        {
            //
            // A line in the help file is longer than LINE_LEN
            // so there's no newline character.  Bail out.
            //
            ErrorExit(APE_HelpFileError);
        }

	*t2 = NULLC;

	if (!_tcsicmp(Arg_P[ali], tmp)) {
	    *t2++ = BLANK;
	    *t2 = NULLC;
	    GenOutput1(out, TEXT("%s"), tmp);
	    *out_len += _tcslen(tmp);
	    return level;
	}
	else {
	    *t2++ = BLANK;
	    *t2 = NULLC;
	    _tcscat(options, tmp);
	    _tcscat(options, TEXT("| "));
	    seek_data(level, 0);
	    do {

		if (!fgetsW(text, LINE_LEN+1, hfile))
		    ErrorExit(APE_HelpFileError);

	    } while (!FCNTRL);
	    return NEXT_RECORD;
	}
    }
}

VOID
print_syntax(
    HANDLE out,
    int    out_len
    )
{
    TCHAR *tmp,
          *rtmp,
          *otmp,
          tchar;

    int   off,
          pg_wdth = LINE_LEN - 14;

    tmp = skipwtspc(&text[2]);

    if (_tcslen(tmp) < 2)
    {
        //
        // Used only for syntax of NET (e.g., if user types
        // in "net foo")
        //
	if (_tcslen(options))
        {
	    otmp = _tcsrchr(options, PIPE);

            if (otmp == NULL)
            {
                ErrorExit(APE_HelpFileError);
            }

	    *otmp = NULLC;
	    GenOutput(out, TEXT("[ "));
	    out_len += 2;
	    tmp = options;
	    otmp = tmp;
	    off = pg_wdth - out_len;

            while (((int)_tcslen(tmp) + out_len) > pg_wdth)
            {
                if ((tmp + off) > &options[OPTION_MAX_LEN])
                    rtmp = (TCHAR*) (&options[OPTION_MAX_LEN]);
                else
                    rtmp = (tmp + off);

                /* save TCHAR about to be stomped by null */
                tchar = *++rtmp;
                *rtmp = NULLC;

                /* use _tcsrchr to find last occurance of a space (kanji compatible) */
                if ( ! ( tmp = _tcsrchr(tmp, PIPE) ) ) {
                    ErrorExit(APE_HelpFileError);
                }

                /* replace stomped TCHAR */
                *rtmp = tchar;
                rtmp = tmp;

                /* replace 'found space' with null for fprintf */
                *++rtmp = NULLC;
                rtmp++;
                GenOutput1(out, TEXT("%s\r\n"), otmp);

                /* indent next line */
                tmp = rtmp - out_len;
                otmp = tmp;

                while (rtmp != tmp)
                {
                    *tmp++ = BLANK;
                }
            }

            GenOutput1(out, TEXT("%s]\r\n"), otmp);
            *tmp = NULLC;
	}
    }
    else
    {
        GenOutput(out, TEXT("\r\n"));
    }

    do
    {
        if (*tmp)
            GenOutput1(out, TEXT("%s"), tmp);
        if(!(tmp = fgetsW(text, LINE_LEN+1, hfile)))
            ErrorExit(APE_HelpFileError);
        if (_tcslen(tmp) > 3)
            tmp += 3;
    }
    while (!CNTRL);
}


VOID
print_help(
    int level
    )
{

    static  TCHAR    help_key[] = {TEXT("#0")};
            TCHAR   *tmp;

    help_key[1] = (TCHAR)(level) + TEXT('0');
    while (!(text[0] == POUND))
	if(!fgetsW(text, LINE_LEN+1, hfile))
	    ErrorExit(APE_HelpFileError);

    while (text[1] > help_key[1]) {
	help_key[1]--;
	seek_data(--level, 0);
	do {
	    if (!fgetsW(text, LINE_LEN+1, hfile))
		ErrorExit(APE_HelpFileError);
	} while(!(text[0] == POUND));
    }

    tmp = &text[2];
    *tmp = NEWLINE;
    do {
	WriteToCon(TEXT("%s"), tmp);
	if (!(tmp = fgetsW(text, LINE_LEN+1, hfile)))
	    ErrorExit(APE_HelpFileError);

	if (_tcslen(tmp) > 3)
	    tmp = &text[3];

    } while (!CNTRL);
}

VOID
print_options(int level)
{

    static  TCHAR    help_key[] = {TEXT("$0")};
    TCHAR    *tmp;

    help_key[1] = (TCHAR)(level) + TEXT('0');
    while (!(text[0] == DOLLAR))
    if(!fgetsW(text, LINE_LEN+1, hfile))
        ErrorExit(APE_HelpFileError);

    while (text[1] > help_key[1]) {
	help_key[1]--;
	seek_data(--level, 0);
	do {
	    if (!fgetsW(text, LINE_LEN+1, hfile))
		ErrorExit(APE_HelpFileError);
	} while(!(text[0] == DOLLAR));
    }

    tmp = &text[2];
    *tmp = NEWLINE;
    do {
	WriteToCon(TEXT("%s"), tmp);
	if (!(tmp = fgetsW(text, LINE_LEN+1, hfile)))
	    ErrorExit(APE_HelpFileError);

	if (_tcslen(tmp) > 3)
	    tmp = &text[3];

    } while (!CNTRL);
}

VOID
seek_data(int level, int opt_trace)
{
    static  TCHAR    data_key[] = {TEXT(":0")};
    static  TCHAR    option_key[] = {TEXT(".0")};

    TCHAR *tmp;
    TCHAR *t2;

    data_key[1] = (TCHAR)(level) + TEXT('0');
    option_key[1] = (TCHAR)(level) + TEXT('1');

    do {
	if (!(fgetsW(text, LINE_LEN+1, hfile)))
	    ErrorExit(APE_HelpFileError);

	if (opt_trace &&
	    (!(_tcsncmp(option_key, text, DIMENSION(option_key)-1)))) {
	    tmp = skipwtspc(&text[2]);
	    t2 = _tcschr(tmp, NEWLINE);

            if (t2 == NULL)
            {
                //
                // A line in the help file is longer than LINE_LEN
                // so there's no newline character.  Not good.
                //
                ErrorExit(APE_HelpFileError);
            }

	    *t2++ = BLANK;
	    *t2 = NULLC;
	    _tcscat(options, tmp);
	    _tcscat(options, TEXT("| "));
	}

    } while (_tcsncmp(data_key, text, DIMENSION(data_key)-1));
}

TCHAR FAR *
skipwtspc(TCHAR FAR *s)
{
    s += _tcsspn(s, WHITE_SPACE);
    return s;
}

/*      help_helpmsg() -- front end for helpmsg utility
 *
 *      This function acts as a front end for the OS/2 HELPMSG.EXE
 *      utility for NET errors only.  It takes as a parameter a string
 *      that contains a VALID message id; i.e., of the form NETxxxx
 *      or xxxx.  The string is assumed to have been screened by the
 *      IsMsgid() function in grammar.c before coming here.

JonN 3/31/00 98273: NETCMD: Need to fix the mapping of error 3521

Before the checkin for 22391, NET1.EXE read errors
  NERR_BASE (2100) <= err < APPERR2_BASE (4300) from NETMSG.DLL,
and all others from FORMAT_MESSAGE_FROM_SYSTEM.
After the checkin for 22391, NET1.EXE read errors
  NERR_BASE (2100) < err < MAX_NERR (2999) from NETMSG.DLL,
and all others from FORMAT_MESSAGE_FROM_SYSTEM.

On closer examination, NETMSG.DLL currently appears to contain messages from
  0x836 (2102) to 0x169F (5791).
This is consistent with lmcons.h:
  #define MIN_LANMAN_MESSAGE_ID  NERR_BASE
  #define MAX_LANMAN_MESSAGE_ID  5799

It looks like we have a basic contradiction here:

3001:
FORMAT_MESSAGE_FROM_SYSTEM: The specified printer driver is currently in use.
NETMSG.DLL: *** errors were logged in the last *** minutes.

3521:
FORMAT_MESSAGE_FROM_SYSTEM: not found
NETMSG.DLL: The *** service is not started.

So what do we do with the error messages in the range
  MAX_NERR (2999) < err <= MAX_LANMAN_MESSAGE_ID
?  The best error message could be in either one.
Perhaps we should try FORMAT_MESSAGE_FROM_SYSTEM, and if that fails
fall back to NETMSG.DLL.

*/
VOID NEAR pascal
help_helpmsg(TCHAR *msgid)
{
    USHORT       err;
    TCHAR      * temp = msgid;

    /* first, filter out non-NET error msgs */

    /* if msgid begins with a string */
    if (!IsNumber(msgid)) {       /* compare it against NET */
        if (_tcsnicmp(msgid, NET_KEYWORD, NET_KEYWORD_SIZE)) {
            ErrorExitInsTxt(APE_BAD_MSGID, msgid);
        }
        else
            temp += NET_KEYWORD_SIZE;
    }

    if (n_atou(temp, &err))
        ErrorExitInsTxt(APE_BAD_MSGID, msgid);

    /* First try FORMAT_MESSAGE_FROM_SYSTEM unless the error is in the range
       NERR_BASE <= err <= MAX_NERR */
    if (err < NERR_BASE || err > MAX_NERR)
    {
        LPWSTR lpMessage = NULL ;

        if (!FormatMessageW(
                FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                err,
                0,
                (LPWSTR)&lpMessage,
                1024,
                NULL))
        {
            // defer error message and fall back to NETMSG.DLL
        }
        else
        {
            WriteToCon(TEXT("\r\n%s\r\n"), lpMessage);
            (void) LocalFree((HLOCAL)lpMessage) ;
            return ;
        }
    }

    /* skip NETMSG.DLL if error message is way out of range */
    if (err < NERR_BASE || err > MAX_MSGID) {
        ErrorExitInsTxt(APE_BAD_MSGID, msgid);
    }

    /* read from NETMSG.DLL */
    PrintNL();

    //
    // If PrintMessage can't find the message id, don't try the expl
    //

    if (PrintMessage(g_hStdOut, MESSAGE_FILENAME, err, StarStrings, 9) == NO_ERROR)
    {
        PrintNL();

        PrintMessageIfFound(g_hStdOut, HELP_MSG_FILENAME, err, StarStrings, 9);
    }
}


/*
 * returns line from file (no CRLFs); returns NULL if EOF
 */

LPWSTR
fgetsW(
    LPWSTR buf,
    int    len,
    FILE  *fh
    )
{
    int c = 0;
    TCHAR *pch;
    int cchline;
    DWORD cchRead;

    pch = buf;
    cchline = 0;

    if (ftell(fh) == 0) {
	fread(&c, sizeof(TCHAR), 1, fh);
	if (c != 0xfeff)
	    GenOutput(g_hStdErr, TEXT("help file not Unicode\r\n"));
    }

    while (TRUE)
    {
      /*
       * for now read in the buffer in ANSI form until Unicode is more
       * widely accepted  - dee
       *
       */

       cchRead = fread(&c, sizeof(TCHAR), 1, fh);

       //
       //  if there are no more characters, end the line
       //

       if (cchRead < 1)
       {
           c = EOF;
           break;
       }

       //
       //  if we see a \r, we ignore it
       //

       if (c == TEXT('\r'))
           continue;

       //
       //  if we see a \n, we end the line
       //

       if (c == TEXT('\n')) {
	   *pch++ = (TCHAR) c;
           break;
       }

       //
       //  if the char is not a tab, store it
       //

       if (c != TEXT('\t'))
       {
           *pch = (TCHAR) c;
           pch++;
           cchline++;
       }

       //
       //  if the line is too long, end it now
       //

       if (cchline >= len - 1) {
           break;
	}
    }

    //
    //  end the line
    //

    *pch = (TCHAR) 0;

    //
    //  return NULL at EOF with nothing read
    //

    return ((c == EOF) && (pch == buf)) ? NULL : buf;
}


//
// Build the fully qualified path name of a file that lives with the exe
// Used by LUI_GetHelpFileName
//

DWORD
GetFileName(
    LPTSTR FileName,
    DWORD  BufferLength,
    LPTSTR FilePartName
    )
{

    TCHAR ExeFileName[MAX_PATH];
    PTCHAR pch;

    //
    // Get the fully qualified path name of where the exe lives
    //

    if (!GetModuleFileName(NULL, ExeFileName, DIMENSION(ExeFileName)))
    {
        return 1;
    }

    //
    // get rid of the file name part
    //

    pch = _tcsrchr(ExeFileName, '\\');

    if (!pch)
    {
        return 1;
    }

    *(pch+1) = NULLC;

    //
    // Copy the path name into the string and add the help filename part
    // but first make sure it's not too big for the user's buffer
    //

    if (_tcslen(ExeFileName) + _tcslen(FilePartName) + 1 > BufferLength)
    {
        return 1;
    }

    _tcscpy(FileName, ExeFileName);
    _tcscat(FileName, FilePartName);

    return 0;

}

//
// Get the help file name
//

DWORD
GetHelpFileName(
    LPTSTR HelpFileName,
    DWORD  BufferLength
    )
{

    TCHAR LocalizedFileName[MAX_PATH];
    DWORD LocalizedFileNameID;
    switch(GetConsoleOutputCP()) {
	case 932:
	case 936:
	case 949:
	case 950:
        LocalizedFileNameID = APE2_FE_NETCMD_HELP_FILE;
        break;
	default:
        LocalizedFileNameID = APE2_US_NETCMD_HELP_FILE;
        break;
    }

    if (LUI_GetMsg(LocalizedFileName, DIMENSION(LocalizedFileName),
                    LocalizedFileNameID))
    {
        return GetFileName(HelpFileName, BufferLength, TEXT("NET.HLP"));
    }
    else
    {
        return GetFileName(HelpFileName, BufferLength, LocalizedFileName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\grammar.c ===
/********************************************************************/
/**			Microsoft LAN Manager			   **/
/**		  Copyright(c) Microsoft Corp., 1987-1991	   **/
/********************************************************************/

/*
 *	Grammar.c - contains the functions to determine type of object
 *	passed.  Is used by the parser to check grammar.
 *
 *	date	  who	  what
 *	??/??/??, ?????,  initial code
 *	10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *	05/02/89, erichn, NLS conversion
 *	06/08/89, erichn, canonicalization sweep
 *	06/23/89, erichn, replaced old NetI calls with new I_Net functions
 *	06/11/90, thomaspa, fixed IsValidAssign() to accept paths with
 *			    embedded spaces.
 *		02/20/91, danhi, change to use lm 16/32 mapping layer
 */


#define INCL_NOCOMMON
#include <os2.h>
#include <lmcons.h>
#include <stdio.h>
#include <ctype.h>
#include <process.h>
#include <lmaccess.h>
#include <lmserver.h>
#include <lmshare.h>
#include <icanon.h>
#include "netcmds.h"
#include "nettext.h"

/* prototypes of worker functions */

int is_other_resource(TCHAR *);





int IsAccessSetting(TCHAR *x)
{
    TCHAR FAR *		    pos;
    TCHAR		    buf[sizeof(ACCESS_LETTERS)];

    pos = _tcschr(x, COLON);

    if (pos == NULL)
	return 0;

    /* check if the first component is a user name. */
    *pos = NULLC;
    if (I_NetNameValidate(NULL, x, NAMETYPE_USER, LM2X_COMPATIBLE))
    {
	*pos = COLON;
	return 0;
    }

    *pos++ = COLON;

    /* if there is a letter that is not an access letter it can
	only be TEXT('y') or TEXT('n'), which must be alone. */

    _tcscpy(buf, pos);
    _tcsupr(buf);
    if ( _tcsspn(buf, TEXT(ACCESS_LETTERS)) != _tcslen(buf) )
	return ( !_tcsicmp(buf, TEXT("Y")) || !_tcsicmp(buf, TEXT("N")) );
    else
	return 1;
}



int IsPathname ( TCHAR * x )
{
    ULONG   type = 0;

    if (I_NetPathType(NULL, x, &type, 0L))
	return 0;

    return (type == ITYPE_PATH_ABSD ||
	    type == ITYPE_PATH_ABSND ||
	    type == ITYPE_PATH_RELD ||
	    type == ITYPE_PATH_RELND );
}



int IsPathnameOrUNC ( TCHAR * x )
{
    ULONG   type = 0;

    if (I_NetPathType(NULL, x, &type, 0L))
	return 0;

    return (type == ITYPE_PATH_ABSD ||
	    type == ITYPE_PATH_ABSND ||
	    type == ITYPE_PATH_RELD ||
	    type == ITYPE_PATH_RELND ||
	    type == ITYPE_UNC);
}



/* Access type resource only, does not include lpt, com etc... */

int IsResource ( TCHAR * x )
{
    ULONG   type = 0;

    if (I_NetPathType(NULL, x, &type, 0L))
	return 0;

    return (type == ITYPE_PATH_ABSD ||
	    type == ITYPE_PATH_ABSND ||
	    type == ITYPE_DEVICE_DISK ||
	    type == ITYPE_PATH_SYS_PIPE ||
	    type == ITYPE_PATH_SYS_COMM ||
	    type == ITYPE_PATH_SYS_PRINT ||
	    is_other_resource(x) );

}



int is_other_resource(TCHAR *  x)
{
    return (!_tcsicmp(x, TEXT("\\PIPE")) ||
	    !_tcsicmp(x, TEXT("\\PRINT")) ||
	    !_tcsicmp(x, TEXT("\\COMM")));
}



int IsNetname(TCHAR *  x)
{
    return (!I_NetNameValidate(NULL, x, NAMETYPE_SHARE, 0));
}


int IsComputerName(TCHAR *x)
{
    ULONG  type = 0;

    if (I_NetPathType(NULL, x, &type, 0L))
	return 0;

    return ( type == ITYPE_UNC_COMPNAME );
}

int IsDomainName(TCHAR *x)
{
    return (!I_NetNameValidate(NULL, x, NAMETYPE_DOMAIN, 0L) || !I_NetNameValidate(NULL, x, NAMETYPE_COMPUTER, 0L));
}



int IsComputerNameShare(TCHAR *x)
{
    ULONG	type;
    TCHAR FAR *	ptr;
    if (I_NetPathType(NULL, x, &type, 0L))
	return 0;

    if (!(type & ITYPE_UNC))
	return 0;

    if (type == ITYPE_UNC_COMPNAME)
	return 0;


    /*	Find the slash separating the computername and the
     *	sharename.  We know this is a UNC name, thus we can safely
     *	skip 2 bytes for the leading backslashes.
     */
    ptr = _tcspbrk(x+2, TEXT("\\/") );
    if ( ptr == NULL )
	return 0;

    ptr +=1;	    /* point past slash TCHAR */

    /*
     * Make sure there are no more slashes
     */
    if( _tcspbrk(ptr, TEXT("\\/")) != NULL)
	return 0;

    return 1;

}

int IsDeviceName(TCHAR *x)
{
    ULONG  type = 0;
    TCHAR FAR * pos;

    if (I_NetPathType(NULL, x, &type, 0L))
	return 0;

    if (type & ITYPE_DEVICE)
    {
	if (type == ITYPE_DEVICE_DISK)
	    return 1;
	if (pos = _tcschr(x, COLON))
	    *pos = NULLC;
	return 1;
    }

    return 0;
}

/*
 *  IsMsgid -- determines if passed string is a valid message id.
 *  msd id's are of the form yyyxxxx where
 *  yyy is any string beginning with a non-numeric character OR null
 *  xxxx is a string containing only numeric characters.
 */
int
IsMsgid(
    LPTSTR x
    )
{
    if (IsNumber(x))
	return TRUE;
    x+= NET_KEYWORD_SIZE;
    if (IsNumber(x))
	return TRUE;
    return FALSE;
}


int
IsNumber(
    LPTSTR x
    )
{
    return (*x && (_tcslen(x) == _tcsspn(x, TEXT("0123456789"))));
}


int
IsShareAssignment(
    LPTSTR x
    )
{
    TCHAR      * pos;
    int 	result;

    /* WARNING: x ALWAYS should be a TCHAR * */
    pos = _tcschr (x, '=');

    if (pos == NULL)
    {
	return 0;
    }

    *pos = NULLC;

    result = (int) ( IsNetname(x) && IsValidAssign(pos+1) );
    *pos = '=';
    return result;
}


int
IsValidAssign(
    LPTSTR name
    )
{
    TCHAR           name_out[MAX_PATH];
    ULONG           types[64];
    DWORD	    count;
    DWORD           i;
    ULONG           type = 0;

    /*
     * First check if it is a path.  Since a path may contain spaces, we
     * return successfully immediately.
     */

    I_NetPathType(NULL, name, &type, 0L);

    if ( type == ITYPE_PATH_ABSD || type == ITYPE_DEVICE_DISK )
    {
	return 1;
    }


    /*
     * Not an absolute path, so go about our normal business.
     */
    if (I_NetListCanonicalize(NULL,	/* server name, NULL means local */
			name,		/* list to canonicalize */
			txt_LIST_DELIMITER_STR_UI,
			name_out,
			DIMENSION(name_out),
			&count,
			types,
			DIMENSION(types),
			(NAMETYPE_PATH | OUTLIST_TYPE_API) ))
    {
	return 0;
    }

    if (count == 0)
    {
	return 0;
    }

    for (i = 0; i < count; i++)
    {
	if (types[i] != ITYPE_DEVICE_LPT  &&
	    types[i] != ITYPE_DEVICE_COM &&
	    types[i] != ITYPE_DEVICE_NUL)
        {
	    return 0;
        }
    }

    return 1;
}


int
IsAnyShareAssign(
    LPTSTR x
    )
{
    TCHAR *		    pos;
    int 		    result;

    /* WARNNING: x ALWAYS should be a TCHAR * */
    pos = _tcschr (x, '=');

    if (pos == NULL)
	return 0;

    *pos = NULLC;

    result = (int) ( IsNetname(x) && IsAnyValidAssign(pos+1) );
    *pos = '=';
    return result;
}


int
IsAnyValidAssign(
    LPTSTR name
    )
{
    TCHAR		    name_out[MAX_PATH];
    ULONG		    types[64];
    DWORD	    count;

    if (I_NetListCanonicalize(NULL,	/* server name, NULL means local */
			name,		/* list to canonicalize */
			txt_LIST_DELIMITER_STR_UI,
			name_out,
			DIMENSION(name_out),
			&count,
			types,
			DIMENSION(types),
			(NAMETYPE_PATH | OUTLIST_TYPE_API) ))
	return 0;

    if (count == 0)
	return 0;

    return 1;
}



#ifdef OS2
int IsAdminShare(TCHAR * x)
{
    if ((_tcsicmp(x, TEXT("IPC$"))) && (_tcsicmp(x, ADMIN_DOLLAR)))
	return 0;
    else
	return 1;
}
#endif /* OS2 */

#ifdef OS2
/*
 * what we are looking for here is PRINT=xxxx
 */
int IsPrintDest(TCHAR *x)
{
    TCHAR FAR * ptr;

    if (!_tcsnicmp(x, TEXT("PRINT="), 6) && _tcslen(x) > 6)
    {
	x += 6;
	if (!IsDeviceName(x))
	    return 0;
	if (ptr = _tcschr(x,COLON))
	    *ptr = NULLC;
	return 1;
    }

    return 0;
}
#endif /* OS2 */

/*
 * returns true is the arg is a valid username
 */
int IsUsername(TCHAR * x)
{
    return !(I_NetNameValidate(NULL, x, NAMETYPE_USER, LM2X_COMPATIBLE));
}

/*
 * returns true is the arg is a valid username or a qualified username,
 * of form domain\user or a potential UPN
 */
int IsQualifiedUsername(TCHAR * x)
{
    TCHAR *ptr, name[UNLEN + 1 + DNLEN + 1] ;

    if (_tcschr(x, '@'))
        return 1;

    // check for overflow
    if (_tcslen(x) >= DIMENSION(name))
	return 0 ;

    // make copy 
    _tcscpy(name, x) ;

    // do we have a domain\username format?
    if (ptr = _tcschr(name, '\\'))
    {
	*ptr = NULLC ;
  	++ptr ;  	// this is DCS safe since we found single byte char

 	// if its a domain, check the username part
	if (IsDomainName(name))
    	    return IsUsername(ptr) ;
	
	// its not valid
	return(0) ;
    }

    // else just straight username
    return IsUsername(x) ;
}

int IsGroupname(TCHAR * x)
{
    return !(I_NetNameValidate(NULL, x, NAMETYPE_GROUP, 0L));
}

int IsMsgname(TCHAR * x)
{
    if (!_tcscmp(x, TEXT("*")))
	return 1;
    return !(I_NetNameValidate(NULL, x, NAMETYPE_COMPUTER, LM2X_COMPATIBLE));
}

int IsPassword(TCHAR * x)
{
    if (!_tcscmp(x, TEXT("*")))
	return 1;
    return !(I_NetNameValidate(NULL, x, NAMETYPE_PASSWORD, 0L));
}

int IsWildCard(TCHAR * x)
{
    if (x == NULL)
        return 0 ;
    return ( (!_tcscmp(x, TEXT("*"))) || (!_tcscmp(x, TEXT("?"))) ) ;
}

int IsQuestionMark(TCHAR * x)
{
    if (x == NULL)
        return 0 ;
    return (!_tcscmp(x, TEXT("?"))) ;
}

#ifdef OS2
int IsSharePassword(TCHAR * x)
{
    if (!_tcscmp(x, TEXT("*")))
	return 1;

    if (_tcslen(x) > SHPWLEN)
	return 0;

    return !(I_NetNameValidate(NULL, x, NAMETYPE_PASSWORD, LM2X_COMPATIBLE));
}
#endif /* OS2 */

int IsNtAliasname(TCHAR *name)
{
    return !(I_NetNameValidate(NULL, name, NAMETYPE_GROUP, 0L));
}


#ifdef OS2
#ifdef IBM_ONLY
int IsAliasname(TCHAR *	x)
{

    if ( _tcslen(x) > 8 )
	return 0;

    return !(I_NetNameValidate(NULL, x, NAMETYPE_SHARE, LM2X_COMPATIBLE));

}
#endif /* IBM_ONLY */
#endif /* OS2 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\lui.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    LUI.C

Abstract:

    Contains support functions

Author:

    Dan Hinsley    (danhi)  06-Jun-1991

Environment:

    User Mode - Win32

Revision History:

    18-Apr-1991     danhi
        32 bit NT version

    06-Jun-1991     Danhi
        Sweep to conform to NT coding style

    23-Oct-1991     W-ShankN
        Added Unicode mapping

    01-Oct-1992 JohnRo
        RAID 3556: Added NetpSystemTimeToGmtTime() for DosPrint APIs.

    10-Feb-1993     YiHsinS
        Moved LUI_GetMsgIns to netlib\luiint.c

--*/

//
// INCLUDES
//

#include <nt.h>	           // these 3 includes are for RTL
#include <ntrtl.h>	   // these files are picked up to
#include <nturtl.h>	   // allow <windows.h> to compile. since we've
			   // already included NT, and <winnt.h> will not
			   // be picked up, and <winbase.h> needs these defs.
#include <windows.h>       // IN, LPTSTR, etc.

#include <string.h>
#include <lmcons.h>
#include <stdio.h>
#include <process.h>
#include "netlibnt.h"
#include <lui.h>
#include "icanon.h"
#include <lmerr.h>
#include <conio.h>
#include <io.h>
#include <tchar.h>
#include <msystem.h>
#include "apperr.h"
#include "apperr2.h"
#include "netascii.h"
#include "netcmds.h"


//
// Local definitions and macros/function declarations
//

#define LUI_PMODE_DEF		  0x00000000
#define LUI_PMODE_EXIT		  0x00000002
#define LUI_PMODE_NODEF 	  0x00000004
#define LUI_PMODE_ERREXT	  0x00000008


/* fatal error, just exit */
#define LUIM_ErrMsgExit(E)		LUI_PrintMsgIns(NULL, 0, E, NULL, \
					    LUI_PMODE_ERREXT | LUI_PMODE_DEF | \
                                            LUI_PMODE_EXIT,  g_hStdErr)

DWORD
LUI_PrintMsgIns(
    LPTSTR       *istrings,
    DWORD         nstrings,
    DWORD         msgno,
    unsigned int *msglen,
    DWORD         mode,
    HANDLE        handle
    );


/*
 * LUI_CanonPassword
 *
 *  This function ensures that the password in the passed buffer is a
 *  syntactically valid password.  
 *  
 *  This USED to upper case passwords. No longer so in NT.
 *
 *
 *  ENTRY
 *      buf         buffer containing password to be canonicalized
 *
 *  EXIT
 *      buf         canonicalized password, if valid
 *
 *  RETURNS
 *      0           password is valid
 *      otherwise   password is invalid
 *
 */

USHORT LUI_CanonPassword(TCHAR * szPassword)
{

    /* check it for validity */
    if (I_NetNameValidate(NULL, szPassword, NAMETYPE_PASSWORD, 0L ))
    {
        return APE_UtilInvalidPass;
    }

    return 0;
}


/*
 * Name:        LUI_GetMsg
 *              This routine is similar to LUI_GetMsgIns,
 *              except it takes does not accept insert strings &
 *              takes less arguments.
 * Args:        msgbuf   : buffer to hold message retrieved
 *              bufsize  : size of buffer
 *              msgno    : message number
 * Returns:     zero if ok, the DOSGETMESSAGE error code otherwise
 * Globals:     (none)
 * Statics:     (none)
 */
DWORD
LUI_GetMsg(
    PTCHAR msgbuf,
    USHORT bufsize,
    DWORD  msgno
    )
{
    return LUI_GetMsgInsW(NULL, 0, msgbuf, bufsize, msgno, NULL);
}


#define SINGLE_HORIZONTAL                       '\x02d'
#define SCREEN_WIDTH                            79
USHORT
LUI_PrintLine(
    VOID
    )
{
    TCHAR string[SCREEN_WIDTH+1];
    USHORT i;


    for (i = 0; i < SCREEN_WIDTH; i++) {
        string[i] = SINGLE_HORIZONTAL;
    }

    string[SCREEN_WIDTH] = NULLC;
    WriteToCon(TEXT("%s\r\n"), &string);

    return(0);

}

/***
 * Y o r N
 *
 * Gets an answer to a Y/N question
 *
 * Entry:       promptMsgNum -- The number of the message to prompt with
 *              def --          default (TRUE if set, FALSE otherwise)
 */
DWORD
LUI_YorN(
    USHORT promptMsgNum,
    USHORT def
    )
{
    return LUI_YorNIns(NULL, 0, promptMsgNum, def);
}
/***
 * Y o r N Insert
 *
 * Gets an answer to a Y/N question containing insertions.
 *
 * !!!!!!!!
 * NOTE: istrings[nstrings] will be used to store "Y" or "N",
 *      depending on default value supplied.  Thus this function
 *      handles one fewer entry in istrings than other LUI Ins
 *      functions do.  Beware!
 * !!!!!!!!
 *
 * Entry:       istrings --     Table of insertion strings
 *              nstrings --     Number of valid insertion strings
 *              promptMsgNum -- The number of the message to prompt with
 *              def --          default (TRUE if set, FALSE otherwise)
 *
 * Returns: TRUE, FALSE, or -1 in case of LUI_PrintMsgIns error.
 */

#define PRINT_MODE      (LUI_PMODE_ERREXT)
#define STRING_LEN      APE2_GEN_MAX_MSG_LEN
#define LUI_LOOP_LIMIT  5

DWORD
LUI_YorNIns(
    PTCHAR * istrings,
    USHORT nstrings,
    USHORT promptMsgNum,
    USHORT def
    )
{

    USHORT       count;            /* count of times we ask */
    DWORD        err;              /* LUI API return values */
    unsigned int dummy;            /* length of msg */

    /* 10 because max # of insert strings to DosGetMessage is 9, and
       we'll leave caller room to mess up and get the error back
       from LUI_PrintMsgIns() */

    LPTSTR IStrings[10];            /* Insertion strings for LUI */
    TCHAR  defaultYes[STRING_LEN];  /* (Y/N) [Y] string */
    TCHAR  defaultNo[STRING_LEN];   /* (Y/N) [N] string */
    TCHAR  NLSYesChar[STRING_LEN];
    TCHAR  NLSNoChar[STRING_LEN];
    TCHAR  strBuf[STRING_LEN];      /* holds input string */
    DWORD  len;                     /* length of string input */
    TCHAR  termChar;                /* terminating char */

    /* copy istrings to IStrings so we'll have room for Y or N */
    for (count=0; count < nstrings; count++)
            IStrings[count] = istrings[count];
    /* retrieve text we need from message file, bail out if probs */
    if (err = LUI_GetMsg(defaultYes, DIMENSION(defaultYes),
                    APE2_GEN_DEFAULT_YES))
    {
            LUIM_ErrMsgExit(err);
    }

    if (err = LUI_GetMsg(defaultNo, DIMENSION(defaultNo),
                    APE2_GEN_DEFAULT_NO))
            LUIM_ErrMsgExit(err);

    if (err = LUI_GetMsg(NLSYesChar, DIMENSION(NLSYesChar),
                    APE2_GEN_NLS_YES_CHAR))
            LUIM_ErrMsgExit(err);

    if (err = LUI_GetMsg(NLSNoChar, DIMENSION(NLSNoChar),
                    APE2_GEN_NLS_NO_CHAR))
            LUIM_ErrMsgExit(err);

    if (def)
            IStrings[nstrings] = defaultYes;
    else
            IStrings[nstrings] = defaultNo;
    nstrings++;

    for (count = 0; count < LUI_LOOP_LIMIT; count++)
    {
        if (count)
        {
            LUI_PrintMsgIns(NULL, 0, APE_UtilInvalidResponse, NULL, PRINT_MODE, g_hStdOut);
        }

        err = LUI_PrintMsgIns(IStrings, nstrings, promptMsgNum,
                              &dummy, PRINT_MODE, g_hStdOut);

        if ((LONG) err < 0)
            return(err);

        if (GetString(strBuf, DIMENSION(strBuf), &len, &termChar))
            /* overwrote buffer, start again */
            continue;

        if ((len == 0) && (termChar == (TCHAR)EOF))
        {
            /* end of file reached */
            PrintNL();
            LUIM_ErrMsgExit(APE_NoGoodResponse);
        }

        if (len == 0)           /* user hit RETURN */
            return def;
        else if (!_tcsnicmp(NLSYesChar, strBuf, _tcslen(NLSYesChar)))
            return TRUE;
        else if (!_tcsnicmp(NLSNoChar, strBuf, _tcslen(NLSNoChar)))
            return FALSE;

        /* default is handled at top of loop. */
    };

    LUIM_ErrMsgExit(APE_NoGoodResponse);

    return err; // Keep compiler happy.
}


/*
 * LUI_CanonMessagename
 *
 * This function uppercases the contents of the buffer, then checks to
 *  make sure that it is a syntactically valid messenging name.
 *
 *
 *  ENTRY
 *      buf         buffer containing name to be canonicalized
 *
 *  EXIT
 *      buf         canonicalized name, if valid
 *
 *  RETURNS
 *      0           name is valid
 *      otherwise   name is invalid
 *
 */
USHORT
LUI_CanonMessagename(
    PTCHAR buf
    )
{
    /* check it for validity */
    if (I_NetNameValidate(NULL, buf, NAMETYPE_MESSAGE, LM2X_COMPATIBLE))
    {
        return NERR_InvalidComputer;
    }

    _tcsupr(buf);
    return 0;
}

/*
 * LUI_CanonMessageDest
 *
 * This function uppercases the contents of the buffer, then checks to
 *  make sure that it is a syntactically valid messenging destination.
 *
 *
 *  ENTRY
 *      buf         buffer containing name to be canonicalized
 *
 *  EXIT
 *      buf         canonicalized name, if valid
 *
 *  RETURNS
 *      0           name is valid
 *      otherwise   name is invalid
 *
 */

USHORT
LUI_CanonMessageDest(
    PTCHAR buf
    )
{
    /* check it for validity */
    if (I_NetNameValidate(NULL, buf, NAMETYPE_MESSAGEDEST, LM2X_COMPATIBLE))
    {
        return NERR_InvalidComputer;
    }

    _tcsupr(buf);
    return(0);

}


/***
 * LUI_CanonForNetBios
 *     Canonicalizes a name to a NETBIOS canonical form.
 * 
 * Args:
 *     Destination             - Will receive the canonicalized name (Unicode).
 *     cchDestination          - the number of chars Destination can hold
 *     pszOem                  - Contains the original name in OEM. Will have
 *                               the canonicalized form put back here.
 * Returns:
 *     0 if success
 *     error code otherwise
 */
USHORT LUI_CanonForNetBios( WCHAR * Destination, INT cchDestination,
                            TCHAR * pszOem )
{

    _tcscpy(Destination, pszOem);
    return NERR_Success;
}   


/*
 * Name:        LUI_PrintMsgIns
 *                      This routine is very similar to LUI_GetmsgIns,
 *                      except it prints the message obtained instead of
 *                      storing it in a buffer.
 * Args:        istrings : pointer to table of insert strings
 *              nstrings : number of insert strings
 *              msgno    : message number
 *              msglen   : pointer to variable that will receive message length
 *              mode     : how the message is to be printed.
 *              handle   : file handle to which output goes
 * Returns:     zero if ok, the DOSGETMESSAGE error code otherwise
 * Globals:     (none)
 * Statics:     (none)
 * Remarks:     (none)
 * Updates:     (none)
 */
DWORD
LUI_PrintMsgIns(
    LPTSTR       *istrings,
    DWORD        nstrings,
    DWORD        msgno,
    unsigned int *msglen,
    DWORD        mode,
    HANDLE       handle
    )
{
    TCHAR        msgbuf[MSG_BUFF_SIZE];
    DWORD        result;
    unsigned int tmplen;
    SHORT        exit_on_error, exit_on_completion, no_default_err_msg;

    /* check if we have illegal combination */
    if ((mode & LUI_PMODE_NODEF)
          &&
        (mode & (LUI_PMODE_EXIT | LUI_PMODE_ERREXT)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    /* setup various flags */
    exit_on_error      = (SHORT)(mode & LUI_PMODE_ERREXT);
    exit_on_completion = (SHORT)(mode & LUI_PMODE_EXIT);
    no_default_err_msg = (SHORT)(mode & LUI_PMODE_NODEF);

    /* get message and write it */
    result = LUI_GetMsgInsW(istrings, nstrings, msgbuf,
			    DIMENSION(msgbuf),
                            msgno, (unsigned *) &tmplen);

    if (result == 0 || !no_default_err_msg)
    {
        _tcsncpy(ConBuf, msgbuf, tmplen);
        ConBuf[tmplen] = NULLC;
        DosPutMessageW(handle, ConBuf, FALSE);
    }

    if (msglen != NULL) *msglen = tmplen ;

    /* different ways of exiting */
    if (exit_on_error && result != 0)
    {
        exit(result) ;
    }

    if (exit_on_completion)
    {
        exit(-1) ;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\luidate.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    luidate.C

Abstract:

    Convert date/time parsing routines

Author:

    Dan Hinsley    (danhi)  06-Jun-1991

Environment:

    User Mode - Win32

Revision History:

    24-Apr-1991     danhi
	32 bit NT version

    06-Jun-1991     Danhi
	Sweep to conform to NT coding style

    01-Oct-1992 JohnRo
        RAID 3556: Added NetpSystemTimeToGmtTime() for DosPrint APIs.

    16-Feb-1993     chuckc
        fixed to _read internation info from system

    22-Feb-1993     yihsins
        Moved from netcmd\map32\pdate.c. And added LUI_ParseDateSinceStartOfDay.

--*/

//
// INCLUDES
//

#include <windows.h>    // IN, LPTSTR, etc.
#include <winerror.h>

#include <malloc.h>
#include <time.h>
#include <tchar.h>

#include <lmcons.h>
#include <apperr.h>
#include <apperr2.h>
#include <timelib.h>

#include <luidate.h>
#include <luiint.h>
#include <luitext.h>
#include "netascii.h"

/*-- manifests --*/

/* max number of fields for either date or time */
#define	PD_MAX_FIELDS		5

/* are we reading a NUMBER, AM/PM selector or MONTHS */
#define	PD_END_MARKER		0
#define	PD_NUMBER		1
#define	PD_AMPM       		2
#define	PD_MONTHS       	3

/* time formats */
#define	PD_24HR			0
#define	PD_AM			1
#define PD_PM			2

/* internal error code */
#define	PD_SUCCESS		0
#define	PD_ERROR_NO_MATCH	1
#define PD_ERROR_INTERNAL	2
#define PD_ERROR_END_OF_INPUT	3

/* indices */
#define DAYS			0
#define MONTHS			1
#define YEARS			2
#define HOURS			0
#define MINUTES			1
#define SECONDS			2
#define AMPM			3

#define WHITE_SPACE		TEXT(" \t\n")
#define DIGITS			TEXT("0123456789")


/*-- types internal to this module --*/

/* describe how we expect to parse a field within a date or time */
typedef struct date_field_desc {
    TCHAR *		sep ;		/* the separator before this field */
    TCHAR *		fmt ;		/* format descriptor, scanf() style */
    UCHAR		typ ;		/* NUMBER or AMPM or MONTHS */
    UCHAR		pos ;		/* position - depends on country */
} date_fdesc ;

/* an array of short values, each corresponding to a field read */
typedef LONG date_data[PD_MAX_FIELDS] ;

/*-- forward declarations --*/

/* type passed in to WParseDate */
#define SECONDS_SINCE_1970           0
#define SECONDS_SINCE_START_OF_DAY   1

DWORD
WParseDate(
    date_fdesc **d_desc ,
    date_fdesc **t_desc ,
    TCHAR      *inbuf  ,
    TCHAR      **nextchr,
    time_t     *time,
    USHORT     nTimeType
    );

DWORD
setup_data(
    TCHAR **bufferp ,
    TCHAR **freep,
    DWORD slist_bufsiz ,
    TCHAR * * local_inbuf,
    PTCHAR inbuf,
    SHORT country,
    PDWORD parselen
    );

SHORT  read_format( TCHAR * *   inbuf,
		           date_fdesc *desc,
		           date_data  data ) ;

DWORD
convert_to_secs(
    date_data  t_data,
    time_t     *time
    );

DWORD
convert_to_abs(
    date_data  d_data,
    date_data  t_data,
    time_t     *time
    );

SHORT convert_to_24hr( date_data time ) ;

VOID advance_date( date_data  d_data) ;

time_t seconds_since_1970( date_data d_data,
		                date_data t_data ) ;

time_t days_so_far( int d, int m, int y ) ;

INT MySscanf(TCHAR* input, TCHAR* fmt, PVOID out);

/* international time/date info */

typedef struct _MY_COUNTRY_INFO
{
     TCHAR   szDateSeparator[16] ;
     TCHAR   szTimeSeparator[16] ;
     USHORT fsDateFmt ;
     TCHAR   szAMString[16] ;
     TCHAR   szPMString[16] ;
} MY_COUNTRY_INFO ;

void GetInternationalInfo(MY_COUNTRY_INFO *pcountry_info) ;

/*-- static data --*/

static searchlist_data ampm_data[] = {
    {APE2_GEN_TIME_AM1, PD_AM},
    {APE2_GEN_TIME_AM2, PD_AM},
    {APE2_GEN_TIME_AM3, PD_AM},
    {APE2_GEN_TIME_PM1, PD_PM},
    {APE2_GEN_TIME_PM2, PD_PM},
    {APE2_GEN_TIME_PM3, PD_PM},
    {0,0}
} ;

static searchlist_data months_data[] = {
    {APE2_TIME_JANUARY,		1},
    {APE2_TIME_FEBRUARY,	2},
    {APE2_TIME_MARCH,		3},
    {APE2_TIME_APRIL,		4},
    {APE2_TIME_MAY,		5},
    {APE2_TIME_JUNE,		6},
    {APE2_TIME_JULY,		7},
    {APE2_TIME_AUGUST,		8},
    {APE2_TIME_SEPTEMBER,	9},
    {APE2_TIME_OCTOBER,		10},
    {APE2_TIME_NOVEMBER,	11},
    {APE2_TIME_DECEMBER,	12},
    {APE2_TIME_JANUARY_ABBREV,	1},
    {APE2_TIME_FEBRUARY_ABBREV,	2},
    {APE2_TIME_MARCH_ABBREV,	3},
    {APE2_TIME_APRIL_ABBREV,	4},
    {APE2_TIME_MAY_ABBREV,	5},
    {APE2_TIME_JUNE_ABBREV,	6},
    {APE2_TIME_JULY_ABBREV,	7},
    {APE2_TIME_AUGUST_ABBREV,	8},
    {APE2_TIME_SEPTEMBER_ABBREV,9},
    {APE2_TIME_OCTOBER_ABBREV,	10},
    {APE2_TIME_NOVEMBER_ABBREV,	11},
    {APE2_TIME_DECEMBER_ABBREV,	12},
    {0,0}
} ;

#define MONTHS_IN_YEAR	(12)
#define NUM_AMPM_LIST 	(sizeof(ampm_data)/sizeof(ampm_data[0]))
#define NUM_MONTHS_LIST (sizeof(months_data)/sizeof(months_data[0]))
#define SLIST_BUFSIZ  	(640)

/*
 * The list containing valid am,pm strings
 */
static TCHAR LUI_usr_am[16];
static TCHAR LUI_usr_pm[16];

static searchlist 	ampm_list[NUM_AMPM_LIST + 4] = {
	{LUI_usr_am,PD_AM},	
	{LUI_usr_pm,PD_PM},	
	{LUI_txt_am,PD_AM},	
	{LUI_txt_pm,PD_PM},
    } ;	

/*
 * NOTE - we init the first 12 hardwired months
 * and get the rest from the message file
 */
static searchlist 	months_list[NUM_MONTHS_LIST + MONTHS_IN_YEAR] = {
	{LUI_txt_january,1},
	{LUI_txt_february,2},
	{LUI_txt_march,3},
	{LUI_txt_april,4},
	{LUI_txt_may,5},
	{LUI_txt_june,6},
	{LUI_txt_july,7},
	{LUI_txt_august,8},
	{LUI_txt_september,9},
	{LUI_txt_october,10},
	{LUI_txt_november,11},	
	{LUI_txt_december,12},
    } ;	

/*
 * built in formats for scanf - we will add to these strings as needed
 * when we read stuff from DosGetCtryInfo(). Note that a string is
 * defined to be anything which is not a known separator.
 */
static TCHAR pd_fmt_null[1]	 = TEXT("") ;
static TCHAR pd_fmt_d_sep1[8]	 = TEXT("/-") ;	/* date separator for NUMBERs */
static TCHAR pd_fmt_d_sep2[8]	 = TEXT("/,- \t") ;	/* date separator for MONTHs  */
static TCHAR pd_fmt_t_sep[8]	 = TEXT(":") ;	/* time separator */
static TCHAR pd_fmt_number[8]	 = TEXT("%d") ;	/* a number */
static TCHAR pd_fmt_string[16]	 = TEXT("%[^,- /:\t") ;  /* string, needs ] at end */

/*-- date descriptors (despite verbosity, not as big at it seems)  --*/

static date_fdesc d_desc1[] = {				     /* eg. 3-31-89 */
    {pd_fmt_null,     pd_fmt_number,   	PD_NUMBER,   	1 },
    {pd_fmt_d_sep1,   pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_d_sep1,   pd_fmt_number,   	PD_NUMBER,   	2 },
    {pd_fmt_null,     pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc d_desc2[] = {				     /* eg. 5 Jun 89 */
    {pd_fmt_null,     pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_d_sep2,   pd_fmt_string,	PD_MONTHS,   	1 },
    {pd_fmt_d_sep2,   pd_fmt_number,  	PD_NUMBER,   	2 },
    {pd_fmt_null,     pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc d_desc3[] = {				     /* eg. Jun 5 89 */
    {pd_fmt_null,     pd_fmt_string,	PD_MONTHS,   	1 },
    {pd_fmt_d_sep2,   pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_d_sep2,   pd_fmt_number,  	PD_NUMBER,   	2 },
    {pd_fmt_null,     pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc d_desc4[] = {				      /* eg. 3-31 */
    {pd_fmt_null,     pd_fmt_number,   	PD_NUMBER,   	1 },
    {pd_fmt_d_sep1,   pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_null,     pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc d_desc5[] = {				      /* eg. 5 Jun */
    {pd_fmt_null,     pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_d_sep2,   pd_fmt_string,	PD_MONTHS,   	1 },
    {pd_fmt_null,     pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc d_desc6[] = {				      /* eg. Jun 5 */
    {pd_fmt_null,     pd_fmt_string,	PD_MONTHS,   	1 },
    {pd_fmt_d_sep2,   pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_null,     pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

/*-- time descriptors --*/

static date_fdesc t_desc1[] = {				   /* eg. 1:00:00pm */
    {pd_fmt_null,   pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_t_sep,  pd_fmt_number,    	PD_NUMBER,   	1 },
    {pd_fmt_t_sep,  pd_fmt_number,    	PD_NUMBER,   	2 },
    {pd_fmt_null,   pd_fmt_string,     	PD_AMPM,   	3 },
    {pd_fmt_null,   pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc t_desc2[] = {				   /* eg. 13:00:00 */
    {pd_fmt_null,   pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_t_sep,  pd_fmt_number,    	PD_NUMBER,   	1 },
    {pd_fmt_t_sep,  pd_fmt_number,    	PD_NUMBER,   	2 },
    {pd_fmt_null,   pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc t_desc3[] = {				    /* eg. 1:00pm */
    {pd_fmt_null,   pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_t_sep,  pd_fmt_number,    	PD_NUMBER,   	1 },
    {pd_fmt_null,   pd_fmt_string,     	PD_AMPM,   	3 },
    {pd_fmt_null,   pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc t_desc4[] = {				    /* eg. 13:00 */
    {pd_fmt_null,   pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_t_sep,  pd_fmt_number,    	PD_NUMBER,   	1 },
    {pd_fmt_null,   pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc t_desc5[] = {				    /* eg. 1pm */
    {pd_fmt_null,   pd_fmt_number,  	PD_NUMBER,   	0 },
    {pd_fmt_null,   pd_fmt_string,     	PD_AMPM,   	3 },
    {pd_fmt_null,   pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

/*-- possible dates & times --*/

/*
 * NOTE - for all the below time/date descriptors, we
 * employ a greedy mechanism - always try longest match first.
 */

/* this is the order we try to parse a date */
static date_fdesc *possible_dates[] = {	
    d_desc1, d_desc2,
    d_desc3, d_desc4,
    d_desc5, d_desc6,
    NULL
    } ;

/* this is the order we try to parse a time */
static date_fdesc *possible_times[] = {
    t_desc1, t_desc2,
    t_desc3, t_desc4,
    t_desc5, NULL
    } ;

/* this is the order we try to parse a 12 hour time */
static date_fdesc *possible_times12[] = {
    t_desc1, t_desc3,
    t_desc5, NULL
    } ;

/* this is the order we try to parse a time */
static date_fdesc *possible_times24[] = {
    t_desc2, t_desc4,
    NULL
    } ;


/*-- exported routines --*/

/*
 * Name: 	ParseDate
 *			will parse the input string (null terminated) for a
 *			date. Valid dates include:
 *				2,June,1989    6/2/89	   6/2
 *			Full details of formats are documented in pdate.txt,
 *			note that Country Information will be used.
 *		
 * Args:	PTCHAR inbuf - string to parse
 *		PLONG time  - will contain time in seconds since midnight 1/1/70
 *			      corresponding to the date if successfully parsed
 *			      (assuming time=midnight). Undefined otherwise.
 *		PUSHORT parselen - length of string parsed
 *		USHORT reserved - not used for now, must be zero.
 *			
 * Returns:	0 if parse successfully,
 *		ERROR_BAD_ARGUMENTS - cannot parse illegal date/time format
 *		ERROR_GEN_FAILURE   - internal error
 * Globals: 	Indirectly, all date/time descriptors, month/year info in this
 *		file. No globals outside of this file is used.
 * Statics:	(none) - but see setup_data()
 * Remarks:	(none)
 * Updates:	(none)
 */
DWORD
ParseDate(
    PTCHAR inbuf,
    time_t * time,
    PDWORD parselen,
    DWORD  reserved
    )
{
    TCHAR *buffer, *local_inbuf, *nextchr ;
    TCHAR *freep;			/* pointer to buffer malloc'd by
					   setup data */
    DWORD res ;

    /* pacify compiler */
    if (reserved) ;

    /* will grab memory, setup d_desc, t_desc, local_inbuf */
    if (setup_data(&buffer,&freep,SLIST_BUFSIZ,&local_inbuf,inbuf,0,parselen)
		!= 0)
    {
	return ERROR_GEN_FAILURE;
    }

    /* call the worker function */
    res = WParseDate(possible_dates,NULL,local_inbuf,&nextchr,(time_t *) time,
                     SECONDS_SINCE_1970);

    *parselen += (DWORD)(nextchr - local_inbuf);

    free(freep);
    return(res);
}

/*
 * Name: 	ParseTime
 *			will parse the input string (null terminated) for a
 *			time. Valid times include:
 *				2pm    14:00    2:00P.M.
 *			Full details of formats are documented in pdate.txt,
 *			note that Country Information will be used.
 *		
 * Args:	PTCHAR inbuf - string to parse
 *		PLONG time  - will contain time in seconds since midnight 1/1/70
 *			      corresponding to the date if successfully parsed
 *			      (assuming day=today). If the time has already
 *			      passed for today, we'll take tomorrow. Time is
 *			      not defined if the parsing fails.
 *		PUSHORT parselen - length of string parsed
 *		USHORT reserved - not used for now, must be zero.
 *			
 * Returns:	0 if parse successfully,
 *		ERROR_BAD_ARGUMENTS - cannot parse illegal date/time format
 *		ERROR_GEN_FAILURE   - internal error
 * Globals: 	Indirectly, all date/time descriptors, month/year info in this
 *		file. No globals outside of this file is used.
 * Statics:	(none) - but see setup_data()
 * Remarks:	(none)
 * Updates:	(none)
 */
DWORD
ParseTime(
    PTCHAR inbuf,
    time_t * time,
    PDWORD parselen,
    DWORD  reserved
    )
{
    TCHAR *buffer, *local_inbuf, *nextchr ;
    TCHAR *freep;			/* pointer to buffer malloc'd by
					   setup data */
    DWORD res ;

    /* pacify compiler */
    if (reserved) ;

    /* will grab memory, setup d_desc, t_desc, local_inbuf */
    if (setup_data(&buffer,&freep,SLIST_BUFSIZ,&local_inbuf,inbuf,0,parselen)
		!= 0)
	return(ERROR_GEN_FAILURE) ;

    /* call the worker function */
    res = WParseDate(NULL,possible_times,local_inbuf,&nextchr,time,
                     SECONDS_SINCE_1970 ) ;
    *parselen += (DWORD) (nextchr - local_inbuf) ;
    free(freep) ;
    return(res) ;
}

/*
 * Name: 	ParseTime12
 *			same as ParseTime, except only 12 hour formats
 *			2:00pm 	is ok, 2:00 is not.
 */
DWORD
ParseTime12(
    PTCHAR inbuf,
    time_t * time,
    PDWORD parselen,
    DWORD  reserved
    )
{
    TCHAR *buffer, *local_inbuf, *nextchr ;
    TCHAR *freep;			/* pointer to buffer malloc'd by
					   setup data */
    DWORD res ;

    /* pacify compiler */
    if (reserved) ;

    /* will grab memory, setup d_desc, t_desc, local_inbuf */
    if (setup_data(&buffer,&freep,SLIST_BUFSIZ,&local_inbuf,inbuf,0,parselen)
		!= 0)
	return(ERROR_GEN_FAILURE) ;

    /* call the worker function */
    res = WParseDate(NULL,possible_times12,local_inbuf,&nextchr,time,
                     SECONDS_SINCE_1970 ) ;
    *parselen += (DWORD) (nextchr - local_inbuf) ;
    free(freep) ;
    return(res) ;
}

/*
 * Name: 	ParseTime24
 *			same as ParseTime, except only 24 hour formats
 *			2:00 	is ok, 2:00am is not.
 */
DWORD
ParseTime24(
    PTCHAR inbuf,
    time_t * time,
    PDWORD parselen,
    DWORD  reserved
    )
{
    TCHAR *buffer, *local_inbuf, *nextchr ;
    TCHAR *freep;			/* pointer to buffer malloc'd by
					   setup data */
    DWORD res ;

    /* pacify compiler */
    if (reserved) ;

    /* will grab memory, setup d_desc, t_desc, local_inbuf */
    if (setup_data(&buffer,&freep,SLIST_BUFSIZ,&local_inbuf,inbuf,0,parselen)
		!= 0)
	return(ERROR_GEN_FAILURE) ;

    /* call the worker function */
    res = WParseDate(NULL,possible_times24,local_inbuf,&nextchr,time,
                     SECONDS_SINCE_1970 ) ;
    *parselen += (DWORD) (nextchr - local_inbuf) ;
    free(freep) ;
    return(res) ;
}


/*-- internal routines for setting up & reading formats --*/

/*
 * setup the field descriptors for date and time,
 * using info from DosGetCtryInfo()
 *
 * we also grab memory here, & split it into 2 - first
 * part for the above, second part for our local copy of
 * the input string in inbuf.
 *
 * side effects - update bufferp, local_inbuf, parselen,
 *     		  and the allocated memory is initialised.
 */
DWORD
setup_data(
    TCHAR  **bufferp,
    TCHAR  **freep,
    DWORD  slist_bufsiz,
    TCHAR  ** local_inbuf,
    LPTSTR inbuf,
    SHORT  country,
    PDWORD parselen
    )
{
    DWORD               bytesread ;
    static short        first_time = TRUE ;
    MY_COUNTRY_INFO     country_info ;

    UNREFERENCED_PARAMETER(country);

    /* skip white space */
    inbuf += (*parselen = _tcsspn(inbuf,WHITE_SPACE)) ;

    /* grab memory */
    if ( (*bufferp = malloc(SLIST_BUFSIZ+(_tcslen(inbuf)+1)*sizeof(TCHAR))) == NULL )
	return(ERROR_GEN_FAILURE) ;

    *freep = *bufferp;

    /*
     * setup local_inbuf
     */
    *local_inbuf  = (TCHAR*)(((LPBYTE)*bufferp) + slist_bufsiz) ;
    _tcscpy((PTCHAR)*local_inbuf, inbuf) ;

    /*
     * Get strings for AM/PM
     */
    if (ILUI_setup_listW(*bufferp,slist_bufsiz,4,&bytesread,ampm_data,ampm_list))
    {
	free(*bufferp) ;
	return(PD_ERROR_INTERNAL) ;
    }
    slist_bufsiz  -= bytesread ;
    *bufferp  = (TCHAR*)(((LPBYTE)*bufferp) + bytesread) ;

    /*
     * Get strings for months
     */
    if (ILUI_setup_listW(*bufferp,slist_bufsiz,MONTHS_IN_YEAR,&bytesread,
	months_data,months_list))
    {
	free(*bufferp);
	return(PD_ERROR_INTERNAL) ;
    }
	
    /*
     * no need to the rest if already done
     */
    if (!first_time)
	return(0) ;
    first_time = FALSE ;

    /*
     * Get country info.
     */
    GetInternationalInfo(&country_info) ;

    _tcscpy( LUI_usr_am, country_info.szAMString );
    _tcscpy( LUI_usr_pm, country_info.szPMString );

    /*
     * append date separator
     */
    if (_tcschr(pd_fmt_d_sep1,country_info.szDateSeparator[0]) == NULL)
   	_tcscat(pd_fmt_d_sep1,country_info.szDateSeparator) ;
    if (_tcschr(pd_fmt_d_sep2,country_info.szDateSeparator[0]) == NULL)
   	_tcscat(pd_fmt_d_sep2,country_info.szDateSeparator) ;
    if (_tcschr(pd_fmt_string,country_info.szDateSeparator[0]) == NULL)
   	_tcscat(pd_fmt_string,country_info.szDateSeparator) ;

    /*
     * append time separator
     */
    if (_tcschr(pd_fmt_t_sep,country_info.szTimeSeparator[0]) == NULL)
   	_tcscat(pd_fmt_t_sep,country_info.szTimeSeparator) ;
    if (_tcschr(pd_fmt_string,country_info.szTimeSeparator[0]) == NULL)
   	_tcscat(pd_fmt_string,country_info.szTimeSeparator) ;

    _tcscat(pd_fmt_string,TEXT("]")) ;	/* terminate string format */

    /* swap order of fields as needed */
    switch (country_info.fsDateFmt)  {
  	case 0x0000:
  	    /* this is the initialised state */
  	    break ;
  	case 0x0001:
  	    d_desc1[0].pos = d_desc4[0].pos = 0 ;
  	    d_desc1[1].pos = d_desc4[1].pos = 1 ;
  	    break ;
  	case 0x0002:
  	    d_desc1[0].pos = d_desc2[0].pos = 2 ;
  	    d_desc1[1].pos = d_desc2[1].pos = 1 ;
  	    d_desc1[2].pos = d_desc2[2].pos = 0 ;
  	    break ;
  	default:
  	    break ;	/* assume USA */
    }
    return(0) ;
}


/*
 * try reading inbuf using the descriptors in d_desc & t_desc.
 * Returns 0 if ok, error code otherwise.
 *
 * inbuf   -> string to parse
 * d_desc  -> array of date descriptors
 * t_desc  -> array of time descriptors
 * nextchr -> will point to end of string parsed
 * time    -> will contain time parsed
 * nTimeType-> Determines what kind of time is returned.
 *             SECONDS_SINCE_1970 - the number of secs since 1/1/70
 *             SECONDS_SINCE_START_OF_DAY - the number of secs since midnight
 */
DWORD
WParseDate(
    date_fdesc **d_desc,
    date_fdesc **t_desc,
    TCHAR	*inbuf,
    TCHAR       **nextchr,
    time_t      *time,
    USHORT       nTimeType
    )
{
    short 	d_index, t_index, res ;
    date_data 	d_data, t_data ;

    /*
     * initialise
     */
    *nextchr = inbuf ;
    memset((TCHAR  *)d_data,0,sizeof(d_data)) ;
    memset((TCHAR  *)t_data,0,sizeof(t_data)) ;
    d_data[YEARS] = (SHORT)0xffff;

    /*
     * try all date followed by time combinations
     */
    if (d_desc != NULL)
	for (d_index = 0; d_desc[d_index] != NULL; d_index++)
	{
	    if ((res = read_format(nextchr,d_desc[d_index],d_data)) == 0)
	    {
		/* if time not required, quit here */
		if (t_desc == NULL)
		{
		    return ( convert_to_abs(d_data,t_data,time) ) ;
		}

		/* else we have match for date, see if we can do time */
		for (t_index = 0; t_desc[t_index] != NULL; t_index++)
		{
		    res = read_format(nextchr,t_desc[t_index],t_data) ;
		    if (res == 0 || res == PD_ERROR_END_OF_INPUT)
		    {
			return ( convert_to_abs(d_data,t_data,time) ) ;
		    }
		}
		/* exhausted times formats, backtrack & try next date format */
		*nextchr = inbuf ;
	    }
	}

    /*
     * reset & try all time followed by date combinations
     */
    *nextchr = inbuf ;
    memset((TCHAR  *)d_data,0,sizeof(d_data)) ;
    d_data[YEARS] = (SHORT)0xffff;
    if (t_desc != NULL)
	for (t_index = 0; t_desc[t_index] != NULL; t_index++)
	{
	    if ((res = read_format(nextchr,t_desc[t_index],t_data)) == 0)
	    {
		/* if date not required, quit here */
		if (d_desc == NULL)
		{
                    if (  ( nTimeType == SECONDS_SINCE_START_OF_DAY )
                       && d_desc == NULL )
                        return ( convert_to_secs( t_data, time ) ) ;
                    else
    		  	return ( convert_to_abs(d_data,t_data,time) ) ;
		}

		/* we have match for time, see if we can do date */
		for (d_index = 0; d_desc[d_index] != NULL; d_index++)
		{
		    res = read_format(nextchr,d_desc[d_index],d_data) ;
		    if (res == 0 || res == PD_ERROR_END_OF_INPUT)
		    {
                        if (  ( nTimeType == SECONDS_SINCE_START_OF_DAY )
                           && d_desc == NULL )
                            return ( convert_to_secs( t_data, time ) ) ;
                        else
    		     	    return ( convert_to_abs(d_data,t_data,time) ) ;
		    }
		}
		/* exhausted date formats, back track, try next time format */
		*nextchr = inbuf ;
	    }
	}
    *nextchr = inbuf ;
    return(ERROR_BAD_ARGUMENTS) ;	 /* we give up */
}

/*
 * try reading inbuf using the descriptor desc.
 * the fields read are stored in order in 'data'.
 * Returns 0 if ok, error code otherwise.
 */
SHORT
read_format(
    TCHAR * * inbuf,
    date_fdesc * desc,
    date_data  data
    )
{
    TCHAR	buffer[128] ;
    TCHAR	*ptr, *oldptr ;
    date_fdesc 	*entry ;
    DWORD       res;
    SHORT	i, count ;

    /*
     * initialize & preliminary checks
     */
    if (*inbuf == NULL || **inbuf==NULLC)
	return(PD_ERROR_END_OF_INPUT) ;
    ptr = *inbuf ;
    oldptr = NULL ;


    /*
     * for all fields => we break out when hit END_MARKER
     */
    for (i=0 ; ; i++)
    {
	LONG value_read ;

	entry = &desc[i] ;
	if (entry->typ == PD_END_MARKER || *ptr == '\0' )
	    break ;  /* no more descriptors */

	/*
	 * find the separator  - the ptr may or may not have moved
	 * as a result of the last read operation. If we read a number,
	 * scanf() would have stopped at the first non-numeric char, which
	 * may not be the separator. We would in this case have moved the
	 * ptr ourselves after the scanf().
	 *
	 * In the case of a string like "JAN", scanf() would have stopped at a
	 * separator and we wouldnt have moved it ourselves after the scanf().
	 * So we advance it now to the separator.
	 */
	if (ptr == oldptr) /* ptr unmoved, we need to move it */
	{
	    if (entry->sep[0] == NULLC)
	        return(PD_ERROR_INTERNAL) ;      /* cant have NULL separator */
	    if ((ptr = (TCHAR *)_tcspbrk(ptr,entry->sep)) == NULL)
		return(PD_ERROR_NO_MATCH) ;	 /* cant find separator */
	    ptr++;
	}
	else   /* already moved */
	{
	    if (entry->sep[0] != NULLC)      /* for NULL separator, do nothing */
	    {
		if (*ptr && !_tcschr(entry->sep,*ptr)) /* are we at separator */
		    return(PD_ERROR_NO_MATCH) ; /* cant find separator        */
		if (*ptr)
			ptr++;	/* advance past separator     */
	    }
	}

	/*
	 * if we get here, we are past the separator, can go read an item
	 */
	ptr += _tcsspn(ptr,WHITE_SPACE) ;    /* skip white space       */
	if ((count = (SHORT)MySscanf(ptr, entry->fmt, &buffer[0])) != 1)
	    return(PD_ERROR_NO_MATCH) ;

	/*
	 * successfully read an item, get value & update pointers
	 */
	res = 0 ;
	if (entry->typ == PD_AMPM)
	    res = ILUI_traverse_slistW(buffer,ampm_list,&value_read) ;
	else if (entry->typ == PD_MONTHS)
	    res = ILUI_traverse_slistW(buffer,months_list,&value_read) ;
	else
	    value_read = (LONG) buffer[0];
	if (res || value_read < 0)
	    return(PD_ERROR_NO_MATCH) ;

	data[entry->pos] = value_read ;
	oldptr = ptr ;
	if (entry->typ == PD_NUMBER)
	    ptr += _tcsspn(ptr,DIGITS) ;  /* skip past number */
    }

    /*
     * no more descriptors, see if we are at end
     */
    if (ptr == oldptr) /* ptr unmoved, we need to move it */
    {
	/* need to advance to WHITE_SPACE or end */
	if ((ptr = (TCHAR *)_tcspbrk(oldptr, WHITE_SPACE)) == NULL)
	{
	    ptr = (TCHAR *)_tcschr(oldptr, NULLC); /* if not found, take end */
	}
    }

    ptr += _tcsspn(ptr,WHITE_SPACE) ;	/* skip white space */
    *inbuf = ptr ;	/* update inbuf */
    return(0) ;		/* SUCCESSFUL   */
}


/*---- time conversion ----*/

#define IS_LEAP(y)         ((y % 4 == 0) && (y % 100 != 0 || y % 400 == 0))
#define DAYS_IN_YEAR(y)    (IS_LEAP(y) ? 366 : 365)
#define DAYS_IN_MONTH(m,y) (IS_LEAP(y) ? _days_month_leap[m] : _days_month[m])
#define SECS_IN_DAY	   (60L * 60L * 24L)
#define SECS_IN_HOUR	   (60L * 60L)
#define SECS_IN_MINUTE	   (60L)

static short _days_month_leap[] = { 31,29,31,30,31,30,31,31,30,31,30,31 } ;
static short _days_month[]      = { 31,28,31,30,31,30,31,31,30,31,30,31 } ;

/*
 * convert date & time in d_data & t_data (these in dd mm yy and
 * HH MM SS AMPM) to the number of seconds since 1/1/70.
 * The result is stored in timep.
 * Returns 0 if ok, error code otherwise.
 *
 * Note - date is either completely unset (all zero),
 * 	  or is fully set, or has day and months set with
 *	  year==0.
 */
DWORD
convert_to_abs(
    date_data d_data,
    date_data t_data,
    time_t * timep
    )
{
    time_t     total_secs, current_time;
    struct tm  time_struct;

    *timep = 0L ;

    if (convert_to_24hr(t_data) != 0)
    {
	return ERROR_BAD_ARGUMENTS;
    }

    //
    // time_now returns a DWORD.  time_t is the size of an int, which is
    // platform-dependent.  Cast it to the appropriate type/size -- this
    // cast should preserve the sign.
    //

    current_time = (time_t) time_now();

    net_gmtime(&current_time, &time_struct);

    /* check for default values */
    if (d_data[DAYS] == 0 && d_data[MONTHS] == 0 && d_data[YEARS] == (SHORT)0xffff)
    {
	/* whole date's been left out */
	d_data[DAYS] = time_struct.tm_mday ;
	d_data[MONTHS] = time_struct.tm_mon + 1 ;
	d_data[YEARS] = time_struct.tm_year ;
	total_secs = seconds_since_1970(d_data,t_data) ;
	if (total_secs < 0)
	    return(ERROR_BAD_ARGUMENTS) ;
	if (total_secs < current_time)
	{
	    /*
	     * if the time parsed is earlier than the current time,
	     * and the date has been left out, we advance to the
	     * next day.
	     */
	    advance_date(d_data) ;
	    total_secs = seconds_since_1970(d_data,t_data) ;
	}
    }
    else if (d_data[YEARS] == (SHORT)0xffff && d_data[MONTHS] != 0 && d_data[DAYS] != 0)
    {
	/* year's been left out */
	d_data[YEARS] = time_struct.tm_year ;
	total_secs = seconds_since_1970(d_data,t_data) ;
	if (total_secs < current_time)
	{
	    ++d_data[YEARS] ;
	    total_secs = seconds_since_1970(d_data,t_data) ;
	}
    }
    else
    {
	total_secs = seconds_since_1970(d_data,t_data) ; /* no need defaults */
    }

    if (total_secs < 0)
	return(ERROR_BAD_ARGUMENTS) ;
    *timep = total_secs ;
    return(0) ;
}

/*
 * convert time in t_data ( this HH MM SS AMPM) to the number of seconds
 * since midnight.
 * The result is stored in timep.
 * Returns 0 if ok, error code otherwise.
 *
 * Note - date is either completely unset (all zero),
 * 	  or is fully set, or has day and months set with
 *	  year==0.
 */
DWORD
convert_to_secs(
    date_data t_data,
    time_t * timep
    )
{
    if (convert_to_24hr(t_data) != 0)
	return(ERROR_BAD_ARGUMENTS) ;

    *timep =  (time_t) t_data[HOURS] * SECS_IN_HOUR +
	      (time_t) t_data[MINUTES] * SECS_IN_MINUTE +
	      (time_t) t_data[SECONDS] ;

    return (0) ;
}

/*
 * count the total number of seconds since 1/1/70
 */
time_t
seconds_since_1970(
    date_data d_data,
    date_data t_data
    )
{
    time_t days ;

    days = days_so_far(d_data[DAYS],d_data[MONTHS],d_data[YEARS]) ;
    if (days < 0)
	return(-1) ;
    return ( days * SECS_IN_DAY +
	     (time_t) t_data[HOURS] * SECS_IN_HOUR +
	     (time_t) t_data[MINUTES] * SECS_IN_MINUTE +
	     (time_t) t_data[SECONDS] ) ;
}

/*
 * given day/month/year, returns how many days
 * have passed since 1/1/70
 * Returns  -1 if there is an error.
 */
time_t
days_so_far(
    int d,
    int m,
    int y
    )
{
    int tmp_year ;
    time_t count = 0 ;

    /* check for validity.  Note that (y >= 100) for year >= 2000 */
    if (y < 0) return(-1) ;
    if (m < 1 || m > 12) return(-1) ;
    if (d < 1) return(-1) ;

    /* a bit of intelligence -- the year can be either 2- or 4-digit */
    if (y < 70)
        y += 2000;
    else if (y < 200)
        y += 1900;

    if (d > DAYS_IN_MONTH(m-1,y)) return(-1) ;

    /* count the days due to years */
    tmp_year = y-1 ;
    while (tmp_year >= 1970)
    {
	count += DAYS_IN_YEAR(tmp_year) ;  /* agreed, this could be faster */
	--tmp_year ;
    }

    /* count the days due to months */
    while (m > 1)
    {
	count += DAYS_IN_MONTH(m-2,y) ;  /* agreed, this could be faster */
	--m ;
    }

    /* finally, the days */
    count += d - 1 ;
    return(count) ;
}

/*
 * convert time in t_data to the 24 hour format
 * returns 0 if ok, -1 otherwise.
 */
SHORT
convert_to_24hr(
    date_data t_data
    )
{
    /* no negative values allowed */
    if (t_data[HOURS] < 0 || t_data[MINUTES] < 0 || t_data[SECONDS] < 0)
	return(-1) ;

    /* check minutes and seconds */
    if ( t_data[MINUTES] > 59 || t_data[SECONDS] > 59)
	return(-1) ;

    /* now check the hour & convert if need */
    if (t_data[AMPM] == PD_PM)
    {
	if (t_data[HOURS] > 12 || t_data[HOURS] < 1)
	    return(-1) ;
	t_data[HOURS] += 12 ;
	if (t_data[HOURS] == 24)
	    t_data[HOURS] = 12 ;
    }
    else if (t_data[AMPM] == PD_AM)
    {
	if (t_data[HOURS] > 12 || t_data[HOURS] < 1)
	    return(-1) ;
	if (t_data[HOURS] == 12)
	    t_data[HOURS] = 0 ;
    }
    else if (t_data[AMPM] == PD_24HR)
    {
	if (t_data[HOURS] > 23)
            if (t_data[HOURS] != 24 || t_data[MINUTES] != 0 || t_data[SECONDS] != 0)
            {
	        return(-1) ;
            }
    }
    else
	return(-1) ;

    return( 0 ) ;
}

/*
 * advance the date in d_data by one day
 */
VOID
advance_date(
    date_data d_data
    )
{
    int year = d_data[YEARS];

    /* a bit of intelligence -- the year can be either 2- or 4-digit */
    if (year < 70)
        year += 2000;
    else if (year < 200)
        year += 1900;

    /* assume all values already in valid range */
    if ( d_data[DAYS] != DAYS_IN_MONTH(d_data[MONTHS]-1,year) )
	++d_data[DAYS] ;		/* increase day */
    else				/* can't increase day */
    {
	d_data[DAYS] = 1 ;		/* set to 1st, try increase month */
	if (d_data[MONTHS] != 12)
	    ++d_data[MONTHS] ;		/* increase month */
	else				/* can't increase month */
	{
	    d_data[MONTHS] = 1 ;	/* set to Jan, and */
	    ++d_data[YEARS] ;		/* increase year   */
	}
    }
}

#define INTERNATIONAL_SECTION      TEXT("intl")
#define TIME_SEPARATOR_KEY         TEXT("sTime")
#define DATE_SEPARATOR_KEY         TEXT("sDate")
#define SHORT_DATE_FORMAT_KEY      TEXT("sShortDate")
#define AM_STRING_KEY              TEXT("s1159")
#define PM_STRING_KEY              TEXT("s2359")

/*
 * reads the time/date separators & date format info from
 * the system.
 */
void GetInternationalInfo(MY_COUNTRY_INFO *pcountry_info)
{
    TCHAR  szDateFormat[256] ;

    /*
     * get the time separator, ignore return val since we have default
     */
    (void)   GetProfileStringW(INTERNATIONAL_SECTION,
                               TIME_SEPARATOR_KEY,
                               TEXT(":"),
                               pcountry_info->szTimeSeparator,
                               sizeof(pcountry_info->szTimeSeparator)) ;

    /*
     * get the date separator, ignore return val since we have default
     */
    (void)   GetProfileStringW(INTERNATIONAL_SECTION,
                               DATE_SEPARATOR_KEY,
                               TEXT("/"),
                               pcountry_info->szDateSeparator,
                               DIMENSION(pcountry_info->szDateSeparator)) ;


    /*
     * get the AM string, ignore return val since we have default
     */
    (void)   GetProfileStringW(INTERNATIONAL_SECTION,
                               AM_STRING_KEY,
                               TEXT("AM"),
                               pcountry_info->szAMString,
                               DIMENSION(pcountry_info->szAMString)) ;

    /*
     * get the PM string, ignore return val since we have default
     */
    (void)   GetProfileStringW(INTERNATIONAL_SECTION,
                               PM_STRING_KEY,
                               TEXT("PM"),
                               pcountry_info->szPMString,
                               DIMENSION(pcountry_info->szPMString)) ;

    /*
     * get the date format, ignore return val since we have default
     */
    (void)   GetProfileStringW(INTERNATIONAL_SECTION,
                               SHORT_DATE_FORMAT_KEY,
                               TEXT(""),
                               szDateFormat,
                               DIMENSION(szDateFormat)) ;

    pcountry_info->fsDateFmt = 0 ;
    if (szDateFormat[0])
    {
        TCHAR *pDay, *pMonth, *pYear ;

        pDay   = _tcspbrk(szDateFormat,TEXT("dD")) ;
        pMonth = _tcspbrk(szDateFormat,TEXT("mM")) ;
        pYear  = _tcspbrk(szDateFormat,TEXT("yY")) ;

        if (!pDay || !pMonth || !pYear)
            ;   // leave it as 0
        else if (pMonth < pDay && pDay < pYear)
            pcountry_info->fsDateFmt = 0 ;
        else if (pDay < pMonth && pMonth < pYear)
            pcountry_info->fsDateFmt = 1 ;
        else if (pYear < pMonth && pMonth < pDay)
            pcountry_info->fsDateFmt = 2 ;
        else
            ;   // leave it as 0
    }
}


INT MySscanf(TCHAR* input, TCHAR* fmt, PVOID out)
{
    TCHAR	*pch = input;
    TCHAR	*pchWhite = fmt+2;
    TCHAR	*pchT;
    TCHAR	tbuf[20];
    int		i = 0;

    if (_tcscmp(fmt, TEXT("%d")) == 0) {
	while (*pch != NULLC && _istdigit(*pch)) {
	    i = i * 10 + (*pch++ - TEXT('0'));
	}
	if (i >= 0x00010000)	// assume short
	    i = 0x0000ffff;
	*(int*)out = i;
    }
    else if (_tcsncmp(fmt, TEXT("%["), 2) == 0) {
	*(TCHAR*)out = NULLC;
	_tcscpy(tbuf, pchWhite);
	pchT = _tcschr(tbuf, TEXT(']'));
	if (pchT != NULL)
	    *pchT = NULLC;
	else
	    return 0;
	i = _tcscspn(input, tbuf);
	if (i != 0) {
	    _tcsncpy(out, input, i);
	    pchT = out;
	    *(pchT+i) = NULLC;
	    return 1;
	}
	return 0;
    }
#if DBG
    else {
	*(ULONG*)out = 0;
	return 0;
    }
#endif
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\luiint.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    luiint.c

Abstract:

    This module provides routines for setting up search lists of string/value
    pairs using messages in the NET.MSG message file, and for traversing
    such a search list.

Author:

    Dan Hinsley    (danhi)  06-Jun-1991

Environment:

    User Mode - Win32

Revision History:

    10-Jul-1989     chuckc
	Created

    24-Apr-1991     danhi
	32 bit NT version

    06-Jun-1991     Danhi
	Sweep to conform to NT coding style

    01-Oct-1992     JohnRo
        RAID 3556: Added NetpSystemTimeToGmtTime() for DosPrint APIs.

    20-Feb-1993     YiHsinS
        Moved from netcmd\map32\search.c. And added LUI_GetMessageIns.
--*/

//
// INCLUDES
//

#include <windows.h>    // IN, LPTSTR, etc.

#include <lmcons.h>
#include <stdio.h>		
#include <tchar.h>		
#include <lmerr.h>
#include <luiint.h>
#include <netdebug.h>   // NetpAssert

#include "netascii.h"
#include "msystem.h"

/*-- routines proper --*/

/*
 * Name: 	ILUI_setup_list
 *			Given an array of 'search_list_data' (ie. msgno/value
 *			pairs), create a string/value pair using the messages
 *			in the message file.
 * Args:	char * buffer           - for holding the meesages retrieved
 *		USHORT bufsiz  		- size of the above buffer
 *		USHORT offset 		- the number of items already setup
 *					  in slist, we will offset our retrieved
 *					  string/value pais by this much.
 *		PUSHORT bytesread	- the number of bytes read into buffer
 *		searchlist_data sdata[] - input array of msgno/value pairs,
 *					  we stop when we hit a message number
 *					  of 0
 *		searchlist slist[]      - will receive the string/value pairs
 *				 	  (string will be pointers into buffer)
 * Returns:	0 if ok, NERR_BufTooSmall otherwise.
 * Globals: 	(none)
 * Statics:	(none)
 * Remarks:	WARNING! We assume the caller KNOWs that slist is big enough
 *		for the pairs to be retrieved. This can be determined statically
 *		while buffer size cannot. Hence we provide checks for the
 *		latter.
 * Updates:	(none)
 */
DWORD
ILUI_setup_listW(
    LPTSTR          buffer,
    DWORD           bufsiz,
    DWORD           offset,
    PDWORD          bytesread,
    searchlist_data sdata[],
    searchlist      slist[]
    )
{
    DWORD          err;
    unsigned int   msglen;
    int            i;

    *bytesread = 0 ;

    for ( i=0; sdata[i].msg_no != 0; i++)
    {
	if (err = LUI_GetMsgInsW(NULL, 0, buffer, bufsiz, sdata[i].msg_no,
			    (unsigned *) &msglen))
        {
	    return err;
        }

	slist[i+offset].s_str = buffer;
	slist[i+offset].val   = sdata[i].value;
	buffer += msglen + 1;
	bufsiz -= msglen + 1;
	*bytesread += (msglen + 1) * sizeof(TCHAR);
    }

    return 0;
}



/*
 * Name: 	ILUI_traverse_slist
 * 			traverse a searchlist ('slist') of string/number pairs,
 * 			and return the number matching string 'str'.
 * Args:	char * 	     pszStr - the string to search for
 *		searchlist * slist  - pointer to head of a searchlist
 *		int *        pusVal - pointer to variable that receives
 *				      the vale retrieved
 * Returns:	0 if found, -1 otherwise.
 * Globals: 	(none)
 * Statics:	(none)
 * Remarks:	(none)
 * Updates:	(none)
 */
DWORD
ILUI_traverse_slistW(
    LPTSTR     pszStr,
    searchlist *slist,
    PLONG      pusVal
    )
{
    if (!slist)
	return (DWORD) -1;
    while (slist->s_str)
    {
	if (_tcsicmp(pszStr, slist->s_str) == 0)
	{
	    *pusVal = slist->val ;
	    return 0;
	}
	++slist ;
    }
    return (DWORD) -1;
}

/*
 * Name:    LUI_GetMsgIns
 *          This routine is very similar to DOSGETMESSAGE,
 *          except it:
 *              1) looks for messages in specific files
 *                 in a specific order:
 *                 a) MESSAGE_FILE in <lanman_dir>
 *                 b) MESSAGE_FILENAME in DPATH
 *                 c) OS2MSG_FILENAME in DPATH
 *              2) guarantees a null terminates string
 *              3) will accept NULL for msglen (see below).
 * Args:    istrings : pointer to table of insert strings
 *          nstrings : number of insert strings
 *          msgbuf   : buffer to hold message retrieved
 *          bufsize  : size of buffer
 *          msgno    : message number
 *          msglen   : pointer to variable that will receive message length
 * Returns: zero if ok, the DOSGETMESSAGE error code otherwise
 * Globals: (none)
 * Statics: NetMsgFileName, OS2MsgFileName
 */

DWORD
LUI_GetMsgInsW(
    PTCHAR       *istrings,
    DWORD        nstrings,
    PTCHAR       msgbuf,
    DWORD        bufsize,
    DWORD        msgno,
    unsigned int *msglen
    )
{
    DWORD        result;
    DWORD        tmplen = 0;
    static WCHAR NetMsgFileName[PATHLEN+1] = { 0 };
    static WCHAR OS2MsgFileName[PATHLEN+1] = { 0 };

    NetpAssert( bufsize > 0 );
    *msgbuf = NULLC ;

    /* make a path to the LANMAN message file */
    if (NetMsgFileName[0] == NULLC)
    {
        wcscpy(NetMsgFileName, MESSAGE_FILENAME);
    }

    /* make a path to the OS/2 message file */
    if (OS2MsgFileName[0] == NULLC)
    {
        wcscpy(OS2MsgFileName, OS2MSG_FILENAME);
    }

    result = DosGetMessageW(istrings,
                            nstrings,
                            msgbuf,
                            bufsize - 1,
                            msgno,
                            NetMsgFileName,
                            &tmplen);

    if (result == ERROR_MR_MID_NOT_FOUND)
    {
        /* Cannot find -- try OS2 message file instead */
        result = DosGetMessageW(istrings,
                                nstrings,
                                msgbuf,
                                bufsize - 1,
                                msgno,
                                OS2MsgFileName,
                                &tmplen);
    }

    /*
     * in all DosGetMessage above we passed it bufsize-1, so we are
     * assure of at least one spare byte for the \0 terminator.
     */
    msgbuf[min(tmplen, bufsize - 1)] = NULLC;

    if (msglen != NULL)
    {
        *msglen = tmplen;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\mutil.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/***
 *  mutil.c
 *      Message utility functions used by netcmd
 *
 *  History:
 *      mm/dd/yy, who, comment
 *      06/10/87, andyh, new code
 *      04/05/88, andyh, created from util.c
 *      10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *      01/04/89, erichn, filenames now MAX_PATH_LEN LONG
 *      01/30/89, paulc, added GetMessageList
 *      05/02/89, erichn, NLS conversion
 *      05/11/89, erichn, moved misc stuff into LUI libs
 *      06/08/89, erichn, canonicalization sweep
 *      01/06/90, thomaspa, fix ReadPass off-by-one pwlen bug
 *      03/02/90, thomaspa, add canon flag to ReadPass
 *      02/20/91, danhi, change to use lm 16/32 mapping layer
 *      03/19/91, robdu, support for lm21 dcr 954, general cleanup
 */

/* Include files */

#define INCL_NOCOMMON
#define INCL_DOSFILEMGR
#define INCL_DOSQUEUES
#define INCL_DOSMISC
#define INCL_ERRORS

#include <os2.h>
#include <lmcons.h>
#include <apperr.h>
#include <apperr2.h>
#define INCL_ERROR_H
#include <lmerr.h>
#include <stdio.h>
#include <stdlib.h>
#include <lui.h>
#include "netcmds.h"
#include "nettext.h"
#include "msystem.h"


/* Constants */

/* HandType */
#define FILE_HANDLE         0
#define DEVICE_HANDLE       1

#define CHAR_DEV            0x8000
#define FULL_SUPPORT        0x0080
#define STDOUT_DEVICE       0x0002
#define DESIRED_HAND_STATE  (CHAR_DEV | FULL_SUPPORT | STDOUT_DEVICE)


/* External variables */

extern int YorN_Switch;
extern CPINFO CurrentCPInfo;

#define MAX_BUF_SIZE	4096

TCHAR	ConBuf [MAX_BUF_SIZE];


/* Forward declarations */

DWORD
DosQHandType(
    HANDLE hf,
    PWORD  pus1,
    PWORD  pus2
    );

DWORD
GetPasswdStr(
    LPTSTR  buf,
    DWORD   buflen,
    PDWORD  len
    );


/* Static variables */

static DWORD   LastError  = 0;
static TCHAR   MsgBuffer[LITTLE_BUF_SIZE];


/***    InfoSuccess
 *
 *    Just an entrypoint to InfoPrintInsHandle, used to avoid pushing
 *    the three args in every invocation.  And there are a *lot*
 *    of invocations.  Saves code space overall.
 */

VOID FASTCALL
InfoSuccess(
    VOID
    )
{
   InfoPrintInsHandle(APE_Success, 0, g_hStdOut);
}


/***
 *  I n f o P r i n t
 *
 */

VOID FASTCALL
InfoPrint(
    DWORD msg
    )
{
    InfoPrintInsHandle(msg, 0, g_hStdOut);
}

/***
 *  I n f o P r i n t I n s
 *
 */

VOID FASTCALL
InfoPrintIns(
    DWORD msg,
    DWORD nstrings
    )
{
    InfoPrintInsHandle(msg, nstrings, g_hStdOut);
}

/***
 *  I n f o P r i n t I n s T x t
 *
 *    Calls InfoPrintInsHandle with supplementary text
 */

void FASTCALL
InfoPrintInsTxt(
    DWORD  msg,
    LPTSTR text
    )
{
    IStrings[0] = text;
    InfoPrintInsHandle(msg, 1, g_hStdOut);
}

/***
 *  I n f o P r i n t I n s H a n d l e
 *
 */

void FASTCALL
InfoPrintInsHandle(
    DWORD  msg,
    DWORD  nstrings,
    HANDLE hdl
    )
{
    PrintMessage(hdl, MESSAGE_FILENAME, msg, IStrings, nstrings);
}

/***
 *  P r i n t M e s s a g e
 *
 */
DWORD FASTCALL
PrintMessage(
    HANDLE outFileHandle,
    TCHAR  *msgFileName,
    DWORD  msg,
    TCHAR  *strings[],
    DWORD  nstrings
    )
{
    DWORD  msg_len;
    DWORD  result;

    result = DosGetMessageW(strings,
                            nstrings,
                            MsgBuffer,
                            LITTLE_BUF_SIZE,
                            msg,
                            msgFileName,
                            &msg_len);

    if (result)                 /* if there was a problem   */
    {                           /* change outFile to stderr */
        outFileHandle = g_hStdErr;
    }

    DosPutMessageW(outFileHandle, MsgBuffer, TRUE);

    return result;
}


/***
 *  P r i n t M e s s a g e I f F o u n d
 *
 */
DWORD FASTCALL
PrintMessageIfFound(
    HANDLE outFileHandle,
    TCHAR  *msgFileName,
    DWORD  msg,
    TCHAR  * strings[],
    DWORD  nstrings
    )
{
    DWORD  msg_len;
    DWORD  result;

    result = DosGetMessageW(strings,
                            nstrings,
                            MsgBuffer,
                            LITTLE_BUF_SIZE,
                            msg,
                            msgFileName,
                            &msg_len);

    if (!result)             /* if ok, print it else just ignore  */
    {
	DosPutMessageW(outFileHandle, MsgBuffer, TRUE);
    }

    return result;
}


/***
 *  E r r o r P r i n t
 *
 *  nstrings ignored for non-NET errors!
 *
 */
VOID FASTCALL
ErrorPrint(
    DWORD err,
    DWORD nstrings
    )
{
    TCHAR buf[17];
    DWORD oserr = 0;

    LastError = err; /* if > NERR_BASE,NetcmdExit() prints a "more help" msg */

    if (err < NERR_BASE || err > MAX_LANMAN_MESSAGE_ID)
    {
        IStrings[0] = _ultow(err, buf, 10);
        nstrings = 1;
        oserr = err;

        err = APE_OS2Error;
    }

    {
        DWORD msg_len;

        DosGetMessageW(IStrings,
                       nstrings,
                       MsgBuffer,
                       LITTLE_BUF_SIZE,
                       err,
                       MESSAGE_FILENAME,
                       &msg_len);

        DosPutMessageW(g_hStdErr, MsgBuffer, TRUE);

        if (!oserr)
        {
            return;
        }

        DosGetMessageW(StarStrings,
                       9,
                       MsgBuffer,
                       LITTLE_BUF_SIZE,
                       oserr,
                       OS2MSG_FILENAME,
                       &msg_len);

        DosPutMessageW(g_hStdErr, MsgBuffer, TRUE);
    }
}


/***
 *  E m p t y E x i t
 *
 *  Prints a message and exits.
 *  Called when a list is empty.
 */

VOID FASTCALL
EmptyExit(
    VOID
    )
{
    InfoPrint(APE_EmptyList);
    NetcmdExit(0);
}


/***
 *  E r r o r E x i t
 *
 *  Calls ErrorPrint and exit for a given LANMAN error.
 */

VOID FASTCALL
ErrorExit(
    DWORD err
    )
{
    ErrorExitIns(err, 0);
}


/***
 *  E r r o r E x i t I n s
 *
 *  Calls ErrorPrint and exit for a given LANMAN error.
 *  Uses IStrings.
 */

VOID FASTCALL
ErrorExitIns(
    DWORD err,
    DWORD nstrings
    )
{
    ErrorPrint(err, nstrings);
    NetcmdExit(2);
}

/***
 *  E r r o r E x i t I n s T x t
 *
 */
VOID FASTCALL
ErrorExitInsTxt(
    DWORD  err,
    LPTSTR text
    )
{
    IStrings[0] = text;
    ErrorPrint(err, 1);
    NetcmdExit(2);
}



/***
 *  N e t c m d E x i t
 *
 *    Net command exit function. Should always be used instead of exit().
 *  Under the appropriate circumstances, it prints a "more help available"
 *  message.
 */

VOID FASTCALL
NetcmdExit(
    int Status
    )
{
    TCHAR  AsciiLastError[17];
    DWORD  MsgLen;

    if (LastError >= NERR_BASE && LastError <= MAX_LANMAN_MESSAGE_ID)
    {
        IStrings[0] = _ultow(LastError, AsciiLastError, 10);

        if (!DosGetMessageW(IStrings, 1, MsgBuffer, LITTLE_BUF_SIZE,
                            APE_MoreHelp, MESSAGE_FILENAME, &MsgLen))
        {
            DosPutMessageW(g_hStdErr, MsgBuffer, TRUE);
        }
    }

    MyExit(Status);
}


/***
 *  P r i n t L i n e
 *
 *  Prints the header line.
 */
VOID FASTCALL
PrintLine(
    VOID
    )
{
    /* The following code is provided in OS-specific versions to reduce     */
    /* FAPI utilization under DOS.                                                                          */

    USHORT  type;
    USHORT  attrib;

    if (DosQHandType((HANDLE) 1, &type, &attrib) ||
        type != DEVICE_HANDLE ||
        (attrib & DESIRED_HAND_STATE) != DESIRED_HAND_STATE)
    {
        WriteToCon(MSG_HYPHENS, NULL);
    }
    else if (LUI_PrintLine())
    {
	WriteToCon(MSG_HYPHENS, NULL);
    }
}

/***
 *      P r i n t D o t
 *
 *      Prints a dot, typically to indicate "I'm working".
 */

VOID FASTCALL
PrintDot(
    VOID
    )
{
    WriteToCon(DOT_STRING, NULL);
}


/***
 *  P r i n t N L
 *
 *  Prints a newline
 */

VOID FASTCALL
PrintNL(
    VOID
    )
{
    WriteToCon(TEXT("\r\n"), NULL);
}


/***
 * Y o r N
 *
 * Gets an answer to a Y/N question
 * an nstrings arg would be nice
 */

int FASTCALL
YorN(
    USHORT prompt,
    USHORT def
    )
{
    DWORD  err;

    if (YorN_Switch)
    {
        return(YorN_Switch - 2);
    }

    err = LUI_YorN(prompt, def);

    switch (err) {
    case TRUE:
    case FALSE:
        break;
    default:
        ErrorExit(err);
        break;
    }

    return err;
}


/***
 *  ReadPass()
 *      Reads a users passwd without echo
 *
 *  Args:
 *      pass - where to put pass
 *          NOTE: buffer for pass should be passlen+1 in size.
 *      passlen - max length of password
 *      confirm - confirm pass if true
 *      prompt - prompt to print, NULL for default
 *      nstrings - number of insertion strings in IStrings on entry
 *      cannon - canonicalize password if true.
 *
 *  Returns:
 */
VOID FASTCALL
ReadPass(
    TCHAR  pass[],
    DWORD  passlen,
    DWORD  confirm,
    DWORD  prompt,
    DWORD  nstrings,
    BOOL   canon
    )
{
    DWORD                   err;
    DWORD                   len;
    TCHAR                   cpass[PWLEN+1]; /* confirmation passwd */
    int                     count;

    passlen++;  /* one extra for null terminator */
    for (count = LOOP_LIMIT; count; count--)
    {
        InfoPrintIns((prompt ? prompt : APE_UtilPasswd), nstrings);

        if (err = GetPasswdStr(pass, passlen, &len))
        {
            /* too LONG */
            InfoPrint(APE_UtilInvalidPass);
            continue;
        }

        if (canon && (err = LUI_CanonPassword(pass)))
        {
            /* not good */
            InfoPrint(APE_UtilInvalidPass);
            continue;
        }
        if (! confirm)
            return;

        /* password confirmation */
        InfoPrint(APE_UtilConfirm);

        if (err = GetPasswdStr(cpass, passlen, &len))
        {
            /* too LONG */
            InfoPrint(APE_UtilInvalidPass);
            ClearStringW(cpass) ;
            continue;
        }

        if (canon && (err = LUI_CanonPassword(cpass)))
        {
            /* not good */
            InfoPrint(APE_UtilInvalidPass);
            ClearStringW(cpass) ;
            continue;
        }

        if (_tcscmp(pass, cpass))
        {
            InfoPrint(APE_UtilNomatch);
            ClearStringW(cpass) ;
            continue;
        }

        ClearStringW(cpass) ;
        return;
    }
    /***
     *  Only get here if user blew if LOOP_LIMIT times
     */
    ErrorExit(APE_NoGoodPass);
}


/***
 *  PromptForString()
 *      Prompts the user for a string.
 *
 *  Args:
 *      msgid	- id of prompt message
 *	buffer  - buffer to receive string
 *      bufsiz  - sizeof buffer
 *
 *  Returns:
 */
VOID FASTCALL
PromptForString(
    DWORD  msgid,
    LPTSTR buffer,
    DWORD  bufsiz
    )
{
    DWORD                   err;
    DWORD                   len;
    TCHAR                   terminator;
    TCHAR                   szLen[16] ;

    InfoPrint(msgid);

    while (err = GetString(buffer, bufsiz, &len, &terminator))
    {
	if (err == NERR_BufTooSmall)
        {
            InfoPrintInsTxt(APE_StringTooLong, _ultow(bufsiz, szLen, 10));
        }
	else
        {
	    ErrorExit(err);
        }
    }
    return;
}

/*
** There is no need to have these functions in the Chinese/Korean
** cases, as there are no half-width varients used in the console
** in those languages (at least, let's hope so.)  However, in the
** interests of a single binary, let's put them in with a CP/932 check.
**
** FloydR 7/10/95
*/
/***************************************************************************\
* BOOL IsFullWidth(WCHAR wch)
*
* Determine if the given Unicode char is fullwidth or not.
*
* History:
* 04-08-92 ShunK       Created.
\***************************************************************************/

BOOL IsFullWidth(WCHAR wch)
{

    /* Assert cp == double byte codepage */
    if (wch <= 0x007f || (wch >= 0xff60 && wch <= 0xff9f))
        return(FALSE);	// Half width.
    else if (wch >= 0x300)
        return(TRUE);	// Full width.
    else
        return(FALSE);	// Half width.
}



/***************************************************************************\
* DWORD SizeOfHalfWidthString(PWCHAR pwch)
*
* Determine width of the given Unicode string in console characters,
* adjusting for half-width chars.
*
* History:
* 08-08-93 FloydR      Created.
\***************************************************************************/
DWORD
SizeOfHalfWidthString(
    PWCHAR pwch
    )
{
    DWORD    c=0;
    DWORD    cp;

    switch (cp=GetConsoleOutputCP())
    {
	case 932:
	case 936:
	case 949:
	case 950:
	    while (*pwch)
            {
		if (IsFullWidth(*pwch))
                {
		    c += 2;
                }
		else
                {
		    c++;
                }

		pwch++;
	    }

	    return c;

	default:
	    return wcslen(pwch);
    }
}


VOID FASTCALL
GetMessageList(
    USHORT      usNumMsg,
    MESSAGELIST Buffer,
    DWORD       *pusMaxActLength
    )
{
    DWORD            Err;
    DWORD            MaxMsgLen = 0;
    MESSAGE          *pMaxMsg;
    MESSAGE          *pMsg;
    DWORD            ThisMsgLen;

#ifdef DEBUG
    USHORT           MallocBytes = 0;
#endif

    pMaxMsg = &Buffer[usNumMsg];

    for (pMsg = Buffer; pMsg < pMaxMsg; pMsg++)
            pMsg->msg_text = NULL;

    for (pMsg = Buffer; pMsg < pMaxMsg; pMsg++)
    {
#ifdef DEBUG
        WriteToCon(TEXT("GetMessageList(): Reading msgID %u\r\n"),pMsg->msg_number);
#endif
        if ((pMsg->msg_text = malloc(MSGLST_MAXLEN)) == NULL)
            ErrorExit(ERROR_NOT_ENOUGH_MEMORY);

        Err = LUI_GetMsgInsW(NULL, 0, pMsg->msg_text, MSGLST_MAXLEN,
                             pMsg->msg_number, &ThisMsgLen);
        if (Err)
        {
            ErrorExit(Err);
        }

#ifdef DEBUG
        MallocBytes += (ThisMsgLen + 1) * sizeof(TCHAR);
#endif

        ThisMsgLen = max(ThisMsgLen, SizeOfHalfWidthString(pMsg->msg_text));

        if (ThisMsgLen > MaxMsgLen)
            MaxMsgLen = ThisMsgLen;
    }

    *pusMaxActLength = MaxMsgLen;

#ifdef DEBUG
    WriteToCon(TEXT("GetMessageList(): NumMsg = %d, MaxActLen=%d, MallocBytes = %d\r\n"),
        usNumMsg, MaxMsgLen, MallocBytes);
#endif

    return;
}


VOID FASTCALL
FreeMessageList(
    USHORT      usNumMsg,
    MESSAGELIST MsgList
    )
{
    USHORT i;

    for (i = 0; i < usNumMsg; i++)
    {
        if (MsgList[i].msg_text != NULL)
        {
            free(MsgList[i].msg_text);
        }
    }

    return;
}


VOID
WriteToCon(
    LPWSTR fmt,
    ...
    )
{
    va_list     args;

    va_start( args, fmt );
    _vsntprintf( ConBuf, MAX_BUF_SIZE, fmt, args );
    va_end( args );

    DosPutMessageW(g_hStdOut, ConBuf, FALSE);
}



/***************************************************************************\
* PWCHAR PaddedString(DWORD size, PWCHAR pwch)
*
* Realize the string, left aligned and padded on the right to the field
* width/precision specified.
*
* Limitations:  This uses a static buffer under the assumption that
* no more than one such string is printed in a single 'printf'.
*
* History:
* 11-03-93 FloydR      Created.
\***************************************************************************/
WCHAR  	PaddingBuffer[MAX_BUF_SIZE];

PWCHAR
PaddedString(
    int    size,
    PWCHAR pwch,
    PWCHAR buffer
    )
{
    int realsize;
    int fEllipsis = FALSE;

    if (buffer==NULL) buffer = PaddingBuffer;

    if (size < 0) {
	fEllipsis = TRUE;
	size = -size;
    }

    //
    // size is >= 0 at this point
    //

    realsize = _snwprintf(buffer, MAX_BUF_SIZE, L"%-*.*ws", size, size, pwch);

    if (realsize == 0)
    {
	return NULL;
    }

    if (SizeOfHalfWidthString(buffer) > (DWORD) size)
    {
	do
        {
	    buffer[--realsize] = NULLC;
	} while (SizeOfHalfWidthString(buffer) > (DWORD) size);

	if (fEllipsis && buffer[realsize-1] != L' ')
        {
	    buffer[realsize-1] = L'.';
	    buffer[realsize-2] = L'.';
	    buffer[realsize-3] = L'.';
	}
    }

    return buffer;
}


DWORD
DosQHandType(
    HANDLE hf,
    PWORD  pus1,
    PWORD  pus2
    )
{

    DWORD dwFileType;

    dwFileType = GetFileType(hf);

    if (dwFileType == FILE_TYPE_CHAR)
    {
        *pus1 = DEVICE_HANDLE;
        *pus2 = DESIRED_HAND_STATE;
    }
    else
    {
        *pus1 = FILE_HANDLE;
    }

    return(0);
}


/***    GetPasswdStr -- read in password string
 *
 *      DWORD GetPasswdStr(char far *, USHORT);
 *
 *      ENTRY:  buf             buffer to put string in
 *              buflen          size of buffer
 *              &len            address of USHORT to place length in
 *
 *      RETURNS:
 *              0 or NERR_BufTooSmall if user typed too much.  Buffer
 *              contents are only valid on 0 return.
 *
 *      History:
 *              who     when    what
 *              erichn  5/10/89 initial code
 *              dannygl 5/28/89 modified DBCS usage
 *              erichn  7/04/89 handles backspaces
 *              danhi   4/16/91 32 bit version for NT
 */
#define CR              0xD
#define BACKSPACE       0x8

DWORD
GetPasswdStr(
    LPTSTR  buf,
    DWORD   buflen,
    PDWORD  len
    )
{
    TCHAR	ch;
    TCHAR	*bufPtr = buf;
    DWORD	c;
    int		err;
    int		mode;

    buflen -= 1;    /* make space for null terminator */
    *len = 0;       /* GP fault probe (a la API's)    */


    //
    // Init mode in case GetConsoleMode() fails
    //

    mode = ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT | ENABLE_PROCESSED_INPUT |
               ENABLE_MOUSE_INPUT;

    GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode);

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
		(~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE)
    {
	err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);

	if (!err || c != 1)
        {
	    ch = 0xffff;
        }

        if ((ch == CR) || (ch == 0xffff))       /* end of the line */
        {
            break;
        }

        if (ch == BACKSPACE)    /* back up one or two */
        {
            /*
             * IF bufPtr == buf then the next two lines are
             * a no op.
             */
            if (bufPtr != buf)
            {
                bufPtr--;
                (*len)--;
            }
        }
        else
        {
            *bufPtr = ch;

            if (*len < buflen) 
                bufPtr++ ;                   /* don't overflow buf */
            (*len)++;                        /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);

    *bufPtr = NULLC;         /* null terminate the string */
    putchar(NEWLINE);

    return ((*len <= buflen) ? 0 : NERR_BufTooSmall);
}


/***    GetString -- read in string with echo
 *
 *      DWORD GetString(char far *, USHORT, USHORT far *, char far *);
 *
 *      ENTRY:  buf             buffer to put string in
 *              buflen          size of buffer
 *              &len            address of USHORT to place length in
 *              &terminator     holds the char used to terminate the string
 *
 *      RETURNS:
 *              0 or NERR_BufTooSmall if user typed too much.  Buffer
 *              contents are only valid on 0 return.  Len is ALWAYS valid.
 *
 *      OTHER EFFECTS:
 *              len is set to hold number of bytes typed, regardless of
 *              buffer length.  Terminator (Arnold) is set to hold the
 *              terminating character (newline or EOF) that the user typed.
 *
 *      Read in a string a character at a time.  Is aware of DBCS.
 *
 *      History:
 *              who     when    what
 *              erichn  5/11/89 initial code
 *              dannygl 5/28/89 modified DBCS usage
 *              danhi   3/20/91 ported to 32 bits
 */

DWORD
GetString(
    LPTSTR  buf,
    DWORD   buflen,
    PDWORD  len,
    LPTSTR  terminator
    )
{
    int		c;
    int		err;

    buflen -= 1;    /* make space for null terminator */
    *len = 0;       /* GP fault probe (a la API's) */

    while (TRUE)
    {
	err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), buf, 1, &c, 0);
	if (!err || c != 1)
	    *buf = 0xffff;

        if (*buf == (TCHAR)EOF)
	    break;
        if (*buf ==  RETURN || *buf ==  NEWLINE) {
	    INPUT_RECORD	ir;
	    int			cr;

	    if (PeekConsoleInput(GetStdHandle(STD_INPUT_HANDLE), &ir, 1, &cr))
		ReadConsole(GetStdHandle(STD_INPUT_HANDLE), buf, 1, &c, 0);
	    break;
	}

        buf += (*len < buflen) ? 1 : 0; /* don't overflow buf */
        (*len)++;                       /* always increment len */
    }

    *terminator = *buf;     /* set terminator */
    *buf = NULLC;            /* null terminate the string */

    return ((*len <= buflen) ? 0 : NERR_BufTooSmall);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\message.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    message.c

Abstract:

    This module provides support routines to map DosxxxMessage APIs to
    the FormatMessage syntax and semantics.

Author:

    Dan Hinsley (DanHi) 24-Sept-1991

Environment:

    Contains NT specific code.

Revision History:

--*/

#define ERROR_MR_MSG_TOO_LONG           316
#define ERROR_MR_UN_ACC_MSGF            318
#define ERROR_MR_INV_IVCOUNT            320

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <limits.h>
#include <lmcons.h>
#include <lmerr.h>
#include <tstring.h>
#include "netascii.h"
#include "netcmds.h"


//
// Local function declarations
//

BOOL
FileIsConsole(
    HANDLE fp
    );

VOID
MyWriteConsole(
    HANDLE  fp,
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    );


//
// 100 is plenty since FormatMessage only takes 99 & old DosGetMessage 9.
//
#define MAX_INSERT_STRINGS (100)

DWORD
DosGetMessageW(
    IN  LPTSTR  *InsertionStrings,
    IN  DWORD   NumberofStrings,
    OUT LPTSTR  Buffer,
    IN  DWORD   BufferLength,
    IN  DWORD   MessageId,
    IN  LPTSTR  FileName,
    OUT PDWORD  pMessageLength
    )
/*++

Routine Description:

    This maps the OS/2 DosGetMessage API to the NT FormatMessage API.

Arguments:

    InsertionStrings - Pointer to an array of strings that will be used
                       to replace the %n's in the message.

    NumberofStrings  - The number of insertion strings.

    Buffer           - The buffer to put the message into.

    BufferLength     - The length of the supplied buffer in characters.

    MessageId        - The message number to retrieve.

    FileName         - The name of the message file to get the message from.

    pMessageLength   - A pointer to return the length of the returned message.

Return Value:

    NERR_Success
    ERROR_MR_MSG_TOO_LONG
    ERROR_MR_INV_IVCOUNT
    ERROR_MR_UN_ACC_MSGF
    ERROR_MR_MID_NOT_FOUND
    ERROR_INVALID_PARAMETER

--*/
{

    DWORD dwFlags = FORMAT_MESSAGE_ARGUMENT_ARRAY;
    DWORD Status ;
    TCHAR NumberString [18];

    static HANDLE lpSource = NULL ;
    static TCHAR CurrentMsgFile[MAX_PATH] = {0,} ;

    //
    // init clear the output string
    //
    Status = NERR_Success;
    if (BufferLength)
        Buffer[0] = NULLC ;

    //
    // make sure we are not over loaded & allocate
    // memory for the Unicode buffer
    //
    if (NumberofStrings > MAX_INSERT_STRINGS)
        return ERROR_INVALID_PARAMETER ;

    //
    // See if they want to get the message from the system message file.
    //

    if (! STRCMP(FileName, OS2MSG_FILENAME)) {
       dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
       //
       // They want it from a separate message file.  Get a handle to DLL
       // If its for the same file as before, dont reload.
       //
       if (!(lpSource && !STRCMP(CurrentMsgFile, FileName)))
       {
           if (lpSource)
           {
               FreeLibrary(lpSource) ;
           }
           STRCPY(CurrentMsgFile, FileName) ;
           lpSource = LoadLibrary(FileName);

           if (!lpSource)
           {
               return ERROR_MR_UN_ACC_MSGF;
           }
       }
       dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    //
    // If they just want to get the message back for later formatting,
    // ignore the insert strings.
    //
    if (NumberofStrings == 0)
    {
        dwFlags |= FORMAT_MESSAGE_IGNORE_INSERTS;
    }

    //
    // call the Unicode version
    //
    *pMessageLength = FormatMessageW(dwFlags,
                                     lpSource,
                                     MessageId,
                                     0,       // LanguageId defaulted
                                     Buffer,
                                     BufferLength,
                                     (va_list *) InsertionStrings);

    //
    // If it failed get the return code and map it to an OS/2 equivalent
    //

    if (*pMessageLength == 0)
    {
        Buffer[0] = 0 ;
        Status = GetLastError();
        if (Status == ERROR_MR_MID_NOT_FOUND)
        {
            //
            // get the message number in Unicode
            //
            ultow(MessageId, NumberString, 16);

            //
            // re-setup to get it from the system. use the not found message
            //
            dwFlags = FORMAT_MESSAGE_ARGUMENT_ARRAY |
                      FORMAT_MESSAGE_FROM_SYSTEM;
            MessageId = ERROR_MR_MID_NOT_FOUND ;

            //
            // setup insert strings
            //
            InsertionStrings[0] = NumberString ;
            InsertionStrings[1] = FileName ;

            //
            // recall the API
            //
            *pMessageLength = FormatMessageW(dwFlags,
                                             lpSource,
                                             MessageId,
                                             0,       // LanguageId defaulted
                                             Buffer,
                                             BufferLength,
                                             (va_list *) InsertionStrings);
            InsertionStrings[1] = NULL ;

            //
            // revert to original error
            //
            Status = ERROR_MR_MID_NOT_FOUND ;
        }
    }

    //
    // note: NumberString don't need to be freed
    // since if used, they would be in the InsertionStrings which is whacked
    //

    return Status;
}





DWORD
DosInsMessageW(
    IN     LPTSTR *InsertionStrings,
    IN     DWORD  NumberofStrings,
    IN OUT LPTSTR InputMessage,
    IN     DWORD  InputMessageLength,
    OUT    LPTSTR Buffer,
    IN     DWORD  BufferLength,
    OUT    PDWORD pMessageLength
    )
/*++

Routine Description:

    This maps the OS/2 DosInsMessage API to the NT FormatMessage API.

Arguments:

    InsertionStrings - Pointer to an array of strings that will be used
                       to replace the %n's in the message.

    NumberofStrings  - The number of insertion strings.

    InputMessage     - A message with %n's to replace

    InputMessageLength - The length in bytes of the input message.

    Buffer           - The buffer to put the message into.

    BufferLength     - The length of the supplied buffer in characters.

    pMessageLength   - A pointer to return the length of the returned message.

Return Value:

    NERR_Success
    ERROR_MR_INV_IVCOUNT
    ERROR_MR_MSG_TOO_LONG

--*/
{

   DWORD Status ;
   DWORD dwFlags = FORMAT_MESSAGE_ARGUMENT_ARRAY;

   UNREFERENCED_PARAMETER(InputMessageLength);

    //
    // init clear the output string
    //
    Status = NERR_Success;
    if (BufferLength)
        Buffer[0] = NULLC ;

   //
   // make sure we are not over loaded & allocate
   // memory for the Unicode buffer
   //
   if (NumberofStrings > MAX_INSERT_STRINGS)
       return ERROR_INVALID_PARAMETER ;

   //
   // This api always supplies the string to format
   //
   dwFlags |= FORMAT_MESSAGE_FROM_STRING;

   //
   // I don't know why they would call this api if they didn't have strings
   // to insert, but it is valid syntax.
   //
   if (NumberofStrings == 0) {
      dwFlags |= FORMAT_MESSAGE_IGNORE_INSERTS;
   }

   *pMessageLength = (WORD) FormatMessageW(dwFlags,
                                   InputMessage,
                                   0,            // ignored
                                   0,            // LanguageId defaulted
                                   Buffer,
                                   BufferLength,
                                   (va_list *)InsertionStrings);

   //
   // If it failed get the return code and map it to an OS/2 equivalent
   //

   if (*pMessageLength == 0)
   {
      Status = GetLastError();
      goto ExitPoint ;
   }

ExitPoint:
    return Status;
}


VOID
DosPutMessageW(
    HANDLE  fp,
    LPWSTR  pch,
    BOOL    fPrintNL
    )
{
    MyWriteConsole(fp,
                   pch,
                   wcslen(pch));

    //
    // If there's a newline at the end of the string,
    // print another one for formatting.
    //

    if (fPrintNL)
    {
        while (*pch && *pch != NEWLINE)
        {
            pch++;
        }

        if (*pch == NEWLINE)
        {
            MyWriteConsole(fp,
                           L"\r\n",
                           2);
        }
    }
}


/***
 *  PrintDependingOnLength()
 *
 *  Prints out a string given to it padded to be as long as iLength. checks
 *  the positions of the cursor in the console window.  if printing the string
 *  would go past the end of the window buffer, outputs a newline and tabs
 *  first unless the cursor is at the start of a line.
 *
 *  Args:
 *      iLength - size of the string to be outputted.  string will be padded
 *      if necessary
 *
 *      OutputString - string to output
 *
 *  Returns:
 *      returns the same value as iLength on success, -1 on failure
 */
int
PrintDependingOnLength(
    IN      int iLength,
    IN      LPTSTR OutputString
    )
{
    CONSOLE_SCREEN_BUFFER_INFO  ThisConsole;
    HANDLE hStdOut;
    
    //
    // save off iLength
    //
    int iReturn = iLength;
                
    //
    // Get the dimensions of the current window
    //
    hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

    if (hStdOut != INVALID_HANDLE_VALUE)
    {
        //
        //init this to INT_MAX - if we aren't able to get the console screen buffer
        //info, then we are probably being piped to a text file (or somewhere else)
        //and can assume that there is no "SpaceLeft" constraint
        //
        int iSpaceLeft = INT_MAX;            

        if (GetConsoleScreenBufferInfo(hStdOut, &ThisConsole))
        {
            //
            //see how much space is left in the console buffer, if we were able to
            //get the console info
            //
            iSpaceLeft = ThisConsole.dwSize.X - ThisConsole.dwCursorPosition.X;
        }
                
        //
        // Print out string.  if we will have to handle a wrapping
        // column and we aren't at the beginning of a line, print a newline  
        // and tabs first for formatting.
        //
        if ((iLength > iSpaceLeft) && (ThisConsole.dwCursorPosition.X))
        {   
            WriteToCon(TEXT("\n\t\t"));
        }
        
        WriteToCon(TEXT("%Fws"), PaddedString(iLength, OutputString, NULL));
    }
    else
    {
        iReturn = -1;
    }
    
    return iReturn;
}
                                         
                                         
/***
 *  FindColumnWidthAndPrintHeader()
 *
 *  figures out what the correct width should be given a longest
 *  string and a ID for a fixed header string.  result will always
 *  be whichever is longer.  Once that width is figured, the function
 *  will output the header specified by HEADER_ID
 *
 *  Args:
 *      iStringLength - integer which specifies the longest string length found
 *          in a set of strings that is going to be outputted to the console in a column 
 *          (think the "share name" column when you do a net view <machinename>.  
 *          since the arrays of strings used by net.exe tend to vary in type, this function
 *          assumes that you have alredy gone through and figured out which string is longest
 *
 *      HEADER_ID - ID of the fixed string that will be the column header for 
 *          that set of strings.  We will figure out whichever one is longest and return
 *          that value (+ an optional TAB_DISTANCE) 
 *
 *      TAB_DISTANCE - distance that should the function should pad the string by
 *          when it outputs the header (Usually 2 for it to look decent)
 *
 *  Returns:
 *      0 or greater - success
 *
 *      -1 - failure - dwHeaderID was 0, or the ID lookup failed
 */
int
FindColumnWidthAndPrintHeader(
    int iStringLength,
    const DWORD HEADER_ID,
    const int TAB_DISTANCE
    )
{
    DWORD dwErr;
    WCHAR MsgBuffer[LITTLE_BUF_SIZE];
    DWORD dwMsgLen = sizeof(MsgBuffer) / sizeof(WCHAR);
    int iResultLength = -1;

    //
    // First, we need the the string specified by HEADER_ID and its length
    //

    dwErr = DosGetMessageW(IStrings,
                           0,
                           MsgBuffer,
                           LITTLE_BUF_SIZE,
                           HEADER_ID,
                           MESSAGE_FILENAME,
                           &dwMsgLen);
                           
    if (!dwErr)
    {
        //
        // Figure out which is longer - the string to
        // display, or the column header
        //
        iResultLength = max((int) SizeOfHalfWidthString(MsgBuffer), iStringLength);
        
        //
        // Add the tab length we were given
        //
        iResultLength += TAB_DISTANCE;

        iResultLength = PrintDependingOnLength(
                iResultLength, 
                MsgBuffer
                );
    }       

    return iResultLength;
}


BOOL
FileIsConsole(
    HANDLE fp
    )
{
    unsigned htype;

    htype = GetFileType(fp);
    htype &= ~FILE_TYPE_REMOTE;
    return htype == FILE_TYPE_CHAR;
}


VOID
MyWriteConsole(
    HANDLE  fp,
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    )
{
    //
    // Jump through hoops for output because:
    //
    //    1.  printf() family chokes on international output (stops
    //        printing when it hits an unrecognized character)
    //
    //    2.  WriteConsole() works great on international output but
    //        fails if the handle has been redirected (i.e., when the
    //        output is piped to a file)
    //
    //    3.  WriteFile() works great when output is piped to a file
    //        but only knows about bytes, so Unicode characters are
    //        printed as two Ansi characters.
    //

    if (FileIsConsole(fp))
    {
	WriteConsole(fp, lpBuffer, cchBuffer, &cchBuffer, NULL);
    }
    else
    {
        LPSTR  lpAnsiBuffer = (LPSTR) LocalAlloc(LMEM_FIXED, cchBuffer * sizeof(WCHAR));

        if (lpAnsiBuffer != NULL)
        {
            cchBuffer = WideCharToMultiByte(CP_OEMCP,
                                            0,
                                            lpBuffer,
                                            cchBuffer,
                                            lpAnsiBuffer,
                                            cchBuffer * sizeof(WCHAR),
                                            NULL,
                                            NULL);

            if (cchBuffer != 0)
            {
                WriteFile(fp, lpAnsiBuffer, cchBuffer, &cchBuffer, NULL);
            }

            LocalFree(lpAnsiBuffer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\misc.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1992          **/
/********************************************************************/

/***
 *  misc.c
 *      common utility functions used by netcmd
 *
 *  History:
 */

/* Include files */

#define INCL_NOCOMMON
#define INCL_DOSMEMMGR
#define INCL_DOSFILEMGR
#define INCL_DOSSIGNALS
#define INCL_ERRORS
#include <os2.h>
#include <lmcons.h>
#include <apperr.h>
#include <apperr2.h>
#include <lmerr.h>
#define INCL_ERROR_H
#include <stdio.h>
#include <stdlib.h>
#include <icanon.h>
#include <malloc.h>
#include <netcmds.h>
#include "nettext.h"
#include <tchar.h>
#include <netascii.h>

/* Constants */

/* Forward declarations */

/* extern function prototypes */


/***
 *  Find the first occurrence of a COLON in a string.
 *  Replace the COLON will a 0, and return the a pointer
 *  to the TCHAR following the COLON.
 *
 *  Return NULL is there is no COLON in the string.
 */

TCHAR  *FindColon(TCHAR  * string)
{
    TCHAR * pos;

    if (pos = _tcschr(string, COLON))
    {
        *pos = NULLC;
        return(pos+1);
    }
    return NULL;
}


/****************** Ascii to Number conversions ***************/

/*
 *  do an ascii to unsigned int conversion
 */
USHORT do_atou(TCHAR *pos, USHORT err, TCHAR *text)
{
    USHORT val ;
    if ( n_atou(pos,&val) != 0 ) {
        ErrorExitInsTxt(err,text) ;
    } else {
        return(val) ;
    }
    return 0;
}

/*
 *  do an ascii to ULONG conversion
 */
ULONG do_atoul(TCHAR *pos, USHORT err, TCHAR *text)
{
    ULONG val ;
    if ( n_atoul(pos,&val) != 0 ) {
        ErrorExitInsTxt(err,text) ;
    } else {
        return(val) ;
    }
    return 0;
}

/*
 *
 *  Remarks:
 *      1)  Check if all TCHAR are numeric.
 *      2)  Check if > 5 TCHAR in string.
 *      3)  do atol, and see if result > 64K.
 */
USHORT n_atou(TCHAR * pos, USHORT * val)
{
    LONG tL = 0;

    *val = 0 ;

    if (!IsNumber(pos))
        return(1) ;

    if (_tcslen(pos) > ASCII_US_LEN)
        return(1) ;

    tL = (LONG)_tcstod(pos, NULL);
    if (tL > MAX_US_VALUE)
        return(1) ;

    *val = (USHORT) tL;
    return(0) ;
}

/*   n_atoul - convert ascii string to ULONG with some verification
 *
 *  Remarks:
 *      1)  Check if all TCHAR are numeric.
 *      2)  Check if > 10 TCHAR in string.
 *      3)  do atol.
 */
USHORT n_atoul(TCHAR * pos, ULONG * val)
{
    DWORD  len;

    *val = 0L ;

    if (!IsNumber(pos))
        return(1) ;

    if ( ( len = _tcslen(pos ) ) > ASCII_UL_LEN)
        return(1) ;

    if (len == ASCII_UL_LEN)
    {
        if( _tcscmp( pos, ASCII_MAX_UL_VAL ) > 0 )
            return(1) ;
    }


    *val = (ULONG)_tcstod(pos, NULL) ;
    return(0) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\msystem.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MSYSTEM.C

Abstract:

    32 bit version of mapping routines for Base API

Author:

    Dan Hinsley    (danhi)  06-Jun-1991

Environment:

    User Mode - Win32

Revision History:

    24-Apr-1991     danhi
        Created

    06-Jun-1991     Danhi
        Sweep to conform to NT coding style

    09-Oct-1991     JohnRo
        Fixed bug #3215 - bogus messages when setting time.

--*/

//
// INCLUDES
//

#include <windows.h>
#include <lmerr.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <netlib.h>

#include "msystem.h"


//
// Used to replace uses of BigBuf and Buffer
//

TCHAR *
GetBuffer(
    DWORD Size
    )
{

    LPVOID  lp;

    //
    // Allocate the buffer so that it can be freed with NetApiBufferFree
    //

    NetapipBufferAllocate(Size, &lp);
    return lp;
}


//
// Replacement for DosAllocSeg
//
DWORD
AllocMem(
    DWORD Size,
    PVOID * pBuffer
    )
{

    return NetApiBufferAllocate(Size, pBuffer);
}


//
// Replacement for DosReallocSeg
//
DWORD
ReallocMem(
    DWORD Size,
    PVOID *pBuffer
    )
{
    return NetApiBufferReallocate(*pBuffer, Size, pBuffer);
}


//
// Frees up memory allocated with MAllocMem
//

DWORD
FreeMem(
    PVOID Buffer
    )
{
   return NetApiBufferFree(Buffer);
}


//
// clear a 8 bit string. this is used to make sure we have no passwords in
// memory that gets written out to pagefile.sys
//
VOID
ClearStringA(
    LPSTR lpszString) 
{
    DWORD len ;

    if (lpszString)
    {
        if (len = strlen(lpszString))
            memset(lpszString, 0, len) ;
    }
}

//
// clear a unicode string. this is used to make sure we have no passwords in
// memory that gets written out to pagefile.sys
//
VOID
ClearStringW(
    LPWSTR lpszString) 
{
    DWORD len ;

    if (lpszString)
    {
        if (len = wcslen(lpszString))
            memset(lpszString, 0, len * sizeof(WCHAR)) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\mserver.c ===
/*++ 

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    MSERVER.C

Abstract:

    32 bit version of mapping routines for NetServerGet/SetInfo API

Author:

    Dan Hinsley    (danhi)  06-Jun-1991

Environment:

    User Mode - Win32

Revision History:

    24-Apr-1991     danhi
        Created

    06-Jun-1991     Danhi
        Sweep to conform to NT coding style

    08-Aug-1991 JohnRo
        Implement downlevel NetWksta APIs.
        Made some UNICODE changes.
        Got rid of tabs in source file.

    15-Aug-1991     W-ShankN
        Added UNICODE mapping layer.

    02-Apr-1992     beng
        Added xport apis

    26-Aug-1992 JohnRo
        RAID 4463: NetServerGetInfo(level 3) to downlevel: assert in convert.c.
--*/

//
// INCLUDES
//

#include <nt.h>
#include <windef.h>
#include <ntrtl.h>
#include <winerror.h>

#include <stdio.h>
#include <memory.h>
#include <tstring.h>
#include <malloc.h>
#include <stddef.h>
#include <excpt.h>

#include <lmcons.h>
#include <lmerr.h>      // NERR_ equates.
#include <lmserver.h>   // NetServer APIs.
#include <lmapibuf.h>   // NetApiBufferFree
#include <mapsupp.h>    // BUILD_LENGTH_ARRAY
#include <xsdef16.h>    // DEF16_*
#include <dlserver.h>   // SERVER_INFO_0
#include <mserver.h>


NET_API_STATUS
NetpMakeServerLevelForNT(
    IN DWORD Level,
    PSERVER_INFO_102 pLevel102,
    PSERVER_INFO_502 pLevel402,
    PSERVER_INFO_2 * ppLevel2
    );

NET_API_STATUS
NetpMakeServerLevelForOS2(
    IN DWORD Level,
    PSERVER_INFO_102 pLevel102,
    PSERVER_INFO_402 pLevel402,
    PSERVER_INFO_2 * ppLevel2
    );

NET_API_STATUS
NetpSplitServerForNT(
    LPTSTR Server,
    IN DWORD Level,
    PSERVER_INFO_2 pLevel2,
    PSERVER_INFO_102 * ppLevel102,
    PSERVER_INFO_502 * ppLevel402
    );


DWORD
MNetServerEnum(
    LPTSTR   pszServer,
    DWORD    nLevel,
    LPBYTE * ppbBuffer,
    DWORD *  pcEntriesRead,
    DWORD    flServerType,
    LPTSTR   pszDomain
    )
{
    DWORD   cTotalAvail;
    DWORD   dwErr;
    DWORD   i;
    LPBYTE  Source;
    LPBYTE  Dest;

    ASSERT(nLevel == 100 || nLevel == 101);

    //
    // In either the case of 100 or 101, all we need to do is move
    // the information up over the top of the platform id.
    //

    dwErr = NetServerEnum(pszServer,
                          nLevel,
                          ppbBuffer,
                          MAX_PREFERRED_LENGTH,
                          pcEntriesRead,
                          &cTotalAvail,
                          flServerType,
                          pszDomain,
                          NULL);

    if (dwErr == NERR_Success || dwErr == ERROR_MORE_DATA)
    {
        //
        // Cycle thru the returned entries, moving each one up over the
        // platform id.  None of the strings need to be moved.
        //

        if (nLevel == 100)
        {
            for (i = 0, Source = Dest = (LPBYTE)*ppbBuffer;
                 i < *pcEntriesRead;
                 i++, Source += sizeof(SERVER_INFO_100), Dest += sizeof(SERVER_INFO_0))
            {
                memmove(Dest,
                        Source + FIELD_OFFSET(SERVER_INFO_100, sv100_name),
                        sizeof(SERVER_INFO_0));
            }
        }
        else
        {
            for (i = 0, Source = Dest = (LPBYTE)*ppbBuffer;
                 i < *pcEntriesRead;
                 i++, Source += sizeof(SERVER_INFO_101), Dest += sizeof(SERVER_INFO_1))
            {
                memmove(Dest,
                        Source + FIELD_OFFSET(SERVER_INFO_100, sv100_name),
                        sizeof(SERVER_INFO_1));
            }
        }
    }

    return dwErr;
}


DWORD
MNetServerGetInfo(
    LPTSTR   ptszServer,
    DWORD    nLevel,
    LPBYTE * ppbBuffer
    )
{
    DWORD ReturnCode;

    //
    // It all depends on what info level they've asked for:
    //

    switch(nLevel)
    {
        case 0:
        {

            PSERVER_INFO_100            pLevel100;

            //
            // Everything they need is in level 100. Get it.
            //

            ReturnCode = NetServerGetInfo(ptszServer, 100, (LPBYTE *) & pLevel100);

            if (ReturnCode)
            {
                return ReturnCode;
            }

            //
            // Since it's just the UNICODEZ string, just copy it up in
            // the RPC allocated buffer and return it.
            //

            ((PSERVER_INFO_0)(pLevel100))->sv0_name = pLevel100->sv100_name;

            *ppbBuffer = (LPBYTE) pLevel100;
            break;
        }

        case 1:
        {
            PSERVER_INFO_101            pLevel101;

            //
            // Everything they need is in level 101. Get it.
            //

            ReturnCode = NetServerGetInfo(ptszServer, 101, (LPBYTE *) & pLevel101);

            if (ReturnCode)
            {
                return ReturnCode;
            }

            //
            // Level 101 is identical to the 32 bit version of info level 1
            // except for the platform_id.  All I have to do is move the
            // fields up sizeof(DWORD) and then pass the buffer on to the user.
            //

            memcpy(
                (LPBYTE)pLevel101,
                (LPBYTE)&(pLevel101->sv101_name),
                sizeof(SERVER_INFO_101) - sizeof(DWORD));

            *ppbBuffer = (LPBYTE) pLevel101;
            break;
        }

        case 2:
        case 3:
        {
            PSERVER_INFO_102 pLevel102;
            LPBYTE pLevel2;
            LPBYTE pLevelx02 = NULL;

            //
            // Level 2/3 requires information from both platform dependant and
            // platform independent levels.  Get level 102 first, which will
            // tell us what platform we're running on (as well as supply some
            // of the other information we'll need.
            //

            ReturnCode = NetServerGetInfo(ptszServer, 102, (LPBYTE *) &pLevel102);

            if (ReturnCode)
            {
                return ReturnCode;
            }

            //
            // Get the platform dependant information and then call the
            // platform dependant worker function that will create the
            // level 2/3 structure.
            //

            if (pLevel102->sv102_platform_id == SV_PLATFORM_ID_NT) {

                ReturnCode = NetServerGetInfo(ptszServer, 502, & pLevelx02);

                if (ReturnCode)
                {
                    NetApiBufferFree(pLevel102);
                    return ReturnCode;
                }

                ReturnCode = NetpMakeServerLevelForNT(nLevel, pLevel102,
                    (PSERVER_INFO_502) pLevelx02, (PSERVER_INFO_2 *) & pLevel2);

                if (ReturnCode)
                {
                    NetApiBufferFree(pLevel102);
                    NetApiBufferFree(pLevelx02);
                    return ReturnCode;
                }
            }
            else if (pLevel102->sv102_platform_id == SV_PLATFORM_ID_OS2) {

                ReturnCode = NetServerGetInfo(ptszServer, 402, & pLevelx02);

                if (ReturnCode)
                {
                    NetApiBufferFree(pLevel102);
                    return ReturnCode;
                }

                ReturnCode = NetpMakeServerLevelForOS2(nLevel, pLevel102,
                    (PSERVER_INFO_402) pLevelx02,
                    (PSERVER_INFO_2 *) & pLevel2);

                if (ReturnCode)
                {
                    NetApiBufferFree(pLevel102);
                    NetApiBufferFree(pLevelx02);
                    return ReturnCode;
                }
            }

            //
            // I got an unknown platform id back, this should never happen!
            //

            else
            {
                NetApiBufferFree(pLevel102);
                return(ERROR_UNEXP_NET_ERR);
            }

            //
            // I've built the old style structure, stick the pointer
            // to the new structure in the user's pointer and return.
            //

            *ppbBuffer = (LPBYTE) pLevel2;

            NetApiBufferFree(pLevel102);
            NetApiBufferFree(pLevelx02);

            break;
        }

        //
        // Not a level I recognize
        //
        default:
            return ERROR_INVALID_LEVEL;
    }

    return NERR_Success;
}

DWORD
MNetServerSetInfoLevel2(
    LPBYTE pbBuffer
    )
{
    DWORD ReturnCode;

    PSERVER_INFO_102 pLevel102 = NULL;
    PSERVER_INFO_502 pLevel502 = NULL;

    //
    // Create the NT levels based on the structure passed in
    //

    NetpSplitServerForNT(NULL,
                         2,
                         (PSERVER_INFO_2) pbBuffer,
                         &pLevel102,
                         &pLevel502);

    //
    // Now SetInfo for both levels (takes two to cover all the
    // information in the old structure
    //

    ReturnCode = NetServerSetInfo(NULL, 102, (LPBYTE) pLevel102, NULL);

/*
    // We no longer want to disable autotuning of all these parameters, so we don't set this info.
    // The only things settable are AutoDisc, Comment, and Hidden, which are all in the 102 structure.
    if (ReturnCode == NERR_Success)
    {
        ReturnCode = NetServerSetInfo(NULL, 502, (LPBYTE) pLevel502, NULL);
    }
*/

    NetApiBufferFree(pLevel102);
    NetApiBufferFree(pLevel502);

    return ReturnCode;
}


NET_API_STATUS
NetpMakeServerLevelForOS2(
    IN DWORD Level,
    PSERVER_INFO_102 pLevel102,
    PSERVER_INFO_402 pLevel402,
    PSERVER_INFO_2 * ppLevel2
    )
{

    DWORD BytesRequired = 0;
    NET_API_STATUS ReturnCode;
    DWORD Level2_102_Length[3];
    DWORD Level2_402_Length[3];
    DWORD Level3_403_Length[1];
    DWORD i;
    LPTSTR pFloor;

    //
    // Initialize the Level2_102_Length array with the length of each string
    // in the 102 and 402 buffers, and allocate the new buffer for
    // SERVER_INFO_2
    //

    BUILD_LENGTH_ARRAY(BytesRequired, 2, 102, Server)
    BUILD_LENGTH_ARRAY(BytesRequired, 2, 402, Server)

    //
    // If we're doing a level 3, Initialize the Level3_403_Length array with
    // the length of each string
    //

    if (Level == 3) {
     //   Can't use the macro here, due to not really having a pLevel403
     //   BUILD_LENGTH_ARRAY(BytesRequired, 3, 403, Server)
     //
        for (i = 0; NetpServer3_403[i].Source != MOVESTRING_END_MARKER; i++) {
            Level3_403_Length[i] =
                (DWORD) STRLEN(
                        (LPVOID) *((LPTSTR*) (LPVOID)
                        (((LPBYTE) (LPVOID) pLevel402)
                            + NetpServer3_403[i].Source)) );
            BytesRequired += Level3_403_Length[i];
        }
    }

    //
    // Allocate the new buffer which will be returned to the user.  Allocate
    // the space for a level 3 even if you only need level 2, it's only 12
    // bytes and it would take more than that in code to differentiate
    //

    ReturnCode =
        NetapipBufferAllocate(BytesRequired + sizeof(SERVER_INFO_3),
            (LPVOID *) ppLevel2);
    if (ReturnCode) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // First get the floor to start moving strings in at.
    //

    pFloor = (LPTSTR)((LPBYTE)*ppLevel2 + BytesRequired + sizeof(SERVER_INFO_2));

    //
    // Now move the variable length entries into the new buffer from both the
    // 102 and 402 data structures.
    //

    (VOID) NetpMoveStrings(
            &pFloor,
            (LPTSTR) (LPVOID) pLevel102,
            (LPVOID) *ppLevel2,
            NetpServer2_102,
            Level2_102_Length);

    (VOID) NetpMoveStrings(
            &pFloor,
            (LPTSTR) (LPVOID) pLevel402,
            (LPVOID) *ppLevel2,
            NetpServer2_402,
            Level2_402_Length);

    //
    // Now set the rest of the fields in the fixed length portion
    // of the structure
    //

    (*ppLevel2)->sv2_version_major = pLevel102->sv102_version_major;
    (*ppLevel2)->sv2_version_minor = pLevel102->sv102_version_minor;
    (*ppLevel2)->sv2_type           = pLevel102->sv102_type;
    (*ppLevel2)->sv2_ulist_mtime   = pLevel402->sv402_ulist_mtime;
    (*ppLevel2)->sv2_glist_mtime   = pLevel402->sv402_glist_mtime;
    (*ppLevel2)->sv2_alist_mtime   = pLevel402->sv402_alist_mtime;
    (*ppLevel2)->sv2_users           = pLevel102->sv102_users;
    (*ppLevel2)->sv2_disc           = pLevel102->sv102_disc;
    (*ppLevel2)->sv2_security           = pLevel402->sv402_security;

    (*ppLevel2)->sv2_auditing           = 0;

    (*ppLevel2)->sv2_numadmin           = pLevel402->sv402_numadmin;
    (*ppLevel2)->sv2_lanmask            = pLevel402->sv402_lanmask;
    (*ppLevel2)->sv2_hidden        = (DWORD) pLevel102->sv102_hidden;
    (*ppLevel2)->sv2_announce           = pLevel102->sv102_announce;
    (*ppLevel2)->sv2_anndelta           = pLevel102->sv102_anndelta;
    (*ppLevel2)->sv2_licenses           = pLevel102->sv102_licenses;
    (*ppLevel2)->sv2_chdevs           = pLevel402->sv402_chdevs;
    (*ppLevel2)->sv2_chdevq           = pLevel402->sv402_chdevq;
    (*ppLevel2)->sv2_chdevjobs           = pLevel402->sv402_chdevjobs;
    (*ppLevel2)->sv2_connections   = pLevel402->sv402_connections;
    (*ppLevel2)->sv2_shares           = pLevel402->sv402_shares;
    (*ppLevel2)->sv2_openfiles           = pLevel402->sv402_openfiles;
    (*ppLevel2)->sv2_sessopens           = pLevel402->sv402_sessopens;
    (*ppLevel2)->sv2_sessvcs           = pLevel402->sv402_sessvcs;
    (*ppLevel2)->sv2_sessreqs           = pLevel402->sv402_sessreqs;
    (*ppLevel2)->sv2_opensearch    = pLevel402->sv402_opensearch;
    (*ppLevel2)->sv2_activelocks   = pLevel402->sv402_activelocks;
    (*ppLevel2)->sv2_numreqbuf           = pLevel402->sv402_numreqbuf;
    (*ppLevel2)->sv2_sizreqbuf           = pLevel402->sv402_sizreqbuf;
    (*ppLevel2)->sv2_numbigbuf           = pLevel402->sv402_numbigbuf;
    (*ppLevel2)->sv2_numfiletasks  = pLevel402->sv402_numfiletasks;
    (*ppLevel2)->sv2_alertsched    = pLevel402->sv402_alertsched;
    (*ppLevel2)->sv2_erroralert    = pLevel402->sv402_erroralert;
    (*ppLevel2)->sv2_logonalert    = pLevel402->sv402_logonalert;
    (*ppLevel2)->sv2_accessalert   = pLevel402->sv402_accessalert;
    (*ppLevel2)->sv2_diskalert           = pLevel402->sv402_diskalert;
    (*ppLevel2)->sv2_netioalert    = pLevel402->sv402_netioalert;
    (*ppLevel2)->sv2_maxauditsz    = pLevel402->sv402_maxauditsz;

    //
    // If we're building a level 3, do the incremental fields
    //

    if (Level == 3) {
        //
        // Now finish up by moving in the level 3 stuff.  This assumes that all
        // the offsets into the level 2 and level 3 structures are the same
        // except for the additional level 3 stuff
        //

        //
        // First the string
        //

        (VOID) NetpMoveStrings(
                 &pFloor,
                 (LPTSTR) (LPVOID) pLevel402,
                 (LPVOID) *ppLevel2,
                 NetpServer3_403,
                 Level3_403_Length);

        //
        // Now the fixed length data
        //

        ((PSERVER_INFO_3) (LPVOID) (*ppLevel2))->sv3_auditedevents  =
            ((PSERVER_INFO_403) (LPVOID) pLevel402)->sv403_auditedevents;
        ((PSERVER_INFO_3) (LPVOID) (*ppLevel2))->sv3_autoprofile =
            ((PSERVER_INFO_403) (LPVOID) pLevel402)->sv403_autoprofile;

    }

    return (NERR_Success);

}


NET_API_STATUS
NetpMakeServerLevelForNT(
    IN DWORD Level,
    PSERVER_INFO_102 pLevel102,
    PSERVER_INFO_502 pLevel502,
    PSERVER_INFO_2 * ppLevel2
    )
{

    DWORD BytesRequired = 0;
    NET_API_STATUS ReturnCode;
    DWORD Level2_102_Length[3];
    DWORD i;
    LPTSTR pFloor;

    //
    // Initialize the Level2_102_Length array with the length of each string
    // in the 102 buffer, and allocate the new buffer for SERVER_INFO_2
    //

    BUILD_LENGTH_ARRAY(BytesRequired, 2, 102, Server)

    //
    // Allocate the new buffer which will be returned to the user. Allocate
    // space for a level 3 just in case
    //

    ReturnCode = NetapipBufferAllocate(BytesRequired + sizeof(SERVER_INFO_3),
        (LPVOID *) ppLevel2);
    if (ReturnCode) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // First get the floor to start moving strings in at.
    //

    pFloor = (LPTSTR)((LPBYTE)*ppLevel2 + BytesRequired + sizeof(SERVER_INFO_3));

    //
    // Now move the variable length entries into the new buffer from the
    // 2 data structure.
    //

    (VOID) NetpMoveStrings(
            &pFloor,
            (LPTSTR) (LPVOID) pLevel102,
            (LPVOID) *ppLevel2,
            NetpServer2_102,
            Level2_102_Length);

    //
    // Clear string pointers in the level 2 structure for strings that
    // don't exist in NT.
    //

    (*ppLevel2)->sv2_alerts = NULL;
    (*ppLevel2)->sv2_guestacct = NULL;
    (*ppLevel2)->sv2_srvheuristics = NULL;

    //
    // Now set the rest of the fields in the fixed length portion
    // of the structure
    //

    (*ppLevel2)->sv2_version_major = pLevel102->sv102_version_major;
    (*ppLevel2)->sv2_version_minor = pLevel102->sv102_version_minor;
    (*ppLevel2)->sv2_type           = pLevel102->sv102_type;
    (*ppLevel2)->sv2_users           = pLevel102->sv102_users;
    (*ppLevel2)->sv2_disc           = pLevel102->sv102_disc;
    (*ppLevel2)->sv2_hidden        = (DWORD) pLevel102->sv102_hidden;
    (*ppLevel2)->sv2_announce           = pLevel102->sv102_announce;
    (*ppLevel2)->sv2_anndelta           = pLevel102->sv102_anndelta;
    (*ppLevel2)->sv2_licenses           = pLevel102->sv102_licenses;

    (*ppLevel2)->sv2_sessopens           = pLevel502->sv502_sessopens;
    (*ppLevel2)->sv2_sessvcs           = pLevel502->sv502_sessvcs;
    (*ppLevel2)->sv2_opensearch    = pLevel502->sv502_opensearch;
    (*ppLevel2)->sv2_sizreqbuf           = pLevel502->sv502_sizreqbuf;

    (*ppLevel2)->sv2_ulist_mtime   = DEF16_sv_ulist_mtime;
    (*ppLevel2)->sv2_glist_mtime   = DEF16_sv_glist_mtime;
    (*ppLevel2)->sv2_alist_mtime   = DEF16_sv_alist_mtime;

    (*ppLevel2)->sv2_security           = SV_USERSECURITY;
    (*ppLevel2)->sv2_auditing           = DEF16_sv_auditing;
    (*ppLevel2)->sv2_numadmin           = (DWORD) DEF16_sv_numadmin;
    (*ppLevel2)->sv2_lanmask            = DEF16_sv_lanmask;
    (*ppLevel2)->sv2_chdevs           = DEF16_sv_chdevs;
    (*ppLevel2)->sv2_chdevq           = DEF16_sv_chdevq;
    (*ppLevel2)->sv2_chdevjobs           = DEF16_sv_chdevjobs;
    (*ppLevel2)->sv2_connections   = DEF16_sv_connections;
    (*ppLevel2)->sv2_shares           = DEF16_sv_shares;
    (*ppLevel2)->sv2_openfiles           = DEF16_sv_openfiles;
    (*ppLevel2)->sv2_sessreqs           = DEF16_sv_sessreqs;
    (*ppLevel2)->sv2_activelocks   = DEF16_sv_activelocks;
    (*ppLevel2)->sv2_numreqbuf           = DEF16_sv_numreqbuf;
    (*ppLevel2)->sv2_numbigbuf           = DEF16_sv_numbigbuf;
    (*ppLevel2)->sv2_numfiletasks  = DEF16_sv_numfiletasks;
    (*ppLevel2)->sv2_alertsched    = DEF16_sv_alertsched;
    (*ppLevel2)->sv2_erroralert    = DEF16_sv_erroralert;
    (*ppLevel2)->sv2_logonalert    = DEF16_sv_logonalert;
    (*ppLevel2)->sv2_accessalert   = DEF16_sv_accessalert;
    (*ppLevel2)->sv2_diskalert           = DEF16_sv_diskalert;
    (*ppLevel2)->sv2_netioalert    = DEF16_sv_netioalert;
    (*ppLevel2)->sv2_maxauditsz    = DEF16_sv_maxauditsz;

    //
    // If we're building a level 3, do the incremental fields
    //

    if (Level == 3) {
        //
        // Now finish up by moving in the level 3 stuff.  This assumes that all
        // the offsets into the level 2 and level 3 structures are the same
        // except for the additional level 3 stuff
        //

        //
        // First the string
        //

        ((PSERVER_INFO_3) (LPVOID) *ppLevel2)->sv3_autopath = NULL;

        //
        // Now the fixed length data
        //

        ((PSERVER_INFO_3) (LPVOID) (*ppLevel2))->sv3_auditedevents  =
            DEF16_sv_auditedevents;
        ((PSERVER_INFO_3) (LPVOID) (*ppLevel2))->sv3_autoprofile          =
            DEF16_sv_autoprofile;

    }

    return (NERR_Success);

}


NET_API_STATUS
NetpSplitServerForNT(
    IN LPTSTR Server,
    IN DWORD Level,
    PSERVER_INFO_2 pLevel2,
    PSERVER_INFO_102 * ppLevel102,
    PSERVER_INFO_502 * ppLevel502
    )
{

    DWORD BytesRequired = 0;
    NET_API_STATUS ReturnCode;
    DWORD Level102_2_Length[3];
    DWORD i;
    LPTSTR pFloor;

    UNREFERENCED_PARAMETER(Level);

    //
    // Initialize the Level102_2_Length array with the length of each string
    // in the 2 buffer
    //

    BUILD_LENGTH_ARRAY(BytesRequired, 102, 2, Server)

    //
    // Allocate the new 102 buffer which will be returned to the user
    //

    ReturnCode = NetapipBufferAllocate(BytesRequired + sizeof(SERVER_INFO_102),
        (LPVOID *) ppLevel102);
    if (ReturnCode) {
        return (ReturnCode);
    }

    //
    // First get the floor to start moving strings in at.
    //

    pFloor = (LPTSTR)((LPBYTE)*ppLevel102 + BytesRequired + sizeof(SERVER_INFO_102));

    //
    // Now move the variable length entries into the new buffer from the
    // level 2 data structure.
    //

    (VOID) NetpMoveStrings(
            &pFloor,
            (LPTSTR) (LPVOID) pLevel2,
            (LPVOID) *ppLevel102,
            NetpServer102_2,
            Level102_2_Length);

    //
    // Now let's do the same stuff for the 502 structure (except that there
    // are no variable length strings.
    //

    //
    // Get the current 502 information, and then lay the new information
    // over the top of it
    //

    ReturnCode = NetServerGetInfo(Server, 502, (LPBYTE *) (LPVOID) ppLevel502);
    if (ReturnCode) {
        return (ReturnCode);
    }

    //
    // Now set the rest of the fields in the fixed length portion
    // of the structure
    //

    (*ppLevel102)->sv102_version_major = pLevel2->sv2_version_major;
    (*ppLevel102)->sv102_version_minor = pLevel2->sv2_version_minor;
    (*ppLevel102)->sv102_type          = pLevel2->sv2_type;
    (*ppLevel102)->sv102_users         = pLevel2->sv2_users;
    (*ppLevel102)->sv102_disc          = pLevel2->sv2_disc;
    (*ppLevel102)->sv102_hidden        = (BOOL) pLevel2->sv2_hidden;
    (*ppLevel102)->sv102_announce      = pLevel2->sv2_announce;
    (*ppLevel102)->sv102_anndelta      = pLevel2->sv2_anndelta;
    (*ppLevel102)->sv102_licenses      = pLevel2->sv2_licenses;

    (*ppLevel502)->sv502_sessopens     = pLevel2->sv2_sessopens;
    (*ppLevel502)->sv502_sessvcs       = pLevel2->sv2_sessvcs;
    (*ppLevel502)->sv502_opensearch    = pLevel2->sv2_opensearch;
    (*ppLevel502)->sv502_sizreqbuf     = pLevel2->sv2_sizreqbuf;

    return (NERR_Success);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\pword.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    PWORD.C

Abstract:

    Convert parsing routines for YES/NO and weekday

Author:

    Dan Hinsley    (danhi)  06-Jun-1991

Environment:

    User Mode - Win32

Revision History:

    31-May-1989     chuckc
	Created

    24-Apr-1991     danhi
	32 bit NT version

    06-Jun-1991     Danhi
	Sweep to conform to NT coding style

    01-Oct-1992 JohnRo
        RAID 3556: Added NetpSystemTimeToGmtTime() for DosPrint APIs.

--*/

//
// INCLUDES
//

#include <windows.h>    // IN, LPTSTR, etc.

#include <lmcons.h>
#include <lui.h>
#include <stdio.h>
#include <malloc.h>
/*
 * Should I put the ID in apperr2.h ?
 * but we should sync the .mc file.
 */
#include "netmsg.h"

#include <luitext.h>

#include "netascii.h"

#include <tchar.h>
#include <nettext.h>   // for swtxt_SW_*

/*-- static data for weeks info --*/

static searchlist_data week_data[] = {
    {APE2_GEN_NONLOCALIZED_MONDAY,   0},
    {APE2_GEN_NONLOCALIZED_TUESDAY,  1},
    {APE2_GEN_NONLOCALIZED_WEDNSDAY, 2},
    {APE2_GEN_NONLOCALIZED_THURSDAY, 3},
    {APE2_GEN_NONLOCALIZED_FRIDAY,   4},
    {APE2_GEN_NONLOCALIZED_SATURDAY, 5},
    {APE2_GEN_NONLOCALIZED_SUNDAY,   6},
    {APE2_GEN_NONLOCALIZED_MONDAY_ABBREV,   0},
    {APE2_GEN_NONLOCALIZED_TUESDAY_ABBREV,  1},
    {APE2_GEN_NONLOCALIZED_WEDNSDAY_ABBREV, 2},
    {APE2_GEN_NONLOCALIZED_THURSDAY_ABBREV, 3},
    {APE2_GEN_NONLOCALIZED_FRIDAY_ABBREV,   4},
    {APE2_GEN_NONLOCALIZED_SATURDAY_ABBREV, 5},
    {APE2_GEN_NONLOCALIZED_SATURDAY_ABBREV2,5},
    {APE2_GEN_NONLOCALIZED_SUNDAY_ABBREV,   6},
    {APE2_GEN_MONDAY_ABBREV,	0},
    {APE2_GEN_TUESDAY_ABBREV,	1},
    {APE2_GEN_WEDNSDAY_ABBREV,	2},
    {APE2_GEN_THURSDAY_ABBREV,	3},
    {APE2_GEN_FRIDAY_ABBREV,	4},
    {APE2_GEN_SATURDAY_ABBREV,	5},
    {APE2_TIME_SATURDAY_ABBREV2, 5},
    {APE2_GEN_SUNDAY_ABBREV,	6},
    {APE2_GEN_MONDAY,		0},
    {APE2_GEN_TUESDAY,		1},
    {APE2_GEN_WEDNSDAY,		2},
    {APE2_GEN_THURSDAY,		3},
    {APE2_GEN_FRIDAY,		4},
    {APE2_GEN_SATURDAY,		5},
    {APE2_GEN_SUNDAY,		6},
    {0,0}
} ;

#define DAYS_IN_WEEK 	(7)
#define NUM_DAYS_LIST 	(sizeof(week_data)/sizeof(week_data[0])+DAYS_IN_WEEK)

/*
 * NOTE - we init the first 7 hardwired days
 *        and get the rest from the message file
 */
static searchlist 	week_list[NUM_DAYS_LIST + DAYS_IN_WEEK] =
{
	{LUI_txt_monday,	0},
	{LUI_txt_tuesday,	1},
	{LUI_txt_wednesday,	2},
	{LUI_txt_thursday,	3},
	{LUI_txt_friday,	4},
	{LUI_txt_saturday,	5},
	{LUI_txt_sunday,	6}
} ;	


/*
 * Name: 	ParseWeekDay
 *			Takes a string and parses it for a week day
 * Args:	PTCHAR inbuf - string to parse
 *		PDWORD answer - set to 0-6, if inbuf is a weekday,
 *				 undefined otherwise.
 * Returns:	0 if ok,
 *		ERROR_INVALID_PARAMETER or NERR_InternalError otherwise.
 * Globals: 	(none)
 * Statics:	(none)
 * Remarks:	
 * Updates:	(none)
 */
DWORD
ParseWeekDay(
    PTCHAR inbuf,
    PDWORD answer
    )
{
    TCHAR buffer[256] ;
    DWORD bytesread ;
    LONG  result ;

    if (inbuf == NULL || inbuf[0] == NULLC)
    {
	return ERROR_INVALID_PARAMETER;
    }

    if (ILUI_setup_listW(buffer, DIMENSION(buffer), 2, &bytesread,
			week_data,week_list))
    {
	return NERR_InternalError;
    }

    if (ILUI_traverse_slistW(inbuf, week_list, &result))
    {
	return ERROR_INVALID_PARAMETER;
    }

    *answer = result ;

    return 0;
}

/*----------- Yes or No ------------*/

static searchlist_data yesno_data[] = {
    {APE2_GEN_YES,		LUI_YES_VAL},
    {APE2_GEN_NO,		LUI_NO_VAL},
    {APE2_GEN_NLS_YES_CHAR,	LUI_YES_VAL},
    {APE2_GEN_NLS_NO_CHAR,	LUI_NO_VAL},
    {0,0}
} ;

#define NUM_YESNO_LIST 	(sizeof(yesno_data)/sizeof(yesno_data[0])+2)

static searchlist 	yesno_list[NUM_YESNO_LIST+2] = {
	{LUI_txt_yes,	LUI_YES_VAL},
	{LUI_txt_no,	LUI_NO_VAL},
} ;

/*
 * Name: 	LUI_ParseYesNo
 *			Takes a string and parses it for YES or NO.
 * Args:	PTCHAR inbuf - string to parse
 *		PUSHORT answer - set to LUI_YES_VAL or LUI_NO_VAL
 *			if inbuf matches YES/NO, undefined otherwise.
 * Returns:	0 if ok,
 *		ERROR_INVALID_PARAMETER or NERR_InternalError otherwise.
 * Globals: 	yesno_data, yesno_list
 * Statics:	(none)
 * Remarks:	
 * Updates:	(none)
 */
DWORD
LUI_ParseYesNo(
    PTCHAR inbuf,
    PDWORD answer
    )
{
    TCHAR  buffer[128] ;
    DWORD  bytesread ;
    LONG   result ;
    DWORD  err;

    if (inbuf == NULL || inbuf[0] == NULLC)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (err = ILUI_setup_listW(buffer, DIMENSION(buffer), 2,
			       &bytesread, yesno_data, yesno_list))
    {
        return err;
    }

    if (ILUI_traverse_slistW(inbuf, yesno_list, &result))
    {
        if (!_tcsicmp(inbuf, &swtxt_SW_YES[1]))
        {
            *answer = LUI_YES_VAL;
            return 0;
        }
        else if (!_tcsicmp(inbuf, &swtxt_SW_NO[1]))
        {
            *answer = LUI_NO_VAL;
            return 0;
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    *answer = result;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\mwksta.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MWKSTA.C

Abstract:

    32 bit version of mapping routines for NetWkstaGet/SetInfo API

Author:

    Dan Hinsley    (danhi)  06-Jun-1991

Environment:

    User Mode - Win32

Revision History:

    24-Apr-1991     danhi
        Created

    06-Jun-1991     Danhi
        Sweep to conform to NT coding style

    15-Aug-1991 JohnRo
        Implement downlevel NetWksta APIs.  (Moved DanHi's NetCmd/Map32/MWksta
        conversion stuff to NetLib.)
        Got rid of _DH hacks.
        Made some UNICODE changes.

    16-Oct-1991     W-ShankN
        Added Unicode mapping layer.
        Cleaned up old excess baggage.
--*/

//
// INCLUDES
//

#include <windef.h>
#include <winerror.h>

#include <stdio.h>
#include <memory.h>
#include <tstring.h>
#include <malloc.h>
#include <stddef.h>
#include <excpt.h>      // try, finally, etc.

#include <lm.h>
#include <mapsupp.h>    // BUILD_LENGTH_ARRAY, NetpMoveStrings
#include <dlwksta.h>

#include "mwksta.h"

NET_API_STATUS
NetpMakeWkstaLevelForNT(
    DWORD Level,
    PWKSTA_INFO_101 pLevel101,
    PWKSTA_USER_INFO_1 pLevelUser_1,
    PWKSTA_INFO_502 pLevel502,
    PWKSTA_INFO_0 * ppLevel0
    );


DWORD
MNetWkstaGetInfo(
    IN DWORD  nLevel,
    LPVOID    * ppbBuffer
    )
{
    NET_API_STATUS     ReturnCode;
    LPWKSTA_INFO_502   pLevel502 = NULL;
    LPTSTR             pLevel10;
    PWKSTA_INFO_101    pLevel101;
    PWKSTA_USER_INFO_1 pLevelUser_1;

    //
    // Get level 101 first, which will supply some of the
    // other information we'll need then User_1, then 502.
    //

    ReturnCode = NetWkstaGetInfo(NULL, 101, (LPBYTE *) &pLevel101);

    if (ReturnCode)
    {
        return ReturnCode;
    }

    NetpAssert(pLevel101 != NULL) ;   // since API succeeded

    ReturnCode = NetWkstaUserGetInfo(NULL, 1, (LPBYTE *) &pLevelUser_1);

    if (ReturnCode)
    {
        NetApiBufferFree(pLevel101);
        return ReturnCode;
    }

    NetpAssert(pLevel101->wki101_platform_id == PLATFORM_ID_NT);

    //
    // This is to be able to call NetApiBufferFree no matter where I
    // exit from.  Note the indentation level is not incremented for
    // the switch.  No sense going too deep.
    //

    try
    {
        //
        // It all depends on what info level they've asked for:
        //

        switch(nLevel)
        {
            case 0:
            case 1:
            {
                PWKSTA_INFO_0 pLevel0or1;

                //
                // This depends on the platform id being 300 400 500
                //

                ReturnCode = NetWkstaGetInfo(NULL, 502, (LPBYTE*) &pLevel502);

                if (ReturnCode)
                {
                    return ReturnCode;
                }

                //
                // Call the platform dependant worker function that builds
                // the old structure.
                //

                ReturnCode = NetpMakeWkstaLevelForNT(nLevel,
                                                     pLevel101,
                                                     pLevelUser_1,
                                                     pLevel502,
                                                     &pLevel0or1);
                if (ReturnCode)
                {
                    return ReturnCode;
                }

                //
                // Put the pointer to the new structure in the user's pointer.
                //

                *ppbBuffer = pLevel0or1;

                break;
            }

            case 10:
            {
                DWORD Level10_101_Length[2];
                DWORD Level10_User_1_Length[3];
                DWORD i;
                DWORD BytesRequired = 0;
                LPBYTE pFloor;

                //
                // Everything needed for a level 10 is in level 101/User_1
                // This is pretty straightforward, let's just do it here.
                //
                // Initialize the Level10_xxx_Length array with the length of each
                // string in the input buffers, and allocate the new buffer
                // for WKSTA_INFO_10
                //

                BUILD_LENGTH_ARRAY(BytesRequired, 10, 101, Wksta)
                BUILD_LENGTH_ARRAY(BytesRequired, 10, User_1, Wksta)

                //
                // Allocate the new buffer which will be returned to the user.
                //

                ReturnCode = NetapipBufferAllocate(BytesRequired + sizeof(WKSTA_INFO_10),
                                                   (LPVOID *) &pLevel10);

                if (ReturnCode)
                {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                //
                // First get the floor to start moving strings in at.
                //

                pFloor = (LPBYTE) pLevel10 + BytesRequired + sizeof(WKSTA_INFO_10);

                //
                // Now move the variable length entries into the new buffer from
                // the 101, 402 and User_1 data structures.
                //

                NetpMoveStrings((LPTSTR *)&pFloor, (LPTSTR) pLevel101, pLevel10,
                                NetpWksta10_101, Level10_101_Length);

                NetpMoveStrings((LPTSTR *)&pFloor, (LPTSTR) pLevelUser_1, pLevel10,
                                NetpWksta10_User_1, Level10_User_1_Length);

                //
                // Now set the rest of the fields in the fixed length portion
                // of the structure
                //

                ((PWKSTA_INFO_10) pLevel10)->wki10_ver_major =
                    pLevel101->wki101_ver_major;
                ((PWKSTA_INFO_10) pLevel10)->wki10_ver_minor =
                    pLevel101->wki101_ver_minor;

                //
                // Put the pointer to the new structure in the user's pointer.
                //

                *ppbBuffer = pLevel10;

                break;
            }

            //
            // Not a level I recognize
            //

            default:
                return ERROR_INVALID_LEVEL;

        } // end of the switch statement
    } // end of the try block

    finally
    {
        //
        // Free up the buffers returned by NetWkstaGetInfo
        //

        NetApiBufferFree((LPBYTE) pLevel101);
        NetApiBufferFree((LPBYTE) pLevelUser_1);

        if (pLevel502)
        {
            NetApiBufferFree((LPBYTE) pLevel502);
        }
    }

    return NERR_Success;
}


NET_API_STATUS
NetpMakeWkstaLevelForNT(
    IN DWORD Level,
    PWKSTA_INFO_101 pLevel101,
    PWKSTA_USER_INFO_1 pLevelUser_1,
    PWKSTA_INFO_502 pLevel502,
    OUT PWKSTA_INFO_0 * ppLevel0
    )
{

    DWORD BytesRequired = 0;
    DWORD ReturnCode;
    DWORD Level0_101_Length[3];
    DWORD Level0_User_1_Length[2];
    DWORD Level1_User_1_Length[2];
    DWORD i;
    LPBYTE pFloor;

    NetpAssert( (Level==0) || (Level==1) );

    //
    // Initialize the Level0_xxx_Length array with the length of each string
    // in the buffers, and allocate the new buffer for WKSTA_INFO_0
    //

    BUILD_LENGTH_ARRAY(BytesRequired, 0, 101, Wksta)
    BUILD_LENGTH_ARRAY(BytesRequired, 0, User_1, Wksta)

    //
    // If this is for a level 1, allocate the additional space for the extra
    // elements
    //

    if (Level == 1) {
        BUILD_LENGTH_ARRAY(BytesRequired, 1, User_1, Wksta)
    }

    //
    // Allocate the new buffer which will be returned to the user.  Allocate
    // space for a level 1 just in case that's what we're doing.
    //

    ReturnCode = NetapipBufferAllocate(BytesRequired + sizeof(WKSTA_INFO_1),
        (LPVOID *) ppLevel0);
    if (ReturnCode) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // First get the floor to start moving strings in at.
    //

    pFloor = (LPBYTE) *ppLevel0 + BytesRequired + sizeof(WKSTA_INFO_1);

    //
    // Now move the variable length entries into the new buffer from the
    // 2 data structures.
    //

    NetpMoveStrings((LPTSTR*)&pFloor, (LPTSTR)pLevel101, (LPTSTR)*ppLevel0,
        NetpWksta0_101,
        Level0_101_Length);

    NetpMoveStrings((LPTSTR*)&pFloor, (LPTSTR)pLevelUser_1, (LPTSTR)*ppLevel0,
        NetpWksta0_User_1, Level0_User_1_Length);

    //
    // Now set the rest of the fields in the fixed length portion
    // of the structure.  Most of these fields don't exist on NT, so
    // I'll just say BIG!
    //

    (*ppLevel0)->wki0_ver_major       = pLevel101->wki101_ver_major;
    (*ppLevel0)->wki0_ver_minor       = pLevel101->wki101_ver_minor;
    (*ppLevel0)->wki0_charwait        = pLevel502->wki502_char_wait;
    (*ppLevel0)->wki0_chartime        = pLevel502->wki502_collection_time;
    (*ppLevel0)->wki0_charcount =
        pLevel502->wki502_maximum_collection_count;
    (*ppLevel0)->wki0_keepconn        = pLevel502->wki502_keep_conn;
    (*ppLevel0)->wki0_keepsearch      = (ULONG)-1;
    (*ppLevel0)->wki0_maxthreads      = pLevel502->wki502_max_threads;
    (*ppLevel0)->wki0_maxcmds         = pLevel502->wki502_max_cmds;
    (*ppLevel0)->wki0_numworkbuf      = (ULONG)-1;
    (*ppLevel0)->wki0_sizworkbuf      = (ULONG)-1;
    (*ppLevel0)->wki0_maxwrkcache     = (ULONG)-1;
    (*ppLevel0)->wki0_sesstimeout     = pLevel502->wki502_sess_timeout;
    (*ppLevel0)->wki0_sizerror        = (ULONG)-1;
    (*ppLevel0)->wki0_numalerts       = (ULONG)-1;
    (*ppLevel0)->wki0_numservices     = (ULONG)-1;
    (*ppLevel0)->wki0_errlogsz        = (ULONG)-1;
    (*ppLevel0)->wki0_printbuftime    = (ULONG)-1;
    (*ppLevel0)->wki0_numcharbuf      = (ULONG)-1;
    (*ppLevel0)->wki0_sizcharbuf      = pLevel502->wki502_siz_char_buf;
    (*ppLevel0)->wki0_wrkheuristics   = NULL;
    (*ppLevel0)->wki0_mailslots       = (ULONG)-1;

    //
    // If we're building a level 1, do the incremental fields
    //

    if (Level == 1) {
        //
        // Now finish up by moving in the level 1 stuff.  This assumes that all
        // the offsets into the level 0 and level 1 structures are the same
        // except for the additional level 1 stuff
        //

        //
        // First the strings
        //

        NetpMoveStrings((LPTSTR*)&pFloor, (LPTSTR)pLevelUser_1, (LPTSTR)*ppLevel0,
            NetpWksta1_User_1, Level1_User_1_Length);

        //
        // No fixed length data
        //

    }

    return 0 ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\nettext.c ===
/********************************************************************/
/**         Microsoft LAN Manager              **/
/**       Copyright(c) Microsoft Corp., 1987-1991      **/
/********************************************************************/

/***
 *
 * READ THIS READ THIS READ THIS READ THIS READ THIS  READ THIS  READ THIS
 *
 * If you change this file you must regenerate nettext.h via:
 *
 *     sed -n -f text.sed nettext.c > nettext.h
 *
 * This is just until there is a sed on NT
 *
 ***/

#define INCL_NOCOMMON
#include <os2.h>
#include <lmcons.h>
#include <lmsvc.h>
#include <icanon.h>
#include <swtchtxt.h>

TCHAR * NULL_STRING =           TEXT("");
TCHAR * DOT_STRING =            TEXT(".");

/* Service name texts */
TCHAR * txt_SERVICE_MSG_SRV =       SERVICE_MESSENGER;
TCHAR * txt_SERVICE_REDIR =     SERVICE_WORKSTATION;
TCHAR * txt_SERVICE_FILE_SRV =      SERVICE_SERVER;
TCHAR * txt_SERVICE_ALERTER =       SERVICE_ALERTER;
TCHAR * txt_SERVICE_NETLOGON =      SERVICE_NETLOGON;
TCHAR * txt_SERVICE_REPL =      SERVICE_REPL;

TCHAR * txt_LIST_DELIMITER_STR_UI = LIST_DELIMITER_STR_UI;

TCHAR * ADMIN_DOLLAR =          TEXT("ADMIN$");
TCHAR * IPC_DOLLAR =            TEXT("IPC$");

TCHAR USER_MAXSTOR_UNLIMITED[] =     TEXT("UNLIMITED");

TCHAR * fmtPSZ =            TEXT("%-*.*ws%Fws\r\n");
TCHAR * fmtNPSZ =           TEXT("%-*.*ws%ws\r\n");
TCHAR * fmtUSHORT =         TEXT("%-*.*ws%hu\r\n");
TCHAR * fmtULONG =          TEXT("%-*.*ws%lu\r\n");

TCHAR USER_NEVER[] =        TEXT("NEVER");
TCHAR USER_ALL[] =      TEXT("ALL");
TCHAR WKSTA_ALL[] =     TEXT("*");
TCHAR SERVER_ANY[] =        TEXT("\\\\*");
TCHAR USER_HOURS_NONE[] =   TEXT("\"\"");
TCHAR USE_USER[] = TEXT("USER");

TCHAR * MSG_HYPHENS =           TEXT("----------------------------------------")
                    TEXT("---------------------------------------\r\n");


/*
 * all the switches go here
 */
TCHAR swtxt_SW_YES[] = SW_YES;
TCHAR swtxt_SW_NO[] = SW_NO;
TCHAR swtxt_SW_HELP[] = SW_HELP;
TCHAR swtxt_SW_SYNTAX[] = SW_SYNTAX;
TCHAR swtxt_SW_ADD[] = SW_ADD;
TCHAR swtxt_SW_DELETE[] = SW_DELETE;
TCHAR swtxt_SW_REMARK[] = SW_REMARK;
TCHAR swtxt_SW_COMMENT[] = SW_COMMENT;
TCHAR swtxt_SW_OPTIONS[] = SW_OPTIONS;
TCHAR swtxt_SW_PRIORITY[] = SW_PRIORITY;
TCHAR swtxt_SW_ROUTE[] = SW_ROUTE;
TCHAR swtxt_SW_DOMAIN[] = SW_DOMAIN;
TCHAR swtxt_SW_NETWARE[] = SW_NETWARE;
TCHAR swtxt_SW_RANDOM[] = SW_RANDOM;
TCHAR swtxt_SW_RTSDOMAIN[] = SW_RTSDOMAIN;
TCHAR swtxt_SW_SETSNTP[] = SW_SETSNTP;
TCHAR swtxt_SW_QUERYSNTP[] = SW_QUERYSNTP;

TCHAR swtxt_SW_ALERTER_SIZALERTBUF[] = SW_ALERTER_SIZALERTBUF;
TCHAR swtxt_SW_NETLOGON_CENTRALIZED[] = SW_NETLOGON_CENTRALIZED;
TCHAR swtxt_SW_NETLOGON_PULSE[] = SW_NETLOGON_PULSE;
TCHAR swtxt_SW_NETLOGON_RANDOMIZE[] = SW_NETLOGON_RANDOMIZE;
TCHAR swtxt_SW_NETLOGON_SYNCHRONIZE[] = SW_NETLOGON_SYNCHRONIZE;
TCHAR swtxt_SW_NETLOGON_SCRIPTS[] = SW_NETLOGON_SCRIPTS;
TCHAR swtxt_SW_UPS_BATTERYTIME[] = SW_UPS_BATTERYTIME;
TCHAR swtxt_SW_UPS_CMDFILE[] = SW_UPS_CMDFILE;
TCHAR swtxt_SW_UPS_DEVICENAME[] = SW_UPS_DEVICENAME;
TCHAR swtxt_SW_UPS_MESSDELAY[] = SW_UPS_MESSDELAY;
TCHAR swtxt_SW_UPS_MESSTIME[] = SW_UPS_MESSTIME;
TCHAR swtxt_SW_UPS_RECHARGE[] = SW_UPS_RECHARGE;
TCHAR swtxt_SW_UPS_SIGNALS[] = SW_UPS_SIGNALS;
TCHAR swtxt_SW_UPS_VOLTLEVELS[] = SW_UPS_VOLTLEVELS;

TCHAR swtxt_SW_WKSTA_CHARCOUNT[] = SW_WKSTA_CHARCOUNT;
TCHAR swtxt_SW_WKSTA_CHARTIME[] = SW_WKSTA_CHARTIME;
TCHAR swtxt_SW_WKSTA_CHARWAIT[] = SW_WKSTA_CHARWAIT;
TCHAR swtxt_SW_WKSTA_COMPUTERNAME[] = SW_WKSTA_COMPUTERNAME;
TCHAR swtxt_SW_WKSTA_KEEPCONN[] = SW_WKSTA_KEEPCONN;
TCHAR swtxt_SW_WKSTA_KEEPSEARCH[] = SW_WKSTA_KEEPSEARCH;
TCHAR swtxt_SW_WKSTA_LOGONSERVER[] = SW_WKSTA_LOGONSERVER;
TCHAR swtxt_SW_WKSTA_MAILSLOTS[] = SW_WKSTA_MAILSLOTS;
TCHAR swtxt_SW_WKSTA_NUMCHARBUF[] = SW_WKSTA_NUMCHARBUF;
TCHAR swtxt_SW_WKSTA_NUMDGRAMBUF[] = SW_WKSTA_NUMDGRAMBUF;
TCHAR swtxt_SW_WKSTA_NUMSERVICES[] = SW_WKSTA_NUMSERVICES;
TCHAR swtxt_SW_WKSTA_NUMWORKBUF[] = SW_WKSTA_NUMWORKBUF;
TCHAR swtxt_SW_WKSTA_SIZCHARBUF[] = SW_WKSTA_SIZCHARBUF;
TCHAR swtxt_SW_WKSTA_SIZERROR[] = SW_WKSTA_SIZERROR;
TCHAR swtxt_SW_WKSTA_SIZWORKBUF[] = SW_WKSTA_SIZWORKBUF;
TCHAR swtxt_SW_WKSTA_WRKHEURISTICS[] = SW_WKSTA_WRKHEURISTICS;
TCHAR swtxt_SW_WKSTA_WRKNETS[] = SW_WKSTA_WRKNETS;
TCHAR swtxt_SW_WKSTA_WRKSERVICES[] = SW_WKSTA_WRKSERVICES;
TCHAR swtxt_SW_WKSTA_PRIMARYDOMAIN[] = SW_WKSTA_PRIMARYDOMAIN;
TCHAR swtxt_SW_WKSTA_OTHDOMAINS[] = SW_WKSTA_OTHDOMAINS;

TCHAR swtxt_SW_WKSTA_MAXERRORLOG[] = SW_WKSTA_MAXERRORLOG;
TCHAR swtxt_SW_WKSTA_MAXWRKCACHE[] = SW_WKSTA_MAXWRKCACHE;
TCHAR swtxt_SW_WKSTA_NUMALERTS[] = SW_WKSTA_NUMALERTS;
TCHAR swtxt_SW_WKSTA_PRINTBUFTIME[] = SW_WKSTA_PRINTBUFTIME;
TCHAR swtxt_SW_WKSTA_SESSTIMEOUT[] = SW_WKSTA_SESSTIMEOUT;

TCHAR swtxt_SW_PRINT_HOLD[] = SW_PRINT_HOLD;
TCHAR swtxt_SW_PRINT_RELEASE[] = SW_PRINT_RELEASE;
TCHAR swtxt_SW_PRINT_AFTER[] = SW_PRINT_AFTER;
TCHAR swtxt_SW_PRINT_FIRST[] = SW_PRINT_FIRST;
TCHAR swtxt_SW_PRINT_LAST[] = SW_PRINT_LAST;
TCHAR swtxt_SW_PRINT_PARMS[] = SW_PRINT_PARMS;
TCHAR swtxt_SW_PRINT_PROCESSOR[] = SW_PRINT_PROCESSOR;
TCHAR swtxt_SW_PRINT_PURGE[] = SW_PRINT_PURGE;
TCHAR swtxt_SW_PRINT_SEPARATOR[] = SW_PRINT_SEPARATOR;
TCHAR swtxt_SW_PRINT_UNTIL[] = SW_PRINT_UNTIL;
TCHAR swtxt_SW_PRINT_DRIVER[] = SW_PRINT_DRIVER;
TCHAR swtxt_SW_SHARE_COMM[] = SW_SHARE_COMM;
TCHAR swtxt_SW_SHARE_PRINT[] = SW_SHARE_PRINT;
TCHAR swtxt_SW_SHARE_UNLIMITED[] = SW_SHARE_UNLIMITED;
TCHAR swtxt_SW_SHARE_USERS[] = SW_SHARE_USERS;
TCHAR swtxt_SW_CACHE[] = SW_CACHE;

TCHAR swtxt_SW_USE_COMM[] = SW_USE_COMM;
TCHAR swtxt_SW_USE_HOME[] = SW_USE_HOME;
TCHAR swtxt_SW_USE_USER[] = SW_USE_USER;
TCHAR swtxt_SW_USE_SMARTCARD[] = SW_USE_SMARTCARD;
TCHAR swtxt_SW_USE_SAVECRED[] = SW_USE_SAVECRED;
TCHAR swtxt_SW_USE_PERSISTENT[] = SW_USE_PERSISTENT;

TCHAR swtxt_SW_USER_ACTIVE[] = SW_USER_ACTIVE;
TCHAR swtxt_SW_USER_COUNTRYCODE[] = SW_USER_COUNTRYCODE;
TCHAR swtxt_SW_USER_EXPIRES[] = SW_USER_EXPIRES;
TCHAR swtxt_SW_USER_ENABLESCRIPT[] = SW_USER_ENABLESCRIPT;
TCHAR swtxt_SW_USER_FULLNAME[] = SW_USER_FULLNAME;
TCHAR swtxt_SW_USER_HOMEDIR[] = SW_USER_HOMEDIR;
TCHAR swtxt_SW_USER_PARMS[] = SW_USER_PARMS;
TCHAR swtxt_SW_USER_PASSWORDREQ[] = SW_USER_PASSWORDREQ;
TCHAR swtxt_SW_USER_PASSWORDCHG[] = SW_USER_PASSWORDCHG;
TCHAR swtxt_SW_USER_SCRIPTPATH[] = SW_USER_SCRIPTPATH;
TCHAR swtxt_SW_USER_TIMES[] = SW_USER_TIMES;
TCHAR swtxt_SW_USER_USERCOMMENT[] = SW_USER_USERCOMMENT;
TCHAR swtxt_SW_USER_WORKSTATIONS[] = SW_USER_WORKSTATIONS;
TCHAR swtxt_SW_USER_PROFILEPATH[] = SW_USER_PROFILEPATH;

TCHAR swtxt_SW_SRV_SRVCOMMENT[] = SW_SRV_SRVCOMMENT;
TCHAR swtxt_SW_SRV_AUTODISCONNECT[] = SW_SRV_AUTODISCONNECT;
TCHAR swtxt_SW_SRV_MAXUSERS[] = SW_SRV_MAXUSERS;
TCHAR swtxt_SW_SRV_SRVANNOUNCE[] = SW_SRV_SRVANNOUNCE;
TCHAR swtxt_SW_SRV_SRVANNDELTA[] = SW_SRV_SRVANNDELTA;
TCHAR swtxt_SW_SRV_MAXSESSOPENS[] = SW_SRV_MAXSESSOPENS;
TCHAR swtxt_SW_SRV_NUMREQBUF[] = SW_SRV_NUMREQBUF;
TCHAR swtxt_SW_SRV_SIZREQBUF[] = SW_SRV_SIZREQBUF;
TCHAR swtxt_SW_SRV_NUMBIGBUF[] = SW_SRV_NUMBIGBUF;
TCHAR swtxt_SW_SRV_SRVHIDDEN[] = SW_SRV_SRVHIDDEN;
TCHAR swtxt_SW_SRV_DEBUG[] = SW_SRV_DEBUG;

TCHAR swtxt_SW_STATS_CLEAR[] = SW_STATS_CLEAR;
TCHAR swtxt_SW_ADMIN_COMMAND[] = SW_ADMIN_COMMAND;
TCHAR swtxt_SW_MESSAGE_BROADCAST[] = SW_MESSAGE_BROADCAST;

TCHAR swtxt_SW_ACCOUNTS_FORCELOGOFF[] = SW_ACCOUNTS_FORCELOGOFF;
TCHAR swtxt_SW_ACCOUNTS_UNIQUEPW[] = SW_ACCOUNTS_UNIQUEPW;
TCHAR swtxt_SW_ACCOUNTS_MINPWLEN[] = SW_ACCOUNTS_MINPWLEN;
TCHAR swtxt_SW_ACCOUNTS_MINPWAGE[] = SW_ACCOUNTS_MINPWAGE;
TCHAR swtxt_SW_ACCOUNTS_MAXPWAGE[] = SW_ACCOUNTS_MAXPWAGE;
TCHAR swtxt_SW_ACCOUNTS_ROLE[] = SW_ACCOUNTS_ROLE;
TCHAR swtxt_SW_ACCOUNTS_PRIMARY[] = SW_ACCOUNTS_PRIMARY;
TCHAR swtxt_SW_ACCOUNTS_LOCKOUT[] = SW_ACCOUNTS_LOCKOUT;
TCHAR swtxt_SW_ACCOUNTS_SYNCH[] = SW_ACCOUNTS_SYNCH;
TCHAR swtxt_SW_ACCOUNTS_LOCKOUT_THRESHOLD[] = SW_ACCOUNTS_LOCKOUT_THRESHOLD;
TCHAR swtxt_SW_ACCOUNTS_LOCKOUT_DURATION[] = SW_ACCOUNTS_LOCKOUT_DURATION;
TCHAR swtxt_SW_ACCOUNTS_LOCKOUT_WINDOW[] = SW_ACCOUNTS_LOCKOUT_WINDOW;
TCHAR swtxt_SW_REPL_REPL[] = SW_REPL_REPL;
TCHAR swtxt_SW_REPL_EXPPATH[] = SW_REPL_EXPPATH;
TCHAR swtxt_SW_REPL_IMPPATH[] = SW_REPL_IMPPATH;
TCHAR swtxt_SW_REPL_EXPLIST[] = SW_REPL_EXPLIST;
TCHAR swtxt_SW_REPL_IMPLIST[] = SW_REPL_IMPLIST;
TCHAR swtxt_SW_REPL_TRYUSER[] = SW_REPL_TRYUSER;
TCHAR swtxt_SW_REPL_LOGON[] = SW_REPL_LOGON;
TCHAR swtxt_SW_REPL_PASSWD[] = SW_REPL_PASSWD;
TCHAR swtxt_SW_REPL_SYNCH[] = SW_REPL_SYNCH;
TCHAR swtxt_SW_REPL_PULSE[] = SW_REPL_PULSE;
TCHAR swtxt_SW_REPL_GUARD[] = SW_REPL_GUARD;
TCHAR swtxt_SW_REPL_RANDOM[] = SW_REPL_RANDOM;

TCHAR swtxt_SW_TIME_SET[] = SW_TIME_SET;

TCHAR swtxt_SW_COMPUTER_JOIN[] = SW_COMPUTER_JOIN;
TCHAR swtxt_SW_COMPUTER_LEAVE[] = SW_COMPUTER_LEAVE;
TCHAR swtxt_SW_NETWORK[] = SW_NETWORK;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\help\makefile.inc ===
$(O)\netus.hlp:  net.hlp
    copy net.hlp $(O)\netus.hlp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\help\dummy.c ===
void
DummyEntryPoint(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\inc\interpre.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    interpre.h

Abstract:

    This is used by the command parser.

Author:

    Dan Hinsley (danhi) 8-Jun-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

--*/

#define	X_RULE		0
#define	X_OR		1
#define	X_PROC		2
#define	X_TOKEN		3
#define	X_CHECK		4
#define	X_CONDIT	5
#define	X_ACTION	6
#define	X_ACCEPT	7
#define	X_DEFINE	8
#define	X_PUSH		9
#define	X_ANY		10
#define	X_SWITCH	11

#define	XF_PTR		0x01	/*  how to assign values to entries  */
#define	XF_INDEX	0x02

#define	XF_NEW_STRING	0x04
#define	XF_VALUE		0x08	/*  how to output those entries  */
#define	XF_PRINT		0x10
#define	XF_DEFINE		0x20
#define	XF_TOKEN		0x40
#define	XF_OR			0x80

#define	MX_PRINT(A)	((A).x_print)
#define	MX_TYPE(A)	((A).x_type)
#define	MX_FLAGS(A)	((A).x_flags)

typedef	struct	s_x	{
	char	*x_print;
	char	x_type;
	char	x_flags;
	} X;

extern	X	X_array[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\swtchtbl.c ===
/********************************************************************/
/**         Microsoft LAN Manager              **/
/**       Copyright(c) Microsoft Corp., 1987-1990      **/
/********************************************************************/

#define INCL_NOCOMMON
#include <os2.h>
#include "netcmds.h"
#include "nettext.h"

/***
 *  READ THIS READ THIS READ THIS
 *
 *  If this file is changed, swtchtbl.h must be regenerated via the following
 *  command:
 *
 *      sed -n -f text.sed swtchtbl.c > swtchtbl.h
 *
 *  This is just until there is a sed supported on NT
 *
 ***
 *
 *  This list of valid switches for each command is made up of
 *  ordered triples.  The first in each triple is what is acceptable
 *  from the command line.  The second in the triple is
 *  what the switch get TRANSLATED into!  If the second is NULL,
 *  no translation is performed.  The translation is done by
 *  ValidateSwitches(), which should be called as the first
 *  condition in the grammar (for each token).  The third value
 *  in the triple specifies whether an arguement is allowed following
 *  the switch.  Values for the third element are NO_ARG, ARG_OPT,
 *  and ARG_REQ.
 *
 *  A small example:
 *   static SWITCHTAB *foo_switches[] = {
 *  "/BAR", "/BELL", ARG_REQ,
 *  "/JACKIE", NULL, NO_ARG,
 *  NULL, NULL, NO_ARG };
 *
 *  user types:  net foo /bar:12 /jackie
 *
 *  After ValidateSwitches is called, the SwitchList will contain:
 *  /BELL:12, and /JACKIE.  Simple enough!
 *
 *  This translation ability can be used for internationalization,
 *  customization, and backwards compatibility.
 *
 *  To prevent folding to upper case of the switch ARGUMENT (switches
 *  are always folded), add the English language form to the no_fold
 *  array.  (The english form is the 2nd element in the truple if there
 *  is a second element; o/w it is the first element.)
 */

/* It should not be necessary to change this.  Provided only for future. */

SWITCHTAB no_switches[] = {
    NULL, NULL, NO_ARG };

SWITCHTAB add_only_switches[] = {
    swtxt_SW_ADD, NULL, NO_ARG,
    NULL, NULL, NO_ARG };

SWITCHTAB del_only_switches[] = {
    swtxt_SW_DELETE, NULL, NO_ARG,
    NULL, NULL, NO_ARG };

SWITCHTAB domain_only_switches[] = {
    swtxt_SW_DOMAIN, NULL, ARG_REQ,
    NULL, NULL, NO_ARG };

SWITCHTAB add_del_switches[] = {
    swtxt_SW_ADD, NULL, NO_ARG,
    swtxt_SW_DELETE, NULL, NO_ARG,
    NULL, NULL, NO_ARG };

SWITCHTAB accounts_switches[] = {
    swtxt_SW_ACCOUNTS_FORCELOGOFF,  NULL, ARG_REQ,
    swtxt_SW_ACCOUNTS_UNIQUEPW,     NULL, ARG_REQ,
    swtxt_SW_ACCOUNTS_MINPWLEN,     NULL, ARG_REQ,
    swtxt_SW_ACCOUNTS_MINPWAGE,     NULL, ARG_REQ,
    swtxt_SW_ACCOUNTS_MAXPWAGE,     NULL, ARG_REQ,
    swtxt_SW_ACCOUNTS_SYNCH,        NULL, NO_ARG,
    swtxt_SW_DOMAIN,            NULL, NO_ARG,
    swtxt_SW_ACCOUNTS_LOCKOUT_THRESHOLD,NULL, ARG_REQ,
    swtxt_SW_ACCOUNTS_LOCKOUT_DURATION, NULL, ARG_REQ,
    swtxt_SW_ACCOUNTS_LOCKOUT_WINDOW,   NULL, ARG_REQ,
    NULL,       NULL, NO_ARG };


SWITCHTAB computer_switches[] = {
    swtxt_SW_ADD,       NULL, NO_ARG,
    swtxt_SW_DELETE,        NULL, NO_ARG,
    swtxt_SW_COMPUTER_JOIN, NULL, NO_ARG,
    swtxt_SW_COMPUTER_LEAVE,NULL, NO_ARG,
    NULL, NULL, NO_ARG };

SWITCHTAB config_wksta_switches[] = {
    swtxt_SW_WKSTA_CHARWAIT, NULL, ARG_REQ,
    swtxt_SW_WKSTA_CHARTIME, NULL, ARG_REQ,
    swtxt_SW_WKSTA_CHARCOUNT, NULL, ARG_REQ,
#ifndef NTENV
    swtxt_SW_WKSTA_OTHDOMAINS, NULL, ARG_OPT,
    swtxt_SW_WKSTA_PRINTBUFTIME, NULL, ARG_REQ,
    swtxt_SW_WKSTA_MAXERRORLOG, NULL, ARG_REQ,
#endif /* !NTENV */
    NULL, NULL, NO_ARG };

#ifdef NTENV
SWITCHTAB config_server_switches[] = {
    swtxt_SW_SRV_SRVCOMMENT, NULL, ARG_REQ,
    swtxt_SW_SRV_AUTODISCONNECT, NULL, ARG_REQ,
    swtxt_SW_SRV_SRVHIDDEN, NULL, ARG_OPT,
    NULL, NULL, NO_ARG };
#else /* !NTENV */
SWITCHTAB config_server_switches[] = {
    swtxt_SW_SRV_SRVCOMMENT, NULL, ARG_REQ,
    swtxt_SW_SRV_AUTODISCONNECT, NULL, ARG_REQ,
    swtxt_SW_SRV_DISKALERT,  NULL, ARG_REQ,
    swtxt_SW_SRV_ERRORALERT, NULL, ARG_REQ,
    swtxt_SW_SRV_LOGONALERT, NULL, ARG_REQ,
    swtxt_SW_SRV_MAXAUDITLOG, NULL, ARG_REQ,
    swtxt_SW_SRV_NETIOALERT, NULL, ARG_REQ,
    swtxt_SW_SRV_SRVHIDDEN, NULL, ARG_OPT,
    swtxt_SW_SRV_ACCESSALERT, NULL, ARG_REQ,
    swtxt_SW_SRV_ALERTNAMES, NULL, ARG_REQ,
    swtxt_SW_SRV_ALERTSCHED, NULL, ARG_REQ,
    NULL, NULL, NO_ARG };
#endif /* !NTENV */

SWITCHTAB file_switches[] = {
    TEXT("/CLOSE"), NULL, NO_ARG,
    NULL, NULL, NO_ARG };

SWITCHTAB help_switches[] = {
    swtxt_SW_OPTIONS, NULL, NO_ARG,
    NULL, NULL, NO_ARG };

SWITCHTAB print_switches[] = {
    swtxt_SW_DELETE, NULL, NO_ARG,
    swtxt_SW_PRINT_HOLD, NULL, NO_ARG,
    swtxt_SW_PRINT_RELEASE, NULL, NO_ARG,
#ifndef NTENV
    swtxt_SW_OPTIONS, NULL, NO_ARG,
    swtxt_SW_PRIORITY, NULL, ARG_REQ,
    swtxt_SW_REMARK, NULL, ARG_REQ,
    swtxt_SW_ROUTE, NULL, ARG_REQ,
    swtxt_SW_PRINT_AFTER, NULL, ARG_REQ,
    swtxt_SW_PRINT_FIRST, NULL, NO_ARG,
    swtxt_SW_PRINT_LAST, NULL, NO_ARG,
    swtxt_SW_PRINT_PARMS, NULL, ARG_REQ,
    swtxt_SW_PRINT_PROCESSOR, NULL, ARG_REQ,
    swtxt_SW_PRINT_PURGE, NULL, NO_ARG,
    swtxt_SW_PRINT_SEPARATOR, NULL, ARG_REQ,
    swtxt_SW_PRINT_UNTIL, NULL, ARG_REQ,
    swtxt_SW_PRINT_DRIVER, NULL, ARG_REQ,
#endif /* !NTENV */
    NULL, NULL, NO_ARG };

SWITCHTAB send_switches[] = {
    swtxt_SW_MESSAGE_BROADCAST, NULL, NO_ARG,
    swtxt_SW_DOMAIN,          NULL, ARG_OPT,
    TEXT("/USERS"),       NULL, NO_ARG,
    NULL, NULL, NO_ARG };

SWITCHTAB share_switches[] = {
    swtxt_SW_DELETE, NULL, NO_ARG,
    swtxt_SW_REMARK, NULL, ARG_REQ,
#ifndef NTENV
    swtxt_SW_SHARE_COMM, NULL, NO_ARG,
#endif /* !NTENV */
    swtxt_SW_SHARE_UNLIMITED, NULL, NO_ARG,
    swtxt_SW_SHARE_USERS, NULL, ARG_REQ,
    swtxt_SW_CACHE, NULL, ARG_OPT,
    NULL, NULL, NO_ARG };

SWITCHTAB start_alerter_switches[] = {
    swtxt_SW_ALERTER_SIZALERTBUF, NULL, ARG_REQ,
    NULL, NULL, NO_ARG };

SWITCHTAB start_netlogon_switches[] = {
    swtxt_SW_NETLOGON_CENTRALIZED,  NULL, ARG_REQ,
    swtxt_SW_NETLOGON_PULSE,        NULL, ARG_REQ,
    swtxt_SW_NETLOGON_RANDOMIZE,    NULL, ARG_REQ,
    swtxt_SW_NETLOGON_SYNCHRONIZE,  NULL, ARG_OPT,
    swtxt_SW_NETLOGON_SCRIPTS,      NULL, ARG_REQ,
    NULL, NULL, NO_ARG };

/* Switches swallowed by netcmd.  Not static, used in start.c */

SWITCHTAB start_netlogon_ignore_switches[] = {
    swtxt_SW_NETLOGON_CENTRALIZED, NULL, ARG_REQ,
    NULL, NULL, NO_ARG };

SWITCHTAB start_repl_switches[] = {
    swtxt_SW_REPL_REPL, NULL, ARG_OPT,
    swtxt_SW_REPL_EXPPATH, NULL, ARG_REQ,
    swtxt_SW_REPL_EXPLIST, NULL, ARG_REQ,
    swtxt_SW_REPL_IMPPATH, NULL, ARG_REQ,
    swtxt_SW_REPL_IMPLIST, NULL, ARG_REQ,
    swtxt_SW_REPL_TRYUSER, NULL, ARG_OPT,
    swtxt_SW_REPL_LOGON, NULL, ARG_REQ,
    swtxt_SW_REPL_PASSWD, NULL, ARG_REQ,
    swtxt_SW_REPL_SYNCH, NULL, ARG_REQ,
    swtxt_SW_REPL_PULSE, NULL, ARG_REQ,
    swtxt_SW_REPL_GUARD, NULL, ARG_REQ,
    swtxt_SW_REPL_RANDOM, NULL, ARG_REQ,
    NULL, NULL, NO_ARG };

/* start_rdr_switches MANIFEST!  used three places  */

#define WORKSTATION_SWITCHES_TWO  /* first half of switches */ \
    swtxt_SW_WKSTA_CHARCOUNT, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_CHARTIME, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_CHARWAIT, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_COMPUTERNAME, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_KEEPCONN, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_KEEPSEARCH, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_LOGONSERVER, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_MAILSLOTS, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_NUMCHARBUF, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_NUMDGRAMBUF, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_NUMWORKBUF, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_OTHDOMAINS, NULL, ARG_OPT, \
    swtxt_SW_WKSTA_PRIMARYDOMAIN, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_SIZCHARBUF, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_SIZWORKBUF, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_WRKHEURISTICS, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_WRKNETS, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_NUMSERVICES, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_WRKSERVICES, NULL, ARG_REQ


/*  WORKSTATION_SWITCHES_THREE are the switches that are different
 *  between MS-DOS and OS/2
 */
#define WORKSTATION_SWITCHES_THREE  /* second half of switches */ \
    swtxt_SW_WKSTA_MAXERRORLOG, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_MAXWRKCACHE, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_NUMALERTS, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_PRINTBUFTIME, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_SESSTIMEOUT, NULL, ARG_REQ, \
    swtxt_SW_WKSTA_SIZERROR, NULL, ARG_REQ

/* start_rdr_switches not static! used in start.c */

SWITCHTAB start_rdr_switches[] = {
    // WORKSTATION_SWITCHES_ONE,  (no longer used)
    WORKSTATION_SWITCHES_TWO,
    WORKSTATION_SWITCHES_THREE,
    NULL, NULL, NO_ARG };

SWITCHTAB start_rdr_ignore_switches[] = {
    swtxt_SW_WKSTA_LOGONSERVER,     NULL, ARG_REQ,
    NULL, NULL, NO_ARG };

SWITCHTAB start_msg_switches[] = {
    // WORKSTATION_SWITCHES_ONE, (no longer used)
    WORKSTATION_SWITCHES_TWO,
    WORKSTATION_SWITCHES_THREE,
    TEXT("/SIZMESSBUF"), NULL, ARG_REQ,
    TEXT("/MBI"), TEXT("/SIZMESSBUF"), ARG_REQ,
    TEXT("/LOGFILE"), NULL, ARG_REQ,
#ifdef  DOS3
    TEXT("/NMSG"), TEXT("/NUMMSGNAMES"), ARG_REQ,
    TEXT("/NUMMSGNAMES"), NULL, ARG_REQ,
#endif
    NULL, NULL, NO_ARG };

#ifndef NTENV
SWITCHTAB start_srv_switches[] = {
    WORKSTATION_SWITCHES_ONE,
    WORKSTATION_SWITCHES_TWO,
    WORKSTATION_SWITCHES_THREE,

    TEXT("/N"),   swtxt_SW_SRV_MAXUSERS,  ARG_REQ,
    TEXT("/RDR"), swtxt_SW_SRV_MAXUSERS,  ARG_REQ,
    TEXT("/MB"),  swtxt_SW_SRV_SIZREQBUF,   ARG_REQ,
    TEXT("/RQB"), swtxt_SW_SRV_SIZREQBUF,   ARG_REQ,
    TEXT("/NB"),  swtxt_SW_SRV_NUMREQBUF,   ARG_REQ,
    TEXT("/REQ"), swtxt_SW_SRV_NUMREQBUF,   ARG_REQ,
    TEXT("/O"),   swtxt_SW_SRV_MAXSHARES,   ARG_REQ,
    TEXT("/SHR"), swtxt_SW_SRV_MAXSHARES,   ARG_REQ,
    TEXT("/SF"),  swtxt_SW_SRV_MAXSESSOPENS,    ARG_REQ,

    swtxt_SW_SRV_AUDITING,  NULL, ARG_REQ,
    swtxt_SW_SRV_NOAUDITING,    NULL, ARG_REQ,
    swtxt_SW_SRV_GUESTACCT, NULL, ARG_REQ,
    swtxt_SW_SRV_MAXSESSREQS,   NULL, ARG_REQ,
    swtxt_SW_SRV_MAXSHARES, NULL, ARG_REQ,
    swtxt_SW_SRV_NUMADMIN,  NULL, ARG_REQ,
    swtxt_SW_SRV_SECURITY,  NULL, ARG_REQ,
    swtxt_SW_SRV_SRVHEURISTICS,     NULL, ARG_REQ,
    swtxt_SW_SRV_SRVNETS,   NULL, ARG_REQ,
    swtxt_SW_SRV_SRVSERVICES,   NULL, ARG_REQ,
    swtxt_SW_SRV_USERPATH,  NULL, ARG_REQ,
    swtxt_SW_SRV_ACCESSALERT,   NULL, ARG_REQ,
    swtxt_SW_SRV_ALERTNAMES,    NULL, ARG_REQ,
    swtxt_SW_SRV_ALERTSCHED,    NULL, ARG_REQ,
    swtxt_SW_SRV_DISKALERT, NULL, ARG_REQ,
    swtxt_SW_SRV_ERRORALERT,    NULL, ARG_REQ,
    swtxt_SW_SRV_LOGONALERT,    NULL, ARG_REQ,
    swtxt_SW_SRV_MAXAUDITLOG,   NULL, ARG_REQ,
    swtxt_SW_SRV_NETIOALERT,    NULL, ARG_REQ,
    swtxt_SW_SRV_SRVHIDDEN, NULL, ARG_REQ,
    swtxt_SW_SRV_AUTOPROFILE,   NULL, ARG_REQ,
    swtxt_SW_SRV_AUTOPATH,  NULL, ARG_REQ,
    swtxt_SW_SRV_MAXSESSOPENS,  NULL, ARG_REQ,
    swtxt_SW_SRV_MAXUSERS,  NULL, ARG_REQ,
    swtxt_SW_SRV_NUMBIGBUF, NULL, ARG_REQ,
    swtxt_SW_SRV_NUMREQBUF, NULL, ARG_REQ,
    swtxt_SW_SRV_SIZREQBUF, NULL, ARG_REQ,
    swtxt_SW_SRV_SRVANNDELTA,   NULL, ARG_REQ,
    swtxt_SW_SRV_SRVANNOUNCE,   NULL, ARG_REQ,
    swtxt_SW_SRV_AUTODISCONNECT,    NULL, ARG_REQ,
    swtxt_SW_SRV_SRVCOMMENT,    NULL, ARG_REQ,
    NULL, NULL, NO_ARG };
#else /* NTENV */
SWITCHTAB start_srv_switches[] = {
    swtxt_SW_SRV_MAXSESSOPENS,  NULL, ARG_REQ,
    swtxt_SW_SRV_MAXUSERS,  NULL, ARG_REQ,
    swtxt_SW_SRV_NUMBIGBUF, NULL, ARG_REQ,
    swtxt_SW_SRV_NUMREQBUF, NULL, ARG_REQ,
    swtxt_SW_SRV_SIZREQBUF, NULL, ARG_REQ,
    swtxt_SW_SRV_SRVANNDELTA,   NULL, ARG_REQ,
    swtxt_SW_SRV_SRVANNOUNCE,   NULL, ARG_REQ,
    swtxt_SW_SRV_AUTODISCONNECT,    NULL, ARG_REQ,
    swtxt_SW_SRV_SRVCOMMENT,    NULL, ARG_REQ,
    swtxt_SW_SRV_DEBUG, NULL, ARG_REQ,
    NULL, NULL, NO_ARG };
#endif /* NTENV */

SWITCHTAB start_ups_switches[] = {
    swtxt_SW_UPS_BATTERYTIME,   NULL, ARG_REQ,
    swtxt_SW_UPS_CMDFILE,   NULL, ARG_REQ,
    swtxt_SW_UPS_DEVICENAME,    NULL, ARG_REQ,
    swtxt_SW_UPS_MESSDELAY, NULL, ARG_REQ,
    swtxt_SW_UPS_MESSTIME,  NULL, ARG_REQ,
    swtxt_SW_UPS_RECHARGE,  NULL, ARG_REQ,
    swtxt_SW_UPS_SIGNALS,   NULL, ARG_REQ,
    swtxt_SW_UPS_VOLTLEVELS,    NULL, ARG_REQ,
    NULL, NULL, NO_ARG };

SWITCHTAB stats_switches[] = {
    swtxt_SW_STATS_CLEAR,   NULL, NO_ARG,
    NULL, NULL, NO_ARG };

SWITCHTAB use_switches[] = {
#ifdef NTENV
    swtxt_SW_USE_USER,        NULL, ARG_REQ,
    swtxt_SW_USE_PERSISTENT,  NULL, ARG_REQ,
    swtxt_SW_USE_HOME,        NULL, NO_ARG,
    swtxt_SW_USE_SMARTCARD,   NULL, NO_ARG,
    swtxt_SW_USE_SAVECRED,    NULL, NO_ARG,
#else
    swtxt_SW_USE_COMM,      NULL, NO_ARG,
#endif /* NTENV */
    swtxt_SW_DELETE,        NULL, NO_ARG,
    NULL, NULL, NO_ARG };

SWITCHTAB user_switches[] = {
    swtxt_SW_ADD,       NULL, NO_ARG,
    swtxt_SW_DELETE,        NULL, NO_ARG,
    swtxt_SW_DOMAIN,        NULL, NO_ARG,
    swtxt_SW_COMMENT,       NULL, ARG_REQ,
    swtxt_SW_REMARK,        swtxt_SW_COMMENT, ARG_REQ,
    swtxt_SW_COMMENT,       NULL, ARG_REQ,
    swtxt_SW_NETWARE,       NULL, ARG_OPT,
    swtxt_SW_RANDOM,        NULL, ARG_OPT,
    swtxt_SW_USER_ACTIVE,   NULL, ARG_OPT,
    swtxt_SW_USER_COUNTRYCODE,  NULL, ARG_REQ,
    swtxt_SW_USER_EXPIRES,  NULL, ARG_REQ,
    swtxt_SW_USER_ENABLESCRIPT, NULL, ARG_REQ,
    swtxt_SW_USER_FULLNAME, NULL, ARG_REQ,
    swtxt_SW_USER_HOMEDIR,  NULL, ARG_REQ,
    swtxt_SW_USER_PARMS,    NULL, ARG_REQ,
    swtxt_SW_USER_PASSWORDREQ,  NULL, ARG_REQ,
    swtxt_SW_USER_PASSWORDCHG,  NULL, ARG_REQ,
    swtxt_SW_USER_SCRIPTPATH,   NULL, ARG_REQ,
    swtxt_SW_USER_TIMES,    NULL, ARG_REQ,
    swtxt_SW_USER_USERCOMMENT,  NULL, ARG_REQ,
    swtxt_SW_USER_WORKSTATIONS, NULL, ARG_REQ,
    swtxt_SW_USER_PROFILEPATH,  NULL, ARG_REQ,
    NULL, NULL, NO_ARG };

SWITCHTAB group_switches[] = {
    swtxt_SW_ADD,       NULL, NO_ARG,
    swtxt_SW_DELETE,        NULL, NO_ARG,
    swtxt_SW_DOMAIN,        NULL, NO_ARG,
    swtxt_SW_COMMENT,       NULL, ARG_REQ,
    swtxt_SW_REMARK,        swtxt_SW_COMMENT, ARG_REQ,
    NULL, NULL, NO_ARG };

SWITCHTAB ntalias_switches[] = {
    swtxt_SW_ADD,       NULL, NO_ARG,
    swtxt_SW_DELETE,        NULL, NO_ARG,
    swtxt_SW_DOMAIN,        NULL, NO_ARG,
    NULL, NULL, NO_ARG };

SWITCHTAB time_switches[] = {
    swtxt_SW_DOMAIN,        NULL, ARG_OPT,
    swtxt_SW_TIME_SET,      NULL, NO_ARG,
    swtxt_SW_RTSDOMAIN,     NULL, ARG_OPT,
    swtxt_SW_SETSNTP,          NULL, ARG_OPT,
    swtxt_SW_QUERYSNTP,     NULL, NO_ARG,
    NULL, NULL, NO_ARG };

SWITCHTAB who_switches[] = {
    swtxt_SW_DOMAIN, NULL, ARG_OPT,
    NULL, NULL, NO_ARG };

SWITCHTAB view_switches[] = {
    swtxt_SW_DOMAIN, NULL, ARG_OPT,
    swtxt_SW_NETWORK, NULL, ARG_OPT,
    swtxt_SW_CACHE, NULL, NO_ARG,
    NULL, NULL, NO_ARG };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\inc\luiint.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    luiint.h

Abstract:

    This file contains the prototypes/manifests used internally by the LUI
    library.

Author:

    Dan Hinsley (danhi) 8-Jun-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

--*/
///////////////////////////////// search lists //////////////////////////////
//   USAGE
//	 we typically declare a data list associating message numbers with
//	 data values, and partially initialize a search list associating
//	 strings with data values. We then complete this search list by passing
//       it together with the data list to a 'setup' function (see SERACH.C).
//  	 
//   CONVENTIONS
// 	 the data lists are terminated with a zero message number, search lists
// 	 terminated with a NULL search string.
//
//   EXAMPLE of USE (for weeks)
//
//   static searchlist_data week_data[] = {	/* strings from message file */
//       {APE2_GEN_SUNDAY_ABBREV,	0},
//       {APE2_GEN_MONDAY_ABBREV,	1},
//       {APE2_GEN_TUESDAY_ABBREV,	2},
//       {APE2_GEN_WEDNSDAY_ABBREV,	3},
//       {APE2_GEN_THURSDAY_ABBREV,	4},
//       {APE2_GEN_FRIDAY_ABBREV,	5},
//       {APE2_GEN_SATURDAY_ABBREV,	6},
//       {APE2_GEN_SUNDAY,		0},
//       {APE2_GEN_MONDAY,		1},
//       {APE2_GEN_TUESDAY,		2},
//       {APE2_GEN_WEDNSDAY,	3},
//       {APE2_GEN_THURSDAY,		4},
//       {APE2_GEN_FRIDAY,		5},
//       {APE2_GEN_SATURDAY,		6},
//       {0,0} 
//   } ;
//
//   #define DAYS_IN_WEEK 	(7)
//   #define NUM_DAYS_LIST 	(sizeof(week_data)/sizeof(week_data[0])+
//				DAYS_IN_WEEK)
//
//   /* 
//    * NOTE - we init the first 7 always recognised days
//    *        and get the rest from the message file 
//    */
//   static searchlist 	week_list[NUM_DAYS_LIST + DAYS_IN_WEEK] = {
//   	{LUI_txt_sunday,0},
//   	{LUI_txt_monday,1},
//   	{LUI_txt_tuesday,2},
//   	{LUI_txt_wednesday,3},
//   	{LUI_txt_thursday,4},
//   	{LUI_txt_friday,5},
//   	{LUI_txt_saturday,6},
//   } ;	

/*-- types for search lists  --*/

/* asssociate message number with value - eg. APE2_GEN_FRIDAY has value 5 */
typedef struct search_list_data {
    LONG msg_no ;	
    LONG value ;
} searchlist_data ;

/* associate search strings with values - eg. "Friday" has value 5 */
typedef struct search_list {
    LPTSTR    s_str ;
    LONG      val ;
} searchlist ;

/*-- function prototypes for search lists --*/

DWORD
ILUI_setup_listW(
    LPTSTR          buffer,
    DWORD           bufsiz,
    DWORD           offset,
    PDWORD          bytesread,
    searchlist_data sdata[],
    searchlist      slist[]
    );

DWORD
ILUI_traverse_slistW( 
    LPTSTR     pszStr,
    searchlist *slist,
    PLONG      pusVal
    );

DWORD
LUI_GetMsgInsW(
    LPTSTR       *istrings, 
    DWORD        nstrings, 
    LPTSTR       msgbuf,
    DWORD        bufsize, 
    DWORD        msgno, 
    unsigned int *msglen
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\inc\luidate.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lui.h

Abstract:

    This file maps the LM 2.x include file name to the appropriate NT include
    file name, and does any other mapping required by this include file.

Author:

    Dan Hinsley (danhi) 8-Jun-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

--*/

DWORD
ParseDate(
    PTCHAR inbuf,
    time_t * time,
    PDWORD parselen,
    DWORD  reserved
    );

DWORD
ParseTime(
    PTCHAR inbuf,
    time_t * time,
    PDWORD parselen,
    DWORD  reserved
    );

DWORD
ParseTime12(
    PTCHAR inbuf,
    time_t * time,
    PDWORD parselen,
    DWORD  reserved
    );

DWORD
ParseTime24(
    PTCHAR inbuf,
    time_t * time,
    PDWORD parselen,
    DWORD  reserved
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\inc\lui.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lui.h

Abstract:

    This file maps the LM 2.x include file name to the appropriate NT include
    file name, and does any other mapping required by this include file.

Author:

    Dan Hinsley (danhi) 8-Jun-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

--*/

#include <stdio.h>
#include <luiint.h>
#include <time.h>

#define LUI_FORMAT_DURATION_LEN  32
#define LUI_FORMAT_TIME_LEN  	 32


/*
 * General word parsing functions and values
 */

#define LUI_UNDEFINED_VAL	0
#define LUI_YES_VAL	        1
#define LUI_NO_VAL 	        2

#define MSG_BUFF_SIZE		512

USHORT LUI_CanonPassword(TCHAR * szPassword);

DWORD  LUI_GetMsg (LPTSTR msgbuf, USHORT bufsize, ULONG msgno);

USHORT LUI_PrintLine(VOID);

DWORD  LUI_YorN(USHORT promptMsgNum, USHORT def);

USHORT LUI_FormatDuration(LONG *, TCHAR *buffer, USHORT bufferlen);

DWORD
GetString(
    LPTSTR  buf,
    DWORD   buflen,
    PDWORD  len,
    LPTSTR  terminator
    );

USHORT LUI_CanonMessagename(PTCHAR buf);

USHORT LUI_CanonMessageDest(PTCHAR buf);

DWORD  LUI_YorNIns(LPTSTR *istrings, USHORT nstrings,
                   USHORT promptMsgNum, USHORT def);

DWORD  LUI_ParseYesNo(LPTSTR inbuf, PDWORD answer);

DWORD  ParseWeekDay(PTCHAR inbuf, PDWORD answer);
DWORD  FormatTimeofDay(time_t *, LPTSTR buf, DWORD buflen);

USHORT LUI_CanonForNetBios( WCHAR * Destination, INT cchDestination,
                            TCHAR * Source );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\common\switches.c ===
/********************************************************************/
/**			Microsoft LAN Manager			   **/
/**		  Copyright(c) Microsoft Corp., 1987-1990	   **/
/********************************************************************/

/*
 *	       Switches.c - switch handling routines
 *
 *	??/??/??, ??????, initial code
 *	10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *	12/04/88, erichn, DOS LM integration
 *	06/08/89, erichn, canonicalization sweep, stronger typing
 *	02/20/91, danhi, change to use lm 16/32 mapping layer
 */


#define INCL_NOCOMMON
#include <os2.h>
#include <apperr.h>
#include <lmerr.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <malloc.h>
#include "netcmds.h"
#include "nettext.h"

/* External variables */

int DOSNEAR FASTCALL firstswitch(TCHAR *known)
{
    if (SwitchList[0] == NULL)
	return 0;
    if (sw_compare(known, SwitchList[0]) >= 0)
	return 1;
    else
	return 0;
}


/*
 * Is the cmd line a valid form of NET ADMIN /C
 */
int DOSNEAR FASTCALL IsAdminCommand(VOID)
{
    if (!SwitchList[0] || !ArgList[1])
	return 0;
    _tcsupr(SwitchList[0]);
    return (IsComputerName(ArgList[1]) &&
	    (sw_compare(swtxt_SW_ADMIN_COMMAND, SwitchList[0]) >= 0));
}

/***	noswitch, oneswitch, twoswitch
 *
 *  noswitch()	Returns TRUE is no switches on the command line
 *  oneswitch() Returns TRUE is there is exactly one switch
 *  twoswitch() Returns TRUE is there are exactly two switches
 *
 */

int DOSNEAR FASTCALL noswitch(VOID)
{
    return (SwitchList[0] == NULL);
}

int DOSNEAR FASTCALL oneswitch(VOID)
{
    return ((SwitchList[0] != NULL) && (SwitchList[1] == NULL));
}

int DOSNEAR FASTCALL twoswitch(VOID)
{
    return ((SwitchList[0] != NULL) && (SwitchList[1] != NULL)
	    && (SwitchList[2] == NULL));
}

/***	noswitch_optional, oneswitch_optional
 *
 *  as above, except that the switch provided as argument is considered
 *  an optional switch that will be allowed. So if you say 
 *  oneswitch_optional("/FOO"), then one switch (any switch) is OK,
 *  and so is two switches if one of them is "/FOO".
 */
int DOSNEAR FASTCALL noswitch_optional(TCHAR *optional_switch ) 
{
    return ( noswitch() ||
             ( oneswitch() && 
	       (sw_compare(optional_switch, SwitchList[0]) >= 0) )
           ) ;
}

int DOSNEAR FASTCALL oneswitch_optional(TCHAR *optional_switch ) 
{
    return ( oneswitch() ||
             ( twoswitch() && 
	       ( (sw_compare(optional_switch, SwitchList[0]) >= 0) ||
	         (sw_compare(optional_switch, SwitchList[1]) >= 0) ) )
           ) ;
}


/***
 * o n l y s w i t c h
 *
 *  Returns TRUE if the first switch matches the named switch, and it
 *  is the only switch.
 */
int DOSNEAR FASTCALL onlyswitch(TCHAR *known)
{
    return (oneswitch() && firstswitch(known));
}


/***	ValidateSwitches
 *
 *  Given a list of valid switches, check each entry in the switch
 *  list.
 *
 *  This function not only checks for invalid switches, but also
 *  attempts to discern ambiguous usages.  A usage is ambiguous if
 *  it does not match any valid swithc exactly, and it a partial
 *  match of more than one switch.  See sw_compare().  This
 *  algorithm can be fooled by nasty lists of valid switches, such
 *  as one which lists the same switch twice.
 *
 *  The function has been modified to canonicalize the SwitchList.
 *  It replaces an '=' in /x=value with a ':'; it translates
 *  switches if needed, (see switches.h); and it expands unambiguous
 *  partial matches to the full switch name.
 *
 *  Returns:
 *	 1:  All switches OK
 *	 *:  If any error, prints a message and exits.
 *
 */

int DOSNEAR FASTCALL ValidateSwitches(USHORT cmd, SWITCHTAB valid_list[])
{
    USHORT	 match;
    int 	 comp_result;
    USHORT	 candidate; /* most recent NEAR match */
    USHORT	 i,j;
    TCHAR *	 good_one; /* which element (cmd_line or trans) of the valid_list */
    int 	 needed;
    TCHAR   FAR * sepptr;

    for (i = 0; SwitchList[i]; i++)
    {
	sepptr = _tcschr(SwitchList[i], ':');
	if (sepptr)
	    *sepptr = NULLC;
	_tcsupr(SwitchList[i]);
	if (sepptr)
	    *sepptr = ':';

	candidate = 0;
	match = 0;

	for (j = 0; valid_list[j].cmd_line; j++)
	{
	    comp_result = sw_compare(valid_list[j].cmd_line, SwitchList[i]);

	    if (comp_result == 0)
	    {
		candidate = j;
		match = 1;
		break;
	    }
	    else if (comp_result == 1)
	    {
		match++;
		candidate = j;
	    }
	}

	if (match == 0)
	{
	    if (! _tcscmp(swtxt_SW_HELP, SwitchList[i]))
		help_help(cmd, ALL);

	    if (! _tcscmp(swtxt_SW_SYNTAX, SwitchList[i]))
		help_help(cmd, USAGE_ONLY);

	    IStrings[0] = SwitchList[i];
	    ErrorPrint(APE_SwUnkSw, 1);
	    help_help(cmd, USAGE_ONLY);
	}
	else if (match > 1)
	{
	    IStrings[0] = SwitchList[i];
	    ErrorPrint(APE_SwAmbSw, 1);
	    help_help(cmd, USAGE_ONLY);
	}

	switch(valid_list[candidate].arg_ok)
	{
	case NO_ARG:
	    if (sepptr)
	    {
		ErrorPrint(APE_InvalidSwitchArg, 0);
		help_help(cmd, USAGE_ONLY);
	    }
	    break;

	case ARG_OPT:
	    break;

	case ARG_REQ:
	    if (!sepptr)
	    {
		ErrorPrint(APE_InvalidSwitchArg, 0);
		help_help(cmd, USAGE_ONLY);
	    }
	    break;
	}

	/* (expansion || translation) required ? */
	if (comp_result || valid_list[candidate].translation)
	{
	     if (valid_list[candidate].translation)
		good_one = valid_list[candidate].translation;
	    else
		good_one = valid_list[candidate].cmd_line;

	    needed = _tcslen(good_one);

	    if (sepptr)
		needed += _tcslen(sepptr);

	    if ((SwitchList[i] = calloc(needed+1, sizeof(TCHAR))) == NULL)
		ErrorExit(NERR_InternalError);

	    _tcscpy(SwitchList[i], good_one);

	    if (sepptr)
		_tcscat(SwitchList[i], sepptr);
	}
    }

    return 1;
}


/***	sw_compare
 *
 *  Compare a known switch name to a switch string passed from
 *  the command line.
 *
 *  The command-line switch may still retain the "excess baggage"
 *  of a value (as in /B:1024).  The comparison is not sensitive
 *  to case, and should be DBCS compatible as it uses the runtime
 *  library to do all searches and compares.
 *
 *  Returns:
 *	-1:  No match
 *	 0:  Exact match to full length of known switch
 *	 1:  Partial match;  matches initial substring of
 *	    known switch
 *
 *  The difference between return 0/1 is used by ValidateSwitches()
 *  to detect the presence of a possibly ambiguous usage.  Once
 *  that function has checked all switches, further compares can
 *  treat results 0 & 1 from this function as "match".
 */

int DOSNEAR FASTCALL sw_compare(TCHAR  *known, TCHAR  *cand)
{
    register unsigned int complen;

    /* Try to find end of switch name by looking */
    /* the for separator between name and value, */
    /* otherwise use total length. */

    complen = _tcscspn(cand, TEXT(":"));

    if (complen < 2)	    /* Special check for empty switch SLASH */
	return -1;

    if (complen > _tcslen(known))
	return -1;

    if (_tcsncmp(known,cand,complen) != 0)
	return -1;

    if (complen == _tcslen(known))
	return 0;

    return 1;
}





/*
 * Used only by interpre.c
 */

int DOSNEAR FASTCALL CheckSwitch(TCHAR *x)
{
    register TCHAR **p;

    for (p=SwitchList; *p; p++)
	if (sw_compare(x,*p) >= 0)
	{
	    return 1;
	}

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\inc\mwksta.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MWKSTA.H

Abstract:

    Contains mapping functions to present netcmd with versions
    of the Net32 APIs which use ASCII instead of Unicode.

    This module maps the NetWksta APIs.

Author:

    Shanku Niyogi   (W-ShankN)   16-Oct-1991

Environment:

    User Mode - Win32

Revision History:

    16-Oct-1991     W-ShankN
        Separated from port1632.h, 32macro.h

--*/

DWORD
MNetWkstaGetInfo(
    DWORD nLevel,
    LPVOID * ppbBuffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\inc\mserver.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MSERVER.H

Abstract:

    Contains mapping functions to present netcmd with versions
    of the Net32 APIs which use ASCII instead of Unicode.

    This module maps the NetServer APIs.

Author:

    Shanku Niyogi   (W-ShankN)   15-Oct-1991

Environment:

    User Mode - Win32

Revision History:

    15-Oct-1991     W-ShankN
        Separated from port1632.h, 32macro.h
    02-Apr-1992     beng
        Added xport apis

--*/

DWORD
MNetServerEnum(
    LPTSTR   pszServer,
    DWORD    nLevel,
    LPBYTE * ppbBuffer,
    DWORD  * pcEntriesRead,
    DWORD    flServerType,
    LPTSTR   pszDomain
    );

DWORD
MNetServerGetInfo(
    LPTSTR   ptszServer,
    DWORD    nLevel,
    LPBYTE * ppbBuffer
    );

DWORD
MNetServerSetInfoLevel2(
    LPBYTE pbBuffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\inc\luitext.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1990		**/ 
/*****************************************************************/ 

/*
 * File:	luitext.h
 *			include file for text strings FIXED into
 *			the LUI library
 * Project:	LANMAN 2.0
 * Authors:	chuckc
 * Remarks:	(none)
 * History:	July 89, chuckc, created
 */

extern TCHAR LUI_txt_yes[] ;
extern TCHAR LUI_txt_no[] ;

extern TCHAR LUI_txt_am[] ;
extern TCHAR LUI_txt_pm[] ;

extern TCHAR LUI_txt_net[] ;
extern TCHAR LUI_txt_help[] ;

extern TCHAR LUI_txt_january[] ;
extern TCHAR LUI_txt_february[] ;
extern TCHAR LUI_txt_march[] ;
extern TCHAR LUI_txt_april[] ;
extern TCHAR LUI_txt_may[] ;
extern TCHAR LUI_txt_june[] ;
extern TCHAR LUI_txt_july[] ;
extern TCHAR LUI_txt_august[] ;
extern TCHAR LUI_txt_september[] ;
extern TCHAR LUI_txt_october[] ;
extern TCHAR LUI_txt_november[] ;
extern TCHAR LUI_txt_december[] ;

extern TCHAR LUI_txt_monday[] ;
extern TCHAR LUI_txt_tuesday[] ;
extern TCHAR LUI_txt_wednesday[] ;
extern TCHAR LUI_txt_thursday[] ;
extern TCHAR LUI_txt_friday[] ;
extern TCHAR LUI_txt_saturday[] ;
extern TCHAR LUI_txt_sunday[] ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\inc\msystem.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msystem.h

Abstract:

    Prototypes functions encapsulating OS function. This essentially covers
    everything that is not in NET***.

Author:

    Dan Hinsley (danhi) 10-Mar-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

Notes:


Revision History:

    26-Aug-1991 beng
	Separated from port1632.h

--*/

//
// Constants
//

#define BIG_BUFFER_SIZE                 4096


//
// Time support
//

typedef struct _DATETIME
{
    UCHAR        hours;
    UCHAR        minutes;
    UCHAR        seconds;
    UCHAR        hundredths;
    UCHAR        day;
    UCHAR        month;
    WORD         year;
    SHORT        timezone;
    UCHAR        weekday;
}
DATETIME, *PDATETIME;


//
// various memory allocation routines
//

LPTSTR
GetBuffer(
    DWORD usSize
    );

DWORD
AllocMem(
    DWORD Size,
    PVOID * ppBuffer
    );

DWORD
ReallocMem(
    DWORD Size,
    PVOID *ppBuffer
    );

DWORD
FreeMem(
    PVOID pBuffer
    );


//
// clear Ansi and Unicode strings
//

VOID
ClearStringW(
    LPWSTR lpszString
    );

VOID
ClearStringA(
    LPSTR lpszString
    );


//
// Console/text manipulation functions/macros
//

DWORD
DosGetMessageW(
    IN  LPTSTR *InsertionStrings,
    IN  DWORD  NumberofStrings,
    OUT LPTSTR Buffer,
    IN  DWORD  BufferLength,
    IN  DWORD  MessageId,
    IN  LPTSTR FileName,
    OUT PDWORD pMessageLength
    );

DWORD
DosInsMessageW(
    IN     LPTSTR *InsertionStrings,
    IN     DWORD  NumberofStrings,
    IN OUT LPTSTR InputMessage,
    IN     DWORD  InputMessageLength,
    OUT    LPTSTR Buffer,
    IN     DWORD  BufferLength,
    OUT    PDWORD pMessageLength
    );

VOID
DosPutMessageW(
    FILE    *fp,
    LPWSTR  pch,
    BOOL    fPrintNL
    );

int
FindColumnWidthAndPrintHeader(
    int iStringLength,
    const DWORD HEADER_ID,
    const int TAB_DISTANCE
    );

VOID
PrintDependingOnLength(
    IN      int iLength,
    IN      LPTSTR OutputString
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\inc\netascii.h ===
#define	DOT	TEXT('.')
#define	MINUS	TEXT('-')
#define	PLUS	TEXT('+')
#define	ASTERISK	TEXT('*')
#define	AMPERSAND	TEXT('&')
#define	PERCENT	TEXT('%')
#define	DOLLAR	TEXT('$')
#define	POUND	TEXT('#')
#define	ATSIGN	TEXT('@')
#define	BANG	TEXT('!')
#define	TILDA	TEXT('~')
#define	SLASH	TEXT('/')
#define	PIPE	TEXT('|')
#define	BACKSLASH	TEXT('\\')
#define RETURN  TEXT('\r')
#define	NEWLINE	TEXT('\n')
#define	TAB	TEXT('\t')
#define	COLON	TEXT(':')
#define	NULLC	TEXT('\0')
#define	BLANK	TEXT(' ')

#define DIMENSION(a) (sizeof(a) / sizeof(a[0]))

VOID    __cdecl WriteToCon(TCHAR *fmt, ...);

extern  TCHAR  ConBuf[];

#define	GenOutput(h, fmt) \
	{swprintf(ConBuf, fmt); \
	 DosPutMessageW(h, ConBuf, FALSE);}

#define	GenOutput1(h, fmt, a1)		\
	{				\
	swprintf(ConBuf, fmt, a1);	\
	DosPutMessageW(h, ConBuf, FALSE);}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\accounts.c ===
/********************************************************************/
/**         Microsoft LAN Manager              **/
/**       Copyright(c) Microsoft Corp., 1987-1990      **/
/********************************************************************/

/*  accounts.c - functions to display & modify the user modals
 *
 *  history:
 *  when    who what
 *  02/19/89 erichn initial code
 *  03/16/89 erichn uses local buf instead of BigBuf, misc cleaning
 *  06/08/89 erichn canonicalization sweep
 *  06/23/89 erichn auto-remoting to domain controller
 *  07/05/89 thomaspa /maxpwage:unlimited
 *  02/19/90 thomaspa fix /forcelogoff to check for overflow
 *  04/27/90 thomaspa fix /uniquepw to check for >DEF_MAX_PWHIST
 *            and /minpwlen >MAX_PASSWD_LEN
 *  01/28/91 robdu, added /lockout switch (includes setting and display)
 *  02/19/91 danhi, converted to 16/32 portability layer
 *  04/01/91 danhi, ifdef'ed out lockout feature
 */

#define INCL_NOCOMMON
#define INCL_DOSFILEMGR
#define INCL_ERRORS
#include <os2.h>
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <lmwksta.h>
#include <lui.h>
#include <lmaccess.h>
#include <apperr.h>
#include <apperr2.h>
#include "netcmds.h"
#include "nettext.h"
#include "sam.h"

#include "swtchtxt.h"

#define SECS_PER_DAY    ((ULONG) 3600 * 24)
#define SECS_PER_MIN    ((ULONG) 60 )
#define NOT_SET     (0xFFFF)
#define CALL_LEVEL_0    (0x0001)
#define CALL_LEVEL_1    (0x0002)
#define CALL_LEVEL_2    (0x0004)
#define CALL_LEVEL_3    (0x0008)
#define LOCKOUT_NEVER 0

/* local function prototype */

VOID CheckAndSetSwitches(LPUSER_MODALS_INFO_0,
    			 LPUSER_MODALS_INFO_1, 
                         LPUSER_MODALS_INFO_3,
			 USHORT *,
			 BOOL *);



/*
 *  accounts_change(): used to set the user modals when switches
 *  are detected on the command line.
 */
VOID accounts_change(VOID)
{
    DWORD        dwErr;
    USHORT       APIMask = 0;    /* maks for API that we call */
    TCHAR         controller[MAX_PATH];   /* name of domain controller */
    BOOL         fPasswordAgeChanged ;   /* has the min/max ages been set? */

    LPUSER_MODALS_INFO_0 modals_0;
    char modals_0_buffer[sizeof(USER_MODALS_INFO_0)];
    LPUSER_MODALS_INFO_1 modals_1;
    char modals_1_buffer[sizeof(USER_MODALS_INFO_1) + MAX_PATH];
    LPUSER_MODALS_INFO_3 modals_3;
    char modals_3_buffer[sizeof(USER_MODALS_INFO_3)];


    // since these are not used for anything on the first pass, make them
    // the same & pointing to some dummy buffer that is not used.
    modals_0 = (LPUSER_MODALS_INFO_0)  modals_0_buffer ;
    modals_1 = (LPUSER_MODALS_INFO_1)  modals_1_buffer ;
    modals_3 = (LPUSER_MODALS_INFO_3)  modals_3_buffer ;

    /* check switches first before doing anything */
    CheckAndSetSwitches(modals_0, modals_1, modals_3, &APIMask, &fPasswordAgeChanged);

    /* if we need to call level 0, try to get DC name to remote to. */
    if (APIMask & (CALL_LEVEL_0 | CALL_LEVEL_3))
    {
        if (dwErr = GetSAMLocation(controller, DIMENSION(controller), 
                                   NULL, 0, TRUE))
        {
            ErrorExit(dwErr);
        }
    }

    if ( APIMask & CALL_LEVEL_0 )
    {
        dwErr = NetUserModalsGet(controller, 0, (LPBYTE*)&modals_0);

        switch (dwErr) {
            case NERR_Success:
                break;
            case ERROR_BAD_NETPATH:
                ErrorExitInsTxt(APE_DCNotFound, controller);
            default:
                ErrorExit(dwErr);
        }
    }   /* APIMask & CALL_LEVEL_0 */

    if ( APIMask & CALL_LEVEL_3 )
    {
        dwErr = NetUserModalsGet(controller, 3, (LPBYTE*)&modals_3);

        switch (dwErr) {
            case NERR_Success:
                break;
            case ERROR_BAD_NETPATH:
                ErrorExitInsTxt(APE_DCNotFound, controller);
            default:
                ErrorExit(dwErr);
        }
    }   /* APIMask & CALL_LEVEL_3 */

    /* Now set switches before doing actual calls */
    CheckAndSetSwitches(modals_0, modals_1, modals_3, &APIMask, &fPasswordAgeChanged);

    /* call remote function first */
    if (APIMask & CALL_LEVEL_0)
    {
	/* check to make sure we dont set Min to be greater than Max */
        if (fPasswordAgeChanged &&
	    modals_0->usrmod0_max_passwd_age < modals_0->usrmod0_min_passwd_age)
        {
	    ErrorExit(APE_MinGreaterThanMaxAge) ;
        }

	/* call the API to do its thing */
        dwErr = NetUserModalsSet(controller, 0, (LPBYTE) modals_0, NULL);
    
        switch (dwErr) 
        {
            case NERR_Success:
                break;
            case ERROR_BAD_NETPATH:
                ErrorExitInsTxt(APE_DCNotFound, controller);
            default:
                ErrorExit(dwErr);
        }
        NetApiBufferFree((TCHAR FAR *) modals_0);
    }

    if (APIMask & CALL_LEVEL_3)
    {
	/* call the API to do its thing */
        dwErr = NetUserModalsSet(controller, 3, (LPBYTE) modals_3, NULL);
    
        switch (dwErr) 
        {
            case NERR_Success:
                break;
            case ERROR_BAD_NETPATH:
                ErrorExitInsTxt(APE_DCNotFound, controller);
            default:
                ErrorExit(dwErr);
        }
        NetApiBufferFree((TCHAR FAR *) modals_3);
    }


    InfoSuccess();
}

/*
 *  CheckAndSetSwitches - validates the contents of switches passed to
 *  NET ACCOUNTS, and sets the appropriate modal structure.  This function
 *  is called twice.  The first is to check the user input for mistakes,
 *  before we do any API calls that might fail.  The
 *  second time is to actually set the structures from what was passed on
 *  the command line.  This function could arguably be two seperate functions,
 *  but it was thought that having all the switch handling code in one place
 *  would be more maintainable.  Also, keeping track of which switches were
 *  given, using flags or whatnot, would be ugly and require adding new
 *  flags with new switches.  So, we just call the thing twice.
 *
 *  When adding new switches, be careful not to break the loop flow
 *  (by adding continue statements, for example), as after each switch
 *  is processed, the colon that is replaced by a NULL in FindColon() is
 *  restored back to a colon for the next call.
 *
 *  Entry   modals_0 - pointer to a user_modals_0 struct.
 *      modals_1 - pointer to a user_modals_1 struct.
 *      modals_3 - pointer to a user_modals_3 struct.
 *
 *  Exit    modals_0 - appropriate fields are set according to switches
 *  modals_1 - appropriate fields are set according to switches
 *  modals_3 - appropriate fields are set according to switches
 *  APIMask - the appropriate bit is set to mark wether an API
 *      should be called.  Currently for modal levels 0 & 1.
 *
 *  Other   Exits on bad arguments in switches.
 */
VOID CheckAndSetSwitches(LPUSER_MODALS_INFO_0 modals_0,
    			 LPUSER_MODALS_INFO_1 modals_1,
    			 LPUSER_MODALS_INFO_3 modals_3,
			 USHORT *APIMask,
			 BOOL   *pfPasswordAgeChanged)
{
    DWORD  i;      			   /* generic index loop */
    DWORD  err;    			   /* API return code */
    DWORD  yesno ;
    TCHAR *  ptr;    			   /* pointer to start of arg, 
					      set by FindColon */

    /* set to FALSE initially */
    *pfPasswordAgeChanged = FALSE ;  

    /* for each switch in switchlist */
    for (i = 0; SwitchList[i]; i++)
    {
    /* Skip the DOMAIN switch */
    if (! _tcscmp(SwitchList[i], swtxt_SW_DOMAIN))
        continue;

    /* all switches currently require arguments, hence colons */
    if ((ptr = FindColon(SwitchList[i])) == NULL)
        ErrorExit(APE_InvalidSwitchArg);

    if (!(_tcscmp(SwitchList[i], swtxt_SW_ACCOUNTS_FORCELOGOFF)))
    {
        (*APIMask) |= CALL_LEVEL_0;
        if ((LUI_ParseYesNo(ptr,&yesno)==0) && (yesno == LUI_NO_VAL))
            modals_0->usrmod0_force_logoff = TIMEQ_FOREVER;
        else
        {
            modals_0->usrmod0_force_logoff = do_atoul(ptr,APE_CmdArgIllegal,
                        swtxt_SW_ACCOUNTS_FORCELOGOFF);
            if (modals_0->usrmod0_force_logoff > 0xffffffff / SECS_PER_MIN)
            {
                ErrorExitInsTxt(APE_CmdArgIllegal,
                        swtxt_SW_ACCOUNTS_FORCELOGOFF);
            }
            modals_0->usrmod0_force_logoff *= SECS_PER_MIN;
        }
    }
    else if (!(_tcscmp(SwitchList[i], swtxt_SW_ACCOUNTS_UNIQUEPW)))
    {
        (*APIMask) |= CALL_LEVEL_0;
        modals_0->usrmod0_password_hist_len =
            do_atou(ptr,APE_CmdArgIllegal,swtxt_SW_ACCOUNTS_UNIQUEPW);
        if (modals_0->usrmod0_password_hist_len > 24) // also in User Manager
        {
            ErrorExitInsTxt(APE_CmdArgIllegal, swtxt_SW_ACCOUNTS_UNIQUEPW);
        }
    }
    else if (!(_tcscmp(SwitchList[i], swtxt_SW_ACCOUNTS_MINPWLEN)))
    {
        (*APIMask) |= CALL_LEVEL_0;
        modals_0->usrmod0_min_passwd_len =
            do_atou(ptr,APE_CmdArgIllegal,swtxt_SW_ACCOUNTS_MINPWLEN);
        if (modals_0->usrmod0_min_passwd_len > MAX_PASSWD_LEN)
        {
            ErrorExitInsTxt(APE_CmdArgIllegal, swtxt_SW_ACCOUNTS_MINPWLEN);
        }
    }
    else if (!(_tcscmp(SwitchList[i], swtxt_SW_ACCOUNTS_MINPWAGE)))
    {
        (*APIMask) |= CALL_LEVEL_0;
	*pfPasswordAgeChanged = TRUE ;
        modals_0->usrmod0_min_passwd_age =
            do_atoul(ptr,APE_CmdArgIllegal,swtxt_SW_ACCOUNTS_MINPWAGE);
        if (modals_0->usrmod0_min_passwd_age > 999)
        {
            ErrorExitInsTxt(APE_CmdArgIllegal, swtxt_SW_ACCOUNTS_MINPWAGE);
        }
        modals_0->usrmod0_min_passwd_age *= SECS_PER_DAY;
    }
    else if (!(_tcscmp(SwitchList[i], swtxt_SW_ACCOUNTS_MAXPWAGE)))
    {
        (*APIMask) |= CALL_LEVEL_0;
	*pfPasswordAgeChanged = TRUE ;
        /* NOTE: we use the same global as "UNLIMITED" for the Net
           User /MAXSTORAGE:unlimited here.  If these diverge then
           a new global will need to be added to nettext.c and .h
         */
        if( !_tcsicmp( ptr, USER_MAXSTOR_UNLIMITED ) )
        {
            modals_0->usrmod0_max_passwd_age = 0xffffffff;
        }
        else
        {
            modals_0->usrmod0_max_passwd_age=
                do_atoul(ptr,APE_CmdArgIllegal,swtxt_SW_ACCOUNTS_MAXPWAGE);
            if (modals_0->usrmod0_max_passwd_age > 999)
            {
                ErrorExitInsTxt(APE_CmdArgIllegal,
                        swtxt_SW_ACCOUNTS_MAXPWAGE);
            }
            modals_0->usrmod0_max_passwd_age *= SECS_PER_DAY;
        }
    }
    else if (!(_tcscmp(SwitchList[i], swtxt_SW_ACCOUNTS_LOCKOUT_DURATION)))
    {
        (*APIMask) |= CALL_LEVEL_3;
        if ((LUI_ParseYesNo(ptr,&yesno)==0) && (yesno == LUI_NO_VAL))
            modals_3->usrmod3_lockout_duration = TIMEQ_FOREVER;
        else
        {
            modals_3->usrmod3_lockout_duration = do_atoul(ptr,APE_CmdArgIllegal,
                        swtxt_SW_ACCOUNTS_LOCKOUT_DURATION);
            if (modals_3->usrmod3_lockout_duration > 0xffffffff / SECS_PER_MIN)
            {
                ErrorExitInsTxt(APE_CmdArgIllegal,
                        swtxt_SW_ACCOUNTS_LOCKOUT_DURATION);
            }
            modals_3->usrmod3_lockout_duration *= SECS_PER_MIN;
        }
    }
    else if (!(_tcscmp(SwitchList[i], swtxt_SW_ACCOUNTS_LOCKOUT_WINDOW)))
    {
        (*APIMask) |= CALL_LEVEL_3;
        if ((LUI_ParseYesNo(ptr,&yesno)==0) && (yesno == LUI_NO_VAL))
            modals_3->usrmod3_lockout_observation_window = TIMEQ_FOREVER;
        else
        {
            modals_3->usrmod3_lockout_observation_window = do_atoul(ptr,APE_CmdArgIllegal,
                        swtxt_SW_ACCOUNTS_LOCKOUT_WINDOW);
            if (modals_3->usrmod3_lockout_observation_window > 0xffffffff / SECS_PER_MIN)
            {
                ErrorExitInsTxt(APE_CmdArgIllegal,
                        swtxt_SW_ACCOUNTS_LOCKOUT_WINDOW);
            }
            modals_3->usrmod3_lockout_observation_window *= SECS_PER_MIN;
        }
    }
    else if (!(_tcscmp(SwitchList[i], swtxt_SW_ACCOUNTS_LOCKOUT_THRESHOLD)))
    {
        (*APIMask) |= CALL_LEVEL_3;
        if ((LUI_ParseYesNo(ptr,&yesno)==0) && (yesno == LUI_NO_VAL))
        modals_3->usrmod3_lockout_threshold = LOCKOUT_NEVER;
        else
        modals_3->usrmod3_lockout_threshold =
            do_atou(ptr, APE_CmdArgIllegal, swtxt_SW_ACCOUNTS_LOCKOUT_THRESHOLD);

    }

    *--ptr = ':';       /* restore pointer for next call */
    }
}

#define FORCE_LOGOFF    0
#define MIN_PW_AGE  (FORCE_LOGOFF + 1)
#define MAX_PW_AGE  (MIN_PW_AGE + 1)
#define MIN_PW_LEN  (MAX_PW_AGE + 1)
#define PW_HIST_LEN (MIN_PW_LEN + 1)
#define ROLE        (PW_HIST_LEN + 1)
#define CONTROLLER  (ROLE + 1)
#define MSG_UNLIMITED   (CONTROLLER + 1)
#define MSG_NEVER   (MSG_UNLIMITED + 1)
#define MSG_NONE    (MSG_NEVER + 1)
#define MSG_UNKNOWN (MSG_NONE + 1)
#define LOCKOUT_CNT (MSG_UNKNOWN + 1)
#define TYPE_PRIMARY (LOCKOUT_CNT + 1)
#define TYPE_BACKUP (TYPE_PRIMARY + 1)
#define TYPE_WORKSTATION (TYPE_BACKUP + 1)
#define TYPE_STANDARD_SERVER (TYPE_WORKSTATION + 1)
#define LOCKOUT_THRESHOLD (TYPE_STANDARD_SERVER + 1)
#define LOCKOUT_DURATION (LOCKOUT_THRESHOLD + 1)
#define LOCKOUT_WINDOW (LOCKOUT_DURATION + 1)

static MESSAGE accMsgList[] = {
    { APE2_ACCOUNTS_FORCELOGOFF,    NULL },
    { APE2_ACCOUNTS_MINPWAGE,       NULL },
    { APE2_ACCOUNTS_MAXPWAGE,       NULL },
    { APE2_ACCOUNTS_MINPWLEN,       NULL },
    { APE2_ACCOUNTS_UNIQUEPW,       NULL },
    { APE2_ACCOUNTS_ROLE,       NULL },
    { APE2_ACCOUNTS_CONTROLLER,     NULL },
    { APE2_GEN_UNLIMITED,       NULL },
    { APE2_NEVER_FORCE_LOGOFF,  NULL },
    { APE2_GEN_NONE,            NULL },
    { APE2_GEN_UNKNOWN,         NULL },
    { APE2_ACCOUNTS_LOCKOUT_COUNT,  NULL },
    { APE2_PRIMARY,  NULL },
    { APE2_BACKUP,  NULL },
    { APE2_WORKSTATION,  NULL },
    { APE2_STANDARD_SERVER, NULL },
    { APE2_ACCOUNTS_LOCKOUT_THRESHOLD },
    { APE2_ACCOUNTS_LOCKOUT_DURATION },
    { APE2_ACCOUNTS_LOCKOUT_WINDOW }
};

#define NUM_ACC_MSGS (sizeof(accMsgList)/sizeof(accMsgList[0]))

/*
 *  accounts_display(): displays the current user modals
 */
VOID accounts_display(VOID)
{
    LPUSER_MODALS_INFO_0 modals_0;
    LPUSER_MODALS_INFO_1 modals_1;
    LPUSER_MODALS_INFO_3 modals_3;

    ULONG       maxPasswdAge;     /* max password age in days */
    ULONG       minPasswdAge;     /* min password age in days */
    ULONG       forceLogoff;      /* force logoff time in minutes */
    DWORD       len;              /* max message string size */
    DWORD       dwErr;
    TCHAR *     rolePtr;          /* points to text for role */
    TCHAR       controller[MAX_PATH]; /* name of domain controller */
    TCHAR *     pBuffer = NULL ;

    /* determine where to call the API. FALSE => no need PDC */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller), 
                               NULL, 0, FALSE))
         ErrorExit(dwErr);

    /* get `da modals */
    if (dwErr = NetUserModalsGet(controller, 0, (LPBYTE*)&modals_0))
        ErrorExit(dwErr);

    if (dwErr = NetUserModalsGet(controller, 1, (LPBYTE*)&modals_1))
        ErrorExit(dwErr);

    if (dwErr = NetUserModalsGet(controller, 3, (LPBYTE*)&modals_3))
        ErrorExit(dwErr);


    /* convert internal representation to days or minutes as approp. */
    if( modals_0->usrmod0_max_passwd_age != 0xffffffff )
    {
        maxPasswdAge = modals_0->usrmod0_max_passwd_age / SECS_PER_DAY;
    }
    minPasswdAge = modals_0->usrmod0_min_passwd_age / SECS_PER_DAY;
    forceLogoff = modals_0->usrmod0_force_logoff / SECS_PER_MIN;

    GetMessageList(NUM_ACC_MSGS, accMsgList, &len);
    len += 5; /* text should be 5 further to right than largest str */

    if (modals_0->usrmod0_force_logoff == TIMEQ_FOREVER)
	    WriteToCon(fmtNPSZ, 0, len,
                   PaddedString(len, accMsgList[FORCE_LOGOFF].msg_text, NULL),
	               accMsgList[MSG_NEVER].msg_text);
    else
	    WriteToCon(fmtULONG, 0, len,
                   PaddedString(len, accMsgList[FORCE_LOGOFF].msg_text, NULL),
	               forceLogoff);

    WriteToCon(fmtULONG, 0, len,
               PaddedString(len, accMsgList[MIN_PW_AGE].msg_text, NULL),
               minPasswdAge);
    if (modals_0->usrmod0_max_passwd_age == 0xffffffff )
    {
        WriteToCon(fmtNPSZ, 0, len,
                   PaddedString(len, accMsgList[MAX_PW_AGE].msg_text, NULL),
                   accMsgList[MSG_UNLIMITED].msg_text );
    }
    else
    {
        WriteToCon(fmtULONG, 0, len,
                   PaddedString(len, accMsgList[MAX_PW_AGE].msg_text, NULL),
                   maxPasswdAge);
    }
    WriteToCon(fmtUSHORT, 0, len,
               PaddedString(len, accMsgList[MIN_PW_LEN].msg_text, NULL),
               modals_0->usrmod0_min_passwd_len);

    if (modals_0->usrmod0_password_hist_len == 0)
        WriteToCon(fmtNPSZ, 0, len,
                   PaddedString(len, accMsgList[PW_HIST_LEN].msg_text, NULL),
                   accMsgList[MSG_NONE].msg_text);
    else
        WriteToCon(fmtUSHORT, 0, len,
                   PaddedString(len, accMsgList[PW_HIST_LEN].msg_text, NULL),
                   modals_0->usrmod0_password_hist_len);

    if (modals_3->usrmod3_lockout_threshold == LOCKOUT_NEVER)
        WriteToCon(fmtNPSZ, 0, len,
                   PaddedString(len, accMsgList[LOCKOUT_THRESHOLD].msg_text, NULL),
                   accMsgList[MSG_NEVER].msg_text);
    else
        WriteToCon(fmtUSHORT, 0, len,
                   PaddedString(len, accMsgList[LOCKOUT_THRESHOLD].msg_text, NULL),
                   modals_3->usrmod3_lockout_threshold);

    if ( modals_3->usrmod3_lockout_duration ==  TIMEQ_FOREVER )
        WriteToCon(fmtNPSZ, 0, len,
                   PaddedString(len, accMsgList[LOCKOUT_DURATION].msg_text, NULL),
                   accMsgList[MSG_NEVER].msg_text);
    else
        WriteToCon(fmtULONG, 0, len,
                   PaddedString(len, accMsgList[LOCKOUT_DURATION].msg_text, NULL),
                   modals_3->usrmod3_lockout_duration / SECS_PER_MIN);

    WriteToCon(fmtULONG, 0, len,
               PaddedString(len, accMsgList[LOCKOUT_WINDOW].msg_text, NULL),
               modals_3->usrmod3_lockout_observation_window / SECS_PER_MIN);


    switch (modals_1->usrmod1_role) {
        case UAS_ROLE_PRIMARY:
            if ((*controller == '\0') && IsLocalMachineWinNT())
                if (IsLocalMachineStandard())
                    rolePtr = accMsgList[TYPE_STANDARD_SERVER].msg_text ;
                else
                    rolePtr = accMsgList[TYPE_WORKSTATION].msg_text ;
	    else
                rolePtr = accMsgList[TYPE_PRIMARY].msg_text ;
            break;
        case UAS_ROLE_BACKUP:
            rolePtr = accMsgList[TYPE_BACKUP].msg_text ;
            break;

        /* this should no happen for NT */
        case UAS_ROLE_STANDALONE:
        case UAS_ROLE_MEMBER:
            rolePtr = accMsgList[MSG_UNKNOWN].msg_text ;
            break;
    }

    WriteToCon(fmtNPSZ, 0, len, PaddedString(len, accMsgList[ROLE].msg_text,NULL), rolePtr);

    NetApiBufferFree((TCHAR FAR *) modals_0);
    NetApiBufferFree((TCHAR FAR *) modals_1);
    InfoSuccess();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\comp.c ===
/********************************************************************/
/**         Microsoft Windows NT                                   **/
/**       Copyright(c) Microsoft Corp., 1992                       **/
/********************************************************************/

/***
 *  comp.c
 *  Functions for displaying and manipulating computers|dc|trust lists
 *
 *  History:
 *  mm/dd/yy, who,      comment
 *  02/04/92, chuckc,   created stubs
 *  02/06/92, madana,   added real worker code.
 */

/* Include files */

#include <nt.h>
#include <ntrtl.h>
#include <ntsam.h>

#include <windef.h>

#include <lmerr.h>
#include <lmaccess.h>
#include <dlwksta.h>

#include <apperr.h>
#include <lui.h>

#include <crypt.h>      // logonmsv.h needs this
#include <logonmsv.h>   // SSI_SECRET_NAME defined here.
#include <ssi.h>        // SSI_ACCOUNT_NAME_POSTFIX defined here

#include "netcmds.h"
#include "nettext.h"

#define TRUST_ENUM_PERF_BUF_SIZE    sizeof(LSA_TRUST_INFORMATION) * 1000
                    // process max. 1000 trusted account records at atime !!

#define NETLOGON_SECRET_NAME  L"NETLOGON$"

NET_API_STATUS
NetuComputerAdd(
    IN LPTSTR Server,
    IN LPTSTR ComputerName
    );

NET_API_STATUS
NetuComputerDel(
    IN LPTSTR Server,
    IN LPTSTR ComputerName
    );


/************************ functions called by parser ************************/

VOID computer_add(TCHAR *pszComputer)
{
    DWORD            dwErr;
    TCHAR            szComputerAccount[MAX_PATH+1+1] ;  // extra 1 for $ at end
    TCHAR            controller[MAX_PATH+1];

    // no need validate pszComputer since parser has done so
    _tcscpy(szComputerAccount, pszComputer) ;

    //
    // block operation if attempted on local WinNT machine
    //
    CheckForLanmanNT() ;

    //
    // determine where to make the API call
    //
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller),
                               NULL, 0, TRUE))
         ErrorExit(dwErr);

    //
    // skip "\\" part of the computer name when adding account for machine
    //
    dwErr = NetuComputerAdd( controller,
                             szComputerAccount + 2 );

    switch ( dwErr )
    {
        case NERR_Success :
            InfoSuccess();
            return;

        case NERR_UserExists :    // map to computer not found
            ErrorExitInsTxt( APE_ComputerAccountExists, szComputerAccount );

        default:
            ErrorExit(dwErr);
    }

}

VOID computer_del(TCHAR *pszComputer)
{

    DWORD   dwErr;
    TCHAR   szComputerAccount[MAX_PATH+1+1] ;  // extra 1 for $ at end
    TCHAR   controller[MAX_PATH+1];

    // no need validate pszComputer since parser has done so
    _tcscpy(szComputerAccount, pszComputer) ;

    //
    // block operation if attempted on local WinNT machine
    //
    CheckForLanmanNT() ;

    //
    // determine where to make the API call
    //
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller),
                               NULL, 0, TRUE))
         ErrorExit(dwErr);


    dwErr = NetuComputerDel( controller, szComputerAccount+2 );

    switch ( dwErr )
    {
        case NERR_Success :
            InfoSuccess();
            return;

        case NERR_UserNotFound :    // map to computer not found
            ErrorExitInsTxt( APE_NoSuchComputerAccount, szComputerAccount );

        default:
            ErrorExit(dwErr);
    }

}


/**************************** worker functions ***************************/


NET_API_STATUS
NetuComputerAdd(
    IN LPTSTR Server,
    IN LPTSTR ComputerName
    )

/*++

Routine Description:

    This function adds a computer account in SAM.

Arguments:

    ComputerName - The name of the computer to be added as a trusted
                    account in the SAM database.

    Password - The password of the above account.

Return Value:

    Error code of the functions called with in this function.

--*/
{
    DWORD           parm_err;
    NET_API_STATUS  NetStatus;
    USER_INFO_1     ComputerAccount;
    WCHAR           UnicodeComputerName[MAX_PATH+1+1] ;  // extra 1 for $ at end
    WCHAR           UnicodePassword[LM20_PWLEN+MAX_PATH];
                    // guaranteed to be enough since we add the two

    //
    // convert computer name to wide character string and
    // canonicalize for NetBios names.
    //
    if (NetStatus = LUI_CanonForNetBios(UnicodeComputerName,
                                        DIMENSION(UnicodeComputerName),
                                        ComputerName))
    {
        goto Cleanup;
    }


    //
    // We truncate by zapping the last char. then lowercase
    // as this is the convention.
    //
    wcscpy(UnicodePassword, ComputerName);
    UnicodePassword[LM20_PWLEN < MAX_PATH ? LM20_PWLEN : MAX_PATH] = 0 ;
    _wcslwr(UnicodePassword) ;

    //
    // add the $ postfix
    //
    wcscat( UnicodeComputerName, SSI_ACCOUNT_NAME_POSTFIX);

    //
    // Build user info structure.
    //
    ComputerAccount.usri1_name = UnicodeComputerName;
    ComputerAccount.usri1_password = UnicodePassword;
    ComputerAccount.usri1_password_age = 0; // not an input parameter.
    ComputerAccount.usri1_priv = USER_PRIV_USER;
    ComputerAccount.usri1_home_dir = NULL;
    ComputerAccount.usri1_comment = NULL;
    ComputerAccount.usri1_flags =  UF_SCRIPT | UF_WORKSTATION_TRUST_ACCOUNT;
    ComputerAccount.usri1_script_path = NULL;


    //
    // call API to actually add it
    //
    NetStatus = NetUserAdd( Server,
                            1,
                            (LPBYTE)&ComputerAccount,
                            &parm_err );

    if( NetStatus != NERR_Success ) {

        if( NetStatus == ERROR_INVALID_PARAMETER ) {
            NetpKdPrint((
                "[NETCMD] NetuComputerAdd : "
                "NetUserAdd returns ERROR_INVALID_PARAMETER "
                "parm_err = %lu \r\n", parm_err));
        }
        else {
            NetpKdPrint((
                "[NETCMD] NetuComputerAdd : "
                "NetUserAdd returns %lu \r\n ", NetStatus ));
        }

    }

Cleanup:

    return NetStatus;
}

NET_API_STATUS
NetuComputerDel(
    IN LPTSTR Server,
    IN LPTSTR ComputerName
    )

/*++

Routine Description:

    This functions deletes a computer account from SAM database.

Arguments:

    ComputerName : The name of the computer whose trusted account to be
                    deleted from SAM database.

Return Value:

    Error code of the functions called with in this function.

--*/
{
    NET_API_STATUS  NetStatus;
    WCHAR           UnicodeComputerName[MAX_PATH+1+1] ; // extra 1 for $ at end

    //
    // convert computer name to wide character string and
    // canonicalize for NetBios
    //
    if (NetStatus = LUI_CanonForNetBios(UnicodeComputerName,
                                        DIMENSION(UnicodeComputerName),
                                        ComputerName))
    {
        goto Cleanup;
    }

    wcscat ( UnicodeComputerName, SSI_ACCOUNT_NAME_POSTFIX ) ;
    NetStatus = NetUserDel( Server,
                            UnicodeComputerName );
    if( NetStatus != NERR_Success ) {

        NetpKdPrint((
            "[NETCMD] NetuComputerAdd : "
            "NetUserAdd returns %lu \r\n ", NetStatus ));
    }

Cleanup :

    return NetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\config.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/***
 *  config.c
 *      Functions that view and change the configuration parameters for
 *      workstation, server, or other (none now) network programs.
 *
 *  History:
 *      07/09/87, ericpe, initial coding
 *      01/06/88, andyh, complete re-write
 *      10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *      01/04/89, erichn, filenames now MAXPATHLEN LONG
 *      01/31/89, paulc, LM 1.2 modifications (fairly major)
 *      05/02/89, erichn, NLS conversion
 *      05/09/89, erichn, local security mods
 *      05/19/89, erichn, NETCMD output sorting
 *      06/07/89, erichn, now used in DOS
 *      06/08/89, erichn, canonicalization sweep
 *      06/26/89, erichn, replaced old NetI canon calls with new I_Net
 *      02/20/91, danhi, change to use lm 16/32 mapping layer
 *      05/22/91, robdu,  LM21 bug 1797 fix
 *      10/15/91, JohnRo, Use DEFAULT_SERVER equate.
 */

/* Include files */

#define INCL_NOCOMMON
#define INCL_DOSFILEMGR
#include <os2.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#define INCL_ERROR_H
#include <apperr.h>
#include <apperr2.h>
#include <dlwksta.h>
#include "mserver.h"
#include "mwksta.h"
#include <dlserver.h>
#include <lmsvc.h>
#include "netcmds.h"
#include "nettext.h"
#include "swtchtbl.h"
#include <dsrole.h>

/*  The following should be moved to ../fileserv/h/srvver.h   */
#define MAJOR_VERSION_MASK  0x0F

/* the following should match the second string in fmt15 */
#define MAX_VAL_MSG_LEN 31

/* Output formats */

static TCHAR fmt10[] = TEXT("%-*.*ws\r\n");
static TCHAR fmt11[] = TEXT("%-*.*ws\\\\%Fws\r\n");
static TCHAR fmt12[] = TEXT("%-*.*ws%-0.31ws %u.%u\r\n");
static TCHAR fmt13[] = TEXT("%-*.*ws%u.%u\r\n");
static TCHAR fmt14[] = TEXT("%-*.*ws%d\r\n");
static TCHAR fmt15[] = TEXT("%-*.*ws%-0.31ws\r\n");

/* The list of configurable services */

static TCHAR * allowed_svc[] = {
    SERVICE_WORKSTATION,
#ifdef OS2
    SERVICE_SERVER,
#endif
    NULL };

/* Config Value Message Numbers */

#define CVMN_YES                0
#define CVMN_NO                 (CVMN_YES+1)
#define CVMN_S_VERSION_LM       (CVMN_NO+1)
#define CVMN_S_VERSION_PS       (CVMN_S_VERSION_LM+1)
#define CVMN_S_VERSION_IBM      (CVMN_S_VERSION_PS+1)
#define CVMN_S_SEC_SHARE        (CVMN_S_VERSION_IBM+1)
#define CVMN_S_SEC_USER         (CVMN_S_SEC_SHARE+1)
#define CVMN_S_LEVEL_UNLIMITED  (CVMN_S_SEC_USER+1)
#define CVMN_WINDOWS2000        (CVMN_S_LEVEL_UNLIMITED+1)

static MESSAGELIST valmsg_list = {
    {   APE2_GEN_YES,                   NULL  },
    {   APE2_GEN_NO,                    NULL  },
    {   APE2_CFG_S_VERSION_LM,          NULL  },
    {   APE2_CFG_S_VERSION_PS,          NULL  },
    {   APE2_CFG_S_VERSION_IBM,         NULL  },
    {   APE2_CFG_S_SEC_SHARE,           NULL  },
    {   APE2_CFG_S_SEC_USER,            NULL  },
    {   APE2_CFG_S_LEVEL_UNLIMITED,     NULL  },
    {   APE2_CFG_WINDOWS2000,           NULL  },
};

#define YES_OR_NO(x) \
    (x ? valmsg_list[CVMN_YES].msg_text : valmsg_list[CVMN_NO].msg_text)

#define NUMVMSG (sizeof(valmsg_list)/sizeof(valmsg_list[0]))


#define CWMN_CNAME      0
#define CWMN_FULL_CNAME (CWMN_CNAME+1)
#define CWMN_UNAME      (CWMN_FULL_CNAME+1)
#define CWMN_VERSION    (CWMN_UNAME+1)
#define CWMN_ROOT       (CWMN_VERSION+1)
#define CWMN_DOMAIN_P   (CWMN_ROOT+1)
#define CWMN_DOMAIN_L   (CWMN_DOMAIN_P+1)
#define CWMN_DOMAIN_DNS   (CWMN_DOMAIN_L+1)
#ifdef  OS2
#define CWMN_COM_OTIME  (CWMN_DOMAIN_DNS+1)
#define CWMN_COM_SCNT   (CWMN_COM_OTIME+1)
#define CWMN_COM_STIME  (CWMN_COM_SCNT+1)
#define CWMN_3X_PRTTIME (CWMN_COM_STIME+1)
#define CWMN_MAXERRLOG  (CWMN_3X_PRTTIME+1)
#define CWMN_MAXCACHE   (CWMN_MAXERRLOG+1)
#define CWMN_NUMNBUF    (CWMN_MAXCACHE+1)
#define CWMN_NUMCBUF    (CWMN_NUMNBUF+1)
#define CWMN_SIZNBUF    (CWMN_NUMCBUF+1)
#define CWMN_SIZCBUF    (CWMN_SIZNBUF+1)
#define CWMN_ACTIVE     (CWMN_SIZCBUF+1)
#endif

static MESSAGE wkstamsg_list[] = {
    {   APE2_CFG_W_CNAME,           NULL    },
    {   APE2_CFG_W_FULL_CNAME,      NULL    },
    {   APE2_CFG_W_UNAME,           NULL    },
    {   APE2_CFG_W_VERSION,         NULL    },
    {   APE2_CFG_W_ROOT,            NULL    },
    {   APE2_CFG_W_DOMAIN_P,        NULL    },
    {   APE2_CFG_W_DOMAIN_L,        NULL    },
    {   APE2_CFG_W_DOMAIN_DNS,        NULL    },
#ifdef  OS2
    {   APE2_CFG_W_COM_OTIME,       NULL    },
    {   APE2_CFG_W_COM_SCNT,        NULL    },
    {   APE2_CFG_W_COM_STIME,       NULL    },
    {   APE2_CFG_W_3X_PRTTIME,      NULL    },
    {   APE2_CFG_W_MAXERRLOG,       NULL    },
    {   APE2_CFG_W_MAXCACHE,        NULL    },
    {   APE2_CFG_W_NUMNBUF,         NULL    },
    {   APE2_CFG_W_NUMCBUF,         NULL    },
    {   APE2_CFG_W_SIZNBUF,         NULL    },
    {   APE2_CFG_W_SIZCBUF,         NULL    },
    {   APE2_CFG_W_NETS,            NULL    },
#endif
    };

#define NUMWMSG (sizeof(wkstamsg_list) / sizeof(wkstamsg_list[0]))

/***
 *  config_display ()
 *      Displays the list of installed services that are configurable.
 *
 */

VOID
config_display(
    VOID
    )
{
    DWORD             dwErr;
    DWORD             cTotalAvail;
    LPTSTR            pBuffer;
    DWORD             _read;       /* num entries read by API */
    DWORD             i;
    DWORD             j;
    int               printed = 0;
    LPSERVICE_INFO_2  info_list_entry;

    if (dwErr = NetServiceEnum(
                            DEFAULT_SERVER,
                            2,
                            (LPBYTE*)&pBuffer,
                            MAX_PREFERRED_LENGTH,
                            &_read,
                            &cTotalAvail,
                            NULL))
        ErrorExit(dwErr);

    if (_read == 0)
        EmptyExit();

    InfoPrint(APE_CnfgHeader);

    for (i=0, info_list_entry = (LPSERVICE_INFO_2) pBuffer;
        i < _read; i++, info_list_entry++)
    {
        for (j = 0 ;  allowed_svc[j] ; j++)
        {
            if (!(_tcsicmp(allowed_svc[j], info_list_entry->svci2_name)) )
            {
                WriteToCon(TEXT("   %Fws"), info_list_entry->svci2_display_name);
                PrintNL();
                break;
            }
        }
    }
    PrintNL();

    NetApiBufferFree(pBuffer);

    InfoSuccess();
}


/***
 *  config_wksta_display()
 *      View the configuration of the current workstation.
 *
 *
 */
VOID
config_wksta_display(
    VOID
    )
{
    DWORD                             dwErr;
    int                               fsz;
    DWORD                             maxmsglen;
    LPWKSTA_INFO_1                    info_entry_w;
    MSGTEXT                           product_name;
    BOOL                              fGotDNSComputerName = FALSE;
    TCHAR                             ComputerDNSName[MAX_PATH+1];
    DWORD                             ComputerDNSNameSize = MAX_PATH;
    DWORD                             DsRoleErr = 0;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pdsroleInfo = NULL;

    start_autostart(txt_SERVICE_REDIR);

    if (dwErr = MNetWkstaGetInfo(1, (LPBYTE *) &info_entry_w))
    {
        ErrorExit (dwErr);
    }

    fGotDNSComputerName = GetComputerNameEx( ComputerNameDnsFullyQualified, 
                                                 ComputerDNSName,
                                                 &ComputerDNSNameSize );

    DsRoleErr = DsRoleGetPrimaryDomainInformation( NULL,
                                                 DsRolePrimaryDomainInfoBasic,
                                                 (PBYTE *)&pdsroleInfo );

    GetMessageList(NUMWMSG, wkstamsg_list, &maxmsglen);

    fsz = maxmsglen + 5;

    GetMessageList(NUMVMSG, valmsg_list, &maxmsglen);

    WriteToCon(fmt11, 0, fsz,
               PaddedString(fsz, wkstamsg_list[CWMN_CNAME].msg_text, NULL),
               (TCHAR FAR *) info_entry_w->wki1_computername);
    if ( fGotDNSComputerName )
    {
        WriteToCon(fmtPSZ, 0, fsz,
               PaddedString(fsz, wkstamsg_list[CWMN_FULL_CNAME].msg_text, NULL),
               (TCHAR FAR *) ComputerDNSName);
    }
    WriteToCon(fmtPSZ, 0, fsz,
               PaddedString(fsz, wkstamsg_list[CWMN_UNAME].msg_text, NULL),
               (TCHAR FAR *) info_entry_w->wki1_username);

    PrintNL();

    WriteToCon(fmt10,   0, fsz, PaddedString(fsz, wkstamsg_list[CWMN_ACTIVE].msg_text,NULL));
    print_lan_mask(info_entry_w->wki1_reserved_3, NETNAME_WKSTA);

    product_name = valmsg_list[CVMN_WINDOWS2000].msg_text;

    WriteToCon(fmt15, 0, fsz,
               PaddedString(fsz,wkstamsg_list[CWMN_VERSION].msg_text,NULL),
               product_name);

    PrintNL();

    WriteToCon(fmtPSZ, 0, fsz,
               PaddedString(fsz, wkstamsg_list[CWMN_DOMAIN_P].msg_text, NULL),
               info_entry_w->wki1_langroup );
    if ( DsRoleErr == 0 )
    {
        WriteToCon(fmtPSZ, 0, fsz,
               PaddedString(fsz, wkstamsg_list[CWMN_DOMAIN_DNS].msg_text, NULL),
               pdsroleInfo->DomainNameDns );
        DsRoleFreeMemory(pdsroleInfo);
    }
    WriteToCon(fmtPSZ, 0, fsz,
               PaddedString(fsz, wkstamsg_list[CWMN_DOMAIN_L].msg_text, NULL),
               info_entry_w->wki1_logon_domain );

    PrintNL();

    WriteToCon(fmtUSHORT, 0, fsz,
               PaddedString(fsz, wkstamsg_list[CWMN_COM_OTIME].msg_text, NULL),
                    info_entry_w->wki1_charwait );
    WriteToCon(fmtUSHORT, 0, fsz,
               PaddedString(fsz, wkstamsg_list[CWMN_COM_SCNT].msg_text, NULL),
                    info_entry_w->wki1_charcount );
    WriteToCon(fmtULONG, 0, fsz,
               PaddedString(fsz, wkstamsg_list[CWMN_COM_STIME].msg_text, NULL),
               info_entry_w->wki1_chartime );
    NetApiBufferFree((TCHAR FAR *) info_entry_w);

    InfoSuccess();
}


#define CSMN_SRVNAME            0
#define CSMN_SRVCOMM            (CSMN_SRVNAME+1)
#define CSMN_ADMINALRT          (CSMN_SRVNAME+2)
#define CSMN_VERSION            (CSMN_SRVNAME+3)
#define CSMN_LEVEL              (CSMN_SRVNAME+4)
#define CSMN_NETS               (CSMN_SRVNAME+5)
#define CSMN_SRVHIDDEN          (CSMN_SRVNAME+6)
#define CSMN_MAXUSERS           (CSMN_SRVNAME+7)
#define CSMN_MAXADMINS          (CSMN_SRVNAME+8)
#define CSMN_MAXSHARES          (CSMN_SRVNAME+9)
#define CSMN_MAXCONNS           (CSMN_SRVNAME+10)
#define CSMN_MAXOFILES          (CSMN_SRVNAME+11)
#define CSMN_MAXOFILESPS        (CSMN_SRVNAME+12)
#define CSMN_MAXLOCKS           (CSMN_SRVNAME+13)
#define CSMN_IDLETIME           (CSMN_SRVNAME+14)
#define CSMN_UNLIMITED          (CSMN_SRVNAME+15)

static MESSAGELIST srvmsg_list = {
    {   APE2_CFG_S_SRVNAME,         NULL  },
    {   APE2_CFG_S_SRVCOMM,         NULL  },
    {   APE2_CFG_S_ADMINALRT,       NULL  },
    {   APE2_CFG_S_VERSION,         NULL  },
    {   APE2_CFG_S_LEVEL,           NULL  },
    {   APE2_CFG_S_NETS,            NULL  },
    {   APE2_CFG_S_SRVHIDDEN,       NULL  },
    {   APE2_CFG_S_MAXUSERS,        NULL  },
    {   APE2_CFG_S_MAXADMINS,       NULL  },
    {   APE2_CFG_S_MAXSHARES,       NULL  },
    {   APE2_CFG_S_MAXCONNS,        NULL  },
    {   APE2_CFG_S_MAXOFILES,       NULL  },
    {   APE2_CFG_S_MAXOFILESPS,     NULL  },
    {   APE2_CFG_S_MAXLOCKS,        NULL  },
    {   APE2_CFG_S_IDLETIME,        NULL  },
    {   APE2_GEN_UNLIMITED,         NULL  },       };


#define NUMSMSG (sizeof(srvmsg_list)/sizeof(srvmsg_list[0]))


#define SV3_OFFSET(x) \
    ( FIELD_OFFSET( SERVER_INFO_3, x ) )

struct val_struct {
        unsigned int    offset;
        unsigned int    msgno;
};

struct val_struct srv_max[] = {
        {  SV3_OFFSET(sv3_users),           CSMN_MAXUSERS       },
        {  SV3_OFFSET(sv3_numadmin),        CSMN_MAXADMINS      },
        {  SV3_OFFSET(sv3_shares),          CSMN_MAXSHARES      },
        {  SV3_OFFSET(sv3_connections),     CSMN_MAXCONNS       },
        {  SV3_OFFSET(sv3_openfiles),       CSMN_MAXOFILES      },
        {  SV3_OFFSET(sv3_sessopens),       CSMN_MAXOFILESPS    },
        {  SV3_OFFSET(sv3_activelocks),     CSMN_MAXLOCKS       },
};

#define NUMSRVMAXVAL (sizeof(srv_max)/sizeof(srv_max[0]))


/***
 *  config_server_display()
 *      View the configuration of the current server.
 *
 */
VOID config_server_display(VOID)
{
    DWORD           dwErr;
    USHORT          major_ver;      /* Major version number */
    int             fsz, i;
    DWORD           maxmsglen;
    MSGTEXT         product_name;

    LPSERVER_INFO_3 info_entry;

    start_autostart(txt_SERVICE_FILE_SRV);

    if (dwErr = MNetServerGetInfo(DEFAULT_SERVER,
                                  3,
                                  (LPBYTE*) & info_entry))
    {
        ErrorExit (dwErr);
    }

    GetMessageList(NUMSMSG, srvmsg_list, &maxmsglen);

    fsz = maxmsglen + 5;

    GetMessageList(NUMVMSG, valmsg_list, &maxmsglen);

    //
    // Don't report on items that are not supported on NT.  This will mean
    // a fair number of ifdef's in this code.
    //

    WriteToCon(fmt11, 0, fsz,
               PaddedString(fsz, srvmsg_list[CSMN_SRVNAME].msg_text, NULL),
               (TCHAR FAR *) info_entry->sv3_name);
    WriteToCon(fmtPSZ, 0, fsz,
               PaddedString(fsz, srvmsg_list[CSMN_SRVCOMM].msg_text, NULL),
               (TCHAR FAR *) info_entry->sv3_comment);

    PrintNL();

    product_name = valmsg_list[CVMN_WINDOWS2000].msg_text;

    WriteToCon(fmt15, 0, fsz,
               PaddedString(fsz,srvmsg_list[CSMN_VERSION].msg_text,NULL),
               product_name);

    WriteToCon(fmt10,   0, fsz, PaddedString(fsz,srvmsg_list[CSMN_NETS].msg_text,NULL));
    print_lan_mask((ULONG)info_entry->sv3_lanmask, NETNAME_SERVER);

    PrintNL();

    WriteToCon(fmtNPSZ, 0, fsz,
               PaddedString(fsz, srvmsg_list[CSMN_SRVHIDDEN].msg_text, NULL),
               YES_OR_NO(info_entry->sv3_hidden) );

    {

        BYTE FAR * ptr;
        ULONG val;

        UNREFERENCED_PARAMETER(i);

        ptr = ((BYTE FAR *)info_entry) + srv_max[0].offset;
        val = * (ULONG FAR *) ptr;

        if (val != 0xFFFFFFFF)
            WriteToCon(fmtULONG, 0, fsz,
                       PaddedString(fsz, srvmsg_list[srv_max[0].msgno].msg_text, NULL),
                       val);
        else
            WriteToCon(fmtPSZ, 0, fsz,
                       PaddedString(fsz, srvmsg_list[srv_max[0].msgno].msg_text, NULL),
                       srvmsg_list[CSMN_UNLIMITED].msg_text) ;


        ptr = ((BYTE FAR *)info_entry) + srv_max[5].offset;
        val = * (ULONG FAR *) ptr;

        WriteToCon(fmtULONG, 0, fsz,
                   PaddedString(fsz, srvmsg_list[srv_max[5].msgno].msg_text, NULL),
                   val);

        PrintNL();
    }


    if (info_entry->sv3_disc == SV_NODISC)
        WriteToCon(fmt14, 0, fsz,
                   PaddedString(fsz, srvmsg_list[CSMN_IDLETIME].msg_text, NULL),
                   info_entry->sv3_disc);
    else
        WriteToCon(fmtUSHORT, 0, fsz,
                   PaddedString(fsz, srvmsg_list[CSMN_IDLETIME].msg_text, NULL),
                   info_entry->sv3_disc);


    NetApiBufferFree((TCHAR FAR *) info_entry);

    InfoSuccess();
}


/***
 *  config_server_change()
 *      Changes the specified configurable server parameters.
 *
 *
 */
VOID
config_server_change(VOID)
{
    DWORD         dwErr;
    USHORT        i;      /* That ever popular counter... */
    TCHAR *       ptr;


    LPSERVER_INFO_2 info_struct;

    start_autostart(txt_SERVICE_FILE_SRV);
    if (dwErr = MNetServerGetInfo(DEFAULT_SERVER,
                                  2,
                                  (LPBYTE*) &info_struct))
        ErrorExit (dwErr);

    for (i = 0; SwitchList[i]; i++)
    {
        /* All switches except /Srvhidden must be followed by a colon and an
           argument... */

        if (!_tcscmp(SwitchList[i], swtxt_SW_SRV_SRVHIDDEN))
        {
            info_struct->sv2_hidden =  1;
            continue;
        }

        if ((ptr = FindColon(SwitchList[i])) == NULL)
            ErrorExit(APE_InvalidSwitchArg);

        if ( !(_tcscmp(SwitchList[i], swtxt_SW_SRV_AUTODISCONNECT)) )
        {
            if (!_tcscmp(ptr, TEXT("-1")))
                info_struct->sv2_disc = SV_NODISC;
            else
                info_struct->sv2_disc =
                    do_atou(ptr,APE_CmdArgIllegal,swtxt_SW_SRV_AUTODISCONNECT);
        }
        else if ( !(_tcscmp(SwitchList[i], swtxt_SW_SRV_SRVCOMMENT)) )
        {
            if (_tcslen(ptr) > LM20_MAXCOMMENTSZ)
                ErrorExit(APE_InvalidSwitchArg) ;
            info_struct->sv2_comment = (TCHAR FAR *) ptr;
        }
        else if ( !(_tcscmp(SwitchList[i], swtxt_SW_SRV_SRVHIDDEN)) )
        {
            _tcsupr(ptr);
            if (*ptr == YES_KEY)
                info_struct->sv2_hidden =  1;
            else if (*ptr == NO_KEY)
                info_struct->sv2_hidden =  0;
            else
                ErrorExitInsTxt(APE_CmdArgIllegal,swtxt_SW_SRV_SRVHIDDEN);
        }
    }

    if (dwErr = MNetServerSetInfoLevel2((LPBYTE)info_struct))
    {
        ErrorExit (dwErr);
    }

    NetApiBufferFree((TCHAR FAR *) info_struct);

    InfoSuccess();
}

/*
 * generic display entry point. based on the service name, it will
 * call the correct worker function.
 */
VOID config_generic_display(TCHAR *service)
{
    TCHAR *keyname ;
    UINT  type ;

    keyname = MapServiceDisplayToKey(service) ;
    type = FindKnownService(keyname) ;

    switch (type)
    {
        case  KNOWN_SVC_WKSTA :
            config_wksta_display() ;
            break;
	case  KNOWN_SVC_SERVER :
	    config_server_display() ;
	    break ;
  	default:
	    help_help(0, USAGE_ONLY) ;
	    break ;
    }
}

/*
 * generic change entry point. based on the service name, it will
 * call the correct worker function.
 */
VOID config_generic_change(TCHAR *service)
{
    TCHAR *keyname ;
    UINT  type ;

    keyname = MapServiceDisplayToKey(service) ;
    type = FindKnownService(keyname) ;

    switch (type)
    {
	case  KNOWN_SVC_SERVER :
	    ValidateSwitches(0,config_server_switches) ;
	    config_server_change() ;
	    break ;
  	default:
	    help_help(0, USAGE_ONLY) ;
	    break ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\file.c ===
/********************************************************************/
/**			Microsoft LAN Manager			   **/
/**		  Copyright(c) Microsoft Corp., 1987-1990	   **/
/********************************************************************/

/***
 *  file.c
 *	Functions that list open file instances and lock counts and
 *	allow the files to be forced closed.
 *
 *  History:
 *	07/07/87, eap, initial coding
 *	05/02/89, thomaspa, change to use NetFileEnum2
	02/20/91, danhi, convert to use 16/32 mapping layer
 */

/* Include files */

#define INCL_NOCOMMON
#define INCL_DOSFILEMGR
#define INCL_ERRORS
#include <os2.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#define INCL_ERROR_H
#include <apperr.h>
#include <apperr2.h>
#include <stdio.h>
#include <stdlib.h>
#include <lmshare.h>
#include "netcmds.h"
#include "nettext.h"

/* Constants */

/* Static variables */

/* Forward declarations */

VOID NEAR compress_path (TCHAR FAR *, TCHAR *, DWORD);
VOID print_file_info( TCHAR FAR *pifbuf, DWORD _read );




#define FILE_MSG_ID		    0
#define FILE_MSG_NUM_LOCKS	    ( FILE_MSG_ID + 1)
#define FILE_MSG_OPENED_FOR	    ( FILE_MSG_NUM_LOCKS + 1)
#define FILE_MSG_PATH		    ( FILE_MSG_OPENED_FOR + 1)
#define FILE_MSG_USER_NAME	    ( FILE_MSG_PATH + 1)

static MESSAGE FileMsgList[] = {
{ APE2_FILE_MSG_ID,		    NULL },
{ APE2_FILE_MSG_NUM_LOCKS,	    NULL },
{ APE2_FILE_MSG_OPENED_FOR,	    NULL },
{ APE2_GEN_PATH,		    NULL },
{ APE2_GEN_USER_NAME,		    NULL },
};

#define NUM_FILE_MSGS	            (sizeof(FileMsgList)/sizeof(FileMsgList[0]))

/***
 *  files_display()
 *
 *	Displays information about lists of files or an individual
 *	file.
 *
 *  Args:
 *	id - the id of the file that the info is desired for. NULL if
 *	     info for all the active files on a server is desired.
 *
 *  Returns:
 *	0 - success
 *	exit(2) - command failed
 */
VOID
files_display(TCHAR *  id)
{
    DWORD            dwErr;      /* API return status */
    LPTSTR           pBuffer;
    DWORD	     _read;      /* num entries read by API */
    DWORD	     total;      /* num entries available */
    DWORD            maxLen;     /* max message length */
    TCHAR            buf[APE2_GEN_MAX_MSG_LEN];

    LPFILE_INFO_3 file_list_entry;

    DWORD_PTR resume;

    start_autostart(txt_SERVICE_FILE_SRV);

    if ( id == NULL )
    {
	resume = 0;
	dwErr  = NetFileEnum(NULL,
			     NULL,
			     NULL,
			     3,
			     (LPBYTE *) &pBuffer,
			     FULL_SEG_BUF,
			     &_read,
			     &total,
			     &resume);

	if( dwErr && dwErr != ERROR_MORE_DATA )
        {
	    ErrorExit(dwErr);
        }

	if (_read == 0)
        {
	    EmptyExit();
        }

	PrintNL();
	InfoPrint(APE2_FILE_MSG_HDR);
	PrintLine();

	/* Print the listing */

	print_file_info( pBuffer, _read );

	NetApiBufferFree(pBuffer);

	/* At this point, we know that dwErr is either 0 or
	   ERROR_MORE_DATA.  So enter the loop if error is not 0. */

	/* loop while there is still more */
	while( dwErr )
	{
	    dwErr = NetFileEnum( NULL,
				 NULL,
				 NULL,
				 3,
				 (LPBYTE*)&pBuffer,
				 (DWORD)-1L,
				 &_read,
				 &total,
				 &resume );
	    if( dwErr && dwErr != ERROR_MORE_DATA )
		ErrorExit(dwErr);

	    /* Print the listing */
	    print_file_info( pBuffer, _read );
	    NetApiBufferFree(pBuffer);
	}
    }
    else
    {
	ULONG actual_id ;
	if (n_atoul(id,&actual_id) != 0)
	{
	    ErrorExit(APE_FILE_BadId) ;
	}
	if (dwErr = NetFileGetInfo(NULL,
				   actual_id,
				   3,
				   (LPBYTE*) & file_list_entry))
        {
	    ErrorExit (dwErr);
        }

	GetMessageList(NUM_FILE_MSGS, FileMsgList, &maxLen);

	maxLen += 5;

	WriteToCon(fmtULONG, 0, maxLen,
               PaddedString(maxLen, FileMsgList[FILE_MSG_ID].msg_text, NULL),
               file_list_entry->fi3_id);

	WriteToCon(fmtPSZ, 0, maxLen,
               PaddedString(maxLen, FileMsgList[FILE_MSG_USER_NAME].msg_text, NULL),
               file_list_entry->fi3_username);

	WriteToCon(fmtUSHORT, 0, maxLen,
               PaddedString(maxLen, FileMsgList[FILE_MSG_NUM_LOCKS].msg_text, NULL),
               file_list_entry->fi3_num_locks);

	WriteToCon(fmtPSZ, 0, maxLen,
               PaddedString(maxLen, FileMsgList[FILE_MSG_PATH].msg_text, NULL),
               file_list_entry->fi3_pathname);

	PermMap(file_list_entry->fi3_permissions, buf, DIMENSION(buf));
	WriteToCon(fmtNPSZ, 0, maxLen,
               PaddedString(maxLen, FileMsgList[FILE_MSG_OPENED_FOR].msg_text, NULL),
               buf);

	NetApiBufferFree(file_list_entry);
    }

    InfoSuccess();
}

/*** print_file_info
 *
 *	Displays information about a list of files.
 *
 *  Args:
 *	pifbuf - a pointer to a buffer of FILE_INFO_3s.
 *
 *	read - the number of entries to display.
 *
 */
VOID print_file_info( TCHAR FAR *pifbuf, DWORD _read )
{
    TCHAR           comp_path[45];
    LPFILE_INFO_3   file_list_entry;
    DWORD	    i;

    for ( i = 0, file_list_entry = (LPFILE_INFO_3) pifbuf;
	i < _read; i++, file_list_entry++)
    {
	WriteToCon(TEXT("%-10lu "),file_list_entry->fi3_id );

	if ( _tcslen (file_list_entry->fi3_pathname) <= 39 )
	    WriteToCon (TEXT("%Fws"), PaddedString(40,file_list_entry->fi3_pathname,NULL));
	else
	{
	    compress_path (file_list_entry->fi3_pathname, comp_path, 39);
	    WriteToCon(TEXT("%Fws"), PaddedString(40,comp_path,NULL));
	}

	    WriteToCon(TEXT("%Fws  %-6u\r\n"),
		PaddedString(20,file_list_entry->fi3_username,NULL),
		file_list_entry->fi3_num_locks);
    }
}



/***
 *  files_close()
 *	Forces the specified file closed.
 *
 *  Args:
 *	id - the unique file id of the file to be closed.
 *
 */
VOID files_close(TCHAR * id)
{
    DWORD        dwErr;         /* API return status */
    ULONG	 actual_id ;

    start_autostart(txt_SERVICE_FILE_SRV);

    if (n_atoul(id,&actual_id) != 0)
    {
	ErrorExit(APE_FILE_BadId) ;
    }

    if (dwErr = NetFileClose(NULL, actual_id))
    {
	ErrorExit(dwErr);
    }

    InfoSuccess();
}




/***
 *  compress_path()
 *	Compresses a path name in to the specified length by truncating
 *	it in the middle.
 *
 *	Note - length must be at least 33, as must the size of dest.
 *	       Also, dest better be at least len characters long.
 *  Args:
 *	src  - the original path name.
 *	dest - the path name produced.
 *	len  - the disired length.
 *
 */
VOID NEAR compress_path(TCHAR FAR *  src, TCHAR * dest, DWORD len)
{
    DWORD   curr_pos;/* Our current position in the src */
    DWORD   dest_pos;/* The current position in the dest */
    DWORD   orig_len;/* The length of the src */
    DWORD   num_gone;/* The number of characters "removed" from src */
    DWORD   first_comp_len = 0;	   /* len of first path component */

#ifdef TRACE
    if ( len < 33 )
    {
	WriteToCon(TEXT("Compress_Path: Length must be at least 33. Given : %d\r\n"), len);
	return;
    }
#endif


    orig_len = _tcslen(src);

    if ( len >= orig_len )
    {
	_tcscpy (dest, src);
	return;
    }

    /* Put the drive:\ of src into dest */

    _tcsncpy (dest, src, 3);
    curr_pos = 3;
    dest_pos = 3;

    /*
     * Put in the first pathname component, or, if the component is long
     * only put the first ((len/2)-6) characters in (6 for drive:\ +
     * ... )
     *	We need to handle strings like
     *	c:\averylongfilenamearewestilltypeingyesweare
     * and
     *	c:\normal\path\which\doesnot\have\really\long\components.
     *
     * In the first case, truncate at approximately the middle, in the
     * second, truncate after the first path component.
     */

    while (0 != _tcsncmp(src+curr_pos, TEXT("\\"), 1) &&
		first_comp_len < ((len / 2) - 6))
    {
	first_comp_len++;
	curr_pos++;
    }
    _tcsncpy(dest+3, src+3, first_comp_len+1);
    dest_pos += first_comp_len+1;

    /* This is where the truncation takes place. */

    _tcscpy(dest+dest_pos, TEXT("..."));
    dest_pos += 3;

    /* Take out enough of the following components to make length(src) < len */

    num_gone = 0;

    while ( orig_len-num_gone+3 > len-1 )  /* -1 because we need room for \0 */
    {
	curr_pos += 1;
	while ( *(src+curr_pos) && _tcsncmp(src+curr_pos, TEXT("\\"), 1) )
	{
	    curr_pos++;
	    num_gone++;
	}
	if( !(*(src+curr_pos)) )
	{
	    /*
	     * We reached the end of the string, this must be a
	     * longfilename or long component name.  Set the
	     * position back to fill in as much as possible.
	     * 3 for drive, 3 for ..., 1 for null terminator.
	     */
	    curr_pos = orig_len - (len - (3 + first_comp_len + 3 + 1));
	    break;
	}
    }
    _tcscpy (dest+dest_pos, src+curr_pos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\group.c ===
/********************************************************************/
/**         Microsoft LAN Manager              **/
/**       Copyright(c) Microsoft Corp., 1987-1990      **/
/********************************************************************/

/*
 *  group.c
 *  net group cmds
 *
 *  History:
 *  mm/dd/yy, who, comment
 *  07/09/87, andyh, new code
 *  10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *  01/26/89, paulc, revision for 1.2
 *  05/02/89, erichn, NLS conversion
 *  05/09/89, erichn, local security mods
 *  05/19/89, erichn, NETCMD output sorting
 *  06/08/89, erichn, canonicalization sweep
 *  06/23/89, erichn, auto-remoting to DC
 *  02/15/91, danhi,  convert to 16/32 mapping layer
 *  03/17/92, chuckc, added /DOMAIN support
 */

/* Include files */

#define INCL_NOCOMMON
#define INCL_ERRORS
#include <os2.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#define INCL_ERROR_H
#include <apperr.h>
#include <apperr2.h>
#include <lmaccess.h>
#include <dlwksta.h>
#include "mwksta.h"
#include <icanon.h>
#include <search.h>
#include "netcmds.h"
#include "nettext.h"


/* Forward declarations */


int __cdecl CmpGroupInfo0(const VOID FAR *, const VOID FAR *);
int __cdecl CmpGrpUsrInfo0( const VOID FAR * , const VOID FAR * );



/***
 *  group_enum()
 *  Display info about all groups on a server
 *
 *  Args:
 *  none.
 *
 *  Returns:
 *  nothing - success
 *  exit 1 - command completed with errors
 *  exit 2 - command failed
 */

VOID group_enum(VOID)
{
    DWORD                dwErr;
    DWORD                cTotalAvail;
    TCHAR FAR *          pBuffer;
    DWORD                num_read;   /* num entries read by API */
    DWORD                i;
    int                  t_err = 0;
    TCHAR                localserver[MAX_PATH+1];
    LPGROUP_INFO_0       group_entry;
    LPWKSTA_INFO_10      wksta_entry;
    TCHAR                controller[MAX_PATH+1];   /* DC name */

    /* block operation if attempted on local WinNT machine */
    CheckForLanmanNT() ;

    /* get localserver name for display */
    if (dwErr = MNetWkstaGetInfo(10, (LPBYTE *) &wksta_entry))
    {
        t_err = TRUE;
        *localserver = NULLC;
    }
    else
    {
        _tcscpy(localserver,
                wksta_entry->wki10_computername) ;

        NetApiBufferFree((TCHAR FAR *) wksta_entry);
    }

    /* determine where to make the API call */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller), 
                               NULL, 0, FALSE))
    {
         ErrorExit(dwErr);
    }

    if (dwErr = NetGroupEnum(controller,
                             0,
                             (LPBYTE*)&pBuffer,
                             MAX_PREFERRED_LENGTH,
                             &num_read,
                             &cTotalAvail,
                             NULL))
        ErrorExit(dwErr);

    if (num_read == 0)
        EmptyExit();

    qsort(pBuffer, num_read, sizeof(GROUP_INFO_0), CmpGroupInfo0);

    PrintNL();
    InfoPrintInsTxt(APE2_GROUPENUM_HEADER,
                    controller[0] ? controller + _tcsspn(controller, TEXT("\\")) :
                        localserver);
    PrintLine();

    for (i = 0, group_entry = (LPGROUP_INFO_0) pBuffer;
         i < num_read;
         i++, group_entry++)
    {
        WriteToCon(TEXT("*%Fws\r\n"), group_entry->grpi0_name,NULL);
    }
    if (t_err)
    {
        InfoPrint(APE_CmdComplWErrors);
        NetcmdExit(1);
    }
    NetApiBufferFree(pBuffer);
    InfoSuccess();
    return;
}

/***
 *  CmpGroupInfo0(group1,group2)
 *
 *  Compares two GROUP_INFO_0 structures and returns a relative
 *  lexical value, suitable for using in qsort.
 *
 */

int __cdecl CmpGroupInfo0(const VOID FAR * group1, const VOID FAR * group2)
{
    INT n;
    n = CompareStringW( GetUserDefaultLCID(),
                        NORM_IGNORECASE,
                        (LPCWSTR)((LPGROUP_INFO_0) group1)->grpi0_name,
                        (int)-1,
                        (LPCWSTR)((LPGROUP_INFO_0) group2)->grpi0_name,
                        (int)-1);
    n -= 2;

    return n;
}

#define GROUPDISP_GROUPNAME 0
#define GROUPDISP_COMMENT   ( GROUPDISP_GROUPNAME + 1 )

static MESSAGE  msglist[] = {
{ APE2_GROUPDISP_GROUPNAME, NULL },
{ APE2_GROUPDISP_COMMENT,   NULL }
};
#define NUM_GRP_MSGS    (sizeof(msglist)/sizeof(msglist[0]))


/***
 *  group_display()
 *  Display info about a single group on a server
 *
 *  Args:
 *  group - name of group to display
 *
 *  Returns:
 *  nothing - success
 *  exit 1 - command completed with errors
 *  exit 2 - command failed
 */
VOID group_display(TCHAR * group)
{
    DWORD                    dwErr;
    DWORD                    dwErr2;
    DWORD                    cTotalAvail;
    DWORD                    num_read;   /* num entries read by API */
    DWORD                    maxmsglen;  /* maxmimum length of msg */
    DWORD                    i;
    LPGROUP_USERS_INFO_0     users_entry;
    LPGROUP_INFO_1           group_entry;
    TCHAR                    controller[MAX_PATH+1];   /* name of DC */

    /* block operation if attempted on local WinNT machine */
    CheckForLanmanNT() ;

    /* determine where to make the API call */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller), 
                               NULL, 0, FALSE))
    {
         ErrorExit(dwErr);
    }

    dwErr = NetGroupGetInfo ( controller,
                              group,
                              1,
                              (LPBYTE*)&group_entry);

    switch( dwErr )
    {
        case NERR_Success:
            break;
        case NERR_SpeGroupOp:

            if( dwErr2 = I_NetNameCanonicalize(NULL,
                           group,
                           group_entry->grpi1_name,
                           GNLEN+1,
                           NAMETYPE_GROUP,
                           0L))

            ErrorExit(dwErr2);
            group_entry->grpi1_comment = (LPTSTR) NULL_STRING;
            break;
        default:
            ErrorExit(dwErr);
    }

    GetMessageList(NUM_GRP_MSGS, msglist, &maxmsglen);

    maxmsglen += 5;

    WriteToCon( fmtPSZ, 0, maxmsglen,
                PaddedString(maxmsglen, msglist[GROUPDISP_GROUPNAME].msg_text, NULL),
                group_entry->grpi1_name );
    WriteToCon( fmtPSZ, 0, maxmsglen,
                PaddedString(maxmsglen, msglist[GROUPDISP_COMMENT].msg_text, NULL),
                group_entry->grpi1_comment );

    /*** The following call wipes out the GROUP_INFO_1 data in
     *   group_entry, obtained above.
     */

    NetApiBufferFree((TCHAR FAR *) group_entry);

    if (dwErr = NetGroupGetUsers(
                  controller,
                  group,
                  0,
                  (LPBYTE *) &group_entry,
                  MAX_PREFERRED_LENGTH,
                  &num_read,
                  &cTotalAvail,
                  NULL))
    {
        ErrorExit(dwErr);
    }

    qsort(group_entry, num_read, sizeof(GROUP_USERS_INFO_0), CmpGrpUsrInfo0);

    PrintNL();
    InfoPrint(APE2_GROUPDISP_MEMBERS);
    PrintLine();

    for (i = 0, users_entry = (LPGROUP_USERS_INFO_0) group_entry;
	i < num_read; i++, users_entry++) {
	WriteToCon(TEXT("%Fws"), PaddedString(25, users_entry->grui0_name, NULL));
	if (((i + 1) % 3) == 0)
	    PrintNL();
    }
    if ((i % 3) != 0)
	PrintNL();
    NetApiBufferFree((TCHAR FAR *) group_entry);
    InfoSuccess();
    return;
}

/***
 *  CmpGrpUsrInfo0(group1,group2)
 *
 *  Compares two GROUP_USERS_INFO_0 structures and returns a relative
 *  lexical value, suitable for using in qsort.
 *
 */

int __cdecl CmpGrpUsrInfo0(const VOID FAR * group1, const VOID FAR * group2)
{
    INT n;
    n = CompareStringW( GetUserDefaultLCID(),
                        NORM_IGNORECASE,
                        (LPCWSTR)((LPGROUP_USERS_INFO_0) group1)->grui0_name,
                        (int)-1,
                        (LPCWSTR)((LPGROUP_USERS_INFO_0) group2)->grui0_name,
                        (int)-1);
    n -= 2;

    return n;
}





/***
 *  group_add()
 *  Add a group
 *
 *  Args:
 *  group - group to add
 *
 *  Returns:
 *  nothing - success
 *  exit(2) - command failed
 */
VOID group_add(TCHAR * group)
{
    DWORD           dwErr;
    GROUP_INFO_1    group_info;
    int             i;
    LPTSTR          ptr;
    TCHAR           controller[MAX_PATH+1];

    /* block operation if attempted on local WinNT machine */
    CheckForLanmanNT() ;

    group_info.grpi1_name = group;
    group_info.grpi1_comment = NULL;

    for (i = 0; SwitchList[i]; i++)
    {
    /* Skip the ADD switch */
    if (! _tcscmp(SwitchList[i], swtxt_SW_ADD))
        continue;

    /* Skip the DOMAIN switch */
    if (! _tcscmp(SwitchList[i], swtxt_SW_DOMAIN))
        continue;

    /*  Check for COLON */

    if ((ptr = FindColon(SwitchList[i])) == NULL)
        ErrorExit(APE_InvalidSwitchArg);

    if (! _tcscmp(SwitchList[i], swtxt_SW_COMMENT))
        group_info.grpi1_comment = ptr;
    }

    /* determine where to make the API call */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller), 
                               NULL, 0, TRUE))
         ErrorExit(dwErr);

    dwErr = NetGroupAdd(controller,
                        1,
                        (LPBYTE) &group_info,
		        NULL);

    switch (dwErr)
    {
        case NERR_Success:
            break;
        case ERROR_BAD_NETPATH:
            ErrorExitInsTxt(APE_DCNotFound, controller);
        default:
            ErrorExit(dwErr);
    }
    InfoSuccess();
}


/***
 *  group_change()
 *  Change a group
 *
 *  Args:
 *  group - group to change
 *
 *  Returns:
 *  nothing - success
 *  exit(2) - command failed
 */
VOID group_change(TCHAR * group)
{
    DWORD           dwErr;
    TCHAR *         comment = NULL;
    int             i;
    TCHAR *         ptr;
    TCHAR           controller[MAX_PATH+1];

    /* block operation if attempted on local WinNT machine */
    CheckForLanmanNT() ;

    for (i = 0; SwitchList[i]; i++)
    {
        /* Skip the DOMAIN switch */
        if (! _tcscmp(SwitchList[i], swtxt_SW_DOMAIN))
            continue;

        /*  Check for COLON */

        if ((ptr = FindColon(SwitchList[i])) == NULL)
            ErrorExit(APE_InvalidSwitchArg);

        if (! _tcscmp(SwitchList[i], swtxt_SW_COMMENT))
            comment = ptr;
    }

    /* determine where to make the API call */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller), 
                               NULL, 0, TRUE))
         ErrorExit(dwErr);

    if (comment != NULL)
    {
        GROUP_INFO_1002 grp_info_1002;

        grp_info_1002.grpi1002_comment = comment;

        dwErr = NetGroupSetInfo(controller,
                                group,
                                GROUP_COMMENT_INFOLEVEL,
                                (LPBYTE) &grp_info_1002,
                                NULL);

        switch (dwErr)
        {
            case NERR_Success:
                break;
            case ERROR_BAD_NETPATH:
                ErrorExitInsTxt(APE_DCNotFound, controller);
            default:
                ErrorExit(dwErr);
        }
    }

    InfoSuccess();
}






/***
 *  group_del()
 *  Delete a group
 *
 *  Args:
 *  group - group to delete
 *
 *  Returns:
 *  nothing - success
 *  exit(2) - command failed
 */
VOID group_del(TCHAR * group)
{
    DWORD            dwErr;
    TCHAR            controller[MAX_PATH+1];


    /* block operation if attempted on local WinNT machine */
    CheckForLanmanNT() ;

    /* determine where to make the API call */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller), 
                               NULL, 0, TRUE))
         ErrorExit(dwErr);

    dwErr = NetGroupDel(controller, group);

    switch (dwErr)
    {
        case NERR_Success:
            break;
        case ERROR_BAD_NETPATH:
            ErrorExitInsTxt(APE_DCNotFound, controller);
        default:
            ErrorExit(dwErr);
    }
    InfoSuccess();
}


/***
 *  group_add_users()
 *  Add users to a group
 *
 *  Args:
 *  group - group to add users to
 *
 *  Returns:
 *  nothing - success
 *  exit(2) - command failed
 */
VOID group_add_users(TCHAR * group)
{
    DWORD           dwErr;
    int             err_cnt = 0;
    int             i;
    TCHAR            controller[MAX_PATH+1];

    /* block operation if attempted on local WinNT machine */
    CheckForLanmanNT() ;

    /* determine where to make the API call */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller), 
                               NULL, 0, TRUE))
         ErrorExit(dwErr);

    for (i = 2; ArgList[i]; i++)
    {
        dwErr = NetGroupAddUser(controller, group, ArgList[i]);
        switch (dwErr)
        {
            case NERR_Success:
                break;
            case ERROR_BAD_NETPATH:
                ErrorExitInsTxt(APE_DCNotFound, controller);
                break;
            case NERR_UserInGroup:
                IStrings[0] = ArgList[i];
                IStrings[1] = group;
                ErrorPrint(APE_UserAlreadyInGroup,2);
                err_cnt++;
                break;
            case NERR_UserNotFound:
                IStrings[0] = ArgList[i];
                ErrorPrint(APE_NoSuchUser,1);
                err_cnt++;
                break;
            case ERROR_INVALID_NAME:
                IStrings[0] = ArgList[i];
                ErrorPrint(APE_BadUGName,1);
                err_cnt++;
                break;
            default:
                ErrorExit(dwErr);
        }
    }

    if (err_cnt)
    {
        /* If at least one success, print complete-with-errs msg */
        if (err_cnt < (i - 2))
            InfoPrint(APE_CmdComplWErrors);
        /* Exit with error set */
        NetcmdExit(1);
    }
    else
        InfoSuccess();

}





/***
 *  group_del_users()
 *  Delete users from a group
 *
 *  Args:
 *  group - group to delete users from
 *
 *  Returns:
 *  nothing - success
 *  exit(2) - command failed
 */
VOID group_del_users(TCHAR * group)
{
    DWORD           dwErr;
    int             err_cnt = 0;
    int             i;
    TCHAR            controller[MAX_PATH+1];

    /* block operation if attempted on local WinNT machine */
    CheckForLanmanNT() ;

    /* determine where to make the API call */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller), 
                               NULL, 0, TRUE))
         ErrorExit(dwErr);

    for (i = 2; ArgList[i]; i++)
    {
        dwErr = NetGroupDelUser(controller, group, ArgList[i]);
        switch (dwErr)
        {
            case NERR_Success:
                break;
            case ERROR_BAD_NETPATH:
                ErrorExitInsTxt(APE_DCNotFound, controller);
                break;
            case NERR_UserNotInGroup:
                IStrings[0] = ArgList[i];
                IStrings[1] = group;
                ErrorPrint(APE_UserNotInGroup,2);
                err_cnt++;
                break;
            case NERR_UserNotFound:
                IStrings[0] = ArgList[i];
                ErrorPrint(APE_NoSuchUser,1);
                err_cnt++;
                break;
            case ERROR_INVALID_NAME:
                IStrings[0] = ArgList[i];
                ErrorPrint(APE_BadUGName,1);
                err_cnt++;
                break;
            default:
                ErrorExit(dwErr);
        }
    }

    if (err_cnt)
    {
        /* If at least one success, print complete-with-errs msg */
        if (err_cnt < (i - 2))
            InfoPrint(APE_CmdComplWErrors);
        /* Exit with error set */
        NetcmdExit(1);
    }
    else
        InfoSuccess();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\contpaus.c ===
/********************************************************************/
/**			Microsoft LAN Manager			   **/
/**		  Copyright(c) Microsoft Corp., 1987-1992	   **/
/********************************************************************/

/***
 *  contpaus.c
 *	process net continue and net pause cmds
 *
 *  History:
 *	mm/dd/yy, who, comment
 *	07/21/87, agh, new code
 *	10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *	12/02/88, erichn, DOS LM integration
 *	05/02/89, erichn, NLS conversion
 *	06/08/89, erichn, canonicalization sweep
 *	10/04/89, thomaspa, require priv to pause or continue server
 *	02/20/91, danhi, convert to 16/32 mapping layer
 *	06/02/92, JohnRo, RAID 9829: Avoid winsvc.h compiler warnings
 */

/* Include files */

#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_ERRORS
#include <os2.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <apperr.h>
#define INCL_ERROR_H
#include <lmsvc.h>      // LM20_SERVICE_ equates.
#include <lmshare.h>
#include "netcmds.h"
#include "nettext.h"
#include "msystem.h"

/* Constants */

/* Static variables */

/* Forward declarations */

VOID NEAR cont_service(TCHAR *, TCHAR);
VOID NEAR paus_service(TCHAR *, TCHAR);




/***
 *  cont_workstation()
 *	Continues the wksta
 *
 *  Args:
 *	none
 *
 *  Returns:
 *	nothing - success
 */
VOID cont_workstation(VOID)
{
    cont_service(txt_SERVICE_REDIR,
#ifdef OS2
		SERVICE_CTRL_REDIR_PRINT | SERVICE_CTRL_REDIR_COMM);
#else
		SERVICE_CTRL_REDIR_PRINT | SERVICE_CTRL_REDIR_DISK);
#endif /* OS2 */
}







/***
 *  paus_workstation(VOID)
 *	Pauses the wksta
 *
 *  Args:
 *	none
 *
 *  Returns:
 *	nothing - success
 */
VOID paus_workstation(VOID)
{
    paus_service(txt_SERVICE_REDIR,
#ifdef OS2
		SERVICE_CTRL_REDIR_PRINT | SERVICE_CTRL_REDIR_COMM);
#else
		SERVICE_CTRL_REDIR_PRINT | SERVICE_CTRL_REDIR_DISK);
#endif /* OS2 */
}


/***
 *  cont_other(TCHAR *)
 *	Continues other services: server, popup, alerter, netrun,
 *	<oem_service>
 *
 *  Args:
 *	service - service to cont
 *
 *  Returns:
 *	nothing - success
 */
VOID cont_other(TCHAR * service)
{
    cont_service(service, 0);
}







/***
 *  paus_other(TCHAR * )
 *	Pauses other services: server, popup, alerter, netrun,
 *	<oem_service>
 *
 *  Args:
 *	service - service to pause
 *
 *  Returns:
 *	nothing - success
 */
VOID paus_other(TCHAR * service)
{
    paus_service(service, 0);
}


/***
 *  cont_service()
 *	Actually continue the service
 *
 *  Args:
 *	service - service to cont
 *	arg - arg for NetServiceControl
 *
 *  Returns:
 *	nothing - success
 *	exit 2 - command failed
 *
 */
VOID NEAR cont_service(TCHAR * service, TCHAR arg)
{
    DWORD             dwErr;
    DWORD             cTotalAvail;
    int               i = 0;
    LPSERVICE_INFO_2  service_entry;
    DWORD             _read;

    if( !_tcsicmp(service, txt_SERVICE_FILE_SRV) )
    {
	/*
	 * Do a NetSessionEnum at level 1 to make sure the user has proper
	 * privilege to continue the server.
	 */
	if( (dwErr = NetSessionEnum( NULL,
                                     NULL,
                                     NULL,
				     1,
				     (LPBYTE*) & service_entry,
                                     MAX_PREFERRED_LENGTH,
				     &_read,
                                     &cTotalAvail,
                                     NULL)) == ERROR_ACCESS_DENIED )
        {
	    ErrorExit(dwErr);
        }

	if (dwErr == NERR_Success)
        {
	    NetApiBufferFree((LPTSTR) service_entry);
        }
    }

    if (dwErr = NetServiceControl(NULL,
				  service,
				  SERVICE_CTRL_CONTINUE,
				  arg,
				  (LPBYTE*) &service_entry))
    {
	ErrorExit(dwErr);
    }

    if ((service_entry->svci2_status & SERVICE_PAUSE_STATE)
	== LM20_SERVICE_CONTINUE_PENDING)
    {
	InfoPrintInsTxt(APE_ContPending,
                        MapServiceKeyToDisplay(service));
    }

    while (((service_entry->svci2_status & SERVICE_PAUSE_STATE)
	!= LM20_SERVICE_ACTIVE) && (i++ < MAXTRIES))
    {
	PrintDot();
	Sleep(SLEEP_TIME);
	NetApiBufferFree((TCHAR FAR *) service_entry);
	if (dwErr = NetServiceControl(NULL,
				      service,
				      SERVICE_CTRL_INTERROGATE,
				      NULLC,
				      (LPBYTE*) & service_entry))
	    ErrorExit(dwErr);

	if ((service_entry->svci2_status & SERVICE_PAUSE_STATE)
	    == LM20_SERVICE_PAUSED)
	    /* continue failed */
	    break;
    } /* while */

    PrintNL();
    if ((service_entry->svci2_status & SERVICE_PAUSE_STATE)
	!= LM20_SERVICE_ACTIVE)
    {
	ErrorExitInsTxt(APE_ContFailed, 
                        MapServiceKeyToDisplay(service));
    }
    else
    {
	InfoPrintInsTxt(APE_ContSuccess, 
                        MapServiceKeyToDisplay(service));
    }
    NetApiBufferFree((TCHAR FAR *) service_entry);
}


/***
 *  paus_service()
 *	Actually pause the service
 *
 *  Args:
 *	service - service to pause
 *	arg - arg for NetServiceControl
 *
 *  Returns:
 *	nothing - success
 *	exit 2 - command failed
 *
 */
VOID NEAR paus_service(TCHAR * service, TCHAR arg)
{
    DWORD             dwErr;
    DWORD             cTotalAvail;
    int               i = 0;
    LPSERVICE_INFO_2  service_entry;
    DWORD             _read;

    if( !_tcsicmp(service, txt_SERVICE_FILE_SRV) )
    {
	/*
	 * Do a NetSessionEnum at level 1 to make sure the user has proper
	 * privilege to pause the server.
	 */
	if( (dwErr = NetSessionEnum(NULL,
                                    NULL,
                                    NULL,
				    1,
				    (LPBYTE*) & service_entry,
                                    MAX_PREFERRED_LENGTH,
				    &_read,
                                    &cTotalAvail,
                                    NULL)) == ERROR_ACCESS_DENIED )
	    ErrorExit(dwErr);
	if (dwErr == NERR_Success)
	    NetApiBufferFree((TCHAR FAR *) service_entry);
    }

    if (dwErr = NetServiceControl(NULL,
				  service,
				  SERVICE_CTRL_PAUSE,
				  arg,
				  (LPBYTE*) & service_entry))
    {
	ErrorExit(dwErr);
    }

    if ((service_entry->svci2_status & SERVICE_PAUSE_STATE)
	== LM20_SERVICE_PAUSE_PENDING)
    {
	InfoPrintInsTxt(APE_PausPending, 
                        MapServiceKeyToDisplay(service));
    }

    while (((service_entry->svci2_status & SERVICE_PAUSE_STATE)
	!= LM20_SERVICE_PAUSED) && (i++ < MAXTRIES))
    {
	PrintDot();
	Sleep(SLEEP_TIME);
	NetApiBufferFree((TCHAR FAR *) service_entry);
	if (dwErr = NetServiceControl(NULL,
				      service,
				      SERVICE_CTRL_INTERROGATE,
				      NULLC,
				      (LPBYTE*) & service_entry))
        {
	    ErrorExit(dwErr);
        }

	if ((service_entry->svci2_status & SERVICE_PAUSE_STATE)
	    == LM20_SERVICE_ACTIVE)
	    /* pause failed */
	    break;
    } /* while */


    PrintNL();
    if ((service_entry->svci2_status & SERVICE_PAUSE_STATE)
	!= LM20_SERVICE_PAUSED)
    {
	ErrorExitInsTxt(APE_PausFailed, 
                        MapServiceKeyToDisplay(service));
    }
    else
    {
	InfoPrintInsTxt(APE_PausSuccess, 
                        MapServiceKeyToDisplay(service));
    }
    NetApiBufferFree((TCHAR FAR *) service_entry);
}

/*
 * generic continue entry point. based on the service name, it will
 * call the correct worker function.
 */
VOID cont_generic(TCHAR *service)
{
    TCHAR *keyname ;
    UINT  type ;

    keyname = MapServiceDisplayToKey(service) ;

    type = FindKnownService(keyname) ;

    switch (type)
    {
	case  KNOWN_SVC_MESSENGER :
	    cont_other(txt_SERVICE_MSG_SRV) ;
	    break ;
	case  KNOWN_SVC_WKSTA :
	    cont_workstation() ;
	    break ;
	case  KNOWN_SVC_SERVER :
	    cont_other(txt_SERVICE_FILE_SRV) ;
	    break ;
	case  KNOWN_SVC_NOTFOUND :
        default:
	    cont_other(keyname);
	    break ;
    }
}

/*
 * generic pause entry point. based on the service name, it will
 * call the correct worker function.
 */
VOID paus_generic(TCHAR *service)
{
    TCHAR *keyname ;
    UINT  type ;

    keyname = MapServiceDisplayToKey(service) ;

    type = FindKnownService(keyname) ;

    switch (type)
    {
	case  KNOWN_SVC_MESSENGER :
	    paus_other(txt_SERVICE_MSG_SRV) ;
	    break ;
	case  KNOWN_SVC_WKSTA :
	    paus_workstation() ;
	    break ;
	case  KNOWN_SVC_SERVER :
	    paus_other(txt_SERVICE_FILE_SRV) ;
	    break ;
	case  KNOWN_SVC_NOTFOUND :
        default:
	    paus_other(keyname);
	    break ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\main.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 * MSNET - a command processor for MSNET 3.0.
 * The command grammar is specified in msnet.x
 *
 *      History
 *
 *      ??/??/??, ??????, initial code
 *      10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *      05/02/89, erichn, NLS conversion
 *      06/08/89, erichn, canonicalization sweep, no LONGer u-cases input
 *      02/15/91, danhi,  convert to be 16/32 portable
 *      10/16/91, JohnRo, added DEFAULT_SERVER support.
 */

/* #define INCL_NOCOMMON */
#include <os2.h>
#include <lmcons.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <io.h>
#include <apperr.h>
#include "netcmds.h"
#include "nettext.h"
#include "msystem.h"
#include "locale.h"

#define _SHELL32_
#include <shellapi.h>


static VOID NEAR init(VOID);

TCHAR *                      ArgList[LIST_SIZE] = {0};
SHORT                       ArgPos[LIST_SIZE] = {0};
TCHAR *                      SwitchList[LIST_SIZE] = {0};
SHORT                       SwitchPos[LIST_SIZE] = {0};

/* Insertion strings for InfoMessage() */
TCHAR FAR *                  IStrings[10] = {0};
TCHAR FAR *                  StarStrings[10] = {TEXT("***"),
                                                TEXT("***"),
                                                TEXT("***"),
                                                TEXT("***"),
                                                TEXT("***"),
                                                TEXT("***"),
                                                TEXT("***"),
                                                TEXT("***"),
                                                TEXT("***")};

/* 1 is /Yes, 2 is /No */
SHORT                       YorN_Switch = 0;
TCHAR **                     MyArgv;   /* argv */

UINT                        SavedArgc = 0 ;
CHAR **                     SavedArgv = NULL ;

/* Buffers for APIs to use */
TCHAR                        Buffer[LITTLE_BUF_SIZE];    /* For GetInfo's, etc.*/
TCHAR                        BigBuffer[BIG_BUF_SIZE];    /* For Enum's */
TCHAR FAR *                  BigBuf = BigBuffer;

//
// Globals for standard console handles
//

HANDLE  g_hStdOut;
HANDLE  g_hStdErr;


/***
 * MAIN - Seperate the command line into switches and arguments.
 * Then call the parser, which will dispatch the command and
 * report on error conditions.  Allocate the BigBuf.
 */

VOID os2cmd(VOID);
CPINFO CurrentCPInfo;

VOID __cdecl main(int argc, CHAR **argv)
{
    SHORT           sindex, aindex;
    SHORT           pos=0;
    DWORD	    cp;
    CHAR            achCodePage[12] = ".OCP";    // '.' + UINT in decimal + '\0'

    SavedArgc = argc ;
    SavedArgv = argv ;


    /*
       Added for bilingual message support.  This is needed for FormatMessage
       to work correctly.  (Called from DosGetMessage).
       Get current CodePage Info.  We need this to decide whether
       or not to use half-width characters.
    */

    cp = GetConsoleOutputCP();

    GetCPInfo(cp, &CurrentCPInfo);

    switch ( cp ) {
	case 932:
	case 936:
	case 949:
	case 950:
	    SetThreadLocale(
		MAKELCID(
		    MAKELANGID(
			    PRIMARYLANGID(GetSystemDefaultLangID()),
			    SUBLANG_ENGLISH_US ),
		    SORT_DEFAULT
		    )
		);
	    break;

	default:
	    SetThreadLocale(
		MAKELCID(
		    MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
		    SORT_DEFAULT
		    )
		);
	    break;
    }

    if (cp)
    {
        sprintf(achCodePage, ".%u", cp);
    }

    setlocale(LC_ALL, achCodePage);

    g_hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

    if (g_hStdOut == INVALID_HANDLE_VALUE)
    {
        ErrorExit(GetLastError());
    }

    g_hStdErr = GetStdHandle(STD_ERROR_HANDLE);

    if (g_hStdErr == INVALID_HANDLE_VALUE)
    {
        ErrorExit(GetLastError());
    }

    MyArgv = CommandLineToArgvW(GetCommandLineW(), &argc);
    if (MyArgv == NULL)
    {
        ErrorExit(ERROR_NOT_ENOUGH_MEMORY) ;
    }

    /* seperate switches and arguments */
    ++MyArgv;
    for (sindex = 0, aindex = 0; --argc; ++MyArgv, ++pos)
    {
        if (**MyArgv == SLASH)
        {
            SHORT arglen;
            SHORT arg_is_special = 0;

            arglen = (SHORT) _tcslen(*MyArgv);

            if (arglen > 1)
            {
                if ( _tcsnicmp(swtxt_SW_YES, (*MyArgv), arglen) == 0 )
                {
                    if (YorN_Switch == NO)
                        ErrorExit(APE_ConflictingSwitches);
                    arg_is_special = 1;
                    YorN_Switch = YES;
                }
                else if ( _tcsnicmp(swtxt_SW_NO, (*MyArgv), arglen) == 0 )
                {
                    if (YorN_Switch == YES)
                        ErrorExit(APE_ConflictingSwitches);
                    arg_is_special = 1;
                    YorN_Switch = NO;
                }
            }

            if ( ! arg_is_special )
            {
                if (sindex >= LIST_SIZE)
                    ErrorExit(APE_NumArgs) ;
                SwitchList[sindex] = *MyArgv;
                SwitchPos[sindex] = pos;
                sindex++;
            }
        }
        else
        {
            if (aindex >= LIST_SIZE)
                ErrorExit(APE_NumArgs) ;
            ArgList[aindex] = *MyArgv;
            ArgPos[aindex] = pos;
            aindex++;
        }
    }

    // register as locations to zero out on exit
    AddToMemClearList(BigBuffer, sizeof(BigBuffer), FALSE) ;
    AddToMemClearList(Buffer, sizeof(Buffer),FALSE) ;

    init();

    os2cmd();

    NetcmdExit(0);
}


static VOID NEAR init(VOID)
{
    _setmode(_fileno(stdin), O_TEXT);
}

/***
 *  M y E x i t
 *
 *    Wrapper around C runtime that cleans up memory for security reasons.
 */

VOID DOSNEAR FASTCALL
MyExit(int Status)
{
    ClearMemory() ;
    exit(Status);
}

typedef struct _MEMOMY_ELEMENT {
    LPBYTE                  lpLocation ;
    struct _MEMORY_ELEMENT *lpNext ;
    UINT                    nSize ;
    BOOL                    fDelete ;
}  MEMORY_ELEMENT, *LPMEMORY_ELEMENT ;

LPMEMORY_ELEMENT lpToDeleteList = NULL ;

/***
 *  AddToMemClearList
 *
 *   add an entry to list of things to clear
 */
VOID AddToMemClearList(VOID *lpBuffer,
                       UINT  nSize,
                       BOOL  fDelete)
{
    LPMEMORY_ELEMENT lpNew, lpTmp ;
    DWORD err ;

    if (err = AllocMem(sizeof(MEMORY_ELEMENT),(LPBYTE *) &lpNew))
    {
        ErrorExit(err);
    }

    lpNew->lpLocation = (LPBYTE) lpBuffer ;
    lpNew->nSize = nSize ;
    lpNew->fDelete = fDelete ;
    lpNew->lpNext = NULL ;

    if (!lpToDeleteList)
        lpToDeleteList = lpNew ;
    else
    {
        lpTmp = lpToDeleteList ;
        while (lpTmp->lpNext)
            lpTmp = (LPMEMORY_ELEMENT) lpTmp->lpNext ;
        lpTmp->lpNext = (struct _MEMORY_ELEMENT *) lpNew ;
    }
}

/***
 *  ClearMemory()
 *
 *   go thru list of things to clear, and clear them.
 */
VOID ClearMemory(VOID)
{

    LPMEMORY_ELEMENT lpList, lpTmp ;
    UINT index ;

    /*
     * Go thru memory registered to be cleaned up.
     */
    lpList = lpToDeleteList ;
    while (lpList)
    {
        memset(lpList->lpLocation, 0, lpList->nSize) ;
        lpTmp = (LPMEMORY_ELEMENT) lpList->lpNext ;
        if (lpList->fDelete)
            FreeMem(lpList->lpLocation) ;
        FreeMem( (LPBYTE) lpList) ;
        lpList = lpTmp ;
    }
    lpToDeleteList = NULL ;

    /*
     * cleanup our copy of the args
     */
    index = 0;
    while (ArgList[index])
    {
        ClearStringW(ArgList[index]) ;
        index++ ;
    }

    /*
     * cleanup original argv
     */
    for ( index = 1 ; index < SavedArgc ; index++ )
    {
        ClearStringA(SavedArgv[index]) ;
    }
    ClearStringW(GetCommandLine());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\message.c ===
/********************************************************************/
/**			Microsoft LAN Manager			   **/
/**		  Copyright(c) Microsoft Corp., 1987-1990	   **/
/********************************************************************/

/***
 *  message.c
 *	Functions for message handling: forward, log, name, send.
 *
 *  History:
 *	mm/dd/yy, who, comment
 *	06/02/87, andyh, new code
 *	10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *	01/04/89, erichn, filenames now MAXPATHLEN LONG
 *	02/08/89, paulc, Net Send /DOMAIN and /BROADCAST mods
 *	05/02/89, erichn, NLS conversion
 *	05/09/89, erichn, local security mods
 *	06/08/89, erichn, canonicalization sweep
 *	02/20/91, danhi, change to use lm 16/32 mapping layer
 */

/* Include files */

#define INCL_NOCOMMON
#define INCL_DOSFILEMGR
#define INCL_ERRORS
#include <os2.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <apperr.h>
#include <apperr2.h>
#include <lmmsg.h>
#include <lmshare.h>
#include <stdlib.h>
#include <dlwksta.h>
#include "mwksta.h"
#include <lui.h>
#include "netcmds.h"
#include "nettext.h"

/* Constants */

#define FROM_CMD_LINE	    1
#define FROM_STDIN	    2

#define TO_NAME 	    1
#define TO_GROUP	    2		// no longer used
#define TO_USERS	    3
#define TO_DOMAIN	    4
#define TO_ALL		    5

/* External variables defined in sighand.c.									*/

extern USHORT FAR	 CtrlCFlag;	/* Used by sig handler for Ctrl-C event.	*/

VOID NEAR
  _sendmsg ( int, int, TCHAR FAR *, TCHAR FAR *, DWORD, DWORD);



/*
 *  NOTE!  be CAREFUL when adding stuff here, make sure what's appropriate
 *  is put in the DOS NameMsgList as well.
 */

#define NAME_MSG_NAME		    0
#define NAME_MSG_FWD		    ( NAME_MSG_NAME + 1)
#define NAME_MSG_FWD_FROM	    ( NAME_MSG_FWD + 1 )
static MESSAGE NameMsgList[] = {
    { APE2_NAME_MSG_NAME,		NULL },
    { APE2_NAME_MSG_FWD,		NULL },
    { APE2_NAME_MSG_FWD_FROM,		NULL },
};

#define NUM_NAME_MSGS	(sizeof(NameMsgList)/sizeof(NameMsgList[0]))

/***
 *  name_display()
 *	Display messaging names
 *
 *  Args:
 *	none
 *
 *  Returns:
 *	0 - success
 *	exit 2 - command failed
 */
VOID name_display(VOID)
{
    DWORD           dwErr;              /* API return status */
    DWORD           num_read;		/* num entries read by API */
    DWORD           cTotalAvail;
    DWORD	    maxLen;		/* max message len */
    DWORD           i;
    LPMSG_INFO_1    msg_entry;
    LPMSG_INFO_1    msg_entry_buffer;
    static TCHAR    fmt1[] = TEXT("%-15.15Fws ");

    start_autostart(txt_SERVICE_REDIR);
    start_autostart(txt_SERVICE_MSG_SRV);

    if (dwErr = NetMessageNameEnum(
			    NULL,
			    1,
			    (LPBYTE*)&msg_entry_buffer,
                            MAX_PREFERRED_LENGTH,
			    &num_read,
                            &cTotalAvail,
                            NULL))
	ErrorExit(dwErr);

    if (num_read == 0)
	EmptyExit();

    GetMessageList(NUM_NAME_MSGS, NameMsgList, &maxLen);

    PrintNL();
    WriteToCon(fmt1, (TCHAR FAR *) NameMsgList[NAME_MSG_NAME].msg_text);
    PrintNL();
    PrintLine();

    msg_entry = msg_entry_buffer ;
    for (i = 0; i < num_read; i++)
    {
	WriteToCon(fmt1, msg_entry->msgi1_name);
	PrintNL();
	msg_entry += 1;
    }

    NetApiBufferFree((TCHAR FAR *) msg_entry_buffer);
    InfoSuccess();
}



/***
 *  name_add()
 *	Add a messaging name
 *
 *  Args:
 *	name - name to add
 *
 *  Returns:
 *	0 - success
 *	exit(2) - command failed
 */
VOID name_add(TCHAR * name)
{
    USHORT			err;		    /* function return status */
    DWORD                       dwErr;

    start_autostart(txt_SERVICE_REDIR);
    start_autostart(txt_SERVICE_MSG_SRV);

    if (err = LUI_CanonMessagename( name ) )
	ErrorExit(err);

    if (dwErr = NetMessageNameAdd(NULL, name))
        ErrorExit(dwErr);

    InfoPrintInsTxt(APE_NameSuccess, name);
}



/***
 *  name_del()
 *	Delete a messaging name
 *
 *  Args:
 *	name - name to delete
 *
 *  Returns:
 *	0 - success
 *	exit(2) - command failed
 */
VOID name_del(TCHAR * name)
{
    USHORT			err;		    /* function return status */
    DWORD                       dwErr;

    start_autostart(txt_SERVICE_REDIR);
    start_autostart(txt_SERVICE_MSG_SRV);

    if (err = LUI_CanonMessagename( name ) )
	ErrorExit(err);

    dwErr = NetMessageNameDel(NULL, name);

    switch(dwErr) {
    case NERR_DeleteLater:
	InfoPrint(err);
	InfoSuccess();
	break;
    case 0:
	InfoPrintInsTxt(APE_DelSuccess, name);
	break;
    default:
	ErrorExit(dwErr);
    }
}






/***
 *  send_direct()
 *	Send a directed message to a user
 *
 *  Args:
 *	recipient - recipient of msg
 *
 *  Returns:
 *	0 - success
 *	exit(1) - command completed with errors
 *	exit(2) - command failed
 *
 *  Operation:
 *	Performs a send to the messaging name.
 *
 *  Note:
 */
VOID send_direct ( TCHAR * recipient )
{

    start_autostart(txt_SERVICE_REDIR);

    if (_tcscmp(recipient,TEXT("*")) == 0)
    {
	send_domain(0);
	return;
    }

    _sendmsg (	2,
		TO_NAME,
		recipient,
		recipient,
		1,
		0 );
}



/***
 *  send_users()
 *	Send a message to all users on a server
 *
 *  Args:
 *	none
 *
 *  Returns:
 *	0 - success
 *	exit(1) - command completed with errors
 *	exit(2) - command failed
 */

VOID
send_users(
    VOID
    )
{
    DWORD     dwErr;        /* API return status */
    DWORD     cTotalAvail;
    LPTSTR    pBuffer;
    DWORD     num_read;     /* num entries read by API */

    start_autostart(txt_SERVICE_REDIR);

    /* Who gets the message? */

    /* possible race cond... tough */
    if (dwErr = NetSessionEnum(
			    NULL,
                            NULL,
                            NULL,
			    0,
			    (LPBYTE*)&pBuffer,
                            MAX_PREFERRED_LENGTH,
			    &num_read,
                            &cTotalAvail,
                            NULL))
    {
        ErrorExit(dwErr);
    }

    if (num_read == 0)
    {
	InfoPrint(APE_NoUsersOfSrv);
	NetcmdExit(0);
    }

    _sendmsg(1,
             TO_USERS,
             NULL,
             pBuffer,
             num_read,
             sizeof(SESSION_INFO_0));

    NetApiBufferFree(pBuffer);

}


/***
 *  send_domain()
 *	Send a message to all users on a server
 *
 *  Args:
 *	is_switch - true if /DOMAIN switch on command line
 *
 *  Returns:
 *	0 - success
 *	exit(1) - command completed with errors
 *	exit(2) - command failed
 */

VOID
send_domain(
    int is_switch
    )
{
    DWORD             dwErr;
    LPWKSTA_INFO_10   wi10_p;
    TCHAR             domain_buf[MAX_PATH+2];
    int               i, have_name = 0;
    LPTSTR            ptr;

    start_autostart(txt_SERVICE_REDIR);

    /*	If there was a /DOMAIN switch, find it and get the domain
     *	name.  A /DOMAIN switch w/o a domain is taken as meaning
     *	"primary domain".  We just skip on by in this case.
     */

    if (is_switch)
    {
	for (i=0; SwitchList[i]; i++)
	{
	    /*	If we match /DOMAIN exactly, there is no argument, so
	     *	we skip this case (and do NOT set have_name).
	     */

	    if (!_tcscmp(SwitchList[i], swtxt_SW_DOMAIN))
		continue;

	    /*	OK, so we know the swith is not just plain /DOMAIN.
	     *	All other switches MUST have a colon.  Just so happens
	     *	that the only other legal switch is /DOMAIN:foo.
	     */

	    if ((ptr = FindColon(SwitchList[i])) == NULL)
		ErrorExit(APE_InvalidSwitchArg);

	    /*	See if this is indeed /DOMAIN:foo.  If so, process it.
	     *	SPECIAL CASE ... if the "argument" is the null string,
	     *	we pretend we never got the name, just as for /DOMAIN
	     *	(without the colon).
	     */

	    if ( !(_tcscmp(SwitchList[i], swtxt_SW_DOMAIN)) )
	    {
		if (_tcslen(ptr) > 0)
		{
		    if( _tcslen(ptr) > DIMENSION(domain_buf)-2 )
			ErrorExit(APE_InvalidSwitchArg);
		    _tcsncpy(domain_buf,ptr,DIMENSION(domain_buf)-2);
		    domain_buf[DIMENSION(domain_buf)-2] = 0;
		    have_name = 1;
		}
	    }
	    else
		ErrorExit(APE_InvalidSwitchArg);
	}
    }

    /*	If we do not have a domain name yet, because:
     *	   (a) no /DOMAIN switch was given, or
     *	   (b) the /DOMAIN switch had no argument,
     *	then fetch the primary domain name.
     */

    if (! have_name)
    {
	/* possible race cond... tough */
	if (dwErr = MNetWkstaGetInfo (10, (LPBYTE*) &wi10_p))
        {
	    ErrorExit(dwErr);
        }

	_tcsncpy(domain_buf, wi10_p->wki10_langroup, DIMENSION(domain_buf)-2);
	domain_buf[DIMENSION(domain_buf)-2] = 0;
    }

    /*	Add the tag "*" to the name, then send the message.  Note that
     *	the first arg depends on whether we got to this function
     *	via the /DOMAIN method (is_switch) or ASTERISK.  If the latter,
     *	we start at ArgList[2] to skip the ASTERISK.
     */

    _tcscat(domain_buf,TEXT("*"));

    _sendmsg (	(is_switch ? 1 : 2),
		TO_DOMAIN,
		domain_buf,
		domain_buf,
		1,
		0 );

    NetApiBufferFree((TCHAR FAR *) wi10_p);

}


/***
 *  send_broadcast()
 *	Send a message to all users on the net
 *
 *  Args:
 *	is_switch - true if /BROADCAST switch on command line
 *
 *  Returns:
 *	0 - success
 *	exit(1) - command completed with errors
 *	exit(2) - command failed
 */

VOID send_broadcast ( int is_switch )
{

    start_autostart(txt_SERVICE_REDIR);

    /*	The first arg depends on whether we got to this function
     *	via the /BROADCAST method (is_switch) or ASTERISK.  If the latter,
     *	we start at ArgList[2] to skip the ASTERISK.
     *
     *	Note that in the current spec, NET SEND * is a true broadcast
     *	(and thus comes into this function) only in DOS.
     */

    _sendmsg (	(is_switch ? 1 : 2),
		TO_ALL,
		NULL,
		TEXT("*"),
		1,
		0 );
}

#define MSGBUF 1024

VOID NEAR _sendmsg ( int firstarg, int dest, TCHAR FAR * v_dest,
    TCHAR FAR * t_list, DWORD t_num, DWORD t_size )
{
    DWORD    err;
    LPTSTR   message_buffer ;
    int      a_index, msglen, buflen = MSGBUF;
    DWORD    t_index;
    int      src;
    LPTSTR   tf_recipient;
    DWORD    last_err;
    DWORD    err_cnt = 0;
    LPTSTR   tmpptr;

    a_index = firstarg;

    if ( !(message_buffer = malloc(buflen*sizeof(TCHAR))) )
        ErrorExit(ERROR_NOT_ENOUGH_MEMORY) ;

    if (ArgList[a_index])
    {
	src = FROM_CMD_LINE;
        msglen = 0 ;

	/* 
         * copy msg text into buf.
         * msglen is length currently in buffer, not including null terminator
         * needed is length of next arg, not including null terminator
         */
	*message_buffer = NULLC;
	do
	{
            int needed = _tcslen(ArgList[a_index]) ;

            if ((msglen+needed) > (int)(buflen-2))  // 2 not 1 because " " is appended
	    {
                LPWSTR lpTemp;

                //
                // Reallocate the buffer as needed.  Add extra in hopes
                // that we won't need to reallocate again as a result.
                //

                buflen = (msglen + needed) * 2;

                lpTemp = realloc(message_buffer, buflen * sizeof(WCHAR));

                if (!lpTemp)
                {
                    ErrorExit(ERROR_NOT_ENOUGH_MEMORY);
                }

                message_buffer = lpTemp;
            }

            _tcscat(message_buffer, ArgList[a_index]);
	    msglen += needed+1 ;
	    _tcscat(message_buffer, TEXT(" "));

	} while(ArgList[++a_index]);

	/* delete trailing TEXT(" ") */
	message_buffer[_tcslen(message_buffer) - 1] = NULLC;
    }
    else
    {
        free(message_buffer) ;
        ErrorExit(APE_SendFileNotSupported);
    }

    /* send 'da msg */

    for (t_index = 0; t_index < t_num; t_index++)
    {
	switch(dest)
	{
	    case TO_NAME:
	    case TO_DOMAIN:
	    case TO_ALL:
		tf_recipient = (TCHAR FAR *) t_list;
		break;

	    case TO_USERS:
		tf_recipient = *((TCHAR FAR * FAR *)t_list);
		break;
	}

	err = 0;
	if( (err = LUI_CanonMessageDest( tf_recipient )) == 0 )
	{
            err = NetMessageBufferSend(NULL,
                                       tf_recipient,
                                       NULL,
                                       (LPBYTE) message_buffer,
                                       _tcslen(message_buffer)*sizeof(TCHAR));
	}

	if (err)
	{
	    last_err = err;
	    err_cnt++;
	    InfoPrintInsTxt(APE_SendErrSending, tf_recipient);
	}

        // must cast t_list since t_size is the size in bytes, but t_list
        // is a TCHAR *.
	(BYTE *) t_list += t_size;
    }

    free(message_buffer) ;
    message_buffer = NULL ;

    /* Bye, bye */

    if (err_cnt == t_num && err_cnt > 0)
    {
	ErrorExit(last_err);
    }
    else if (err_cnt)
    {
	InfoPrint(APE_CmdComplWErrors);
	NetcmdExit(1);
    }

    IStrings[0] = v_dest;

    switch(dest)
    {
	case TO_NAME:
	    InfoPrintIns(APE_SendSuccess, 1);
	    break;

	case TO_USERS:
	    InfoPrint(APE_SendUsersSuccess);
	    break;

	case TO_DOMAIN:
	    /*
	     * Strip off the trailing ASTERISK.
	     */
	    tmpptr = _tcschr( IStrings[0], ASTERISK );
	    if (tmpptr != NULL)
		*tmpptr = NULLC;
	    InfoPrintIns(APE_SendDomainSuccess, 1);
	    break;

	case TO_ALL:
	    InfoPrint(APE_SendAllSuccess);
	    break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\nettext.h ===
extern TCHAR * NULL_STRING;
extern TCHAR * DOT_STRING;
extern TCHAR * txt_SERVICE_MSG_SRV;
extern TCHAR * txt_SERVICE_REDIR;
extern TCHAR * txt_SERVICE_FILE_SRV;
extern TCHAR * txt_SERVICE_ALERTER;
extern TCHAR * txt_SERVICE_NETLOGON;
extern TCHAR * txt_SERVICE_REPL;
extern TCHAR * txt_LIST_DELIMITER_STR_UI;
extern TCHAR * ADMIN_DOLLAR;
extern TCHAR * IPC_DOLLAR;
extern TCHAR USER_MAXSTOR_UNLIMITED[];
extern TCHAR * fmtPSZ;
extern TCHAR * fmtNPSZ;
extern TCHAR * fmtUSHORT;
extern TCHAR * fmtULONG;
extern TCHAR USER_NEVER[];
extern TCHAR USE_USER[];
extern TCHAR USER_ALL[];
extern TCHAR WKSTA_ALL[];
extern TCHAR SERVER_ANY[];
extern TCHAR USER_HOURS_NONE[];
extern TCHAR * MSG_HYPHENS;
extern TCHAR swtxt_SW_YES[];
extern TCHAR swtxt_SW_NO[];
extern TCHAR swtxt_SW_HELP[];
extern TCHAR swtxt_SW_SYNTAX[];
extern TCHAR swtxt_SW_ADD[];
extern TCHAR swtxt_SW_DELETE[];
extern TCHAR swtxt_SW_REMARK[];
extern TCHAR swtxt_SW_COMMENT[];
extern TCHAR swtxt_SW_OPTIONS[];
extern TCHAR swtxt_SW_PRIORITY[];
extern TCHAR swtxt_SW_ROUTE[];
extern TCHAR swtxt_SW_DOMAIN[];
extern TCHAR swtxt_SW_NETWARE[];
extern TCHAR swtxt_SW_RANDOM[];
extern TCHAR swtxt_SW_RTSDOMAIN[];
extern TCHAR swtxt_SW_SETSNTP[];
extern TCHAR swtxt_SW_QUERYSNTP[];
extern TCHAR swtxt_SW_ALERTER_SIZALERTBUF[];
extern TCHAR swtxt_SW_NETLOGON_CENTRALIZED[];
extern TCHAR swtxt_SW_NETLOGON_PULSE[];
extern TCHAR swtxt_SW_NETLOGON_RANDOMIZE[];
extern TCHAR swtxt_SW_NETLOGON_SYNCHRONIZE[];
extern TCHAR swtxt_SW_NETLOGON_SCRIPTS[];
extern TCHAR swtxt_SW_UPS_BATTERYTIME[];
extern TCHAR swtxt_SW_UPS_CMDFILE[];
extern TCHAR swtxt_SW_UPS_DEVICENAME[];
extern TCHAR swtxt_SW_UPS_MESSDELAY[];
extern TCHAR swtxt_SW_UPS_MESSTIME[];
extern TCHAR swtxt_SW_UPS_RECHARGE[];
extern TCHAR swtxt_SW_UPS_SIGNALS[];
extern TCHAR swtxt_SW_UPS_VOLTLEVELS[];
extern TCHAR swtxt_SW_WKSTA_CHARCOUNT[];
extern TCHAR swtxt_SW_WKSTA_CHARTIME[];
extern TCHAR swtxt_SW_WKSTA_CHARWAIT[];
extern TCHAR swtxt_SW_WKSTA_COMPUTERNAME[];
extern TCHAR swtxt_SW_WKSTA_KEEPCONN[];
extern TCHAR swtxt_SW_WKSTA_KEEPSEARCH[];
extern TCHAR swtxt_SW_WKSTA_LOGONSERVER[];
extern TCHAR swtxt_SW_WKSTA_MAILSLOTS[];
extern TCHAR swtxt_SW_WKSTA_NUMCHARBUF[];
extern TCHAR swtxt_SW_WKSTA_NUMDGRAMBUF[];
extern TCHAR swtxt_SW_WKSTA_NUMSERVICES[];
extern TCHAR swtxt_SW_WKSTA_NUMWORKBUF[];
extern TCHAR swtxt_SW_WKSTA_SIZCHARBUF[];
extern TCHAR swtxt_SW_WKSTA_SIZERROR[];
extern TCHAR swtxt_SW_WKSTA_SIZWORKBUF[];
extern TCHAR swtxt_SW_WKSTA_WRKHEURISTICS[];
extern TCHAR swtxt_SW_WKSTA_WRKNETS[];
extern TCHAR swtxt_SW_WKSTA_WRKSERVICES[];
extern TCHAR swtxt_SW_WKSTA_PRIMARYDOMAIN[];
extern TCHAR swtxt_SW_WKSTA_OTHDOMAINS[];
extern TCHAR swtxt_SW_WKSTA_MAXERRORLOG[];
extern TCHAR swtxt_SW_WKSTA_MAXWRKCACHE[];
extern TCHAR swtxt_SW_WKSTA_NUMALERTS[];
extern TCHAR swtxt_SW_WKSTA_PRINTBUFTIME[];
extern TCHAR swtxt_SW_WKSTA_SESSTIMEOUT[];
extern TCHAR swtxt_SW_PRINT_HOLD[];
extern TCHAR swtxt_SW_PRINT_RELEASE[];
extern TCHAR swtxt_SW_PRINT_AFTER[];
extern TCHAR swtxt_SW_PRINT_FIRST[];
extern TCHAR swtxt_SW_PRINT_LAST[];
extern TCHAR swtxt_SW_PRINT_PARMS[];
extern TCHAR swtxt_SW_PRINT_PROCESSOR[];
extern TCHAR swtxt_SW_PRINT_PURGE[];
extern TCHAR swtxt_SW_PRINT_SEPARATOR[];
extern TCHAR swtxt_SW_PRINT_UNTIL[];
extern TCHAR swtxt_SW_PRINT_DRIVER[];
extern TCHAR swtxt_SW_SHARE_COMM[];
extern TCHAR swtxt_SW_SHARE_PRINT[];
extern TCHAR swtxt_SW_SHARE_UNLIMITED[];
extern TCHAR swtxt_SW_SHARE_USERS[];
extern TCHAR swtxt_SW_CACHE[];
extern TCHAR swtxt_SW_USE_COMM[];
extern TCHAR swtxt_SW_USE_USER[];
extern TCHAR swtxt_SW_USE_SMARTCARD[];
extern TCHAR swtxt_SW_USE_SAVECRED[];
extern TCHAR swtxt_SW_USE_HOME[];
extern TCHAR swtxt_SW_USE_PERSISTENT[];
extern TCHAR swtxt_SW_USER_ACTIVE[];
extern TCHAR swtxt_SW_USER_COUNTRYCODE[];
extern TCHAR swtxt_SW_USER_EXPIRES[];
extern TCHAR swtxt_SW_USER_ENABLESCRIPT[];
extern TCHAR swtxt_SW_USER_FULLNAME[];
extern TCHAR swtxt_SW_USER_HOMEDIR[];
extern TCHAR swtxt_SW_USER_PARMS[];
extern TCHAR swtxt_SW_USER_PASSWORDREQ[];
extern TCHAR swtxt_SW_USER_PASSWORDCHG[];
extern TCHAR swtxt_SW_USER_SCRIPTPATH[];
extern TCHAR swtxt_SW_USER_TIMES[];
extern TCHAR swtxt_SW_USER_USERCOMMENT[];
extern TCHAR swtxt_SW_USER_WORKSTATIONS[];
extern TCHAR swtxt_SW_USER_PROFILEPATH[];
extern TCHAR swtxt_SW_SRV_SRVCOMMENT[];
extern TCHAR swtxt_SW_SRV_AUTODISCONNECT[];
extern TCHAR swtxt_SW_SRV_MAXUSERS[];
extern TCHAR swtxt_SW_SRV_SRVANNOUNCE[];
extern TCHAR swtxt_SW_SRV_SRVANNDELTA[];
extern TCHAR swtxt_SW_SRV_MAXSESSOPENS[];
extern TCHAR swtxt_SW_SRV_NUMREQBUF[];
extern TCHAR swtxt_SW_SRV_SIZREQBUF[];
extern TCHAR swtxt_SW_SRV_NUMBIGBUF[];
extern TCHAR swtxt_SW_SRV_SRVHIDDEN[];
extern TCHAR swtxt_SW_SRV_DEBUG[];
extern TCHAR swtxt_SW_STATS_CLEAR[];
extern TCHAR swtxt_SW_ADMIN_COMMAND[];
extern TCHAR swtxt_SW_MESSAGE_BROADCAST[];
extern TCHAR swtxt_SW_ACCOUNTS_FORCELOGOFF[];
extern TCHAR swtxt_SW_ACCOUNTS_UNIQUEPW[];
extern TCHAR swtxt_SW_ACCOUNTS_MINPWLEN[];
extern TCHAR swtxt_SW_ACCOUNTS_MINPWAGE[];
extern TCHAR swtxt_SW_ACCOUNTS_MAXPWAGE[];
extern TCHAR swtxt_SW_ACCOUNTS_ROLE[];
extern TCHAR swtxt_SW_ACCOUNTS_PRIMARY[];
extern TCHAR swtxt_SW_ACCOUNTS_LOCKOUT[];
extern TCHAR swtxt_SW_ACCOUNTS_SYNCH[];
extern TCHAR swtxt_SW_ACCOUNTS_LOCKOUT_THRESHOLD[];
extern TCHAR swtxt_SW_ACCOUNTS_LOCKOUT_DURATION[];
extern TCHAR swtxt_SW_ACCOUNTS_LOCKOUT_WINDOW[];
extern TCHAR swtxt_SW_REPL_REPL[];
extern TCHAR swtxt_SW_REPL_EXPPATH[];
extern TCHAR swtxt_SW_REPL_IMPPATH[];
extern TCHAR swtxt_SW_REPL_EXPLIST[];
extern TCHAR swtxt_SW_REPL_IMPLIST[];
extern TCHAR swtxt_SW_REPL_TRYUSER[];
extern TCHAR swtxt_SW_REPL_LOGON[];
extern TCHAR swtxt_SW_REPL_PASSWD[];
extern TCHAR swtxt_SW_REPL_SYNCH[];
extern TCHAR swtxt_SW_REPL_PULSE[];
extern TCHAR swtxt_SW_REPL_GUARD[];
extern TCHAR swtxt_SW_REPL_RANDOM[];
extern TCHAR swtxt_SW_TIME_SET[];
extern TCHAR swtxt_SW_COMPUTER_JOIN[];
extern TCHAR swtxt_SW_COMPUTER_LEAVE[];
extern TCHAR swtxt_SW_NETWORK[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\net.c ===
#include	"interpre.h"

#define INCL_NOCOMMON
#include <os2.h>

#define ACCOUNTS 600
#define COMPUTER 601
#define CONFIG 602
#define CONTINUE 603
#define FILE_token 604
#define GROUP 605
#define HELP 606
#define HELPMSG 607
#define NAME 608
#define LOCALGROUP 609
#define PAUSE 610
#define PRINT 611
#define SEND 612
#define SESSION 613
#define SHARE 614
#define START 615
#define STATS 616
#define STOP 617
#define TIME 618
#define USER 619
#define MSG 620
#define NETPOPUP 621
#define REDIR 622
#define SVR 623
#define ALERTER 624
#define NETLOGON 625
#define EOS EOF

#include <stdio.h>
#include <lmcons.h>

#include "netcmds.h"
#include "nettext.h"
#include "swtchtbl.h"
#include "os2incl.h"
			
	char	*Rule_strings[] = {
		0
	};
	short	Index_strings[] = {
	0
	};

#define _net 0
#define _accounts 65
#define _computer 76
#define _config 102
#define _continue 118
#define _file 125
#define _group 144
#define _helpmsg 191
#define _help 198
#define _name 218
#define _localgroup 243
#define _pause 290
#define _print 297
#define _send 350
#define _session 372
#define _share 395
#define _start 436
#define _stats 453
#define _stop 468
#define _time 475
#define _user 534
#define _unknown 579
#define _no_command 599
#define _domainname 602
#define _computername 605
#define _computername_share 608
#define _device_name 611
#define _resource_name 614
#define _access_setting 617
#define _pathname 620
#define _pathnameOrUNC 623
#define _number 626
#define _jobno 629
#define _netname 632
#define _msgid 635
#define _username 638
#define _qualified_username 641
#define _msgname 644
#define _pass 647
#define _servicename 650
#define _assignment 652
#define _anyassign 655
#define _admin_shares 658
#define _print_dest 661
#define _localgroupname 664
#define _groupname 667
	TCHAR	XXtype[] = {
/*  0  */	X_OR,	/*  3  */
/*  1  */	X_PROC,	/*  _no_command  */
/*  2  */	X_ACCEPT,	/*  190  */
/*  3  */	X_OR,	/*  6  */
/*  4  */	X_PROC,	/*  _accounts  */
/*  5  */	X_ACCEPT,	/*  191  */
/*  6  */	X_OR,	/*  9  */
/*  7  */	X_PROC,	/*  _config  */
/*  8  */	X_ACCEPT,	/*  192  */
/*  9  */	X_OR,	/*  12  */
/*  10  */	X_PROC,	/*  _computer  */
/*  11  */	X_ACCEPT,	/*  193  */
/*  12  */	X_OR,	/*  15  */
/*  13  */	X_PROC,	/*  _continue  */
/*  14  */	X_ACCEPT,	/*  194  */
/*  15  */	X_OR,	/*  18  */
/*  16  */	X_PROC,	/*  _file  */
/*  17  */	X_ACCEPT,	/*  195  */
/*  18  */	X_OR,	/*  21  */
/*  19  */	X_PROC,	/*  _group  */
/*  20  */	X_ACCEPT,	/*  196  */
/*  21  */	X_OR,	/*  24  */
/*  22  */	X_PROC,	/*  _help  */
/*  23  */	X_ACCEPT,	/*  197  */
/*  24  */	X_OR,	/*  27  */
/*  25  */	X_PROC,	/*  _helpmsg  */
/*  26  */	X_ACCEPT,	/*  198  */
/*  27  */	X_OR,	/*  30  */
/*  28  */	X_PROC,	/*  _name  */
/*  29  */	X_ACCEPT,	/*  199  */
/*  30  */	X_OR,	/*  33  */
/*  31  */	X_PROC,	/*  _localgroup  */
/*  32  */	X_ACCEPT,	/*  200  */
/*  33  */	X_OR,	/*  36  */
/*  34  */	X_PROC,	/*  _pause  */
/*  35  */	X_ACCEPT,	/*  201  */
/*  36  */	X_OR,	/*  39  */
/*  37  */	X_PROC,	/*  _print  */
/*  38  */	X_ACCEPT,	/*  202  */
/*  39  */	X_OR,	/*  42  */
/*  40  */	X_PROC,	/*  _send  */
/*  41  */	X_ACCEPT,	/*  203  */
/*  42  */	X_OR,	/*  45  */
/*  43  */	X_PROC,	/*  _session  */
/*  44  */	X_ACCEPT,	/*  204  */
/*  45  */	X_OR,	/*  48  */
/*  46  */	X_PROC,	/*  _share  */
/*  47  */	X_ACCEPT,	/*  205  */
/*  48  */	X_OR,	/*  51  */
/*  49  */	X_PROC,	/*  _start  */
/*  50  */	X_ACCEPT,	/*  206  */
/*  51  */	X_OR,	/*  54  */
/*  52  */	X_PROC,	/*  _stats  */
/*  53  */	X_ACCEPT,	/*  207  */
/*  54  */	X_OR,	/*  57  */
/*  55  */	X_PROC,	/*  _stop  */
/*  56  */	X_ACCEPT,	/*  208  */
/*  57  */	X_OR,	/*  60  */
/*  58  */	X_PROC,	/*  _time  */
/*  59  */	X_ACCEPT,	/*  209  */
/*  60  */	X_OR,	/*  63  */
/*  61  */	X_PROC,	/*  _user  */
/*  62  */	X_ACCEPT,	/*  210  */
/*  63  */	X_PROC,	/*  _unknown  */
/*  64  */	X_ACCEPT,	/*  212  */
/*  65  */	X_TOKEN,	/*  (short)ACCOUNTS  */
/*  66  */	X_CONDIT,	/*  0  */
/*  67  */	X_TOKEN,	/*  (short)EOS  */
/*  68  */	X_OR,	/*  72  */
/*  69  */	X_CONDIT,	/*  1  */
/*  70  */	X_ACTION,	/*  0  */
/*  71  */	X_ACCEPT,	/*  398  */
/*  72  */	X_ACTION,	/*  1  */
/*  73  */	X_ACCEPT,	/*  400  */
/*  74  */	X_ACCEPT,	/*  401  */
/*  75  */	X_ACCEPT,	/*  401  */
/*  76  */	X_TOKEN,	/*  (short)COMPUTER  */
/*  77  */	X_CONDIT,	/*  2  */
/*  78  */	X_OR,	/*  90  */
/*  79  */	X_PROC,	/*  _computername  */
/*  80  */	X_TOKEN,	/*  (short)EOS  */
/*  81  */	X_SWITCH,	/*  0  */
/*  82  */	X_OR,	/*  86  */
/*  83  */	X_CONDIT,	/*  3  */
/*  84  */	X_ACTION,	/*  2  */
/*  85  */	X_ACCEPT,	/*  553  */
/*  86  */	X_ACTION,	/*  3  */
/*  87  */	X_ACCEPT,	/*  555  */
/*  88  */	X_ACCEPT,	/*  556  */
/*  89  */	X_ACCEPT,	/*  557  */
/*  90  */	X_PROC,	/*  _computername  */
/*  91  */	X_TOKEN,	/*  (short)EOS  */
/*  92  */	X_SWITCH,	/*  1  */
/*  93  */	X_OR,	/*  97  */
/*  94  */	X_CONDIT,	/*  4  */
/*  95  */	X_ACTION,	/*  4  */
/*  96  */	X_ACCEPT,	/*  564  */
/*  97  */	X_ACTION,	/*  5  */
/*  98  */	X_ACCEPT,	/*  566  */
/*  99  */	X_ACCEPT,	/*  567  */
/*  100  */	X_ACCEPT,	/*  568  */
/*  101  */	X_ACCEPT,	/*  568  */
/*  102  */	X_TOKEN,	/*  (short)CONFIG  */
/*  103  */	X_OR,	/*  108  */
/*  104  */	X_TOKEN,	/*  (short)EOS  */
/*  105  */	X_CONDIT,	/*  5  */
/*  106  */	X_ACTION,	/*  6  */
/*  107  */	X_ACCEPT,	/*  576  */
/*  108  */	X_PROC,	/*  _servicename  */
/*  109  */	X_TOKEN,	/*  (short)EOS  */
/*  110  */	X_OR,	/*  114  */
/*  111  */	X_CONDIT,	/*  6  */
/*  112  */	X_ACTION,	/*  7  */
/*  113  */	X_ACCEPT,	/*  581  */
/*  114  */	X_ACTION,	/*  8  */
/*  115  */	X_ACCEPT,	/*  583  */
/*  116  */	X_ACCEPT,	/*  584  */
/*  117  */	X_ACCEPT,	/*  584  */
/*  118  */	X_TOKEN,	/*  (short)CONTINUE  */
/*  119  */	X_CONDIT,	/*  7  */
/*  120  */	X_PROC,	/*  _servicename  */
/*  121  */	X_TOKEN,	/*  (short)EOS  */
/*  122  */	X_ACTION,	/*  9  */
/*  123  */	X_ACCEPT,	/*  590  */
/*  124  */	X_ACCEPT,	/*  590  */
/*  125  */	X_TOKEN,	/*  (short)FILE_token  */
/*  126  */	X_CONDIT,	/*  8  */
/*  127  */	X_OR,	/*  133  */
/*  128  */	X_TOKEN,	/*  (short)EOS  */
/*  129  */	X_CONDIT,	/*  9  */
/*  130  */	X_ACTION,	/*  10  */
/*  131  */	X_ACCEPT,	/*  662  */
/*  132  */	X_ACCEPT,	/*  663  */
/*  133  */	X_PROC,	/*  _number  */
/*  134  */	X_TOKEN,	/*  (short)EOS  */
/*  135  */	X_OR,	/*  139  */
/*  136  */	X_CONDIT,	/*  10  */
/*  137  */	X_ACTION,	/*  11  */
/*  138  */	X_ACCEPT,	/*  668  */
/*  139  */	X_SWITCH,	/*  2  */
/*  140  */	X_ACTION,	/*  12  */
/*  141  */	X_ACCEPT,	/*  671  */
/*  142  */	X_ACCEPT,	/*  672  */
/*  143  */	X_ACCEPT,	/*  672  */
/*  144  */	X_TOKEN,	/*  (short)GROUP  */
/*  145  */	X_CONDIT,	/*  11  */
/*  146  */	X_OR,	/*  151  */
/*  147  */	X_TOKEN,	/*  (short)EOS  */
/*  148  */	X_CONDIT,	/*  12  */
/*  149  */	X_ACTION,	/*  13  */
/*  150  */	X_ACCEPT,	/*  678  */
/*  151  */	X_OR,	/*  178  */
/*  152  */	X_PROC,	/*  _groupname  */
/*  153  */	X_TOKEN,	/*  (short)EOS  */
/*  154  */	X_OR,	/*  158  */
/*  155  */	X_CONDIT,	/*  13  */
/*  156  */	X_ACTION,	/*  14  */
/*  157  */	X_ACCEPT,	/*  683  */
/*  158  */	X_OR,	/*  167  */
/*  159  */	X_SWITCH,	/*  1  */
/*  160  */	X_OR,	/*  164  */
/*  161  */	X_CONDIT,	/*  14  */
/*  162  */	X_ACTION,	/*  15  */
/*  163  */	X_ACCEPT,	/*  688  */
/*  164  */	X_ACTION,	/*  16  */
/*  165  */	X_ACCEPT,	/*  690  */
/*  166  */	X_ACCEPT,	/*  691  */
/*  167  */	X_OR,	/*  172  */
/*  168  */	X_SWITCH,	/*  0  */
/*  169  */	X_ACTION,	/*  17  */
/*  170  */	X_ACCEPT,	/*  695  */
/*  171  */	X_ACCEPT,	/*  696  */
/*  172  */	X_SWITCH,	/*  3  */
/*  173  */	X_CONDIT,	/*  15  */
/*  174  */	X_ACTION,	/*  18  */
/*  175  */	X_ACCEPT,	/*  701  */
/*  176  */	X_ACCEPT,	/*  702  */
/*  177  */	X_ACCEPT,	/*  703  */
/*  178  */	X_PROC,	/*  _groupname  */
/*  179  */	X_PROC,	/*  _username  */
/*  180  */	X_CONDIT,	/*  16  */
/*  181  */	X_OR,	/*  185  */
/*  182  */	X_SWITCH,	/*  0  */
/*  183  */	X_ACTION,	/*  19  */
/*  184  */	X_ACCEPT,	/*  710  */
/*  185  */	X_SWITCH,	/*  1  */
/*  186  */	X_ACTION,	/*  20  */
/*  187  */	X_ACCEPT,	/*  713  */
/*  188  */	X_ACCEPT,	/*  714  */
/*  189  */	X_ACCEPT,	/*  715  */
/*  190  */	X_ACCEPT,	/*  715  */
/*  191  */	X_TOKEN,	/*  (short)HELPMSG  */
/*  192  */	X_CONDIT,	/*  17  */
/*  193  */	X_PROC,	/*  _msgid  */
/*  194  */	X_TOKEN,	/*  (short)EOS  */
/*  195  */	X_ACTION,	/*  21  */
/*  196  */	X_ACCEPT,	/*  721  */
/*  197  */	X_ACCEPT,	/*  721  */
/*  198  */	X_TOKEN,	/*  (short)HELP  */
/*  199  */	X_CONDIT,	/*  18  */
/*  200  */	X_OR,	/*  209  */
/*  201  */	X_TOKEN,	/*  (short)EOS  */
/*  202  */	X_OR,	/*  206  */
/*  203  */	X_CONDIT,	/*  19  */
/*  204  */	X_ACTION,	/*  22  */
/*  205  */	X_ACCEPT,	/*  729  */
/*  206  */	X_ACTION,	/*  23  */
/*  207  */	X_ACCEPT,	/*  731  */
/*  208  */	X_ACCEPT,	/*  732  */
/*  209  */	X_ANY,	/*  0  */
/*  210  */	X_OR,	/*  214  */
/*  211  */	X_CONDIT,	/*  20  */
/*  212  */	X_ACTION,	/*  24  */
/*  213  */	X_ACCEPT,	/*  737  */
/*  214  */	X_ACTION,	/*  25  */
/*  215  */	X_ACCEPT,	/*  739  */
/*  216  */	X_ACCEPT,	/*  740  */
/*  217  */	X_ACCEPT,	/*  740  */
/*  218  */	X_TOKEN,	/*  (short)NAME  */
/*  219  */	X_CONDIT,	/*  21  */
/*  220  */	X_OR,	/*  226  */
/*  221  */	X_TOKEN,	/*  (short)EOS  */
/*  222  */	X_CONDIT,	/*  22  */
/*  223  */	X_ACTION,	/*  26  */
/*  224  */	X_ACCEPT,	/*  748  */
/*  225  */	X_ACCEPT,	/*  749  */
/*  226  */	X_PROC,	/*  _msgname  */
/*  227  */	X_TOKEN,	/*  (short)EOS  */
/*  228  */	X_OR,	/*  232  */
/*  229  */	X_CONDIT,	/*  23  */
/*  230  */	X_ACTION,	/*  27  */
/*  231  */	X_ACCEPT,	/*  754  */
/*  232  */	X_CONDIT,	/*  24  */
/*  233  */	X_OR,	/*  237  */
/*  234  */	X_SWITCH,	/*  0  */
/*  235  */	X_ACTION,	/*  28  */
/*  236  */	X_ACCEPT,	/*  759  */
/*  237  */	X_SWITCH,	/*  1  */
/*  238  */	X_ACTION,	/*  29  */
/*  239  */	X_ACCEPT,	/*  762  */
/*  240  */	X_ACCEPT,	/*  763  */
/*  241  */	X_ACCEPT,	/*  764  */
/*  242  */	X_ACCEPT,	/*  764  */
/*  243  */	X_TOKEN,	/*  (short)LOCALGROUP  */
/*  244  */	X_CONDIT,	/*  25  */
/*  245  */	X_OR,	/*  250  */
/*  246  */	X_TOKEN,	/*  (short)EOS  */
/*  247  */	X_CONDIT,	/*  26  */
/*  248  */	X_ACTION,	/*  30  */
/*  249  */	X_ACCEPT,	/*  770  */
/*  250  */	X_OR,	/*  277  */
/*  251  */	X_PROC,	/*  _localgroupname  */
/*  252  */	X_TOKEN,	/*  (short)EOS  */
/*  253  */	X_OR,	/*  257  */
/*  254  */	X_CONDIT,	/*  27  */
/*  255  */	X_ACTION,	/*  31  */
/*  256  */	X_ACCEPT,	/*  775  */
/*  257  */	X_OR,	/*  266  */
/*  258  */	X_SWITCH,	/*  1  */
/*  259  */	X_OR,	/*  263  */
/*  260  */	X_CONDIT,	/*  28  */
/*  261  */	X_ACTION,	/*  32  */
/*  262  */	X_ACCEPT,	/*  780  */
/*  263  */	X_ACTION,	/*  33  */
/*  264  */	X_ACCEPT,	/*  782  */
/*  265  */	X_ACCEPT,	/*  783  */
/*  266  */	X_OR,	/*  271  */
/*  267  */	X_SWITCH,	/*  0  */
/*  268  */	X_ACTION,	/*  34  */
/*  269  */	X_ACCEPT,	/*  787  */
/*  270  */	X_ACCEPT,	/*  788  */
/*  271  */	X_SWITCH,	/*  3  */
/*  272  */	X_CONDIT,	/*  29  */
/*  273  */	X_ACTION,	/*  35  */
/*  274  */	X_ACCEPT,	/*  793  */
/*  275  */	X_ACCEPT,	/*  794  */
/*  276  */	X_ACCEPT,	/*  795  */
/*  277  */	X_PROC,	/*  _localgroupname  */
/*  278  */	X_PROC,	/*  _qualified_username  */
/*  279  */	X_CONDIT,	/*  30  */
/*  280  */	X_OR,	/*  284  */
/*  281  */	X_SWITCH,	/*  0  */
/*  282  */	X_ACTION,	/*  36  */
/*  283  */	X_ACCEPT,	/*  802  */
/*  284  */	X_SWITCH,	/*  1  */
/*  285  */	X_ACTION,	/*  37  */
/*  286  */	X_ACCEPT,	/*  805  */
/*  287  */	X_ACCEPT,	/*  806  */
/*  288  */	X_ACCEPT,	/*  807  */
/*  289  */	X_ACCEPT,	/*  807  */
/*  290  */	X_TOKEN,	/*  (short)PAUSE  */
/*  291  */	X_CONDIT,	/*  31  */
/*  292  */	X_PROC,	/*  _servicename  */
/*  293  */	X_TOKEN,	/*  (short)EOS  */
/*  294  */	X_ACTION,	/*  38  */
/*  295  */	X_ACCEPT,	/*  839  */
/*  296  */	X_ACCEPT,	/*  839  */
/*  297  */	X_TOKEN,	/*  (short)PRINT  */
/*  298  */	X_CONDIT,	/*  32  */
/*  299  */	X_OR,	/*  320  */
/*  300  */	X_PROC,	/*  _jobno  */
/*  301  */	X_TOKEN,	/*  (short)EOS  */
/*  302  */	X_OR,	/*  306  */
/*  303  */	X_CONDIT,	/*  33  */
/*  304  */	X_ACTION,	/*  39  */
/*  305  */	X_ACCEPT,	/*  847  */
/*  306  */	X_CONDIT,	/*  34  */
/*  307  */	X_OR,	/*  311  */
/*  308  */	X_SWITCH,	/*  1  */
/*  309  */	X_ACTION,	/*  40  */
/*  310  */	X_ACCEPT,	/*  852  */
/*  311  */	X_OR,	/*  315  */
/*  312  */	X_SWITCH,	/*  4  */
/*  313  */	X_ACTION,	/*  41  */
/*  314  */	X_ACCEPT,	/*  855  */
/*  315  */	X_SWITCH,	/*  5  */
/*  316  */	X_ACTION,	/*  42  */
/*  317  */	X_ACCEPT,	/*  858  */
/*  318  */	X_ACCEPT,	/*  859  */
/*  319  */	X_ACCEPT,	/*  923  */
/*  320  */	X_OR,	/*  343  */
/*  321  */	X_PROC,	/*  _computername  */
/*  322  */	X_PROC,	/*  _jobno  */
/*  323  */	X_TOKEN,	/*  (short)EOS  */
/*  324  */	X_OR,	/*  328  */
/*  325  */	X_CONDIT,	/*  35  */
/*  326  */	X_ACTION,	/*  43  */
/*  327  */	X_ACCEPT,	/*  930  */
/*  328  */	X_CONDIT,	/*  36  */
/*  329  */	X_OR,	/*  333  */
/*  330  */	X_SWITCH,	/*  1  */
/*  331  */	X_ACTION,	/*  44  */
/*  332  */	X_ACCEPT,	/*  935  */
/*  333  */	X_OR,	/*  337  */
/*  334  */	X_SWITCH,	/*  4  */
/*  335  */	X_ACTION,	/*  45  */
/*  336  */	X_ACCEPT,	/*  938  */
/*  337  */	X_SWITCH,	/*  5  */
/*  338  */	X_ACTION,	/*  46  */
/*  339  */	X_ACCEPT,	/*  941  */
/*  340  */	X_ACCEPT,	/*  942  */
/*  341  */	X_ACCEPT,	/*  943  */
/*  342  */	X_ACCEPT,	/*  944  */
/*  343  */	X_PROC,	/*  _computername_share  */
/*  344  */	X_TOKEN,	/*  (short)EOS  */
/*  345  */	X_CONDIT,	/*  37  */
/*  346  */	X_ACTION,	/*  47  */
/*  347  */	X_ACCEPT,	/*  949  */
/*  348  */	X_ACCEPT,	/*  950  */
/*  349  */	X_ACCEPT,	/*  950  */
/*  350  */	X_TOKEN,	/*  (short)SEND  */
/*  351  */	X_CONDIT,	/*  38  */
/*  352  */	X_OR,	/*  357  */
/*  353  */	X_SWITCH,	/*  6  */
/*  354  */	X_CONDIT,	/*  39  */
/*  355  */	X_ACTION,	/*  48  */
/*  356  */	X_ACCEPT,	/*  956  */
/*  357  */	X_OR,	/*  362  */
/*  358  */	X_SWITCH,	/*  7  */
/*  359  */	X_CONDIT,	/*  40  */
/*  360  */	X_ACTION,	/*  49  */
/*  361  */	X_ACCEPT,	/*  959  */
/*  362  */	X_OR,	/*  367  */
/*  363  */	X_SWITCH,	/*  8  */
/*  364  */	X_CONDIT,	/*  41  */
/*  365  */	X_ACTION,	/*  50  */
/*  366  */	X_ACCEPT,	/*  962  */
/*  367  */	X_PROC,	/*  _msgname  */
/*  368  */	X_CONDIT,	/*  42  */
/*  369  */	X_ACTION,	/*  51  */
/*  370  */	X_ACCEPT,	/*  965  */
/*  371  */	X_ACCEPT,	/*  965  */
/*  372  */	X_TOKEN,	/*  (short)SESSION  */
/*  373  */	X_CONDIT,	/*  43  */
/*  374  */	X_OR,	/*  384  */
/*  375  */	X_TOKEN,	/*  (short)EOS  */
/*  376  */	X_OR,	/*  380  */
/*  377  */	X_CONDIT,	/*  44  */
/*  378  */	X_ACTION,	/*  52  */
/*  379  */	X_ACCEPT,	/*  1005  */
/*  380  */	X_SWITCH,	/*  1  */
/*  381  */	X_ACTION,	/*  53  */
/*  382  */	X_ACCEPT,	/*  1008  */
/*  383  */	X_ACCEPT,	/*  1009  */
/*  384  */	X_PROC,	/*  _computername  */
/*  385  */	X_TOKEN,	/*  (short)EOS  */
/*  386  */	X_OR,	/*  390  */
/*  387  */	X_CONDIT,	/*  45  */
/*  388  */	X_ACTION,	/*  54  */
/*  389  */	X_ACCEPT,	/*  1014  */
/*  390  */	X_SWITCH,	/*  1  */
/*  391  */	X_ACTION,	/*  55  */
/*  392  */	X_ACCEPT,	/*  1017  */
/*  393  */	X_ACCEPT,	/*  1018  */
/*  394  */	X_ACCEPT,	/*  1018  */
/*  395  */	X_TOKEN,	/*  (short)SHARE  */
/*  396  */	X_CONDIT,	/*  46  */
/*  397  */	X_OR,	/*  402  */
/*  398  */	X_TOKEN,	/*  (short)EOS  */
/*  399  */	X_CONDIT,	/*  47  */
/*  400  */	X_ACTION,	/*  56  */
/*  401  */	X_ACCEPT,	/*  1024  */
/*  402  */	X_OR,	/*  412  */
/*  403  */	X_ANY,	/*  0  */
/*  404  */	X_SWITCH,	/*  1  */
/*  405  */	X_OR,	/*  409  */
/*  406  */	X_CONDIT,	/*  48  */
/*  407  */	X_ACTION,	/*  57  */
/*  408  */	X_ACCEPT,	/*  1029  */
/*  409  */	X_ACTION,	/*  58  */
/*  410  */	X_ACCEPT,	/*  1031  */
/*  411  */	X_ACCEPT,	/*  1032  */
/*  412  */	X_OR,	/*  418  */
/*  413  */	X_PROC,	/*  _admin_shares  */
/*  414  */	X_TOKEN,	/*  (short)EOS  */
/*  415  */	X_ACTION,	/*  59  */
/*  416  */	X_ACCEPT,	/*  1042  */
/*  417  */	X_ACCEPT,	/*  1058  */
/*  418  */	X_OR,	/*  425  */
/*  419  */	X_PROC,	/*  _assignment  */
/*  420  */	X_TOKEN,	/*  (short)EOS  */
/*  421  */	X_ACTION,	/*  60  */
/*  422  */	X_ACCEPT,	/*  1064  */
/*  423  */	X_ACCEPT,	/*  1065  */
/*  424  */	X_ACCEPT,	/*  1066  */
/*  425  */	X_PROC,	/*  _netname  */
/*  426  */	X_OR,	/*  431  */
/*  427  */	X_TOKEN,	/*  (short)EOS  */
/*  428  */	X_CONDIT,	/*  49  */
/*  429  */	X_ACTION,	/*  61  */
/*  430  */	X_ACCEPT,	/*  1071  */
/*  431  */	X_TOKEN,	/*  (short)EOS  */
/*  432  */	X_ACTION,	/*  62  */
/*  433  */	X_ACCEPT,	/*  1074  */
/*  434  */	X_ACCEPT,	/*  1075  */
/*  435  */	X_ACCEPT,	/*  1075  */
/*  436  */	X_TOKEN,	/*  (short)START  */
/*  437  */	X_OR,	/*  442  */
/*  438  */	X_TOKEN,	/*  (short)EOS  */
/*  439  */	X_CONDIT,	/*  50  */
/*  440  */	X_ACTION,	/*  63  */
/*  441  */	X_ACCEPT,	/*  1081  */
/*  442  */	X_ANY,	/*  0  */
/*  443  */	X_OR,	/*  447  */
/*  444  */	X_TOKEN,	/*  (short)EOS  */
/*  445  */	X_ACTION,	/*  64  */
/*  446  */	X_ACCEPT,	/*  1086  */
/*  447  */	X_PROC,	/*  _msgname  */
/*  448  */	X_TOKEN,	/*  (short)EOS  */
/*  449  */	X_ACTION,	/*  65  */
/*  450  */	X_ACCEPT,	/*  1089  */
/*  451  */	X_ACCEPT,	/*  1090  */
/*  452  */	X_ACCEPT,	/*  1090  */
/*  453  */	X_TOKEN,	/*  (short)STATS  */
/*  454  */	X_CONDIT,	/*  51  */
/*  455  */	X_OR,	/*  461  */
/*  456  */	X_TOKEN,	/*  (short)EOS  */
/*  457  */	X_CONDIT,	/*  52  */
/*  458  */	X_ACTION,	/*  66  */
/*  459  */	X_ACCEPT,	/*  1098  */
/*  460  */	X_ACCEPT,	/*  1099  */
/*  461  */	X_PROC,	/*  _servicename  */
/*  462  */	X_TOKEN,	/*  (short)EOS  */
/*  463  */	X_CONDIT,	/*  53  */
/*  464  */	X_ACTION,	/*  67  */
/*  465  */	X_ACCEPT,	/*  1104  */
/*  466  */	X_ACCEPT,	/*  1105  */
/*  467  */	X_ACCEPT,	/*  1105  */
/*  468  */	X_TOKEN,	/*  (short)STOP  */
/*  469  */	X_CONDIT,	/*  54  */
/*  470  */	X_PROC,	/*  _servicename  */
/*  471  */	X_TOKEN,	/*  (short)EOS  */
/*  472  */	X_ACTION,	/*  68  */
/*  473  */	X_ACCEPT,	/*  1112  */
/*  474  */	X_ACCEPT,	/*  1112  */
/*  475  */	X_TOKEN,	/*  (short)TIME  */
/*  476  */	X_CONDIT,	/*  55  */
/*  477  */	X_OR,	/*  499  */
/*  478  */	X_PROC,	/*  _computername  */
/*  479  */	X_TOKEN,	/*  (short)EOS  */
/*  480  */	X_OR,	/*  486  */
/*  481  */	X_SWITCH,	/*  9  */
/*  482  */	X_CONDIT,	/*  56  */
/*  483  */	X_ACTION,	/*  69  */
/*  484  */	X_ACCEPT,	/*  1122  */
/*  485  */	X_ACCEPT,	/*  1123  */
/*  486  */	X_OR,	/*  490  */
/*  487  */	X_SWITCH,	/*  10  */
/*  488  */	X_ACTION,	/*  70  */
/*  489  */	X_ACCEPT,	/*  1126  */
/*  490  */	X_OR,	/*  494  */
/*  491  */	X_SWITCH,	/*  11  */
/*  492  */	X_ACTION,	/*  71  */
/*  493  */	X_ACCEPT,	/*  1129  */
/*  494  */	X_CONDIT,	/*  57  */
/*  495  */	X_ACTION,	/*  72  */
/*  496  */	X_ACCEPT,	/*  1133  */
/*  497  */	X_ACCEPT,	/*  1134  */
/*  498  */	X_ACCEPT,	/*  1135  */
/*  499  */	X_TOKEN,	/*  (short)EOS  */
/*  500  */	X_OR,	/*  505  */
/*  501  */	X_SWITCH,	/*  7  */
/*  502  */	X_SWITCH,	/*  9  */
/*  503  */	X_ACTION,	/*  73  */
/*  504  */	X_ACCEPT,	/*  1140  */
/*  505  */	X_OR,	/*  509  */
/*  506  */	X_SWITCH,	/*  7  */
/*  507  */	X_ACTION,	/*  74  */
/*  508  */	X_ACCEPT,	/*  1143  */
/*  509  */	X_OR,	/*  514  */
/*  510  */	X_SWITCH,	/*  12  */
/*  511  */	X_SWITCH,	/*  9  */
/*  512  */	X_ACTION,	/*  75  */
/*  513  */	X_ACCEPT,	/*  1146  */
/*  514  */	X_OR,	/*  518  */
/*  515  */	X_SWITCH,	/*  12  */
/*  516  */	X_ACTION,	/*  76  */
/*  517  */	X_ACCEPT,	/*  1149  */
/*  518  */	X_OR,	/*  522  */
/*  519  */	X_SWITCH,	/*  9  */
/*  520  */	X_ACTION,	/*  77  */
/*  521  */	X_ACCEPT,	/*  1152  */
/*  522  */	X_OR,	/*  526  */
/*  523  */	X_SWITCH,	/*  10  */
/*  524  */	X_ACTION,	/*  78  */
/*  525  */	X_ACCEPT,	/*  1155  */
/*  526  */	X_OR,	/*  530  */
/*  527  */	X_SWITCH,	/*  11  */
/*  528  */	X_ACTION,	/*  79  */
/*  529  */	X_ACCEPT,	/*  1158  */
/*  530  */	X_ACTION,	/*  80  */
/*  531  */	X_ACCEPT,	/*  1161  */
/*  532  */	X_ACCEPT,	/*  1162  */
/*  533  */	X_ACCEPT,	/*  1162  */
/*  534  */	X_TOKEN,	/*  (short)USER  */
/*  535  */	X_CONDIT,	/*  58  */
/*  536  */	X_OR,	/*  541  */
/*  537  */	X_TOKEN,	/*  (short)EOS  */
/*  538  */	X_CONDIT,	/*  59  */
/*  539  */	X_ACTION,	/*  81  */
/*  540  */	X_ACCEPT,	/*  1169  */
/*  541  */	X_OR,	/*  564  */
/*  542  */	X_PROC,	/*  _username  */
/*  543  */	X_TOKEN,	/*  (short)EOS  */
/*  544  */	X_OR,	/*  548  */
/*  545  */	X_CONDIT,	/*  60  */
/*  546  */	X_ACTION,	/*  82  */
/*  547  */	X_ACCEPT,	/*  1174  */
/*  548  */	X_OR,	/*  557  */
/*  549  */	X_SWITCH,	/*  1  */
/*  550  */	X_OR,	/*  554  */
/*  551  */	X_CONDIT,	/*  61  */
/*  552  */	X_ACTION,	/*  83  */
/*  553  */	X_ACCEPT,	/*  1179  */
/*  554  */	X_ACTION,	/*  84  */
/*  555  */	X_ACCEPT,	/*  1181  */
/*  556  */	X_ACCEPT,	/*  1182  */
/*  557  */	X_OR,	/*  561  */
/*  558  */	X_SWITCH,	/*  0  */
/*  559  */	X_ACTION,	/*  85  */
/*  560  */	X_ACCEPT,	/*  1185  */
/*  561  */	X_ACTION,	/*  86  */
/*  562  */	X_ACCEPT,	/*  1187  */
/*  563  */	X_ACCEPT,	/*  1188  */
/*  564  */	X_PROC,	/*  _username  */
/*  565  */	X_PROC,	/*  _pass  */
/*  566  */	X_TOKEN,	/*  (short)EOS  */
/*  567  */	X_OR,	/*  571  */
/*  568  */	X_SWITCH,	/*  1  */
/*  569  */	X_ACTION,	/*  87  */
/*  570  */	X_ACCEPT,	/*  1193  */
/*  571  */	X_OR,	/*  575  */
/*  572  */	X_SWITCH,	/*  0  */
/*  573  */	X_ACTION,	/*  88  */
/*  574  */	X_ACCEPT,	/*  1196  */
/*  575  */	X_ACTION,	/*  89  */
/*  576  */	X_ACCEPT,	/*  1198  */
/*  577  */	X_ACCEPT,	/*  1199  */
/*  578  */	X_ACCEPT,	/*  1199  */
/*  579  */	X_ANY,	/*  0  */
/*  580  */	X_OR,	/*  584  */
/*  581  */	X_SWITCH,	/*  13  */
/*  582  */	X_ACTION,	/*  90  */
/*  583  */	X_ACCEPT,	/*  1247  */
/*  584  */	X_OR,	/*  588  */
/*  585  */	X_SWITCH,	/*  14  */
/*  586  */	X_ACTION,	/*  91  */
/*  587  */	X_ACCEPT,	/*  1250  */
/*  588  */	X_OR,	/*  592  */
/*  589  */	X_SWITCH,	/*  15  */
/*  590  */	X_ACTION,	/*  92  */
/*  591  */	X_ACCEPT,	/*  1253  */
/*  592  */	X_OR,	/*  596  */
/*  593  */	X_SWITCH,	/*  16  */
/*  594  */	X_ACTION,	/*  93  */
/*  595  */	X_ACCEPT,	/*  1256  */
/*  596  */	X_ACTION,	/*  94  */
/*  597  */	X_ACCEPT,	/*  1258  */
/*  598  */	X_ACCEPT,	/*  1258  */
/*  599  */	X_TOKEN,	/*  (short)EOS  */
/*  600  */	X_ACTION,	/*  95  */
/*  601  */	X_ACCEPT,	/*  1262  */
/*  602  */	X_ANY,	/*  0  */
/*  603  */	X_CONDIT,	/*  62  */
/*  604  */	X_ACCEPT,	/*  1268  */
/*  605  */	X_ANY,	/*  0  */
/*  606  */	X_CONDIT,	/*  63  */
/*  607  */	X_ACCEPT,	/*  1270  */
/*  608  */	X_ANY,	/*  0  */
/*  609  */	X_CONDIT,	/*  64  */
/*  610  */	X_ACCEPT,	/*  1272  */
/*  611  */	X_ANY,	/*  0  */
/*  612  */	X_CONDIT,	/*  65  */
/*  613  */	X_ACCEPT,	/*  1274  */
/*  614  */	X_ANY,	/*  0  */
/*  615  */	X_CONDIT,	/*  66  */
/*  616  */	X_ACCEPT,	/*  1276  */
/*  617  */	X_ANY,	/*  0  */
/*  618  */	X_CONDIT,	/*  67  */
/*  619  */	X_ACCEPT,	/*  1278  */
/*  620  */	X_ANY,	/*  0  */
/*  621  */	X_CONDIT,	/*  68  */
/*  622  */	X_ACCEPT,	/*  1280  */
/*  623  */	X_ANY,	/*  0  */
/*  624  */	X_CONDIT,	/*  69  */
/*  625  */	X_ACCEPT,	/*  1282  */
/*  626  */	X_ANY,	/*  0  */
/*  627  */	X_CONDIT,	/*  70  */
/*  628  */	X_ACCEPT,	/*  1284  */
/*  629  */	X_ANY,	/*  0  */
/*  630  */	X_CONDIT,	/*  71  */
/*  631  */	X_ACCEPT,	/*  1286  */
/*  632  */	X_ANY,	/*  0  */
/*  633  */	X_CONDIT,	/*  72  */
/*  634  */	X_ACCEPT,	/*  1288  */
/*  635  */	X_ANY,	/*  0  */
/*  636  */	X_CONDIT,	/*  73  */
/*  637  */	X_ACCEPT,	/*  1290  */
/*  638  */	X_ANY,	/*  0  */
/*  639  */	X_CONDIT,	/*  74  */
/*  640  */	X_ACCEPT,	/*  1292  */
/*  641  */	X_ANY,	/*  0  */
/*  642  */	X_CONDIT,	/*  75  */
/*  643  */	X_ACCEPT,	/*  1294  */
/*  644  */	X_ANY,	/*  0  */
/*  645  */	X_CONDIT,	/*  76  */
/*  646  */	X_ACCEPT,	/*  1296  */
/*  647  */	X_ANY,	/*  0  */
/*  648  */	X_CONDIT,	/*  77  */
/*  649  */	X_ACCEPT,	/*  1298  */
/*  650  */	X_ANY,	/*  0  */
/*  651  */	X_ACCEPT,	/*  1300  */
/*  652  */	X_ANY,	/*  0  */
/*  653  */	X_CONDIT,	/*  78  */
/*  654  */	X_ACCEPT,	/*  1302  */
/*  655  */	X_ANY,	/*  0  */
/*  656  */	X_CONDIT,	/*  79  */
/*  657  */	X_ACCEPT,	/*  1304  */
/*  658  */	X_ANY,	/*  0  */
/*  659  */	X_CONDIT,	/*  80  */
/*  660  */	X_ACCEPT,	/*  1306  */
/*  661  */	X_ANY,	/*  0  */
/*  662  */	X_CONDIT,	/*  81  */
/*  663  */	X_ACCEPT,	/*  1308  */
/*  664  */	X_ANY,	/*  0  */
/*  665  */	X_CONDIT,	/*  82  */
/*  666  */	X_ACCEPT,	/*  1310  */
/*  667  */	X_ANY,	/*  0  */
/*  668  */	X_CONDIT,	/*  83  */
/*  669  */	X_ACCEPT,	/*  1312  */
	};
	short	XXvalues[] = {
/*  0  */	3,
/*  1  */	_no_command,
/*  2  */	190,
/*  3  */	6,
/*  4  */	_accounts,
/*  5  */	191,
/*  6  */	9,
/*  7  */	_config,
/*  8  */	192,
/*  9  */	12,
/*  10  */	_computer,
/*  11  */	193,
/*  12  */	15,
/*  13  */	_continue,
/*  14  */	194,
/*  15  */	18,
/*  16  */	_file,
/*  17  */	195,
/*  18  */	21,
/*  19  */	_group,
/*  20  */	196,
/*  21  */	24,
/*  22  */	_help,
/*  23  */	197,
/*  24  */	27,
/*  25  */	_helpmsg,
/*  26  */	198,
/*  27  */	30,
/*  28  */	_name,
/*  29  */	199,
/*  30  */	33,
/*  31  */	_localgroup,
/*  32  */	200,
/*  33  */	36,
/*  34  */	_pause,
/*  35  */	201,
/*  36  */	39,
/*  37  */	_print,
/*  38  */	202,
/*  39  */	42,
/*  40  */	_send,
/*  41  */	203,
/*  42  */	45,
/*  43  */	_session,
/*  44  */	204,
/*  45  */	48,
/*  46  */	_share,
/*  47  */	205,
/*  48  */	51,
/*  49  */	_start,
/*  50  */	206,
/*  51  */	54,
/*  52  */	_stats,
/*  53  */	207,
/*  54  */	57,
/*  55  */	_stop,
/*  56  */	208,
/*  57  */	60,
/*  58  */	_time,
/*  59  */	209,
/*  60  */	63,
/*  61  */	_user,
/*  62  */	210,
/*  63  */	_unknown,
/*  64  */	212,
/*  65  */	(short)ACCOUNTS,
/*  66  */	0,
/*  67  */	(short)EOS,
/*  68  */	72,
/*  69  */	1,
/*  70  */	0,
/*  71  */	398,
/*  72  */	1,
/*  73  */	400,
/*  74  */	401,
/*  75  */	401,
/*  76  */	(short)COMPUTER,
/*  77  */	2,
/*  78  */	90,
/*  79  */	_computername,
/*  80  */	(short)EOS,
/*  81  */	0,
/*  82  */	86,
/*  83  */	3,
/*  84  */	2,
/*  85  */	553,
/*  86  */	3,
/*  87  */	555,
/*  88  */	556,
/*  89  */	557,
/*  90  */	_computername,
/*  91  */	(short)EOS,
/*  92  */	1,
/*  93  */	97,
/*  94  */	4,
/*  95  */	4,
/*  96  */	564,
/*  97  */	5,
/*  98  */	566,
/*  99  */	567,
/*  100  */	568,
/*  101  */	568,
/*  102  */	(short)CONFIG,
/*  103  */	108,
/*  104  */	(short)EOS,
/*  105  */	5,
/*  106  */	6,
/*  107  */	576,
/*  108  */	_servicename,
/*  109  */	(short)EOS,
/*  110  */	114,
/*  111  */	6,
/*  112  */	7,
/*  113  */	581,
/*  114  */	8,
/*  115  */	583,
/*  116  */	584,
/*  117  */	584,
/*  118  */	(short)CONTINUE,
/*  119  */	7,
/*  120  */	_servicename,
/*  121  */	(short)EOS,
/*  122  */	9,
/*  123  */	590,
/*  124  */	590,
/*  125  */	(short)FILE_token,
/*  126  */	8,
/*  127  */	133,
/*  128  */	(short)EOS,
/*  129  */	9,
/*  130  */	10,
/*  131  */	662,
/*  132  */	663,
/*  133  */	_number,
/*  134  */	(short)EOS,
/*  135  */	139,
/*  136  */	10,
/*  137  */	11,
/*  138  */	668,
/*  139  */	2,
/*  140  */	12,
/*  141  */	671,
/*  142  */	672,
/*  143  */	672,
/*  144  */	(short)GROUP,
/*  145  */	11,
/*  146  */	151,
/*  147  */	(short)EOS,
/*  148  */	12,
/*  149  */	13,
/*  150  */	678,
/*  151  */	178,
/*  152  */	_groupname,
/*  153  */	(short)EOS,
/*  154  */	158,
/*  155  */	13,
/*  156  */	14,
/*  157  */	683,
/*  158  */	167,
/*  159  */	1,
/*  160  */	164,
/*  161  */	14,
/*  162  */	15,
/*  163  */	688,
/*  164  */	16,
/*  165  */	690,
/*  166  */	691,
/*  167  */	172,
/*  168  */	0,
/*  169  */	17,
/*  170  */	695,
/*  171  */	696,
/*  172  */	3,
/*  173  */	15,
/*  174  */	18,
/*  175  */	701,
/*  176  */	702,
/*  177  */	703,
/*  178  */	_groupname,
/*  179  */	_username,
/*  180  */	16,
/*  181  */	185,
/*  182  */	0,
/*  183  */	19,
/*  184  */	710,
/*  185  */	1,
/*  186  */	20,
/*  187  */	713,
/*  188  */	714,
/*  189  */	715,
/*  190  */	715,
/*  191  */	(short)HELPMSG,
/*  192  */	17,
/*  193  */	_msgid,
/*  194  */	(short)EOS,
/*  195  */	21,
/*  196  */	721,
/*  197  */	721,
/*  198  */	(short)HELP,
/*  199  */	18,
/*  200  */	209,
/*  201  */	(short)EOS,
/*  202  */	206,
/*  203  */	19,
/*  204  */	22,
/*  205  */	729,
/*  206  */	23,
/*  207  */	731,
/*  208  */	732,
/*  209  */	0,
/*  210  */	214,
/*  211  */	20,
/*  212  */	24,
/*  213  */	737,
/*  214  */	25,
/*  215  */	739,
/*  216  */	740,
/*  217  */	740,
/*  218  */	(short)NAME,
/*  219  */	21,
/*  220  */	226,
/*  221  */	(short)EOS,
/*  222  */	22,
/*  223  */	26,
/*  224  */	748,
/*  225  */	749,
/*  226  */	_msgname,
/*  227  */	(short)EOS,
/*  228  */	232,
/*  229  */	23,
/*  230  */	27,
/*  231  */	754,
/*  232  */	24,
/*  233  */	237,
/*  234  */	0,
/*  235  */	28,
/*  236  */	759,
/*  237  */	1,
/*  238  */	29,
/*  239  */	762,
/*  240  */	763,
/*  241  */	764,
/*  242  */	764,
/*  243  */	(short)LOCALGROUP,
/*  244  */	25,
/*  245  */	250,
/*  246  */	(short)EOS,
/*  247  */	26,
/*  248  */	30,
/*  249  */	770,
/*  250  */	277,
/*  251  */	_localgroupname,
/*  252  */	(short)EOS,
/*  253  */	257,
/*  254  */	27,
/*  255  */	31,
/*  256  */	775,
/*  257  */	266,
/*  258  */	1,
/*  259  */	263,
/*  260  */	28,
/*  261  */	32,
/*  262  */	780,
/*  263  */	33,
/*  264  */	782,
/*  265  */	783,
/*  266  */	271,
/*  267  */	0,
/*  268  */	34,
/*  269  */	787,
/*  270  */	788,
/*  271  */	3,
/*  272  */	29,
/*  273  */	35,
/*  274  */	793,
/*  275  */	794,
/*  276  */	795,
/*  277  */	_localgroupname,
/*  278  */	_qualified_username,
/*  279  */	30,
/*  280  */	284,
/*  281  */	0,
/*  282  */	36,
/*  283  */	802,
/*  284  */	1,
/*  285  */	37,
/*  286  */	805,
/*  287  */	806,
/*  288  */	807,
/*  289  */	807,
/*  290  */	(short)PAUSE,
/*  291  */	31,
/*  292  */	_servicename,
/*  293  */	(short)EOS,
/*  294  */	38,
/*  295  */	839,
/*  296  */	839,
/*  297  */	(short)PRINT,
/*  298  */	32,
/*  299  */	320,
/*  300  */	_jobno,
/*  301  */	(short)EOS,
/*  302  */	306,
/*  303  */	33,
/*  304  */	39,
/*  305  */	847,
/*  306  */	34,
/*  307  */	311,
/*  308  */	1,
/*  309  */	40,
/*  310  */	852,
/*  311  */	315,
/*  312  */	4,
/*  313  */	41,
/*  314  */	855,
/*  315  */	5,
/*  316  */	42,
/*  317  */	858,
/*  318  */	859,
/*  319  */	923,
/*  320  */	343,
/*  321  */	_computername,
/*  322  */	_jobno,
/*  323  */	(short)EOS,
/*  324  */	328,
/*  325  */	35,
/*  326  */	43,
/*  327  */	930,
/*  328  */	36,
/*  329  */	333,
/*  330  */	1,
/*  331  */	44,
/*  332  */	935,
/*  333  */	337,
/*  334  */	4,
/*  335  */	45,
/*  336  */	938,
/*  337  */	5,
/*  338  */	46,
/*  339  */	941,
/*  340  */	942,
/*  341  */	943,
/*  342  */	944,
/*  343  */	_computername_share,
/*  344  */	(short)EOS,
/*  345  */	37,
/*  346  */	47,
/*  347  */	949,
/*  348  */	950,
/*  349  */	950,
/*  350  */	(short)SEND,
/*  351  */	38,
/*  352  */	357,
/*  353  */	6,
/*  354  */	39,
/*  355  */	48,
/*  356  */	956,
/*  357  */	362,
/*  358  */	7,
/*  359  */	40,
/*  360  */	49,
/*  361  */	959,
/*  362  */	367,
/*  363  */	8,
/*  364  */	41,
/*  365  */	50,
/*  366  */	962,
/*  367  */	_msgname,
/*  368  */	42,
/*  369  */	51,
/*  370  */	965,
/*  371  */	965,
/*  372  */	(short)SESSION,
/*  373  */	43,
/*  374  */	384,
/*  375  */	(short)EOS,
/*  376  */	380,
/*  377  */	44,
/*  378  */	52,
/*  379  */	1005,
/*  380  */	1,
/*  381  */	53,
/*  382  */	1008,
/*  383  */	1009,
/*  384  */	_computername,
/*  385  */	(short)EOS,
/*  386  */	390,
/*  387  */	45,
/*  388  */	54,
/*  389  */	1014,
/*  390  */	1,
/*  391  */	55,
/*  392  */	1017,
/*  393  */	1018,
/*  394  */	1018,
/*  395  */	(short)SHARE,
/*  396  */	46,
/*  397  */	402,
/*  398  */	(short)EOS,
/*  399  */	47,
/*  400  */	56,
/*  401  */	1024,
/*  402  */	412,
/*  403  */	0,
/*  404  */	1,
/*  405  */	409,
/*  406  */	48,
/*  407  */	57,
/*  408  */	1029,
/*  409  */	58,
/*  410  */	1031,
/*  411  */	1032,
/*  412  */	418,
/*  413  */	_admin_shares,
/*  414  */	(short)EOS,
/*  415  */	59,
/*  416  */	1042,
/*  417  */	1058,
/*  418  */	425,
/*  419  */	_assignment,
/*  420  */	(short)EOS,
/*  421  */	60,
/*  422  */	1064,
/*  423  */	1065,
/*  424  */	1066,
/*  425  */	_netname,
/*  426  */	431,
/*  427  */	(short)EOS,
/*  428  */	49,
/*  429  */	61,
/*  430  */	1071,
/*  431  */	(short)EOS,
/*  432  */	62,
/*  433  */	1074,
/*  434  */	1075,
/*  435  */	1075,
/*  436  */	(short)START,
/*  437  */	442,
/*  438  */	(short)EOS,
/*  439  */	50,
/*  440  */	63,
/*  441  */	1081,
/*  442  */	0,
/*  443  */	447,
/*  444  */	(short)EOS,
/*  445  */	64,
/*  446  */	1086,
/*  447  */	_msgname,
/*  448  */	(short)EOS,
/*  449  */	65,
/*  450  */	1089,
/*  451  */	1090,
/*  452  */	1090,
/*  453  */	(short)STATS,
/*  454  */	51,
/*  455  */	461,
/*  456  */	(short)EOS,
/*  457  */	52,
/*  458  */	66,
/*  459  */	1098,
/*  460  */	1099,
/*  461  */	_servicename,
/*  462  */	(short)EOS,
/*  463  */	53,
/*  464  */	67,
/*  465  */	1104,
/*  466  */	1105,
/*  467  */	1105,
/*  468  */	(short)STOP,
/*  469  */	54,
/*  470  */	_servicename,
/*  471  */	(short)EOS,
/*  472  */	68,
/*  473  */	1112,
/*  474  */	1112,
/*  475  */	(short)TIME,
/*  476  */	55,
/*  477  */	499,
/*  478  */	_computername,
/*  479  */	(short)EOS,
/*  480  */	486,
/*  481  */	9,
/*  482  */	56,
/*  483  */	69,
/*  484  */	1122,
/*  485  */	1123,
/*  486  */	490,
/*  487  */	10,
/*  488  */	70,
/*  489  */	1126,
/*  490  */	494,
/*  491  */	11,
/*  492  */	71,
/*  493  */	1129,
/*  494  */	57,
/*  495  */	72,
/*  496  */	1133,
/*  497  */	1134,
/*  498  */	1135,
/*  499  */	(short)EOS,
/*  500  */	505,
/*  501  */	7,
/*  502  */	9,
/*  503  */	73,
/*  504  */	1140,
/*  505  */	509,
/*  506  */	7,
/*  507  */	74,
/*  508  */	1143,
/*  509  */	514,
/*  510  */	12,
/*  511  */	9,
/*  512  */	75,
/*  513  */	1146,
/*  514  */	518,
/*  515  */	12,
/*  516  */	76,
/*  517  */	1149,
/*  518  */	522,
/*  519  */	9,
/*  520  */	77,
/*  521  */	1152,
/*  522  */	526,
/*  523  */	10,
/*  524  */	78,
/*  525  */	1155,
/*  526  */	530,
/*  527  */	11,
/*  528  */	79,
/*  529  */	1158,
/*  530  */	80,
/*  531  */	1161,
/*  532  */	1162,
/*  533  */	1162,
/*  534  */	(short)USER,
/*  535  */	58,
/*  536  */	541,
/*  537  */	(short)EOS,
/*  538  */	59,
/*  539  */	81,
/*  540  */	1169,
/*  541  */	564,
/*  542  */	_username,
/*  543  */	(short)EOS,
/*  544  */	548,
/*  545  */	60,
/*  546  */	82,
/*  547  */	1174,
/*  548  */	557,
/*  549  */	1,
/*  550  */	554,
/*  551  */	61,
/*  552  */	83,
/*  553  */	1179,
/*  554  */	84,
/*  555  */	1181,
/*  556  */	1182,
/*  557  */	561,
/*  558  */	0,
/*  559  */	85,
/*  560  */	1185,
/*  561  */	86,
/*  562  */	1187,
/*  563  */	1188,
/*  564  */	_username,
/*  565  */	_pass,
/*  566  */	(short)EOS,
/*  567  */	571,
/*  568  */	1,
/*  569  */	87,
/*  570  */	1193,
/*  571  */	575,
/*  572  */	0,
/*  573  */	88,
/*  574  */	1196,
/*  575  */	89,
/*  576  */	1198,
/*  577  */	1199,
/*  578  */	1199,
/*  579  */	0,
/*  580  */	584,
/*  581  */	13,
/*  582  */	90,
/*  583  */	1247,
/*  584  */	588,
/*  585  */	14,
/*  586  */	91,
/*  587  */	1250,
/*  588  */	592,
/*  589  */	15,
/*  590  */	92,
/*  591  */	1253,
/*  592  */	596,
/*  593  */	16,
/*  594  */	93,
/*  595  */	1256,
/*  596  */	94,
/*  597  */	1258,
/*  598  */	1258,
/*  599  */	(short)EOS,
/*  600  */	95,
/*  601  */	1262,
/*  602  */	0,
/*  603  */	62,
/*  604  */	1268,
/*  605  */	0,
/*  606  */	63,
/*  607  */	1270,
/*  608  */	0,
/*  609  */	64,
/*  610  */	1272,
/*  611  */	0,
/*  612  */	65,
/*  613  */	1274,
/*  614  */	0,
/*  615  */	66,
/*  616  */	1276,
/*  617  */	0,
/*  618  */	67,
/*  619  */	1278,
/*  620  */	0,
/*  621  */	68,
/*  622  */	1280,
/*  623  */	0,
/*  624  */	69,
/*  625  */	1282,
/*  626  */	0,
/*  627  */	70,
/*  628  */	1284,
/*  629  */	0,
/*  630  */	71,
/*  631  */	1286,
/*  632  */	0,
/*  633  */	72,
/*  634  */	1288,
/*  635  */	0,
/*  636  */	73,
/*  637  */	1290,
/*  638  */	0,
/*  639  */	74,
/*  640  */	1292,
/*  641  */	0,
/*  642  */	75,
/*  643  */	1294,
/*  644  */	0,
/*  645  */	76,
/*  646  */	1296,
/*  647  */	0,
/*  648  */	77,
/*  649  */	1298,
/*  650  */	0,
/*  651  */	1300,
/*  652  */	0,
/*  653  */	78,
/*  654  */	1302,
/*  655  */	0,
/*  656  */	79,
/*  657  */	1304,
/*  658  */	0,
/*  659  */	80,
/*  660  */	1306,
/*  661  */	0,
/*  662  */	81,
/*  663  */	1308,
/*  664  */	0,
/*  665  */	82,
/*  666  */	1310,
/*  667  */	0,
/*  668  */	83,
/*  669  */	1312,
	};
extern	TCHAR *	XXnode;
xxcondition(index,xxvar)int index;register TCHAR * xxvar[]; {switch(index) {
#line 392 "msnet.nt"
		case 0 :
			return(ValidateSwitches(0, accounts_switches));
#line 396 "msnet.nt"
		case 1 :
			return(noswitch_optional(swtxt_SW_DOMAIN));
#line 545 "msnet.nt"
		case 2 :
			return(ValidateSwitches(0,computer_switches));
#line 551 "msnet.nt"
		case 3 :
			return(oneswitch());
#line 562 "msnet.nt"
		case 4 :
			return(oneswitch());
#line 574 "msnet.nt"
		case 5 :
			return(ValidateSwitches(0,no_switches));
#line 579 "msnet.nt"
		case 6 :
			return(noswitch());
#line 586 "msnet.nt"
		case 7 :
			return(ValidateSwitches(0,no_switches));
#line 656 "msnet.nt"
		case 8 :
			return(ValidateSwitches(0,file_switches));
#line 660 "msnet.nt"
		case 9 :
			return(noswitch());
#line 666 "msnet.nt"
		case 10 :
			return(noswitch());
#line 674 "msnet.nt"
		case 11 :
			return(ValidateSwitches(0,group_switches));
#line 676 "msnet.nt"
		case 12 :
			return(noswitch_optional(swtxt_SW_DOMAIN));
#line 681 "msnet.nt"
		case 13 :
			return(noswitch_optional(swtxt_SW_DOMAIN));
#line 686 "msnet.nt"
		case 14 :
			return(oneswitch_optional(swtxt_SW_DOMAIN));
#line 699 "msnet.nt"
		case 15 :
			return(oneswitch_optional(swtxt_SW_DOMAIN));
#line 706 "msnet.nt"
		case 16 :
			return(oneswitch_optional(swtxt_SW_DOMAIN));
#line 717 "msnet.nt"
		case 17 :
			return(ValidateSwitches(0,no_switches));
#line 723 "msnet.nt"
		case 18 :
			return(ValidateSwitches(0,help_switches));
#line 727 "msnet.nt"
		case 19 :
			return(oneswitch());
#line 735 "msnet.nt"
		case 20 :
			return(oneswitch());
#line 742 "msnet.nt"
		case 21 :
			return(ValidateSwitches(0,add_del_switches));
#line 746 "msnet.nt"
		case 22 :
			return(noswitch());
#line 752 "msnet.nt"
		case 23 :
			return(noswitch());
#line 755 "msnet.nt"
		case 24 :
			return(oneswitch());
#line 766 "msnet.nt"
		case 25 :
			return(ValidateSwitches(0,group_switches));
#line 768 "msnet.nt"
		case 26 :
			return(noswitch_optional(swtxt_SW_DOMAIN));
#line 773 "msnet.nt"
		case 27 :
			return(noswitch_optional(swtxt_SW_DOMAIN));
#line 778 "msnet.nt"
		case 28 :
			return(oneswitch_optional(swtxt_SW_DOMAIN));
#line 791 "msnet.nt"
		case 29 :
			return(oneswitch_optional(swtxt_SW_DOMAIN));
#line 798 "msnet.nt"
		case 30 :
			return(oneswitch_optional(swtxt_SW_DOMAIN));
#line 835 "msnet.nt"
		case 31 :
			return(ValidateSwitches(0,no_switches));
#line 841 "msnet.nt"
		case 32 :
			return(ValidateSwitches(0,print_switches));
#line 845 "msnet.nt"
		case 33 :
			return(noswitch());
#line 848 "msnet.nt"
		case 34 :
			return(oneswitch());
#line 928 "msnet.nt"
		case 35 :
			return(noswitch());
#line 931 "msnet.nt"
		case 36 :
			return(oneswitch());
#line 947 "msnet.nt"
		case 37 :
			return(noswitch());
#line 952 "msnet.nt"
		case 38 :
			return(ValidateSwitches(0,send_switches));
#line 954 "msnet.nt"
		case 39 :
			return(oneswitch());
#line 957 "msnet.nt"
		case 40 :
			return(oneswitch());
#line 960 "msnet.nt"
		case 41 :
			return(oneswitch());
#line 963 "msnet.nt"
		case 42 :
			return(noswitch());
#line 999 "msnet.nt"
		case 43 :
			return(ValidateSwitches(0,del_only_switches));
#line 1003 "msnet.nt"
		case 44 :
			return(noswitch());
#line 1012 "msnet.nt"
		case 45 :
			return(noswitch());
#line 1020 "msnet.nt"
		case 46 :
			return(ValidateSwitches(0,share_switches));
#line 1022 "msnet.nt"
		case 47 :
			return(noswitch());
#line 1027 "msnet.nt"
		case 48 :
			return(oneswitch());
#line 1069 "msnet.nt"
		case 49 :
			return(noswitch());
#line 1079 "msnet.nt"
		case 50 :
			return(ValidateSwitches(0,no_switches));
#line 1092 "msnet.nt"
		case 51 :
			return(ValidateSwitches(0,stats_switches));
#line 1096 "msnet.nt"
		case 52 :
			return(noswitch());
#line 1102 "msnet.nt"
		case 53 :
			return(noswitch());
#line 1108 "msnet.nt"
		case 54 :
			return(ValidateSwitches(0,no_switches));
#line 1114 "msnet.nt"
		case 55 :
			return(ValidateSwitches(0,time_switches));
#line 1120 "msnet.nt"
		case 56 :
			return(oneswitch());
#line 1131 "msnet.nt"
		case 57 :
			return(noswitch());
#line 1165 "msnet.nt"
		case 58 :
			return(ValidateSwitches(0,user_switches));
#line 1167 "msnet.nt"
		case 59 :
			return(noswitch_optional(swtxt_SW_DOMAIN));
#line 1172 "msnet.nt"
		case 60 :
			return(noswitch_optional(swtxt_SW_DOMAIN));
#line 1177 "msnet.nt"
		case 61 :
			return(oneswitch_optional(swtxt_SW_DOMAIN));
#line 1268 "msnet.nt"
		case 62 :
			return(IsDomainName(xxvar[0]));
#line 1270 "msnet.nt"
		case 63 :
			return(IsComputerName(xxvar[0]));
#line 1272 "msnet.nt"
		case 64 :
			return(IsComputerNameShare(xxvar[0]));
#line 1274 "msnet.nt"
		case 65 :
			return(IsDeviceName(xxvar[0]));
#line 1276 "msnet.nt"
		case 66 :
			return(IsResource(xxvar[0]));
#line 1278 "msnet.nt"
		case 67 :
			return(IsAccessSetting(xxvar[0]));
#line 1280 "msnet.nt"
		case 68 :
			return(IsPathname(xxvar[0]));
#line 1282 "msnet.nt"
		case 69 :
			return(IsPathnameOrUNC(xxvar[0]));
#line 1284 "msnet.nt"
		case 70 :
			return(IsNumber(xxvar[0]));
#line 1286 "msnet.nt"
		case 71 :
			return(IsNumber(xxvar[0]));
#line 1288 "msnet.nt"
		case 72 :
			return(IsNetname(xxvar[0]));
#line 1290 "msnet.nt"
		case 73 :
			return(IsMsgid(xxvar[0]));
#line 1292 "msnet.nt"
		case 74 :
			return(IsUsername(xxvar[0]));
#line 1294 "msnet.nt"
		case 75 :
			return(IsQualifiedUsername(xxvar[0]));
#line 1296 "msnet.nt"
		case 76 :
			return(IsMsgname(xxvar[0]));
#line 1298 "msnet.nt"
		case 77 :
			return(IsPassword(xxvar[0]));
#line 1302 "msnet.nt"
		case 78 :
			return(IsShareAssignment(xxvar[0]));
#line 1304 "msnet.nt"
		case 79 :
			return(IsAnyShareAssign(xxvar[0]));
#line 1306 "msnet.nt"
		case 80 :
			return(IsAdminShare(xxvar[0]));
#line 1308 "msnet.nt"
		case 81 :
			return(IsPrintDest(xxvar[0]));
#line 1310 "msnet.nt"
		case 82 :
			return(IsNtAliasname(xxvar[0]));
#line 1312 "msnet.nt"
		case 83 :
			return(IsGroupname(xxvar[0]));
		}return 0;}
xxaction(index,xxvar)int index;register TCHAR * xxvar[]; {switch(index) {
#line 397 "msnet.nt"
		case 0 :
			{accounts_display(); } break;
#line 399 "msnet.nt"
		case 1 :
			{accounts_change(); } break;
#line 552 "msnet.nt"
		case 2 :
			{computer_add(xxvar[1]); } break;
#line 554 "msnet.nt"
		case 3 :
			{help_help(0, USAGE_ONLY); } break;
#line 563 "msnet.nt"
		case 4 :
			{computer_del(xxvar[1]); } break;
#line 565 "msnet.nt"
		case 5 :
			{help_help(0, USAGE_ONLY); } break;
#line 575 "msnet.nt"
		case 6 :
			{config_display(); } break;
#line 580 "msnet.nt"
		case 7 :
			{config_generic_display(xxvar[1]); } break;
#line 582 "msnet.nt"
		case 8 :
			{config_generic_change(xxvar[1]); } break;
#line 589 "msnet.nt"
		case 9 :
			{cont_generic(_tcsupr(xxvar[1])); } break;
#line 661 "msnet.nt"
		case 10 :
			{files_display(NULL); } break;
#line 667 "msnet.nt"
		case 11 :
			{files_display(xxvar[1]); } break;
#line 670 "msnet.nt"
		case 12 :
			{files_close(xxvar[1]); } break;
#line 677 "msnet.nt"
		case 13 :
			{group_enum(); } break;
#line 682 "msnet.nt"
		case 14 :
			{group_display(xxvar[1]); } break;
#line 687 "msnet.nt"
		case 15 :
			{group_del(xxvar[1]); } break;
#line 689 "msnet.nt"
		case 16 :
			{help_help(0, USAGE_ONLY); } break;
#line 694 "msnet.nt"
		case 17 :
			{group_add(xxvar[1]); } break;
#line 700 "msnet.nt"
		case 18 :
			{group_change(xxvar[1]); } break;
#line 709 "msnet.nt"
		case 19 :
			{group_add_users(xxvar[1]); } break;
#line 712 "msnet.nt"
		case 20 :
			{group_del_users(xxvar[1]); } break;
#line 720 "msnet.nt"
		case 21 :
			{help_helpmsg(xxvar[1]); } break;
#line 728 "msnet.nt"
		case 22 :
			{help_help(0, OPTIONS_ONLY); } break;
#line 730 "msnet.nt"
		case 23 :
			{help_help(0, ALL); } break;
#line 736 "msnet.nt"
		case 24 :
			{help_help(1, OPTIONS_ONLY); } break;
#line 738 "msnet.nt"
		case 25 :
			{help_help(1, ALL); } break;
#line 747 "msnet.nt"
		case 26 :
			{name_display(); } break;
#line 753 "msnet.nt"
		case 27 :
			{name_add(xxvar[1]); } break;
#line 758 "msnet.nt"
		case 28 :
			{name_add(xxvar[1]); } break;
#line 761 "msnet.nt"
		case 29 :
			{name_del(xxvar[1]); } break;
#line 769 "msnet.nt"
		case 30 :
			{ntalias_enum(); } break;
#line 774 "msnet.nt"
		case 31 :
			{ntalias_display(xxvar[1]); } break;
#line 779 "msnet.nt"
		case 32 :
			{ntalias_del(xxvar[1]); } break;
#line 781 "msnet.nt"
		case 33 :
			{help_help(0, USAGE_ONLY); } break;
#line 786 "msnet.nt"
		case 34 :
			{ntalias_add(xxvar[1]); } break;
#line 792 "msnet.nt"
		case 35 :
			{ntalias_change(xxvar[1]); } break;
#line 801 "msnet.nt"
		case 36 :
			{ntalias_add_users(xxvar[1]); } break;
#line 804 "msnet.nt"
		case 37 :
			{ntalias_del_users(xxvar[1]); } break;
#line 838 "msnet.nt"
		case 38 :
			{paus_generic(_tcsupr(xxvar[1])); } break;
#line 846 "msnet.nt"
		case 39 :
			{print_job_status(NULL,xxvar[1]); } break;
#line 851 "msnet.nt"
		case 40 :
			{print_job_del(NULL,xxvar[1]); } break;
#line 854 "msnet.nt"
		case 41 :
			{print_job_hold(NULL,xxvar[1]); } break;
#line 857 "msnet.nt"
		case 42 :
			{print_job_release(NULL,xxvar[1]); } break;
#line 929 "msnet.nt"
		case 43 :
			{print_job_status(xxvar[1],xxvar[2]); } break;
#line 934 "msnet.nt"
		case 44 :
			{print_job_del(xxvar[1],xxvar[2]); } break;
#line 937 "msnet.nt"
		case 45 :
			{print_job_hold(xxvar[1],xxvar[2]); } break;
#line 940 "msnet.nt"
		case 46 :
			{print_job_release(xxvar[1],xxvar[2]); } break;
#line 948 "msnet.nt"
		case 47 :
			{print_q_display(xxvar[1]); } break;
#line 955 "msnet.nt"
		case 48 :
			{send_users(); } break;
#line 958 "msnet.nt"
		case 49 :
			{send_domain(1); } break;
#line 961 "msnet.nt"
		case 50 :
			{send_domain(1); } break;
#line 964 "msnet.nt"
		case 51 :
			{send_direct(xxvar[1]); } break;
#line 1004 "msnet.nt"
		case 52 :
			{session_display(NULL); } break;
#line 1007 "msnet.nt"
		case 53 :
			{session_del_all(1,1); } break;
#line 1013 "msnet.nt"
		case 54 :
			{session_display(xxvar[1]); } break;
#line 1016 "msnet.nt"
		case 55 :
			{session_del(xxvar[1]); } break;
#line 1023 "msnet.nt"
		case 56 :
			{share_display_all(); } break;
#line 1028 "msnet.nt"
		case 57 :
			{share_del(xxvar[1]); } break;
#line 1030 "msnet.nt"
		case 58 :
			{help_help(0, USAGE_ONLY); } break;
#line 1041 "msnet.nt"
		case 59 :
			{share_admin(xxvar[1]); } break;
#line 1063 "msnet.nt"
		case 60 :
			{share_add(xxvar[1],NULL,0); } break;
#line 1070 "msnet.nt"
		case 61 :
			{share_display_share(xxvar[1]); } break;
#line 1073 "msnet.nt"
		case 62 :
			{share_change(xxvar[1]); } break;
#line 1080 "msnet.nt"
		case 63 :
			{start_display(); } break;
#line 1085 "msnet.nt"
		case 64 :
			{start_generic(_tcsupr(xxvar[1]), NULL); } break;
#line 1088 "msnet.nt"
		case 65 :
			{start_generic(_tcsupr(xxvar[1]), xxvar[2]); } break;
#line 1097 "msnet.nt"
		case 66 :
			{stats_display(); } break;
#line 1103 "msnet.nt"
		case 67 :
			{stats_generic_display(_tcsupr(xxvar[1])); } break;
#line 1111 "msnet.nt"
		case 68 :
			{stop_generic(_tcsupr(xxvar[1])); } break;
#line 1121 "msnet.nt"
		case 69 :
			{time_display_server( xxvar[1], TRUE ); } break;
#line 1125 "msnet.nt"
		case 70 :
			{time_set_sntp( xxvar[1] ); } break;
#line 1128 "msnet.nt"
		case 71 :
			{time_get_sntp( xxvar[1] ); } break;
#line 1132 "msnet.nt"
		case 72 :
			{time_display_server( xxvar[1], FALSE ); } break;
#line 1139 "msnet.nt"
		case 73 :
			{time_display_dc( TRUE ); } break;
#line 1142 "msnet.nt"
		case 74 :
			{time_display_dc(FALSE); } break;
#line 1145 "msnet.nt"
		case 75 :
			{time_display_rts(TRUE, TRUE); } break;
#line 1148 "msnet.nt"
		case 76 :
			{time_display_rts(FALSE, TRUE); } break;
#line 1151 "msnet.nt"
		case 77 :
			{time_display_rts(TRUE, FALSE); } break;
#line 1154 "msnet.nt"
		case 78 :
			{time_set_sntp( NULL ); } break;
#line 1157 "msnet.nt"
		case 79 :
			{time_get_sntp( NULL ); } break;
#line 1160 "msnet.nt"
		case 80 :
			{time_display_rts(FALSE, FALSE); } break;
#line 1168 "msnet.nt"
		case 81 :
			{user_enum(); } break;
#line 1173 "msnet.nt"
		case 82 :
			{user_display(xxvar[1]); } break;
#line 1178 "msnet.nt"
		case 83 :
			{user_del(xxvar[1]); } break;
#line 1180 "msnet.nt"
		case 84 :
			{help_help(0, USAGE_ONLY); } break;
#line 1184 "msnet.nt"
		case 85 :
			{user_add(xxvar[1], NULL); } break;
#line 1186 "msnet.nt"
		case 86 :
			{user_change(xxvar[1],NULL); } break;
#line 1192 "msnet.nt"
		case 87 :
			{help_help(0,USAGE_ONLY); } break;
#line 1195 "msnet.nt"
		case 88 :
			{user_add(xxvar[1], xxvar[2]); } break;
#line 1197 "msnet.nt"
		case 89 :
			{user_change(xxvar[1],xxvar[2]); } break;
#line 1246 "msnet.nt"
		case 90 :
			{help_help(0, ALL); } break;
#line 1249 "msnet.nt"
		case 91 :
			{help_help(0, ALL); } break;
#line 1252 "msnet.nt"
		case 92 :
			{help_help(0, ALL); } break;
#line 1255 "msnet.nt"
		case 93 :
			{help_help(0, USAGE_ONLY); } break;
#line 1257 "msnet.nt"
		case 94 :
			{help_help(0, USAGE_ONLY); } break;
#line 1261 "msnet.nt"
		case 95 :
			{help_help(0, USAGE_ONLY); } break;
		}return 0;}
TCHAR * xxswitch[] = {
TEXT("/ADD"),
TEXT("/DELETE"),
TEXT("/CLOSE"),
TEXT("/COMMENT"),
TEXT("/HOLD"),
TEXT("/RELEASE"),
TEXT("/USERS"),
TEXT("/DOMAIN"),
TEXT("/BROADCAST"),
TEXT("/SET"),
TEXT("/SETSNTP"),
TEXT("/QUERYSNTP"),
TEXT("/RTSDOMAIN"),
TEXT("/HELP"),
TEXT("/help"),
TEXT("/Help"),
TEXT("/?"),
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\ntalias.c ===
/********************************************************************/
/**                     Microsoft Windows NT                       **/
/**               Copyright(c) Microsoft Corp., 1992               **/
/********************************************************************/

/*
 *  ntalias.c
 *      net ntalias cmds
 *
 *  History:
 *      mm/dd/yy, who, comment
 *      01/24/92, chuckc,  templated from groups.c
 */



/* Include files */

#include <nt.h>            // base definitions
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>         // for Sam***

#define INCL_NOCOMMON
#define INCL_ERRORS
#include <os2.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#define INCL_ERROR_H
#include <apperr.h>
#include <apperr2.h>
#include <search.h>
#include <dlwksta.h>
#include "mwksta.h"
#include "netcmds.h"
#include "nettext.h"
#include <rpc.h>
#include <ntdsapi.h>
#include "sam.h"
#include "msystem.h"

/* Forward declarations */
VOID SamErrorExit(DWORD err);
VOID SamErrorExitInsTxt(DWORD err, LPTSTR);
int __cdecl CmpAliasEntry(const VOID *, const VOID *);
int __cdecl CmpAliasMemberEntry(const VOID *, const VOID *);

/***
 *  ntalias_enum()
 *      Display info about all ntaliases on a server
 *
 *  Args:
 *      none.
 *
 *  Returns:
 *      nothing - success
 *      exit 1 - command completed with errors
 *      exit 2 - command failed
 */

VOID ntalias_enum(VOID)
{
    DWORD            dwErr ;
    ALIAS_ENTRY      *aliases, *next_alias ;
    DWORD            num_read, i ;
    TCHAR            controller[MAX_PATH+1];
    TCHAR            localserver[MAX_PATH+1];
    LPWKSTA_INFO_10  wksta_entry;

    /* get localserver name for display */
    if (dwErr = MNetWkstaGetInfo(10, (LPBYTE *) &wksta_entry))
    {
        ErrorExit(dwErr);
    }

    _tcscpy(localserver, wksta_entry->wki10_computername);
    NetApiBufferFree((TCHAR FAR *) wksta_entry);

    /* determine where to make the API call */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller), 
                               NULL, 0, FALSE))
    {
         ErrorExit(dwErr);
    }

    /* open SAM to enum aliases */
    dwErr = OpenSAM(controller,READ_PRIV) ;
    if (dwErr != NERR_Success)
        SamErrorExit(dwErr);

    /* do the enumeration */
    dwErr = SamEnumAliases(&aliases, &num_read) ;
    if (dwErr != NERR_Success)
        SamErrorExit(dwErr);

    /* sort the return buffer */
    qsort((TCHAR *)aliases, num_read, sizeof(ALIAS_ENTRY), CmpAliasEntry);

    /* now go display the info */
    PrintNL();
    InfoPrintInsTxt(APE2_ALIASENUM_HEADER,
                    controller[0] ? controller + _tcsspn(controller, TEXT("\\")) :
                        localserver);
    PrintLine();
    for (i = 0, next_alias = aliases;
         i < num_read;
         i++, next_alias++)
    {
        WriteToCon(TEXT("*%Fws\r\n"), next_alias->name);
    }

    /* free things up, cleanup, go home */
    FreeAliasEntries(aliases, num_read) ;
    FreeMem(aliases) ;
    CloseSAM() ;

    InfoSuccess();
    return;
}

/* setup info for GetMessageList */

#define ALIASDISP_ALIASNAME     0
#define ALIASDISP_COMMENT       ( ALIASDISP_ALIASNAME + 1 )

static MESSAGE  msglist[] = {
{ APE2_ALIASDISP_ALIASNAME, NULL },
{ APE2_ALIASDISP_COMMENT,   NULL }
};
#define NUM_ALIAS_MSGS  (sizeof(msglist)/sizeof(msglist[0]))


/***
 *  ntalias_display()
 *      Display info about a single ntalias on a server
 *
 *  Args:
 *      ntalias - name of ntalias to display
 *
 *  Returns:
 *      nothing - success
 *      exit 1 - command completed with errors
 *      exit 2 - command failed
 */
VOID ntalias_display(TCHAR * ntalias)
{
    DWORD           dwErr;
    TCHAR           controller[MAX_PATH+1];
    ALIAS_ENTRY     Alias ;
    TCHAR **        alias_members ;
    DWORD           num_members, i ;
    DWORD           maxmsglen;  /* maxmimum length of msg */

    Alias.name = ntalias ;

    /* determine where to make the API call */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller), 
                               NULL, 0, FALSE))
         ErrorExit(dwErr);

    /* access the database */
    if (dwErr = OpenSAM(controller,READ_PRIV))
        SamErrorExit(dwErr);

    /* access the alias */
    if (dwErr = OpenAlias(ntalias, ALIAS_READ_INFORMATION | ALIAS_LIST_MEMBERS, USE_BUILTIN_OR_ACCOUNT))
        SamErrorExit(dwErr);

    /* get comment of alias */
    if (dwErr = AliasGetInfo(&Alias))
        SamErrorExit(dwErr);

    /* display name & comment */
    GetMessageList(NUM_ALIAS_MSGS, msglist, &maxmsglen);
    maxmsglen += 5;

    WriteToCon( fmtPSZ, 0, maxmsglen,
                PaddedString(maxmsglen, msglist[ALIASDISP_ALIASNAME].msg_text, NULL),
                Alias.name );
    WriteToCon( fmtPSZ, 0, maxmsglen,
                PaddedString(maxmsglen, msglist[ALIASDISP_COMMENT].msg_text, NULL),
                (Alias.comment ? Alias.comment : TEXT("")) );

    /* free if need. would have been alloc-ed by GetInfo */
    if (Alias.comment)
    {
        FreeMem(Alias.comment);
    }

    /* now get members */
    if (dwErr = AliasEnumMembers(&alias_members, &num_members))
        SamErrorExit(dwErr);

    /* sort the buffer */
    qsort((TCHAR *) alias_members, num_members,
             sizeof(TCHAR *), CmpAliasMemberEntry);

    /* display all members */
    PrintNL();
    InfoPrint(APE2_ALIASDISP_MEMBERS);
    PrintLine();
    for (i = 0 ; i < num_members; i++)
    {
        WriteToCon(TEXT("%Fws\r\n"), alias_members[i]);
    }

    // free up stuff, cleanup
    AliasFreeMembers(alias_members, num_members);
    NetApiBufferFree((TCHAR FAR *) alias_members);
    CloseSAM() ;
    CloseAlias() ;

    InfoSuccess();
    return;
}


/***
 *  ntalias_add()
 *      Add a ntalias
 *
 *  Args:
 *      ntalias - ntalias to add
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 */
VOID ntalias_add(TCHAR * ntalias)
{
    TCHAR           controller[MAX_PATH+1], *ptr;
    ALIAS_ENTRY     alias_entry ;
    DWORD           dwErr;
    USHORT          i;

    alias_entry.name = ntalias;
    alias_entry.comment = NULL;

    /* go thru switches */
    for (i = 0; SwitchList[i]; i++)
    {
         /* Skip the ADD or DOMAIN switch */
         if (!_tcscmp(SwitchList[i], swtxt_SW_ADD) ||
             !_tcscmp(SwitchList[i],swtxt_SW_DOMAIN))
             continue;

        /* only the COMMENT switch is interesting */
        if (! _tcsncmp(SwitchList[i],
                       swtxt_SW_COMMENT,
                       _tcslen(swtxt_SW_COMMENT)))
        {
            /* make sure comment is there */
            if ((ptr = FindColon(SwitchList[i])) == NULL)
                ErrorExit(APE_InvalidSwitchArg);
            alias_entry.comment = ptr;
        }
    }

    /* determine where to make the API call */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller), 
                               NULL, 0, TRUE))
         ErrorExit(dwErr);

    /* access the database */
    if (dwErr = OpenSAM(controller,WRITE_PRIV))
        SamErrorExit(dwErr);

    /* add it! */
    if (dwErr = SamAddAlias(&alias_entry))
        SamErrorExit(dwErr);

    CloseSAM() ;
    InfoSuccess();
}


/***
 *  ntalias_change()
 *      Change a ntalias
 *
 *  Args:
 *      ntalias - ntalias to change
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 */
VOID ntalias_change(TCHAR * ntalias)
{
    DWORD           dwErr;
    TCHAR           controller[MAX_PATH+1], *comment, *ptr ;
    ALIAS_ENTRY     alias_entry ;
    USHORT          i;

    /* init the structure */
    comment = alias_entry.comment = NULL ;
    alias_entry.name = ntalias ;

    /* go thru cmdline switches */
    for (i = 0; SwitchList[i]; i++)
    {
         /* Skip the DOMAIN switch */
         if (!_tcscmp(SwitchList[i],swtxt_SW_DOMAIN))
             continue;

        /* only the COMMENT switch is interesting */
        if (! _tcsncmp(SwitchList[i],
                       swtxt_SW_COMMENT,
                       _tcslen(swtxt_SW_COMMENT)))
        {
            /* make sure comment is there */
            if ((ptr = FindColon(SwitchList[i])) == NULL)
                ErrorExit(APE_InvalidSwitchArg);
            comment = ptr;
        }
    }

    /* determine where to make the API call */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller), 
                               NULL, 0, TRUE))
         ErrorExit(dwErr);

    /* access the database */
    if (dwErr = OpenSAM(controller,WRITE_PRIV))
        SamErrorExit(dwErr);

    /* access the alias */
    if (dwErr = OpenAlias(ntalias, ALIAS_WRITE_ACCOUNT, USE_BUILTIN_OR_ACCOUNT))
        SamErrorExit(dwErr);

    /* if comment was specified, do a set info */
    if (comment != NULL)
    {
        alias_entry.comment = comment ;
        dwErr = AliasSetInfo ( &alias_entry ) ;
        if (dwErr)
            SamErrorExit(dwErr);
    }

    /* cleanup, go home */
    CloseSAM() ;
    CloseAlias() ;
    InfoSuccess();
}



/***
 *  ntalias_del()
 *      Delete a ntalias
 *
 *  Args:
 *      ntalias - ntalias to delete
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 */
VOID ntalias_del(TCHAR * ntalias)
{
    TCHAR            controller[MAX_PATH+1];
    DWORD            dwErr;

    /* determine where to make the API call */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller), 
                               NULL, 0, TRUE))
         ErrorExit(dwErr);

    /* access the database */
    if (dwErr = OpenSAM(controller,WRITE_PRIV))
        SamErrorExit(dwErr);

    /* nuke it! */
    dwErr = SamDelAlias(ntalias);

    switch (dwErr)
    {
        case NERR_Success:
            break;
        default:
            SamErrorExit(dwErr);
    }

    /* cleanup, go home */
    CloseSAM() ;
    CloseAlias() ;
    InfoSuccess();
}


/***
 *  ntalias_add_users()
 *      Add users to a ntalias
 *
 *  Args:
 *      ntalias - ntalias to add users to
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 */
VOID ntalias_add_users(TCHAR * ntalias)
{
    DWORD           dwErr;
    int             i, err_cnt = 0 ;
    TCHAR            controller[MAX_PATH+1];
    PDS_NAME_RESULT pNameResult = NULL;
    HANDLE hDs = NULL;

    /* determine where to make the API call */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller), 
                               NULL, 0, TRUE))
         ErrorExit(dwErr);

    /* access the database */
    if (dwErr = OpenSAM(controller, WRITE_PRIV))
    {
        SamErrorExit(dwErr);
    }

    /* access the alias */
    if (dwErr = OpenAlias(ntalias, ALIAS_ADD_MEMBER, USE_BUILTIN_OR_ACCOUNT))
    {
 	if (dwErr == APE_UnknownAccount)
        {
            SamErrorExitInsTxt(APE_NoSuchAccount, ntalias);
        }
	else
        {
            SamErrorExit(dwErr);
        }
    }

    /* go thru switches */
    for (i = 2; ArgList[i]; i++)
    {
        LPWSTR  pNameToAdd = ArgList[i];

        /*
         * Is this username in UPN format?
         */

        if (_tcschr( ArgList[i], '@' ))
        {

            if (hDs == NULL)
            {
                DsBindW( NULL, NULL, &hDs );
            }

            if (hDs != NULL)
            {
                if ( !DsCrackNames( hDs,
                                DS_NAME_NO_FLAGS,
                                DS_USER_PRINCIPAL_NAME,
                                DS_NT4_ACCOUNT_NAME,
                                1,
                                &ArgList[i],
                                &pNameResult ) )
                {
                    if (pNameResult->cItems == 1)
                    {
                        if (pNameResult->rItems[0].status ==  0 )
                        {
                            pNameToAdd = pNameResult->rItems[0].pName;
                        }
                    }
                }
            }
        }
        dwErr = AliasAddMember(pNameToAdd);
        switch (dwErr)
        {
            case NERR_Success:
                break;

            case NERR_UserInGroup:
                IStrings[0] = pNameToAdd;
                IStrings[1] = ntalias;
                ErrorPrint(APE_AccountAlreadyInLocalGroup,2);
                err_cnt++;
                break;

            case APE_UnknownAccount:
            case NERR_UserNotFound:
                IStrings[0] = pNameToAdd;
                ErrorPrint(APE_NoSuchRegAccount,1);
                err_cnt++;
                break;

            case ERROR_INVALID_NAME:
                IStrings[0] = pNameToAdd;
                ErrorPrint(APE_BadUGName,1);
                err_cnt++;
                break;

            default:
                SamErrorExit(dwErr);
        }

        if (pNameResult)
        {
            DsFreeNameResult(pNameResult);
            pNameResult = NULL;
        }
    }

    if (hDs)
    {
        DsUnBind( &hDs );
    }

    CloseSAM() ;
    CloseAlias() ;

    if (err_cnt)
    {
        /* If at least one success, print complete-with-errs msg */
        if (err_cnt < (i - 2))
            InfoPrint(APE_CmdComplWErrors);
        /* Exit with error set */
        NetcmdExit(1);
    }
    else
        InfoSuccess();
}


/***
 *  ntalias_del_users()
 *      Delete users from a ntalias
 *
 *  Args:
 *      ntalias - ntalias to delete users from
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 */
VOID ntalias_del_users(TCHAR * ntalias)
{
    DWORD           dwErr;
    TCHAR           controller[MAX_PATH+1];
    int             i, err_cnt = 0 ;
    PDS_NAME_RESULT pNameResult = NULL;
    HANDLE hDs = NULL;

    /* determine where to make the API call */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller), 
                               NULL, 0, TRUE))
    {
         ErrorExit(dwErr);
    }

    /* access the database */
    if (dwErr = OpenSAM(controller,WRITE_PRIV))
    {
        SamErrorExit(dwErr);
    }

    /* access the alias */
    if (dwErr = OpenAlias(ntalias, ALIAS_REMOVE_MEMBER, USE_BUILTIN_OR_ACCOUNT))
    {
 	if (dwErr == APE_UnknownAccount)
        {
            SamErrorExitInsTxt(APE_NoSuchAccount,ntalias) ;
        }
	else
        {
            SamErrorExit(dwErr);
        }
    }

    /* go thru switches */
    for (i = 2; ArgList[i]; i++)
    {
        LPWSTR  pNameToDel = ArgList[i];

        /*
         * Is this username in UPN format?
         */

        if (_tcschr( ArgList[i], '@' ))
        {
            if (hDs == NULL)
            {
                DsBindW( NULL, NULL, &hDs );
            }

            if (hDs != NULL)
            {
                if ( !DsCrackNames( hDs,
                                DS_NAME_NO_FLAGS,
                                DS_USER_PRINCIPAL_NAME,
                                DS_NT4_ACCOUNT_NAME,
                                1,
                                &ArgList[i],
                                &pNameResult ) )
                {
                    if (pNameResult->cItems == 1)
                    {
                        if (pNameResult->rItems[0].status ==  0 )
                        {
                            pNameToDel = pNameResult->rItems[0].pName;
                        }
                    }
                }
            }
        }

        dwErr = AliasDeleteMember(pNameToDel);
        switch (dwErr)
        {
            case NERR_Success:
                break;

            case NERR_UserNotInGroup:
                IStrings[0] = pNameToDel;
                IStrings[1] = ntalias;
                ErrorPrint(APE_UserNotInGroup,2);
                err_cnt++;
                break;

            case APE_UnknownAccount:
            case NERR_UserNotFound:
                IStrings[0] = pNameToDel;
                ErrorPrint(APE_NoSuchRegAccount,1);
                err_cnt++;
                break;

            case ERROR_INVALID_NAME:
                IStrings[0] = pNameToDel;
                ErrorPrint(APE_BadUGName,1);
                err_cnt++;
                break;

            default:
                SamErrorExit(dwErr);
        }
        if (pNameResult)
        {
            DsFreeNameResult(pNameResult);
            pNameResult = NULL;
        }
    }
    if (hDs)
    {
        DsUnBind( &hDs );
    }

    CloseSAM() ;
    CloseAlias() ;

    if (err_cnt)
    {
        /* If at least one success, print complete-with-errs msg */
        if (err_cnt < (i - 2))
            InfoPrint(APE_CmdComplWErrors);
        /* Exit with error set */
        NetcmdExit(1);
    }
    else
    {
        InfoSuccess();
    }
}

/***
 *  SamErrorExit()
 *
 *  Just like the usual ErrorExit(), except we close the various
 *  handles first
 */
VOID
SamErrorExit(
    DWORD err
    )
{
    CloseSAM();
    CloseAlias();
    ErrorExit(err);
}

/***
 *  SamErrorExitInsTxt()
 *
 *  Just like the usual ErrorExitInsTxt(), except we close the various
 *  handles first
 */
VOID
SamErrorExitInsTxt(
    DWORD  err,
    LPTSTR txt
    )
{
    CloseSAM();
    CloseAlias();
    ErrorExitInsTxt(err,txt);
}

/***
 *  CmpAliasEntry(alias1,alias2)
 *
 *  Compares two ALIAS_ENTRY structures and returns a relative
 *  lexical value, suitable for using in qsort.
 *
 */
int __cdecl CmpAliasEntry(const VOID FAR * alias1, const VOID FAR * alias2)
{
    INT n;
    n = CompareStringW( GetUserDefaultLCID(),
                        NORM_IGNORECASE,
                        (LPCWSTR)((ALIAS_ENTRY *) alias1)->name,
                        (int)-1,
                        (LPCWSTR)((ALIAS_ENTRY *) alias2)->name,
                        (int)-1);
    n -= 2;

    return n;
}
/***
 *  CmpAliasMemberEntry(member1,member2)
 *
 *  Compares two TCHAR ** and returns a relative
 *  lexical value, suitable for using in qsort.
 *
 */
int __cdecl CmpAliasMemberEntry(const VOID FAR * member1, const VOID FAR * member2)
{
    INT n;
    n = CompareStringW( GetUserDefaultLCID(),
                        NORM_IGNORECASE,
                        *(LPCWSTR*)member1,
                        (int)-1,
                        *(LPCWSTR*)member2,
                        (int)-1);
    n -= 2;

    return n;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\netcmds.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/


/* Global variables */

extern TCHAR FAR *                       IStrings[];
extern TCHAR FAR *                       StarStrings[];
extern TCHAR *                           ArgList[];
extern SHORT                             ArgPos[];
extern TCHAR *                           SwitchList[];
extern SHORT                             SwitchPos[];
extern TCHAR FAR *                       BigBuf;
extern TCHAR                             Buffer[];
extern SHORT                             Argc;
extern TCHAR **                          Argv;
extern HANDLE                            g_hStdOut;
extern HANDLE                            g_hStdErr;


/* Typedefs */

typedef struct switchtab {
        TCHAR * cmd_line;
        TCHAR * translation;
        int arg_ok;  /*  Takes values NO_ARG, ARG_OPT, ARG_REQ.  See below */
} SWITCHTAB;

#define  KNOWN_SVC_NOTFOUND      0
#define  KNOWN_SVC_MESSENGER     1
#define  KNOWN_SVC_WKSTA	 2
#define  KNOWN_SVC_SERVER	 3
#define  KNOWN_SVC_ALERTER	 4
#define  KNOWN_SVC_NETLOGON 	 5

/* structure used to associate a service name (keyname) to a type manifest */
typedef struct SVC_MAP_ {
    TCHAR *name ;
    UINT type ;
} SVC_MAP ;


/* Structs for output messages */

typedef TCHAR * MSGTEXT;

typedef struct msg_struct
{
    DWORD           msg_number;
    MSGTEXT         msg_text;
}
MESSAGE;

typedef MESSAGE MESSAGELIST[];



/* Macro definitions */

#define DOSNEAR
#undef  FASTCALL
#define FASTCALL

/* Maximum message size retrieved by GetMessageList. */

#define       MSGLST_MAXLEN   (128*sizeof(TCHAR))

/* convert from NEAR to FAR TCHAR * */
#define nfc(x) ((TCHAR FAR *)(x == NULL ? 0 : x))

/*
 * Total time for timeout on ServiceControl APIs is
 *           MAXTRIES * SLEEP_TIME
 */
#define MAXTRIES                        8               /* times to try API */
#define SLEEP_TIME                      2500L   /* sec sleep between tries */

/*
 * For Installing Services, default values are
 */
#define IP_MAXTRIES             8
#define IP_SLEEP_TIME           2500L
#define IP_WAIT_HINT_TO_MS      100

/* 
 * macros to getting service checkpoints and hints
 */
#define GET_HINT(code) \
    (IP_WAIT_HINT_TO_MS * SERVICE_NT_WAIT_GET(code))

#define GET_CHECKPOINT(code) ((DWORD)(code & SERVICE_IP_CHKPT_NUM))


/*
 * Values for arg_ok in the SWITCHTAB
 */
#define NO_ARG                          0
#define ARG_OPT                         1
#define ARG_REQ                         2


/*
 * For confirming numeric switch arguments
 */
#define MAX_US_VALUE            0xFFFF  /* maximum value in an USHORT */
#define ASCII_US_LEN            5               /* number of TCHAR in max USHORT */
#define MAX_UL_VALUE            0xFFFFFFFF      /* max value in ULONG */
#define ASCII_UL_LEN            10              /* number of TCHAR in max ULONG */
#define ASCII_MAX_UL_VAL        TEXT("4294967295")    /* max ascii val of ULONG  */

#include "netascii.h"
#include <tchar.h>

#define LOOP_LIMIT              3               /*
                                                 * max times user can enter passowrds,
                                                 * usernames, compnames, Y/N, etc.
                                                 */
#define FALSE                   0
#define TRUE                    1
#define UNKNOWN                 -2
#define YES                     1
#define NO                      2
#define BIG_BUF_SIZE            4096
#define FULL_SEG_BUF            65535
#define LITTLE_BUF_SIZE         1024
#define TEXT_BUF_SIZE           241

#define LIST_SIZE                       256      /* ArgList and SwitchList */
#define CR                                      0xD

#define YES_KEY                         TEXT('Y')
#define NO_KEY                          TEXT('N')

#define NET_KEYWORD                     TEXT("NET")
#define NET_KEYWORD_SIZE        (sizeof(NET_KEYWORD) -1)        /* don't want null terminator */
#define MAX_MSGID                       9999

#define DEFAULT_SERVER          NULL


/* use */
VOID use_display_all(VOID);
VOID use_unc(TCHAR *);
VOID use_display_dev(TCHAR *);
VOID use_add(TCHAR *, TCHAR *, TCHAR *, int, int);
void use_add_home(TCHAR *, TCHAR *);
VOID use_del(TCHAR *, BOOL, int);
VOID use_set_remembered(VOID) ;
#ifdef IBM_ONLY
VOID use_add_alias(TCHAR *, TCHAR *, TCHAR *, int, int);
#endif /* IBM_ONLY */

/* start */
#define START_ALREADY_STARTED   1
#define START_STARTED                   2
VOID start_display(VOID);
VOID start_generic(TCHAR *, TCHAR *) ;
VOID start_workstation(TCHAR *);
VOID start_badcname(TCHAR *, TCHAR *);
VOID start_other(TCHAR *, TCHAR *);
int PASCAL start_autostart(TCHAR *);

/* stop */
VOID stop_server(VOID);
VOID stop_workstation(VOID);
VOID stop_service(TCHAR *, BOOL fStopDependent);
VOID stop_generic(TCHAR *);

/* message */
VOID name_display(VOID);
VOID name_add(TCHAR *);
VOID name_del(TCHAR *);
VOID send_direct(TCHAR *);
VOID send_domain(int);
VOID send_users(VOID);
VOID send_broadcast(int);

/* user */
VOID user_enum(VOID);
VOID user_display(TCHAR *);
VOID user_add(TCHAR *, TCHAR *);
VOID user_del(TCHAR *);
VOID user_change(TCHAR *, TCHAR *);

/* stats */
VOID stats_display(VOID);
VOID stats_wksta_display(VOID);
VOID stats_server_display(VOID);
VOID stats_generic_display(TCHAR *);
VOID stats_clear(TCHAR *);

/* share */
VOID share_display_all(VOID);
VOID share_display_share(TCHAR *);
VOID share_add(TCHAR *, TCHAR *, int);
VOID share_del(TCHAR *);
VOID share_change(TCHAR *);
VOID share_admin(TCHAR *);

/* view */
VOID view_display (TCHAR *);

/* who */
VOID who_network(int);
VOID who_machine(TCHAR *);
VOID who_user(TCHAR *);

/* access */
VOID access_display(TCHAR *);
VOID access_display_resource(TCHAR *);
VOID access_add(TCHAR *);
VOID access_del(TCHAR *);
VOID access_grant(TCHAR *);
VOID access_revoke(TCHAR *);
VOID access_change(TCHAR *);
VOID access_trail(TCHAR *);
VOID access_audit(TCHAR *);

/* file */
extern VOID files_display (TCHAR *);
extern VOID files_close (TCHAR *);

/* session */
VOID session_display (TCHAR *);
VOID session_del (TCHAR *);
VOID session_del_all (int, int);

/* group */
VOID group_enum(VOID);
VOID group_display(TCHAR *);
VOID group_change(TCHAR *);
VOID group_add(TCHAR *);
VOID group_del(TCHAR *);
VOID group_add_users(TCHAR *);
VOID group_del_users(TCHAR *);

VOID ntalias_enum(VOID) ;
VOID ntalias_display(TCHAR * ntalias) ;
VOID ntalias_add(TCHAR * ntalias) ;
VOID ntalias_change(TCHAR * ntalias) ;
VOID ntalias_del(TCHAR * ntalias) ;
VOID ntalias_add_users(TCHAR * ntalias) ;
VOID ntalias_del_users(TCHAR * ntalias) ;

/* print */
VOID print_job_status(TCHAR  *,TCHAR *);
VOID print_job_del(TCHAR  * , TCHAR *);
VOID print_job_hold(TCHAR  * , TCHAR *);
VOID print_job_release(TCHAR  * , TCHAR *);
VOID print_job_pos(TCHAR *);
VOID print_job_dev_hold(TCHAR  *, TCHAR *);
VOID print_job_dev_release(TCHAR  *, TCHAR *);
VOID print_job_dev_del(TCHAR  *, TCHAR *);
VOID print_job_dev_display(TCHAR  *, TCHAR *);
VOID print_q_display(TCHAR  *);
VOID print_device_display(TCHAR  *);
VOID print_server_display(TCHAR  *);

// Used by print_lan_mask()
#define NETNAME_SERVER 0
#define NETNAME_WKSTA 1

VOID
print_lan_mask(
    DWORD Mask,
    DWORD ServerOrWksta
    );


/* time */
VOID time_display_server(TCHAR FAR *, BOOL);
VOID time_display_dc(BOOL);
VOID time_display_rts(BOOL, BOOL);
VOID time_set_rts(VOID) ;
VOID time_get_sntp(TCHAR FAR *) ;
VOID time_set_sntp(TCHAR FAR *) ;

/* computer */
VOID computer_add(TCHAR *);
VOID computer_del(TCHAR *);

/* mutil */
VOID   FASTCALL InfoSuccess(void);
VOID   FASTCALL InfoPrint(DWORD);
VOID   FASTCALL InfoPrintIns(DWORD, DWORD);
VOID   FASTCALL InfoPrintInsTxt(DWORD, LPTSTR);
VOID   FASTCALL InfoPrintInsHandle(DWORD, DWORD, HANDLE);
DWORD  FASTCALL PrintMessage(HANDLE, LPTSTR, DWORD, LPTSTR *, DWORD);
DWORD  FASTCALL PrintMessageIfFound(HANDLE, LPTSTR, DWORD, LPTSTR *, DWORD);
VOID   FASTCALL ErrorPrint(DWORD, DWORD);
VOID   FASTCALL EmptyExit(VOID);
VOID   FASTCALL ErrorExit(DWORD);
VOID   FASTCALL ErrorExitIns(DWORD, DWORD);
VOID   FASTCALL ErrorExitInsTxt(DWORD, LPTSTR);
VOID   FASTCALL NetcmdExit(int);
VOID   FASTCALL MyExit(int);
VOID   FASTCALL PrintLine(VOID);
VOID   FASTCALL PrintDot(VOID);
VOID   FASTCALL PrintNL(VOID);
int    FASTCALL YorN(USHORT, USHORT);
VOID   FASTCALL ReadPass(TCHAR[], DWORD, DWORD, DWORD, DWORD, BOOL);
VOID   FASTCALL PromptForString(DWORD, LPTSTR, DWORD);
VOID   FASTCALL NetNotStarted(VOID);
void   FASTCALL GetMessageList(USHORT, MESSAGELIST, PDWORD);
void   FASTCALL FreeMessageList(USHORT, MESSAGELIST);
DWORD  FASTCALL SizeOfHalfWidthString(PWCHAR pwch);
LPWSTR FASTCALL PaddedString(int size, PWCHAR pwch, PWCHAR buffer);

/* svcutil */
VOID Print_UIC_Error(USHORT, USHORT, LPTSTR);
VOID Print_ServiceSpecificError(ULONG) ;

/* util */

DWORD  FASTCALL                 GetSAMLocation(TCHAR *, 
                                               USHORT, 
                                               TCHAR *,
                                               ULONG,
                                               BOOL);
VOID   FASTCALL                 CheckForLanmanNT(VOID);
VOID   FASTCALL                 DisplayAndStopDependentServices(TCHAR *service) ;
LPTSTR FASTCALL                 MapServiceDisplayToKey(TCHAR *displayname) ;
LPTSTR FASTCALL                 MapServiceKeyToDisplay(TCHAR *keyname) ;
UINT   FASTCALL                 FindKnownService(TCHAR * keyname) ;
VOID                            AddToMemClearList(VOID *lpBuffer,
                                                  UINT  nSize,
                                                  BOOL  fDelete) ;
VOID                            ClearMemory(VOID) ;


VOID         FASTCALL PermMap(DWORD, TCHAR [], DWORD);
VOID         FASTCALL ExtractServernamef(TCHAR FAR *, TCHAR FAR *);
TCHAR *      FASTCALL FindColon(TCHAR FAR *);
VOID         FASTCALL KillConnections(VOID);
USHORT       FASTCALL do_atou(TCHAR *, USHORT, TCHAR *);
ULONG        FASTCALL do_atoul(TCHAR *, USHORT, TCHAR *);
USHORT       FASTCALL n_atou(TCHAR *, USHORT *);
USHORT       FASTCALL n_atoul(TCHAR *, ULONG *);
VOID         FASTCALL ShrinkBuffer(VOID);
unsigned int FASTCALL MakeBiggerBuffer(VOID);

#define DOS_PRINT_JOB_ENUM 0
#define DOS_PRINT_Q_ENUM   1

DWORD FASTCALL CallDosPrintEnumApi(DWORD, LPTSTR, LPTSTR, WORD, LPWORD, LPWORD);


/* switches */
int FASTCALL CheckSwitch(TCHAR *);
int FASTCALL ValidateSwitches(USHORT, SWITCHTAB[]);
int FASTCALL sw_compare(TCHAR *, TCHAR *);
int FASTCALL onlyswitch(TCHAR *);
int FASTCALL oneswitch(VOID);
int FASTCALL twoswitch(VOID);
int FASTCALL noswitch(VOID);
int FASTCALL noswitch_optional(TCHAR *);
int FASTCALL oneswitch_optional(TCHAR *);
int FASTCALL IsAdminCommand(VOID);
int FASTCALL firstswitch(TCHAR *);

/* grammar */
int IsAdminShare(TCHAR *);
int IsComputerName(TCHAR *);
int IsDomainName(TCHAR *);
int IsComputerNameShare(TCHAR *);
int IsPathname(TCHAR *);
int IsPathnameOrUNC(TCHAR *);
int IsDeviceName(TCHAR *);
int IsMsgid(TCHAR *);
int IsNumber(TCHAR *);
int IsAbsolutePath(TCHAR *);
int IsAccessSetting(TCHAR *);
int IsShareAssignment(TCHAR *);
int IsAnyShareAssign(TCHAR *);
int IsPrintDest(TCHAR *);
int IsValidAssign(TCHAR *);
int IsAnyValidAssign(TCHAR *);
int IsResource(TCHAR *);
int IsNetname(TCHAR *);
int IsUsername(TCHAR *);
int IsQualifiedUsername(TCHAR *);
int IsGroupname(TCHAR *);
int IsNtAliasname(TCHAR *);
int IsPassword(TCHAR *);
int IsSharePassword(TCHAR *);
int IsMsgname(TCHAR *);
int IsAliasname(TCHAR *);
int IsWildCard(TCHAR *);
int IsQuestionMark(TCHAR *);

/* config */
VOID config_display(VOID);
VOID config_wksta_display(VOID);
VOID config_server_display(VOID);
VOID config_generic_display(TCHAR *);
VOID config_wksta_change(VOID);
VOID config_server_change(VOID);
VOID config_generic_change(TCHAR *);


/* continue and pause */
VOID cont_workstation(VOID);
VOID paus_workstation(VOID);
VOID cont_other(TCHAR *);
VOID paus_other(TCHAR *);
VOID paus_print(TCHAR FAR *);
VOID cont_print(TCHAR FAR *);
VOID paus_all_print(VOID);
VOID cont_all_print(VOID);
VOID paus_generic(TCHAR *);
VOID cont_generic(TCHAR *);

#ifdef DOS3
VOID cont_prdr(VOID);
VOID paus_prdr(VOID);
VOID cont_drdr(VOID);
VOID paus_drdr(VOID);
#endif /* DOS3 */

/* help */
#define ALL             1
#define USAGE_ONLY      0
#define OPTIONS_ONLY    2

VOID NEAR pascal help_help       (SHORT, SHORT);
VOID NEAR pascal help_helpmsg   (TCHAR *);



/* accounts */
VOID    accounts_display(VOID);
VOID    accounts_change(VOID);

/* user time */
typedef UCHAR WEEK[7][3];

DWORD   parse_days_times(LPTSTR, PUCHAR);
int     UnicodeCtime(PULONG, LPTSTR, int);
int     UnicodeCtimeWorker(PULONG, LPTSTR, int, int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\net1.c ===
//
// Dummy file to make build happy.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\nwsupp.c ===
/********************************************************************/
/**         Microsoft LAN Manager              **/
/**       Copyright(c) Microsoft Corp., 1987-1990      **/
/********************************************************************/

/***
 *  usernw.c
 *      FPNW/DSM user properties
 *
 *  History:
 *  08/20/95, chuckc, split off from user.c
 */

/*---- Include files ----*/
#include <nt.h>        // base definitions
#include <ntrtl.h>
#include <nturtl.h>    // these 2 includes allows <windows.h> to compile.
                       // since we'vealready included NT, and <winnt.h> will
                       // not be picked up, and <winbase.h> needs these defs.


#define INCL_NOCOMMON
#define INCL_DOSFILEMGR
#define INCL_ERRORS
#include <os2.h>
#include <lmcons.h>
#include <lmerr.h>
#include <apperr2.h>
#include <apperr.h>
#define INCL_ERROR_H
#include <lmaccess.h>
#include "netcmds.h"
#include "nettext.h"

#include "nwsupp.h"
#include <usrprop.h>

/*---- Constants ----*/

#define FPNWCLNT_DLL_NAME                 TEXT("FPNWCLNT.DLL")
#define NWAPI32_DLL_NAME                  TEXT("NWAPI32.DLL")

#define SETUSERPROPERTY_NAME              "SetUserProperty"
#define RETURNNETWAREFORM_NAME            "ReturnNetwareForm"
#define GETNCPSECRETKEY_NAME              "GetNcpSecretKey"
#define QUERYUSERPROPERTY_NAME            "QueryUserProperty"
#define ATTACHTOFILESERVER_NAME           "NWAttachToFileServerW"
#define DETACHFROMFILESERVER_NAME         "NWDetachFromFileServer"
#define GETFILESERVERDATEANDTIME_NAME     "NWGetFileServerDateAndTime"


typedef NTSTATUS (*PF_GetNcpSecretKey) (
    CHAR *pSecret) ;

typedef NTSTATUS (*PF_ReturnNetwareForm) (
    const CHAR * pszSecretValue,
    DWORD dwUserId,
    const WCHAR * pchNWPassword,
    UCHAR * pchEncryptedNWPassword);

typedef NTSTATUS (*PF_SetUserProperty) (
    LPWSTR             UserParms,
    LPWSTR             Property,
    UNICODE_STRING     PropertyValue,
    WCHAR              PropertyFlag,
    LPWSTR *           pNewUserParms,
    BOOL *             Update );


typedef NTSTATUS (*PF_QueryUserProperty) (
    LPWSTR          UserParms,
    LPWSTR          Property,
    PWCHAR          PropertyFlag,
    PUNICODE_STRING PropertyValue );

typedef USHORT (*PF_AttachToFileServer) (
    const WCHAR             *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE           *phNewConn
    );


typedef USHORT (*PF_DetachFromFileServer) (
    NWCONN_HANDLE           hConn
    );


typedef USHORT (*PF_GetFileServerDateAndTime) (
    NWCONN_HANDLE           hConn,
    BYTE                    *year,
    BYTE                    *month,
    BYTE                    *day,
    BYTE                    *hour,
    BYTE                    *minute,
    BYTE                    *second,
    BYTE                    *dayofweek
    );

/*---- Static variables ----*/


/*---- Forward declarations ----*/

PVOID LoadNwApi32Function(
    CHAR *function) ;

PVOID LoadNwslibFunction(
    CHAR *function) ;

NTSTATUS NetcmdGetNcpSecretKey (
    CHAR *pSecret) ;

NTSTATUS NetcmdReturnNetwareForm (
    const CHAR * pszSecretValue,
    DWORD dwUserId,
    const WCHAR * pchNWPassword,
    UCHAR * pchEncryptedNWPassword);

NTSTATUS NetcmdSetUserProperty (
    LPWSTR             UserParms,
    LPWSTR             Property,
    UNICODE_STRING     PropertyValue,
    WCHAR              PropertyFlag,
    LPWSTR *           pNewUserParms,
    BOOL *             Update );

/*
NTSTATUS NetcmdQueryUserProperty (
    LPWSTR          UserParms,
    LPWSTR          Property,
    PWCHAR          PropertyFlag,
    PUNICODE_STRING PropertyValue );
*/

/*---- functions proper -----*/

/***
 *   SetNetWareProperties
 *
 *   Args:
 *       user_entry    - USER3 structure. we will modify the user parms field
 *       password      - in plain text
 *       password_only - TRUE if we are only setting the passwd
 *       ntas          - TRUE if target SAM is NTAS. used for RID munging.
 *
 *   Returns:
 *       NERR_Success if all is well. APE_CannotSetNW otherwise.
 */
int SetNetWareProperties(LPUSER_INFO_3 user_entry,
                         TCHAR         *password,
                         BOOL          password_only,
                         BOOL          ntas)
{
    BOOL fUpdate, fIsSupervisor ;
    LPTSTR lpNewUserParms ;
    USHORT ushTemp ;
    UNICODE_STRING uniTmp;
    NTSTATUS status ;
    LARGE_INTEGER currentTime;
    TCHAR *ptr ;
    ULONG objectId ;
    BYTE lsaSecret[NCP_LSA_SECRET_LENGTH] ;
    WCHAR encryptedPassword[NWENCRYPTEDPASSWORDLENGTH +1] ;

    ptr = user_entry->usri3_parms ;

    //
    // Get Object ID. Set high bit if NTAS. Set to well known if Supervisor.
    //
    objectId = user_entry->usri3_user_id ;
    if (ntas)
        objectId |= 0x10000000 ;

    fIsSupervisor = !_tcsicmp(user_entry->usri3_name, SUPERVISOR_NAME_STRING);
    if (fIsSupervisor)
        objectId = SUPERVISOR_USERID ;

    //
    // get LSA secret. assume FPNW not installed if not there. use the
    // secret to calculate the NetWare form.
    //
    status = NetcmdGetNcpSecretKey(lsaSecret) ;
    if (!NT_SUCCESS(status))
        return(APE_FPNWNotInstalled) ;

    memset(encryptedPassword, 0, sizeof(encryptedPassword)) ;
    status = NetcmdReturnNetwareForm( lsaSecret,
                                      objectId,
                                      password,
                                      (BYTE *)encryptedPassword );
    if (!NT_SUCCESS(status))
        goto common_exit ;

    //
    // get time for setting expiry.
    //
    status = NtQuerySystemTime (&currentTime);
    if (!NT_SUCCESS(status))
        goto common_exit ;

    uniTmp.Buffer = (PWCHAR) &currentTime;
    uniTmp.Length = sizeof (LARGE_INTEGER);
    uniTmp.MaximumLength = sizeof (LARGE_INTEGER);

    status = NetcmdSetUserProperty (ptr,
                                    NWTIMEPASSWORDSET,  // set time
                                    uniTmp,
                                    USER_PROPERTY_TYPE_ITEM,
                                    &lpNewUserParms,
                                    &fUpdate);
    if (!NT_SUCCESS(status))
        goto common_exit ;

    ptr = lpNewUserParms ;

    //
    // skip below if we are only setting the password
    //
    if (!password_only)
    {
        ushTemp = DEFAULT_MAXCONNECTIONS;
        uniTmp.Buffer = &ushTemp;
        uniTmp.Length = 2;
        uniTmp.MaximumLength = 2;

        status = NetcmdSetUserProperty (ptr,
                                        MAXCONNECTIONS,
                                        uniTmp,
                                        USER_PROPERTY_TYPE_ITEM,
                                        &lpNewUserParms,
                                        &fUpdate);
        if (!NT_SUCCESS(status))
            goto common_exit ;

        ptr = lpNewUserParms ;
        ushTemp = DEFAULT_GRACELOGINALLOWED;
        uniTmp.Buffer = &ushTemp;
        uniTmp.Length = 2;
        uniTmp.MaximumLength = 2;

        status = NetcmdSetUserProperty (ptr,
                                        GRACELOGINALLOWED,
                                        uniTmp,
                                        USER_PROPERTY_TYPE_ITEM,
                                        &lpNewUserParms,
                                        &fUpdate);
        if (!NT_SUCCESS(status))
            goto common_exit ;

        ptr = lpNewUserParms ;
        ushTemp = DEFAULT_GRACELOGINREMAINING ;
        uniTmp.Buffer = &ushTemp;
        uniTmp.Length = 2;
        uniTmp.MaximumLength = 2;

        status = NetcmdSetUserProperty (ptr,
                                        GRACELOGINREMAINING,
                                        uniTmp,
                                        USER_PROPERTY_TYPE_ITEM,
                                        &lpNewUserParms,
                                        &fUpdate);
        if (!NT_SUCCESS(status))
            goto common_exit ;

        ptr = lpNewUserParms ;
        uniTmp.Buffer = NULL;
        uniTmp.Length =  0;
        uniTmp.MaximumLength = 0;

        status = NetcmdSetUserProperty (ptr,
                                        NWHOMEDIR,
                                        uniTmp,
                                        USER_PROPERTY_TYPE_ITEM,
                                        &lpNewUserParms,
                                        &fUpdate);
        if (!NT_SUCCESS(status))
            goto common_exit ;

        ptr = lpNewUserParms ;
        uniTmp.Buffer = NULL;
        uniTmp.Length =  0;
        uniTmp.MaximumLength = 0;

        status = NetcmdSetUserProperty (ptr,
                                        NWLOGONFROM,
                                        uniTmp,
                                        USER_PROPERTY_TYPE_ITEM,
                                        &lpNewUserParms,
                                        &fUpdate);
        if (!NT_SUCCESS(status))
            goto common_exit ;

        user_entry->usri3_flags |= UF_MNS_LOGON_ACCOUNT;

        ptr = lpNewUserParms ;
    }

    uniTmp.Buffer =         encryptedPassword ;
    uniTmp.Length =         NWENCRYPTEDPASSWORDLENGTH * sizeof(WCHAR);
    uniTmp.MaximumLength =  NWENCRYPTEDPASSWORDLENGTH * sizeof(WCHAR);

    status = NetcmdSetUserProperty (ptr,
                                    NWPASSWORD,
                                    uniTmp,
                                    USER_PROPERTY_TYPE_ITEM,
                                    &lpNewUserParms,
                                    &fUpdate);
    if (!NT_SUCCESS(status))
        goto common_exit ;

    user_entry->usri3_parms = lpNewUserParms ;

common_exit:

    return(NT_SUCCESS(status) ? NERR_Success : APE_CannotSetNW) ;
}

/***
 *   DeleteNetWareProperties
 *
 *   Args:
 *       user_entry    - USER3 structure. we will modify the user parms field
 *                       to nuke the NW fields.
 *
 *   Returns:
 *       NERR_Success if all is well. Win32/NERR error code otherwise.
 */
int DeleteNetWareProperties(LPUSER_INFO_3 user_entry)
{
    DWORD err;
    UNICODE_STRING uniNullProperty;
    BOOL fUpdate ;
    LPTSTR lpNewUserParms ;
    TCHAR *ptr ;

    //
    // initialize NULL unicode string
    //
    uniNullProperty.Buffer = NULL;
    uniNullProperty.Length = 0;
    uniNullProperty.MaximumLength = 0;
    ptr = user_entry->usri3_parms ;

    //
    // set all the properties to NULL
    //
    err = NetcmdSetUserProperty(ptr, NWPASSWORD, uniNullProperty,
                          USER_PROPERTY_TYPE_ITEM, &lpNewUserParms, &fUpdate) ;
    if (err)
        return err;

    ptr = lpNewUserParms ;
    err = NetcmdSetUserProperty(ptr, MAXCONNECTIONS, uniNullProperty,
                          USER_PROPERTY_TYPE_ITEM, &lpNewUserParms, &fUpdate) ;
    if (err)
        return err;

    ptr = lpNewUserParms ;
    err = NetcmdSetUserProperty(ptr, NWTIMEPASSWORDSET, uniNullProperty,
                          USER_PROPERTY_TYPE_ITEM, &lpNewUserParms, &fUpdate) ;
    if (err)
        return err;

    ptr = lpNewUserParms ;
    err = NetcmdSetUserProperty(ptr, GRACELOGINALLOWED, uniNullProperty,
                          USER_PROPERTY_TYPE_ITEM, &lpNewUserParms, &fUpdate) ;
    if (err)
        return err;

    ptr = lpNewUserParms ;
    err = NetcmdSetUserProperty(ptr, GRACELOGINREMAINING, uniNullProperty,
                          USER_PROPERTY_TYPE_ITEM, &lpNewUserParms, &fUpdate) ;
    if (err)
        return err;

    ptr = lpNewUserParms ;
    err = NetcmdSetUserProperty(ptr, NWLOGONFROM, uniNullProperty,
                          USER_PROPERTY_TYPE_ITEM, &lpNewUserParms, &fUpdate) ;
    if (err)
        return err;

    ptr = lpNewUserParms ;
    err = NetcmdSetUserProperty(ptr, NWHOMEDIR, uniNullProperty,
                          USER_PROPERTY_TYPE_ITEM, &lpNewUserParms, &fUpdate) ;
    if (err)
        return err;

    user_entry->usri3_flags &= ~UF_MNS_LOGON_ACCOUNT;
    user_entry->usri3_parms = lpNewUserParms ;
    return NERR_Success;
}


/***
 *   LoadNwslibFunction
 *
 *   Args:
 *      none
 *
 *   Returns: function pointer if successfully loads the function from
 *            FPNWCLNT.DLL. Returns NULL otherwise.
 *
 */
PVOID LoadNwslibFunction(CHAR *function)
{
    static HANDLE hDllNwslib = NULL ;
    PVOID pFunc ;

    // if not already loaded, load dll now

    if (hDllNwslib == NULL)
    {
        // load the library. if it fails, it would have done a SetLastError.
        if (!(hDllNwslib = LoadLibrary(FPNWCLNT_DLL_NAME)))
           return NULL ;
    }

    return ((PVOID) GetProcAddress(hDllNwslib, function)) ;
}

/***
 *   LoadNwApi32Function
 *
 *   Args:
 *      none
 *
 *   Returns: function pointer if successfully loads the function from
 *            FPNWCLNT.DLL. Returns NULL otherwise.
 *
 */
PVOID LoadNwApi32Function(CHAR *function)
{
    static HANDLE hDllNwApi32 = NULL ;
    PVOID pFunc ;

    // if not already loaded, load dll now

    if (hDllNwApi32 == NULL)
    {
        // load the library. if it fails, it would have done a SetLastError.
        if (!(hDllNwApi32 = LoadLibrary(NWAPI32_DLL_NAME)))
           return NULL ;
    }

    return ((PVOID) GetProcAddress(hDllNwApi32, function)) ;
}

/***
 *   NetcmdGetNcpSecretKey
 *
 *   Args:
 *      see GetNcpSecretKey in fpnwclnt.dll
 *
 *   Returns:
 *       see GetNcpSecretKey in fpnwclnt.dll
 */
NTSTATUS NetcmdGetNcpSecretKey (
    CHAR *pSecret)
{
    static PF_GetNcpSecretKey  pfGetNcpSecretKey  = NULL ;

    if (pfGetNcpSecretKey == NULL)
    {
        pfGetNcpSecretKey = (PF_GetNcpSecretKey)
                                LoadNwslibFunction(GETNCPSECRETKEY_NAME) ;
    }

    if (pfGetNcpSecretKey == NULL)
        return(STATUS_NOT_SUPPORTED) ;

    return (*pfGetNcpSecretKey)(pSecret) ;
}


/***
 *   NetcmdReturnNetwareForm
 *
 *   Args:
 *      see ReturnNetwareForm in fpnwclnt.dll
 *
 *   Returns:
 *       see ReturnNetwareForm in fpnwclnt.dll
 */
NTSTATUS NetcmdReturnNetwareForm (
    const CHAR * pszSecretValue,
    DWORD dwUserId,
    const WCHAR * pchNWPassword,
    UCHAR * pchEncryptedNWPassword)
{
    static PF_ReturnNetwareForm pfReturnNetwareForm = NULL ;

    if (pfReturnNetwareForm == NULL)
    {
        pfReturnNetwareForm = (PF_ReturnNetwareForm)
                                LoadNwslibFunction(RETURNNETWAREFORM_NAME) ;
    }

    if (pfReturnNetwareForm == NULL)
        return(STATUS_NOT_SUPPORTED) ;

    return (*pfReturnNetwareForm)(pszSecretValue,
                                  dwUserId,
                                  pchNWPassword,
                                  pchEncryptedNWPassword) ;
}

/***
 *   NetcmdSetUserProperty
 *
 *   Args:
 *      see SetUserProperty in fpnwclnt.dll
 *
 *   Returns:
 *       see SetUserProperty in fpnwclnt.dll
 */
NTSTATUS NetcmdSetUserProperty (
    LPWSTR             UserParms,
    LPWSTR             Property,
    UNICODE_STRING     PropertyValue,
    WCHAR              PropertyFlag,
    LPWSTR *           pNewUserParms,
    BOOL *             Update )
{
#if 0
    static PF_SetUserProperty pfSetUserProperty = NULL ;

    if (pfSetUserProperty == NULL)
    {
        pfSetUserProperty = (PF_SetUserProperty)
                                LoadNwslibFunction(SETUSERPROPERTY_NAME) ;
    }

    if (pfSetUserProperty == NULL)
        return(STATUS_NOT_SUPPORTED) ;
#endif
    return NetpParmsSetUserProperty(UserParms,
                                    Property,
                                    PropertyValue,
                                    PropertyFlag,
                                    pNewUserParms,
                                    Update) ;
}

/***
 *   NetcmdQueryUserProperty
 *
 *   Args:
 *      see QueryUserProperty in fpnwclnt.dll
 *
 *   Returns:
 *       see QueryUserProperty in fpnwclnt.dll
 */
NTSTATUS NetcmdQueryUserProperty (
    LPWSTR          UserParms,
    LPWSTR          Property,
    PWCHAR          PropertyFlag,
    PUNICODE_STRING PropertyValue )
{
#if 0
    static PF_QueryUserProperty pfQueryUserProperty = NULL ;

    if (pfQueryUserProperty == NULL)
    {
        pfQueryUserProperty = (PF_QueryUserProperty)
                                  LoadNwslibFunction(QUERYUSERPROPERTY_NAME) ;
    }

    if (pfQueryUserProperty == NULL)
        return(STATUS_NOT_SUPPORTED) ;
#endif
    return NetpParmsQueryUserProperty(UserParms,
                                      Property,
                                      PropertyFlag,
                                      PropertyValue) ;
}

USHORT NetcmdNWAttachToFileServerW(
    const WCHAR             *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE           *phNewConn
    )
{
    static PF_AttachToFileServer pfAttachToFileServer = NULL ;

    if (pfAttachToFileServer == NULL)
    {
        pfAttachToFileServer = (PF_AttachToFileServer)
                               LoadNwApi32Function(ATTACHTOFILESERVER_NAME) ;
    }

    if (pfAttachToFileServer == NULL)
        return(ERROR_NOT_SUPPORTED) ;

    return (*pfAttachToFileServer)(pszServerName, ScopeFlag, phNewConn) ;
}


USHORT NetcmdNWDetachFromFileServer(
    NWCONN_HANDLE           hConn
    )
{
    static PF_DetachFromFileServer pfDetachFromFileServer = NULL ;

    if (pfDetachFromFileServer == NULL)
    {
        pfDetachFromFileServer = (PF_DetachFromFileServer)
                                 LoadNwApi32Function(DETACHFROMFILESERVER_NAME) ;
    }

    if (pfDetachFromFileServer == NULL)
        return(ERROR_NOT_SUPPORTED) ;

    return (*pfDetachFromFileServer)(hConn) ;
}


USHORT NetcmdNWGetFileServerDateAndTime(
    NWCONN_HANDLE           hConn,
    BYTE                    *year,
    BYTE                    *month,
    BYTE                    *day,
    BYTE                    *hour,
    BYTE                    *minute,
    BYTE                    *second,
    BYTE                    *dayofweek
    )
{
    static PF_GetFileServerDateAndTime pfGetFileServerDateAndTime = NULL ;

    if (pfGetFileServerDateAndTime == NULL)
    {
        pfGetFileServerDateAndTime = (PF_GetFileServerDateAndTime)
                           LoadNwApi32Function(GETFILESERVERDATEANDTIME_NAME) ;
    }

    if (pfGetFileServerDateAndTime == NULL)
        return(ERROR_NOT_SUPPORTED) ;

    return (*pfGetFileServerDateAndTime)(hConn,
                                         year,
                                         month,
                                         day,
                                         hour,
                                         minute,
                                         second,
                                         dayofweek) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\os2.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    os2.h

Abstract:

    This file maps the LM 2.x include file name to the appropriate NT include
    file name, and does any other mapping required by this include file.

Author:

    Dan Hinsley (danhi) 8-Jun-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

Revision History:

    14-May-1992 JohnRo
        winsvc.h and related file cleanup.

--*/


#ifndef _OS2_
#define _OS2_


#define NOMINMAX
#define NOGDI
#define NOSERVICE       // Avoid <winsvc.h> vs. <lmsvc.h> conflicts.
#include <windows.h>


#endif // ndef _OS2_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\nwsupp.h ===
/*++ 

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    nwsupp.h

Abstract:

    This file contains functions used to support netware functionality.

Environment:

    User Mode - Win32

Notes:

--*/


#ifndef _NWSUPP_
#define _NWSUPP_

#include <crypt.h>

#ifdef __cplusplus
extern "C" {
#endif

#define NWLOCAL_SCOPE USHORT 
#define NWCONN_HANDLE  HANDLE 

//
// below is taken from FPNW
//

#define NWPASSWORD                     L"NWPassword"
#define OLDNWPASSWORD                  L"OldNWPassword"
#define MAXCONNECTIONS                 L"MaxConnections"
#define NWTIMEPASSWORDSET              L"NWPasswordSet"
#define GRACELOGINALLOWED              L"GraceLoginAllowed"
#define GRACELOGINREMAINING            L"GraceLoginRemaining"
#define NWLOGONFROM                    L"NWLogonFrom"
#define NWHOMEDIR                      L"NWHomeDir"

#define USER_PROPERTY_TYPE_ITEM        1
#define USER_PROPERTY_TYPE_SET         2

#define NWENCRYPTEDPASSWORDLENGTH      8
#define SUPERVISOR_USERID	           1
#define SUPERVISOR_NAME_STRING 	       L"Supervisor"
#define NCP_LSA_SECRET_KEY             L"G$MNSEncryptionKey"
#define NCP_LSA_SECRET_LENGTH          USER_SESSION_KEY_LENGTH

#define DEFAULT_MAXCONNECTIONS         0xffff
#define DEFAULT_NWPASSWORDEXPIRED      FALSE
#define DEFAULT_GRACELOGINALLOWED      6
#define DEFAULT_GRACELOGINREMAINING    6
#define DEFAULT_NWLOGONFROM            NULL
#define DEFAULT_NWHOMEDIR              NULL

int SetNetWareProperties(
        LPUSER_INFO_3 user_entry,
        TCHAR         *password,
        BOOL          password_only,
        BOOL          ntas
        );

int DeleteNetWareProperties(
        LPUSER_INFO_3 user_entry
        ) ;

NTSTATUS NetcmdQueryUserProperty (
    LPWSTR          UserParms,
    LPWSTR          Property,
    PWCHAR          PropertyFlag,
    PUNICODE_STRING PropertyValue );

USHORT NetcmdNWAttachToFileServerW(
    const WCHAR             *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE           *phNewConn
    );


USHORT NetcmdNWDetachFromFileServer(
    NWCONN_HANDLE           hConn
    );


USHORT NetcmdNWGetFileServerDateAndTime(
    NWCONN_HANDLE           hConn,
    BYTE                    *year,
    BYTE                    *month,
    BYTE                    *day,
    BYTE                    *hour,
    BYTE                    *minute,
    BYTE                    *second,
    BYTE                    *dayofweek
    );

#ifdef __cplusplus
}
#endif

#endif // _NWSUPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\os2cmd.h ===
typedef struct {
	int key;
	TCHAR *text;
	} KEYTAB;
#define ACCOUNTS 600
#define COMPUTER 601
#define CONFIG 602
#define CONTINUE 603
#define FILE_token 604
#define GROUP 605
#define HELP 606
#define HELPMSG 607
#define NAME 608
#define LOCALGROUP 609
#define PAUSE 610
#define PRINT 611
#define SEND 612
#define SESSION 613
#define SHARE 614
#define START 615
#define STATS 616
#define STOP 617
#define TIME 618
#define USER 619
#define MSG 620
#define NETPOPUP 621
#define REDIR 622
#define SVR 623
#define ALERTER 624
#define NETLOGON 625
#define EOS EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\os2incl.h ===
#define XX_USERLEX lexor
#define XX_USERPARSE os2cmd
#define XX_USERTYPE TCHAR *
#define XX_START 0
#define INTER_FRAME 4
#define INTER_OR 9
extern	TCHAR	XXtype[];
extern	short	XXvalues[];
typedef struct 
{
XX_USERTYPE node;
int token;
} TOKSTACK;
int xxaction(int, TCHAR**);
int xxcondition(int, TCHAR**);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\os2cmd.c ===
#include <windows.h>
#include "os2cmd.h"
KEYTAB KeyTab[] = {
	ACCOUNTS, TEXT("accounts"),
	COMPUTER, TEXT("computer"),
	CONFIG, TEXT("config"),
	CONTINUE, TEXT("continue"),
	CONTINUE, TEXT("cont"),
	FILE_token, TEXT("file"),
	FILE_token, TEXT("files"),
	GROUP, TEXT("group"),
	GROUP, TEXT("groups"),
	HELP, TEXT("help"),
	HELPMSG, TEXT("helpmsg"),
	NAME, TEXT("name"),
	LOCALGROUP, TEXT("localgroup"),
	PAUSE, TEXT("pause"),
	PRINT, TEXT("print"),
	SEND, TEXT("send"),
	SESSION, TEXT("session"),
	SESSION, TEXT("sessions"),
	SESSION, TEXT("sess"),
	SHARE, TEXT("share"),
	START, TEXT("start"),
	STATS, TEXT("stats"),
	STATS, TEXT("statistics"),
	STOP, TEXT("stop"),
	TIME, TEXT("time"),
	USER, TEXT("user"),
	USER, TEXT("users"),
	MSG, TEXT("msg"),
	MSG, TEXT("messenger"),
	MSG, TEXT("receiver"),
	MSG, TEXT("rcv"),
	NETPOPUP, TEXT("netpopup"),
	REDIR, TEXT("redirector"),
	REDIR, TEXT("redir"),
	REDIR, TEXT("rdr"),
	REDIR, TEXT("workstation"),
	REDIR, TEXT("work"),
	REDIR, TEXT("wksta"),
	REDIR, TEXT("prdr"),
	REDIR, TEXT("devrdr"),
	REDIR, TEXT("lanmanworkstation"),
	SVR, TEXT("server"),
	SVR, TEXT("svr"),
	SVR, TEXT("srv"),
	SVR, TEXT("lanmanserver"),
	ALERTER, TEXT("alerter"),
	NETLOGON, TEXT("netlogon"),
	0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\print.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1992          **/
/********************************************************************/

/***
 *      print.c
 *      NET PRINT commands
 *
 *  History:
 *      07/10/87, amar, new code
 *      07/10/87, amar, lots of changes for andy
 *      10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *      12/05/88, erichn, DOS LM integration
 *      01/04/89, erichn, filenames now MAX_PATH LONG
 *      05/02/89, erichn, NLS conversion
 *      05/09/89, erichn, local security mods
 *      05/19/89, thomaspa, NETCMD output sorting
 *      06/08/89, erichn, canonicalization sweep
 *      06/27/89, erichn, replaced old NetI canon calls with new I_Net
 *      09/01/89, thomaspa, use new info levels and PMSPL.H structs
 *      11/07/89, thomaspa, added HURSLEY support
 *      01/29/90, thomaspa, HURSLEY -> IBM_ONLY
 *      02/20/91, danhi, change to use lm 16/32 mapping layer
 *      05/22/91, robdu, LM21 bug 1799 fix
 *      07/20/92, JohnRo, RAID 160: Avoid 64KB requests (be nice to Winball).
 */

/* Include files */

#define INCL_NOCOMMON
#define INCL_DOSDATETIME
#define INCL_DOSERRORS
#define INCL_DOSMEMMGR
#define INCL_DOSFILEMGR
#define INCL_DOSMISC
#define INCL_SPLDOSPRINT

#include <os2.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <apperr.h>
#include <apperr2.h>
#include <lmuse.h>
#include <lui.h>
#include <dlserver.h>
#include <dlwksta.h>
#include "mserver.h"
#include "mwksta.h"
#include "netcmds.h"
#include "nettext.h"
#include "netlib.h"
#include <dosprint.h>
#include <tstring.h>
#include "msystem.h"

/* Constants */

#define MAGIC 0xFFFF

/* Forward declarations */

int NEAR                dscheduled(USHORT, USHORT);
PPRDINFO                NEAR find_print_dev( USHORT );
VOID NEAR               display_one_queue(PPRQINFO);
TCHAR FAR * NEAR        print_findstatus(PPRQINFO,TCHAR FAR *,USHORT);

TCHAR FAR * NEAR        findjobstatus(PPRJINFO,TCHAR FAR *,USHORT);
VOID NEAR               print_printqstruct(PPRQINFO);
VOID NEAR               print_each_job(PPRJINFO);
LPTSTR                  am_pm(USHORT, LPTSTR, DWORD);
VOID NEAR               print_field_header(VOID);  /* Net Name Job# etc */
VOID NEAR               display_core_q(TCHAR *);
int NEAR                print_set_time(TCHAR *, TCHAR *);
int FAR                 CmpPQInfo(const VOID FAR *,const VOID FAR *);
VOID                    InitSortBuf(PPRQINFO FAR *, USHORT, TCHAR FAR *);
DWORD                   GetDateTime(PDATETIME pDateTime);


/* Static variables */

static PPRDINFO         LptDest;
static USHORT           LptDestCnt;

#define TEXTBUFSZ       80
static TCHAR         textbuf[TEXTBUFSZ]; /* Scratch buf for formatting
                                                messages in *_findstatus* */

/***
 *  print_q_display()
 *      NET PRINT \\comp\queue or NET PRINT queue
 *
 *  Args:
 *      TCHAR FAR * queue;
 *
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 */
VOID print_q_display(TCHAR * queue)
{
    DWORD            printer_err;
    DWORD            dwErr;
    USHORT           available;  /* num entries available */
    USHORT           buffer_size;        /* Actual buffer size in bytes. */
    BOOL             first_time = TRUE;
    TCHAR            server_name[MAX_PATH + 1];
    LPTSTR           ptr_to_server;
    LPWKSTA_INFO_10  workstn;

    start_autostart(txt_SERVICE_REDIR);

    if (*queue == '\\')
    {
        /* copy computer name into server name */
        ExtractServernamef(server_name,queue );
        ptr_to_server = server_name;
    }
    else
    {
        ptr_to_server = NULL;

        if (dwErr = MNetWkstaGetInfo(10, (LPBYTE*) &workstn))
        {
            ErrorExit(dwErr);
        }

        _tcscpy(server_name,workstn->wki10_computername);
        NetApiBufferFree((TCHAR *) workstn);
    }

    /* If the regular (4K) buffer is not big enough here, we try the
     * returned buffer size.
     */

    buffer_size = BIG_BUF_SIZE;
    do {
        printer_err = DosPrintQGetInfo(nfc(ptr_to_server),
                            queue,
                            2,
                            (LPBYTE)BigBuf,
                            buffer_size,
                            &available);

        switch(printer_err)
        {
        case NERR_Success:
            break;
        case ERROR_MORE_DATA:
        case NERR_BufTooSmall:
        case ERROR_BUFFER_OVERFLOW:
            if (first_time) {
                if (MakeBiggerBuffer()) {
                    ErrorExit(printer_err);
                }
                first_time = FALSE;
            }

            NetpAssert( available != 0 );
            if (available <= FULL_SEG_BUF)
            {
                if (buffer_size >= available)
                {
                    // if avail<bufsize, wrong err code from downlevel.
                    // if avail=bufsize, bug here or in downlevel?
                    ErrorExit( NERR_InternalError );
                }
                else
                {
                    buffer_size = available;
                }
            }
            else
            {
                // this is just being defensive. currently, should not happen
                // since available is USHORT.
                ErrorExit( NERR_BufTooSmall );
            }
            printer_err = ERROR_MORE_DATA;
            continue;   // Loop and try again.

        case ERROR_NOT_SUPPORTED:
            display_core_q(ptr_to_server);
            return;
        default:
            ErrorExit(printer_err);
            break;          /* NOTE:  This statement should never be reached */
        }
    } while (printer_err == ERROR_MORE_DATA);

    if (available == 0)
        EmptyExit();

    PrintNL();
    InfoPrintInsTxt(APE_PrintQueues, server_name);
    print_field_header();

    display_one_queue((PPRQINFO)BigBuf);
    InfoSuccess();
}



#define PRINT_MSG_JOB_ID                0
#define PRINT_MSG_STATUS                ( PRINT_MSG_JOB_ID + 1 )
#define PRINT_MSG_SIZE                  ( PRINT_MSG_STATUS + 1 )
#define PRINT_MSG_SUBMITTING_USER       ( PRINT_MSG_SIZE + 1 )
#define PRINT_MSG_NOTIFY                ( PRINT_MSG_SUBMITTING_USER + 1 )
#define PRINT_MSG_JOB_DATA_TYPE         ( PRINT_MSG_NOTIFY + 1 )
#define PRINT_MSG_JOB_PARAMETERS        ( PRINT_MSG_JOB_DATA_TYPE + 1 )
#define PRINT_MSG_ADDITIONAL_INFO       ( PRINT_MSG_JOB_PARAMETERS + 1 )
#define MSG_REMARK                      ( PRINT_MSG_ADDITIONAL_INFO + 1 )
#define MSG_UNKNOWN                     ( MSG_REMARK + 1 )

static MESSAGE  PJSMsgList[] = {
{ APE2_PRINT_MSG_JOB_ID,                NULL },
{ APE2_PRINT_MSG_STATUS,                NULL },
{ APE2_PRINT_MSG_SIZE,                  NULL },
{ APE2_PRINT_MSG_SUBMITTING_USER,       NULL },
{ APE2_PRINT_MSG_NOTIFY,                NULL },
{ APE2_PRINT_MSG_JOB_DATA_TYPE,         NULL },
{ APE2_PRINT_MSG_JOB_PARAMETERS,        NULL },
{ APE2_PRINT_MSG_ADDITIONAL_INFO,       NULL },
{ APE2_GEN_REMARK,                      NULL },
{ APE2_GEN_UNKNOWN,                     NULL },
};

#define NUM_PJS_MSGS    (sizeof(PJSMsgList)/sizeof(PJSMsgList[0]))

/***
 *  print_job_status(server,jobnum)
 *
 * NET PRINT job# and NET PRINT \\comp job#
 *
 *  Args:
 *      server : computer name or null if local
 *      jobnum : job_id
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 */
VOID print_job_status(TCHAR  * server, TCHAR  * num)
{
    USHORT          available;/* num entries available */
    DWORD           printer_err;
    USHORT          jobnum;
    DWORD           dwLen;
    PPRJINFO        job_ptr = (PPRJINFO) BigBuf;

    start_autostart(txt_SERVICE_REDIR);

    if (n_atou(num,&jobnum) != 0)
        ErrorExit(APE_PRINT_BadId) ;


    if (printer_err = DosPrintJobGetInfo(nfc(server),
                                server ? TRUE : FALSE,
                                jobnum,
                                1,
                                (LPBYTE)BigBuf,
                                BIG_BUF_SIZE,
                                &available))
    {
        ErrorExit(printer_err);
    }

    GetMessageList(NUM_PJS_MSGS, PJSMsgList, &dwLen);

    dwLen += 5;

    InfoPrint(APE_PrintJobOptions);
    PrintNL();

    WriteToCon(fmtUSHORT, 0, dwLen,
               PaddedString(dwLen, PJSMsgList[PRINT_MSG_JOB_ID].msg_text, NULL),
               job_ptr->uJobId);

    WriteToCon(fmtPSZ, 0, dwLen,
               PaddedString(dwLen, PJSMsgList[PRINT_MSG_STATUS].msg_text, NULL),
               findjobstatus(job_ptr, textbuf, TEXTBUFSZ));

    if (job_ptr->ulSize == (ULONG) -1)
        WriteToCon(fmtNPSZ, 0, dwLen,
                   PaddedString(dwLen, PJSMsgList[PRINT_MSG_SIZE].msg_text, NULL),
                   PJSMsgList[MSG_UNKNOWN].msg_text);
    else
        WriteToCon(fmtULONG, 0, dwLen,
                   PaddedString(dwLen, PJSMsgList[PRINT_MSG_SIZE].msg_text, NULL),
                   job_ptr->ulSize);

    WriteToCon(fmtPSZ, 0, dwLen,
               PaddedString(dwLen, PJSMsgList[MSG_REMARK].msg_text, NULL),
               job_ptr->pszComment);

    WriteToCon(fmtPSZ, 0, dwLen,
               PaddedString(dwLen, PJSMsgList[PRINT_MSG_SUBMITTING_USER].msg_text, NULL),
               job_ptr->szUserName);

    WriteToCon(fmtPSZ, 0, dwLen,
               PaddedString(dwLen, PJSMsgList[PRINT_MSG_NOTIFY].msg_text, NULL),
               job_ptr->szNotifyName);

    WriteToCon(fmtPSZ, 0, dwLen,
               PaddedString(dwLen, PJSMsgList[PRINT_MSG_JOB_DATA_TYPE].msg_text, NULL),
               job_ptr->szDataType);

    WriteToCon(fmtPSZ, 0, dwLen,
               PaddedString(dwLen, PJSMsgList[PRINT_MSG_JOB_PARAMETERS].msg_text, NULL),
               job_ptr->pszParms);

    WriteToCon(fmtPSZ, 0, dwLen,
               PaddedString(dwLen, PJSMsgList[PRINT_MSG_ADDITIONAL_INFO].msg_text, NULL),
               job_ptr->pszStatus);

    InfoSuccess();
}


/***
 *  print_job_del()
 *      NET PRINT \\comp job# /D and
 *      NET PRINT job# /D
 *
 *  Args:
 *      server : computer name ; null if local
 *      jobno  : job_id to be killed
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 */
VOID print_job_del(TCHAR  * server, TCHAR  * num)
{
    unsigned int    err;/* API return status */
    USHORT jobnum;


    start_autostart(txt_SERVICE_REDIR);

    if (n_atou(num,&jobnum) != 0)
        ErrorExit(APE_PRINT_BadId) ;

    if(err = DosPrintJobDel(nfc(server),
                            server ? TRUE : FALSE,
                            jobnum))
        ErrorExit(err);

    InfoSuccess();
}


/***
 *  print_job_hold()
 *      NET PRINT \\comp Jobnum /Hold
 *      NET PRINT jobnum /Hold
 *
 *  Args:
 *      server : server name
 *      jobnum : job id
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 */
VOID print_job_hold(TCHAR * server, TCHAR * num)
{
    unsigned int  err;
    USHORT        jobnum;


    start_autostart(txt_SERVICE_REDIR);

    if (n_atou(num,&jobnum) != 0)
        ErrorExit(APE_PRINT_BadId) ;

    if(err = DosPrintJobPause(nfc(server),
                              server ? TRUE : FALSE,
                              jobnum))
        ErrorExit(err);

    InfoSuccess();
}


/***
 *  print_job_release()
 *      NET PRINT \\comp Jobnum /Release
 *      NET PRINT jobnum /Release
 *
 *  Args:
 *      server : server name
 *      jobnum : job id
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 */
VOID print_job_release(TCHAR * server, TCHAR * num)
{
    unsigned int err;/* API return status */
    USHORT       jobnum;


    start_autostart(txt_SERVICE_REDIR);

    if (n_atou(num,&jobnum) != 0)
        ErrorExit(APE_PRINT_BadId) ;

    if(err = DosPrintJobContinue(nfc(server),
                                 server ? TRUE : FALSE,
                                 jobnum))
        ErrorExit(err);

    InfoSuccess();
}


/***
 *  print_job_dev_del()
 *      NET PRINT device jobnum /Delete
 *
 *  Args:
 *      device : device name
 *      jobnum : job id
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 *
 *  Remarks:
 *      Redirected device only
 */
VOID print_job_dev_del(TCHAR *device, TCHAR *num)
{
    DWORD           dwErr;
    unsigned int    printer_err;
    TCHAR           server[MAX_PATH+1];
    TCHAR           path_name[MAX_PATH];
    LPUSE_INFO_0    temp_use_inf_0;
    USHORT          jobnum;

    start_autostart(txt_SERVICE_REDIR);

    if (n_atou(num,&jobnum) != 0)
        ErrorExit(APE_PRINT_BadId) ;

    if (dwErr = NetUseGetInfo(NULL,
                              device,
                              0,
                             (LPBYTE*)&temp_use_inf_0))
        ErrorExit(dwErr);
    _tcscpy(path_name , temp_use_inf_0->ui0_remote);
    NetApiBufferFree((TCHAR FAR *) temp_use_inf_0);

    /* extract server name */
    ExtractServernamef(server,path_name );

    /* now delete the job in the server */

    if(printer_err = DosPrintJobDel(server,
                                    server ? TRUE : FALSE,
                                    jobnum))
        ErrorExit(printer_err);
    InfoSuccess();
}




/***
 *  print_job_dev_display()
 *      NET PRINT device jobnum
 *
 *  Args:
 *      device : device name
 *      jobnum : job id
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 *
 *  Remarks:
 *      Redirected device only
 */
VOID print_job_dev_display(TCHAR *device, TCHAR *num)
{
    DWORD          dwErr;
    TCHAR          server[MAX_PATH+1];
    TCHAR          path_name[MAX_PATH];
    LPUSE_INFO_0   temp_use_inf_0;

    start_autostart(txt_SERVICE_REDIR);

    if (dwErr = NetUseGetInfo(NULL,
                              device,
                              0,
                              (LPBYTE*)&temp_use_inf_0))
        ErrorExit(dwErr);
    _tcscpy(path_name , temp_use_inf_0->ui0_remote);
    NetApiBufferFree((TCHAR FAR *) temp_use_inf_0);

    /* extract server name */
    ExtractServernamef(server,path_name );

    /* now call print job status */

    print_job_status(server,num);
}





/***
 *  print_job_dev_hold()
 *      NET PRINT device jobnum /Hold
 *
 *  Args:
 *      device : device name
 *      jobnum : job id
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 *
 *  Remarks:
 *      Redirected device only
 */
VOID print_job_dev_hold(TCHAR *device, TCHAR *num)
{
    DWORD         dwErr;
    unsigned int  printer_err;
    TCHAR         server[MAX_PATH+1];
    TCHAR         path_name[MAX_PATH];
    LPUSE_INFO_0  temp_use_inf_0;
    USHORT          jobnum;

    start_autostart(txt_SERVICE_REDIR);

    if (n_atou(num,&jobnum) != 0)
        ErrorExit(APE_PRINT_BadId) ;

    if (dwErr = NetUseGetInfo(NULL,
                              device,
                              0,
                              (LPBYTE*)&temp_use_inf_0))
        ErrorExit(dwErr);
    _tcscpy(path_name, temp_use_inf_0->ui0_remote);
    NetApiBufferFree((TCHAR FAR *) temp_use_inf_0);

    /* extract server name */
    ExtractServernamef(server,path_name );

    /* now pause the job in the server */

    if(printer_err = DosPrintJobPause(server,
                                      server ? TRUE : FALSE,
                                      jobnum))
        ErrorExit(printer_err);
    InfoSuccess();
}


/***
 *  print_job_dev_release()
 *      NET PRINT device jobnum /Release
 *
 *  Args:
 *      device : device name
 *      jobnum : job id
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 *
 *  Remarks:
 *      Redirected device only
 */
VOID print_job_dev_release(TCHAR *device, TCHAR *num)
{
    DWORD         dwErr;
    unsigned int  printer_err;
    TCHAR         server[MAX_PATH+1];
    TCHAR         path_name[MAX_PATH];
    LPUSE_INFO_0  temp_use_inf_0;
    USHORT  jobnum;

    start_autostart(txt_SERVICE_REDIR);

    if (n_atou(num,&jobnum) != 0)
        ErrorExit(APE_PRINT_BadId) ;

    if (dwErr = NetUseGetInfo(NULL,
                              device,
                              0,
                              (LPBYTE*)&temp_use_inf_0))
        ErrorExit(dwErr);
    _tcscpy(path_name, temp_use_inf_0->ui0_remote);
    NetApiBufferFree((TCHAR FAR *) temp_use_inf_0);

    /* extract server name */
    ExtractServernamef(server,path_name );

    /* now continue the job in the server */

    if(printer_err = DosPrintJobContinue(server,
                                         server ? TRUE : FALSE,
                                         jobnum))
        ErrorExit(printer_err);
    InfoSuccess();
}


VOID NEAR display_one_queue(PPRQINFO queue_ptr)
{
    PPRJINFO        job_ptr;
    USHORT  i;

    print_printqstruct(queue_ptr); /* print info for the queue */

    /* advance the correct number of bytes */
    job_ptr = (PPRJINFO)(queue_ptr + 1 );

    /* print info for each job in the queue */

    for(i = queue_ptr->cJobs; i > 0; i--)
    {
        print_each_job(job_ptr);
        job_ptr++;
    }
}


VOID NEAR print_field_header(VOID)
{
    PrintNL();
    InfoPrint(APE2_PRINT_MSG_HDR);
    PrintLine();
}




VOID NEAR print_each_job(PPRJINFO job_ptr)
{
    WriteToCon(TEXT("%5.5ws%Fws%6hu"),
            NULL_STRING,
            PaddedString(23,job_ptr->szUserName,NULL),
            job_ptr->uJobId);

    if (job_ptr->ulSize == (ULONG) -1)
        WriteToCon(TEXT("%10.10ws"), NULL_STRING);
    else
        WriteToCon(TEXT("%10lu"), job_ptr->ulSize);

    WriteToCon(TEXT("%12.12ws%ws\r\n"),
            NULL_STRING,
            findjobstatus(job_ptr, textbuf, TEXTBUFSZ));
}





#define MSG_QUEUE           0
#define PRINT_MSG_JOBS      ( MSG_QUEUE + 1 )

static MESSAGE PQSMsgList[] = {
{ APE2_GEN_QUEUE,           NULL },
{ APE2_PRINT_MSG_JOBS,      NULL },
};

#define NUM_PQS_MSGS    (sizeof(PQSMsgList)/sizeof(PQSMsgList[0]))

VOID
print_printqstruct(
    PPRQINFO queue_ptr
    )
{
    DWORD       len;
    TCHAR       firstbuf[10];
    ULONG       l;
    BOOL        dummy;

    GetMessageList(NUM_PQS_MSGS, PQSMsgList, &len);

    /* Increased the size for the display text. */

    _tcscpy(firstbuf, PaddedString(8, PQSMsgList[MSG_QUEUE].msg_text,NULL));

#ifdef UNICODE

    l = WideCharToMultiByte(GetConsoleOutputCP(),0,
                            (queue_ptr->szName),-1,NULL,0,(const char *)L"?",&dummy);

#else

    l = strlen(queue_ptr->szName);

#endif

    WriteToCon(TEXT("%Fws %ws%*ws%2hu %ws%16.16ws*%ws*\r\n"),
            queue_ptr->szName,
            firstbuf,
            19 - l,
            NULL_STRING,
            queue_ptr->cJobs,
            PaddedString(10, PQSMsgList[PRINT_MSG_JOBS].msg_text,NULL),
            NULL_STRING,
            print_findstatus(queue_ptr,textbuf,TEXTBUFSZ));
}


#define PRINT_MSG_QUEUE_ACTIVE              0
#define PRINT_MSG_QUEUE_PAUSED              ( PRINT_MSG_QUEUE_ACTIVE + 1 )
#define PRINT_MSG_QUEUE_ERROR               ( PRINT_MSG_QUEUE_PAUSED + 1 )
#define PRINT_MSG_QUEUE_PENDING             ( PRINT_MSG_QUEUE_ERROR + 1 )
#define PRINT_MSG_QUEUE_UNSCHED             ( PRINT_MSG_QUEUE_PENDING + 1 )

static MESSAGE PFSMsgList[] = {
{ APE2_PRINT_MSG_QUEUE_ACTIVE,          NULL },
{ APE2_PRINT_MSG_QUEUE_PAUSED,          NULL },
{ APE2_PRINT_MSG_QUEUE_ERROR,           NULL },
{ APE2_PRINT_MSG_QUEUE_PENDING,         NULL },
{ APE2_PRINT_MSG_QUEUE_UNSCHED,         NULL },
};

#define NUM_PFS_MSGS    (sizeof(PFSMsgList)/sizeof(PFSMsgList[0]))

LPTSTR
print_findstatus(
    PPRQINFO qptr,
    LPTSTR   retbuf,
    USHORT   buflen
    )
{
    USHORT          queue_status;
    static USHORT   allocated = FALSE;
    DWORD           err;                    /* API return code */
    DWORD           len;                    /* message format size */
    TCHAR           timebuf[LUI_FORMAT_TIME_LEN + 1];

    if (!allocated)     /* retrieve messages from msg file */
    {
        GetMessageList(NUM_PFS_MSGS, PFSMsgList, &len);
        allocated = TRUE;
    }

    queue_status = qptr->fsStatus & PRQ_STATUS_MASK;

    switch (queue_status)
    {
        case PRQ_ACTIVE:
        {
            if (dscheduled(qptr->uStartTime, qptr->uUntilTime))
            {
                IStrings[0] = am_pm(qptr->uStartTime, timebuf, DIMENSION(timebuf));

                err = DosInsMessageW(
                          IStrings,
                          1,
                          PFSMsgList[PRINT_MSG_QUEUE_UNSCHED].msg_text,
                          _tcslen(PFSMsgList[PRINT_MSG_QUEUE_UNSCHED].msg_text),
                          retbuf,
                          buflen - 1,
                          &len);

                if (err)
                {
                    ErrorExit(err);
                    return(NULL);
                }

                *(retbuf+len) = NULLC;
                return retbuf;
            }
            else
            {
                return PFSMsgList[PRINT_MSG_QUEUE_ACTIVE].msg_text;
            }
        }

        case PRQ_PAUSED:
            return PFSMsgList[PRINT_MSG_QUEUE_PAUSED].msg_text;

        case PRQ_ERROR:
            return PFSMsgList[PRINT_MSG_QUEUE_ERROR].msg_text;

        case PRQ_PENDING:
            return PFSMsgList[PRINT_MSG_QUEUE_PENDING].msg_text;
    }

    /*
     * Active is as good as any return.  Should never get here.
     */
    return PFSMsgList[PRINT_MSG_QUEUE_ACTIVE].msg_text;
}


#define PRINT_MSG_WAITING               0
#define PRINT_MSG_PAUSED_IN_QUEUE       ( PRINT_MSG_WAITING + 1 )
#define PRINT_MSG_SPOOLING              ( PRINT_MSG_PAUSED_IN_QUEUE + 1 )
#define PRINT_MSG_PRINTER_PAUSED        ( PRINT_MSG_SPOOLING + 1 )
#define PRINT_MSG_OUT_OF_PAPER          ( PRINT_MSG_PRINTER_PAUSED + 1 )
#define PRINT_MSG_PRINTER_OFFLINE       ( PRINT_MSG_OUT_OF_PAPER + 1 )
#define PRINT_MSG_PRINTER_ERROR         ( PRINT_MSG_PRINTER_OFFLINE + 1 )
#define PRINT_MSG_PRINTER_INTERV        ( PRINT_MSG_PRINTER_ERROR + 1 )
#define PRINT_MSG_PRINTING              ( PRINT_MSG_PRINTER_INTERV + 1 )
#define PRINT_MSG_PRINTER_PAUSED_ON     ( PRINT_MSG_PRINTING + 1 )
#define PRINT_MSG_OUT_OF_PAPER_ON       ( PRINT_MSG_PRINTER_PAUSED_ON + 1 )
#define PRINT_MSG_PRINTER_OFFLINE_ON    ( PRINT_MSG_OUT_OF_PAPER_ON + 1 )
#define PRINT_MSG_PRINTER_ERROR_ON      ( PRINT_MSG_PRINTER_OFFLINE_ON + 1 )
#define PRINT_MSG_PRINTER_INTERV_ON     ( PRINT_MSG_PRINTER_ERROR_ON + 1 )
#define PRINT_MSG_PRINTING_ON           ( PRINT_MSG_PRINTER_INTERV_ON + 1 )

static MESSAGE FJSMsgList[] = {
{ APE2_PRINT_MSG_WAITING,               NULL },
{ APE2_PRINT_MSG_PAUSED_IN_QUEUE,       NULL },
{ APE2_PRINT_MSG_SPOOLING,              NULL },
{ APE2_PRINT_MSG_PRINTER_PAUSED,        NULL },
{ APE2_PRINT_MSG_OUT_OF_PAPER,          NULL },
{ APE2_PRINT_MSG_PRINTER_OFFLINE,       NULL },
{ APE2_PRINT_MSG_PRINTER_ERROR,         NULL },
{ APE2_PRINT_MSG_PRINTER_INTERV,        NULL },
{ APE2_PRINT_MSG_PRINTING,              NULL },
{ APE2_PRINT_MSG_PRINTER_PAUS_ON,       NULL },
{ APE2_PRINT_MSG_OUT_OF_PAPER_ON,       NULL },
{ APE2_PRINT_MSG_PRINTER_OFFL_ON,       NULL },
{ APE2_PRINT_MSG_PRINTER_ERR_ON,        NULL },
{ APE2_PRINT_MSG_PRINTER_INTV_ON,       NULL },
{ APE2_PRINT_MSG_PRINTING_ON,           NULL },
};

#define NUM_FJS_MSGS     (sizeof(FJSMsgList)/sizeof(FJSMsgList[0]))

TCHAR FAR * NEAR findjobstatus(PPRJINFO jptr, TCHAR FAR * retbuf, USHORT buflen)
{
    PPRDINFO        dest;
    static USHORT   allocated = FALSE;
    DWORD           err;                    /* API return code */
    DWORD           len;                    /* message format size */
    TCHAR FAR       *pMsg;                  /* message to display */
    USHORT          fOnPrinter = FALSE;     /* Is job on printer */

    /* Make sure the buffer is empty */
    memset( retbuf, NULLC, buflen*sizeof(WCHAR) );

    if (!allocated)     /* retrieve messages from msg file */
    {
        GetMessageList(NUM_FJS_MSGS, FJSMsgList, &len);
        allocated = TRUE;
    }

    switch (jptr->fsStatus & PRJ_QSTATUS)
    {
    case PRJ_QS_QUEUED:
        pMsg = FJSMsgList[PRINT_MSG_WAITING].msg_text;
        break;

    case PRJ_QS_PAUSED:
        pMsg = FJSMsgList[PRINT_MSG_PAUSED_IN_QUEUE].msg_text;
        break;

    case PRJ_QS_SPOOLING:
        pMsg = FJSMsgList[PRINT_MSG_SPOOLING].msg_text;
        break;

    case PRJ_QS_PRINTING:
        if ((dest = find_print_dev(jptr->uJobId)) != NULL)
        {
            IStrings[0] = dest->szName;
            fOnPrinter = TRUE;
        }
        if (jptr->fsStatus & PRJ_DESTPAUSED)
            pMsg = fOnPrinter ?
                            FJSMsgList[PRINT_MSG_PRINTER_PAUSED_ON].msg_text
                            : FJSMsgList[PRINT_MSG_PRINTER_PAUSED].msg_text;
        else if (jptr->fsStatus & PRJ_DESTNOPAPER)
            pMsg = fOnPrinter ?
                            FJSMsgList[PRINT_MSG_OUT_OF_PAPER_ON].msg_text
                            : FJSMsgList[PRINT_MSG_OUT_OF_PAPER].msg_text;
        else if (jptr->fsStatus & PRJ_DESTOFFLINE)
            pMsg = fOnPrinter ?
                            FJSMsgList[PRINT_MSG_PRINTER_OFFLINE_ON].msg_text
                            : FJSMsgList[PRINT_MSG_PRINTER_OFFLINE].msg_text;
        else if (jptr->fsStatus & PRJ_ERROR)
            pMsg = fOnPrinter ?
                            FJSMsgList[PRINT_MSG_PRINTER_ERROR_ON].msg_text
                            : FJSMsgList[PRINT_MSG_PRINTER_ERROR].msg_text;
        else if (jptr->fsStatus & PRJ_INTERV)
            pMsg = fOnPrinter ?
                            FJSMsgList[PRINT_MSG_PRINTER_INTERV_ON].msg_text
                            : FJSMsgList[PRINT_MSG_PRINTER_INTERV].msg_text;
        else
            pMsg = fOnPrinter ?
                            FJSMsgList[PRINT_MSG_PRINTING_ON].msg_text
                            : FJSMsgList[PRINT_MSG_PRINTING].msg_text;
        break;
    }

    if (err = DosInsMessageW(IStrings,
                             (fOnPrinter ? 1 : 0),
                             pMsg,
                             _tcslen(pMsg),
                             retbuf,
                             buflen,
                             &len))
    {
        ErrorExit(err);
    }

    return retbuf;
}


/* print rountine to print the options of a given queue */

#define PQO_MSG_STATUS              0
#define PRINT_MSG_DEVS              ( PQO_MSG_STATUS + 1 )
#define PRINT_MSG_SEPARATOR         ( PRINT_MSG_DEVS + 1 )
#define PRINT_MSG_PRIORITY          ( PRINT_MSG_SEPARATOR + 1 )
#define PRINT_MSG_AFTER             ( PRINT_MSG_PRIORITY + 1 )
#define PRINT_MSG_UNTIL             ( PRINT_MSG_AFTER + 1 )
#define PRINT_MSG_PROCESSOR         ( PRINT_MSG_UNTIL + 1 )
#define PRINT_MSG_PARMS             ( PRINT_MSG_PROCESSOR + 1 )
#define PRINT_MSG_DRIVER            ( PRINT_MSG_PARMS + 1 )
#define PQO_MSG_REMARK              ( PRINT_MSG_DRIVER + 1 )

static MESSAGE PrOptMsgList[] = {
{ APE2_PRINT_MSG_STATUS,            NULL },
{ APE2_PRINT_MSG_DEVS,              NULL },
{ APE2_PRINT_MSG_SEPARATOR,         NULL },
{ APE2_PRINT_MSG_PRIORITY,          NULL },
{ APE2_PRINT_MSG_AFTER,             NULL },
{ APE2_PRINT_MSG_UNTIL,             NULL },
{ APE2_PRINT_MSG_PROCESSOR,         NULL },
{ APE2_PRINT_MSG_PARMS,             NULL },
{ APE2_PRINT_MSG_DRIVER,            NULL },
{ APE2_GEN_REMARK,                  NULL },
};
#define NUM_PROPT_MSGS  (sizeof(PrOptMsgList)/sizeof(PrOptMsgList[0]))


/* returns the time of day as a CHARacter string */
LPTSTR
am_pm(
    USHORT time,
    LPTSTR dest,
    DWORD  buflen
    )
{
    time_t seconds;

    seconds = (LONG) time;
    seconds *= 60;

    FormatTimeofDay(&seconds, dest, buflen);

    return dest;
}


VOID
display_core_q(
    LPTSTR server
    )
{
    WORD         num_read;
    WORD         avail;
    unsigned int err;
    PPRJINFO     job_ptr;
    DWORD        i;

    if (err = CallDosPrintEnumApi(DOS_PRINT_JOB_ENUM, server, NULL_STRING,
                                  1, &num_read, &avail))
    {
        ErrorExit(err);
    }

    if (num_read == 0)
        EmptyExit();

    InfoPrintInsTxt(APE_PrintJobs, server);
    print_field_header();  /* Net Name Job# etc */

    /* print info for each job in the queue */

    for (i = 0, job_ptr = (PPRJINFO)(BigBuf);
        i < num_read;
        i++, job_ptr++)
        print_each_job(job_ptr);
    InfoSuccess();
}



/*
 * Check if the printq is dcheduled
 * Hongly code.  Stolen from NIF
 */
int
dscheduled(
    USHORT starttime,
    USHORT untiltime
    )
{
    USHORT   current;
    DATETIME time;

    if (GetDateTime(&time))
    {
        return FALSE;
    }

    current = time.hours*60 + time.minutes;

    if (starttime >= untiltime)
        untiltime += 24*60;
    if (starttime > current)
        current += 24*60;

    if (current > untiltime)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


/*
 * find_print_dev -- Find the printing device that currently prints the job
 * Hongly code.  Stolen from NIF
 */
PPRDINFO NEAR
find_print_dev(USHORT id)
{
    PPRDINFO dest;
    USHORT   i;

    dest = LptDest;
    for (i=0; i < LptDestCnt; i++, dest++)
    {
        if (dest->uJobId == id)
            return dest;
    }

    /*
     * Not Found
     */
    return NULL;
}


// For WriteToCon below.

#define fmtPrintLanMask TEXT("\t%s (%s)\r\n")

VOID
print_lan_mask(
    DWORD Mask,
    DWORD ServerOrWksta
    )
{

    DWORD EntriesRead;
    DWORD TotalEntries;
    DWORD i;
    LPBYTE pBuffer = NULL;
    DWORD ReturnCode;

    // Mask is only used in the 16 bit version of this function
    UNREFERENCED_PARAMETER(Mask);

    if (ServerOrWksta == NETNAME_SERVER) {
        PSERVER_TRANSPORT_INFO_0 pSti0;

        //
        // Enumerate the transports managed by the server
        //

        ReturnCode = NetServerTransportEnum(
                        NULL,
                        0,            // Level 0
                        & pBuffer,
                        0xffffffff,         // MaxPreferredLength
                        & EntriesRead,
                        & TotalEntries,
                        NULL);       // Optional resume handle

        if (ReturnCode != 0) {

            if (ReturnCode = ERROR_NETWORK_UNREACHABLE)
            {
                EntriesRead = 0;
            }
            else
            {
                //
                // Couldn't enumerate the nets, return with an error
                //

                ErrorExit(ReturnCode);
            }
        }


        //
        // Now we've got the network names, let's print them out
        //

        for (i = 0, pSti0 = (PSERVER_TRANSPORT_INFO_0) pBuffer;
             i < EntriesRead; i++, pSti0++) {
                //
                // skip the \Device\ part of the name
                //

                pSti0->svti0_transportname =
                    STRCHR(pSti0->svti0_transportname, BACKSLASH);
                pSti0->svti0_transportname =
                    STRCHR(++pSti0->svti0_transportname, BACKSLASH);
                pSti0->svti0_transportname++;

                WriteToCon(fmtPrintLanMask,
                       pSti0->svti0_transportname,
                       pSti0->svti0_networkaddress);
        }

    }
    else if (ServerOrWksta == NETNAME_WKSTA) {
        PWKSTA_TRANSPORT_INFO_0 pWti0;

        //
        // Enumerate the transports managed by the server
        //

        ReturnCode = NetWkstaTransportEnum(NULL,
                        0,
                        & pBuffer,
                        0xffffffff,         // MaxPreferredLength
                        & EntriesRead,
                        & TotalEntries,
                        NULL);       // Optional resume handle

        if (ReturnCode != 0) {
            if (ReturnCode = ERROR_NETWORK_UNREACHABLE)
            {
                EntriesRead = 0;
            }
            else
            {
                //
                // Couldn't enumerate the nets, return with an error
                //

                ErrorExit(ReturnCode);
            }
        }

        //
        // Now we've got the network names, let's print them out
        //

        for (i = 0, pWti0 = (PWKSTA_TRANSPORT_INFO_0) pBuffer;
             i < EntriesRead; i++, pWti0++) {
                //
                // skip the \Device\ part of the name
                //

                pWti0->wkti0_transport_name =
                    STRCHR(pWti0->wkti0_transport_name, BACKSLASH);
                pWti0->wkti0_transport_name =
                    STRCHR(++pWti0->wkti0_transport_name, BACKSLASH);
                pWti0->wkti0_transport_name++;


                WriteToCon(fmtPrintLanMask,
                       pWti0->wkti0_transport_name,
                       pWti0->wkti0_transport_address);
        }


    }
    else
    {
        // Return with an error
        ErrorExit(NERR_InternalError);
    }

    //
    // Free up the buffer allocated by NetxTransportEnum
    //

    NetApiBufferFree(pBuffer);

    //
    // Print a blank line and return
    //

    PrintNL();

    return;

}


DWORD
GetDateTime(
    PDATETIME pDateTime
    )
{
    SYSTEMTIME Date_And_Time;

    GetSystemTime(&Date_And_Time);

    pDateTime->hours      =  (UCHAR) Date_And_Time.wHour;
    pDateTime->minutes    =  (UCHAR) Date_And_Time.wMinute;
    pDateTime->seconds    =  (UCHAR) Date_And_Time.wSecond;
    pDateTime->hundredths =  (UCHAR) (Date_And_Time.wMilliseconds / 10);
    pDateTime->day        =  (UCHAR) Date_And_Time.wDay;
    pDateTime->month      =  (UCHAR) Date_And_Time.wMonth;
    pDateTime->year       =  (WORD)  Date_And_Time.wYear;
    pDateTime->timezone   =  (SHORT) -1; // ==> undefined
    pDateTime->weekday    =  (UCHAR) Date_And_Time.wDayOfWeek;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\sam.c ===
/*++  

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MSAM.C

Abstract:

    Contains mapping functions to present netcmd with non-unicode
    view of SAM/LSA. We also package the data in a simpler form for 
    the netcmd side to deal with.

Author:

    ChuckC       13-Apr-1992

Environment:

    User Mode - Win32

Revision History:

    13-Apr-1992     chuckc      Created.

--*/

#include <nt.h>            // base definitions
#include <ntsam.h>         // for Sam***
#include <ntlsa.h>         // for Lsa***

#include <ntrtl.h>         // for RtlGetNtProductType()
#include <nturtl.h>        // allows <windows.h> to compile. since we've
                           // already included NT, and <winnt.h> will not
                           // be picked up, and <winbase.h> needs these defs.

#include <windows.h>

#include <lmcons.h>
#include <lmerr.h>
#include <netlibnt.h>      // NetpNtStatusToApistatus
#include <secobj.h>        // NetpGetBuiltInDomainSID
#include <apperr.h>
#include <tchar.h>
#include "netascii.h"
#include "sam.h"
#include "msystem.h"

/*
 * globals. init to NULL, closed before app exits.
 */
SAM_HANDLE BuiltInDomainHandle = NULL;
SAM_HANDLE AccountsDomainHandle = NULL;
SAM_HANDLE AliasHandle = NULL;
LSA_HANDLE LsaHandle = NULL;
PSID       AccountDomainSid = NULL ;

/* 
 * forward declare various worker functions. more detailed
 * descriptions are found with function bodies.
 */

// enumerate aliases in a domain. returns NERR_* or APE_*
DWORD EnumerateAliases(SAM_HANDLE DomainHandle, 
                       ALIAS_ENTRY **ppAlias, 
                       ULONG *pcAlias,
                       ULONG *pcMaxEntry) ;

// From a RID & Domain, create the PSID. Returns NERR_* or APE_*
DWORD SamGetSIDFromRID(PSID pSidDomain,
                       ULONG rid,
                       PSID *ppSID) ;

// From a name, lookup the PSID. Returns NERR_* or APE_*
DWORD SamGetSIDFromName(TCHAR *name,
                        PSID *ppSID,
                        SID_NAME_USE *pSidUse) ;

// From a name, lookup the RSID. Returns NERR_* or APE_*
DWORD SamGetRIDFromName(TCHAR *name,
                        ULONG *pRID) ;

// From a SID, lookup the ASCII name.
DWORD SamGetNameFromSID(PSID psid,
                        TCHAR **name) ;

// check if a SID (of particular type is already in a domain
BOOL SamCheckIfExists(PUNICODE_STRING pAccount, 
                      SAM_HANDLE hDomain,
                      SID_NAME_USE use) ;

DWORD CreateUnicodeString(TCHAR *pch, PUNICODE_STRING pUnicodeStr);

/*------------------------- SAM operations ---------------------------*/

/*
 * OpenSAM
 *
 * here we go thru all the steps needed to get a SAM domain handles
 * so we can go do our thing. we also get the LSA handle while we're here.
 *
 * return code: NERR_Success if got handle.
 *              error code that can be used for ErrorExit() otherwise
 * parameters:  server indicates the machine to perform operation on.
 *              priv is a netcmd defined number that indicates what we
 *              need to do with the database.
 */
DWORD
OpenSAM(
    TCHAR *server,
    ULONG priv
    )
{
    SAM_HANDLE                  ServerHandle = NULL;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo = NULL;
    NTSTATUS                    NtStatus;
    DWORD                       dwErr = NERR_Success ;
    DWORD                       sidlength ;
    UNICODE_STRING              unistrServer ; 
    ACCESS_MASK                 ServerAccessMask, AccountDomainAccessMask,
                                BuiltInDomainAccessMask, LsaAccessMask ;

    unistrServer.Length = 0 ;
    unistrServer.Length = 2 ;
    unistrServer.Buffer = L"" ;

    dwErr = CreateUnicodeString(server, &unistrServer) ;

    if (dwErr != NERR_Success)
    {
        return(dwErr) ;
    }

    /*
     * figure out the right access mask
     */
    switch(priv)
    {
        case READ_PRIV:
            ServerAccessMask        = SAM_SERVER_READ | SAM_SERVER_EXECUTE ;
            AccountDomainAccessMask = DOMAIN_READ | DOMAIN_EXECUTE ;
            BuiltInDomainAccessMask = DOMAIN_READ | DOMAIN_EXECUTE ;
            LsaAccessMask           = POLICY_EXECUTE ;
            break ;

        case WRITE_PRIV:
            ServerAccessMask        = SAM_SERVER_READ |
                                      SAM_SERVER_EXECUTE ;
            AccountDomainAccessMask = DOMAIN_READ | 
                                      DOMAIN_EXECUTE |
                                      DOMAIN_CREATE_ALIAS ;
            BuiltInDomainAccessMask = DOMAIN_READ | 
                                      DOMAIN_EXECUTE ;
            LsaAccessMask           = POLICY_EXECUTE ;
            break ;

        default:
            // currently, no other supported
            ServerAccessMask = 0 ;      
            AccountDomainAccessMask = 0 ;
            LsaAccessMask = 0 ;
            return(ERROR_INVALID_PARAMETER) ;
    }

    /*
     * Open the LSA
     */
    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );
    NtStatus = LsaOpenPolicy(&unistrServer,
                             &ObjectAttributes,
                             LsaAccessMask,
                             &LsaHandle);

    if (!NT_SUCCESS(NtStatus)) 
    {
        dwErr = NetpNtStatusToApiStatus(NtStatus) ;
        goto error_exit ;
    }

    /*
     * Get the Account domain SID from LSA
     */
    NtStatus = LsaQueryInformationPolicy(LsaHandle,
                                         PolicyAccountDomainInformation,
                                         (PVOID *)&PolicyAccountDomainInfo);
    if (!NT_SUCCESS(NtStatus)) 
    {
        dwErr = NetpNtStatusToApiStatus(NtStatus) ;
        goto error_exit ;
    }


    /*
     * Connect to SAM
     */
    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );
    NtStatus = SamConnect(
                  &unistrServer,
                  &ServerHandle,
                  ServerAccessMask,
                  &ObjectAttributes
                  );
    if (!NT_SUCCESS(NtStatus)) 
    {
        dwErr = NetpNtStatusToApiStatus(NtStatus) ;
        goto error_exit ;
    }

    /*
     * Make copy of Account Domain Sid. We later use this to determine
     * if an account retrieved is in the Account Domain or not.
     */
    sidlength = (ULONG) GetLengthSid(PolicyAccountDomainInfo->DomainSid) ;
    if (dwErr = AllocMem(sidlength, (CHAR **)&AccountDomainSid))
        goto error_exit ;

    if (!CopySid(sidlength, 
                 AccountDomainSid, 
                 PolicyAccountDomainInfo->DomainSid))
    {
        dwErr = GetLastError() ;
        goto error_exit ;
    }
    
    /*
     * Open the Account Domain.
     */
    NtStatus = SamOpenDomain(
                   ServerHandle,
                   AccountDomainAccessMask,
                   PolicyAccountDomainInfo->DomainSid,
                   &AccountsDomainHandle
                   );

    if (!NT_SUCCESS(NtStatus)) 
    {
        dwErr = NetpNtStatusToApiStatus(NtStatus) ;
        goto error_exit ;
    }

    /*
     * Open the builtin domain
     */

    // Create well-known SIDs. we are only interested in BuiltIn Domain
    if (! NT_SUCCESS (NtStatus = NetpCreateWellKnownSids(NULL)))
    {
        dwErr = NetpNtStatusToApiStatus(NtStatus) ;
        goto error_exit ;
    }

    // open the built in domain
    NtStatus = SamOpenDomain(
                   ServerHandle,
                   BuiltInDomainAccessMask,
                   BuiltinDomainSid,    // setup by NetpCreateWellKnownSids
                   &BuiltInDomainHandle
                   );

    if (!NT_SUCCESS(NtStatus)) 
    {
        dwErr = NetpNtStatusToApiStatus(NtStatus) ;
        goto error_exit ;
    }

    dwErr = NERR_Success ;
    goto ok_exit ;

error_exit:

    /*
     * only get here if we failed. clean everything up and go home.
     */
    if (BuiltInDomainHandle) 
    {
        SamCloseHandle(BuiltInDomainHandle);
        BuiltInDomainHandle = NULL;
    }
    if (AccountsDomainHandle) 
    {
        SamCloseHandle(AccountsDomainHandle);
        AccountsDomainHandle = NULL;
    }
    if (LsaHandle) 
    {
        LsaClose(LsaHandle);
        LsaHandle = NULL;
    }
    if (AccountDomainSid)
    {
        FreeMem((CHAR *)AccountDomainSid); 
        AccountDomainSid = NULL ;
    }

ok_exit:

    /*
     * successful exit point. clean up the transient pieces and go home.
     */
    if (PolicyAccountDomainInfo) 
    {
        LsaFreeMemory(PolicyAccountDomainInfo);
        PolicyAccountDomainInfo = NULL ;
    }
    if (ServerHandle) 
    {
        SamCloseHandle(ServerHandle);
        ServerHandle = NULL ;
    }

    return(dwErr) ;
}

/*
 * CloseSAM
 *
 * close the the various handles
 *
 * return code: none
 * parameters:  none
 */
VOID CloseSAM(void) 
{
    if (BuiltInDomainHandle) 
    {
        SamCloseHandle(BuiltInDomainHandle);
        BuiltInDomainHandle = NULL;
    }
    if (AccountsDomainHandle) 
    {
        SamCloseHandle(AccountsDomainHandle);
        AccountsDomainHandle = NULL;
    }
    if (LsaHandle) 
    {
        LsaClose(LsaHandle);
        LsaHandle = NULL ;
    }
    if (AccountDomainSid)
    {
        FreeMem((CHAR *)AccountDomainSid); 
        AccountDomainSid = NULL ;
    }

    NetpFreeWellKnownSids() ;
}

/*
 * SamAddAlias
 *
 * used to add an alias to the SAM Accounts domain. It is never used
 * with builtin domain.
 *
 * return code: NERR_* or APE_* that can be used for ErrorExit()
 * parameters : an ALIAS_ENTRY with both name and comment properly filled.
 */
DWORD SamAddAlias(ALIAS_ENTRY *pAlias) 
{
    ULONG RelativeId ;
    NTSTATUS NtStatus;
    DWORD dwErr = NERR_Success ;
    UNICODE_STRING alias_name ;

    // setup unicode string for name
    if (dwErr = CreateUnicodeString(pAlias->name, &alias_name))
        return(dwErr) ;


    // check if its already in BuiltIn domain first
    if (SamCheckIfExists(&alias_name,
                         BuiltInDomainHandle,
                         SidTypeAlias))
    {
        return(NERR_GroupExists) ;
    }

    // call SAM To do its thing 
    NtStatus = SamCreateAliasInDomain(AccountsDomainHandle,
                                      &alias_name,
                                      ALIAS_WRITE,
                                      &AliasHandle,
                                      &RelativeId) ;

    // did we succeed?
    if (!NT_SUCCESS(NtStatus)) 
    {
        dwErr = NetpNtStatusToApiStatus(NtStatus) ;
        return(dwErr) ;
    }

    // the call above has setup global handle. AliasSetInfo will
    // use it to set the comment.
    return (AliasSetInfo(pAlias)) ;
}

/*
 * SamDelAlias
 *
 * used to delete an alias in the SAM Accounts domain. It is never used
 * with builtin domain.
 *
 * return code: NERR_* or APE_* that can be used foe ErrorExit()
 * parameters : an ALIAS_ENTRY with name properly filled.
 */
DWORD SamDelAlias(TCHAR *alias) 
{
    NTSTATUS NtStatus;
    DWORD dwErr = NERR_Success ;

    // open the alias to get the handle
    if (dwErr = OpenAlias(alias, DELETE, USE_BUILTIN_OR_ACCOUNT))
    {
        return dwErr;
    }

    // nuke it
    NtStatus = SamDeleteAlias( AliasHandle ) ;

    if (!NT_SUCCESS(NtStatus)) 
    {
        dwErr = NetpNtStatusToApiStatus(NtStatus) ;
    }

    AliasHandle = NULL;

    return dwErr;
}



#define INIT_ALLOC_COUNT        500
#define PREFERRED_BUFSIZ        16000

/*
 * MSamEnumAliases
 *
 * function to go thru both builtin and accounts domain, 
 * enum all aliases, build up a table (unsorted) of ALIAS_ENTRY 
 * structures that is used to display aliases with comments.
 *
 * return code: NERR_* or APE_*
 * parameters:  the two OUT parametrs receive a pointer to an array of 
 *              ALIAS_ENTRYs and a count of the number of entries. The
 *              caller must free pointers within *ppAlias and *ppAlias itself.
 */
DWORD SamEnumAliases(ALIAS_ENTRY **ppAlias, LPDWORD pcAlias)
{
    ALIAS_ENTRY *pAlias = NULL ;
    ULONG cAlias = 0 ;
    ULONG cMaxAlias = INIT_ALLOC_COUNT ;
    DWORD dwErr ;

    /* 
     * init results to NULL and alloc memory for table
     */
    *pcAlias = 0 ;
    *ppAlias = NULL ;

    if (dwErr = AllocMem(cMaxAlias * sizeof(ALIAS_ENTRY),
                          (VOID **)&pAlias))
        return dwErr ;

    memset(pAlias, 0, cMaxAlias*sizeof(ALIAS_ENTRY)) ;

    /*
     * call the worker routine for BUILT IN domain
     */
    dwErr = EnumerateAliases(BuiltInDomainHandle,
                             &pAlias,
                             &cAlias,
                             &cMaxAlias) ;
    if (dwErr)
    {
        FreeMem(pAlias); 
        return(dwErr) ; 
    }

    /*
     * call the worker routine for ACCOUNTS domain
     */
    dwErr = EnumerateAliases(AccountsDomainHandle,
                             &pAlias,
                             &cAlias,
                             &cMaxAlias) ;
    if (dwErr)
    {
        FreeMem(pAlias); 
        return dwErr ;
    }

    *pcAlias = cAlias ;
    *ppAlias = pAlias ;
    return(NERR_Success) ; 
}

/*
 * EnumerateAliases
 *
 * enumerate the aliases in the desired domain
 *
 * return code: NERR_* or APE_*
 * parameters : DomainHandle is the domain of interest.
 *              ppAlias points to the start of the buffer to return data in.
 *                  this buffer may already be partially used.
 *              pcAlias tells us how much of the buffer is alreadt used, so
 *                  we should start from (*ppAlias) + *pcAlias.
 *              pcMaxAlias tells us how big the total buffer is.
 */
DWORD EnumerateAliases(SAM_HANDLE DomainHandle, 
                       ALIAS_ENTRY **ppAlias, 
                       ULONG *pcAlias,
                       ULONG *pcMaxAlias)
{
    DWORD                          dwErr ;
    NTSTATUS                       NtStatus ;
    PVOID                          pBuffer = NULL ;
    ULONG                          iEntry ;
    ALIAS_ENTRY                    *pEntry ;
    SAM_ENUMERATE_HANDLE           hEnum = 0 ;

    /*
     * setup these guys to point to the right place in the buffer
     */
    iEntry = *pcAlias;
    pEntry = *ppAlias + iEntry ;

    /*
     * loop since it is resumable iteration.
     */
    do 
    {
        PSAM_RID_ENUMERATION   psamRidEnum ;
        ULONG                  count ;
        ULONG                  i ;

        /*
         * get a buncha aliases 
         */
        NtStatus = SamEnumerateAliasesInDomain( DomainHandle,
                                                &hEnum,
                                                &pBuffer,
                                                PREFERRED_BUFSIZ,
                                                &count ) ;
        if (!NT_SUCCESS(NtStatus)) 
        {
            dwErr = NetpNtStatusToApiStatus(NtStatus) ;
            pBuffer = NULL ;
            goto cleanupandexit ;
        }

        /* 
         * extract name of each alias 
         */
        psamRidEnum = (PSAM_RID_ENUMERATION) pBuffer ;
        for (i = 0 ;
             i < count ;
             i++, psamRidEnum++) 
        {
            if (iEntry >= *pcMaxAlias)
            {
                // original buffer not big enough. double and realloc
                *pcMaxAlias *= 2 ;
                if (dwErr = ReallocMem(*pcMaxAlias * sizeof(ALIAS_ENTRY),
                                        (CHAR **)ppAlias))
                    goto cleanupandexit ;

                pEntry = *ppAlias + iEntry;
            }

            if (dwErr = AllocMem(psamRidEnum->Name.Length+sizeof(TCHAR), &pEntry->name))
                goto cleanupandexit ;

            _tcsncpy(pEntry->name,
                     psamRidEnum->Name.Buffer,
                     psamRidEnum->Name.Length/sizeof(TCHAR));

            *(pEntry->name + psamRidEnum->Name.Length/sizeof(TCHAR)) = NULLC;
            pEntry->comment = NULL ;    // currently not used on Enum

            iEntry++ ; 
            pEntry++ ;
        }

        // we can now free the buffer
        SamFreeMemory(pBuffer);
        pBuffer = NULL ;
    }
    while (NtStatus == STATUS_MORE_ENTRIES) ;

    if (!NT_SUCCESS(NtStatus)) 
    {
        dwErr = NetpNtStatusToApiStatus(NtStatus) ;
        goto cleanupandexit ;
    }

    *pcAlias = iEntry ;
    return(NERR_Success) ;

cleanupandexit:         // only get here on error

    if (pBuffer) 
        SamFreeMemory(pBuffer);
   
    FreeAliasEntries(*ppAlias, iEntry) ;
    return(dwErr) ; 
}


/*
 * FreeAliasEntries
 *
 * free up entries in table allocated by MSamEnumerateAliases
 *
 * return code: none
 * parameters:  pAlias is pointer to array of entries, cAlias is 
 *              count of entries.
 */
VOID FreeAliasEntries( ALIAS_ENTRY *pAlias, 
                       ULONG cAlias) 
{
    while (cAlias--)
    {
        if (pAlias->name) 
        {
            FreeMem(pAlias->name) ;
            (pAlias++)->name = NULL ;
        }
    }
}


/*-------------------------- ALIAS operations -------------------------*/

/*
 * OpenAlias
 *
 * Get a handle to an alias in either ACCOUNT or BUILTIN domain.
 *
 * return code: NERR_Success if got handle.
 *              error code that can be used for ErrorExit() otherwise
 * parameters:  alias is the name of the alias. 
 *              priv is a netcmd defined number that indicates what we
 *              need to do with the alias.
 *              domain is one of: USE_BUILTIN_DOMAIN, USE_ACCOUNT_DOMAIN
 *              or USE_BUILTIN_OR_ACCOUNT.
 */
DWORD
OpenAlias(
    LPWSTR       alias,
    ACCESS_MASK  AccessMask,
    ULONG        domain
    )
{
    ULONG RelativeId ;
    DWORD dwErr = NERR_Success ;

    //
    // call worker routine to find the RID
    //

    if (dwErr = SamGetRIDFromName(alias, &RelativeId))
    {
        return dwErr;
    }

    return OpenAliasUsingRid( RelativeId, AccessMask, domain );
}


/*-------------------------- ALIAS operations -------------------------*/

/*
 * OpenAliasUsingRid
 *
 * Get a handle to an alias in either ACCOUNT or BUILTIN domain.
 *
 * return code: NERR_Success if got handle.
 *              error code that can be used for ErrorExit() otherwise
 * parameters:  alias is the name of the alias. 
 *              priv is a netcmd defined number that indicates what we
 *              need to do with the alias.
 *              domain is one of: USE_BUILTIN_DOMAIN, USE_ACCOUNT_DOMAIN
 *              or USE_BUILTIN_OR_ACCOUNT.
 */
DWORD
OpenAliasUsingRid(
    ULONG       RelativeId,
    ACCESS_MASK AccessMask,
    ULONG       domain
    )
{
    NTSTATUS NtStatus;
    DWORD dwErr = NERR_Success ;

    /*
     * call SAM to open the Alias. We use different domains depending
     * on the domain argument.
     */

    switch (domain) 
    {
        case USE_BUILTIN_OR_ACCOUNT:
            NtStatus = SamOpenAlias(BuiltInDomainHandle,
                                    AccessMask,
                                    RelativeId,
                                    &AliasHandle) ;
            if (NtStatus != STATUS_NO_SUCH_ALIAS) 
                break ;

            // otherwise we couldnt find alias, so drop thru to 
            // to try builtin domain
        
        case USE_ACCOUNT_DOMAIN:
            NtStatus = SamOpenAlias(AccountsDomainHandle,
                                    AccessMask,
                                    RelativeId,
                                    &AliasHandle) ;
            break ;

        case USE_BUILTIN_DOMAIN:
            NtStatus = SamOpenAlias(BuiltInDomainHandle,
                                    AccessMask,
                                    RelativeId,
                                    &AliasHandle) ;
            break ;

        default:
            return(NERR_InternalError) ;  // this should never happen
    }

    if (!NT_SUCCESS(NtStatus))
    {
        dwErr = NetpNtStatusToApiStatus(NtStatus);
    }

    return(dwErr) ;
}

/*
 * CloseAlias
 *
 * Close a handle to an alias.
 *
 * return code: none
 * parameters:  none
 */
VOID CloseAlias(void) 
{
    if (AliasHandle) 
        SamCloseHandle(AliasHandle);
    AliasHandle = NULL ;
}

/*
 * AliasAddMember
 *
 * Add a member to an alias that has been opened via MOpenAlias().
 *
 * return code: NERR_Success if got handle.
 *              error code that can be used for ErrorExit() otherwise
 * parameters:  member is the name of the member to add. It may either
 *              NAME or DOMAIN\NAME. 
 */
DWORD AliasAddMember(TCHAR *member) 
{
    PSID psid ;
    NTSTATUS NtStatus;
    DWORD dwErr ;
    SID_NAME_USE sidUse = SidTypeUnknown;

    // translate ascii name to PSID
    if (dwErr = SamGetSIDFromName(member,&psid,&sidUse))
    {
        return dwErr;
    }

    if (sidUse == SidTypeDomain)
    {
        return ERROR_NO_SUCH_USER;
    }

    // add the SID
    NtStatus = SamAddMemberToAlias(AliasHandle, psid) ;

    // free this memory, since its useless by now
    FreeMem(psid) ;

    // check for error
    if (!NT_SUCCESS(NtStatus)) 
    {
        dwErr = NetpNtStatusToApiStatus(NtStatus);
    }

    return dwErr;
}

/*
 * AliasDeleteMember
 *
 * Remove a member from the alias opened by MOpenAlias().
 *
 * return code: NERR_Success if got handle.
 *              error code that can be used for ErrorExit() otherwise
 * parameters:  member is the name of the member to remove. It may be
 *              NAME or DOMAIN\NAME. 
 */
DWORD AliasDeleteMember(TCHAR *member) 
{
    PSID psid ;
    NTSTATUS NtStatus;
    DWORD dwErr = NERR_Success ;
    SID_NAME_USE sidUse = SidTypeUnknown;

    // call worker routine to get SID
    if (dwErr = SamGetSIDFromName(member,&psid, &sidUse))
    {
        return dwErr;
    }

    // call SAM To do its thing
    NtStatus = SamRemoveMemberFromAlias(AliasHandle, psid);

    // free this memory, since its useless by now
    FreeMem(psid);

    if (NtStatus == STATUS_MEMBER_NOT_IN_ALIAS
         &&
        _tcsstr(member, TEXT("\\")) == NULL)
    {
        LPTSTR  lpName;
        DWORD   cchName = MAX_COMPUTERNAME_LENGTH + 2 + _tcslen(member);

        //
        // If we tried to delete an unqualified user and that
        // failed, try again with the machine name prepended
        //

        if (AllocMem(cchName * sizeof(TCHAR),
                      &lpName))
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (!GetComputerName(lpName, &cchName))
        {
            dwErr = GetLastError();
            FreeMem(lpName);
            return dwErr;
        }

        lpName[cchName] = TEXT('\\');

        _tcscpy(&lpName[cchName + 1], member);

        if (dwErr = SamGetSIDFromName(lpName, &psid, &sidUse))
        {
            FreeMem(lpName);
            return dwErr;
        }

        FreeMem(lpName);

        NtStatus = SamRemoveMemberFromAlias(AliasHandle, psid);

        FreeMem(psid);
    }

    // check for error
    if (!NT_SUCCESS(NtStatus))
    {
        dwErr = NetpNtStatusToApiStatus(NtStatus);
    }

    return dwErr;
}

/*
 * AliasEnumMembers
 *
 * Get the members of an alias.
 *
 * return code: NERR_Success if got handle.
 *              error code that can be used for ErrorExit() otherwise
 * parameters:  members is used to return a pointer to an array of PSZs.
 *              count is used to return how many members.
 */
DWORD AliasEnumMembers(TCHAR ***members, DWORD *count) 
{
    PSID *pSids, *next_sid ;
    NTSTATUS NtStatus;
    DWORD dwErr = NERR_Success ;
    TCHAR *pBuffer, **ppchNext, **ppchResults ;
    ULONG i, num_read = 0, num_bad = 0 ;

    /* 
     * call SAM to enumerate the members
     */
    NtStatus = SamGetMembersInAlias(AliasHandle, &pSids, &num_read) ;
    if (!NT_SUCCESS(NtStatus)) 
    {
        dwErr = NetpNtStatusToApiStatus(NtStatus) ;
        return(dwErr) ;
    }

    /*
     * allocate buffer for array of strings, and NULL it.
     */
    if (dwErr = AllocMem(num_read * sizeof(TCHAR *), &pBuffer) )
    {
        SamFreeMemory(pSids) ;
        return(dwErr) ;
    }
    memset(pBuffer, 0, num_read*sizeof(TCHAR *)) ;
    ppchNext = ppchResults = (TCHAR **) pBuffer ;

    /*
     * go thru each SID returned and add the member to out buffer
     */
    for (i = 0, next_sid = pSids; 
         i < num_read; 
         i++, next_sid++)
    {
        /*
         * convert to strings. On error, free things up.
         */
        if (dwErr = SamGetNameFromSID(*next_sid, ppchNext))
        {
            if (dwErr == APE_UnknownAccount)
            {
                // we have bad or deleted SID, just ignore. 
                // ie. do nothing, dont advance pointer either.
                // we do however, keep count of how many we ignore
                ++num_bad ;
            }
            else
            {
                // cleanup & go home
                while (i--) 
                {
                   FreeMem(ppchResults[i]) ;
                }
    
                SamFreeMemory((TCHAR *)pSids) ;
                FreeMem(ppchResults) ;
                return(dwErr) ;
            }
        }
        else
           ++ppchNext ;
    }

    // dont need this anymore
    SamFreeMemory((TCHAR *)pSids) ;
    
    // setup return info
    *count = num_read - num_bad ;   // number read minus the ones ignored.
    *members = ppchResults ;
    return(NERR_Success) ;
}

/*
 * MAliasFreeMembers
 *
 * Free the members memory used for members of an alias.
 *
 * return code: none
 * parameters:  members is pointer to an array of PSZs.
 *              count indicates how many members.
 */
VOID AliasFreeMembers(TCHAR **members, DWORD count) 
{
    while (count--)
    {
        FreeMem(*members) ;
        ++members ;
    }
}


/*
 * MAliasGetInfo 
 * 
 * this wrapper gets info about the alias. currently, only comment is 
 * returned.
 *
 * returns:    NERR_* or APE_* for ErrorExit()
 * parameters: pointer to ALIAS_ENTRY. the comment field of this entry
 *             will on successful exit point to an ascii string which
 *             should be FreeMem()-ed. The name field is untouched.
 */
DWORD AliasGetInfo(ALIAS_ENTRY *pAlias) 
{
    NTSTATUS NtStatus;
    DWORD dwErr = NERR_Success ;
    TCHAR *pBuffer ;
    PALIAS_ADM_COMMENT_INFORMATION pAliasCommentInfo ;
    TCHAR *pchAdminComment ;

    pAlias->comment = NULL ;

    NtStatus = SamQueryInformationAlias(AliasHandle, 
                                        AliasAdminCommentInformation,
                                        (PVOID *)&pBuffer) ;

    if (!NT_SUCCESS(NtStatus)) 
    {
        dwErr = NetpNtStatusToApiStatus(NtStatus) ;
        return(dwErr) ;
    }

    pAliasCommentInfo = (PALIAS_ADM_COMMENT_INFORMATION)pBuffer ;
    if (dwErr = AllocMem(
            pAliasCommentInfo->AdminComment.Length+sizeof(TCHAR),
            &pchAdminComment))
        return(dwErr) ;

    _tcsncpy(pchAdminComment, pAliasCommentInfo->AdminComment.Buffer,
                pAliasCommentInfo->AdminComment.Length/sizeof(TCHAR));

    *(pchAdminComment+pAliasCommentInfo->AdminComment.Length/sizeof(TCHAR))
        = NULLC;

    SamFreeMemory(pBuffer) ;
    pAlias->comment = pchAdminComment ;
    return(NERR_Success) ;
}

/*
 * Set Alias information. Currently, only comment is settable.
 *
 * return code: NERR_* or APE_* that can be used for ErrorExit()
 *
 * parameters:  alias is pointer to ALIAS_ENTRY that supplies
 *              the comment. If comment is NULL, do nothing. "" will
 *              clear the comment.
 */
DWORD AliasSetInfo(ALIAS_ENTRY *pAlias) 
{
    NTSTATUS NtStatus;
    USHORT cBuffer;
    DWORD  dwErr = NERR_Success ;
    PALIAS_ADM_COMMENT_INFORMATION pComment ;
    TCHAR *pBuffer ;

    // this is all we set currently. if nothing, just return.
    if (pAlias->comment == NULL)
        return(NERR_Success) ;

    // allocate the buffer
    cBuffer = sizeof(ALIAS_ADM_COMMENT_INFORMATION) ;
    if (dwErr = AllocMem(cBuffer, &pBuffer)) 
        return(dwErr) ;
    pComment = (PALIAS_ADM_COMMENT_INFORMATION) pBuffer ;

    // set it up with the comment
    if (dwErr = CreateUnicodeString(pAlias->comment, &(pComment->AdminComment)))
    {
        // free up previously alloc-ed buffer and exit
        FreeMem(pBuffer) ;
        return(dwErr) ;
    }

    // call SAM to do its thing
    NtStatus = SamSetInformationAlias(AliasHandle, 
                                      AliasAdminCommentInformation,
                                      pBuffer) ;
   
    // free up the buffer we alloc-ed
    FreeMem(pBuffer);

    // map errors if any
    if (!NT_SUCCESS(NtStatus)) 
        dwErr = NetpNtStatusToApiStatus(NtStatus) ;
    
    return(dwErr) ;
}

/*----------------------- worker routines ------------------------------*/

/*
 * SamGetSIDFromRID
 *
 * From a domain sid and a rid, create the PSID.
 * Caller must free the PSID with FreeMem().
 *
 * return code: NERR_* or APE_*
 * parameters:  pSidDomain is the domain sid.
 *              rid is the RID.
 *              ppSID is used to return the PSID which should be 
 *              freed using FreeMem().
 */
DWORD SamGetSIDFromRID(PSID pSidDomain,
                       ULONG rid,
                       PSID *ppSID) 
{
    DWORD dwErr ;
    ULONG cbSid ;
    DWORD *pdwLastSubAuthority ;
    UCHAR *pcSubAuthority ;

    // allocate mem for it. we need room for one extra Sub Authority.
    cbSid = GetSidLengthRequired((UCHAR) 
                ((*GetSidSubAuthorityCount(pSidDomain))+1)) ;

    if (dwErr = AllocMem(cbSid, (CHAR **)ppSID ))
        return dwErr ;

    // make copy so we can mess with it
    if (!CopySid(cbSid, *ppSID, pSidDomain))
    {
        FreeMem(*ppSID);
        *ppSID = NULL ;
        return NERR_InternalError ;  
    }

    // get the last subauthority and set it with RelativeID, 
    // thereby generating the account SID we wanted in first place
    pcSubAuthority = GetSidSubAuthorityCount((PSID)*ppSID) ;
    (*pcSubAuthority)++ ;
    pdwLastSubAuthority = GetSidSubAuthority((PSID)*ppSID,
                                             *pcSubAuthority-1) ;
    *pdwLastSubAuthority = rid ;
    return NERR_Success ;
}

/*
 * SamGetSIDFromName
 *
 * From a name, lookup the PSID.
 * Caller must free the PSID with FreeMem().
 *
 * return code: NERR_* or APE_*
 * parameters:  name is account name. May be domain\user format.
 *              ppSID is used to return the PSID which should be 
 *              freed using FreeMem().
 */
DWORD SamGetSIDFromName(TCHAR *name,
                        PSID *ppSID,
                        SID_NAME_USE *pSidUse) 
{
    NTSTATUS NtStatus;
    DWORD dwErr = NERR_Success ;
    PLSA_REFERENCED_DOMAIN_LIST pRefDomains ; 
    PLSA_TRANSLATED_SID2 pTranslatedSids ;
    UNICODE_STRING UnicodeStr ;
    ULONG cbSid ;
    DWORD *pdwLastSubAuthority ;
    BYTE *pSidBuffer ;
    PSID pDomainSid ;
    UCHAR *pcSubAuthority ;
    LONG iDomain ;

    *ppSID = NULL ; 
    *pSidUse = SidTypeUnknown;

    // create the unicode structure for LSA
    if (dwErr = CreateUnicodeString(name, &UnicodeStr))
        return (dwErr) ;

    // do lookup 
    NtStatus = LsaLookupNames2(LsaHandle,
                              0, // Flags
                              1,
                              &UnicodeStr,
                              &pRefDomains,
                              &pTranslatedSids) ;

    if (!NT_SUCCESS(NtStatus)) 
    {
        if (NtStatus == STATUS_NONE_MAPPED)
            dwErr = APE_UnknownAccount ;
        else
            dwErr = NetpNtStatusToApiStatus(NtStatus) ;
        return(dwErr) ;
    }

    // get to the right domain
    iDomain = pTranslatedSids->DomainIndex ;
    if (iDomain < 0)
        return(APE_UnknownAccount) ;  
    pDomainSid = ((pRefDomains->Domains)+iDomain)->Sid ;

    // allocate mem for it. we need room for one extra Sub Authority.
    cbSid = RtlLengthSid( pTranslatedSids->Sid );
    if (dwErr = AllocMem(cbSid, &pSidBuffer ))
        goto exitpoint ;

    // make copy so we can mess with it
    if (!CopySid(cbSid, pSidBuffer, pTranslatedSids->Sid))
    {
        dwErr = NERR_InternalError ;  // shouldnt happen
        goto exitpoint ;
    }

    *ppSID = (PSID) pSidBuffer ;
    *pSidUse = pTranslatedSids->Use;
    dwErr = NERR_Success ;

exitpoint:

    LsaFreeMemory(pTranslatedSids) ;
    LsaFreeMemory(pRefDomains) ;
    return(dwErr) ;
}


/*
 * SamGetRIDFromName
 *
 * From a name, lookup the RID
 *
 * return code: NERR_* or APE_*
 * parameters:  name is account name. May be domain\user/
 *              pRID is used to return the RID.
 */
DWORD SamGetRIDFromName(TCHAR *name,
                        ULONG *pRID) 

{
    NTSTATUS NtStatus;
    DWORD dwErr = NERR_Success ;
    PLSA_REFERENCED_DOMAIN_LIST Domains ; 
    PLSA_TRANSLATED_SID Sids ;
    UNICODE_STRING UnicodeStr ;
    PSID_NAME_USE pSidNameUse = NULL;
    PULONG pRidList = NULL ;

    // create the unicode structure for LSA
    if (dwErr = CreateUnicodeString(name, &UnicodeStr))
        return (dwErr) ;

    // do lookup in local accounts first in case same as machine name
    // and LSA will return the wrong one.
    NtStatus = SamLookupNamesInDomain(  AccountsDomainHandle,
                                        1,
                                        &UnicodeStr,
                                        &pRidList,
                                        &pSidNameUse );
    // if succeed, take a close look
    if (NT_SUCCESS(NtStatus)) 
    {
        // what type of name is this?
        switch (*pSidNameUse)
        {
            case SidTypeAlias :
                // found what we wanted
                *pRID = *pRidList ;
                SamFreeMemory(pRidList);
                SamFreeMemory(pSidNameUse);
                return NERR_Success ;

            case SidTypeWellKnownGroup :
            case SidTypeGroup:
            case SidTypeUser :
            case SidTypeDomain :
            case SidTypeDeletedAccount :
            case SidTypeInvalid :
            case SidTypeUnknown :
            default:
                // carry on by looking up via LSA
                SamFreeMemory(pRidList);
                SamFreeMemory(pSidNameUse);
                break ;
        }
    }

    NtStatus = LsaLookupNames(LsaHandle,
                              1,
                              &UnicodeStr,
                              &Domains,
                              &Sids) ;

    if (!NT_SUCCESS(NtStatus)) 
    {
        switch (NtStatus)
        {
            case STATUS_NONE_MAPPED:
            case STATUS_TRUSTED_DOMAIN_FAILURE:
                dwErr = ERROR_NO_SUCH_ALIAS ;
                break ;
            default:
                dwErr = NetpNtStatusToApiStatus(NtStatus);
        }

        return(dwErr) ;
    }

    *pRID = Sids->RelativeId ;
    LsaFreeMemory(Sids) ;
    LsaFreeMemory(Domains) ;
    return(NERR_Success) ;
}


/*
 * SamGetNameFromRid
 *
 * From a RID, lookup the ASCII name.
 *
 * return code: NERR_* or APE_*
 * parameters:  psid is the sid to lookup
 *              name is used to return the pointer
 *              to ascii name that should be FreeMem()-ed.
 *              fIsBuiltin indicates to use the Builtin Domain.
 */
DWORD SamGetNameFromRid(ULONG RelativeId,
                        TCHAR **name,
                        BOOL fIsBuiltin ) 
{
    NTSTATUS NtStatus;
    DWORD dwErr = NERR_Success;
    PUNICODE_STRING pUniString;
    PSID_NAME_USE pSidNameUse;
    ULONG cbNameLen ;
    TCHAR *pchName ;

    NtStatus = SamLookupIdsInDomain( fIsBuiltin ? BuiltInDomainHandle
                                                : AccountsDomainHandle,
                                        1,
                                        &RelativeId,
                                        &pUniString,
                                        &pSidNameUse );
    if (!NT_SUCCESS(NtStatus)) 
    {
   
        dwErr = NetpNtStatusToApiStatus(NtStatus) ;

        // if not found, map to unknown account
        if (dwErr == NERR_GroupNotFound || dwErr == NERR_UserNotFound)
            return(APE_UnknownAccount) ;

        return(dwErr) ;
    }
    // what type of name is this?
    switch (*pSidNameUse)
    {
        case SidTypeUser :
        case SidTypeGroup:
        case SidTypeAlias :
        case SidTypeWellKnownGroup :
            // this is OK case
            break ;
        case SidTypeDomain :
        case SidTypeDeletedAccount :
        case SidTypeInvalid :
        case SidTypeUnknown :
            // the above shouldnt happen. we only deal with users/groups.
            // if it does, behave as if cannot find.
        default:
            dwErr = APE_UnknownAccount ;
            goto exitpoint ;
    }

    // alloc mem for name. +1 for terminator
    cbNameLen = (pUniString->Length+1)*sizeof(WCHAR) ;
    if (dwErr = AllocMem(cbNameLen, &pchName))
        goto exitpoint ;

    // init the buffer to zeros, then build the WCHAR name
    memset(pchName, 0, cbNameLen) ;
    wcsncpy((LPWSTR)pchName, 
            pUniString->Buffer, 
            cbNameLen/sizeof(WCHAR) - 1) ;

    *name = pchName ;
    dwErr = NERR_Success ;

exitpoint:

    SamFreeMemory(pUniString);
    SamFreeMemory(pSidNameUse);
    return(dwErr) ;

}



/*
 * SamGetNameFromSID
 *
 * From a SID, lookup the ASCII name.
 *
 * return code: NERR_* or APE_*
 * parameters:  psid is the sid to lookup
 *              name is used to return the pointer
 *              to ascii name that should be FreeMem()-ed.
 */
DWORD SamGetNameFromSID(PSID psid,
                        TCHAR **name) 
{
    NTSTATUS NtStatus;
    DWORD dwErr = NERR_Success ;
    PLSA_REFERENCED_DOMAIN_LIST pRefDomains ;
    PLSA_TRANSLATED_NAME pTranslatedNames ;
    ULONG cbNameLen, cbDomainLen, cbTotal ;
    TCHAR *pchName ;
    LONG iDomain ;

    // call LSA to lookup the SID
    NtStatus = LsaLookupSids(LsaHandle,
                             1,
                             &psid,
                             &pRefDomains,
                             &pTranslatedNames) ;

    if (!NT_SUCCESS(NtStatus)) 
    {
   
        dwErr = NetpNtStatusToApiStatus(NtStatus) ;

        // if not found, map to unknown account
        switch (dwErr)
        {
        case NERR_GroupNotFound:
        case NERR_UserNotFound:
        case ERROR_TRUSTED_DOMAIN_FAILURE:
        case ERROR_TRUSTED_RELATIONSHIP_FAILURE:
        case ERROR_DS_GC_NOT_AVAILABLE:
            return(APE_UnknownAccount) ;
        }
        return(dwErr);
    }

    // what type of name is this?
    switch (pTranslatedNames->Use)
    {
        case SidTypeUser :
        case SidTypeGroup:
        case SidTypeAlias :
        case SidTypeWellKnownGroup :
            // this is OK case
            break ;
        case SidTypeDomain :
            // the above shouldnt happen. we only deal with users/groups.
            // if it does, behave as if cannot find.
        case SidTypeDeletedAccount :
        case SidTypeInvalid :
        case SidTypeUnknown :
        default:
            return(APE_UnknownAccount) ;
    }

    // get to right domain
    iDomain =  pTranslatedNames->DomainIndex ; 
    if (iDomain < 0)
    {
        return(APE_UnknownAccount);
    }

    //
    // alloc mem for name. +1 for '\', and another +1 for terminator
    //
    cbNameLen = pTranslatedNames->Name.Length;
    cbDomainLen = ((pRefDomains->Domains)+iDomain)->Name.Length;
    cbTotal = (cbNameLen + cbDomainLen + 1 + 1) * sizeof(WCHAR);

    if (dwErr = AllocMem(cbTotal, &pchName))
    {
        goto exitpoint;
    }

    //
    // init the buffer to zeros, then build the WCHAR name by concatenating
    // the domain name with the user name. but dont do it if its the account
    // domain or builtin (in this case, only show username).  Also do this
    // for names that have no domain (e.g., well-known groups like "Everyone")
    //
    memset(pchName, 0, cbTotal) ;

    if (((pRefDomains->Domains)+iDomain)->Name.Length != 0
         &&
        !EqualSid(((pRefDomains->Domains)+iDomain)->Sid, AccountDomainSid)
         &&
        !EqualSid(((pRefDomains->Domains)+iDomain)->Sid, BuiltinDomainSid))
    {
        wcsncpy((LPWSTR)pchName, 
                ((pRefDomains->Domains)+iDomain)->Name.Buffer,
                cbDomainLen/sizeof(WCHAR)) ;
        wcscat((LPWSTR)pchName, L"\\") ;
    }

    wcsncat((LPWSTR) pchName, 
            pTranslatedNames->Name.Buffer, 
            cbNameLen/sizeof(WCHAR)) ;

    *name = pchName ;
    dwErr = NERR_Success ;

exitpoint:

    LsaFreeMemory(pTranslatedNames) ;
    LsaFreeMemory(pRefDomains) ;
    return(dwErr) ;
}

/*
* CreateUnicodeString
*
* build a UNICODE_STRING from an string.
*/
DWORD CreateUnicodeString(TCHAR *pch, PUNICODE_STRING pUnicodeStr)
{

    pUnicodeStr->Length = (USHORT)(_tcslen(pch) * sizeof(WCHAR)) ;
    pUnicodeStr->Buffer = pch ;
    pUnicodeStr->MaximumLength = pUnicodeStr->Length + (USHORT)sizeof(WCHAR) ;
                        
    return(NERR_Success) ;
}

/*---------------------- alias memberships of a user  ----------------------*/

/*
 * UserEnumAliases
 *
 * Get the members of an alias.
 *
 * return code: NERR_Success if got handle.
 *              error code that can be used for ErrorExit() otherwise
 * parameters:  members is used to return a pointer to an array of PSZs.
 *              count is used to return how many members.
 */
DWORD UserEnumAliases(TCHAR *user, TCHAR ***members, DWORD *count) 
{
    PSID pSidUser = NULL ;
    ULONG *pRidAccountAliases = NULL ;
    ULONG *pRidBuiltinAliases = NULL ;
    ULONG *next_rid ;
    NTSTATUS NtStatus;
    DWORD dwErr = NERR_Success ;
    TCHAR *pBuffer, **ppchNext, **ppchResults ;
    ULONG i, cAccountAliases = 0, cBuiltinAliases = 0 ;
    SID_NAME_USE sidUse = SidTypeUnknown;

    /*
     * initialize the return info
     */
    *members = NULL,
    *count = 0 ;

    /* 
     * get sid from the user name 
     */
    if (dwErr = SamGetSIDFromName(user,  &pSidUser, &sidUse))
        return(dwErr) ;

    /* 
     * call SAM to enumerate the aliases the user is in for account domain
     */
    NtStatus = SamGetAliasMembership(AccountsDomainHandle, 
                                     1,
                                     &pSidUser,
                                     &cAccountAliases,
                                     &pRidAccountAliases) ;
    if (!NT_SUCCESS(NtStatus)) 
    {
        dwErr = NetpNtStatusToApiStatus(NtStatus) ;
        goto exitpoint ;
    }


    /* 
     * call SAM to enumerate the aliases the user is in for builtin domain
     */
    NtStatus = SamGetAliasMembership(BuiltInDomainHandle, 
                                     1,
                                     &pSidUser,
                                     &cBuiltinAliases,
                                     &pRidBuiltinAliases) ;
    if (!NT_SUCCESS(NtStatus)) 
    {
        dwErr = NetpNtStatusToApiStatus(NtStatus) ;
        goto exitpoint ;
    }

    /* 
     * if none, return now 
     */
    if ((cBuiltinAliases + cAccountAliases) == 0)
    {
        dwErr = NERR_Success ;
        goto exitpoint ;
    }

    /*
     * allocate buffer for array of strings, and NULL it.
     */
    if (dwErr = AllocMem( (cAccountAliases+cBuiltinAliases) * sizeof(TCHAR *), 
                           &pBuffer) )
        goto exitpoint ;

    memset(pBuffer, 0, (cAccountAliases+cBuiltinAliases)*sizeof(TCHAR *)) ;
    ppchNext = ppchResults = (TCHAR **) pBuffer ;

    /*
     * go thru each account alias returned and add the member to out buffer
     */
    for (i = 0, next_rid = pRidAccountAliases; 
         i < cAccountAliases; 
         i++, next_rid++)
    {
        BYTE *pSidBuffer ;

        /*
         * first off, convert the RID to SID. what a drag...
         */
        if (dwErr = SamGetSIDFromRID(AccountDomainSid, *next_rid, 
                                     (PSID *)&pSidBuffer))
            goto exitpoint ;

        /*
         * convert to strings. On error, free things up.
         */
        if (dwErr = SamGetNameFromSID(pSidBuffer, ppchNext))
        {
            if (dwErr == APE_UnknownAccount)
            {
                // we have bad or deleted SID, just ignore. 
                // ie. do nothing, dont advance pointer either.
            }
            else
            {
                // cleanup & go home
                while (i--)
                {
                   FreeMem(ppchResults[i]);
                }

                FreeMem(ppchResults);
                goto exitpoint ;
            }
        }
        else
        {
           ++ppchNext;
        }

        FreeMem(pSidBuffer);
    }

    /*
     * go thru each builtin alias returned and add the member to out buffer
     */
    for (next_rid = pRidBuiltinAliases; 
         i < cBuiltinAliases + cAccountAliases; 
         i++, next_rid++)
    {
        BYTE *pSidBuffer ;

        /*
         * first off, convert the RID to SID. what a drag...
         */
        if (dwErr = SamGetSIDFromRID(BuiltinDomainSid, *next_rid, 
                                     (PSID *)&pSidBuffer))
            goto exitpoint ;

        /*
         * convert to strings. On error, free things up.
         */
        if (dwErr = SamGetNameFromSID(pSidBuffer, ppchNext))
        {
            if (dwErr == APE_UnknownAccount)
            {
                // we have bad or deleted SID, just ignore. 
                // ie. do nothing, dont advance pointer either.
            }
            else
            {
                // cleanup & go home
                while (i--)
                {
                   FreeMem(ppchResults[i]);
                }

                FreeMem(ppchResults);
                goto exitpoint ;
            }
        }
        else
        {
           ++ppchNext;
        }

        FreeMem(pSidBuffer);
    }

    // setup return info
    *count = i ;   // number read minus the ones ignored.
    *members = ppchResults ;
    dwErr = NERR_Success ;

exitpoint:

    // dont need these anymore
    if (pRidBuiltinAliases) SamFreeMemory((CHAR *)pRidBuiltinAliases);
    if (pRidAccountAliases) SamFreeMemory((CHAR *)pRidAccountAliases);
    if (pSidUser) FreeMem(pSidUser);
    
    return(dwErr) ;
}

/*
 * UserFreeAliases
 *
 * Free the members memory used for members of an alias.
 *
 * return code: none
 * parameters:  members is pointer to an array of PSZs.
 *              count indicates how many members.
 */
VOID UserFreeAliases(TCHAR **members, DWORD count) 
{
    while (count--)
    {
        FreeMem(*members);
        ++members ;
    }
}


/*---------------------- misc sam/lsa related routines ----------------------*/


/*
 * SamCheckIfExists
 *
 * From an alias name, check if its already in the builtin Domain.
 *
 * return value: TRUE if it is, FALSE otherwise.
 * parameters:  name is account name. May be domain\user format.
 */
BOOL SamCheckIfExists(PUNICODE_STRING pAccount, 
                       SAM_HANDLE hDomain,
                       SID_NAME_USE use) 
{
    NTSTATUS NtStatus;
    PSID_NAME_USE pSidNameUse ;
    PULONG pulRelativeIds ;

    // do lookup 
    NtStatus = SamLookupNamesInDomain(hDomain,
                                      1,
                                      pAccount,
                                      &pulRelativeIds,
                                      &pSidNameUse) ;

    if (!NT_SUCCESS(NtStatus)) 
        return FALSE ;

    // could not translate, assume not there
    if ( (*pulRelativeIds != 0) && (*pSidNameUse == use) )
    {
        //
        // if the RID is non zero (successful lookup and
        // the name use is the same as the queried one, 
        // assume we have match.
        //
        SamFreeMemory(pSidNameUse);
        SamFreeMemory(pulRelativeIds);
        return TRUE ;
    }

    SamFreeMemory(pSidNameUse);
    SamFreeMemory(pulRelativeIds);
    return FALSE ;
}


BOOL IsLocalMachineWinNT(void)
{

   NT_PRODUCT_TYPE producttype ;

   RtlGetNtProductType(&producttype) ;
  
   return (producttype != NtProductLanManNt) ;
}

BOOL IsLocalMachineStandard(void)
{
   NT_PRODUCT_TYPE producttype ;

   RtlGetNtProductType(&producttype) ;
  
   return(producttype == NtProductServer) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\sam.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MSAM.H

Abstract:

    Contains mapping functions to present netcmd with non-unicode
    view of SAM.

Author:

    ChuckC       13-Apr-1992

Environment:

    User Mode - Win32

Revision History:

    13-Apr-1992     chuckc 	Created

--*/

/* 
 * define structure that contains the necessary display info
 */
typedef struct _ALIAS_ENTRY {
    TCHAR *name ;
    TCHAR *comment;
} ALIAS_ENTRY ;

#define READ_PRIV    1 
#define WRITE_PRIV   2 
#define CREATE_PRIV  3 

#define USE_BUILTIN_DOMAIN   	1
#define USE_ACCOUNT_DOMAIN   	2
#define USE_BUILTIN_OR_ACCOUNT  3

DWORD OpenSAM(TCHAR *server, ULONG priv) ;
VOID  CloseSAM(void) ;
DWORD SamEnumAliases(ALIAS_ENTRY **ppAlias, DWORD *pcAlias) ;
DWORD SamAddAlias(ALIAS_ENTRY *pAlias) ;
DWORD SamDelAlias(TCHAR *alias) ;
VOID  FreeAliasEntries(ALIAS_ENTRY *pAlias, ULONG cAlias) ;

DWORD OpenAlias(LPWSTR alias, ACCESS_MASK AccessMask, ULONG domain) ;
DWORD OpenAliasUsingRid(ULONG RelativeId, ACCESS_MASK AccessMask, ULONG domain) ;
VOID  CloseAlias(void) ;
DWORD AliasAddMember(TCHAR *member) ;
DWORD AliasDeleteMember(TCHAR *member) ;
DWORD AliasEnumMembers(TCHAR ***members, DWORD *count) ;
VOID  AliasFreeMembers(TCHAR **members, DWORD count) ;
DWORD AliasGetInfo(ALIAS_ENTRY *pAlias) ;
DWORD AliasSetInfo(ALIAS_ENTRY *pAlias) ;
DWORD UserEnumAliases(TCHAR *user, TCHAR ***members, DWORD *count) ;
VOID  UserFreeAliases(TCHAR **members, DWORD count) ;
DWORD SamGetNameFromRid(ULONG RelativeId, TCHAR **name, BOOL fIsBuiltin ) ;

BOOL  IsLocalMachineWinNT(void) ;
BOOL  IsLocalMachineStandard(void) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\session.c ===
/********************************************************************/
/**         Microsoft LAN Manager              **/
/**       Copyright(c) Microsoft Corp., 1987-1990      **/
/********************************************************************/

/***
 *  session.c
 *  Functions that display and disconnect user sessions to the
 *  server.
 *
 *  History:
 *  12/20/87, pjc, fix bug in null-name (enum) version with re-use of
 *             buf for both itoa calls in WriteToCon.
 *  07/08/87, eap, initial coding
 *  10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *  01/04/89, erichn, filenames now MAXPATHLEN LONG
 *  05/02/89, erichn, NLS conversion
 *  05/09/89, erichn, local security mods
 *  05/19/89, thomaspa, NETCMD output sorting
 *  06/08/89, erichn, canonicalization sweep
 *  02/20/91, danhi, change to use lm 16/32 mapping layer
 *  10/15/91, JohnRo, change to use DEFAULT_SERVER equate.
 */

/* Include files */

#define INCL_NOCOMMON
#define INCL_DOSFILEMGR
#define INCL_ERRORS
#include <os2.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <apperr.h>
#include <apperr2.h>
#include <stdio.h>
#include <stdlib.h>
#include <search.h>
#include <lui.h>
#include <lmshare.h>
#include "netcmds.h"
#include "nettext.h"

/* Constants */

#define SECS_PER_DAY 86400
#define SECS_PER_HOUR 3600
#define SECS_PER_MINUTE 60

/* Static variables */

static TCHAR * fmt3 = TEXT("%-9.9ws\r\n");


#define SESS_MSG_CMPTR      0
#define SESS_MSG_CLIENTTYPE ( SESS_MSG_CMPTR + 1 )
#define SESS_MSG_GUEST      ( SESS_MSG_CLIENTTYPE + 1 )
#define SESS_MSG_SESSTIME   ( SESS_MSG_GUEST + 1 )
#define SESS_MSG_IDLETIME   ( SESS_MSG_SESSTIME + 1 )
#define MSG_USER_NAME       ( SESS_MSG_IDLETIME + 1 )
#define USE_TYPE_DISK       ( MSG_USER_NAME + 1 )
#define USE_TYPE_IPC        ( USE_TYPE_DISK + 1 )
#define USE_TYPE_COMM       ( USE_TYPE_IPC + 1 )
#define USE_TYPE_PRINT      ( USE_TYPE_COMM + 1 )
#define MSG_YES         ( USE_TYPE_PRINT + 1 )
#define MSG_NO          ( MSG_YES + 1 )

static  MESSAGE SessMsgList[] = {
{ APE2_SESS_MSG_CMPTR,      NULL },
{ APE2_SESS_MSG_CLIENTTYPE, NULL },
{ APE2_SESS_MSG_GUEST,      NULL },
{ APE2_SESS_MSG_SESSTIME,   NULL },
{ APE2_SESS_MSG_IDLETIME,   NULL },
{ APE2_GEN_USER_NAME,       NULL },
{ APE2_USE_TYPE_DISK,       NULL },
{ APE2_USE_TYPE_IPC,        NULL },
{ APE2_USE_TYPE_COMM,       NULL },
{ APE2_USE_TYPE_PRINT,      NULL },
{ APE2_GEN_YES,         NULL },
{ APE2_GEN_NO,          NULL },
};

#define NUM_SESS_MSGS   (sizeof(SessMsgList)/sizeof(SessMsgList[0]))

#define YES_OR_NO(x) \
    ((TCHAR FAR *) (x ? SessMsgList[MSG_YES].msg_text \
             : SessMsgList[MSG_NO].msg_text) )

/* Forward declarations */
int __cdecl CmpSessInfo2(const VOID FAR *, const VOID far *) ;
int __cdecl CmpConnInfo1(const VOID FAR *, const VOID far *) ;

/***
 *  session_display()
 *  Lists all user sessions.
 *
 *  Args:
 *  name - the name of the server for which the info is desired.
 *
 *  Returns:
 */
VOID
session_display(TCHAR * name)
{
    DWORD                dwErr;
    DWORD                cTotalAvail;
    LPTSTR               pBuffer;
    DWORD                _read;       /* num entries read by API */
    DWORD                maxLen;     /* max message length */
    TCHAR                time_str[LUI_FORMAT_DURATION_LEN + 1];
    DWORD                i;
    USHORT               more_data = FALSE;
    LPSESSION_INFO_2     sess_list_entry;
    LPCONNECTION_INFO_1  conn_list_entry;
    TCHAR                txt_UNKNOWN[APE2_GEN_MAX_MSG_LEN];

    LUI_GetMsg(txt_UNKNOWN, APE2_GEN_MAX_MSG_LEN, APE2_GEN_UNKNOWN);

    if (name == NULL)
    {
    if ((dwErr = NetSessionEnum(
                   DEFAULT_SERVER,
                   NULL,
                   NULL,
                   2,
                   (LPBYTE*)&pBuffer,
                   MAX_PREFERRED_LENGTH,
                   &_read,
                   &cTotalAvail,
                   NULL)) == ERROR_MORE_DATA)
        more_data = TRUE;
    else if (dwErr)
        ErrorExit (dwErr);

    if (_read == 0)
        EmptyExit();

    qsort(pBuffer, _read, sizeof(SESSION_INFO_2), CmpSessInfo2);

    PrintNL();
    InfoPrint(APE2_SESS_MSG_HDR);
    PrintLine();

    /* Display the listing */

    for (i = 0, sess_list_entry = (LPSESSION_INFO_2) pBuffer;
        i < _read; i++, sess_list_entry++)
    {
        if( sess_list_entry->sesi2_cname != NULL )
        {
            LUI_FormatDuration((LONG *) &(sess_list_entry->sesi2_idle_time),
                               time_str,
                               DIMENSION(time_str));

            {
                TCHAR buffer1[22],buffer2[22],buffer3[18];

                WriteToCon(TEXT("\\\\%Fws%Fws%Fws%6u %ws\r\n"),
                           PaddedString(21,sess_list_entry->sesi2_cname,buffer1),
                           PaddedString(21,(sess_list_entry->sesi2_username == NULL) ?
                                    (TCHAR FAR *)txt_UNKNOWN :
                                    sess_list_entry->sesi2_username,buffer2),
                           PaddedString(17,(sess_list_entry->sesi2_cltype_name == NULL) ?
                                    (TCHAR FAR *)txt_UNKNOWN :
                                    sess_list_entry->sesi2_cltype_name,buffer3),
                           sess_list_entry->sesi2_num_opens,
                           PaddedString(12,time_str,NULL));
            }
        }
    }

    NetApiBufferFree(pBuffer);
    }
    else
    {
    if (dwErr = NetSessionGetInfo(DEFAULT_SERVER,
                                  name,
                                  L"",
                                  2,
                                 (LPBYTE *) &sess_list_entry))
    {
        ErrorExit (dwErr);
    }

    GetMessageList(NUM_SESS_MSGS, SessMsgList, &maxLen);

    maxLen += 5;

    /* Print the computer and user name etc... */

    WriteToCon(fmtPSZ, 0, maxLen,
               PaddedString(maxLen, SessMsgList[MSG_USER_NAME].msg_text, NULL),
               sess_list_entry->sesi2_username);

    WriteToCon(fmtPSZ, 0, maxLen,
               PaddedString(maxLen, SessMsgList[SESS_MSG_CMPTR].msg_text, NULL),
               sess_list_entry->sesi2_cname);

    WriteToCon(fmtPSZ, 0, maxLen,
               PaddedString(maxLen, SessMsgList[SESS_MSG_GUEST].msg_text, NULL),
               YES_OR_NO(sess_list_entry->sesi2_user_flags & SESS_GUEST) );

    WriteToCon(fmtPSZ, 0, maxLen,
               PaddedString(maxLen, SessMsgList[SESS_MSG_CLIENTTYPE].msg_text, NULL),
               sess_list_entry->sesi2_cltype_name);

    LUI_FormatDuration((LONG FAR *) &(sess_list_entry->sesi2_time),
        time_str, DIMENSION(time_str));

    WriteToCon(fmtNPSZ, 0, maxLen,
               PaddedString(maxLen, SessMsgList[SESS_MSG_SESSTIME].msg_text, NULL),
               time_str);

    LUI_FormatDuration((LONG FAR *) &(sess_list_entry->sesi2_idle_time),
        time_str, DIMENSION(time_str));

    WriteToCon(fmtNPSZ, 0, maxLen,
               PaddedString(maxLen, SessMsgList[SESS_MSG_IDLETIME].msg_text, NULL),
               time_str);

    /* Print the header */

    PrintNL();
    InfoPrint(APE2_SESS_MSG_HDR2);
    PrintLine();

    NetApiBufferFree((TCHAR FAR *) sess_list_entry);

    /* Print the listing of the connections */

    if ((dwErr = NetConnectionEnum(
                     DEFAULT_SERVER,
                     name,
                     1,
                     (LPBYTE*)&pBuffer,
                     MAX_PREFERRED_LENGTH,
                     &_read,
                     &cTotalAvail,
                     NULL)) == ERROR_MORE_DATA)
        more_data = TRUE;
    else if( dwErr )
        ErrorExit (dwErr);

    qsort(pBuffer, _read, sizeof(CONNECTION_INFO_1), CmpConnInfo1);

    for ( i = 0,
          conn_list_entry = (LPCONNECTION_INFO_1) pBuffer;
          i < _read; i++, conn_list_entry++)
    {
        WriteToCon(TEXT("%Fws"),
                   PaddedString(15, conn_list_entry->coni1_netname == NULL
                                    ? (TCHAR FAR *)txt_UNKNOWN :
                                      conn_list_entry->coni1_netname,NULL));

        /* NOTE : the only type that can have # open is disk . */

        switch ( conn_list_entry->coni1_type )
        {
        case STYPE_DISKTREE :
        WriteToCon(TEXT("%ws%u\r\n"),
            PaddedString(9,SessMsgList[USE_TYPE_DISK].msg_text,NULL),
            conn_list_entry->coni1_num_opens);
        break;

        case STYPE_PRINTQ :
        WriteToCon(fmt3, SessMsgList[USE_TYPE_PRINT].msg_text);
        break;

        case STYPE_DEVICE :
        WriteToCon(fmt3, SessMsgList[USE_TYPE_COMM].msg_text);
        break;

        case STYPE_IPC :
        WriteToCon(fmt3, SessMsgList[USE_TYPE_IPC].msg_text);
        break;
#ifdef TRACE
        default:
        WriteToCon(TEXT("Unknown Type\r\n"));
        break;
#endif
        }
    }
    NetApiBufferFree(pBuffer);
    }

    if( more_data )
    InfoPrint( APE_MoreData);
    else
    InfoSuccess();
}



/***
 *  CmpSessInfo2(sess1,sess2)
 *
 *  Compares two SESSION_INFO_2 structures and returns a relative
 *  lexical value, suitable for using in qsort.
 *
 */

int __cdecl CmpSessInfo2(const VOID FAR * sess1, const VOID FAR * sess2)
{
    if (((LPSESSION_INFO_2) sess1)->sesi2_cname == NULL)
    {
        if (((LPSESSION_INFO_2) sess2)->sesi2_cname == NULL)
            return( 0 );
        else
            return( -1 );
    }
    else if (((LPSESSION_INFO_2) sess2)->sesi2_cname == NULL)
    {
        return( 1 );
    }

    return _tcsicmp(((LPSESSION_INFO_2) sess1)->sesi2_cname,
                    ((LPSESSION_INFO_2) sess2)->sesi2_cname);
}


/***
 *  CmpConnInfo1(conn1,conn2)
 *
 *  Compares two CONNECTION_INFO_1 structures and returns a relative
 *  lexical value, suitable for using in qsort.
 *
 */

int __cdecl CmpConnInfo1(const VOID FAR * conn1, const VOID FAR * conn2)
{
    if (((LPCONNECTION_INFO_1) conn1)->coni1_netname == NULL)
    {
        if(((LPCONNECTION_INFO_1) conn2)->coni1_netname == NULL )
            return( 0 );
        else
            return( - 1 );
    }
    else if (((LPCONNECTION_INFO_1) conn2)->coni1_netname == NULL)
    {
        return( 1 );
    }

    return _tcsicmp(((LPCONNECTION_INFO_1) conn1)->coni1_netname,
                    ((LPCONNECTION_INFO_1) conn2)->coni1_netname);
}



/***
 *  session_del_all()
 *  Disconnect all sessions at the local server.
 *
 *  Args:
 *  print_ok     - OK to print CCS?
 *  actually_del - if 0, we skip the actual deletions since server
 *                 is going down anyway.
 *
 */
VOID session_del_all(int print_ok, int actually_del)
{
    DWORD             dwErr;        /* API return status */
    DWORD             cTotalAvail;
    LPTSTR            pBuffer;
    DWORD             _read;      /* num entries read by API */
    TCHAR             tbuf[MAX_PATH+1];
    DWORD             i,j = 0;
    TCHAR             txt_UNKNOWN[APE2_GEN_MAX_MSG_LEN];
    USHORT            more_data = FALSE;
    LPSESSION_INFO_1  sess_list_entry;

    LUI_GetMsg(txt_UNKNOWN, APE2_GEN_MAX_MSG_LEN, APE2_GEN_UNKNOWN);

    if ((dwErr = NetSessionEnum(
                  DEFAULT_SERVER,
                  NULL,
                  NULL,
                  1,
                  (LPBYTE*)&pBuffer,
                  MAX_PREFERRED_LENGTH,
                  &_read,
                  &cTotalAvail,
                  NULL)) == ERROR_MORE_DATA) {

        more_data = TRUE;
    }
    else if (dwErr) {
        ErrorExit (dwErr);
    }

    if (_read == 0) {

        if (print_ok) {
            InfoSuccess();
        }

        return;
    }


    /* List sessions */

    InfoPrint(APE_SessionList);

    for (i = 0, sess_list_entry = (LPSESSION_INFO_1) pBuffer;
        i < _read; i++, sess_list_entry++) {

        if (sess_list_entry->sesi1_num_opens > 0) {
            j++;
        }

        WriteToCon(TEXT("%Fws"),
                   PaddedString(25,(sess_list_entry->sesi1_cname == NULL)
                                   ? (TCHAR FAR *)txt_UNKNOWN :
                                     sess_list_entry->sesi1_cname,NULL));
        if (((i + 1) % 3) == 0)
            PrintNL();
    }

    if ((i % 3) != 0)
        PrintNL();

    if (!YorN(APE_OkToProceed, 1))
        NetcmdExit(2);

    /* List sessions with open files */

    if (j) {

        InfoPrint(APE_SessionOpenList);

        for (i=0, j=0, sess_list_entry = (LPSESSION_INFO_1) pBuffer;
            i < _read; i++, sess_list_entry++)
        {
            if (sess_list_entry->sesi1_num_opens > 0)
            {
                j++;
                WriteToCon(TEXT("%Fws"),
                           PaddedString(25, (sess_list_entry->sesi1_cname == NULL)
                                            ? (TCHAR FAR *)txt_UNKNOWN :
                                              sess_list_entry->sesi1_cname,NULL));
            if (j && ((j % 3) == 0))
                PrintNL();
            }
        }

        if ((j % 3) != 0)
            PrintNL();

        if (!YorN(APE_OkToProceed, 0))
            NetcmdExit(2);
    }

    if (!actually_del)
    {
        NetApiBufferFree(pBuffer);
        return;
    }

    /* Close sessions */

    _tcscpy(tbuf, TEXT("\\\\"));

    for (i = 0, sess_list_entry = (LPSESSION_INFO_1) pBuffer;
    i < _read; i++, sess_list_entry++)
    {
        if( sess_list_entry->sesi1_cname )
        {
            _tcscpy(tbuf+2, sess_list_entry->sesi1_cname);
            if ((dwErr = NetSessionDel(DEFAULT_SERVER, tbuf, NULL)) &&
                (dwErr != NERR_ClientNameNotFound))
                    ErrorExit (dwErr);
        }
    }

    NetApiBufferFree(pBuffer);

    if (print_ok)
        if( more_data )
            InfoPrint( APE_MoreData);
        else
            InfoSuccess();
}



/***
 *  session_del()
 *  Disconnect a session at the local server.
 *
 *  Args:
 *  name - the name of the session to disconnect
 *
 */
VOID session_del(TCHAR * name)
{
    DWORD             dwErr;        /* API return status */
    LPSESSION_INFO_1  sess_list_entry;


    if (dwErr = NetSessionGetInfo(DEFAULT_SERVER,
                                  name,
                                  L"",
                                  1,
                                  (LPBYTE *) &sess_list_entry))
    {
        ErrorExit(dwErr);
    }

    if ( sess_list_entry->sesi1_num_opens )
    {
    /* Warn the administrator */
    InfoPrintInsTxt(APE_SessionOpenFiles, sess_list_entry->sesi1_cname);

    if (!YorN(APE_OkToProceed, 0))
        NetcmdExit(2);
    }

    if (dwErr = NetSessionDel(DEFAULT_SERVER, name, NULL))
        ErrorExit (dwErr);

    NetApiBufferFree((TCHAR FAR *) sess_list_entry);

    InfoSuccess();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\share.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/***
 *  share.c
 *      functions for controlling shares on a server
 *
 *  History:
 *      mm/dd/yy, who, comment
 *      06/30/87, andyh, new code
 *      10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *      05/02/89, erichn, NLS conversion
 *      05/09/89, erichn, local security mods
 *      05/19/89, erichn, NETCMD output sorting
 *      06/08/89, erichn, canonicalization sweep
 *      06/23/89, erichn, replaced old NetI canon calls with new I_Net
 *      11/19/89, paulc,  fix bug 4772
 *      02/15/91, danhi,  convert to 16/32 mapping layer
 *      02/26/91, robdu, fix lm21 bug 818 (nonFAT sharename warning)
 *      05/28/91, robdu, fix lm21 bug 1800 (ignore share /d during spooling)
 */

/* Include files */

#define INCL_NOCOMMON
#define INCL_DOSFILEMGR
#define INCL_ERRORS
#include <os2.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <search.h>
#include "mserver.h"
#include <lui.h>
#include <dosprint.h>
#include <lmshare.h>
#include <lmaccess.h>
#include <dlserver.h>
#include <apperr.h>
#include <apperr2.h>
#define INCL_ERROR_H
#include <icanon.h>
#include "netcmds.h"
#include "nettext.h"
#include "msystem.h"

/* Forward declarations */

VOID   NEAR share_munge(LPSHARE_INFO_2, DWORD *CacheFlag);
VOID   NEAR check_max_uses(VOID);
DWORD  delete_share(LPTSTR);
VOID   NEAR get_print_devices(LPTSTR);
int    __cdecl CmpShrInfo2(const VOID *, const VOID *);


#define SHARE_MSG_SPOOLED           0
#define SHARE_MSG_NAME              ( SHARE_MSG_SPOOLED + 1 )
#define SHARE_MSG_DEVICE            ( SHARE_MSG_NAME + 1)
#define SHARE_MSG_PERM              ( SHARE_MSG_DEVICE + 1 )
#define SHARE_MSG_MAX_USERS         ( SHARE_MSG_PERM + 1 )
#define SHARE_MSG_ULIMIT            ( SHARE_MSG_MAX_USERS + 1 )
#define SHARE_MSG_USERS             ( SHARE_MSG_ULIMIT + 1 )
#define SHARE_MSG_CACHING           ( SHARE_MSG_USERS + 1 )
#define SHARE_MSG_PATH              ( SHARE_MSG_CACHING + 1 )
#define SHARE_MSG_REMARK            ( SHARE_MSG_PATH + 1 )
#define SHARE_MSG_CACHED_MANUAL     ( SHARE_MSG_REMARK + 1 )
#define SHARE_MSG_CACHED_AUTO       ( SHARE_MSG_CACHED_MANUAL + 1 )
#define SHARE_MSG_CACHED_VDO        ( SHARE_MSG_CACHED_AUTO + 1 )
#define SHARE_MSG_CACHED_DISABLED   ( SHARE_MSG_CACHED_VDO + 1 )

#define SWITCH_CACHE_AUTOMATIC      ( SHARE_MSG_CACHED_DISABLED+1)
#define SWITCH_CACHE_MANUAL         ( SWITCH_CACHE_AUTOMATIC+1)
#de