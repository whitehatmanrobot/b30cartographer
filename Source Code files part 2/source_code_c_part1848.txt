    DBGPRINT((sdlError,
                          "SdbpCloseAndUnmapFile",
                          "ZwClose on file failed Status 0x%x\n",
                          Status));
            }

            pImageData->hFile = INVALID_HANDLE_VALUE;
        }
    }

    return bSuccess;
}


NTSTATUS
SdbpUpcaseUnicodeStringToMultiByteN(
    OUT LPSTR   lpszDest,       // dest buffer
    IN  DWORD   dwSize,         // size in characters, excluding unicode_null
    IN  LPCWSTR lpszSrc         // source
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Convert up to dwSize characters from Unicode to ANSI.
--*/
{
    ANSI_STRING    strDest;
    UNICODE_STRING ustrSource;
    NTSTATUS       Status;
    UNICODE_STRING ustrUpcaseSource = { 0 };
    USHORT         DestBufSize = (USHORT)dwSize * sizeof(WCHAR);

    RtlInitUnicodeString(&ustrSource, lpszSrc);

    STACK_ALLOC(ustrUpcaseSource.Buffer, ustrSource.MaximumLength);

    if (ustrUpcaseSource.Buffer == NULL) {
        DBGPRINT((sdlError,
                  "SdbpUnicodeToMultiByteN",
                  "Failed to allocate %d bytes on the stack\n",
                  (DWORD)ustrSource.MaximumLength));
        return STATUS_NO_MEMORY;
    }

    ustrUpcaseSource.MaximumLength = ustrSource.MaximumLength;
    ustrUpcaseSource.Length        = 0;

    Status = RtlUpcaseUnicodeString(&ustrUpcaseSource, &ustrSource, FALSE);
    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpUnicodeToMultiByteN",
                  "RtlUpcaseUnicodeString failed Status 0x%x\n",
                  Status));
        goto Done;
    }

    if (ustrUpcaseSource.Length > DestBufSize) {
        ustrUpcaseSource.Length = DestBufSize;
    }

    strDest.Buffer        = lpszDest;
    strDest.MaximumLength = DestBufSize + sizeof(UNICODE_NULL);
    strDest.Length        = 0;

    Status = RtlUnicodeStringToAnsiString(&strDest, &ustrUpcaseSource, FALSE);
    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpUnicodeToMultiByteN",
                  "RtlUnicodeStringToAnsiString failed Status 0x%x\n",
                  Status));
    }

Done:

    if (ustrUpcaseSource.Buffer != NULL) {
        STACK_FREE(ustrUpcaseSource.Buffer);
    }

    return Status;
}


BOOL
SdbpQueryFileDirectoryAttributesNT(
    PIMAGEFILEDATA           pImageData,
    PFILEDIRECTORYATTRIBUTES pFileDirectoryAttributes
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   BUGBUG: ?
--*/
{
    LARGE_INTEGER liFileSize;

    liFileSize.QuadPart = pImageData->FileSize;

    pFileDirectoryAttributes->dwFlags       |= FDA_FILESIZE;
    pFileDirectoryAttributes->dwFileSizeHigh = liFileSize.HighPart;
    pFileDirectoryAttributes->dwFileSizeLow  = liFileSize.LowPart;

    return TRUE;
}


BOOL
SdbpDoesFileExists_U(
    LPCWSTR pwszPath
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   BUGBUG: ?
--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    ustrFileName;
    HANDLE            hFile;
    NTSTATUS          Status;
    IO_STATUS_BLOCK   IoStatusBlock;

    RtlInitUnicodeString(&ustrFileName, pwszPath);

    InitializeObjectAttributes(&ObjectAttributes,
                               &ustrFileName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwCreateFile(&hFile,
                          STANDARD_RIGHTS_REQUIRED |
                            FILE_READ_ATTRIBUTES,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,                      // AllocationSize
                          FILE_ATTRIBUTE_NORMAL,     // FileAttributes
                          FILE_SHARE_READ,           // Share Access
                          FILE_OPEN,                 // Create Disposition
                          FILE_NON_DIRECTORY_FILE |  // Create Options
                            FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,                      // EaBuffer
                          0);                        // EaLength


    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpDoesFileExists_U",
                  "Failed to create file. Status 0x%x\n",
                  Status));
        return FALSE;
    }

    ZwClose(hFile);

    return TRUE;
}


PVOID
SdbGetFileInfo(
    IN  HSDB    hSDB,
    IN  LPCWSTR pwszFilePath,
    IN  HANDLE  hFile,      // handle for the file in question
    IN  LPVOID  pImageBase, // image base for this file
    IN  DWORD   dwImageSize, 
    IN  BOOL    bNoCache
    )
/*++
    Return: BUGBUG: ?

    Desc:   Create and link a new entry in a file attribute cache.
--*/
{
    PSDBCONTEXT        pContext = (PSDBCONTEXT)hSDB;
    LPCWSTR            FullPath = pwszFilePath;
    NTSTATUS           Status;
    PFILEINFO          pFileInfo = NULL;
    UNICODE_STRING     FullPathU;

    if (!bNoCache) {
        pFileInfo = FindFileInfo(pContext, FullPath);
    }

    if (pFileInfo == NULL) {
        if (hFile != INVALID_HANDLE_VALUE || pImageBase != NULL || SdbpDoesFileExists_U(FullPath)) {
            RtlInitUnicodeString(&FullPathU, FullPath);

            pFileInfo = CreateFileInfo(pContext,
                                       FullPathU.Buffer,
                                       FullPathU.Length / sizeof(WCHAR),
                                       hFile,
                                       pImageBase,
                                       dwImageSize,
                                       bNoCache);
        }
    }

    return (PVOID)pFileInfo;
}


WCHAR*
DuplicateUnicodeString(
    PUNICODE_STRING pStr,
    PUSHORT         pLength     // pLength is an allocated length
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    WCHAR* pBuffer = NULL;
    USHORT Length  = 0;

    if (pStr != NULL && pStr->Length > 0) {

        Length = pStr->Length + sizeof(UNICODE_NULL);

        pBuffer = (WCHAR*)SdbAlloc(Length);

        if (pBuffer == NULL) {
            DBGPRINT((sdlError,
                      "DuplicateUnicodeString",
                      "Failed to allocate %d bytes\n",
                      Length));
            return NULL;
        }

        RtlMoveMemory(pBuffer, pStr->Buffer, pStr->Length);
        pBuffer[pStr->Length/sizeof(WCHAR)] = UNICODE_NULL;
    }

    if (pLength != NULL) {
        *pLength = Length;
    }

    return pBuffer;
}

BOOL
SdbpCreateUnicodeString(
    PUNICODE_STRING pStr,
    LPCWSTR         lpwsz
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    USHORT         Length;
    UNICODE_STRING ustrSrc;

    RtlZeroMemory(pStr, sizeof(*pStr));
    RtlInitUnicodeString(&ustrSrc, lpwsz);

    pStr->Buffer = DuplicateUnicodeString(&ustrSrc, &Length);
    pStr->Length = ustrSrc.Length;
    pStr->MaximumLength = Length;


    return pStr->Buffer != NULL;
}

BOOL
SdbpGetFileDirectoryAttributesNT(
    OUT PFILEINFO      pFileInfo,
    IN  PIMAGEFILEDATA pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function retrieves the header attributes for the
            specified file.
--*/
{
    BOOL bSuccess = FALSE;
    FILEDIRECTORYATTRIBUTES fda;
    int i;

    bSuccess = SdbpQueryFileDirectoryAttributesNT(pImageData, &fda);
    if (!bSuccess) {
        DBGPRINT((sdlInfo,
                  "SdbpGetFileDirectoryAttributesNT",
                  "No file directory attributes available.\n"));
        goto Done;
    }

    if (fda.dwFlags & FDA_FILESIZE) {
        assert(fda.dwFileSizeHigh == 0);
        SdbpSetAttribute(pFileInfo, TAG_SIZE, &fda.dwFileSizeLow);
    }

Done:

    if (!bSuccess) {
        for (i = 0; g_rgDirectoryTags[i] != 0; ++i) {
            SdbpSetAttribute(pFileInfo, g_rgDirectoryTags[i], NULL);
        }
    }

    return bSuccess;
}


#ifdef _DEBUG_SPEW
extern DBGLEVELINFO g_rgDbgLevelInfo[];
extern PCH          g_szDbgLevelUser;
#endif // _DEBUG_SPEW

int __cdecl
ShimDbgPrint(
    int iLevel,
    PCH pszFunctionName,
    PCH Format,
    ...
    )
{
    int nch = 0;

#ifdef _DEBUG_SPEW

    PCH     pszFormat = NULL;
    va_list arglist;
    ULONG   Level = 0;
    int     i;
    CHAR    szPrefix[64];
    PCH     pchBuffer = szPrefix;
    PCH     pchLevel  = NULL;

    PREPARE_FORMAT(pszFormat, Format);

    if (pszFormat == NULL) {
        //
        // Can't convert format for debug output
        //
        return 0;
    }

    //
    // Do we have a comment for this debug level? if so, print it
    //
    for (i = 0; i < DEBUG_LEVELS; ++i) {
        if (g_rgDbgLevelInfo[i].iLevel == iLevel) {
            pchLevel = (PCH)g_rgDbgLevelInfo[i].szStrTag;
            break;
        }
    }

    if (pchLevel == NULL) {
        pchLevel = g_szDbgLevelUser;
    }

    nch = sprintf(pchBuffer, "[%-4hs]", pchLevel);
    pchBuffer += nch;

    if (pszFunctionName) {
        //
        // Single-byte char going into UNICODE buffer
        //
        nch = sprintf(pchBuffer, "[%-30hs] ", pszFunctionName);
        pchBuffer += nch;
    }

    switch (iLevel) {
    
    case sdlError:
        Level = (1 << DPFLTR_ERROR_LEVEL) | DPFLTR_MASK;
        break;

    case sdlWarning:
        Level = (1 << DPFLTR_WARNING_LEVEL) | DPFLTR_MASK;
        break;

    case sdlInfo:
        Level = (1 << DPFLTR_TRACE_LEVEL) | DPFLTR_MASK;
        break;
    }

    va_start(arglist, Format);

    nch  = (int)vDbgPrintExWithPrefix(szPrefix,
                                      DPFLTR_NTOSPNP_ID,
                                      Level,
                                      pszFormat,
                                      arglist);

    va_end(arglist);
    STACK_FREE(pszFormat);

#endif // _DEBUG_SPEW

    return nch;
}


#endif // KERNEL_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\chm.h ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    chm.h
//
// History: 21-Mar-00   vadimb     Created.
//
// Desc:    Header for chm.cpp
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef __CHM_H__
#define __CHM_H__

BOOL ChmWriteProject(
    SdbOutputFile* pOutputFile,
    SdbDatabase* pAppHelpDB);


#endif  // __CHM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\lib\apphelp.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        apphelp.c

    Abstract:

        This module implements high-level functions to access apphelp information

    Author:

        dmunsil     created     sometime in 1999

    Revision History:

--*/

#include "sdbp.h"

#define SIZE_WSTRING(pwsz) \
    (pwsz == NULL ? 0 : (wcslen((LPCWSTR)(pwsz)) * sizeof(WCHAR) + sizeof(UNICODE_NULL)))

WCHAR g_szHackURL[MAX_PATH];

BOOL
SdbReadApphelpDetailsData(
    IN  PDB           pdb,      // apphelp.sdb handle
    OUT PAPPHELP_DATA pData     // apphelp data, which is filled with various bits of information
    )
/*++
    Return: TRUE if the string was read, FALSE if not.

    Desc:   This function retrieves APPHELP details from apphelp.sdb. The database
            should have a valid index on HTMLHELPID. In addition, we assume that
            the compiler generated unique entries for the htmlhelpids. Tthat means,
            no two items have identical indexes. The logic to do so has been
            specifically built into shimdbc. If this ever changes, this function will
            have to be changed as well.
--*/
{
    BOOL      bSuccess = FALSE;
    TAGID     tiApphelp;
    TAGID     tiAppTitle;
    TAGID     tiContact;
    TAGID     tiDetails;
    TAGID     tiLink;
    TAGID     tiURL;
    TAGID     tiLinkText;
    FIND_INFO FindInfo;
    DWORD     crtLangId;

    if (!SdbIsIndexAvailable(pdb, TAG_APPHELP, TAG_HTMLHELPID)) {
        DBGPRINT((sdlError,
                  "SdbReadApphelpDetailsData",
                  "HTMLHELPID index in details database is not available.\n"));
        return FALSE;
    }

    tiApphelp = SdbFindFirstDWORDIndexedTag(pdb,
                                            TAG_APPHELP,
                                            TAG_HTMLHELPID,
                                            pData->dwHTMLHelpID,
                                            &FindInfo);

    if (!tiApphelp) {
        DBGPRINT((sdlError,
                  "SdbReadApphelpDetailsData",
                  "Failed to find HTMLHELPID 0x%x in the details database.\n",
                  pData->dwHTMLHelpID));
        return FALSE;
    }

    crtLangId = (DWORD)GetUserDefaultUILanguage();

    //
    // Loop through the items until we get to a match with the current langid
    //
    while (1) {

        TAGID tiHtmlHelpId;
        TAGID tiLangId;
        DWORD dwHtmlHelpId;
        DWORD langId;

        tiHtmlHelpId = SdbFindFirstTag(pdb, tiApphelp, TAG_HTMLHELPID);

        if (tiHtmlHelpId == TAGID_NULL) {
            DBGPRINT((sdlError,
                      "SdbReadApphelpDetailsData",
                      "Failed to get HTMLHELPID for entry 0x%x.\n",
                      tiApphelp));
            return FALSE;
        }

        dwHtmlHelpId = SdbReadDWORDTag(pdb, tiHtmlHelpId, 0);

        if (dwHtmlHelpId != pData->dwHTMLHelpID) {
            DBGPRINT((sdlError,
                      "SdbReadApphelpDetailsData",
                      "No entry with the same HTMLHELPID for 0x%x.\n",
                      tiApphelp));
            return FALSE;
        }

        tiLangId = SdbFindFirstTag(pdb, tiApphelp, TAG_LANGID);

        if (tiLangId == TAGID_NULL) {
            break;
        }
        langId = SdbReadDWORDTag(pdb, tiLangId, 0);

        if (langId == crtLangId || langId == 0) {
            break;
        }

        tiApphelp = SdbFindNextDWORDIndexedTag(pdb, &FindInfo);

        if (tiApphelp == TAGID_NULL) {
            DBGPRINT((sdlError,
                      "SdbReadApphelpDetailsData",
                      "No entry for HTMLHELPID 0x%x.\n",
                      pData->dwHTMLHelpID));
            return FALSE;
        }
    }

    //
    // Now find the link. We support multiple links but use only one for now.
    //
    tiLink = SdbFindFirstTag(pdb, tiApphelp, TAG_LINK);
    if (tiLink) {
        tiURL = SdbFindFirstTag(pdb, tiLink, TAG_LINK_URL);
        if (tiURL) {
            GUID guidDB = { 0 };

            pData->szURL = SdbGetStringTagPtr(pdb, tiURL);

            //
            // HORIBLE HACK to fix the URL for XP Gold
            // Do this horrible hack only when pdb is not a custom
            // database; do so by comparing db guid to the standard
            // "details" guid
            //
            if (SdbGetDatabaseID(pdb, &guidDB) &&
                (!memcmp(&guidDB, &GUID_APPHELP_SDB, sizeof(GUID)) ||
                 !memcmp(&guidDB, &GUID_APPHELP_SP_SDB, sizeof(GUID)))) {

                if (pData->szURL != NULL &&
                    *pData->szURL != TEXT('\0') &&
                    wcsstr(pData->szURL, L"clcid") == NULL) {

                    _stprintf(g_szHackURL, L"%s&clcid=0x%x", pData->szURL, crtLangId);
                    pData->szURL = g_szHackURL;
                }
            }
        }
        tiLinkText = SdbFindFirstTag(pdb, tiLink, TAG_LINK_TEXT);
        if (tiLinkText) {
            pData->szLink = SdbGetStringTagPtr(pdb, tiLinkText);
        }
    }

    tiDetails = SdbFindFirstTag(pdb, tiApphelp, TAG_APPHELP_DETAILS);
    if (tiDetails) {
        pData->szDetails = SdbGetStringTagPtr(pdb, tiDetails);
    }

    tiContact = SdbFindFirstTag(pdb, tiApphelp, TAG_APPHELP_CONTACT);
    if (tiContact) {
        pData->szContact = SdbGetStringTagPtr(pdb, tiContact);
    }

    tiAppTitle = SdbFindFirstTag(pdb, tiApphelp, TAG_APPHELP_TITLE);
    if (tiAppTitle) {
        pData->szAppTitle = SdbGetStringTagPtr(pdb, tiAppTitle);
    }

    bSuccess = TRUE;

    return bSuccess;
}


BOOL
SdbReadApphelpData(
    IN  HSDB          hSDB,     // handle to the database channel
    IN  TAGREF        trExe,    // TAGREF of the EXE with data to read
    OUT PAPPHELP_DATA pData     // data that we read
    )
/*++
    Return: TRUE if the string was read, FALSE if not.

    Desc:   Read the data associated with the apphelp entry
            into APPHELP_DATA structure. If there are no apphelp data
            for this exe, then the function returns FALSE.
            One or more members of the APPHELP_DATA structure may
            be 0.
--*/
{
    TAGID tiAppHelp,
          tiAppName,
          tiProblemSeverity,
          tiFlags,
          tiHtmlHelpID;
    TAGID tiExe,
          tiSP;
    PDB   pdb;

    if (pData) {
        RtlZeroMemory(pData, sizeof(APPHELP_DATA));
    }

    if (!SdbTagRefToTagID(hSDB, trExe, &pdb, &tiExe)) {
        DBGPRINT((sdlError,
                  "SdbReadApphelpData",
                  "Failed to get the TAGID for TAGREF 0x%x.\n",
                  trExe));
        return FALSE;
    }

    tiAppHelp = SdbFindFirstTag(pdb, tiExe, TAG_APPHELP);

    if (tiAppHelp == TAGID_NULL) {
        //
        // This is not an apphelp entry
        //
        DBGPRINT((sdlInfo,
                  "SdbReadApphelpData",
                  "This is not an apphelp entry tiExe 0x%x.\n",
                  tiExe));
        return FALSE;
    }

    //
    // if we are just checking for data being present - return now
    //

    if (pData == NULL) {
        return TRUE;
    }

    pData->trExe = trExe;

    tiSP = SdbFindFirstTag(pdb, tiAppHelp, TAG_USE_SERVICE_PACK_FILES);

    pData->bSPEntry = (tiSP != TAGID_NULL);

    //
    // Read supplemental flags.
    //
    tiFlags = SdbFindFirstTag(pdb, tiAppHelp, TAG_FLAGS);

    if (tiFlags != TAGID_NULL) {
        pData->dwFlags = SdbReadDWORDTag(pdb, tiFlags, 0);
    }

    //
    // Read problem severity for this app.
    //
    tiProblemSeverity = SdbFindFirstTag(pdb, tiAppHelp, TAG_PROBLEMSEVERITY);

    if (tiProblemSeverity != TAGID_NULL) {
        pData->dwSeverity = SdbReadDWORDTag(pdb, tiProblemSeverity, 0);
    }

    if (pData->dwSeverity == 0) {
        DBGPRINT((sdlError,
                  "SdbReadApphelpData",
                  "Problem severity for tiExe 0x%x missing.\n",
                  tiExe));
        return FALSE;
    }

    //
    // We should have html help id here.
    //
    tiHtmlHelpID = SdbFindFirstTag(pdb, tiAppHelp, TAG_HTMLHELPID);

    if (tiHtmlHelpID != TAGID_NULL) {
        pData->dwHTMLHelpID = SdbReadDWORDTag(pdb, tiHtmlHelpID, 0);
    }

    //
    // While we are at it, include app's name for now. We might need it.
    //
    tiAppName = SdbFindFirstTag(pdb, tiExe, TAG_APP_NAME);

    if (tiAppName != TAGID_NULL) {
        pData->szAppName = SdbGetStringTagPtr(pdb, tiAppName);
    }

    return TRUE;
}

BOOL
SDBAPI
SdbEscapeApphelpURL(
    LPWSTR    szResult,     // escaped string (output)
    LPDWORD   pdwCount,      // count of tchars in the buffer pointed to by szResult
    LPCWSTR   szToEscape    // string to escape
    )
{
    static const BYTE s_grfbitEscape[] =
    {
        0xFF, 0xFF, // 00 - 0F
        0xFF, 0xFF, // 10 - 1F
        0xFF, 0x13, // 20 - 2F
        0x00, 0xFC, // 30 - 3F
        0x00, 0x00, // 40 - 4F
        0x00, 0x78, // 50 - 5F
        0x01, 0x00, // 60 - 6F
        0x00, 0xF8, // 70 - 7F
        0xFF, 0xFF, // 80 - 8F
        0xFF, 0xFF, // 90 - 9F
        0xFF, 0xFF, // A0 - AF
        0xFF, 0xFF, // B0 - BF
        0xFF, 0xFF, // C0 - CF
        0xFF, 0xFF, // D0 - DF
        0xFF, 0xFF, // E0 - EF
        0xFF, 0xFF, // F0 - FF
    };
    static const WCHAR s_rgchHex[] = L"0123456789ABCDEF";

    WCHAR   ch;
    BOOL    bSuccess = FALSE;
    DWORD   nch = 0;
    LPCWSTR lpszURL = szToEscape;
    DWORD   dwCount = *pdwCount;

    // part one -- measure length
    while ((ch = *lpszURL++) != L'\0') {
        if ((ch & 0xFF00) != 0) { // a unicode char ?
            nch += 6;
        } else if(s_grfbitEscape[ch >> 3] & (1 << (ch & 7))) {
            nch += 3;
        } else {
            nch += 1;
        }
    }

    nch++; // one more for the final \0

    if (dwCount < nch) {
        DBGPRINT((sdlError,
                  "SdbEscapeApphelpURL",
                  "Not enough storage to escape URL \"%S\" need %ld got %ld\n",
                  szToEscape,
                  nch,
                  dwCount));
        *pdwCount = nch;
        return FALSE;
    }

    lpszURL = szToEscape;

    while ((ch = *lpszURL++) != L'\0') {

         if (ch == L' ') {
            *szResult++ = L'+';
         } else if ((ch & 0xFF00) != 0) { // a unicode char ?
            *szResult++ = L'%';
            *szResult++ = L'u';
            *szResult++ = s_rgchHex[(ch >> 12) & 0x0F];
            *szResult++ = s_rgchHex[(ch >>  8) & 0x0F];
            *szResult++ = s_rgchHex[(ch >>  4) & 0x0F];
            *szResult++ = s_rgchHex[ ch        & 0x0F];
        } else if(s_grfbitEscape[ch >> 3] & (1 << (ch & 7))) {
            *szResult++ = L'%';
            *szResult++ = s_rgchHex[(ch >>  4) & 0x0F];
            *szResult++ = s_rgchHex[ ch        & 0x0F];
        } else {
            *szResult++ = ch;
        }
    }

    *szResult = L'\0';
    *pdwCount = nch - 1; // do not include the term \0 into a char count

    return TRUE;

}



/////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Retrieving apphelp information
//
//
//



PDB
SDBAPI
SdbOpenApphelpDetailsDatabase(
    LPCWSTR pwszDetailsDatabasePath
    )
{

    PDB    pdbDetails = NULL;
    DWORD  dwLength;
    WCHAR  wszAppHelpSdb[MAX_PATH];

    if (pwszDetailsDatabasePath == NULL) {
        //
        // By default the details database is in %windir%\AppPatch\apphelp.sdb
        //

        dwLength = SdbpGetStandardDatabasePath(SDB_DATABASE_MAIN_DETAILS,
                                               0, // retrieve NT_PATH
                                               wszAppHelpSdb,
                                               CHARCOUNT(wszAppHelpSdb));
        if (dwLength != 0 && dwLength < CHARCOUNT(wszAppHelpSdb)) {
            pdbDetails = SdbOpenDatabase(wszAppHelpSdb, NT_PATH);
        }

    } else {
        pdbDetails = SdbOpenDatabase(pwszDetailsDatabasePath, DOS_PATH);
    }

    if (pdbDetails == NULL) {
        DBGPRINT((sdlError, "SdbOpenApphelpDetailsDatabase", "Failed to open the details database.\n"));
    }

    return pdbDetails;
}


PDB
SDBAPI
SdbOpenApphelpDetailsDatabaseSP(
    void
    )
{
    PDB    pdbDetails = NULL;
    DWORD  dwLength;
    WCHAR  wszAppHelpSdb[MAX_PATH];

    dwLength = SdbpGetStandardDatabasePath(SDB_DATABASE_MAIN_SP_DETAILS,
                                           0, // retrieve NT_PATH
                                           wszAppHelpSdb,
                                           CHARCOUNT(wszAppHelpSdb));

    if (dwLength != 0 && dwLength < CHARCOUNT(wszAppHelpSdb)) {
        pdbDetails = SdbOpenDatabase(wszAppHelpSdb, NT_PATH);
    }

    if (pdbDetails == NULL) {
        DBGPRINT((sdlError,
                  "SdbOpenApphelpDetailsDatabaseSP",
                  "Failed to open the SP details database.\n"));
    }

    return pdbDetails;
}

BOOL
SdbpReadApphelpBasicInfo(
    IN PDB pdb,
    IN TAGID tiEntry,
    OUT TAGID*  ptiApphelp,
    OUT LPDWORD lpdwHtmlHelpID,
    OUT LPDWORD lpdwProblemSeverity,
    OUT LPDWORD lpdwFlags
    )
{
    TAGID tiAppHelp    = TAGID_NULL;
    TAGID tiHtmlHelpID = TAGID_NULL;
    TAGID tiSeverity   = TAGID_NULL;
    TAGID tiFlags      = TAGID_NULL;
    DWORD dwHtmlHelpID = 0;
    DWORD dwSeverity   = 0;
    DWORD dwFlags      = 0;
    BOOL  bReturn = FALSE;

    if (tiEntry == TAGID_NULL) {
        goto out;
    }

    assert(ptiApphelp != NULL);

    tiAppHelp = SdbFindFirstTag(pdb, tiEntry, TAG_APPHELP);
    if (tiAppHelp == TAGID_NULL) {
        //
        // This is not an apphelp entry
        //
        DBGPRINT((sdlError, "SdbpReadApphelpBasicInfo",
                  "This is not an apphelp entry tiExe 0x%x.\n", tiEntry));
        goto out;
    }

    if (lpdwHtmlHelpID != NULL) {
        tiHtmlHelpID = SdbFindFirstTag(pdb, tiAppHelp, TAG_HTMLHELPID);
        if (tiHtmlHelpID != TAGID_NULL) {
            dwHtmlHelpID = SdbReadDWORDTag(pdb, tiHtmlHelpID, 0);
        }
        *lpdwHtmlHelpID = dwHtmlHelpID;
    }

    if (lpdwProblemSeverity != NULL) {
        tiSeverity = SdbFindFirstTag(pdb, tiAppHelp, TAG_PROBLEMSEVERITY);
        if (tiSeverity != TAGID_NULL) {
            dwSeverity = SdbReadDWORDTag(pdb, tiSeverity, 0);
        }
        *lpdwProblemSeverity = dwSeverity;
    }

    //
    // Read supplemental flags.
    //
    if (lpdwFlags != NULL) {
        tiFlags = SdbFindFirstTag(pdb, tiAppHelp, TAG_FLAGS);
        if (tiFlags != TAGID_NULL) {
            dwFlags = SdbReadDWORDTag(pdb, tiFlags, 0);
        }
        *lpdwFlags = dwFlags;
    }

    bReturn = TRUE;

out:

    // always set the tiApphelp

    *ptiApphelp = tiAppHelp;

    return bReturn;
}


HAPPHELPINFOCONTEXT
SDBAPI
SdbOpenApphelpInformationByID(
    IN HSDB   hSDB,
    IN TAGREF trEntry,
    IN DWORD  dwDatabaseType                // pass the type of db you are using
    )
{
    PAPPHELPINFOCONTEXT pApphelpInfoContext = NULL;
    DWORD dwSeverity   = 0;
    DWORD dwHtmlHelpID = 0;
    TAGID tiApphelpExe = TAGID_NULL;
    PDB   pdb = NULL;
    TAGID tiExe = TAGID_NULL;
    BOOL  bSuccess = FALSE;

    if (trEntry == TAGREF_NULL) {
        return NULL;
    }

    //
    // if we are here, it is apphelp for sure, so we create the context
    //
    pApphelpInfoContext = (PAPPHELPINFOCONTEXT)SdbAlloc(sizeof(APPHELPINFOCONTEXT));
    if (pApphelpInfoContext == NULL) {
        DBGPRINT((sdlError, "SdbOpenApphelpInformation",
                  "Error allocating memory for apphelp info context\n"));
        goto out;
    }

    pApphelpInfoContext->hSDB           = hSDB;
    pApphelpInfoContext->pdb            = pdb;
    pApphelpInfoContext->dwContextFlags |= AHC_HSDB_NOCLOSE; // external hsdb, do not touch it
    //
    // all we care for -- is whether it's "main" database or not
    //
    pApphelpInfoContext->dwDatabaseType = dwDatabaseType;

    // get the guid for this db
    if (!SdbTagRefToTagID(hSDB, trEntry, &pdb, &tiExe)) {
        DBGPRINT((sdlError, "SdbOpenApphelpInformationByID",
                   "Error converting tagref to tagref 0x%lx\n", trEntry));
        goto out;
    }

    pApphelpInfoContext->tiExe          = tiExe;

    if (!SdbGetDatabaseGUID(hSDB, pdb, &pApphelpInfoContext->guidDB)) {
        DBGPRINT((sdlError, "SdbOpenApphelpInformationByID",
                  "Error reading database guid for tagref 0x%lx\n", trEntry));
        goto out;
    }

    if (!SdbpReadApphelpBasicInfo(pdb,
                                  tiExe,
                                  &pApphelpInfoContext->tiApphelpExe,
                                  &pApphelpInfoContext->dwHtmlHelpID,
                                  &pApphelpInfoContext->dwSeverity,
                                  &pApphelpInfoContext->dwFlags)) {

        DBGPRINT((sdlError, "SdbOpenApphelpInformationByID",
                  "Error reading apphelp basic information, apphelp may not be present for 0x%lx\n", trEntry));
        goto out;
    }

    bSuccess = TRUE;

    //
out:
    if (!bSuccess) {

        if (pApphelpInfoContext != NULL) {
            SdbFree(pApphelpInfoContext);
            pApphelpInfoContext = NULL;
        }
    }

    return pApphelpInfoContext;

}


HAPPHELPINFOCONTEXT
SDBAPI
SdbOpenApphelpInformation(
    IN GUID* pguidDB,
    IN GUID* pguidID
    )
{

    WCHAR        szDatabasePath[MAX_PATH];
    DWORD        dwDatabaseType = 0;
    DWORD        dwLength;
    BOOL         bInstallPackage = TRUE;
    HSDB         hSDB = NULL;
    PDB          pdb = NULL;
    TAGID        tiMatch      = TAGID_NULL;
    TAGID        tiAppHelp    = TAGID_NULL;
    TAGID        tiHtmlHelpID = TAGID_NULL;
    TAGID        tiSeverity   = TAGID_NULL;
    TAGID        tiFlags      = TAGID_NULL;
    DWORD        dwHtmlHelpID = 0;
    DWORD        dwSeverity   = 0;
    DWORD        dwFlags      = 0;
    FIND_INFO    FindInfo;

    PAPPHELPINFOCONTEXT pApphelpInfoContext = NULL;
    BOOL         bSuccess = FALSE;

    //
    // resolve and open the database
    //

    hSDB = SdbInitDatabase(HID_NO_DATABASE, NULL);
    if (hSDB == NULL) {
        DBGPRINT((sdlError, "SdbOpenApphelpInformation",
                  "Failed to initialize database\n"));
        goto out;
    }

    //
    // First, we need to resolve a db
    //
    dwLength = SdbResolveDatabase(pguidDB,
                                  &dwDatabaseType,
                                  szDatabasePath,
                                  CHARCOUNT(szDatabasePath));
    if (dwLength == 0 || dwLength > CHARCOUNT(szDatabasePath)) {
        DBGPRINT((sdlError, "SdbOpenApphelpInformation",
                  "Failed to resolve database path\n"));
        goto out;
    }

    //
    // open database
    //

    if (!SdbOpenLocalDatabase(hSDB, szDatabasePath)) {
        DBGPRINT((sdlError, "SdbOpenApphelpInformation",
                  "Failed to open database \"%s\"\n", szDatabasePath));
        goto out;
    }
    //
    // we have database opened, I presume
    //
    pdb = ((PSDBCONTEXT)hSDB)->pdbLocal;

    //
    // we search only the LOCAL database in this case
    //

    tiMatch = SdbFindFirstGUIDIndexedTag(pdb,
                                         TAG_EXE,
                                         TAG_EXE_ID,
                                         pguidID,
                                         &FindInfo);
    // if we have a match...
    if (tiMatch == TAGID_NULL) {
        DBGPRINT((sdlWarning, "SdbOpenApphelpInformation", "guid was not found in the database\n"));
        goto out;
    }

    //
    // if we are here, it is apphelp for sure, so we create the context
    //
    pApphelpInfoContext = (PAPPHELPINFOCONTEXT)SdbAlloc(sizeof(APPHELPINFOCONTEXT));
    if (pApphelpInfoContext == NULL) {
        DBGPRINT((sdlError, "SdbOpenApphelpInformation",
                  "Error allocating memory for apphelp info context\n"));
        goto out;
    }

    pApphelpInfoContext->hSDB           = hSDB;
    pApphelpInfoContext->pdb            = pdb;
    pApphelpInfoContext->guidID         = *pguidID;
    pApphelpInfoContext->guidDB         = *pguidDB;
    pApphelpInfoContext->tiExe          = tiMatch;
    pApphelpInfoContext->dwDatabaseType = dwDatabaseType;

    if (!SdbpReadApphelpBasicInfo(pdb,
                                  tiMatch,
                                  &pApphelpInfoContext->tiApphelpExe,
                                  &pApphelpInfoContext->dwHtmlHelpID,
                                  &pApphelpInfoContext->dwSeverity,
                                  &pApphelpInfoContext->dwFlags)) {

        DBGPRINT((sdlError, "SdbOpenApphelpInformation",
                  "Error reading apphelp basic information, apphelp may not be present for tagid 0x%lx\n", tiMatch));
        goto out;
    }

    bSuccess = TRUE;

    //
    // we are done now
    //

out:
    if (!bSuccess) {

        if (hSDB != NULL) {
            SdbReleaseDatabase(hSDB);
        }

        if (pApphelpInfoContext != NULL) {
            SdbFree(pApphelpInfoContext);
            pApphelpInfoContext = NULL;
        }

    }


    return (HAPPHELPINFOCONTEXT)pApphelpInfoContext;
}

BOOL
SDBAPI
SdbCloseApphelpInformation(
    HAPPHELPINFOCONTEXT hctx
    )
{
    PAPPHELPINFOCONTEXT pApphelpInfoContext = (PAPPHELPINFOCONTEXT)hctx;

    if (pApphelpInfoContext != NULL) {
        if (pApphelpInfoContext->hSDB != NULL &&
            !(pApphelpInfoContext->dwContextFlags & AHC_HSDB_NOCLOSE)) {
            SdbReleaseDatabase(pApphelpInfoContext->hSDB);
        }
        if (pApphelpInfoContext->pdbDetails != NULL &&
            !(pApphelpInfoContext->dwContextFlags & AHC_DBDETAILS_NOCLOSE)) {
            SdbCloseDatabaseRead(pApphelpInfoContext->pdbDetails);
        }
        if (pApphelpInfoContext->pwszHelpCtrURL != NULL) {
            SdbFree(pApphelpInfoContext->pwszHelpCtrURL);
        }

        RtlFreeUnicodeString(&pApphelpInfoContext->ustrChmFile);
        RtlFreeUnicodeString(&pApphelpInfoContext->ustrDetailsDatabase);

        SdbFree(pApphelpInfoContext);
    }

    return TRUE;
}

DWORD
SDBAPI
SdbpReadApphelpString(
    PDB pdb,
    TAGID tiParent,
    TAG   tItem,
    LPCWSTR* ppwszCache,
    LPVOID*  ppResult
    )
{
    DWORD cbResult = 0;
    TAGID tiItem;
    LPCWSTR pwszItem = NULL;

    if (*ppwszCache != NULL) {
        pwszItem = *ppwszCache;
    } else {

        tiItem = SdbFindFirstTag(pdb, tiParent, tItem);
        if (tiItem != TAGID_NULL) {
            pwszItem = SdbGetStringTagPtr(pdb, tiItem);
            if (pwszItem != NULL) {
                *ppwszCache = pwszItem;
            }
        }
    }

    cbResult = SIZE_WSTRING(pwszItem);
    *ppResult = (LPVOID)pwszItem;

    return cbResult;
}

BOOL
SDBAPI
SdbpReadApphelpLinkInformation(
    PAPPHELPINFOCONTEXT pApphelpInfoContext
    )
{
    TAGID tiLink;
    TAGID tiApphelp = pApphelpInfoContext->tiApphelpDetails;
    PDB   pdb       = pApphelpInfoContext->pdbDetails;
    TAGID tiURL;
    TAGID tiLinkText;

    if (pApphelpInfoContext->tiLink != TAGID_NULL) {
        return TRUE;
    }

    //
    // Now find the link. We support multiple links but use only one for now.
    //

    tiLink = SdbFindFirstTag(pdb, tiApphelp, TAG_LINK);
    if (tiLink == TAGID_NULL) {
        return FALSE;
    }

    tiURL = SdbFindFirstTag(pdb, tiLink, TAG_LINK_URL);
    if (tiURL) {
        pApphelpInfoContext->pwszLinkURL = SdbGetStringTagPtr(pdb, tiURL);
    }

    tiLinkText = SdbFindFirstTag(pdb, tiLink, TAG_LINK_TEXT);
    if (tiLinkText) {
        pApphelpInfoContext->pwszLinkText = SdbGetStringTagPtr(pdb, tiLinkText);
    }

    pApphelpInfoContext->tiLink = tiLink;
    return TRUE;
}

BOOL
SDBAPI
SdbpCreateHelpCenterURL(
    IN HAPPHELPINFOCONTEXT hctx,
    IN BOOL bOfflineContent OPTIONAL, // pass FALSE
    IN BOOL bUseHtmlHelp    OPTIONAL, // pass FALSE
    IN LPCWSTR pwszChmFile  OPTIONAL  // pass NULL
    );

BOOL
SDBAPI
SdbSetApphelpDebugParameters(
    IN HAPPHELPINFOCONTEXT hctx,
    IN LPCWSTR pszDetailsDatabase OPTIONAL,
    IN BOOL    bOfflineContent OPTIONAL, // pass FALSE
    IN BOOL    bUseHtmlHelp    OPTIONAL, // pass FALSE
    IN LPCWSTR pszChmFile      OPTIONAL  // pass NULL
    )
{
    PAPPHELPINFOCONTEXT pApphelpInfoContext = (PAPPHELPINFOCONTEXT)hctx;

    if (pApphelpInfoContext == NULL) {
        return FALSE;
    }

    if (bUseHtmlHelp && !bOfflineContent) {
        DBGPRINT((sdlError, "SdbSetApphelpDebugParameters",
                   "Inconsistent parameters: when using html help -- offline content flag should also be set\n"));
        bOfflineContent = TRUE;
    }

    RtlFreeUnicodeString(&pApphelpInfoContext->ustrDetailsDatabase);
    RtlFreeUnicodeString(&pApphelpInfoContext->ustrChmFile);

    pApphelpInfoContext->bOfflineContent = bOfflineContent;
    pApphelpInfoContext->bUseHtmlHelp    = bUseHtmlHelp;

    if (pszDetailsDatabase != NULL) {
        if (!RtlCreateUnicodeString(&pApphelpInfoContext->ustrDetailsDatabase, pszDetailsDatabase)) {
            DBGPRINT((sdlError, "SdbSetApphelpDebugParameters",
                      "Failed to create unicode string from \"%S\"\n", pszDetailsDatabase));
            return FALSE;
        }
    }

    if (pszChmFile != NULL) {
        if (!RtlCreateUnicodeString(&pApphelpInfoContext->ustrChmFile, pszChmFile)) {
            DBGPRINT((sdlError, "SdbSetApphelpDebugParameters",
                      "Failed to create unicode string from \"%S\"\n", pszChmFile));
            return FALSE;
        }
    }

    return TRUE;
}


DWORD
SDBAPI
SdbQueryApphelpInformation(
    HAPPHELPINFOCONTEXT hctx,
    APPHELPINFORMATIONCLASS InfoClass,
    LPVOID pBuffer,                     // may be NULL
    DWORD  cbSize                       // may be 0 if pBuffer is NULL
    )
{
    PAPPHELPINFOCONTEXT pApphelpInfoContext = (PAPPHELPINFOCONTEXT)hctx;

    LPCWSTR *ppwsz;
    TAG    tag;
    TAGID  tiParent;
    LPVOID pResult = NULL;
    DWORD  cbResult = 0;
    PDB    pdb = NULL;
    PDB    pdbDetails = NULL;
    TAGID  tiApphelpDetails = TAGID_NULL;
    FIND_INFO FindInfo;


    switch(InfoClass) {
    case ApphelpLinkURL:
    case ApphelpLinkText:
    case ApphelpTitle:
    case ApphelpDetails:
    case ApphelpContact:

        pdbDetails = pApphelpInfoContext->pdbDetails;
        if (pApphelpInfoContext->pdbDetails == NULL) {
            //
            // see which db we should open
            //
            if ((pApphelpInfoContext->ustrDetailsDatabase.Buffer != NULL) ||
                (pApphelpInfoContext->dwDatabaseType & SDB_DATABASE_MAIN)) {
                pdbDetails = SdbOpenApphelpDetailsDatabase(pApphelpInfoContext->ustrDetailsDatabase.Buffer);
            } else {
                // we have a case when the apphelp details should be in main db
                pApphelpInfoContext->dwContextFlags |= AHC_DBDETAILS_NOCLOSE;
                pdbDetails = pApphelpInfoContext->pdb;
            }

            if (pdbDetails == NULL) {
                return cbResult; // apphelp db is not available
            }

            pApphelpInfoContext->pdbDetails = pdbDetails;
        }

        tiApphelpDetails = pApphelpInfoContext->tiApphelpDetails;
        if (tiApphelpDetails == TAGID_NULL) {
            if (!SdbIsIndexAvailable(pdbDetails, TAG_APPHELP, TAG_HTMLHELPID)) {
                DBGPRINT((sdlError,
                          "SdbQueryApphelpInformation",
                          "HTMLHELPID index in details database is not available.\n"));
                return cbResult;
            }

            tiApphelpDetails = SdbFindFirstDWORDIndexedTag(pdbDetails,
                                                           TAG_APPHELP,
                                                           TAG_HTMLHELPID,
                                                           pApphelpInfoContext->dwHtmlHelpID,
                                                           &FindInfo);

            if (tiApphelpDetails == TAGID_NULL) {
                DBGPRINT((sdlError,
                          "SdbQueryApphelpInformation",
                          "Failed to find HTMLHELPID 0x%x in the details database.\n",
                          pApphelpInfoContext->dwHtmlHelpID));
                return cbResult;
            }

            pApphelpInfoContext->tiApphelpDetails = tiApphelpDetails;
        }
        break;

    default:
        break;
    }


    switch(InfoClass) {
    case ApphelpExeTagID:
        pResult  = &pApphelpInfoContext->tiExe;
        cbResult = sizeof(pApphelpInfoContext->tiExe);
        break;

    case ApphelpExeName:
        pdb      = pApphelpInfoContext->pdb;  // main db
        tiParent = pApphelpInfoContext->tiExe;
        ppwsz    = &pApphelpInfoContext->pwszExeName;
        tag      = TAG_NAME;
        cbResult = SdbpReadApphelpString(pdb, tiParent, tag, ppwsz, &pResult);
        break;

    case ApphelpAppName:
        pdb      = pApphelpInfoContext->pdb;  // main db
        tiParent = pApphelpInfoContext->tiExe;
        ppwsz    = &pApphelpInfoContext->pwszAppName;
        tag      = TAG_APP_NAME;
        cbResult = SdbpReadApphelpString(pdb, tiParent, tag, ppwsz, &pResult);
        break;

    case ApphelpVendorName:
        pdb      = pApphelpInfoContext->pdb;  // main db
        tiParent = pApphelpInfoContext->tiExe;
        ppwsz    = &pApphelpInfoContext->pwszVendorName;
        tag      = TAG_VENDOR;
        cbResult = SdbpReadApphelpString(pdb, tiParent, tag, ppwsz, &pResult);
        break;

    case ApphelpHtmlHelpID:
        pResult = &pApphelpInfoContext->dwHtmlHelpID;
        cbResult = sizeof(pApphelpInfoContext->dwHtmlHelpID);
        break;

    case ApphelpProblemSeverity:
        pResult  = &pApphelpInfoContext->dwSeverity;
        cbResult = sizeof(pApphelpInfoContext->dwSeverity);
        break;

    case ApphelpFlags:
        pResult  = &pApphelpInfoContext->dwFlags;
        cbResult = sizeof(pApphelpInfoContext->dwFlags);
        break;

    case ApphelpLinkURL:
        if (!SdbpReadApphelpLinkInformation(pApphelpInfoContext)) {
            break;
        }
        pResult = (LPWSTR)pApphelpInfoContext->pwszLinkURL;
        cbResult = SIZE_WSTRING(pResult);
        break;

    case ApphelpLinkText:
        if (!SdbpReadApphelpLinkInformation(pApphelpInfoContext)) {
            break;
        }
        pResult = (LPWSTR)pApphelpInfoContext->pwszLinkText;
        cbResult = SIZE_WSTRING(pResult);
        break;

    case ApphelpTitle:
        pdb      = pdbDetails;
        tiParent = tiApphelpDetails;
        ppwsz    = &pApphelpInfoContext->pwszTitle;
        tag      = TAG_APPHELP_TITLE;
        cbResult = SdbpReadApphelpString(pdb, tiParent, tag, ppwsz, &pResult);
        break;


    case ApphelpDetails:
        pdb      = pdbDetails;
        tiParent = tiApphelpDetails;
        ppwsz    = &pApphelpInfoContext->pwszDetails;
        tag      = TAG_APPHELP_DETAILS;
        cbResult = SdbpReadApphelpString(pdb, tiParent, tag, ppwsz, &pResult);
        break;

    case ApphelpContact:
        pdb      = pdbDetails;
        tiParent = tiApphelpDetails;
        ppwsz    = &pApphelpInfoContext->pwszContact;
        tag      = TAG_APPHELP_CONTACT;
        cbResult = SdbpReadApphelpString(pdb, tiParent, tag, ppwsz, &pResult);
        break;

    case ApphelpHelpCenterURL:
        if (!SdbpCreateHelpCenterURL(hctx,
                                     pApphelpInfoContext->bOfflineContent,
                                     pApphelpInfoContext->bUseHtmlHelp,
                                     pApphelpInfoContext->ustrChmFile.Buffer)) {
             break;
        }
        pResult  = pApphelpInfoContext->pwszHelpCtrURL;
        cbResult = SIZE_WSTRING(pResult);
        break;

    case ApphelpDatabaseGUID:
        pResult = &pApphelpInfoContext->guidDB;
        cbResult = sizeof(pApphelpInfoContext->guidDB);
        break;

    default:
        DBGPRINT((sdlError, "SdbQueryApphelpInformation",
                  "Bad Apphelp Information class 0x%lx\n", InfoClass));
        return 0;
        break;
    }


    if (pBuffer == NULL || cbResult > cbSize) {
        return cbResult;
    }

    if (pResult != NULL && cbResult > 0) {
        RtlCopyMemory(pBuffer, pResult, cbResult);
    }

    return cbResult;

}

typedef HRESULT (STDAPICALLTYPE *PFNUrlUnescapeW)(
    LPWSTR pszUrl,
    LPWSTR pszUnescaped,
    LPDWORD pcchUnescaped,
    DWORD dwFlags);

typedef HRESULT (STDAPICALLTYPE *PFNUrlEscapeW)(
    LPCWSTR pszURL,
    LPWSTR pszEscaped,
    LPDWORD pcchEscaped,
    DWORD dwFlags
);

//
// if bUseHtmlHelp is set -- then bOfflineContent is also set to TRUE
//

BOOL
SDBAPI
SdbpCreateHelpCenterURL(
    IN HAPPHELPINFOCONTEXT hctx,
    IN BOOL bOfflineContent OPTIONAL, // pass FALSE
    IN BOOL bUseHtmlHelp    OPTIONAL, // pass FALSE
    IN LPCWSTR pwszChmFile  OPTIONAL  // pass NULL
    )
{
    WCHAR szAppHelpURL[2048];
    WCHAR szChmURL[1024];
    PAPPHELPINFOCONTEXT pApphelpInfo = (PAPPHELPINFOCONTEXT)hctx;
    HMODULE hModShlwapi = NULL;
    PFNUrlUnescapeW pfnUnescape;
    PFNUrlEscapeW   pfnEscape;
    BOOL bSuccess = FALSE;

    int nChURL = 0; // counts used bytes
    int cch    = 0;
    int nch;
    LPWSTR  lpwszUnescaped = NULL;
    HRESULT hr;
    DWORD   nChars;
    WCHAR   szWindowsDir[MAX_PATH];
    BOOL    bCustom;

    if (pApphelpInfo->pwszHelpCtrURL != NULL) {
        return TRUE;
    }

    if (bUseHtmlHelp) {
        bOfflineContent = TRUE;
    }

    // ping the database
    if (0 == SdbQueryApphelpInformation(hctx, ApphelpLinkURL, NULL, 0)) {
       return FALSE;
    }

    //
    // check and see whether it's custom apphelp or not
    //
    bCustom = !(pApphelpInfo->dwDatabaseType & SDB_DATABASE_MAIN);

    if (bCustom) {
        if (pApphelpInfo->pwszLinkURL != NULL) {
            nChURL = _snwprintf(szAppHelpURL, CHARCOUNT(szAppHelpURL),
                                L"%ls", pApphelpInfo->pwszLinkURL);
            if (nChURL < 0) {
                DBGPRINT((sdlError, "SdbpCreateHelpCenterURL",
                          "Custom apphelp URL %s is too long\n", pApphelpInfo->pwszLinkURL));
                goto out;
            }

            // now we are done
            goto createApphelpURL;

        } else {
            // custom apphelp will not fly without a link
            DBGPRINT((sdlError, "SdbpCreateHelpCenterURL", "Custom apphelp without a url link\n"));
            goto out;
        }
    }


    // unescape the URL
    hModShlwapi = LoadLibraryW(L"shlwapi.dll");
    if (hModShlwapi == NULL) {
        return FALSE;
    }

    pfnUnescape = (PFNUrlUnescapeW)GetProcAddress(hModShlwapi, "UrlUnescapeW");
    pfnEscape   = (PFNUrlEscapeW)  GetProcAddress(hModShlwapi, "UrlEscapeW");
    if (pfnUnescape == NULL || pfnEscape == NULL) {
        DBGPRINT((sdlError, "SdbpCreateHelpCenterURL", "Cannot get shlwapi functions\n"));
        goto out;
    }


    if (!bUseHtmlHelp) {

        nChURL = _snwprintf(szAppHelpURL,
                            CHARCOUNT(szAppHelpURL),
                            L"hcp://services/redirect?online=");
    }

    if (!bOfflineContent && pApphelpInfo->pwszLinkURL != NULL) {


        // unescape the url first using shell
        cch = wcslen(pApphelpInfo->pwszLinkURL) + 1;

        STACK_ALLOC(lpwszUnescaped, cch * sizeof(WCHAR));
        if (lpwszUnescaped == NULL) {
            DBGPRINT((sdlError, "SdbpCreateHelpCenterURL",
                      "Error trying to allocate memory for \"%S\"\n", pApphelpInfo->pwszLinkURL));
            goto out;
        }

        //
        // Unescape round 1 - use the shell function (same as used to encode it for xml/database)
        //

        hr = pfnUnescape((LPTSTR)pApphelpInfo->pwszLinkURL, lpwszUnescaped, &cch, 0);
        if (!SUCCEEDED(hr)) {
            DBGPRINT((sdlError, "SdbCreateHelpCenterURL", "UrlUnescapeW failed on \"%S\"\n", pApphelpInfo->pwszLinkURL));
            goto out;
        }

        //
        // round 2 - use our function borrowed from help center
        //

        cch = (DWORD)(CHARCOUNT(szAppHelpURL) - nChURL);
        if (!SdbEscapeApphelpURL(szAppHelpURL + nChURL, &cch, lpwszUnescaped)) {
            DBGPRINT((sdlError,  "SdbCreateHelpCenterURL", "Error escaping URL \"%S\"\n", lpwszUnescaped));
            goto out;
        }

        nChURL += (int)cch;

    }


    //
    // Retrieve the Windows directory.
    //
    nChars = GetWindowsDirectoryW(szWindowsDir, CHARCOUNT(szWindowsDir));
    if (!nChars || nChars > CHARCOUNT(szWindowsDir)) {
        DBGPRINT((sdlError, "SdbCreateHelpCenterURL",
                  "Error trying to retrieve Windows Directory %d.\n", GetLastError()));
        goto out;
    }

    if (pwszChmFile != NULL) {
        _snwprintf(szChmURL,
                   CHARCOUNT(szChmURL),
                   L"mk:@msitstore:%ls::/idh_w2_%d.htm",
                   pwszChmFile,
                   pApphelpInfo->dwHtmlHelpID);
    } else { // standard chm file

        //
        // Attention: if we use hDlg here then, upon exit we will need to clean
        // up the window.
        //
        _snwprintf(szChmURL,
                   CHARCOUNT(szChmURL),
                   L"mk:@msitstore:%ls\\help\\apps.chm::/idh_w2_%d.htm",
                   szWindowsDir,
                   pApphelpInfo->dwHtmlHelpID);

    }

    if (bOfflineContent) {


        if (bUseHtmlHelp) {
            cch = CHARCOUNT(szAppHelpURL);
            hr = pfnEscape(szChmURL, szAppHelpURL, &cch, 0);
            if (SUCCEEDED(hr)) {
                nChURL += (INT)cch;
            }

        } else { // do not use html help

            cch = (DWORD)(CHARCOUNT(szAppHelpURL) - nChURL);
            if (!SdbEscapeApphelpURL(szAppHelpURL+nChURL, &cch, szChmURL)) {
                DBGPRINT((sdlError,  "SdbCreateHelpCenterURL", "Error escaping URL \"%S\"\n", szChmURL));
                goto out;
            }
            nChURL += (INT)cch;
        }
    }


    if (!bUseHtmlHelp) {

        //
        // now offline sequence
        //
        cch = (DWORD)(CHARCOUNT(szAppHelpURL) - nChURL);
        nch = _snwprintf(szAppHelpURL + nChURL, cch, L"&offline=");
        if (nch < 0) {
            goto out;
        }
        nChURL += nch;

        cch = (DWORD)(CHARCOUNT(szAppHelpURL) - nChURL);

        if (!SdbEscapeApphelpURL(szAppHelpURL+nChURL, &cch, szChmURL)) {
            DBGPRINT((sdlError,  "SdbCreateHelpCenterURL", "Error escaping URL \"%S\"\n", szChmURL));
            goto out;
        }

        nChURL += (int)cch;
    }

    *(szAppHelpURL + nChURL) = L'\0';

    // we are done
    // copy data now

createApphelpURL:

    pApphelpInfo->pwszHelpCtrURL = (LPWSTR)SdbAlloc(nChURL * sizeof(WCHAR) + sizeof(UNICODE_NULL));
    if (pApphelpInfo->pwszHelpCtrURL == NULL) {
        DBGPRINT((sdlError, "SdbCreateHelpCenterURL", "Error allocating memory for the URL 0x%lx chars\n", nChURL));
        goto out;
    }

    wcscpy(pApphelpInfo->pwszHelpCtrURL, szAppHelpURL);
    bSuccess = TRUE;

out:

    if (lpwszUnescaped != NULL) {
        STACK_FREE(lpwszUnescaped);
    }

    if (hModShlwapi) {
        FreeLibrary(hModShlwapi);
    }

    return bSuccess;
}


//
// returns TRUE if dialog was shown
//  if there was an error, input parameter (pRunApp) will NOT
//  be touched


BOOL
SdbShowApphelpDialog(               // returns TRUE if success, whether we should run the app is in pRunApp
    IN  PAPPHELP_INFO   pAHInfo,    // the info necessary to find the apphelp data
    IN  PHANDLE         phProcess,  // [optional] returns the process handle of
                                    // the process displaying the apphelp.
                                    // When the process completes, the return value
                                    // (from GetExitCodeProcess()) will be zero
                                    // if the app should not run, or non-zero
                                    // if it should run.
    IN OUT BOOL*        pRunApp
    )
{
    //
    // basically just launch the apphelp.exe and wait for it to return
    //
    TCHAR               szGuid[64];
    TCHAR               szCommandLine[MAX_PATH * 2 + 64];
    LPTSTR              pszCmdLine = szCommandLine;
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    DWORD       dwExit  = 1; // by default and in case of failure, we allow to run the app
    BOOL        bReturn = FALSE;
    BOOL        bRunApp = TRUE; // by default we run the app ?

    int nch; // chars in the buffer

    nch = _stprintf(pszCmdLine, TEXT("ahui.exe"));
    pszCmdLine += nch;


    if (pAHInfo->tiExe != TAGID_NULL) {

        // figure out what the default return value should be
        if (!SdbGUIDToString(&pAHInfo->guidDB, szGuid)) {
            DBGPRINT((sdlError, "SdbShowApphelpDialog",
                      "Failed to convert guid to string.\n"));
            goto cleanup;
        }

        nch = _stprintf(pszCmdLine, L" %s 0x%lX", szGuid, pAHInfo->tiExe);
        pszCmdLine += nch;

    } else {
        if (!pAHInfo->dwHtmlHelpID) {
            DBGPRINT((sdlError, "SdbShowApphelpDialog",
                      "Neither HTMLHELPID nor tiExe provided\n"));
            goto cleanup;
        }

        nch = _stprintf(pszCmdLine, TEXT(" /HTMLHELPID:0x%lx"), pAHInfo->dwHtmlHelpID);
        pszCmdLine += nch;

        nch = _stprintf(pszCmdLine, TEXT(" /SEVERITY:0x%lx"), pAHInfo->dwSeverity);
        pszCmdLine += nch;

        if (!SdbIsNullGUID(&pAHInfo->guidID)) {
            if (SdbGUIDToString(&pAHInfo->guidID, szGuid)) {
                nch = _stprintf(pszCmdLine, TEXT(" /GUID:%s"), szGuid);
                pszCmdLine += nch;
            }
        }

        if (pAHInfo->lpszAppName != NULL) {
            nch = _stprintf(pszCmdLine, TEXT(" /APPNAME:\"%s\""), pAHInfo->lpszAppName);
            pszCmdLine += nch;
        }

    }

    if (pAHInfo->bPreserveChoice) {
        nch = _stprintf(pszCmdLine, TEXT(" /PRESERVECHOICE"));
        pszCmdLine += nch;
    }

/*++

    if (bOfflineContent) {
        _tcscat(szCommand, TEXT(" /USELOCALCHM"));
    }
    if (bUseHTMLHelp) {
        _tcscat(szCommand, TEXT(" /USEHTMLHELP"));
    }
    if (lpszChmFile) {
        _tcscat(szCommand, TEXT(" /HTMLHELP:"));
        _tcscat(szCommand, lpszChmFile);
    }
    if (lpszDetailsFile) {
        _tcscat(szCommand, TEXT(" /DETAILS:"));
        _tcscat(szCommand, lpszDetailsFile);
    }

--*/

    RtlZeroMemory(&StartupInfo, sizeof(StartupInfo));
    RtlZeroMemory(&ProcessInfo, sizeof(ProcessInfo));
    StartupInfo.cb = sizeof(StartupInfo);

    if (!CreateProcessW(NULL,
                        szCommandLine,
                        NULL,
                        NULL,
                        FALSE,
                        0,
                        NULL,
                        NULL,
                        &StartupInfo, &ProcessInfo)) {
        DBGPRINT((sdlError, "SdbShowApphelpDialog",
                  "Failed to launch apphelp process.\n"));
        goto cleanup;
    }

    //
    // check to see if they want to monitor the process themselves
    //
    if (phProcess) {
        bReturn = TRUE;
        pRunApp = NULL;  // we do this so that we don't touch the bRunApp
        *phProcess = ProcessInfo.hProcess;
        goto cleanup;
    }

    //
    // otherwise, we'll do the waiting.
    //

    WaitForSingleObject(ProcessInfo.hProcess, INFINITE);

    bReturn = GetExitCodeProcess(ProcessInfo.hProcess, &dwExit);
    if (bReturn) {
        bRunApp = (0 != dwExit);
    }

cleanup:
    if (bReturn && pRunApp != NULL) {
        *pRunApp = bRunApp;
    }

    //
    // process handle is to be closed only when phProcess is NULL
    //

    if (phProcess == NULL && ProcessInfo.hProcess) {
        CloseHandle(ProcessInfo.hProcess);
    }
    if (ProcessInfo.hThread) {
        CloseHandle(ProcessInfo.hThread);
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\fileio.h ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    fileio.h
//
// History: 06-Apr-01   markder     Created.
//
// Desc:    This file contains classes to encapsulate MBCS and UNICODE files.
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef __FILEIO_H__
#define __FILEIO_H__

class CTextFile : public CFile
{
public:
    CTextFile( LPCTSTR lpszFileName, UINT nOpenFlags );

    virtual void WriteString(LPCTSTR lpsz) = 0;
};

class CANSITextFile : public CTextFile
{
private:
    UINT m_dwCodePage;

public:
    CANSITextFile(LPCTSTR lpszFileName, UINT dwCodePage, UINT nOpenFlags);

    virtual void WriteString(LPCTSTR lpsz);
};

class CUTF8TextFile : public CTextFile
{
public:
    CUTF8TextFile(LPCTSTR lpszFileName, UINT nOpenFlags);

    virtual void WriteString(LPCTSTR lpsz);
};

class CUTF16TextFile : public CTextFile
{
public:
    CUTF16TextFile(LPCTSTR lpszFileName, UINT nOpenFlags);

    virtual void WriteString(LPCTSTR lpsz);
};

#endif  // __FILEIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\fileio.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    fileio.cpp
//
// History: 06-Apr-01   markder     Created.
//
// Desc:    This file contains classes to encapsulate MBCS and UNICODE files.
//
////////////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "FileIO.h"

CTextFile::CTextFile( LPCTSTR lpszFileName, UINT nOpenFlags ) :
    CFile(lpszFileName, nOpenFlags)
{
}


CANSITextFile::CANSITextFile(LPCTSTR lpszFileName, UINT dwCodePage, UINT nOpenFlags) :
    CTextFile(lpszFileName, (nOpenFlags & (~CFile::typeText)) | CFile::typeBinary)
{
    m_dwCodePage = dwCodePage;
}

CUTF8TextFile::CUTF8TextFile(LPCTSTR lpszFileName, UINT nOpenFlags) :
    CTextFile(lpszFileName, (nOpenFlags & (~CFile::typeText)) | CFile::typeBinary)
{
    UCHAR    EncodingMarker[3];

    EncodingMarker[0] = (UCHAR) 0xEF;
    EncodingMarker[1] = (UCHAR) 0xBB;
    EncodingMarker[2] = (UCHAR) 0xBF;

    Write(&EncodingMarker, 3);
}

CUTF16TextFile::CUTF16TextFile(LPCTSTR lpszFileName, UINT nOpenFlags) :
    CTextFile(lpszFileName, (nOpenFlags & (~CFile::typeText)) | CFile::typeBinary)
{
    UCHAR    EncodingMarker[2];

    EncodingMarker[0] = (UCHAR) 0xFF;
    EncodingMarker[1] = (UCHAR) 0xFE;

    Write(&EncodingMarker, 2);
}

void CANSITextFile::WriteString(LPCTSTR lpsz)
{
    LPVOID  lpBuf = NULL;
    LPVOID  lpAllocatedBuffer = NULL;
    LONG    nBufSize = 0;
    LONG    nBytesToWrite = 0;
    CString csStringToWrite(lpsz);

    csStringToWrite.Replace(_T("\012"), _T("\015\012"));

#ifdef UNICODE
    nBufSize = WideCharToMultiByte(
      m_dwCodePage,
      0,
      csStringToWrite,
      -1,
      NULL,
      0,
      NULL,
      NULL
    );
        
    lpAllocatedBuffer = malloc(nBufSize);
    if (lpAllocatedBuffer == NULL) {
        AfxThrowMemoryException();
    }

    lpBuf = lpAllocatedBuffer;

    nBytesToWrite = WideCharToMultiByte(
      m_dwCodePage,
      0,
      csStringToWrite,
      -1,
      (LPSTR) lpBuf,
      nBufSize,
      NULL,
      NULL
    );

    //
    // Take off NULL terminator
    //
    nBytesToWrite--;

#else
    lpBuf = (LPVOID) (LPCSTR) csStringToWrite;
    nBytesToWrite = strlen(csStringToWrite); // we use strlen to get total bytes

#endif

    if (nBytesToWrite == 0) {
        goto eh;
    }

    Write(lpBuf, nBytesToWrite);

eh:
    if (lpAllocatedBuffer) {
        free(lpAllocatedBuffer);
    }
}

void CUTF8TextFile::WriteString(LPCTSTR lpsz)
{
    LPVOID  lpBuf = NULL;
    LPVOID  lpAllocatedBuffer = NULL;
    LONG    nBufSize = 0;
    LONG    nBytesToWrite = 0;
    CString csStringToWrite(lpsz);

    csStringToWrite.Replace(_T("\012"), _T("\015\012"));

#ifdef UNICODE
    nBufSize = WideCharToMultiByte(
      CP_UTF8,
      0,
      csStringToWrite,
      -1,
      NULL,
      0,
      NULL,
      NULL
    );
        
    lpAllocatedBuffer = malloc(nBufSize);
    if (lpAllocatedBuffer == NULL) {
        AfxThrowMemoryException();
    }

    lpBuf = lpAllocatedBuffer;

    nBytesToWrite = WideCharToMultiByte(
      CP_UTF8,
      0,
      csStringToWrite,
      -1,
      (LPSTR) lpBuf,
      nBufSize,
      NULL,
      NULL
    );

    //
    // Take off NULL terminator
    //
    nBytesToWrite--;

#else
    lpBuf = (LPVOID) (LPCSTR) csStringToWrite;
    nBytesToWrite = strlen(csStringToWrite); // we use strlen to get total bytes

#endif

    if (nBytesToWrite == 0) {
        goto eh;
    }

    Write(lpBuf, nBytesToWrite);

eh:
    if (lpAllocatedBuffer) {
        free(lpAllocatedBuffer);
    }
}

void CUTF16TextFile::WriteString(LPCTSTR lpsz)
{
    LPVOID  lpBuf = NULL;
    LPVOID  lpAllocatedBuffer = NULL;
    LONG    nBufSize = 0;
    LONG    nBytesToWrite = 0;
    CString csStringToWrite(lpsz);

    csStringToWrite.Replace(_T("\012"), _T("\015\012"));

#ifdef UNICODE
    lpBuf = (LPVOID) (LPCWSTR) csStringToWrite;
    nBytesToWrite = csStringToWrite.GetLength() * sizeof(WCHAR);

#else
    nBufSize = MultiByteToWideChar(
        CP_ACP, 
        0, 
        csStringToWrite, 
        -1, 
        NULL, 
        0);
        
    lpAllocatedBuffer = malloc(nBufSize);
    if (lpAllocatedBuffer == NULL) {
        AfxThrowMemoryException();
    }

    lpBuf = lpAllocatedBuffer;

    nBytesToWrite = MultiByteToWideChar(
        CP_ACP, 
        0, 
        csStringToWrite, 
        -1, 
        lpBuf, 
        nBufSize);

    //
    // Take off NULL terminator
    //
    nBytesToWrite -= sizeof(WCHAR);

#endif

    if (nBytesToWrite == 0) {
        goto eh;
    }

    Write(lpBuf, nBytesToWrite);

eh:
    if (lpAllocatedBuffer) {
        free(lpAllocatedBuffer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\chm.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    chm.cpp
//
// History: 21-Mar-00   vadimb     Created.
//
// Desc:    This file contains all code needed to produce chm project files
//
////////////////////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "obj.h"
#include "make.h"
#include "globals.h"
#include "chm.h"
#include "FileIO.h"

TCHAR gszTagXMLBR[]        = _T("<br/>");
TCHAR gszTagBR[]           = _T("<br>");

TCHAR gszTagXMLP[]         = _T("<p/>");
TCHAR gszTagP[]            = _T("<p>");

TCHAR gszHFileName[]       = _T("apperr.h");

BOOL ChmMakeFilePath(
   CString& csPath,
   LPCTSTR lpszPath,
   LPCTSTR lpszFileName,
   LPCTSTR lpszExt = NULL)
{
   csPath.Empty();

   if (NULL != lpszPath) {

      csPath = lpszPath;
      if (csPath.GetLength() >= 1 && csPath.Right(1) != _T("\\")) {
         csPath += _T('\\');
      }
   }
   csPath += lpszFileName;
   if (NULL != lpszExt) {
      csPath += lpszExt;
   }

   return(csPath.GetLength() > 0);
}    

CString ChmConstructArticleName(
    SdbOutputFile*  pOutputFile,
    SdbAppHelp*     pAppHelp,
    CString&        csLangID)
{
    CString csArticleName, csLCID;

    csArticleName = pOutputFile->GetParameter(_T("ARTICLE NAME TEMPLATE"));
    if (!csArticleName.GetLength()) {
        csArticleName = _T("idh_w2_$HTMLHELPID$");
    }

    ReplaceStringNoCase(csArticleName, _T("$HTMLHELPID$"), pAppHelp->m_csName);
    ReplaceStringNoCase(csArticleName, _T("$LANGID$"), csLangID);
    csLCID.Format(_T("%X"), pAppHelp->m_pDB->m_pCurrentMakefile->GetLangMap(csLangID)->m_lcid);
    ReplaceStringNoCase(csArticleName, _T("$LCID$"), csLCID);

    return csArticleName;
}

BOOL ChmCreatePage(
    SdbDatabase*   pDB,
    SdbOutputFile* pOutputFile,
    SdbAppHelp*    pAppHelp,
    SdbMessage*    pMessage,
    CString&       csTemplate,
    CString&       csLangID
    )
{
    CString csHelpID;
    CString csFilePath;
    CString csTemp;
    CString csContents;
    BOOL    bSuccess = FALSE;

    DWORD   dwHTMLHelpID;

    SdbMessageField FieldIcon;
    SdbMessageField FieldMessage;
    SdbMessageField FieldMSHAID;
    SdbMessageField FieldAName;
    SdbMessageField FieldAppTitle;
    SdbMessageField FieldAppVersion;
    SdbMessageField FieldContactInfo;
    SdbMessageField FieldDetails;
    SdbMessageField FieldCompanyName;
    SdbRefArray<SdbMessageField> rgFields;

    CString csURL, csContactInfo, csAppTitle;
    CString csDetails, csEncoding;
    CTextFile* pFile = NULL;

    csEncoding = pOutputFile->GetParameter(_T("ENCODING"));

    if (!pMessage->m_pDB->ConstructMessageParts(
        pAppHelp,
        pMessage,
        csLangID,
        &dwHTMLHelpID,
        &csURL,
        &csContactInfo,
        &csAppTitle,
        NULL,
        &csDetails)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    // generate name for the file -- this name appears also in
    // other places like in a tag at the beginning of the page, in
    // meta tag and in help project file, as well as in apperr.h

    //
    // give this entry a name in form idh_w2_helpid
    // this is also a filename (sans .htm)
    //
    csHelpID = ChmConstructArticleName(pOutputFile, pAppHelp, csLangID);
    csFilePath.Format(_T("%s%s.htm"), pOutputFile->GetDirectory(), csHelpID);

    try {
        if (0 == csEncoding.CompareNoCase(_T("ANSI"))) {
            pFile = new CANSITextFile(csFilePath,
                pDB->m_pCurrentMakefile->GetLangMap(csLangID)->m_dwCodePage,
                CFile::typeText |
                CFile::modeCreate |
                CFile::modeWrite |
                CFile::shareDenyWrite);

        } else {
            pFile = new CUTF8TextFile(csFilePath,
                CFile::typeText |
                CFile::modeCreate |
                CFile::modeWrite |
                CFile::shareDenyWrite);
        }

        csContents = csTemplate;
    
        // first up is the MS_HAID
        csTemp.Format(_T("<META NAME=\"MS_HAID\" CONTENT=\"a_%s\">\n"), (LPCTSTR)csHelpID);
        FieldMSHAID.m_csName = _T("MS_HAID");
        FieldMSHAID.m_csValue = csTemp;

        //
        // problem level... 
        // will not be used now
        switch(pAppHelp->m_Type) {
        case SDB_APPHELP_HARDBLOCK:
            csTemp = _T("<IMG SRC=\"apphelp_stop.gif\"/>");
            break;
            
        case SDB_APPHELP_NOBLOCK:
            csTemp = _T("<IMG SRC=\"apphelp_warn.gif\"/>");
            break;
        }

        FieldIcon.m_csName = _T("ICON");
        FieldIcon.m_csValue = csTemp;

        // next is name
        csTemp.Format(_T("<P><A NAME=\"a_%s\"></A></P>"), (LPCTSTR)csHelpID);
        FieldAName.m_csName = _T("A NAME");
        FieldAName.m_csValue = csTemp;

        csTemp = csAppTitle;
        csTemp.Replace(_T("\r\n"), _T("\n"));
        FieldAppTitle.m_csName = _T("TITLE");
        FieldAppTitle.m_csValue = csTemp;

        csTemp = _T("");
        csTemp.Replace(_T("\r\n"), _T("\n"));
        FieldAppVersion.m_csName = _T("VERSION");
        FieldAppVersion.m_csValue = csTemp;
        
        csTemp = csContactInfo;
        csTemp.Replace(_T("\r\n"), _T("\n"));
        ReplaceStringNoCase(csTemp, gszTagXMLBR, gszTagBR);
        ReplaceStringNoCase(csTemp, gszTagXMLP, gszTagP);
        FieldContactInfo.m_csName = _T("CONTACT INFO");
        FieldContactInfo.m_csValue = csTemp;
        
        csTemp = csDetails;
        csTemp.Replace(_T("\r\n"), _T("\n"));
        ReplaceStringNoCase(csTemp, gszTagXMLBR, gszTagBR);
        ReplaceStringNoCase(csTemp, gszTagXMLP, gszTagP);
        FieldDetails.m_csName = _T("DETAILS");
        FieldDetails.m_csValue = csTemp;

        csTemp = pAppHelp->m_pApp->GetLocalizedVendorName();
        FieldCompanyName.m_csName = _T("COMPANY NAME");
        FieldCompanyName.m_csValue = csTemp;

        rgFields.Add(&FieldIcon);
        rgFields.Add(&FieldMessage);
        rgFields.Add(&FieldMSHAID);
        rgFields.Add(&FieldAName);
        rgFields.Add(&FieldAppTitle);
        rgFields.Add(&FieldAppVersion);
        rgFields.Add(&FieldContactInfo);
        rgFields.Add(&FieldDetails);
        rgFields.Add(&FieldCompanyName);
        if (!pDB->ReplaceFields(csContents, &csContents, &rgFields)) {
            goto eh;
        }

        if (0 == csEncoding.CompareNoCase(_T("ANSI"))) {
            ReplaceStringNoCase(
                csContents,
                _T("%HTML_CHARSET%"),
                pDB->m_pCurrentMakefile->GetLangMap(csLangID)->m_csHtmlCharset);
        } else {
            ReplaceStringNoCase(
                csContents,
                _T("%HTML_CHARSET%"),
                _T("UTF-8"));
        }

        pFile->WriteString(csContents);
        
        pFile->Close();

        bSuccess = TRUE;

    }
    catch(CFileException* pFileEx) {
        pFileEx->Delete();
    }
    catch(CMemoryException* pMemEx) {
        pMemEx->Delete();
    }
eh:

    if (pFile) {
        delete pFile;
    }

    return bSuccess;
}

BOOL ChmUpdateFile(LPCTSTR lpszFilePath, LPCTSTR lpszString)
{
   BOOL bSuccess = TRUE;

   try {
      CStdioFile File(lpszFilePath, CFile::modeCreate|CFile::modeNoTruncate|CFile::modeReadWrite|CFile::shareDenyWrite);
      File.SeekToEnd();
      File.WriteString(lpszString);
   }
   catch(CFileException* pex) {
      bSuccess = FALSE;
      pex->Delete();
   }

   return(bSuccess);
}



//
// generate apperr.h
// generate symbols for every file
//

BOOL ChmCreateHFileEntry(SdbAppHelp* pAppHelp, CString& csEntry)
{
   csEntry.Format(_T("#define idh_w2_%s %s"),
                  pAppHelp->m_csName,
                  pAppHelp->m_csName);
   return(TRUE);
}

BOOL ChmUpdateHFile(
   SdbOutputFile*  pOutputFile,
   SdbMessage* pMessage,
   SdbAppHelp* pAppHelp)
{
   CString csEntry;
   BOOL bSuccess;
   CString csFilePath;

   csFilePath = pOutputFile->GetFullPathWithoutExtension() + _T(".h");

   bSuccess = ChmCreateHFileEntry(pAppHelp, csEntry);
   if (bSuccess) {
      csEntry += _T("\n");
      bSuccess = ChmUpdateFile(csFilePath, csEntry);
   }
   return(bSuccess);
}

BOOL ChmWriteHHPFileHeader(
    SdbDatabase* pDB,
    SdbOutputFile*  pOutputFile)
{
    CString csHeader, csOut;
    BOOL  bSuccess = FALSE;

    csHeader += _T("[OPTIONS]                                \n");
    csHeader += _T("Binary Index=No                          \n");
    csHeader += _T("Compatibility=1.1                        \n");
    csHeader += _T("Compiled file=%s.chm                     \n");
    csHeader += _T("Default Window=nobrowse                  \n");
    csHeader += _T("Default topic=%s_first_screen.htm        \n");
    csHeader += _T("Display compile progress=Yes             \n");
    csHeader += _T("Error log file=%s.log                    \n");
    csHeader += _T("                                         \n");
    csHeader += _T("[WINDOWS]                                \n");
    csHeader += _T("nobrowse=\"\",,,,,,,,,,,0x0,,,,,,,,0 \n");
    csHeader += _T("                                         \n");
    csHeader += _T("[MAP]                                    \n");
    csHeader += _T("                                         \n");
    csHeader += _T("[FILES]                                  \n");
    csHeader += _T("%s_first_screen.htm                      \n");

    CString csNameWithoutExt = pOutputFile->GetNameWithoutExtension();

    csOut.Format(csHeader, csNameWithoutExt,
        csNameWithoutExt, csNameWithoutExt,
        csNameWithoutExt);

    try {
        CStdioFile File(pOutputFile->GetFullPathWithoutExtension() + _T(".hhp"),
            CFile::typeText |
            CFile::modeCreate |
            CFile::modeWrite |
            CFile::shareDenyWrite);

        File.WriteString(csOut);

        File.Close();
    }
    catch(...) {
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL ChmWriteFirstScreen(
    SdbDatabase* pDB,                           
    SdbOutputFile*  pOutputFile)
{
    BOOL  bSuccess = FALSE;


    try {
        CStdioFile File(pOutputFile->GetFullPathWithoutExtension() + _T("_first_screen.htm"),
            CFile::typeText |
            CFile::modeCreate |
            CFile::modeWrite |
            CFile::shareDenyWrite);

        File.WriteString(pDB->m_csHTMLHelpFirstScreen);

        File.Close();
    }
    catch(...) {
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL ChmUpdateHHPFile(
   SdbOutputFile*  pOutputFile,
   SdbAppHelp* pAppHelp,
   CString csLangID)
{
   CString csEntry;
   CString csFilePath;
   BOOL bSuccess;

   csFilePath = pOutputFile->GetFullPathWithoutExtension() + _T(".hhp");

   // we presume to be writing file list now
   csEntry = ChmConstructArticleName(pOutputFile, pAppHelp, csLangID);
   csEntry += _T(".htm\n");
   bSuccess = ChmUpdateFile(csFilePath, csEntry);
   return(bSuccess);
}

//
// lpszPath here denotes the path to the help file project's directory
//
BOOL ChmProcessMessageEntry(
   SdbDatabase* pDB,
   SdbOutputFile*  pOutputFile,
   SdbAppHelp* pAppHelp,
   SdbMessage* pMessage,
   CString& csTemplate,
   CString& csLangID)
{
   BOOL bSuccess;

   // 1 - generate chum
   bSuccess = ChmCreatePage(pDB, pOutputFile, pAppHelp, pMessage, csTemplate, csLangID);
   if (!bSuccess) {
      goto eh;
   }

   // 2 - update hhp -- append filename to it
   bSuccess = ChmUpdateHHPFile(pOutputFile, pAppHelp, csLangID);

eh:
   return(bSuccess);

}

BOOL ChmPrepareDirectory(
   SdbDatabase* pDB,
   SdbOutputFile*  pOutputFile)
{
   CString csDest;
   BOOL    bSuccess = FALSE;

   try {

       if (!ChmWriteHHPFileHeader(pDB, pOutputFile)) {
          goto eh;
       }

        if (!ChmWriteFirstScreen(pDB, pOutputFile)) {
            goto eh;
        }

   }
   catch(CFileException* pex) {
      pex->Delete();
      goto eh;
   }

   bSuccess = TRUE;

eh:

   return bSuccess;
}

// go through all the entries in apphelp database
BOOL ChmWriteProject(
    SdbOutputFile*  pOutputFile,
    SdbDatabase*    pMessageDB)
{
    BOOL bOverallSuccess = FALSE;
    SdbMessage* pMessage = NULL;
    SdbAppHelp* pAppHelp = NULL;
    SdbDatabase* pAppHelpDB = NULL;
    SdbLocalizedString* pHTMLHelpTemplate = NULL;
    int i, j;
    CString csTemplate;
    CString csLanguagesParam, csLangID;
    CStringArray rgLanguages;

    csLanguagesParam = pOutputFile->GetParameter(_T("LANGUAGES"));
    if (csLanguagesParam.GetLength()) {
        if (!ParseLanguagesString(csLanguagesParam, &rgLanguages))
        {
            SDBERROR_FORMAT((_T("Error parsing LANGUAGES parameter in makefile: %s\n"), csLanguagesParam));
            goto eh;
        }
    } else {
        rgLanguages.Add(pMessageDB->m_pCurrentMakefile->m_csLangID);
    }

    if (!pOutputFile->GetParameter(_T("HTMLHELP TEMPLATE")).GetLength()) {
        SDBERROR(_T("No HTMLHELP_TEMPLATE <PARAM> specified for CHM file generation."));
        goto eh;
    }

    if (!ChmPrepareDirectory(pMessageDB, pOutputFile)) {
        SDBERROR(_T("Error preparing HTMLHelp directory."));
        goto eh;
    }

    for (j = 0; j < rgLanguages.GetSize(); j++)
    {
        csLangID = rgLanguages[j];

        pHTMLHelpTemplate = (SdbLocalizedString *) pMessageDB->m_rgHTMLHelpTemplates.LookupName(
            pOutputFile->GetParameter(_T("HTMLHELP TEMPLATE")), csLangID);

        if (!pHTMLHelpTemplate) {
            SDBERROR_FORMAT((_T("HTMLHELP_TEMPLATE not found for LANG \"%s\": \"%s\"\n"), 
                csLangID, pOutputFile->GetParameter(_T("HTMLHELP_TEMPLATE"))));
            goto eh;
        }

        csTemplate = pHTMLHelpTemplate->m_csValue;
        if (csTemplate.GetLength() == 0) {
            SDBERROR(_T("No HTMLHelp template specified."));
            goto eh;
        }

        pAppHelpDB = pMessageDB;
        for (i = 0; i < pAppHelpDB->m_rgAppHelps.GetSize(); ++i) {

            pAppHelp = (SdbAppHelp*)pAppHelpDB->m_rgAppHelps[i];

            if (SDB_APPHELP_NONE == pAppHelp->m_Type) {
                continue;
            }

            if (!(g_dwCurrentWriteFilter & pAppHelp->m_dwFilter)) {
                continue;
            }

            if (g_dtCurrentWriteRevisionCutoff > pAppHelp->m_dtLastRevision) {
                continue;
            }

            pMessage = (SdbMessage *) pMessageDB->m_rgMessages.LookupName(pAppHelp->m_csMessage, csLangID);

            if (pMessage == NULL) {
                //
                // Message instance not found in localized file.
                //
                SDBERROR_FORMAT((_T("Localized MESSAGE not found for\n    NAME:       %s\n    HTMLHELPID: %s\n    LANG:       %s\n"),
                    pAppHelp->m_csMessage, pAppHelp->m_csName, csLangID));
                goto eh;
            }

            if (!ChmProcessMessageEntry(
                    pMessageDB,
                    pOutputFile,
                    pAppHelp,
                    pMessage,
                    csTemplate,
                    csLangID)) {
                SDBERROR_PROPOGATE();
                goto eh;
            }
        }
    }

    bOverallSuccess = TRUE;

eh:
    return(bOverallSuccess);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\globals.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    globals.cpp
//
// History: 16-Nov-00   markder     Created.
//
// Desc:    This file contains miscellaneous helper functions.
//
////////////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include <errno.h>

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   PrintError, PrintErrorStack, Print
//
//  Desc:   Helper functions for console output
//
////////////////////////////////////////////////////////////////////////////////////

TCHAR gszT[1024]; // Global buffer for console output

void _cdecl PrintError(
                      LPCTSTR pszFmt,
                      ...)
{
    va_list arglist;

    va_start(arglist, pszFmt);
    StringCchVPrintf(gszT, ARRAYSIZE(gszT), pszFmt, arglist);
    gszT[1023] = _T('\0');              // ensure null termination
    va_end(arglist);
    _tprintf(_T("\nNMAKE :  U8604: 'ShimDBC': %s"), gszT);
}

void PrintErrorStack()
{
    CString csError;
    INT_PTR     i, j;

    Print(_T("\n\nErrors were encountered during compilation:\n"));
    for (i = g_rgErrors.GetSize() - 1; i >= 0; i--) {
        csError.Empty();
        j = g_rgErrors.GetSize() - i;
        while(--j) {
            csError += _T(" ");
        }
        csError += g_rgErrors[i];
        csError += _T("\n");
        PrintError(csError);
    }
}

void _cdecl Print(
                 LPCTSTR pszFmt,
                 ...)
{
    va_list arglist;

    if (g_bQuiet)
        return;

    va_start(arglist, pszFmt);
    StringCchVPrintf(gszT, ARRAYSIZE(gszT), pszFmt, arglist);
    gszT[1023] = _T('\0');              // ensure null termination
    va_end(arglist);
    _tprintf(_T("%s"), gszT);

}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   StringToDword
//
//  Desc:   Converts a string to a DWORD. Handles the 0x prefix for hex strings.
//
DWORD StringToDword(
    CString cs)
{
    DWORD dwRet;

    cs.MakeLower();

    if (cs.Left(2) == _T("0x")) {
        _stscanf(cs, _T("0x%x"), &dwRet);
    } else {
        dwRet = _ttol(cs);
    }

    return dwRet;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   StringToULong
//
//  Desc:   Converts a string to a unsigned long.
//
ULONG StringToULong(
    LPCTSTR lpszVal)
{
    TCHAR* pEnd;

    return _tcstoul(lpszVal, &pEnd, 0);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   StringToMask
//
//  Desc:   Converts a string to a mask, with some checking
//
BOOL
StringToMask(
    LPDWORD pdwMask,
    LPCTSTR lpszVal
    )
{
    DWORD dwMask = 0;
    LPCTSTR pVal;
    BOOL bSuccess;
    TCHAR* pEnd = NULL;

    pVal = lpszVal + _tcsspn(lpszVal, _T(" \t"));
    dwMask = (DWORD)_tcstoul(pVal, &pEnd, 0);

    if (dwMask == 0) { // suspicious, possibly check errno
        if (errno != 0) {
            goto errHandle;
        }
    }

    //
    // if a mask is ending with some garbage -- it's an error
    //
    if (pEnd && *pEnd != _T('\0') && !_istspace(*pEnd)) {
        goto errHandle;
    }

    if (pdwMask) {
        *pdwMask = dwMask;
    }
    return TRUE;


errHandle:
    SDBERROR_FORMAT((_T("Failed to parse \"%s\"\n"), lpszVal));
    return FALSE;
}





////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   StringToQword
//
//  Desc:   Converts a string to a 64-bit ULONGLONG (aka QWORD). Handles the 0x
//          prefix for hex strings.
//
ULONGLONG StringToQword(
    CString cs)
{
    ULONGLONG ullRet;

    cs.MakeLower();

    if (cs.Left(2) == _T("0x")) {
        _stscanf(cs, _T("0x%I64x"), &ullRet);
    } else {
        ullRet = _ttoi64(cs);
    }

    return ullRet;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   VersionToQword
//
//  Desc:   Converts a version string to a 64-bit ULONGLONG (aka QWORD).
//          Version strings are of the form xx.xx.xx.xx, where each of
//          numbers is turned into a word and combined into a single
//          quad word. If a portion of the version string is a * or is
//          missing, it is stored as 0xFFFF.
//
BOOL VersionToQword(
    LPCTSTR lpszVersion,
    ULONGLONG* pullRet
    )
{
    BOOL          bSuccess = FALSE;
    ULONG     ulPart;
    LPTSTR    pEnd = NULL;
    int i;

    *pullRet = 0;

    for (i = 0; i < 4; i++) {

        ulPart = (WORD)0xFFFF;

        //
        // skip whitespace
        //

        lpszVersion += _tcsspn(lpszVersion, _T(" \t"));

        if (*lpszVersion == _T('*')) {

            //
            // we expect to see either *\0 or *.xxx
            // so move past *
            //
            pEnd = (LPTSTR)(lpszVersion + 1);

        }
        else {
            //
            // not a wildcard - if we have not reached the end of the string,
            // keep parsing numbers
            //
            if (*lpszVersion) {

                pEnd = NULL;

                ulPart = _tcstol(lpszVersion, &pEnd, 0);

                //
                // check to see that the part was converted properly
                //
                if (pEnd == NULL) {
                    SDBERROR_FORMAT((_T("Internal error, failed to parse \"%s\"\n"), lpszVersion));
                    goto eh;
                }
            }

        }

        if (pEnd == NULL) {
            break;
        }

        //
        // skip whitespace first
        //
        pEnd += _tcsspn(pEnd, _T(" \t"));

        //
        // at this point we should be at the end of
        // the string OR at the '.'
        //
        if (*pEnd && *pEnd != _T('.')) {
            SDBERROR_FORMAT((_T("Bad version specification, parsing stopped at \"%s\"\n"), pEnd));
            goto eh;
        }

        lpszVersion = (*pEnd == _T('.') ? pEnd + 1 : pEnd);

        *pullRet = (*pullRet << 16) | ((WORD)ulPart);
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL VersionQwordToString(
    OUT CString&   rString,
    ULONGLONG      ullVersion
    )
{
    // we do conversion to string
    int       i;
    WORD      wPart;
    CString   csPart;
    ULONGLONG ullMask = (((ULONGLONG)0xFFFF) << 48);
    ULONGLONG ullPart;

    rString.Empty();

    for (i = 0; i < 4; ++i) {

        ullPart = ullVersion & ullMask;
        ullVersion = (ullVersion << 16) | (WORD)0xFFFF;

        //
        // get the part into the lower portion
        //
        wPart = (WORD)(ullPart >> 48);

        if (wPart == (WORD)0xFFFF) {
            csPart = _T('*');
        } else {
            csPart.Format(_T("%hu"), wPart);
        }

        if (i > 0) {
            rString += _T('.');
        }

        rString += csPart;

        if (ullVersion == (ULONGLONG)-1) {
            break;
        }

    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   TrimParagraph
//
//  Desc:   Trims extra whitespace from a string
//
//

CString TrimParagraph(CString csInput)
{
    CString csOutput;
    long i;

    // Expand CString's buffer to size of input
    csOutput.GetBuffer(csInput.GetLength());
    csOutput.ReleaseBuffer();

    for (i = 0; i < csInput.GetLength(); i++) {
        TCHAR c = csInput.GetAt(i);

        if (_istspace(c)) {
            if (csOutput.GetLength() == 0)
                continue;

            if (csOutput.Mid(csOutput.GetLength() - 1) == _T(' ') ||
                csOutput.Mid(csOutput.GetLength() - 4, 4) == _T("BR/>") ||
                csOutput.Mid(csOutput.GetLength() - 3, 3) == _T("P/>"))
                continue;

            csOutput += _T(' ');
            continue;
        }

        if (csInput.Left(3) == _T("<BR") ||
            csInput.Left(2) == _T("<P")) {
            //
            // Get rid of spaces preceding a <BR/> tag
            //
            csOutput.TrimRight();
        }

        csOutput += c;
    }

    csOutput.TrimLeft();
    csOutput.TrimRight();

    return csOutput;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   ReplaceStringNoCase
//
//  Desc:   Replaces all instances of lpszFindThis with lpszReplaceWithThis
//          within csText (case insensitive).
//
VOID ReplaceStringNoCase(CString& csText, LPCTSTR lpszFindThis, LPCTSTR lpszReplaceWithThis)
{
    LPTSTR lpszBuffer;
    LPTSTR lpszFind;

    if (0 == csText.GetLength()) {
        return;
    }

    CString strFindNoCase(lpszFindThis);

    lpszBuffer = csText.GetBuffer(csText.GetLength());

    strFindNoCase.MakeUpper();

    do {
        lpszFind = StrStrI(lpszBuffer, strFindNoCase);
        if (NULL != lpszFind) {
            memcpy(lpszFind, (LPCTSTR)strFindNoCase, strFindNoCase.GetLength() * sizeof(*lpszFind));
            lpszBuffer = lpszFind + strFindNoCase.GetLength();
        }
    } while (NULL != lpszFind);

    // now that all the instances of the lpszFindThis had been replaced with
    // the upper-cased version... do a regular replace
    csText.ReleaseBuffer();
    csText.Replace(strFindNoCase, lpszReplaceWithThis);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   MakeFullPath
//
//  Desc:   Creates a full path from a (possible) relative one. Uses
//          GetCurrentDirectory to prepend the passed in string.
//
CString MakeFullPath(CString cs)
{
    CString csNewPath;
    DWORD dwCurDirSize;
    LPTSTR lpszCurDir;

    return cs;

#if 0
    //
    // Check if it's already a full path
    //
    if (cs.Mid(1, 1) == _T(":") ||
        cs.Left(2) == _T("\\\\")) {
        //
        // This is either a UNC full path or a DOS full path.
        // Drop out.
        //
        return cs;
    }

    dwCurDirSize = GetCurrentDirectory(0, NULL);
    lpszCurDir = csNewPath.GetBuffer(dwCurDirSize);

    if (0 == GetCurrentDirectory(dwCurDirSize, lpszCurDir)) {
        //
        // Something really weird happened. Not sure how to error out.
        //
        return cs;
    }

    csNewPath.ReleaseBuffer();

    if (csNewPath.Right(1) != _T("\\")) {
        csNewPath += _T("\\");
    }

    csNewPath += cs;

    return csNewPath;
#endif
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   GetByteStringSize
//
//  Desc:   Parses a 'byte string' (used in <PATCH> declarations) to determine
//          how many bytes it contains.
//
DWORD GetByteStringSize(
    CString  csBytes)
{
    DWORD dwByteCount = 0;
    BOOL  bOnByte = FALSE;

    csBytes.MakeUpper();

    for (long i = 0; i < csBytes.GetLength(); i++) {
        if (_istxdigit(csBytes.GetAt(i))) {
            if (!bOnByte) {
                dwByteCount++;
                bOnByte = TRUE;
            }
        } else if (_istspace(csBytes.GetAt(i))) {
            bOnByte = FALSE;
        } else {
            SDBERROR_FORMAT((_T("Unrecognized byte character '%c' in <PATCH> block:\n%s\n"),
                              csBytes.GetAt(i), ((LPCTSTR)csBytes)+i));

            return 0xFFFFFFFF;
        }
    }

    return dwByteCount;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   GetBytesFromString
//
//  Desc:   Parses a 'byte string' (used in <PATCH> declarations) into an actual
//          memory block.
//
DWORD GetBytesFromString(
    CString  csBytes,
    BYTE*    pBuffer,
    DWORD    dwBufferSize)
{
    csBytes.MakeUpper();

    CString csByte;
    DWORD   dwRequiredBufferSize;
    LONG    nFirstByteChar = -1;
    DWORD   dwBufferCursor = 0;
    DWORD   dwByte;

    dwRequiredBufferSize = GetByteStringSize(csBytes);

    if (dwRequiredBufferSize < dwBufferSize || dwRequiredBufferSize == 0xFFFFFFFF) {
        return dwRequiredBufferSize;
    }

    for (long i = 0; i < csBytes.GetLength() + 1; i++) {
        if (_istxdigit(csBytes.GetAt(i))) {

            if (nFirstByteChar == -1) {
                nFirstByteChar = i;
            }
        } else if (_istspace(csBytes.GetAt(i))   ||
                   csBytes.GetAt(i) == _T('\0')) {

            if (nFirstByteChar != -1) {
                csByte = csBytes.Mid(nFirstByteChar, i - nFirstByteChar);
                _stscanf(csByte, _T("%x"), &dwByte);
                memcpy(pBuffer + dwBufferCursor++, &dwByte, sizeof(BYTE));
            }

            nFirstByteChar = -1;
        } else {
            SDBERROR_FORMAT((_T("Unrecognized byte character '%c' in <PATCH> block:\n%s\n"),
                              csBytes.GetAt(i), ((LPCTSTR)csBytes)+i));

            return 0xFFFFFFFF;
        }
    }

    return dwRequiredBufferSize;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   DecodeString
//
//  Desc:   Decodes a list of strings with flags
//
//  [00]  [00]    [00]   [00]
//    ^   Arch1   Arch2  Arch3
//    |- flags
//
//  syntax for the runtime platform:
//  [!] ( [!] STR1 [; STR2 ] ... )
//  example:
//  !STR1 - will evaluate to TRUE when the the string is NOT STR1
//  !(STR1; STR2) - will evaluate to TRUE when the string doesn't contain STR1 or STR2
//


BOOL DecodeString(LPCTSTR pszStr, LPDWORD pdwMask, PFNGETSTRINGMASK pfnGetStringMask)
{
    BOOL   bNot     = FALSE;
    BOOL   bBracket = FALSE;
    LPTSTR pEnd;
    TCHAR  chSave;
    DWORD  dwElement;
    BOOL   bNotElement;
    DWORD  dwMask = 0;
    INT    nElement = 0;
    BOOL   bSuccess = FALSE;

    pszStr += _tcsspn(pszStr, _T(" \t"));
    //
    // Got the first char
    //
    if (*pszStr == _T('!')) {
        //
        // Peek ahead and see whether we have a bracket
        //
        pEnd = (LPTSTR)(pszStr + 1);
        pEnd += _tcsspn(pEnd, _T(" \t"));
        if (*pEnd == '(') {
            // global not
            bNot = TRUE;
            pszStr = pEnd;
        } else {
            // local NOT -- so jump to parsing it
            goto ParseStart;
        }
    }

    if (*pszStr == _T('(')) {
        // bracket, we need to find closing one too
        ++pszStr;
        bBracket = TRUE;
    }

ParseStart:

    do {
        dwElement = 0;
        pszStr += _tcsspn(pszStr, _T(" ;,\t"));
        if (*pszStr == _T('\0') || *pszStr == _T(')')) {
            break;
        }

        bNotElement = (*pszStr == _T('!'));

        if (bNotElement) {
            pszStr++;
        }

        // find the end of this token
        pEnd = _tcspbrk(pszStr, _T(" \t;,)"));
        if (pEnd != NULL) {
            chSave = *pEnd;
            *pEnd = _T('\0');
        }

        dwElement = (*pfnGetStringMask)(pszStr);

        if (pEnd) {
            *pEnd = chSave;
        }

        if (dwElement == OS_SKU_NONE) {
            goto HandleError;
        }

        if (bNotElement) {
            dwElement ^= 0xFFFFFFFF;
        }

        dwMask |= dwElement;

        pszStr = pEnd;

    } while (pEnd);  // when pEnd == NULL -- it was the last token

    if (bBracket && (!pszStr || *pszStr != ')')) {
        // we expected a bracket here
        goto HandleError;
    }

    if (bNot) {
        dwMask ^= 0xFFFFFFFF;
    }

    *pdwMask = dwMask;
    bSuccess = TRUE;

HandleError:

    if (!bSuccess) {
        SDBERROR_FORMAT((_T("Failed to decode \"%s\"\n"), pszStr));
    }

    return bSuccess;
}



////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   DecodeRuntimePlatformString
//
//  Desc:   Decodes a list of Platform Strings with flags
//
//  [00]  [00]    [00]   [00]
//    ^   Arch1   Arch2  Arch3
//    |- flags
//
//  syntax for the runtime platform:
//  [!] ( [!] Platform1 [; Platform2 ] ... )
//  example:
//  !(IA64; !X86) - will evaluate to TRUE when it's NOT IA64 (native) and X86
//  (IA3264; X86) - will evaluate to TRUE when it's running on X86 or 32-bit subsystem on IA64
//  (AMD64; IA3264) - will evaluate to TRUE when it's running on AMD64 or 32-bit subsystem on ia64
//


BOOL DecodeRuntimePlatformString(LPCTSTR pszPlatform, LPDWORD pdwRuntimePlatform)
{
    BOOL bNot        = FALSE;
    BOOL bBracket    = FALSE;
    LPTSTR pEnd;
    TCHAR  chSave;
    DWORD  dwElement;
    DWORD  dwNotElementFlag;
    DWORD  dwRuntimePlatform = 0;
    INT    nElement = 0;
    BOOL   bSuccess = FALSE;

    pszPlatform += _tcsspn(pszPlatform, _T(" \t"));
    // got the first char
    if (*pszPlatform == _T('!')) {
        // peek ahead and see whether we have a bracket

        pEnd = (LPTSTR)(pszPlatform + 1);
        pEnd += _tcsspn(pEnd, _T(" \t"));
        if (*pEnd == '(') {
            // global not
            bNot = TRUE;
            pszPlatform = pEnd;
        } else {
            // local NOT -- so jump to parsing it
            goto ParseStart;
        }
    }

    if (*pszPlatform == _T('(')) {
        // bracket, we need to find closing one too
        ++pszPlatform;
        bBracket = TRUE;
    }

ParseStart:

    do {
        dwElement = 0;
        pszPlatform += _tcsspn(pszPlatform, _T(" ;,\t"));
        if (*pszPlatform == _T('\0') || *pszPlatform == _T(')')) {
            break;
        }

        dwNotElementFlag = (*pszPlatform == _T('!')) ? RUNTIME_PLATFORM_FLAG_NOT_ELEMENT : 0;

        // find the end of this token
        pEnd = _tcspbrk(pszPlatform, _T(" \t;,)"));
        if (pEnd != NULL) {
            chSave = *pEnd;
            *pEnd = _T('\0');
        }

        dwElement = GetRuntimePlatformType(pszPlatform);
        if (pEnd) {
            *pEnd = chSave;
        }

        if (dwElement == PROCESSOR_ARCHITECTURE_UNKNOWN) {
            goto HandleError;
        }

        dwElement |= dwNotElementFlag | RUNTIME_PLATFORM_FLAG_VALID;

        if (nElement >= 3) {
            goto HandleError;
        }

        // now shift
        dwElement <<= (nElement * 8);
        ++nElement; // on to the next element
        dwRuntimePlatform |= dwElement;

        pszPlatform = pEnd;

    } while(pEnd);  // when pEnd == NULL -- it was the last token

    if (bBracket && (!pszPlatform || *pszPlatform != ')')) {
        // we expected a bracket here
        goto HandleError;
    }

    if (bNot && nElement > 1) {
        dwRuntimePlatform |= RUNTIME_PLATFORM_FLAG_NOT;
    }

    *pdwRuntimePlatform = dwRuntimePlatform;
    bSuccess = TRUE;

HandleError:

    return bSuccess;

}



////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   ReadName
//
//  Desc:   Wrapper to read the name attribute from an XML node.
//
BOOL ReadName( IXMLDOMNode* pNode, CString* pcsName)
{
    BOOL bSuccess = FALSE;

    if (!GetAttribute(_T("NAME"), pNode, pcsName)) {
        SDBERROR_FORMAT((_T("NAME attribute required:\n%s\n\n"),
                          GetXML(pNode)));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return TRUE;
}

BOOL ReadLangID(IXMLDOMNode* pNode, SdbDatabase* pDB, CString* pcsLangID)
{
    if (!GetAttribute(_T("LANGID"), pNode, pcsLangID)) {
        if (!pDB->m_csCurrentLangID.GetLength())
        {
            SDBERROR_FORMAT((
                _T("Tag requires LANGID attribute if there is no LANGID on the DATABASE node\n%s\n"),
                GetXML(pNode)));
            return FALSE;
        }

        *pcsLangID = pDB->m_csCurrentLangID;
    }

    return TRUE;
}

BOOL FilterOSVersion(DOUBLE flOSVersion, CString csOSVersionSpec, LPDWORD lpdwSPMask)
{
    DOUBLE  flVerXML;
    CString csTemp;
    long    nBeg, i, nIndSP;
    int     nSPVersion;
    TCHAR   chSP;
    BOOL    bFilter = TRUE;
    DWORD   dwSPMask;

    if (flOSVersion == 0.0 || csOSVersionSpec.IsEmpty()) {
        *lpdwSPMask = 0xFFFFFFFF;
        return FALSE;
    }

    *lpdwSPMask = 0;

    nBeg = 0;

    for (i = 0; i <= csOSVersionSpec.GetLength(); i++) {
        if (csOSVersionSpec.GetAt(i) == _T('\0') || csOSVersionSpec.GetAt(i) == _T(';')) {

            csTemp = csOSVersionSpec.Mid(nBeg, i - nBeg);
            nBeg = i + 1;

            if (csTemp.GetLength() == 0) {
                continue;
            }

            dwSPMask = 0xFFFFFFFF;

            nSPVersion = -1;
            nIndSP = -1;

            if ((nIndSP = csTemp.Find('.')) != -1) {
                if ((nIndSP = csTemp.Find('.', nIndSP + 1)) != -1) {

                    CString csSP = csTemp.Right(csTemp.GetLength() - nIndSP - 1);

                    chSP = csTemp.GetAt(nIndSP);
                    csTemp.SetAt(nIndSP, 0);

                    nSPVersion = _ttoi(csSP);
                }
            }

            if (csTemp.Left(2) == _T("gt")) {
                if (csTemp.Left(3) == _T("gte")) {

                    flVerXML = _tcstod(csTemp.Right(csTemp.GetLength() - 3), NULL);

                    if (flOSVersion >= flVerXML) {
                        bFilter = FALSE;
                    }

                    if (nSPVersion != -1 && flOSVersion == flVerXML) {
                        dwSPMask = 0xFFFFFFFF - (1 << nSPVersion) + 1;
                    }

                } else {

                    flVerXML = _tcstod(csTemp.Right(csTemp.GetLength() - 2), NULL);

                    if (flOSVersion > flVerXML) {
                        bFilter = FALSE;
                    }

                    if (nSPVersion != -1 && flOSVersion == flVerXML) {
                        bFilter = FALSE;
                        dwSPMask = 0xFFFFFFFF - (1 << (nSPVersion + 1)) + 1;
                    }
                }
            } else if (csTemp.Left(2) == _T("lt")) {
                if (csTemp.Left(3) == _T("lte")) {

                    flVerXML = _tcstod(csTemp.Right(csTemp.GetLength() - 3), NULL);

                    if (flOSVersion <= flVerXML) {
                        bFilter = FALSE;
                    }

                    if (nSPVersion != -1 && flOSVersion == flVerXML) {
                        dwSPMask = 0xFFFFFFFF - (1 << (nSPVersion + 1)) + 1;
                        dwSPMask ^= 0xFFFFFFFF;
                    }

                } else {
                    flVerXML = _tcstod(csTemp.Right(csTemp.GetLength() - 2), NULL);

                    if (flOSVersion < flVerXML) {
                        bFilter = FALSE;
                    }

                    if (nSPVersion != -1 && flOSVersion == flVerXML) {
                        bFilter = FALSE;
                        dwSPMask = 0xFFFFFFFF - (1 << nSPVersion) + 1;
                        dwSPMask ^= 0xFFFFFFFF;
                    }
                }
            } else {
                if (flOSVersion == _tcstod(csTemp, NULL)) {
                    bFilter = FALSE;

                    if (nSPVersion != -1) {
                        dwSPMask = (1 << nSPVersion);
                    }
                }
            }

            if (nIndSP != -1) {
                csTemp.SetAt(nIndSP, chSP);
                *lpdwSPMask |= dwSPMask;
            }
        }
    }

    if (*lpdwSPMask == 0) {
        *lpdwSPMask = 0xFFFFFFFF;
    }

    return bFilter;
}


VOID ExpandEnvStrings(CString* pcs)
{
    LPTSTR lpszBuf;
    DWORD cchReqBufSize;
    CString cs(*pcs);

    cchReqBufSize = ExpandEnvironmentStrings(cs, NULL, 0);
    lpszBuf = pcs->GetBuffer(cchReqBufSize);
    ExpandEnvironmentStrings(cs, lpszBuf, cchReqBufSize);
    pcs->ReleaseBuffer();
}

BOOL MakeUTCTime(CString& cs, time_t* pt)
{
    BOOL bSuccess = FALSE;
    CString csTZ;

    //
    // Set TZ environment variable to override locale
    // settings so that date/time conversion routines
    // never do any localizations.
    //
    csTZ = _tgetenv(_T("TZ"));
    csTZ = _T("TZ=") + csTZ;
    _tputenv(_T("TZ=UTC0"));
    _tzset();

    COleDateTime odt;
    SYSTEMTIME st;
    CTime time;

    if (!odt.ParseDateTime(cs)) {
        goto eh;
    }

    if (!odt.GetAsSystemTime(st)) {
        goto eh;
    }

    time = st;

    *pt = time.GetTime();

    bSuccess = TRUE;

eh:
    _tputenv(csTZ);
    _tzset();

    return bSuccess;
}

BOOL ParseLanguageID(LPCTSTR pszLanguage, DWORD* pdwLanguageID)
{
    LPCTSTR pch;
    LPTSTR  pend = NULL;
    BOOL    bSuccess = FALSE;
    BOOL    bBracket = FALSE;
    DWORD   dwLangID = 0;

    pch = _tcschr(pszLanguage, TEXT('['));
    if (NULL != pch) {
        bBracket = TRUE;
        ++pch;
    } else {
        pch = pszLanguage;
    }

    while (_istspace(*pch)) {
        ++pch;
    }

    dwLangID = _tcstoul(pch, &pend, 0);

    if (dwLangID == 0) {
        goto cleanup;
    }

    if (pend != NULL) {
        bSuccess = bBracket ? (_istspace(*pend) || *pend == TEXT(']')) :
                              (_istspace(*pend) || *pend == TEXT('\0'));
    }

cleanup:

    if (bSuccess) {
        *pdwLanguageID = dwLangID;
    }

    return bSuccess;


}

BOOL ParseLanguagesString(CString csLanguages, CStringArray* prgLanguages)
{
    BOOL bSuccess = FALSE, bExistsAlready = FALSE;
    int nLastSemicolon = -1, i, j;
    CString csLangID;

    for (i = 0; i <= csLanguages.GetLength(); i++)
    {
        if (csLanguages[i] == _T(';') || csLanguages[i] == _T('\0')) {
            csLangID = csLanguages.Mid(nLastSemicolon + 1, i - nLastSemicolon - 1);
            csLangID.TrimLeft();
            csLangID.TrimRight();
            csLangID.MakeUpper();
            
            bExistsAlready = FALSE;
            for (j = 0; j < prgLanguages->GetSize(); j++)
            {
                if (prgLanguages->GetAt(j) == csLangID)
                {
                    bExistsAlready = TRUE;
                    break;
                }
            }

            if (!bExistsAlready)
            {
                prgLanguages->Add(csLangID);
            }

            nLastSemicolon = i;
        }
    }

    bSuccess = TRUE;

    return bSuccess;
}

CString GetGUID(REFGUID guid)
{
    CString csRet;
    LPOLESTR lpszGUID = NULL;

    StringFromCLSID(guid, &lpszGUID);

    csRet = lpszGUID;

    CoTaskMemFree(lpszGUID);

    return csRet;
}

CString ProcessShimCmdLine(
    CString& csCommandLine,
    GUID&    guidDB,
    TAGID    tiShimRef
    )
{
    //
    // find whether we have anything to expand in csCommandLine
    //

    LPCTSTR pch;
    int nIndex;
    CString csNewCmdLine = csCommandLine;
    CString csToken;
    int nIndexStart = 0;
    int nIndexEnd;

    while (nIndexStart < csNewCmdLine.GetLength()) {

        nIndex = csNewCmdLine.Find(_T('%'), nIndexStart);
        if (nIndex < 0) {
            goto Done;
        }

        nIndexEnd = csNewCmdLine.Find(_T('%'), nIndex + 1);
        if (nIndexEnd < 0) {
            goto Done;
        }

        //
        // we matched a token, see whether it's something we're interested in
        //
        csToken = csNewCmdLine.Mid(nIndex + 1, nIndexEnd - nIndex - 1);
        if (0 == csToken.CompareNoCase(_T("DBINFO"))) {

            csToken.Format(_T("-d%ls -t0x%lx"), (LPCTSTR)GetGUID(guidDB), tiShimRef);

            //
            // replace the token with csToken
            //
            csNewCmdLine.Delete(nIndex, nIndexEnd - nIndex + 1);
            csNewCmdLine.Insert(nIndex, csToken);

            //
            // adjust our position for scanning
            //
            nIndexEnd = nIndex + csToken.GetLength() - 1; // one char before the end of this token
        }

        nIndexStart = nIndexEnd + 1;
    }


Done:

    return csNewCmdLine;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\globals.h ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    globals.h
//
// History: 17-Nov-00   markder     Created.
//
// Desc:    This file contains extern declarations of all global variables.
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef __GLOBALS_H__
#define __GLOBALS_H__

class SdbDatabase;

extern BOOL    g_bQuiet;
extern BOOL    g_bStrict;

extern CStringArray g_rgErrors;

BOOL        ReadDatabase(SdbInputFile* pInputFile, SdbDatabase* pDatabase);
BOOL        WriteDatabase(SdbOutputFile* pOutputFile, SdbDatabase* pDatabase);

BOOL        StringToMask(LPDWORD pdwMask, LPCTSTR lpszVal);
DWORD       StringToDword(CString cs);
ULONG       StringToULong(LPCTSTR lpszVal);
ULONGLONG   StringToQword(CString cs);
BOOL        VersionToQword(LPCTSTR lpszVersion, ULONGLONG* pullRet);
BOOL        VersionQwordToString(
                OUT CString&   rString,
                ULONGLONG      ullVersion
                );

BOOL        MakeUTCTime(CString& cs, time_t* pt);
CString     TrimParagraph(CString csInput);
VOID        ReplaceStringNoCase(CString& strText, LPCTSTR lpszFindThis, LPCTSTR lpszReplaceWithThis);
VOID        ExpandEnvStrings(CString* pcs);
CString     MakeFullPath(CString cs);
DWORD       GetBytesFromString(CString csBytes, BYTE* pBuffer, DWORD dwBufferSize);
DWORD       GetByteStringSize(CString csBytes);

typedef DWORD (*PFNGETSTRINGMASK)(LPCTSTR szOSSKUType);

DWORD       GetOSSKUType(LPCTSTR szOSSKUType);
DWORD       GetOSPlatform(LPCTSTR szOSPlatform);

DWORD       GetRuntimePlatformType(LPCTSTR szPlatformType);
DWORD       GetFilter(LPCTSTR szFilter);
CString     GetGUID(REFGUID guid);

BOOL        DecodeString(LPCTSTR pszStr, LPDWORD pdwMask, PFNGETSTRINGMASK pfnGetStringMask);

BOOL        DecodeRuntimePlatformString(LPCTSTR pszPlatform, LPDWORD pdwRuntimePlatform);
DWORD       DecodeOutputFlags(CString csFlags);
BOOL        FilterOSVersion(DOUBLE flOSVersion, CString csOSVersionSpec, LPDWORD lpdwSPMask);
BOOL        ParseLanguageID(LPCTSTR pszLanguage, DWORD* pdwLanguageID);
BOOL        ParseLanguagesString(CString csLanguages, CStringArray* prgLanguages);
CString     ProcessShimCmdLine(CString& csCommandLine, GUID& guidDB, TAGID tiShimRef);


SdbOutputType GetOutputType(LPCTSTR szOutputType);

BOOL        ReadName( IXMLDOMNode* pNode, CString* pcsName);
BOOL        ReadLangID(IXMLDOMNode* pNode, SdbDatabase* pDB, CString* pcsLangID);

void _cdecl Print(LPCTSTR pszFmt, ...);
void _cdecl PrintError(LPCTSTR pszFmt, ...);
void        PrintErrorStack();


#endif // __GLOBALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\ntcompat.h ===
///////////////////////////////////////////////////////////////////////////////
//
// File:    ntcompat.h
//
// History: 27-Mar-01   markder     Created.
//
// Desc:    This file contains all code needed to create ntcompat.inx
//          additions.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __NTCOMPAT_H__
#define __NTCOMPAT_H__

BOOL NtCompatWriteInfAdditions(
    SdbOutputFile* pOutputFile,
    SdbDatabase* pDB);

BOOL NtCompatWriteMessageInf(
    SdbOutputFile* pOutputFile,
    SdbDatabase* pDB);


#endif // __NTCOMPAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\mig.cpp ===
//depot/private/Lab06_DEV/Windows/AppCompat/ShimDBC/mig.cpp#1 - branch change 8778 (text)
////////////////////////////////////////////////////////////////////////////////////
//
// File:    mig.cpp
//
// History: ??-Jul-00   vadimb      Added Migdb logic
//
//
////////////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "xml.h"
#include "mig.h"
#include "make.h"
#include "typeinfo.h"
#include "fileio.h"

//
// Max length of a migdb.inf string entry
//
#define MAX_INF_STRING_LENGTH 255

//
// from read.cpp - converts module type to a string (which is static)
//
LPCTSTR ModuleTypeIndicatorToStr(DWORD ModuleType);


//
// Mig tags support -- translation table
//
ATTRLISTENTRY g_rgMigDBAttributes[] = {
    MIGDB_ENTRY2(COMPANYNAME,      COMPANY_NAME,         COMPANYNAME    ),
    MIGDB_ENTRY2(FILEDESCRIPTION,  FILE_DESCRIPTION,     FILEDESCRIPTION),
    MIGDB_ENTRY2(FILEVERSION,      FILE_VERSION,         FILEVERSION    ),
    MIGDB_ENTRY2(INTERNALNAME,     INTERNAL_NAME,        INTERNALNAME   ),
    MIGDB_ENTRY2(LEGALCOPYRIGHT,   LEGAL_COPYRIGHT,      LEGALCOPYRIGHT ),
    MIGDB_ENTRY2(ORIGINALFILENAME, ORIGINAL_FILENAME,    ORIGINALFILENAME),
    MIGDB_ENTRY2(PRODUCTNAME,      PRODUCT_NAME,         PRODUCTNAME    ),
    MIGDB_ENTRY2(PRODUCTVERSION,   PRODUCT_VERSION,      PRODUCTVERSION ),
    MIGDB_ENTRY2(FILESIZE,         SIZE,                 FILESIZE       ),
    MIGDB_ENTRY4(ISMSBINARY),
    MIGDB_ENTRY4(ISWIN9XBINARY),
    MIGDB_ENTRY4(INWINDIR),
    MIGDB_ENTRY4(INCATDIR),
    MIGDB_ENTRY4(INHLPDIR),
    MIGDB_ENTRY4(INSYSDIR),
    MIGDB_ENTRY4(INPROGRAMFILES),
    MIGDB_ENTRY4(ISNOTSYSROOT),
    MIGDB_ENTRY (CHECKSUM),
    MIGDB_ENTRY2(EXETYPE,          MODULE_TYPE,          EXETYPE           ),
    MIGDB_ENTRY5(DESCRIPTION,      16BIT_DESCRIPTION,    S16BITDESCRIPTION ),
    MIGDB_ENTRY4(INPARENTDIR),
    MIGDB_ENTRY4(INROOTDIR),
    MIGDB_ENTRY4(PNPID),
    MIGDB_ENTRY4(HLPTITLE),
    MIGDB_ENTRY4(ISWIN98),
    MIGDB_ENTRY4(HASVERSION),
//    MIGDB_ENTRY (REQFILE),
    MIGDB_ENTRY2(BINFILEVER,       BIN_FILE_VERSION,     BINFILEVER     ),
    MIGDB_ENTRY2(BINPRODUCTVER,    BIN_PRODUCT_VERSION,  BINPRODUCTVER  ),
    MIGDB_ENTRY5(FILEDATEHI,       VERFILEDATEHI,        FILEDATEHI),
    MIGDB_ENTRY5(FILEDATELO,       VERFILEDATELO,        FILEDATELO),
    MIGDB_ENTRY2(FILEVEROS,        VERFILEOS,            FILEVEROS      ),
    MIGDB_ENTRY2(FILEVERTYPE,      VERFILETYPE,          FILEVERTYPE    ),
    MIGDB_ENTRY4(FC),
    MIGDB_ENTRY2(UPTOBINPRODUCTVER,UPTO_BIN_PRODUCT_VERSION,UPTOBINPRODUCTVER),
    MIGDB_ENTRY2(UPTOBINFILEVER,UPTO_BIN_FILE_VERSION,UPTOBINFILEVER),
    MIGDB_ENTRY4(SECTIONKEY),
    MIGDB_ENTRY2(REGKEYPRESENT,    REGISTRY_ENTRY,       REGKEYPRESENT),
    MIGDB_ENTRY4(ATLEASTWIN98),
//    MIGDB_ENTRY (ARG)
};

TCHAR g_szArg[]     = _T("ARG");
TCHAR g_szReqFile[] = _T("REQFILE");


//
// report MigDB exception
// this is our mechanism for passing errors around
//

void __cdecl MigThrowException(
    LPCTSTR lpszFormat, ...
    )
{
    va_list arglist;
    CString csError;
    int nSize = 1024;
    LPTSTR lpszBuffer;

    va_start(arglist, lpszFormat);

    try {
        lpszBuffer = csError.GetBuffer(nSize);
        StringCchVPrintf(lpszBuffer, nSize, lpszFormat, arglist);
        csError.ReleaseBuffer();
    } catch(CMemoryException* pMemoryException) {
        SDBERROR(_T("Memory allocation error while trying to report an error\n"));
        pMemoryException->Delete();
    }

    // now we throw
    throw new CMigDBException(csError);

}


//
// Given an XML attribute mask, produce equivalent Migdb attribute type
//

MIGATTRTYPE GetInfTagByXMLAttrType(
        IN DWORD dwXMLAttrType
        )
{
    MIGATTRTYPE MigAttrType = NONE;
    int i;

    for (i = 0; i < sizeof(g_rgMigDBAttributes)/sizeof(g_rgMigDBAttributes[0]); ++i) {
        if (g_rgMigDBAttributes[i].XMLAttrType == dwXMLAttrType) {
            MigAttrType = g_rgMigDBAttributes[i].MigAttrType;
            break;
        }
    }

    return MigAttrType;
}

//
// make string nice and flat, with no extra spaces in-between
//
//

LPCTSTR g_pszDelim = _T(" \t\n\r");

CString FlattenString(LPCTSTR lpszStr)
{
    TCHAR*  pchStart = (TCHAR*)lpszStr;
    TCHAR*  pch;
    CString csResult;
    BOOL    bSpace = FALSE;

    while (*pchStart) {
        //
        // skip leading spaces or other trash
        //
        pchStart += _tcsspn(pchStart, g_pszDelim);
        if (*pchStart == _T('\0')) {
            // tough bananas - we got what we've got, exit now
            break;
        }

        // search for the end-of-line
        pch = _tcspbrk(pchStart, g_pszDelim);
        if (pch == NULL) {
            // we are done, no more nasty characters
            // append and exit
            //
            if (bSpace) {
                csResult += _T(' ');
            }
            csResult += pchStart;
            break;
        }


        // add everything -- up until this \n
        if (bSpace) {
            csResult += _T(' ');
        }
        csResult += CString(pchStart, (int)(pch - pchStart));
        bSpace = TRUE; // we have just removed a portion of the string containing \n

        pchStart = pch; // point to the \n
    }

    //
    // Make quotes (") into double quotes ("") so that
    // it is legal INF
    //
    ReplaceStringNoCase(csResult, _T("\""), _T("\"\""));

    return csResult;
}

VOID FilterStringNonAlnum(
    CString& csTarget
    )
{
    TCHAR ch;
    INT   i;

    for (i = 0; i < csTarget.GetLength(); i++) {
        ch = csTarget.GetAt(i);
        if (!((ch >= 'a' && ch <= 'z') ||
              (ch >= 'A' && ch <= 'Z') ||
              (ch >= '0' && ch <= '9'))) {
            csTarget.SetAt(i, _T('_'));
        }
    }

}


////////////////////////////////////////////////////////////////////////////////////////////
//
//  Dumping .inf data support
//

CString MigApp::dump(void)
{
    CString cs;
    BOOL bInline;
    INT i;
    MigAttribute* pAttr;

    // we can't do "inline" sections if we also have "ARGS"
    bInline = (0 == m_rgArgs.GetSize());

    cs = m_pSection->dump(m_csDescription.IsEmpty() ? NULL : (LPCTSTR)m_csDescription, NULL, FALSE, bInline);
    if (m_csDescription.IsEmpty() && !bInline) {
        cs += _T(",");
    }

    if (!bInline) {
        for (i = 0; i < m_rgArgs.GetSize(); ++i) {
            pAttr = (MigAttribute*)m_rgArgs.GetAt(i);
            cs += (cs.IsEmpty()? _T(""): _T(", ")) + pAttr->dump();
        }
    }
    return cs;
}


// we dump info into an array of strings, single-line entries are returned

// The first kind of return is "inline" --
// all the supplemental info is shoved into the rgOut
// for example, the return might be a reference to the section
// section's header and body are placed into rgOut

// ELIMINATE duplicate section names (reqfile!)
// optimize output - single "and" replaced with straight
// if a section is generated and placed as a single-line entry, promote the contents
// to upper level


CString MigSection::dump(LPCTSTR lpszDescription, int* pIndexContents, BOOL bNoHeader, BOOL bInline)
{
    SdbArrayElement* p;
    MigEntry* pEntry;
    MigSection* pSection;
    int indexContents = -1;
    int nEntries;

    const type_info& tiEntry = typeid(MigEntry);    // cache type id info
    const type_info& tiSection = typeid(MigSection);
    int i;

    CString cs;         // inline return
    CString csContents; // contents of supplemental section information
    CString csSect;
    CString csHeader;
    CString csDescription(lpszDescription);

    // place inline name and description
    // we may need to enclose this into quotes

    cs = m_csName;
    if (!csDescription.IsEmpty()) {
        if (csDescription.Left(1) == _T("%") &&
            csDescription.Right(1) == _T("%")) {
            cs += _T(", ") + csDescription;
        } else {
            cs += _T(", \"") + csDescription + _T("\"");
        }
    }

    // if our section is a single-entry
    // we dump this depending on the calling

    // special case -- single file (and/or, matters not)
    if (1 == m_rgEntries.GetSize() && m_bTopLevel && bInline) {

        // this single line goes "inline" only if we are called from within
        // other section

        // dump the entry if it's an entry
        p = (SdbArrayElement*)m_rgEntries.GetAt(0);
        if (typeid(*p) == tiEntry) {
            pEntry = (MigEntry*)p;

            if (m_bTopLevel && csDescription.IsEmpty()) { // if the description was not added earlier and top-level...
                cs += _T(",");
            }
            cs += _T(", ") + pEntry->dump();
            return cs;
        }
    }


    // first deal with sections...
    switch(m_Operation) {
    case MIGOP_OR:
        // grab just one section in all if more than one entry
        // IF we're the only entry -- but we need to have the right entry
        //
        if (!bNoHeader) {  // ONLY valid for OR sections
            csContents.Format(_T("[%s]\n"), (LPCTSTR)m_csName);
        }

        for (i = 0; i < m_rgEntries.GetSize(); ++i) {
            p = (SdbArrayElement*)m_rgEntries.GetAt(i);
            const type_info& tiPtr = typeid(*p);
            if (tiPtr == tiEntry) {
                pEntry = (MigEntry*)p;
                csContents += pEntry->dump() + _T("\n");
            }
            else if (tiPtr == tiSection) {
                pSection = (MigSection*)p;
                csContents += pSection->dump() + _T("\n");
            }
            else {
                // if we are here -- something is seriously wrong
                // _tprintf(_T("Error - bad class information\n"));
                MigThrowException(_T("Bad Entry detected in section \"%s\"\n"), (LPCTSTR)m_csName);
                break;
            }
        }
        break;


    case MIGOP_AND:
        // and for this entry ...

        // optimization:
        // if we're single-entry, retrieve the contents of the child section
        // and put it right in
        nEntries = m_rgEntries.GetSize();
        for (i = 0; i < nEntries; ++i) {
            p = (SdbArrayElement*)m_rgEntries.GetAt(i);

            if (nEntries > 1) {
                ++m_nEntry;
                csSect.Format(_T("[%s.%d]\n"), (LPCTSTR)m_csName, m_nEntry);
            }
            else {
                csSect.Format(_T("[%s]\n"), (LPCTSTR)m_csName);
            }
            csContents += csSect;

            const type_info& tiPtr = typeid(*p);
            if (tiPtr == tiEntry) {        // this is an entry, dump it into the section body
                pEntry = (MigEntry*)p;

                // numbered entry please...
                csContents += pEntry->dump() + _T("\n");

            }
            else if (tiPtr == tiSection) {  // this is a section, dump it, get the ref into the section body
                pSection = (MigSection*)p;

                // optimization:
                if (pSection->m_Operation == MIGOP_OR) { // sub is an "OR" -- we need not have a ref
                    int index;
                    CString csSingle;

                    // dump all the entries right here
                    csSingle = pSection->dump(NULL, &index, TRUE);
                    if (index >= 0) {
                        csContents += m_pMigDB->m_rgOut.GetAt(index) + _T("\n");
                        m_pMigDB->m_rgOut.RemoveAt(index);
                    }
                    else {
                        csContents += csSingle;
                    }

                }
                else {
                    csContents += pSection->dump(NULL) + _T("\n");
                }
            }
            else {
                MigThrowException(_T("Internal Error: bad migration object\n"));
                break;
            }
        }
        break;

    }

    if (!csContents.IsEmpty()) {
        indexContents = m_pMigDB->m_rgOut.Add(csContents);
    }
    if (NULL != pIndexContents) {
        *pIndexContents = indexContents;
    }

    return cs;
}

CString MigEntry::FormatName(
    VOID
    )
{
    INT i;
    TCHAR ch;
    BOOL bQuoteStr = FALSE;
    CString csName;

    bQuoteStr = (m_csName.GetLength() > 12); // 8.3 outright

    for (i = 0; i < m_csName.GetLength() && !bQuoteStr; ++i) {
        ch = m_csName.GetAt(i);
        bQuoteStr = _istspace(ch) || (!_istalnum(ch) && _T('.') != ch);
    }

    if (!bQuoteStr) { // hmmm check filename and ext part
        i = m_csName.Find(_T('.'));
        if (i < 0) {
            bQuoteStr = (m_csName.GetLength() > 8);
        }
        else {
            // check for the second dot
            bQuoteStr = (m_csName.Find(_T('.'), i+1) >= 0);
            if (!bQuoteStr) {
                // check for the ext length
                bQuoteStr = (m_csName.Mid(i).GetLength() > 4); // with .abc
            }
        }
    }

    if (!bQuoteStr) {
        return m_csName;
    }

    // else

    csName.Format(_T("\"%s\""), m_csName);
    return csName;
}


CString MigEntry::dump(void)
{
    INT i;
    MigAttribute* pAttr;
    CString cs;
    CString csName;
    ULONG ulResult;

    // _tprintf(_T("Entry: name=\"%s\"\n"), (LPCTSTR)m_csName);
    // check whether we need to enclose this into quotes
    // to do such a check we need to:
    // check for non-ascii stuff...

    // parser has put all the ARG attributes in the beginning of the array

    // put any "arg" attributes before the exe name
    for (i = 0; i < m_rgAttrs.GetSize(); ++i) {
        pAttr = (MigAttribute*)m_rgAttrs.GetAt(i);
        if (ARG != pAttr->m_type) {
            break;
        }

        cs += (cs.IsEmpty()? _T(""): _T(", ")) + pAttr->dump();
    }


    cs += (cs.IsEmpty()? _T(""): _T(", ")) + FormatName();

    for (;i < m_rgAttrs.GetSize(); ++i) {
        pAttr = (MigAttribute*)m_rgAttrs.GetAt(i);
        cs += (cs.IsEmpty()? _T(""): _T(", ")) + pAttr->dump();
    }

    return cs;
}


CString MigAttribute::dump(void)
{

    CString cs;
    CString csTemp;

    switch(m_type) {
    // note -- none of the attributes below are supported
    case ISMSBINARY:
    case ISWIN9XBINARY:
    case INWINDIR:
    case INCATDIR:
    case INHLPDIR:
    case INSYSDIR:
    case INPROGRAMFILES:
    case ISNOTSYSROOT:
    case INROOTDIR:
    case ISWIN98:
    case HASVERSION:
    case ATLEASTWIN98:
        cs.Format(_T("%s%s"), m_bNot ? _T("!") : _T(""), (LPCTSTR)m_csName);
        break;

    case CHECKSUM:
    case FILESIZE:
        // under old code the following two values had been strings
    case FILEDATEHI:
    case FILEDATELO:
        cs.Format(_T("%s%s(0x%.8lX)"), m_bNot?_T("!"):_T(""), (LPCTSTR)m_csName, m_dwValue);
        break;

    case BINFILEVER:
    case BINPRODUCTVER:
    case UPTOBINFILEVER:
    case UPTOBINPRODUCTVER:
        // version, ull
        VersionQwordToString(csTemp, m_ullValue);
        cs.Format(_T("%s%s(%s)"), m_bNot? _T("!"):_T(""), (LPCTSTR)m_csName, (LPCTSTR)csTemp);
        break;

    case EXETYPE:
        // this is dword-encoded format that really is a string, convert
        //
        cs.Format(_T("%s%s(\"%s\")"), m_bNot ? _T("!") : _T(""), (LPCTSTR)m_csName, ModuleTypeIndicatorToStr(m_dwValue));
        break;

    // these two attributes are not supported either
    case ARG:
    case REQFILE:

        if (m_pSection) {
            m_pSection->dump();
        }
        // fall through

    default:
        cs.Format(_T("%s%s(\"%s\")"), m_bNot ? _T("!") : _T(""), (LPCTSTR)m_csName, (LPCTSTR)m_csValue);
        break;
    }

    return cs;
}


/*++
    Used to be a nice statistics-spewing function


VOID DumpMigDBStats(ShimDatabase* pDatabase)
{
    POSITION pos = pDatabase->m_mapMigApp.GetStartPosition();
    ShimArray* prgApp;
    CString csSection;
    DWORD dwApps = 0;
    INT i;

    Print( _T("Sections compiled: %d\n\n"), pDatabase->m_mapMigApp.GetCount());
    while (pos) {
        pDatabase->m_mapMigApp.GetNextAssoc(pos, csSection, (LPVOID&)prgApp);

        Print(_T("Section [%36s]: %8ld apps\n"), (LPCTSTR)csSection, prgApp->GetSize());
        dwApps += prgApp->GetSize();
    }
    Print( _T("--------\n"));
    Print( _T("Total   %38s: %8ld entries\n"), "", dwApps);
    Print( _T("\n"));
    if (gfVerbose) {
        Print(_T("APPS\n"));

        pos = pDatabase->m_mapMigApp.GetStartPosition();
        while (pos) {
            pDatabase->m_mapMigApp.GetNextAssoc(pos, csSection, (LPVOID&)prgApp);

            Print(_T("Section [%36s]: %8ld apps\n"), (LPCTSTR)csSection, prgApp->GetSize());
            Print(_T("-------------------------------------------------------------\n"));
            for (i = 0; i < prgApp->GetSize(); ++i) {
                MigApp* pApp = (MigApp*)prgApp->GetAt(i);
                Print(_T("%s\n"), (LPCTSTR)pApp->m_csName);
            }
            Print(_T("\n"));
        }

    }

}

--*/

BOOL MigDatabase::DumpMigDBStrings(
    LPCTSTR lpszFilename
    )
{
    CString csOut;
    POSITION pos;
    CANSITextFile OutFile(
        lpszFilename,
        m_pAppHelpDatabase->m_pCurrentMakefile->GetLangMap(m_pAppHelpDatabase->m_pCurrentOutputFile->m_csLangID)->m_dwCodePage,
        CFile::modeCreate|CFile::modeReadWrite|CFile::shareDenyWrite);
    CString csStringID;
    CString csStringContent;
    CString csCompoundString, csCompoundStringPart;
    long nCursor = 0;

    //
    // write header (needed for postbuild!)
    //
    OutFile.WriteString(_T(";\n; AppCompat additions start here\n;\n; ___APPCOMPAT_MIG_ENTRIES___\n;\n"));

    //
    // write out the strings section
    //
    pos = m_mapStringsOut.GetStartPosition();
    while (pos) {
        m_mapStringsOut.GetNextAssoc(pos, csStringID, csStringContent);

        if (csStringContent.GetLength() > MAX_INF_STRING_LENGTH) {
            nCursor = 0;
            csCompoundString.Empty();
            while (nCursor * MAX_INF_STRING_LENGTH < csStringContent.GetLength()) {
                csOut.Format(_T("%s.%d = \"%s\"\n"),
                    (LPCTSTR)csStringID,
                    nCursor + 1,
                    (LPCTSTR)csStringContent.Mid(nCursor * MAX_INF_STRING_LENGTH, MAX_INF_STRING_LENGTH));

                OutFile.WriteString(csOut);

                csCompoundStringPart.Format(_T(" %%%s.%d%%"), csStringID, nCursor + 1);
                csCompoundString += csCompoundStringPart;
                nCursor++;
            }
        } else {
            csOut.Format(_T("%s = \"%s\"\n"), (LPCTSTR)csStringID, (LPCTSTR)csStringContent);
            OutFile.WriteString(csOut);
        }
    }

    return TRUE;
}

BOOL MigDatabase::DumpMigDBInf(
    LPCTSTR lpszFilename
    )
{
    CString csSection;
    CString csOut;
    SdbArray<SdbArrayElement>* prgApp;
    INT      i;
    MigApp*  pApp;
    BOOL     bSuccess = FALSE;
    POSITION pos;

    CStringArray rgShowInSimplifiedView;

    // clear out help array
    m_rgOut.RemoveAll();

    CANSITextFile OutFile(
        lpszFilename,
        m_pAppHelpDatabase->m_pCurrentMakefile->GetLangMap(m_pAppHelpDatabase->m_pCurrentOutputFile->m_csLangID)->m_dwCodePage,
        CFile::modeCreate|CFile::modeReadWrite|CFile::shareDenyWrite);

    //
    // traverse sections...
    //
    pos = m_mapSections.GetStartPosition();
    while (pos) {
        m_mapSections.GetNextAssoc(pos, csSection, (LPVOID&)prgApp);
        csOut.Format(_T("[%s]\n"), (LPCTSTR)csSection);
        OutFile.WriteString(csOut);

        for (i = 0; i < prgApp->GetSize(); ++i) {
            pApp = (MigApp*)prgApp->GetAt(i);
            csOut.Format(_T("%s\n"), pApp->dump());

            if (pApp->m_bShowInSimplifiedView) {
                rgShowInSimplifiedView.Add(csOut);
            }

            OutFile.WriteString(csOut);
        }

        csOut.Format(_T("\n"));
        OutFile.WriteString(csOut);
    }

    //
    // Dump ShowInSimplifiedView section
    //
    OutFile.WriteString(_T("[ShowInSimplifiedView]\n"));
    for (i = 0; i < rgShowInSimplifiedView.GetSize(); i++) {
        OutFile.WriteString(rgShowInSimplifiedView[i]);
    }

    OutFile.WriteString(_T("\n"));

    for (i = 0; i < m_rgOut.GetSize(); ++i) {
        OutFile.WriteString(m_rgOut.GetAt(i));
    }

    bSuccess = TRUE;

    return bSuccess;
}

MigSection& MigSection::operator=(SdbMatchOperation& rMatchOp)
{
    MigEntry* pEntry;
    MigSection* pSection;
    int i;

    if (rMatchOp.m_Type == SDB_MATCH_ALL) {
        m_Operation = MIGOP_AND;
    } else if (rMatchOp.m_Type == SDB_MATCH_ANY) {
        m_Operation = MIGOP_OR;
    } else {
        MigThrowException(_T("Bad matching operation\n"));
    }

    // now translate the content
    for (i = 0; i < rMatchOp.m_rgMatchingFiles.GetSize(); ++i) {
        SdbMatchingFile* pMatchingFile = (SdbMatchingFile*)rMatchOp.m_rgMatchingFiles.GetAt(i);

        pEntry = new MigEntry(m_pMigDB);
        if (pEntry == NULL) {
            AfxThrowMemoryException();
        }

        *pEntry = *pMatchingFile;

        // add the entry in
        m_rgEntries.Add(pEntry, m_pDB);
    }

    for (i = 0; i < rMatchOp.m_rgSubMatchOps.GetSize(); ++i) {
        SdbMatchOperation* pMatchOp = (SdbMatchOperation*)rMatchOp.m_rgSubMatchOps.GetAt(i);

        pSection = new MigSection(m_pMigDB);

        if (pSection == NULL) {
            AfxThrowMemoryException();
        }

        //
        // format section's name
        //
        pSection->m_csName.Format(_T("%s_%lx"), (LPCTSTR)m_csName, i);

        *pSection = *pMatchOp;

        //
        // patch the name of the section
        //

        m_rgEntries.Add(pSection, m_pDB);
    }

    return *this;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Conversion code
//

MigApp& MigApp::operator=(
    SdbWin9xMigration& rMig
    )
{
    INT i;
    SdbMatchingFile* pMatchingFile;
    MigEntry*        pMigEntry;
    CString          csSectionName;
    CString          csID;
    BOOL             bSuccess;
    CString          csName;

    if (rMig.m_pApp == NULL) {
        MigThrowException(_T("Internal Compiler Error: Migration object should contain reference to the application"));
    }

    // name please

    csName = m_pMigDB->GetAppTitle(&rMig);

    m_csName = csName;

    ++m_pMigDB->m_dwExeCount;

    //
    // step one -- translate the general stuff
    // we will probably need

    m_pSection = new MigSection(m_pMigDB); //
    if (m_pSection == NULL) {
        AfxThrowMemoryException();
    }


    // our matching method is always AND (meaning all the files have to be present to produce a match
    // it is set when constructing the section object

    //
    //    m_csSection -- set here the section where this exe will go
    //    should the function below fail -- it will throw an exception
    //
    m_csSection = rMig.m_csSection; // copy the section over

    //
    // check whether we will have description
    m_csDescription = m_pMigDB->FormatDescriptionStringID(&rMig);

    //
    // Set the section's level
    //
    m_pSection->m_bTopLevel = TRUE;

    // the name of the section is the name of the app
    m_pSection->m_csName = csName;

    m_bShowInSimplifiedView = rMig.m_bShowInSimplifiedView;

    //
    // on to the assignment operation
    //
    *m_pSection = rMig.m_MatchOp; // simple assignment

    return *this;
}

MigEntry& MigEntry::operator=(
    SdbMatchingFile& rMatchingFile
    )
{
    INT i;
    MigAttribute* pAttr;

    //
    // this name may be '*' denoting the main exe -- in this case the name will be corrected
    // on the upper level, after this assignment operation completes
    //
    m_csName = rMatchingFile.m_csName;

    // inherit the database ptr
    m_pDB = rMatchingFile.m_pDB;

    // roll through the attributes now
    for (i = 0; i < sizeof(g_rgMigDBAttributes)/sizeof(g_rgMigDBAttributes[0]); ++i) {
        if (!g_rgMigDBAttributes[i].XMLAttrType) {
            continue;
        }

        // now check whether this attribute is present in matching file
        if (!(rMatchingFile.m_dwMask & g_rgMigDBAttributes[i].XMLAttrType)) {
            // attribute not present, keep on
            continue;
        }

        // this attribute is present, encode it
        pAttr = new MigAttribute(m_pMigDB);
        if (pAttr == NULL) {
            AfxThrowMemoryException();
        }

        pAttr->m_type   = g_rgMigDBAttributes[i].MigAttrType;
        pAttr->m_csName = g_rgMigDBAttributes[i].szOutputName ?
                                g_rgMigDBAttributes[i].szOutputName :
                                g_rgMigDBAttributes[i].szAttributeName;

        switch(g_rgMigDBAttributes[i].XMLAttrType) {
        case SDB_MATCHINGINFO_SIZE:
            pAttr->m_dwValue = rMatchingFile.m_dwSize;
            break;

        case SDB_MATCHINGINFO_CHECKSUM:
            pAttr->m_dwValue = rMatchingFile.m_dwChecksum;
            break;

        case SDB_MATCHINGINFO_COMPANY_NAME:
            pAttr->m_csValue = rMatchingFile.m_csCompanyName;
            break;

        case SDB_MATCHINGINFO_PRODUCT_NAME:
            pAttr->m_csValue = rMatchingFile.m_csProductName;
            break;

        case SDB_MATCHINGINFO_PRODUCT_VERSION:
            pAttr->m_csValue = rMatchingFile.m_csProductVersion;
            break;

        case SDB_MATCHINGINFO_FILE_DESCRIPTION:
            pAttr->m_csValue = rMatchingFile.m_csFileDescription;
            break;

        case SDB_MATCHINGINFO_BIN_FILE_VERSION:
            pAttr->m_ullValue = rMatchingFile.m_ullBinFileVersion;
            break;

        case SDB_MATCHINGINFO_BIN_PRODUCT_VERSION:
            pAttr->m_ullValue = rMatchingFile.m_ullBinProductVersion;
            break;

        case SDB_MATCHINGINFO_MODULE_TYPE:
            pAttr->m_dwValue = rMatchingFile.m_dwModuleType;
            break;

        case SDB_MATCHINGINFO_VERFILEDATEHI:
            pAttr->m_dwValue = rMatchingFile.m_dwFileDateMS;
            break;

        case SDB_MATCHINGINFO_VERFILEDATELO:
            pAttr->m_dwValue = rMatchingFile.m_dwFileDateLS;
            break;

        case SDB_MATCHINGINFO_VERFILEOS:
            pAttr->m_dwValue = rMatchingFile.m_dwFileOS;
            break;

        case SDB_MATCHINGINFO_VERFILETYPE:
            pAttr->m_dwValue = rMatchingFile.m_dwFileType;
            break;

        case SDB_MATCHINGINFO_PE_CHECKSUM:
            pAttr->m_ulValue = rMatchingFile.m_ulPECheckSum;
            break;

        case SDB_MATCHINGINFO_FILE_VERSION:
            pAttr->m_csValue = rMatchingFile.m_csFileVersion;
            break;

        case SDB_MATCHINGINFO_ORIGINAL_FILENAME:
            pAttr->m_csValue = rMatchingFile.m_csOriginalFileName;
            break;

        case SDB_MATCHINGINFO_INTERNAL_NAME:
            pAttr->m_csValue = rMatchingFile.m_csInternalName;
            break;

        case SDB_MATCHINGINFO_LEGAL_COPYRIGHT:
            pAttr->m_csValue = rMatchingFile.m_csLegalCopyright;
            break;

        case SDB_MATCHINGINFO_UPTO_BIN_PRODUCT_VERSION:
            pAttr->m_ullValue = rMatchingFile.m_ullUpToBinProductVersion;
            break;

        case SDB_MATCHINGINFO_UPTO_BIN_FILE_VERSION:
            pAttr->m_ullValue = rMatchingFile.m_ullUpToBinFileVersion;
            break;

        case SDB_MATCHINGINFO_16BIT_DESCRIPTION:
            pAttr->m_csValue = rMatchingFile.m_cs16BitDescription;
            break;

        case SDB_MATCHINGINFO_REGISTRY_ENTRY:
            pAttr->m_csValue = rMatchingFile.m_csRegistryEntry;
            break;


//
//      case SDB_MATCHINGINFO_PREVOSMAJORVERSION
//      case SDB_MATCHINGINFO_PREVOSMINORVERSION
//      case SDB_MATCHINGINFO_PREVOSPLATFORMID
//      case SDB_MATCHINGINFO_PREVOSBUILDNO
//      there is no such attribute. it will simply be ignored
//

        }

        m_rgAttrs.Add(pAttr, NULL);

    }


    return *this;
}

TCHAR g_szIncompatible[] = _T("Incompatible");
TCHAR g_szReinstall[]    = _T("Reinstall");

CString MigDatabase::GetAppTitle(
    SdbWin9xMigration* pAppMig
    )
{
    // part one -- get the application's title
    BOOL    bSuccess;
    CString csID;
    CString csAppTitle;
    LPTSTR pBuffer = csID.GetBuffer(64); // a little more than you need for guid
    if (pBuffer == NULL) {
        AfxThrowMemoryException();
    }

    bSuccess = StringFromGUID(pBuffer, &pAppMig->m_ID);
    csID.ReleaseBuffer();
    if (!bSuccess) {
        MigThrowException(_T("Failed trying to convert GUID to string for entry \"%s\"\n"),
                          (LPCTSTR)pAppMig->m_pApp->m_csName);
    }

    //
    // name of this particular exe (we don't care for it -- it won't be reflected anywhere)
    //
    csAppTitle.Format(_T("%s_%s"), (LPCTSTR)pAppMig->m_pApp->m_csName, (LPCTSTR)csID);
    csAppTitle.Remove(_T('{'));
    csAppTitle.Remove(_T('}'));

    // weed out the rest of non-alnum characters

    FilterStringNonAlnum(csAppTitle);

    return csAppTitle;


}


CString MigDatabase::GetDescriptionStringID(
    SdbWin9xMigration* pAppMig
    )
{
    CString csDescriptionID;

    // part one -- get the application's title
    BOOL    bSuccess;
    CString csID;
    CString csAppTitle;

    if (pAppMig->m_csMessage.IsEmpty()) {
        return csID; // empty string
    }

    LPTSTR pBuffer = csID.GetBuffer(64); // a little more than you need for guid
    if (pBuffer == NULL) {
        AfxThrowMemoryException();
    }

    bSuccess = StringFromGUID(pBuffer, &pAppMig->m_ID);
    csID.ReleaseBuffer();
    if (!bSuccess) {
        MigThrowException(_T("Failed trying to convert GUID to string for entry \"%s\"\n"),
                          (LPCTSTR)pAppMig->m_pApp->m_csName);
    }

    //
    // name of this particular exe (we don't care for it -- it won't be reflected anywhere)
    //

    csDescriptionID.Format(_T("__Message_%s_%s"), (LPCTSTR)pAppMig->m_csMessage, (LPCTSTR)csID);
    csDescriptionID.Remove(_T('{'));
    csDescriptionID.Remove(_T('}'));

    // weed out the rest of non-alnum characters

    FilterStringNonAlnum(csDescriptionID);

    return csDescriptionID;


}

CString MigDatabase::FormatDescriptionStringID(
    SdbWin9xMigration* pMigApp
    )
{
    CString csDescriptionID;
    CString csRet;
    CString csCompoundStringPart;
    CString csStringContent;
    long nCursor;

    //
    // get the string
    // basis is the application's name

    csDescriptionID = GetDescriptionStringID(pMigApp);
    if (csDescriptionID.IsEmpty()) {
        return csDescriptionID;
    }

    csStringContent = GetDescriptionString(pMigApp);

    if (csStringContent.GetLength() > MAX_INF_STRING_LENGTH) {
        nCursor = 0;
        while (nCursor * MAX_INF_STRING_LENGTH < csStringContent.GetLength()) {
            csCompoundStringPart.Format(_T("%%%s.%d%%"), csDescriptionID, nCursor + 1);
            csRet += csCompoundStringPart;
            nCursor++;
        }
    } else {
        csRet.Format(_T("%%%s%%"), csDescriptionID);
    }

    //
    // return id
    //
    return csRet;

}

CString MigDatabase::GetDescriptionString(
    SdbWin9xMigration* pMigApp
    )
{
    CString csDescription;

    SdbMessage*  pMessage;
    SdbDatabase* pMessageDB;

    CString csDetails;

    BOOL   bSuccess;

    //
    // get apphelp database
    //
    pMessageDB = m_pMessageDatabase;
    if (pMessageDB == NULL) {
        MigThrowException(_T("Internal error: cannot produce description without apphelp database\n"));
    }

    if (pMigApp->m_csMessage.IsEmpty()) {
        return csDescription;
    }

    //
    // lookup this app in the apphelp db
    //
    pMessage = (SdbMessage *)pMessageDB->m_rgMessages.LookupName(pMigApp->m_csMessage, pMessageDB->m_pCurrentMakefile->m_csLangID);
    if (pMessage == NULL) {
        MigThrowException(_T("Exe \"%s\" has bad apphelp reference object\n"), (LPCTSTR)pMigApp->m_csMessage);
    }

    bSuccess = pMessageDB->ConstructMigrationMessage(pMigApp,
                                                     pMessage,
                                                     &csDetails);
    if (!bSuccess) {
        MigThrowException(_T("Failed to construct Migration message %s for \"%s\"\n"),
                          (LPCTSTR)pMigApp->m_pApp->m_csName, pMigApp->m_csMessage);
    }

    //
    // 2. now that we have csDetails, flatten it
    //

    csDescription = FlattenString(csDetails);

    return csDescription;
}

BOOL MigDatabase::AddApp(
    MigApp*       pApp
    )
{
    SdbArray<MigApp>* prgApp;
    CString           csSection;

    csSection = pApp->m_csSection;

    csSection.MakeUpper();

    if (m_mapSections.Lookup(csSection, (LPVOID&)prgApp)) {
        if (g_bStrict && NULL != prgApp->LookupName(pApp->m_csName)) {

            //
            // can't do that -- duplicate name
            //

            MigThrowException(_T("Duplicate application name found for app \"%s\"\n"), (LPCTSTR)pApp->m_csName);
        }

        prgApp->Add(pApp, m_pFixDatabase, FALSE);
    } else {
        prgApp = new SdbArray<MigApp>;
        if (prgApp == NULL) {
            AfxThrowMemoryException();
        }

        prgApp->Add(pApp, m_pFixDatabase, FALSE);
        m_mapSections.SetAt(csSection, (LPVOID&)prgApp);
    }

    return TRUE;
}


BOOL MigDatabase::Populate(
    VOID
    )
{
    //
    // roll through all the outer objects (exes and generate migdb objects)
    //

    int i, iMig;
    SdbExe* pExe;
    MigApp* pMigApp;
    SdbDatabase* pFixDatabase = m_pFixDatabase;
    SdbApp* pApp;
    SdbWin9xMigration* pMigration;

    if (pFixDatabase == NULL) {
        MigThrowException(_T("Cannot produce migdb entries without fix db\n"));
    }

    for (i = 0; i < pFixDatabase->m_rgApps.GetSize(); i++) {
        //
        // for each app check whether it has migration info
        //
        pApp = (SdbApp*)pFixDatabase->m_rgApps.GetAt(i);

        for (iMig = 0; iMig < pApp->m_rgWin9xMigEntries.GetSize(); ++iMig) {
            pMigration = (SdbWin9xMigration*)pApp->m_rgWin9xMigEntries.GetAt(iMig);

            pMigApp = new MigApp(this);
            if (pMigApp == NULL) {
                AfxThrowMemoryException();
            }

            // we have a brand new migration object, assign it
            *pMigApp = *pMigration;

            // once that is done, pMigApp->m_csSection has the destination of it
            // this function will throw an exception if an error occurs
            AddApp(pMigApp);

        }

    }

    return TRUE;

}

BOOL MigDatabase::PopulateStrings(
    VOID
    )
{
    SdbWin9xMigration* pMigration;
    SdbApp*            pApp;
    CString            csDescriptionID;
    CString            csDescription;
    CString            csAppTitleID;
    CString            csAppTitle;
    CString            csTemp;
    int                i, iMig;

    //
    // get all the strings
    //
    for (i = 0; i < m_pAppHelpDatabase->m_rgApps.GetSize(); i++) {
        //
        // for each app check whether it has migration info
        //
        pApp = (SdbApp*)m_pAppHelpDatabase->m_rgApps.GetAt(i);

        for (iMig = 0; iMig < pApp->m_rgWin9xMigEntries.GetSize(); ++iMig) {
            pMigration = (SdbWin9xMigration*)pApp->m_rgWin9xMigEntries.GetAt(iMig);


            //
            // Set up title strings
            //
            csAppTitleID = GetAppTitle(pMigration);
            csAppTitle   = pMigration->m_pApp->GetLocalizedAppName();

            if (m_mapStringsOut.Lookup(csAppTitleID, csTemp)) {
                MigThrowException(_T("Duplicate String ID \"%s\" found for entry \"%s\"\n"),
                                  csAppTitleID,
                                  pMigration->m_pApp->m_csName);
            }

            m_mapStringsOut.SetAt(csAppTitleID, csAppTitle);

            csDescription = GetDescriptionString(pMigration);
            csDescriptionID = GetDescriptionStringID(pMigration);

            if (csDescriptionID.IsEmpty()) { // we allow description to be empty
                continue;
            }

            if (m_mapStringsOut.Lookup(csDescriptionID, csTemp)) {
                MigThrowException(_T("Duplicate String ID \"%s\" found for entry \"%s\"\n"),
                                  csDescriptionID,
                                  pMigration->m_pApp->m_csName);
            }

            m_mapStringsOut.SetAt(csDescriptionID, csDescription);

        }
    }

    return TRUE;
}




////////////////////////////////////////////////////////////////////////////
//
// Top-level function
//
// if supplied: pAppHelpDatabase and pFixDatabase    ->> migapp.inx is produced
//              pAppHelpDatabase and pMessageDatabas ->> migapp.txt is produced
//
BOOL WriteMigDBFile(
    SdbDatabase* pFixDatabase,        // may be NULL
    SdbDatabase* pAppHelpDatabase, // always supplied
    SdbDatabase* pMessageDatabase,    // may be NULL
    LPCTSTR      lpszFileName         // always supplied
    )
{
    MigDatabase* pMigDatabase = NULL;
    BOOL bSuccess = FALSE;

    // construct migdatabase object and populate it

    try {

        // construct

        pMigDatabase = new MigDatabase;
        if (pMigDatabase == NULL) {
            AfxThrowMemoryException();
        }

        // init MigDatabase object
        //
        // [markder] Make them all the same so that
        // we can process messages/fixes at the same
        // time.
        //
        pMigDatabase->m_pFixDatabase     = pAppHelpDatabase;
        pMigDatabase->m_pAppHelpDatabase = pAppHelpDatabase;
        pMigDatabase->m_pMessageDatabase = pAppHelpDatabase;

        bSuccess = pMigDatabase->Populate();
        if (!bSuccess) {
            throw new CMigDBException(_T("Unknown error populating MIGDB additions."));
        }

        bSuccess = pMigDatabase->PopulateStrings();
        if (!bSuccess) {
            throw new CMigDBException(_T("Unknown error populating MIGDB additions."));
        }

        if (pFixDatabase != NULL) {

            //
            // produce migdb.inf
            //
            bSuccess = pMigDatabase->DumpMigDBInf(lpszFileName);

        } else { // dumping the strings

            bSuccess = pMigDatabase->DumpMigDBStrings(lpszFileName);

        }

        delete pMigDatabase;

        //
        // can only get here if we don't catch any exceptions
        //
        return bSuccess;

    } catch(CMigDBException* pMigdbException) {

        SDBERROR((LPCTSTR)pMigdbException->m_csError);
        pMigdbException->Delete();

    } catch(CFileException*  pFileException) {
        //
        // a little more tricky
        //
        CString csError;
        int     nSize = 1024;
        BOOL    bError;
        bError = pFileException->GetErrorMessage(csError.GetBuffer(nSize), nSize);
        csError.ReleaseBuffer();
        if (bError) {
            SDBERROR((LPCTSTR)csError);
        }

        pFileException->Delete();

    } catch(CMemoryException* pMemoryException) {

        SDBERROR(_T("Memory Allocation Failure\n"));
        pMemoryException->Delete();
    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\ntcompat.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    ntcompat.cpp
//
// History: 27-Mar-01   markder     Created.
//
// Desc:    This file contains all code needed to create ntcompat.inx
//          additions.
//
////////////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "make.h"
#include "fileio.h"

BOOL NtCompatCreateWinNTUpgradeEntry(
    SdbWinNTUpgrade* pNTUpg,
    CString* pcsInfLine)
{
    BOOL bSuccess = FALSE;
    CString csLinkDate, csAttr, csBinProductVersion, csBinFileVersion, csTemp;
    CString csFileName, csServiceName;
    ULONGLONG ullAttr = 0;

    if (pNTUpg->m_AppHelpRef.m_pAppHelp == NULL) {
        SDBERROR_FORMAT((_T("NTCOMPAT entry requires APPHELP: \"%s\"\n"),
            pNTUpg->m_pApp->m_csName));
        goto eh;
    }
    
    if (pNTUpg->m_MatchingFile.m_csName.GetLength() ||
        pNTUpg->m_MatchingFile.m_csServiceName.GetLength()) {
        if (pNTUpg->m_MatchingFile.m_dwMask & (~(
            SDB_MATCHINGINFO_BIN_PRODUCT_VERSION        |
            SDB_MATCHINGINFO_UPTO_BIN_PRODUCT_VERSION   |
            SDB_MATCHINGINFO_BIN_FILE_VERSION           |
            SDB_MATCHINGINFO_UPTO_BIN_FILE_VERSION      |
            SDB_MATCHINGINFO_LINK_DATE                  |
            SDB_MATCHINGINFO_UPTO_LINK_DATE))) {

            SDBERROR_FORMAT((_T("NTCOMPAT entry can only use (UPTO_)LINK_DATE and (UPTO_)BIN_xxxx_VERSION as matching info: \"%s\"\n"),
                pNTUpg->m_pApp->m_csName));

            goto eh;
        }

        if (pNTUpg->m_MatchingFile.m_dwMask & SDB_MATCHINGINFO_BIN_PRODUCT_VERSION ||
            pNTUpg->m_MatchingFile.m_dwMask & SDB_MATCHINGINFO_UPTO_BIN_PRODUCT_VERSION) {

            csAttr.Empty();

            if (pNTUpg->m_MatchingFile.m_dwMask & SDB_MATCHINGINFO_BIN_PRODUCT_VERSION) {
                ullAttr = pNTUpg->m_MatchingFile.m_ullBinProductVersion;
            } else {
                ullAttr = pNTUpg->m_MatchingFile.m_ullUpToBinProductVersion;
            }

            if (((WORD)(ullAttr >> 48)) != 0xFFFF) {
                csTemp.Format(_T("%d"), (WORD)(ullAttr >> 48));
                csAttr += csTemp;

                if (((WORD)(ullAttr >> 32)) != 0xFFFF) {
                    csTemp.Format(_T(".%d"), (WORD)(ullAttr >> 32));
                    csAttr += csTemp;

                    if (((WORD)(ullAttr >> 16)) != 0xFFFF) {
                        csTemp.Format(_T(".%d"), (WORD)(ullAttr >> 16));
                        csAttr += csTemp;

                        if (((WORD)(ullAttr)) != 0xFFFF) {
                            csTemp.Format(_T(".%d"), (WORD)(ullAttr));
                            csAttr += csTemp;
                        }
                    }
                }
            }

            if (pNTUpg->m_MatchingFile.m_dwMask & SDB_MATCHINGINFO_BIN_PRODUCT_VERSION) {
                csAttr = _T("=") + csAttr;
            }

            csAttr = _T("\"") + csAttr;
            csAttr += _T("\"");

            csBinProductVersion = csAttr;
        }

        if (pNTUpg->m_MatchingFile.m_dwMask & SDB_MATCHINGINFO_BIN_FILE_VERSION ||
            pNTUpg->m_MatchingFile.m_dwMask & SDB_MATCHINGINFO_UPTO_BIN_FILE_VERSION) {

            csAttr.Empty();

            if (pNTUpg->m_MatchingFile.m_dwMask & SDB_MATCHINGINFO_BIN_FILE_VERSION) {
                ullAttr = pNTUpg->m_MatchingFile.m_ullBinFileVersion;
            } else {
                ullAttr = pNTUpg->m_MatchingFile.m_ullUpToBinFileVersion;
            }

            if (((WORD)(ullAttr >> 48)) != 0xFFFF) {
                csTemp.Format(_T("%d"), (WORD)(ullAttr >> 48));
                csAttr += csTemp;

                if (((WORD)(ullAttr >> 32)) != 0xFFFF) {
                    csTemp.Format(_T(".%d"), (WORD)(ullAttr >> 32));
                    csAttr += csTemp;

                    if (((WORD)(ullAttr >> 16)) != 0xFFFF) {
                        csTemp.Format(_T(".%d"), (WORD)(ullAttr >> 16));
                        csAttr += csTemp;

                        if (((WORD)(ullAttr)) != 0xFFFF) {
                            csTemp.Format(_T(".%d"), (WORD)(ullAttr));
                            csAttr += csTemp;
                        }
                    }
                }
            }

            if (pNTUpg->m_MatchingFile.m_dwMask & SDB_MATCHINGINFO_BIN_FILE_VERSION) {
                csAttr = _T("=") + csAttr;
            }

            csAttr = _T("\"") + csAttr;
            csAttr += _T("\"");

            csBinFileVersion = csAttr;
        }

        if (pNTUpg->m_MatchingFile.m_dwMask & SDB_MATCHINGINFO_UPTO_LINK_DATE) {
            csLinkDate.Format(_T("\"0x%08X\""), (DWORD) pNTUpg->m_MatchingFile.m_timeUpToLinkDate);
        }

        if (pNTUpg->m_MatchingFile.m_dwMask & SDB_MATCHINGINFO_LINK_DATE) {
            csLinkDate.Format(_T("\"=0x%08X\""), (DWORD) pNTUpg->m_MatchingFile.m_timeLinkDate);
        }

        if (pNTUpg->m_MatchingFile.m_csServiceName.IsEmpty()) {
            pcsInfLine->Format(
                _T("f,\"%s\",%s,*idh_w2_%s.htm,,%%drvmain__%s__%%,,,,%s,%s"),
                pNTUpg->m_MatchingFile.m_csName,
                csBinFileVersion,
                pNTUpg->m_AppHelpRef.m_pAppHelp->m_csName,
                pNTUpg->m_AppHelpRef.m_pAppHelp->m_csName,
                csLinkDate,
                csBinProductVersion);
        } else {

            if (!pNTUpg->m_MatchingFile.m_csName.IsEmpty()) {
                csFileName = _T("\"");
                csFileName += pNTUpg->m_MatchingFile.m_csName;
                csFileName += _T("\"");
            }

            if (!pNTUpg->m_MatchingFile.m_csServiceName.IsEmpty()) {
                csServiceName = _T("\"");
                csServiceName += pNTUpg->m_MatchingFile.m_csServiceName;
                csServiceName += _T("\"");
            }

            pcsInfLine->Format(
                _T("s,%s,*idh_w2_%s.htm,,%%drvmain__%s__%%,%s,%s,,,,%s,%s"),
                csServiceName,
                pNTUpg->m_AppHelpRef.m_pAppHelp->m_csName,
                pNTUpg->m_AppHelpRef.m_pAppHelp->m_csName,
                csFileName,
                csBinFileVersion,
                csLinkDate,
                csBinProductVersion);
        }

    } else if (pNTUpg->m_MatchingRegistryEntry.m_csName.GetLength()) {

        CString csKey, csValueName, csValue;

        csKey = pNTUpg->m_MatchingRegistryEntry.m_csName;
        csValueName = pNTUpg->m_MatchingRegistryEntry.m_csValueName;
        csValue = pNTUpg->m_MatchingRegistryEntry.m_csValue;

        if (!csKey.IsEmpty()) {
            csKey = _T("\"") + csKey + _T("\"");
        }

        if (!csValueName.IsEmpty()) {
            csValueName = _T("\"") + csValueName + _T("\"");
        }

        if (!csValue.IsEmpty()) {
            csValue = _T("\"") + csValue + _T("\"");
        }
        

        pcsInfLine->Format(
            _T("r,%s,%s,%s,*idh_w2_%s.htm,*idh_w2_%s.htm,%%drvmain__%s__%%"),
            csKey,
            csValueName,
            csValue,
            pNTUpg->m_AppHelpRef.m_pAppHelp->m_csName,
            pNTUpg->m_AppHelpRef.m_pAppHelp->m_csName,
            pNTUpg->m_AppHelpRef.m_pAppHelp->m_csName);

    } else {
        SDBERROR_FORMAT((_T("NTCOMPAT entry requires 1 matching specification: \"%s\"\n"),
            pNTUpg->m_pApp->m_csName));
        goto eh;
    }

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL NtCompatWriteInfAdditions(
    SdbOutputFile* pOutputFile,
    SdbDatabase* pDB)
{
    BOOL bSuccess = FALSE;
    CStringArray rgServicesToDisable;
    CStringArray rgServicesToStopInstallation;
    CMapStringToString mapStrings;
    CString csInfLine, csStringKey, csStringLine;
    SdbWinNTUpgrade* pNTUpg = NULL;
    long i;

    for (i = 0; i < pDB->m_rgWinNTUpgradeEntries.GetSize(); i++) {

        pNTUpg = (SdbWinNTUpgrade *) pDB->m_rgWinNTUpgradeEntries.GetAt(i);

        if (!(pNTUpg->m_dwFilter & g_dwCurrentWriteFilter)) {
            continue;
        }

        if (!NtCompatCreateWinNTUpgradeEntry(pNTUpg, &csInfLine)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (pNTUpg->m_AppHelpRef.m_pAppHelp->m_bBlockUpgrade) {
            rgServicesToStopInstallation.Add(csInfLine);
        } else {
            rgServicesToDisable.Add(csInfLine);
        }

        csStringKey.Format(_T("drvmain__%s__"),
            pNTUpg->m_AppHelpRef.m_pAppHelp->m_csName);

        csStringLine.Format(_T("drvmain__%s__=\"%s\""),
            pNTUpg->m_AppHelpRef.m_pAppHelp->m_csName,
            pNTUpg->m_AppHelpRef.m_pAppHelp->m_pApp->GetLocalizedAppName());

        mapStrings.SetAt(csStringKey,csStringLine);
    }

    try {
        POSITION pos;
        CANSITextFile File(pOutputFile->m_csName,
            pDB->m_pCurrentMakefile->GetLangMap(pDB->m_pCurrentOutputFile->m_csLangID)->m_dwCodePage,
            CFile::typeText |
            CFile::modeCreate |
            CFile::modeWrite |
            CFile::shareDenyWrite);

        File.WriteString(_T(";\n"));
        File.WriteString(_T("; App Compat entries start here\n"));
        File.WriteString(_T(";\n"));
        File.WriteString(_T("; ___APPCOMPAT_NTCOMPAT_ENTRIES___\n"));
        File.WriteString(_T(";\n"));

        pos = mapStrings.GetStartPosition();

        while (pos) {
            mapStrings.GetNextAssoc(pos, csStringKey, csStringLine);

            File.WriteString(csStringLine + _T("\n"));
        }

        File.WriteString(_T("\n\n[ServicesToDisable]\n"));
        for (i = 0; i < rgServicesToDisable.GetSize(); i++) {
            File.WriteString(rgServicesToDisable[i] + _T("\n"));
        }

        File.WriteString(_T("\n\n[ServicesToStopInstallation]\n"));
        for (i = 0; i < rgServicesToStopInstallation.GetSize(); i++) {
            File.WriteString(rgServicesToStopInstallation[i] + _T("\n"));
        }

        File.Close();
    }

    catch(...) {
        SDBERROR_FORMAT((_T("Error writing NTCOMPAT file \"%s\"."),
            pOutputFile->m_csName));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL NtCompatWriteMessageInf(
    SdbOutputFile* pOutputFile,
    SdbDatabase* pDB)
{
    BOOL bSuccess = FALSE;
    SdbAppHelp* pAppHelp;
    SdbMessage* pMessage;
    CString csInfLine;
    long i;

    // Message parts
    DWORD   dwHTMLHelpID;
    LANGID  langID;
    CString csURL, csContactInfo, csAppTitle;
    CString csDetails;

    try {

        CANSITextFile File(pOutputFile->m_csName,
            pDB->m_pCurrentMakefile->GetLangMap(pDB->m_pCurrentOutputFile->m_csLangID)->m_dwCodePage,
            CFile::typeText |
            CFile::modeCreate |
            CFile::modeWrite |
            CFile::shareDenyWrite);

        File.WriteString(_T(";\n;  AppHelp Message INF for NTCOMPAT-style upgrades\n"));
        File.WriteString(_T(";\n;  This file is generated from XML via ShimDBC\n;\n"));
        File.WriteString(_T("\n\n[Version]\nsignature=\"$windows nt$\"\n\n"));

        for (i = 0; i < pDB->m_rgAppHelps.GetSize(); i++) {

            pAppHelp = (SdbAppHelp *) pDB->m_rgAppHelps.GetAt(i);

            if (!(pAppHelp->m_dwFilter & g_dwCurrentWriteFilter)) {
                continue;
            }

            pMessage =
                (SdbMessage *) pDB->m_rgMessages.LookupName(pAppHelp->m_csMessage, pDB->m_pCurrentMakefile->m_csLangID);

            if (pMessage == NULL) {
                SDBERROR_FORMAT((_T("Error looking up message for AppHelp HTMLHELPID %s\n"),
                    pAppHelp->m_csName));
                goto eh;
            }

            if (!pDB->ConstructMessageParts(
                pAppHelp,
                pMessage,
                pDB->m_pCurrentMakefile->m_csLangID,
                &dwHTMLHelpID,
                &csURL,
                &csContactInfo,
                &csAppTitle,
                NULL,
                &csDetails)) {
                SDBERROR_PROPOGATE();
                goto eh;
            }

            csInfLine.Format(_T("[idh_w2_%d.htm]\n"), dwHTMLHelpID);
            File.WriteString(csInfLine);

            csDetails = TrimParagraph(csDetails);

            if (!pDB->HTMLtoText(csDetails, &csInfLine)) {
                SDBERROR_PROPOGATE();
                goto eh;
            }

            ReplaceStringNoCase(csInfLine, _T(" \n"), _T("\n"));
            ReplaceStringNoCase(csInfLine, _T("\n "), _T("\n"));
            ReplaceStringNoCase(csInfLine, _T("\""), _T("'"));
            ReplaceStringNoCase(csInfLine, _T("\n"), _T("\"\n\""));

            csInfLine.TrimLeft();
            csInfLine.TrimRight();
            csInfLine = _T("\"") + csInfLine;
            csInfLine += _T("\"\n\"\"\n");

            File.WriteString(csInfLine);

            csContactInfo = TrimParagraph(csContactInfo);

            if (!pDB->HTMLtoText(csContactInfo, &csInfLine)) {
                SDBERROR_PROPOGATE();
                goto eh;
            }

            ReplaceStringNoCase(csInfLine, _T(" \n"), _T("\n"));
            ReplaceStringNoCase(csInfLine, _T("\n "), _T("\n"));
            ReplaceStringNoCase(csInfLine, _T("\""), _T("'"));
            ReplaceStringNoCase(csInfLine, _T("\n"), _T("\"\n\""));

            csInfLine.TrimLeft();
            csInfLine.TrimRight();
            csInfLine = _T("\"") + csInfLine;
            csInfLine += _T("\"\n\n");

            File.WriteString(csInfLine);
        }

        File.Close();
    }
    catch(...) {
        SDBERROR_FORMAT((_T("Error writing to NTCOMPAT INF for HTMLHELPID %s.\n"),
            pAppHelp->m_csName));
    }


    bSuccess = TRUE;

eh:
    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\make.h ===
///////////////////////////////////////////////////////////////////////////////
//
// File:    make.h
//
// History: 28-Feb-01   markder     Created.
//
// Desc:    This file contains definitions of the SdbMakefile object.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __MAKE_H__
#define __MAKE_H__

#include "obj.h"

class SdbInOutFile : public SdbArrayElement
{
public:
    CMapStringToString  m_mapParameters;

    CString GetParameter(CString csName) {
        CString csReturn;

        if (m_mapParameters.Lookup(csName, csReturn)) {
            return csReturn;
        }
        return CString();
    }

    CString GetDirectory()
    {
        CString csFullPath(MakeFullPath(m_csName));
        for (long i = csFullPath.GetLength() - 1; i >= 0; i--) {
            if (csFullPath.GetAt(i)== _T('\\')) {
                return csFullPath.Left(i+1);
            }
        }

        return CString();
    }

    CString GetFullPath()
    {
        return MakeFullPath(m_csName);
    }

    CString GetFullPathWithoutExtension()
    {
        CString csFullPath(MakeFullPath(m_csName));
        for (long i = csFullPath.GetLength() - 1; i >= 0; i--) {
            if (csFullPath.GetAt(i) == _T('.')) {
                return csFullPath.Left(i);
            }
            if (csFullPath.GetAt(i) == _T('\\')) {
                return csFullPath;
            }
        }

        return csFullPath;
    }

    CString GetNameWithoutExtension()
    {
        long nDot = -1;
        CString csName(m_csName);
        for (long i = csName.GetLength() - 1; i >= 0; i--) {
            if (csName.GetAt(i) == _T('.')) {
                if (nDot == -1) {
                    nDot = i;
                }
            }
            if (csName.GetAt(i) == _T('\\')) {
                return csName.Mid(i + 1, nDot - i - 1);
            }
        }

        if (nDot == -1) {
            return csName;
        }

        return csName.Left(nDot);
    }

};

class SdbInputFile : public SdbInOutFile
{
public:
    SdbInputFile() :
        m_bSourceUpdated(FALSE) {}


    BOOL        m_bSourceUpdated;

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
};

class SdbOutputFile : public SdbInOutFile
{
public:
    DATE            m_dtRevisionCutoff;
    SdbOutputType   m_OutputType;

    SdbOutputFile() :
      m_OutputType(SDB_OUTPUT_TYPE_SDB),
      m_dtRevisionCutoff(0)
    {
        m_dwFilter = SDB_FILTER_INCLUDE_ALL;
    }

    CString GetFriendlyNameForType() {
        switch (m_OutputType) {
        case SDB_OUTPUT_TYPE_SDB:
            return CString(_T("Writing SDB file"));
        case SDB_OUTPUT_TYPE_HTMLHELP:
            return CString(_T("Writing HTMLHelp files"));
        case SDB_OUTPUT_TYPE_MIGDB_INX:
            return CString(_T("Writing MigDB INX file"));
        case SDB_OUTPUT_TYPE_MIGDB_TXT:
            return CString(_T("Writing MigDB TXT file"));
        case SDB_OUTPUT_TYPE_WIN2K_REGISTRY:
            return CString(_T("Writing Win2k reg files"));
        case SDB_OUTPUT_TYPE_REDIR_MAP:
            return CString(_T("Writing redir map file"));
        case SDB_OUTPUT_TYPE_NTCOMPAT_INF:
            return CString(_T("Writing NTCOMPAT add file"));
        case SDB_OUTPUT_TYPE_NTCOMPAT_MESSAGE_INF:
            return CString(_T("Writing NTCOMPAT msg file"));
        case SDB_OUTPUT_TYPE_APPHELP_REPORT:
            return CString(_T("Writing AppHelp report file"));
        }

        return CString();
    }

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
};

class SdbLangMap : public SdbArrayElement
{
public:
    UINT    m_dwCodePage;
    LCID    m_lcid;
    CString m_csHtmlCharset;

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
};

class SdbMakefile
{
public:
    SdbMakefile() :
      m_bAddExeStubs(FALSE),
      m_flOSVersion(0.0),
      m_dwOSPlatform(OS_PLATFORM_I386),
      m_csLangID(_T("---")) { }

    SdbArray<SdbInputFile>  m_rgInputFiles;
    SdbArray<SdbOutputFile> m_rgOutputFiles;
    SdbArray<SdbLangMap>    m_rgLangMaps;

    DOUBLE      m_flOSVersion;
    DWORD       m_dwOSPlatform;
    BOOL        m_bAddExeStubs;

    CString m_csHTMLHelpFilesOutputDir;
    CString m_csRegistryFilesOutputDir;
    CString m_csMigDBFilesOutputDir;
    CString m_csLangID;

    CStringArray m_rgHistoryKeywords;
    void AddHistoryKeywords(LPCTSTR szStart);

    SdbLangMap* GetLangMap(CString& csLangID);

    BOOL ReadMakefile(CString csMakefile);
    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
};

BOOL WriteRedirMapFile(CString csFile, CString csTemplateFile, SdbDatabase* pDB);
BOOL WriteAppHelpReport(SdbOutputFile* pOutputFile, SdbDatabase* pDB);

#endif // __MAKE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\obj.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// File:    obj.cpp
//
// History: 16-Nov-00   markder     Created.
//
// Desc:    This file contains various member functions/constructors
//          used by the SdbDatabase object model.
//
///////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "make.h"

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   ReadFromXML, WriteToSDB, WriteRefToSDB
//
//  Desc:   Each element that can be initialized from XML must implement
//          ReadFromXML. Similarly, each object that can persist itself
//          in an SDB file must implement WriteToSDB. A special case of
//          WriteToSDB is when an object is written differently if it
//          is a reference to an object in the LIBRARY, in which case
//          the object must implement WriteRefToSDB.
//
BOOL SdbArrayElement::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    SDBERROR(_T("ReadFromXML not implemented for this object"));
    return FALSE;
}

BOOL SdbArrayElement::WriteToSDB(PDB pdb)
{
    SDBERROR(_T("WriteToSDB not implemented for this object."));
    return FALSE;
}

BOOL SdbArrayElement::WriteRefToSDB(PDB pdb)
{
    SDBERROR(_T("WriteRefToSDB not implemented for this object."));
    return FALSE;
}

void SdbArrayElement::PropagateFilter(DWORD dwFilter)
{
    if (!(m_dwFilter & SDB_FILTER_OVERRIDE)) {
        m_dwFilter |= dwFilter;
    }

    if (dwFilter == SDB_FILTER_EXCLUDE_ALL) {
        m_dwFilter = SDB_FILTER_EXCLUDE_ALL;
    }

    if (m_csOSVersionSpec.GetLength() &&
        m_pDB->m_pCurrentMakefile->m_flOSVersion != 0.0) {
        if (FilterOSVersion(m_pDB->m_pCurrentMakefile->m_flOSVersion,
                            m_csOSVersionSpec,
                            &m_dwSPMask)) {

            m_dwFilter = SDB_FILTER_EXCLUDE_ALL;
        }
    }
    
    if (!(m_dwOSPlatform & m_pDB->m_pCurrentMakefile->m_dwOSPlatform)) {
        m_dwFilter = SDB_FILTER_EXCLUDE_ALL;
    }
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   Compare
//
//  Desc:   Compare two elements - first compare the keys (m_ullKey member)
//          then names, return < 0 if this element should precede pElement
//          > 0 if this element should follow pElement
//          = 0 if the elements are equal
//
int SdbArrayElement::Compare(const SdbArrayElement* pElement) {

    //
    // compare key first
    //
    if (m_ullKey < pElement->m_ullKey) {
        return -1;
    }
    //
    // we are either greater or equal
    //
    if (m_ullKey > pElement->m_ullKey) {
        return 1;
    }

    //
    // equal keys, compare names
    //
    return m_csName.CompareNoCase(pElement->m_csName);
}

int SdbExe::Compare(const SdbArrayElement* pElement) {

    int nRet = SdbArrayElement::Compare(pElement);

    if (nRet == 0) {
        //
        // the keys are equal, but we want to put the additive one(s) before the non-additive
        //

        if (m_dwMatchMode == MATCH_ADDITIVE && ((SdbExe*)pElement)->m_dwMatchMode != MATCH_ADDITIVE) {
            nRet = -1;
        } else if (m_dwMatchMode != MATCH_ADDITIVE && ((SdbExe*)pElement)->m_dwMatchMode == MATCH_ADDITIVE) {
            nRet = 1;
        }
    }
    return nRet;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   SdbPatch::AddBlobBytes, SdbPatch::ClearBlob
//
//  Desc:   Helper functions to add to the SdbPatch 'blob', which is a series
//          of opcodes and instructions that define how to match on memory
//          and 'patch' it safely.
//
void SdbPatch::AddBlobBytes( LPVOID pBytes, DWORD dwSize )
{
    PBYTE pOldBuffer        = NULL;
    DWORD dwOldBufferSize   = 0;

    if( m_pBlob == NULL )
    {
        m_dwBlobMemSize = dwSize > 1000 ? dwSize : 1000;
        m_pBlob = new BYTE[m_dwBlobMemSize];
        m_dwBlobSize = 0;
    }

    if( dwSize > m_dwBlobMemSize - m_dwBlobSize )
    {
        pOldBuffer = m_pBlob;
        dwOldBufferSize = m_dwBlobMemSize;
        m_dwBlobMemSize = ( m_dwBlobMemSize * 2 ) + dwSize;
        m_pBlob = new BYTE[m_dwBlobMemSize];

        if( pOldBuffer )
        {
            memcpy( m_pBlob, pOldBuffer, dwOldBufferSize );
            delete pOldBuffer;
        }
    }

    memcpy( (LPVOID) (m_pBlob + m_dwBlobSize ), pBytes, dwSize );

    m_dwBlobSize += dwSize;
}

void SdbPatch::ClearBlob()
{
    if (m_pBlob != NULL) {
        delete m_pBlob;
        m_pBlob = NULL;
    }
    m_dwBlobMemSize = 0;
    m_dwBlobSize = 0;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   SdbData::SetValue, SdbData::Clear
//
//  Desc:   Accessor functions to set/clear the value of a data object.
//          The object mimics the registry in the way that it can store
//          DWORDs, strings or binary data.
//
BOOL SdbData::SetValue(SdbDataValueType DataType, LPCTSTR szValue)
{
    Clear();

    m_DataType  = DataType;
    m_dwDataSize = 0;

    switch(DataType) {
    case eValueDWORD:
        m_dwDataSize = sizeof(m_dwValue);
        m_dwValue = StringToDword(szValue);
        break;

    case eValueQWORD:
        m_dwDataSize = sizeof(m_ullValue);
        m_ullValue = StringToQword(szValue);
        break;

    case eValueBinary:
        m_dwDataSize = GetByteStringSize(szValue);

        m_pBinValue = new BYTE[m_dwDataSize];
        if (m_pBinValue == NULL) {
            return FALSE;
        }

        GetBytesFromString(szValue, m_pBinValue, m_dwDataSize);
        break;

    case eValueString:

        m_szValue = new TCHAR[_tcslen(szValue) + 1];
        if (m_szValue == NULL) {
            return FALSE;
        }
        StringCchCopy(m_szValue, _tcslen(szValue) + 1, szValue);
        break;

    }

    return TRUE;
}

void SdbData::Clear()
{
    switch(m_DataType) {

    case eValueString:
        if (NULL != m_szValue) {
            delete[] m_szValue;
        }
        break;

    case eValueBinary:
        if (NULL != m_pBinValue) {
            delete[] m_pBinValue;
        }
        break;
    }

    m_DataType = eValueNone;
}

BOOL SdbDatabase::IsStandardDatabase(VOID)
{
    const GUID* rgpGUID[] = {
        &GUID_SYSMAIN_SDB,
        &GUID_APPHELP_SDB,
        &GUID_SYSTEST_SDB,
        &GUID_DRVMAIN_SDB,
        &GUID_MSIMAIN_SDB
    };

    int i;

    for (i = 0; i < ARRAYSIZE(rgpGUID); ++i) {
        if (*rgpGUID[i] == m_CurrentDBID) {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL SdbDatabase::ReplaceFields(CString csXML, CString* pcsReturn, SdbRefArray<SdbMessageField>* prgFields)
{
    BOOL bSuccess = FALSE;
    XMLNodeList XQL;
    IXMLDOMNodePtr cpTargetNode;
    IXMLDOMNodePtr cpCurrentNode;
    IXMLDOMNodePtr cpNewTextNode;
    IXMLDOMNodePtr cpParentNode;
    IXMLDOMNodePtr cpOldNode;
    IXMLDOMDocument* pDocument;
    CString csFieldName, csTempXML;
    CHAR* lpBuf;
    BSTR bsText = NULL;
    VARIANT                 vType;
    long i;
    SdbMessageField* pField;

    VariantInit(&vType);

    vType.vt = VT_I4;
    vType.lVal = NODE_TEXT;

#ifdef UNICODE
//    lpBuf = (LPSTR) csTempXML.GetBuffer(10);
//    lpBuf[0] = (CHAR) 0xFF;
//    lpBuf[1] = (CHAR) 0xFE;
//    lpBuf[2] = 0x00;
//    lpBuf[3] = 0x00;
//    csTempXML.ReleaseBuffer();
    csTempXML += L"<?xml version=\"1.0\" encoding=\"UTF-16\"?>";
#else
    csTempXML = "<?xml version=\"1.0\" encoding=\"Windows-1252\"?>";
#endif

    csTempXML += _T("<_TARGET>");
    csTempXML += csXML;
    csTempXML += _T("</_TARGET>");

    //
    // Replace all <, > and &amp; in fields with ugly markers to be replaced later
    //
    for (i = 0; i < prgFields->GetSize(); i++) {
        pField = (SdbMessageField *) prgFields->GetAt(i);

        pField->m_csValue.Replace(_T("&lt;"), _T("____REAL_LESS_THAN____"));
        pField->m_csValue.Replace(_T("&gt;"), _T("____REAL_GREATER_THAN____"));
        pField->m_csValue.Replace(_T("<"), _T("____LESS_THAN____"));
        pField->m_csValue.Replace(_T(">"), _T("____GREATER_THAN____"));
        pField->m_csValue.Replace(_T("&amp;"), _T("____AMP____"));
        pField->m_csValue.Replace(_T("&nbsp;"), _T("____NBSP____"));
    }

    //
    // Load the XML into the temporary DOM
    //
    if (!OpenXML(csTempXML, &m_cpTempXML, TRUE, &m_cpTempXMLDoc)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!XQL.Query(m_cpTempXML, _T("_TARGET"))) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!XQL.GetItem(0, &cpTargetNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    XQL.Query(cpTargetNode, _T("//*"));

    for (i = 0; i < XQL.GetSize(); i++) {

        if (!XQL.GetItem(i, &cpCurrentNode)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (GetNodeName(cpCurrentNode) == _T("FIELD")) {
            GetAttribute(_T("NAME"), cpCurrentNode, &csFieldName);

            pField = (SdbMessageField *) prgFields->LookupName(csFieldName);

            if (pField != NULL) {

                bsText = pField->m_csValue.AllocSysString();

                if (FAILED(m_cpTempXML->get_ownerDocument(&pDocument))) {
                    SDBERROR(_T("createNode failed while adding attribute"));
                    goto eh;
                }

                if (FAILED(m_cpTempXMLDoc->createNode(vType, NULL, NULL, &cpNewTextNode))) {
                    SDBERROR(_T("createNode failed while adding attribute"));
                    goto eh;
                }

                if (FAILED(cpNewTextNode->put_text(bsText))) {
                    SDBERROR(_T("Could not set text property of FIELD object."));
                    goto eh;
                }

                if (FAILED(cpCurrentNode->get_parentNode(&cpParentNode))) {
                    SDBERROR(_T("Could not retrieve parent node of FIELD object."));
                    goto eh;
                }

                if (FAILED(cpParentNode->replaceChild(cpNewTextNode, cpCurrentNode, &cpOldNode))) {
                    SDBERROR(_T("Could not replace <FIELD> node with text node."));
                    goto eh;
                }

                cpNewTextNode = NULL;
                cpOldNode = NULL;

                SysFreeString(bsText);
                bsText = NULL;
            }
        }

        cpCurrentNode.Release();
    }

    *pcsReturn = GetInnerXML(cpTargetNode);

    //
    // Turn the ugly markers back to prettiness
    //
    pcsReturn->Replace(_T("____REAL_LESS_THAN____"), _T("&lt;"));
    pcsReturn->Replace(_T("____REAL_GREATER_THAN____"), _T("&gt;"));
    pcsReturn->Replace(_T("____LESS_THAN____"), _T("<"));
    pcsReturn->Replace(_T("____GREATER_THAN____"), _T(">"));
    pcsReturn->Replace(_T("____AMP____"), _T("&amp;"));
    pcsReturn->Replace(_T("____NBSP____"), _T("&nbsp;"));

    bSuccess = TRUE;

eh:
    VariantClear(&vType);

    if (bsText) {
        SysFreeString(bsText);
    }

    return bSuccess;
}

BOOL SdbDatabase::RedirectLinks(CString* pcsXML, LCID lcid, CString csRedirURL)
{
    BOOL bSuccess = FALSE;
    XMLNodeList XQL;
    IXMLDOMNodePtr cpTargetNode;
    IXMLDOMNodePtr cpCurrentNode;
    CString csRedirID, csFinalRedirURL, csLCID;
    CString csTempXML;
    long i;

    csLCID.Format(_T("%X"), lcid);

    csTempXML = _T("<?xml version=\"1.0\"?><_TARGET>");
    csTempXML += *pcsXML;
    csTempXML += _T("</_TARGET>");

    if (!OpenXML(csTempXML, &m_cpTempXML, TRUE, &m_cpTempXMLDoc)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!XQL.Query(m_cpTempXML, _T("_TARGET"))) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!XQL.GetItem(0, &cpTargetNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!XQL.Query(m_cpTempXML, _T("//A"))) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    for (i = 0; i < XQL.GetSize(); i++) {

        if (!XQL.GetItem(i, &cpCurrentNode)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (!GetAttribute(_T("REDIR_ID"), cpCurrentNode, &csRedirID)) {
            SDBERROR_FORMAT((_T("REDIR_ID not found on <A> element:\n%s\n"),
                *pcsXML));
            goto eh;
        }

        csFinalRedirURL = csRedirURL;
        csFinalRedirURL.Replace(_T("$REDIR_ID$"), csRedirID);
        csFinalRedirURL.Replace(_T("$LCID$"), csLCID);

        if (!AddAttribute(cpCurrentNode, _T("HREF"), csFinalRedirURL)) {
            SDBERROR_FORMAT((_T("Could not replace HREF attribute on <A> tag:\n%s\n"),
                *pcsXML));
            goto eh;
        }

        if (!AddAttribute(cpCurrentNode, _T("TARGET"), _T("_new"))) {
            SDBERROR_FORMAT((_T("Could not add TARGET=\"_new\" attribute on <A> tag:\n%s\n"),
                *pcsXML));
            goto eh;
        }

        if (!RemoveAttribute(_T("REDIR_ID"), cpCurrentNode)) {
            SDBERROR_FORMAT((_T("Could not remove REDIR_ID attribute on <A> tag:\n%s\n"),
                *pcsXML));
            goto eh;
        }

    }

    *pcsXML = GetInnerXML(cpTargetNode);

    bSuccess = TRUE;

 eh:

    return bSuccess;
}

BOOL SdbDatabase::HTMLtoText(CString csXML, CString* pcsReturn)
{
    BOOL bSuccess = FALSE;
    XMLNodeList XQL;
    IXMLDOMNodePtr cpTargetNode;
    IXMLDOMNodePtr cpCurrentNode;
    IXMLDOMDocument* pDocument;
    DOMNodeType NodeType;
    CString csTempXML;
    BSTR bsText = NULL;
    long i;

    csTempXML = _T("<?xml version=\"1.0\"?><_TARGET>");
    csTempXML += csXML;
    csTempXML += _T("</_TARGET>");

    pcsReturn->Empty();

    //
    // Load the XML into the temporary DOM
    //
    if (!OpenXML(csTempXML, &m_cpTempXML, TRUE, &m_cpTempXMLDoc)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!XQL.Query(m_cpTempXML, _T("_TARGET"))) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!XQL.GetItem(0, &cpTargetNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    XQL.Query(cpTargetNode, _T("//"));

    for (i = 0; i < XQL.GetSize(); i++) {

        if (!XQL.GetItem(i, &cpCurrentNode)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (FAILED(cpCurrentNode->get_nodeType(&NodeType))) {
            SDBERROR(_T("Error retrieving nodeType attribute."));
            goto eh;
        }

        if (NodeType == NODE_TEXT) {

            *pcsReturn += _T(" ");
            *pcsReturn += GetText(cpCurrentNode);
            *pcsReturn += _T(" ");

        } else {

            if (GetNodeName(cpCurrentNode) == _T("BR")) {
                *pcsReturn += _T("\n");
            }

            if (GetNodeName(cpCurrentNode) == _T("P")) {
                *pcsReturn += _T("\n\n");
            }
        }

        cpCurrentNode.Release();
    }

    bSuccess = TRUE;

eh:
    if (bsText) {
        SysFreeString(bsText);
    }

    return bSuccess;
}

CString SdbApp::GetLocalizedAppName()
{
    return GetLocalizedAppName(m_pDB->m_pCurrentMakefile->m_csLangID);
}

CString SdbApp::GetLocalizedAppName(CString csLangID)
{
    CString csLookup(m_csName);
    SdbLocalizedString* pLocString = NULL;

    csLookup.MakeUpper();
    pLocString = (SdbLocalizedString *) m_pDB->m_rgLocalizedAppNames.LookupName(csLookup, csLangID);
    if (pLocString) {
        return pLocString->m_csValue;
    } else {
        return m_csName;
    }
}

CString SdbApp::GetLocalizedVendorName()
{
    return GetLocalizedVendorName(m_pDB->m_pCurrentMakefile->m_csLangID);
}

CString SdbApp::GetLocalizedVendorName(CString csLangID)
{
    CString csLookup(m_csVendor);
    SdbLocalizedString* pLocString = NULL;

    csLookup.MakeUpper();
    pLocString = (SdbLocalizedString *) 
        m_pDB->m_rgLocalizedVendorNames.LookupName(csLookup, csLangID);
    if (pLocString) {
        return pLocString->m_csValue;
    } else {
        return m_csVendor;
    }
}

BOOL SdbExe::IsValidForWin2k(CString csXML)
{
    BOOL bReturn = FALSE;

    SdbMatchingFile* pMFile;

    if (!FilterOSVersion(5.0, m_csOSVersionSpec, &m_dwSPMask)) {

        if (m_csName.GetLength() > 1 &&
            m_csName.FindOneOf(_T("*?")) != -1) {
            SDBERROR_FORMAT((
                _T("Wildcards not supported on Win2k. Add OS_VERSION=\"gte5.1\" to <EXE>:\n%s\n"),
                csXML));
            goto eh;
        }

        for (long i = 0; i < m_rgMatchingFiles.GetSize(); i++) {
            pMFile = (SdbMatchingFile *) m_rgMatchingFiles.GetAt(i);

            if (!pMFile->IsValidForWin2k(csXML)) {
                SDBERROR_PROPOGATE();
                goto eh;
            }
        }
    }

    bReturn = TRUE;

eh:

    return bReturn;
}

BOOL SdbMatchingFile::IsValidForWin2k(CString csXML)
{
    BOOL bReturn = FALSE;

    if (m_bMatchLogicNot) {
        SDBERROR_FORMAT((
            _T("LOGIC=\"NOT\" not supported on Win2k, add OS_VERSION=\"gte5.1\" to <EXE>:\n%s\n"),
            csXML));
        goto eh;
    }

    if (m_dwMask &
        (SDB_MATCHINGINFO_LINK_DATE | SDB_MATCHINGINFO_UPTO_LINK_DATE)) {
        SDBERROR_FORMAT((
            _T("LINK_DATE and UPTO_LINK_DATE not supported on Win2k, add OS_VERSION=\"gte5.1\" to <EXE>:\n%s\n"),
            csXML));
        goto eh;
    }

    if (m_csCompanyName.FindOneOf(_T("*?")) != -1 ||
        m_csProductName.FindOneOf(_T("*?")) != -1 ||
        m_csProductVersion.FindOneOf(_T("*?")) != -1 ||
        m_csFileDescription.FindOneOf(_T("*?")) != -1 ||
        m_csFileVersion.FindOneOf(_T("*?")) != -1 ||
        m_csOriginalFileName.FindOneOf(_T("*?")) != -1 ||
        m_csInternalName.FindOneOf(_T("*?")) != -1 ||
        m_csLegalCopyright.FindOneOf(_T("*?")) != -1 ||
        m_cs16BitDescription.FindOneOf(_T("*?")) != -1 ||
        m_cs16BitModuleName.FindOneOf(_T("*?")) != -1) {
        SDBERROR_FORMAT((
            _T("Wildcards not supported on Win2k, add OS_VERSION=\"gte5.1\" to <EXE>:\n%s\n"),
            csXML));
        goto eh;
    }

    if ((m_ullBinFileVersion & 0x000000000000FFFF) == 0x000000000000FFFF ||
        (m_ullBinProductVersion & 0x000000000000FFFF) == 0x000000000000FFFF)
    {
        SDBERROR_FORMAT((
            _T("Non-exact matching on binary version not supported on Win2k, add OS_VERSION=\"gte5.1\" to <EXE>:\n%s\n"),
            csXML));
        goto eh;
    }

    bReturn = TRUE;

eh:

    return bReturn;
}

ULONGLONG SdbFlag::MakeMask(SdbRefArray<SdbFlag>* prgFlags, DWORD dwType)
{
    SdbFlag* pFlag;
    long i;
    ULONGLONG ullMask = 0;

    for (i = 0; i < prgFlags->GetSize(); i++) {
        pFlag = (SdbFlag *) prgFlags->GetAt(i);

        if (pFlag->m_dwType == dwType) {
            ullMask |= pFlag->m_ullMask;
        }
    }

    return ullMask;
}

BOOL SdbFlag::SetType(CString csType)
{
    csType.MakeUpper();

    if (csType == _T("KERNEL")) {
        m_dwType = SDB_FLAG_KERNEL;
    } else if (csType == _T("USER")) {
        m_dwType = SDB_FLAG_USER;
    } else if (csType == _T("SHELL")) {
        m_dwType = SDB_FLAG_SHELL;
    } else if (csType == _T("NTVDM1")) {
        m_dwType = SDB_FLAG_NTVDM1;
    } else if (csType == _T("NTVDM2")) {
        m_dwType = SDB_FLAG_NTVDM2;
    } else if (csType == _T("NTVDM3")) {
        m_dwType = SDB_FLAG_NTVDM3;
    } else {
        return FALSE;
    }

    return TRUE;
}

TAG SdbFlag::TagFromType(DWORD dwType)
{
    TAG tReturn = TAG_NULL;

    switch (dwType) {

    case SDB_FLAG_KERNEL:
        tReturn = TAG_FLAG_MASK_KERNEL;
        break;

    case SDB_FLAG_USER:
        tReturn = TAG_FLAG_MASK_USER;
        break;

    case SDB_FLAG_SHELL:
        tReturn = TAG_FLAG_MASK_SHELL;
        break;

    case SDB_FLAG_NTVDM1:
        tReturn = TAG_FLAGS_NTVDM1;
        break;

    case SDB_FLAG_NTVDM2:
        tReturn = TAG_FLAGS_NTVDM2;
        break;

    case SDB_FLAG_NTVDM3:
        tReturn = TAG_FLAGS_NTVDM3;
        break;

    default:
        break;
    }

    return tReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\make.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// File:    make.cpp
//
// History: 06-Mar-01   markder     Created.
//
// Desc:    This file contains various member functions/constructors
//          used by the makefile objects.
//
///////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "make.h"
#include "fileio.h"

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   ReadDatabase
//
//  Desc:   Opens an XML file and calls read on the database object.
//
BOOL SdbMakefile::ReadMakefile(
    CString csMakefile)
{
    BOOL                bSuccess            = FALSE;
    IXMLDOMNodePtr      cpRootNode;
    IXMLDOMNodePtr      cpMakefile;
    XMLNodeList         XQL;

    if (!OpenXML(csMakefile, &cpRootNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!GetChild(_T("SHIMDBC_MAKEFILE"), cpRootNode, &cpMakefile)) {
        SDBERROR(_T("<SHIMDBC_MAKEFILE> object not found"));
        goto eh;
    }

    if (!ReadFromXML(cpMakefile, NULL)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL SdbMakefile::ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB)
{
    BOOL                bSuccess            = FALSE;
    SdbOutputFile*      pOutputFile         = NULL;

    if (!m_rgInputFiles.ReadFromXML(_T("INPUT"), NULL, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!m_rgOutputFiles.ReadFromXML(_T("OUTPUT"), NULL, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Propagate LANGID to output files if needed
    //
    for (int j = 0; j < m_rgOutputFiles.GetSize(); j++) {
        pOutputFile = (SdbOutputFile *) m_rgOutputFiles.GetAt(j);
        if (!pOutputFile->m_csLangID.GetLength()) {
            pOutputFile->m_csLangID = m_csLangID;
        }
    }

    if (!m_rgLangMaps.ReadFromXML(_T("LANG_MAP"), NULL, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
    
}

BOOL SdbInputFile::ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB)
{
    BOOL                bSuccess            = FALSE;
    CString             csType, csParamName, csParamValue;
    XMLNodeList         XQL;
    IXMLDOMNodePtr      cpParam;
    long                i;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_csName = MakeFullPath(m_csName);

    ExpandEnvStrings(&m_csName);

    if (!XQL.Query(pNode, _T("PARAM"))) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    for (i = 0; i < XQL.GetSize(); i++) {

        if (!XQL.GetItem(i, &cpParam)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (!GetAttribute(_T("NAME"), cpParam, &csParamName)) {
            SDBERROR_FORMAT((_T("<PARAM> requires NAME attribute:\n%s\n"),
                           GetXML(cpParam)));
        }

        if (!GetAttribute(_T("VALUE"), cpParam, &csParamValue)) {
            SDBERROR_FORMAT((_T("<PARAM> requires VALUE attribute:\n%s\n"),
                           GetXML(cpParam)));
        }

        ExpandEnvStrings(&csParamValue);

        if (csParamName == _T("FILTER")) {
            m_dwFilter = GetFilter(csParamValue);
        }

        m_mapParameters.SetAt(csParamName, csParamValue);

        cpParam.Release();
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
    
}

BOOL SdbOutputFile::ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB)
{
    BOOL                bSuccess            = FALSE;
    CString             csType, csParamName, csParamValue;
    XMLNodeList         XQL;
    IXMLDOMNodePtr      cpParam;
    long                i;
    COleDateTime        odtServicePackBaselineDate;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    ExpandEnvStrings(&m_csName);

    m_csName = MakeFullPath(m_csName);

    if (!GetAttribute(_T("TYPE"), pNode, &csType)) {
        SDBERROR_FORMAT((_T("<OUTPUT> requires TYPE attribute:\n%s\n"),
                       GetXML(pNode)));
    }

    m_OutputType = GetOutputType(csType);

    if (m_OutputType == SDB_OUTPUT_TYPE_UNKNOWN) {
        SDBERROR_FORMAT((_T("<OUTPUT TYPE> not recognized:\n%s\n"),
                       csType));
    }

    if (!XQL.Query(pNode, _T("PARAM"))) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    for (i = 0; i < XQL.GetSize(); i++) {

        if (!XQL.GetItem(i, &cpParam)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (!GetAttribute(_T("NAME"), cpParam, &csParamName)) {
            SDBERROR_FORMAT((_T("<PARAM> requires NAME attribute:\n%s\n"),
                           GetXML(cpParam)));
        }

        if (!GetAttribute(_T("VALUE"), cpParam, &csParamValue)) {
            SDBERROR_FORMAT((_T("<PARAM> requires VALUE attribute:\n%s\n"),
                           GetXML(cpParam)));
        }

        ExpandEnvStrings(&csParamValue);

        if (csParamName == _T("FILTER")) {
            m_dwFilter = GetFilter(csParamValue);
        }

        if (csParamName == _T("INCLUDE FILES")) {
            if (csParamValue.Right(1) != _T("\\")) {
                csParamValue += _T("\\");
            }
        }

        if (csParamName == _T("SERVICE PACK BASELINE DATE")) {
            if (csParamValue.GetLength()) {
                if (!odtServicePackBaselineDate.ParseDateTime(csParamValue, 0, 0x0409)) {
                    SDBERROR_FORMAT((_T("Error parsing SERVICE PACK BASELINE DATE parameter in makefile: %s\n"), 
                        csParamValue));
                    goto eh;
                }
                m_dtRevisionCutoff = odtServicePackBaselineDate.m_dt;
            }
        }

        if (csParamName == _T("LANGID")) {
            m_csLangID = csParamValue;
        }

        m_mapParameters.SetAt(csParamName, csParamValue);

        cpParam.Release();
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
    
}

BOOL SdbLangMap::ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB)
{
    BOOL bSuccess = FALSE;
    CString csCodePage, csLCID;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }
    m_csName.MakeUpper();

    if (!GetAttribute(_T("CODEPAGE"), pNode, &csCodePage)) {
        SDBERROR_FORMAT((_T("<LANG_MAP> requires CODEPAGE attribute:\n%s\n"),
                       GetXML(pNode)));
    }

    if (!GetAttribute(_T("LCID"), pNode, &csLCID)) {
        SDBERROR_FORMAT((_T("<LANG_MAP> requires LCID attribute:\n%s\n"),
                       GetXML(pNode)));
    }

    if (!GetAttribute(_T("HTML_CHARSET"), pNode, &m_csHtmlCharset)) {
        SDBERROR_FORMAT((_T("<LANG_MAP> requires HTML_CHARSET attribute:\n%s\n"),
                       GetXML(pNode)));
    }

    m_dwCodePage = _ttol(csCodePage);
    m_lcid = _tcstol(csLCID, NULL, 0);

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL WriteRedirMapFile(CString csFile, CString csTemplateFile, SdbDatabase* pDB)
{
    BOOL bSuccess = FALSE;
    CString csID, csURL, csTemplate, csRow;

    try {
        CStdioFile TemplateFile(csTemplateFile, CFile::typeText|CFile::modeRead);

        while (TemplateFile.ReadString(csRow)) {
            csTemplate += csRow + _T("\n");
        }
    }
    catch(CFileException* pFileEx) {

        SDBERROR_FORMAT((_T("Error reading from redir template file: %s\n"), csTemplateFile));

        pFileEx->Delete();
        goto eh;
    }
    catch(CMemoryException* pMemEx) {
        pMemEx->Delete();
        goto eh;
    }

    try {
        SdbLocalizedString* pRedir = NULL;
        CStdioFile OutputFile(csFile,   CFile::typeText |
                                        CFile::modeCreate |
                                        CFile::modeWrite |
                                        CFile::shareDenyWrite);

        OutputFile.WriteString(_T("<root>\n"));

        for (int i = 0; i < pDB->m_rgRedirs.GetSize(); i++) {

            pRedir = (SdbLocalizedString *) pDB->m_rgRedirs.GetAt(i);

            if (pRedir->m_csLangID == pDB->m_pCurrentOutputFile->m_csLangID)
            {
                csID = pRedir->m_csName;
                csURL = pRedir->m_csValue;

                csRow = csTemplate;
                csRow.Replace(_T("%REDIR_ID%"), csID);
                csRow.Replace(_T("%URL%"), csURL);

                OutputFile.WriteString(csRow);
            }
        }

        OutputFile.WriteString(_T("</root>\n"));
        OutputFile.Close();
    }
    catch(CFileException* pFileEx) {
        pFileEx->Delete();
        goto eh;
    }
    catch(CMemoryException* pMemEx) {
        pMemEx->Delete();
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

void SdbMakefile::AddHistoryKeywords(LPCTSTR szStart)
{
    LPCTSTR szEnd;
    szEnd = szStart;

    while (*szEnd) {
        if (*(szEnd+1) == _T(';') || *(szEnd+1) == _T('\0')) {
            m_rgHistoryKeywords.Add(szStart);
            m_rgHistoryKeywords[m_rgHistoryKeywords.GetSize()-1] =
            m_rgHistoryKeywords[m_rgHistoryKeywords.GetSize()-1].Left((int)(szEnd - szStart + 1));
            szStart = szEnd + 2;
        }
        szEnd++;
    }
}

SdbLangMap* SdbMakefile::GetLangMap(CString& csLangID)
{
    SdbLangMap* pLangMap = NULL;

    return (SdbLangMap *) m_rgLangMaps.LookupName(csLangID);
}

BOOL WriteAppHelpReport(SdbOutputFile* pOutputFile, SdbDatabase* pDB)
{
    BOOL bSuccess = FALSE;
    SdbAppHelp* pAppHelp;
    long i, j;
    CString csHTML, csRedirID, csRedirURL, csThisRedirURL, csURL, csTemp;
    SdbLocalizedString* pRedir = NULL;

    csRedirURL = pOutputFile->GetParameter(_T("REDIR URL"));

    try {

        CUTF16TextFile   File(pOutputFile->m_csName, CFile::typeText |
                                         CFile::modeCreate |
                                         CFile::modeWrite |
                                         CFile::shareDenyWrite);

        File.WriteString(_T("<HTML><HEAD><STYLE>td { font-family: sans-serif; font-size: 8pt; }</STYLE></HEAD><BODY>"));
        File.WriteString(_T("<TABLE BORDER=0 CELLSPACING=0>"));

        File.WriteString(_T("<TR>\n"));
        File.WriteString(_T("<TD COLSPAN=3 ALIGN=CENTER>AppHelp Pages</TD>\n"));
        File.WriteString(_T("</TR><TR><TD COLSPAN=3>&nbsp;</TD></TR>\n"));

        File.WriteString(_T("<TR BGCOLOR=#E0E0E0>\n"));
        File.WriteString(_T("<TD>App</TD>\n"));
        File.WriteString(_T("<TD>Vendor</TD>\n"));
        File.WriteString(_T("<TD>HTMLHelpID</TD>\n"));
        File.WriteString(_T("</TR>\n"));

        for (i = 0; i < pDB->m_rgAppHelps.GetSize(); i++) {
            pAppHelp = (SdbAppHelp *) pDB->m_rgAppHelps[i];

            File.WriteString(_T("<TR>\n"));

            csHTML.Format(_T("<TD>%s</TD>\n"), pAppHelp->m_pApp->GetLocalizedAppName());
            File.WriteString(csHTML);

            csHTML.Format(_T("<TD>%s</TD>\n"), pAppHelp->m_pApp->GetLocalizedVendorName());
            File.WriteString(csHTML);

            csHTML.Format(_T("<TD><A TARGET=\"_new\" HREF=\"idh_w2_%s.htm\">%s</A></TD>\n"), 
                pAppHelp->m_csName, pAppHelp->m_csName);
            File.WriteString(csHTML);

            File.WriteString(_T("</TR>\n"));

        }

        File.WriteString(_T("</TABLE><P><P>"));

        File.WriteString(_T("<TABLE BORDER=0 CELLSPACING=0>"));
        File.WriteString(_T("<TR>\n"));
        File.WriteString(_T("<TD COLSPAN=3 ALIGN=CENTER>Redirector Report</TD>\n"));
        File.WriteString(_T("</TR><TR><TD COLSPAN=3>&nbsp;</TD></TR>\n"));

        File.WriteString(_T("<TR BGCOLOR=#E0E0E0>\n"));
        File.WriteString(_T("<TD>RedirID</TD>\n"));
        File.WriteString(_T("<TD>URL</TD>\n"));
        File.WriteString(_T("<TD>FWLink Entry</TD>\n"));
        File.WriteString(_T("</TR>\n"));

        for (i = 0; i < pDB->m_rgRedirs.GetSize(); i++) {
            pRedir = (SdbLocalizedString *) pDB->m_rgRedirs.GetAt(i);

            if (pRedir->m_csLangID == pDB->m_pCurrentMakefile->m_csLangID)
            {
                csRedirID = pRedir->m_csName;
                csURL = pRedir->m_csValue;

                File.WriteString(_T("<TR>\n"));

                csHTML.Format(_T("<TD>%s</TD>\n"), csRedirID);
                File.WriteString(csHTML);

                csHTML.Format(_T("<TD>%s</TD>\n"), csURL);
                File.WriteString(csHTML);

                csThisRedirURL = csRedirURL;
                csThisRedirURL.Replace(_T("$REDIR_ID$"), csRedirID);
                csTemp.Format(_T("%X"), pDB->m_pCurrentMakefile->GetLangMap(pOutputFile->m_csLangID)->m_lcid);
                csThisRedirURL.Replace(_T("$LCID$"), csTemp);

                csHTML.Format(_T("<TD><A TARGET=\"_new\" HREF=\"%s\">%s</A></TD>\n"), 
                    csThisRedirURL, csThisRedirURL);
                File.WriteString(csHTML);

                File.WriteString(_T("</TR>\n"));
            }
        }

        File.WriteString(_T("</TABLE></BODY></HTML>"));

        File.Close();

    }
    catch(CFileException* pFileEx) {
        pFileEx->Delete();
        goto eh;
    }
    catch(CMemoryException* pMemEx) {
        pMemEx->Delete();
        goto eh;
    }

    bSuccess = TRUE;

eh:
    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\obj.h ===
///////////////////////////////////////////////////////////////////////////////
//
// File:    obj.h
//
// History: 19-Nov-99   markder     Created.
//          16-Nov-00   markder     Converted from ShimDatabase.h, rewritten
//          15-Jan-02   jdoherty    Modified code to add ID to additional tags.
//
// Desc:    This file contains definitions of the SdbDatabase object model.
//
///////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_OBJ_H__5C16373A_D713_46CD_B8BF_7755216C62E0__INCLUDED_)
#define AFX_OBJ_H__5C16373A_D713_46CD_B8BF_7755216C62E0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xml.h"
#include "utils.h"

extern DWORD   g_dwCurrentWriteFilter;
extern DATE    g_dtCurrentWriteRevisionCutoff;

//
// Common map types
//
typedef CMap<DWORD, DWORD, DWORD, DWORD> CMapDWORDToDWORD;



//
// These definitions are used by SdbMatchingFile::m_dwMask
//
#define SDB_MATCHINGINFO_SIZE                       0x00000001
#define SDB_MATCHINGINFO_CHECKSUM                   0x00000002
#define SDB_MATCHINGINFO_REGISTRY_ENTRY             0x00000004
#define SDB_MATCHINGINFO_COMPANY_NAME               0x00000008
#define SDB_MATCHINGINFO_PRODUCT_NAME               0x00000010
#define SDB_MATCHINGINFO_PRODUCT_VERSION            0x00000020
#define SDB_MATCHINGINFO_FILE_DESCRIPTION           0x00000040
#define SDB_MATCHINGINFO_BIN_FILE_VERSION           0x00000080
#define SDB_MATCHINGINFO_BIN_PRODUCT_VERSION        0x00000100
#define SDB_MATCHINGINFO_MODULE_TYPE                0x00000200
#define SDB_MATCHINGINFO_VERFILEDATEHI              0x00000400
#define SDB_MATCHINGINFO_VERFILEDATELO              0x00000800
#define SDB_MATCHINGINFO_VERFILEOS                  0x00001000
#define SDB_MATCHINGINFO_VERFILETYPE                0x00002000
#define SDB_MATCHINGINFO_PE_CHECKSUM                0x00004000
#define SDB_MATCHINGINFO_FILE_VERSION               0x00008000
#define SDB_MATCHINGINFO_ORIGINAL_FILENAME          0x00010000
#define SDB_MATCHINGINFO_INTERNAL_NAME              0x00020000
#define SDB_MATCHINGINFO_LEGAL_COPYRIGHT            0x00040000
#define SDB_MATCHINGINFO_16BIT_DESCRIPTION          0x00080000
#define SDB_MATCHINGINFO_UPTO_BIN_PRODUCT_VERSION   0x00100000
#define SDB_MATCHINGINFO_PREVOSMAJORVERSION         0x00200000
#define SDB_MATCHINGINFO_PREVOSMINORVERSION         0x00400000
#define SDB_MATCHINGINFO_PREVOSPLATFORMID           0x00800000
#define SDB_MATCHINGINFO_PREVOSBUILDNO              0x01000000
#define SDB_MATCHINGINFO_LINKER_VERSION             0x02000000
#define SDB_MATCHINGINFO_16BIT_MODULE_NAME          0x04000000
#define SDB_MATCHINGINFO_LINK_DATE                  0x08000000
#define SDB_MATCHINGINFO_UPTO_LINK_DATE             0x10000000
#define SDB_MATCHINGINFO_VER_LANGUAGE               0x20000000
#define SDB_MATCHINGINFO_UPTO_BIN_FILE_VERSION      0x40000000
//
// Possible MODULE_TYPE values
//
#define SDB_MATCHINGINFO_MODULE_TYPE_UNK    0
#define SDB_MATCHINGINFO_MODULE_TYPE_DOS    1
#define SDB_MATCHINGINFO_MODULE_TYPE_W16    2
#define SDB_MATCHINGINFO_MODULE_TYPE_W32    3

//
// Filters
//
#define SDB_FILTER_EXCLUDE_ALL      0x00000000
#define SDB_FILTER_DEFAULT          0x00000001
#define SDB_FILTER_OVERRIDE         0x00000002
#define SDB_FILTER_FIX              0x00000004
#define SDB_FILTER_APPHELP          0x00000008
#define SDB_FILTER_MSI              0x00000010
#define SDB_FILTER_DRIVER           0x00000020
#define SDB_FILTER_NTCOMPAT         0x00000040
#define SDB_FILTER_INCLUDE_ALL      0xFFFFFFFF

//
// This enumeration is used by SdbFlag::m_dwType
//
enum
{
    SDB_FLAG_UNKNOWN = 0,
    SDB_FLAG_KERNEL,
    SDB_FLAG_USER,
    SDB_FLAG_NTVDM1,
    SDB_FLAG_NTVDM2,
    SDB_FLAG_NTVDM3,
    SDB_FLAG_SHELL,
    SDB_FLAG_MAX_TYPE
};

//
// This enumeration is used by SdbOutputFile::m_OutputType
//
enum SdbOutputType
{
    SDB_OUTPUT_TYPE_UNKNOWN = 0,
    SDB_OUTPUT_TYPE_SDB,
    SDB_OUTPUT_TYPE_HTMLHELP,
    SDB_OUTPUT_TYPE_MIGDB_INX,
    SDB_OUTPUT_TYPE_MIGDB_TXT,
    SDB_OUTPUT_TYPE_WIN2K_REGISTRY,
    SDB_OUTPUT_TYPE_REDIR_MAP,
    SDB_OUTPUT_TYPE_NTCOMPAT_INF,
    SDB_OUTPUT_TYPE_NTCOMPAT_MESSAGE_INF,
    SDB_OUTPUT_TYPE_APPHELP_REPORT
};

//
// This enumeration is used by SdbCaller::m_CallerType
//
enum SdbCallerType
{
    SDB_CALLER_EXCLUDE = 0,
    SDB_CALLER_INCLUDE
};

//
// This enumeration is used by SdbShim::m_Purpose
//
enum SdbPurpose
{
    SDB_PURPOSE_GENERAL = 0,
    SDB_PURPOSE_SPECIFIC
};

//
// This enumeration is used by SdbMessage::m_Type
// These values are taken from badapps.h in shell\published
// and are compatible with Win2k, do not change
//
enum SdbAppHelpType
{
    SDB_APPHELP_NONE         = 0,
    SDB_APPHELP_NOBLOCK      = 1,
    SDB_APPHELP_HARDBLOCK    = 2,
    SDB_APPHELP_MINORPROBLEM = 3,
    SDB_APPHELP_REINSTALL    = 4,
    SDB_APPHELP_VERSIONSUB   = 5,
    SDB_APPHELP_SHIM         = 6
};

enum SdbMatchOperationType
{
    SDB_MATCH_ALL = 0,
    SDB_MATCH_ANY
};

//
// This enumeration is used by SdbData::m_DataType
//
enum SdbDataValueType
{
    eValueNone   = REG_NONE,
    eValueDWORD  = REG_DWORD,
    eValueQWORD  = REG_QWORD,
    eValueString = REG_SZ,
    eValueBinary = REG_BINARY
};

//
// Forward declarations of all classes
//
class SdbApp;
class SdbExe;
class SdbFile;
class SdbShim;
class SdbFlag;
class SdbData;
class SdbAction;
class SdbPatch;
class SdbLayer;
class SdbCaller;
class SdbMessage;
class SdbLibrary;
class SdbShimRef;
class SdbFlagRef;
class SdbAppHelp;
class SdbDatabase;
class SdbLayerRef;
class SdbAppHelpRef;
class SdbMsiPackage;
class SdbContactInfo;
class SdbMsiTransform;
class SdbWinNTUpgrade;
class SdbMatchingFile;
class SdbMessageField;
class SdbWin9xMigration;
class SdbMsiTransformRef;
class SdbMsiCustomAction;
class SdbMessageTemplate;
class SdbMatchingRegistryEntry;

class SdbMakefile;
class SdbInputFile;
class SdbOutputFile;

///////////////////////////////////////////////////////////////////////////////
//
// SdbArrayElement
//
// All elements contained in a SdbArray or SdbRefArray must be derived
// from this base class. It defines the basic m_csName property which is
// used throughout the object model for array lookup, sorting etc.
//
class SdbArrayElement
{
public:
    CString          m_csName;
    ULONGLONG        m_ullKey;          // 64-bit key used to sort element within array
    SdbDatabase*     m_pDB;             // Pointer to root database object.
    DWORD            m_dwFilter;
    DWORD            m_dwSPMask;
    DWORD            m_dwOSPlatform;
    CString          m_csOSVersionSpec;
    CString          m_csLangID;
    DATE             m_dtLastRevision;

    SdbArrayElement() :
        m_ullKey(0),
        m_pDB(NULL),
        m_dwSPMask(0xFFFFFFFF),
        m_dwOSPlatform(OS_PLATFORM_ALL),
        m_dwFilter(SDB_FILTER_DEFAULT),
        m_dtLastRevision(0) {}

    virtual ~SdbArrayElement() { }

    virtual int Compare(const SdbArrayElement* pElement);

    virtual ULONGLONG MakeKey() {
        return SdbMakeIndexKeyFromString(m_csName);
    }

    virtual void PropagateFilter(DWORD dwFilter);

    //
    // Virtual persistance functions
    //
    virtual BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    virtual BOOL WriteToSDB(PDB pdb);
    virtual BOOL WriteRefToSDB(PDB pdb);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbArrayT
//
// This template is an extension of CPtrArray which
// designates that the array owns its elements or simply
// references them. If it owns them, it will delete them during
// destruction. Array elements must be derived from SdbArrayElement
// to be properly destructed.
//
// SdbArray and SdbRefArray are class instances of the template.
//
template <class T, BOOL bOwnsElements> class SdbArrayT;
template <class T> class SdbArray    : public SdbArrayT<T, TRUE>  { };
template <class T> class SdbRefArray : public SdbArrayT<T, FALSE> { };

template <class T, BOOL bOwnsElements> class SdbArrayT : public CPtrArray
{
public:
    CMapStringToPtr m_mapName;

    //
    // 'LookupName' looks up an element in the array by name
    //
    SdbArrayElement* LookupName( LPCTSTR lpszName, long* piStart = NULL ) {

        return LookupName(lpszName, NULL, piStart);
    }

    SdbArrayElement* LookupName( LPCTSTR lpszName, LPCTSTR lpszLangID, long* piStart = NULL ) {

        CString csName;
        SdbArrayElement* pElement;

        if (lpszLangID) {
            csName.Format(_T("%s\\%s"), lpszLangID, lpszName);
        } else {
            csName = lpszName;
        }
        csName.MakeUpper();

        if (!m_mapName.Lookup(csName, (LPVOID&)pElement)) {
            pElement = NULL;
        }

        return pElement;
    }

    ~SdbArrayT()
    {
        LONG i = 0;
        if( bOwnsElements ) {
            for( i = 0; i < (LONG)GetSize(); i++ ) {
                delete (SdbArrayElement *) GetAt( i );
            }
        }
    }

    //
    // 'AddOrdered' will add the element to the array sorted by name
    //
    int AddOrdered(SdbArrayElement* pElement)
    {

        INT iLeft  = 0;
        INT iRight = (INT) (GetSize() - 1);
        INT i = -1;
        INT iCmp;
        BOOL bFound = FALSE;
        SdbArrayElement* pElementCompare;

        if (0 == pElement->m_ullKey) {
            pElement->m_ullKey = pElement->MakeKey();
        }

        if (iRight >= 0) {

            do {

                i = (iLeft + iRight) / 2; // middle ground
                pElementCompare = (SdbArrayElement*)GetAt(i); // element that we're going to try

                iCmp = pElement->Compare(pElementCompare);

                if (iCmp <= 0) {
                    iRight = i - 1;
                }
                if (iCmp >= 0) {
                    iLeft = i + 1;
                }

            } while (iRight >= iLeft);
        }

        //
        // if the element was found -- we insert right where it's at
        // if not -- to the right of the current element
        //

        bFound = (iLeft - iRight) > 1;
        if (!bFound) {
            i = iRight + 1;
        }

        CPtrArray::InsertAt(i, pElement);

        return i;
    }

    //
    // 'Add' will simply add an element to the array, and add
    // to the name map that is used for look up.
    //
    INT Add(SdbArrayElement* pElement, SdbDatabase* pDB = NULL, BOOL bOrdered = FALSE)
    {
        CString csName;
        pElement->m_pDB = pDB;
        csName.MakeUpper();

        if (pElement->m_csLangID.GetLength()) {
            csName.Format(_T("%s\\%s"), pElement->m_csLangID, pElement->m_csName);
        } else {
            csName = pElement->m_csName;
        }
        csName.MakeUpper();

        m_mapName.SetAt(csName, (LPVOID)pElement);

        // also insert at the right place according to the imposed order
        return (INT)(bOrdered ? AddOrdered(pElement) : CPtrArray::Add(pElement));
    }

    int Append(const SdbArray<T>& rgArray)
    {
        SdbArrayElement* pElement;
        int nFirstElement = -1;
        int nThisElement = -1;

        //
        // Cannot own elements
        //
        if (!bOwnsElements) {
            for (long i = 0; i < rgArray.GetSize(); i++) {
                pElement = (SdbArrayElement *) rgArray.GetAt(i);

                nThisElement = Add(pElement, pElement->m_pDB);

                if (nFirstElement == -1) {
                    nFirstElement = nThisElement;
                }
            }
        }

        return nFirstElement;
    }

    DWORD GetFilteredCount(DWORD dwFilter, DATE dtRevisionCutoff = 0)
    {
        DWORD dwCount = 0;
        long i = 0;
        SdbArrayElement* pElem;

        for (i = 0; i < GetSize(); i++) {
            pElem = (SdbArrayElement *) GetAt(i);

            if ((pElem->m_dwFilter & dwFilter) &&
                dtRevisionCutoff <= pElem->m_dtLastRevision) {
                dwCount++;
            }
        }

        return dwCount;
    }

    virtual void PropagateFilter(DWORD dwFilter)
    {
        long i = 0;
        SdbArrayElement* pElem;

        for (i = 0; i < GetSize(); i++) {
            pElem = (SdbArrayElement *) GetAt(i);

            pElem->PropagateFilter(dwFilter);
        }
    }

    //
    // 'ReadFromXML' will perform an XQL query on the pParentNode object and
    // populate the array with members -- each of which read themselves in from
    // the nodes returned by the query.
    //
    BOOL ReadFromXML(LPCTSTR szXQL, SdbDatabase* pDB, IXMLDOMNode* pParentNode, SdbArray<T>* pOwnerArray = NULL, BOOL bAddOrdered = FALSE, LPCTSTR lpszKeyAttribute = _T("NAME"))
    {
        BOOL                bSuccess            = FALSE;
        XMLNodeList         XQL;
        IXMLDOMNodePtr      cpNode;
        T*                  pNewObject          = NULL;
        LONG                i;
        CString             csName;

        if (!XQL.Query(pParentNode, szXQL)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        for (i = 0; i < (LONG)XQL.GetSize(); i++) {

            pNewObject = NULL;

            if (!XQL.GetItem(i, &cpNode)) {
                SDBERROR_PROPOGATE();
                goto eh;
            }

            if (bOwnsElements) {
                pNewObject = (T*) new T();

                if (pNewObject == NULL) {
                    CString csFormat;
                    csFormat.Format(_T("Error allocating new object to read \"%s\" tag"), szXQL);
                    SDBERROR(csFormat);
                    goto eh;
                }

                if (!pNewObject->ReadFromXML(cpNode, pDB)) {
                    SDBERROR_PROPOGATE();
                    goto eh;
                }
            } else {
                if (lpszKeyAttribute) {
                    if (!GetAttribute(lpszKeyAttribute, cpNode, &csName)) {
                        CString csFormat;
                        csFormat.Format(_T("Error retrieving %s attribute on tag:\n\n%s\n\n"),
                            lpszKeyAttribute, szXQL, GetXML(cpNode));
                        SDBERROR(csFormat);
                        goto eh;
                    }
                }

                if (pOwnerArray == NULL) {
                    SDBERROR(_T("Internal error: SdbArray::ReadFromXML() requires non-NULL ")
                        _T("pOwnerArray for reference arrays."));
                    goto eh;
                }

                pNewObject = (T*) pOwnerArray->LookupName(csName);

                if (!pNewObject && g_bStrict) {
                    CString csFormat;
                    csFormat.Format(_T("Tag \"%s\" references unknown LIBRARY item \"%s\":\n\n%s\n\n"),
                        szXQL, csName, GetXML(cpNode));

                    SDBERROR(csFormat);
                    goto eh;
                }
            }

            if (pNewObject) {
                Add(pNewObject, pDB, bAddOrdered);
            }

            cpNode.Release();
        }

        bSuccess = TRUE;

eh:
        return bSuccess;
    }

    //
    // 'WriteToSDB' will write each of the elements in the array out
    // to the SDB database specified by pdb.
    //
    BOOL WriteToSDB(PDB pdb, BOOL bReference = FALSE)
    {
        LONG i;
        T*   pOb;

        for (i = 0; i < (LONG)GetSize(); i++) {
            pOb = (T*) GetAt(i);

            if ((g_dwCurrentWriteFilter & pOb->m_dwFilter) &&
                (pOb->m_dtLastRevision != 0 ? g_dtCurrentWriteRevisionCutoff <= pOb->m_dtLastRevision : TRUE)) {
                    if (bReference) {
                        if (!pOb->WriteRefToSDB(pdb)) {
                            return FALSE;
                        }
                    } else {
                        if (!pOb->WriteToSDB(pdb)) {
                            return FALSE;
                        }
                    }
                }
        }

        return TRUE;
    }

};

///////////////////////////////////////////////////////////////////////////////
//
// SdbLocalizedString
//
// The SdbLocalizedString object is simply a named string that also has a
// LangID associated with it.
//
class SdbLocalizedString : public SdbArrayElement
{
public:
    CString     m_csValue;
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbLibrary
//
// The SdbLibrary object contains the shims, patches and kernel flags and
// layers that are referenced by App or Exe objects. NOTE: It is possible
// to compile a database without entries in Library, with the assumption
// that any references will be resolved when further databases in the
// search path are opened.
//
class SdbLibrary : public SdbArrayElement
{
public:
    SdbArray<SdbFile>               m_rgFiles;
    SdbArray<SdbShim>               m_rgShims;
    SdbArray<SdbPatch>              m_rgPatches;
    SdbArray<SdbLayer>              m_rgLayers;
    SdbArray<SdbFlag>               m_rgFlags;
    SdbArray<SdbCaller>             m_rgCallers;
    SdbArray<SdbMsiTransform>       m_rgMsiTransforms;

    void PropagateFilter(DWORD dwFilter)
    {
        SdbArrayElement::PropagateFilter(dwFilter);

        m_rgFiles.PropagateFilter(m_dwFilter);
        m_rgShims.PropagateFilter(m_dwFilter);
        m_rgPatches.PropagateFilter(m_dwFilter);
        m_rgLayers.PropagateFilter(m_dwFilter);
        m_rgFlags.PropagateFilter(m_dwFilter);
        m_rgCallers.PropagateFilter(m_dwFilter);
        m_rgMsiTransforms.PropagateFilter(m_dwFilter == SDB_FILTER_EXCLUDE_ALL ? SDB_FILTER_EXCLUDE_ALL : SDB_FILTER_MSI);
    }

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);

    //
    // method to clear out tagIDs before writing the db out
    //
    VOID SanitizeTagIDs(VOID);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbDatabase
//
// This is the base class for the three database classes. It contains
// any common properties between the three.
//
class SdbDatabase : public SdbArrayElement
{
public:
    SdbDatabase() :
        m_ID(GUID_NULL),
        m_pCurrentApp(NULL),
        m_pCurrentMakefile(NULL),
        m_pCurrentInputFile(NULL),
        m_pCurrentOutputFile(NULL),
        m_iiWildcardExeIndex(NULL),
        m_iiModuleExeIndex(NULL),
        m_iiMsiIDIndex(NULL),
        m_iiDrvIDIndex(NULL),
        m_iiShimIndex(NULL),
        m_iiMsiTransformIndex(NULL),
        m_iiMsiPackageIndex(NULL)
    {
        m_Library.m_pDB = this;
    }

    GUID            m_ID;

    SdbMakefile*    m_pCurrentMakefile;
    SdbInputFile*   m_pCurrentInputFile;
    SdbOutputFile*  m_pCurrentOutputFile;
    GUID            m_CurrentDBID;  // last written out dbid
    CString         m_csCurrentLangID;

    IXMLDOMNodePtr  m_cpCurrentDatabaseNode;

    SdbLibrary      m_Library;

    //
    // Holding variables that are used while reading/writing
    //
    INDEXID         m_iiWildcardExeIndex;
    INDEXID         m_iiModuleExeIndex;
    INDEXID         m_iiExeIndex;
    INDEXID         m_iiShimIndex;
    INDEXID         m_iiMsiTransformIndex;
    INDEXID         m_iiMsiPackageIndex;
    INDEXID         m_iiMsiIDIndex;
    INDEXID         m_iiDrvIDIndex;
    INDEXID         m_iiHtmlHelpID;
    SdbApp*         m_pCurrentApp;

    IXMLDOMDocumentPtr  m_cpTempXMLDoc;
    IXMLDOMNodePtr      m_cpTempXML;

    SdbArray<SdbApp>                    m_rgApps;
    SdbArray<SdbAction>                 m_rgAction;
    SdbRefArray<SdbExe>                 m_rgExes;
    SdbRefArray<SdbExe>                 m_rgWildcardExes;
    SdbRefArray<SdbExe>                 m_rgModuleExes; // exes that match on module name
    SdbRefArray<SdbWinNTUpgrade>        m_rgWinNTUpgradeEntries;
    SdbRefArray<SdbMsiPackage>          m_rgMsiPackages;

    CString                             m_csHTMLHelpFirstScreen;
    SdbArray<SdbContactInfo>            m_rgContactInfo;
    SdbArray<SdbMessage>                m_rgMessages;
    SdbArray<SdbMessageTemplate>        m_rgMessageTemplates;
    SdbArray<SdbLocalizedString>        m_rgHTMLHelpTemplates;
    SdbArray<SdbLocalizedString>        m_rgHTMLHelpFirstScreens;
    SdbArray<SdbLocalizedString>        m_rgLocalizedAppNames;
    SdbArray<SdbLocalizedString>        m_rgLocalizedVendorNames;
    SdbArray<SdbLocalizedString>        m_rgRedirs;

    SdbArray<SdbAppHelp>                m_rgAppHelps;

    //
    // Maps used to map IDs to their objects
    //
    CMapStringToPtr     m_mapExeIDtoExe;

    SdbExe*     LookupExe(DWORD dwTagID);

    BOOL        ReplaceFields(CString csXML, CString* pcsReturn, SdbRefArray<SdbMessageField>* prgFields);
    BOOL        ReplaceFieldsInXML(IXMLDOMNode* cpTargetNode, SdbRefArray<SdbMessageField>* prgFields);
    BOOL        RedirectLinks(CString* pcsXML, LCID lcid, CString csRedirURL);
    BOOL        HTMLtoText(CString csXML, CString* pcsReturn);

    DWORD       GetNextSequentialID(CString csType);

    BOOL WriteAppHelpRefTag(
            PDB pdb,
            CString csHTMLHelpID,
            LCID langID,
            CString csURL,
            CString csAppTitle,
            CString csSummary);

    BOOL ConstructMessageParts(
            SdbAppHelp* pAppHelp,
            SdbMessage* pMessage,
            CString& csLangID,
            DWORD* pdwHTMLHelpID,
            CString* pcsURL,
            CString* pcsContactInformation,
            CString* pcsAppTitle,
            CString* pcsSummary,
            CString* pcsDetails);

    BOOL ConstructMigrationMessage(
            SdbWin9xMigration* pMigApp,
            SdbMessage* pMessage,
            CString* pcsMessage);

    void PropagateFilter(DWORD dwFilter)
    {
        SdbArrayElement::PropagateFilter(dwFilter);

        m_rgApps.PropagateFilter(m_dwFilter == SDB_FILTER_EXCLUDE_ALL ? SDB_FILTER_EXCLUDE_ALL : SDB_FILTER_FIX);
        m_rgAction.PropagateFilter(m_dwFilter == SDB_FILTER_EXCLUDE_ALL ? SDB_FILTER_EXCLUDE_ALL : SDB_FILTER_FIX);
        m_Library.PropagateFilter(m_dwFilter == SDB_FILTER_EXCLUDE_ALL ? SDB_FILTER_EXCLUDE_ALL : SDB_FILTER_FIX);
    }

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);

    BOOL IsStandardDatabase(VOID);

};

///////////////////////////////////////////////////////////////////////////////
//
// SdbApp
//
// The SdbApp object groups Exe objects by application title and vendor. Note
// that it contains only references to exes: Exe objects are owned by the
// database object.
//
class SdbApp : public SdbArrayElement
{
public:
    CString                 m_csVendor;
    CString                 m_csVendorXML;
    CString                 m_csVersion;
    SdbArray<SdbExe>        m_rgExes;
    SdbArray<SdbMsiPackage> m_rgMsiPackages;

    SdbArray<SdbWin9xMigration>
                            m_rgWin9xMigEntries;
    SdbArray<SdbWinNTUpgrade>
                            m_rgWinNTUpgradeEntries;

    SdbRefArray<SdbAppHelpRef> m_rgAppHelpRefs;

    CString                 m_csKeywords;
    BOOL                    m_bSeen;
    GUID                    m_ID;

    SdbApp():
        m_ID(GUID_NULL){}

    CString GetLocalizedAppName();
    CString GetLocalizedAppName(CString csLangID);
    CString GetLocalizedVendorName();
    CString GetLocalizedVendorName(CString csLangID);

    void PropagateFilter(DWORD dwFilter)
    {
        SdbArrayElement::PropagateFilter(dwFilter);

        m_rgExes.PropagateFilter(m_dwFilter);
        m_rgMsiPackages.PropagateFilter(m_dwFilter == SDB_FILTER_EXCLUDE_ALL ? SDB_FILTER_EXCLUDE_ALL : SDB_FILTER_MSI);
        m_rgWin9xMigEntries.PropagateFilter(m_dwFilter);
        m_rgWinNTUpgradeEntries.PropagateFilter(m_dwFilter);
    }

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbContactInfo
//
// The SdbContactInfo object contains all contact information for the vendor
// portion of the AppHelp dialog. These values can be overridden in the
// AppHelp object.
//
class SdbContactInfo : public SdbArrayElement
{
public:
    CString     m_csXML;
    GUID        m_ID;

    SdbContactInfo() :
        m_ID(GUID_NULL){}

    BOOL        ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbMessageTemplate
//
// The SdbMessageTemplate object contains AppHelp messages to be used as 'templates'
// for SdbMessage objects. A SdbMessage object can specify a template and
// use its m_csText and m_csHTML values, or override one of them.
//
class SdbMessageTemplate : public SdbArrayElement
{
public:
    CString     m_csSummaryXML;
    CString     m_csDetailsXML;

    BOOL        ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbMessage
//
// The SdbMessage object contains all information required for an AppHelp
// dialog in localized form. A SdbAppHelp object references a single
// SdbMessage object, but all of the text is localized in multiple languages.
// A SdbMessage object can derive from a SdbMessageTemplate object, which
// supplies the default m_csText and m_csHTML values.
//
class SdbMessage : public SdbArrayElement
{
public:
    SdbMessageTemplate*         m_pTemplate;
    SdbArray<SdbMessageField>   m_rgFields;

    CString     m_csContactInfoXML; // Overriding ContactInfo object
    CString     m_csSummaryXML;     // Overriding Template object
    CString     m_csDetailsXML;     // Overriding Template object
    GUID        m_ID;

    SdbMessage() :
        m_ID(GUID_NULL),
        m_pTemplate(NULL) {}

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbAppHelp
//
// The SdbAppHelp object is an instantiation of an AppHelp message. An
// SdbAppHelp is the only object that contains the HTMLHELPID attribute,
// which is needed for each unique AppHelp entry in the CHM file.
//
// HTMLHELPID is stored in SdbAppHelp::m_csName.
//
class SdbAppHelp : public SdbArrayElement
{
public:
    CString         m_csMessage;
    SdbApp*         m_pApp;
    SdbAppHelpType  m_Type;
    BOOL            m_bBlockUpgrade;
    CString         m_csURL;            // custom URL, if supplied

    SdbAppHelp() :
        m_bBlockUpgrade(FALSE),
        m_Type(SDB_APPHELP_NOBLOCK),
        m_pApp(NULL) { }

    void PropagateFilter(DWORD dwFilter)
    {
        //
        // We OR this one unconditionally to achieve the following
        // effect: If an HTMLHELPID is used at least once, it will
        // be included. If it is not used at all (given the current
        // filtering), it will never get an SDB_FILTER_APPHELP bit
        // set.
        //
        m_dwFilter |= dwFilter;
    }
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbAppHelpRef
//
// The SdbAppHelpRef object is an instantiation of an AppHelp object.
//
class SdbAppHelpRef : public SdbArrayElement
{
public:
    BOOL            m_bApphelpOnly;
    SdbAppHelp*     m_pAppHelp;
    IXMLDOMNodePtr  m_cpNode;

    SdbAppHelpRef() :
        m_bApphelpOnly(FALSE),
        m_pAppHelp(NULL)
        {}

    void PropagateFilter(DWORD dwFilter)
    {
        SdbArrayElement::PropagateFilter(dwFilter);

        if (m_pAppHelp) {
            m_pAppHelp->PropagateFilter(m_dwFilter);
        }
    }

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbMessageField
//
// The SdbMessageField object contains a name-value pair that can is used to
// replace fields embedded in templates.
//
class SdbMessageField : public SdbArrayElement
{
public:
    CString         m_csValue;

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbMatchingFile
//
// The SdbMatchingFile object contains all file information about files that
// must be matched on for app identification. m_dwMask is used to indicate
// which of the criteria contain valid values (see defines at top of file for
// mask).
//
class SdbMatchingFile : public SdbArrayElement
{
public:
    DWORD             m_dwMask;
    DWORD             m_dwSize;
    DWORD             m_dwChecksum;
    CString           m_csCompanyName;
    CString           m_csProductName;
    CString           m_csProductVersion;
    CString           m_csFileDescription;
    ULONGLONG         m_ullBinFileVersion;
    ULONGLONG         m_ullBinProductVersion;
    DWORD             m_dwVerLanguage;

    DWORD             m_dwModuleType;
    DWORD             m_dwFileDateMS;
    DWORD             m_dwFileDateLS;
    DWORD             m_dwFileOS;
    DWORD             m_dwFileType;
    ULONG             m_ulPECheckSum;
    DWORD             m_dwLinkerVersion;
    CString           m_csFileVersion;
    CString           m_csOriginalFileName;
    CString           m_csInternalName;
    CString           m_csLegalCopyright;
    CString           m_cs16BitDescription;
    CString           m_cs16BitModuleName;
    ULONGLONG         m_ullUpToBinProductVersion;
    ULONGLONG         m_ullUpToBinFileVersion;
    DWORD             m_dwPrevOSMajorVersion;
    DWORD             m_dwPrevOSMinorVersion;
    DWORD             m_dwPrevOSPlatformID;
    DWORD             m_dwPrevOSBuildNo;

    time_t            m_timeLinkDate;
    time_t            m_timeUpToLinkDate;

    BOOL              m_bMatchLogicNot;
    CString           m_csServiceName;
    CString           m_csRegistryEntry;

    SdbMatchingFile() :
        m_dwMask(NULL),
        m_bMatchLogicNot(FALSE) {}

    BOOL IsValidForWin2k(CString csXML);

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);
};


///////////////////////////////////////////////////////////////////////////////
//
// SdbMsiPackage
//
// The SdbMsiPackage object represents an Installer package that must be fixed via
// application of a custom MSI_TRANSFORM
//
class SdbMsiPackage : public SdbArrayElement
{
public:

    //
    // Pointer to the (parent) app object
    //
    SdbApp*                      m_pApp;

    //
    // supplemental data for MSI_PACKAGE object
    // it is used to further identify the package
    //
    SdbArray<SdbData>            m_rgData;

    //
    // MSI_TRANSFORM stuff designed to fix this package (references transforms in lib)
    //
    SdbArray<SdbMsiTransformRef> m_rgMsiTransformRefs;

    GUID                         m_MsiPackageID; // package id (non-unique guid)

    GUID                         m_ID;           // exe id (unique guid)

    //
    // RUNTIME_PLATFORM attribute
    //
    DWORD                        m_dwRuntimePlatform;

    //
    // OS_SKU attribute
    //
    DWORD                        m_dwOSSKU;

    //
    // apphelp
    //
    SdbAppHelpRef                m_AppHelpRef;

    //
    // shims and layers don't cut it, we need another entity here
    //
    SdbArray<SdbMsiCustomAction> m_rgCustomActions;


    //
    // we override the default MakeKey function
    // in order to sort the content by keys made from guid IDs instead of the name
    // secondary sort order will be provided by name
    //
    virtual ULONGLONG MakeKey() {
        return MAKEKEYFROMGUID(&m_ID);
    }

    SdbMsiPackage() :
        m_ID(GUID_NULL),
        m_dwRuntimePlatform(RUNTIME_PLATFORM_ANY),
        m_dwOSSKU(OS_SKU_ALL) {}

    void PropagateFilter(DWORD dwFilter)
    {
        SdbArrayElement::PropagateFilter(dwFilter);

        m_AppHelpRef.PropagateFilter(m_dwFilter == SDB_FILTER_EXCLUDE_ALL ? SDB_FILTER_EXCLUDE_ALL : SDB_FILTER_APPHELP);
        m_rgData.PropagateFilter(m_dwFilter);
        m_rgMsiTransformRefs.PropagateFilter(m_dwFilter);
        m_rgCustomActions.PropagateFilter(m_dwFilter);
    }

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbMsiCustomAction
//
// The SdbMsiCustomAction object encapsulates custom actions and what we do
// for them (shim/etc)
//


class SdbMsiCustomAction : public SdbArrayElement
{
public:
    SdbArray<SdbShimRef>    m_rgShimRefs;
    SdbArray<SdbLayerRef>   m_rgLayerRefs;

    void PropagateFilter(DWORD dwFilter)
    {
        SdbArrayElement::PropagateFilter(dwFilter);

        m_rgShimRefs.PropagateFilter(m_dwFilter);
        m_rgLayerRefs.PropagateFilter(m_dwFilter);
    }

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);

};



///////////////////////////////////////////////////////////////////////////////
//
// SdbMsiTransform
//
// The SdbMsiTransform object encapsulates an MSI_TRANSFORM remedy.
//
class SdbMsiTransform : public SdbArrayElement
{
public:
    SdbMsiTransform() :
        m_tiTagID(NULL),
        m_pSdbFile(NULL) {}

    TAGID           m_tiTagID;              // tagid of this record
    SdbFile*        m_pSdbFile;             // pointer to the transform file
    CString         m_csMsiTransformFile;   // transform filename
    CString         m_csDesc;               // description

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbMsiTransformRef
//
// The SdbMsiTransformRef object is a reference to an SdbMsiTransform object
// in the library.
//
class SdbMsiTransformRef : public SdbArrayElement
{
public:
    SdbMsiTransformRef() :
      m_pMsiTransform(NULL) {}

    SdbMsiTransform* m_pMsiTransform;

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);
};

#define MATCH_DEFAULT ((DWORD)-1)


///////////////////////////////////////////////////////////////////////////////
//
// SdbExe
//
// The SdbExe object represents an executable that must be patched/shimmed.
// The m_pApp member can be NULL, or it can contain a pointer to the SdbApp
// object that groups it with other SdbExe objects.
//
class SdbExe : public SdbArrayElement
{
public:
    SdbApp*                     m_pApp;
    SdbArray<SdbShimRef>        m_rgShimRefs;
    SdbArray<SdbLayerRef>       m_rgLayerRefs;
    SdbArray<SdbFlagRef>        m_rgFlagRefs;
    SdbArray<SdbMatchingFile>   m_rgMatchingFiles;
    SdbArray<SdbData>           m_rgData;
    SdbArray<SdbAction>         m_rgAction;
    SdbRefArray<SdbPatch>       m_rgPatches;
    SdbAppHelpRef               m_AppHelpRef;
    CString                     m_csSXSManifest;

    GUID            m_ID;
    BOOL            m_bWildcardInName;
    BOOL            m_bMatchOnModule;

    DWORD           m_dwTagID;
    BOOL            m_bSeen;

    DWORD           m_dwMatchMode; // modes include NORMAL, EXCLUSIVE, or ADDITIVE

    DWORD           m_dwRuntimePlatform;
    DWORD           m_dwOSSKU;

    SdbExe() :
        m_pApp(NULL),
        m_dwTagID(0),
        m_ID(GUID_NULL),
        m_dwMatchMode(MATCH_DEFAULT),
        m_bWildcardInName(FALSE),
        m_dwRuntimePlatform(RUNTIME_PLATFORM_ANY),
        m_dwOSSKU(OS_SKU_ALL),
        m_bMatchOnModule(FALSE) {m_dwOSPlatform = OS_PLATFORM_I386;}

    BOOL IsValidForWin2k(CString csXML);

    void PropagateFilter(DWORD dwFilter)
    {
        SdbArrayElement::PropagateFilter(dwFilter);

        m_rgShimRefs.PropagateFilter(m_dwFilter);
        m_rgLayerRefs.PropagateFilter(m_dwFilter);
        m_rgFlagRefs.PropagateFilter(m_dwFilter);
        m_rgMatchingFiles.PropagateFilter(m_dwFilter);
        m_rgData.PropagateFilter(m_dwFilter);
        m_rgAction.PropagateFilter(m_dwFilter);
        m_rgPatches.PropagateFilter(m_dwFilter);
        m_AppHelpRef.PropagateFilter(m_dwFilter == SDB_FILTER_EXCLUDE_ALL ? SDB_FILTER_EXCLUDE_ALL : SDB_FILTER_APPHELP);
    }

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);
    int  Compare(const SdbArrayElement* pElement);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbFile
//
// The SdbFile object represents a binary file that can be stored in the
// database.
//
class SdbFile : public SdbArrayElement
{
public:
    SdbFile() :
        m_tiTagID(NULL) {}

    TAGID       m_tiTagID;

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbShim
//
// The SdbShim object represents a shim, which contains Win32 API hooks.
// A shim's 'purpose' can be marked as GENERAL or SPECIFIC -- if it is GENERAL,
// it is appropriate for reuse, otherwise it is application specific.
//
class SdbShim : public SdbArrayElement
{
public:
    SdbShim() :
      m_ID(GUID_NULL),
      m_tiTagID(NULL),
      m_Purpose(SDB_PURPOSE_SPECIFIC),
      m_bApplyAllShims(FALSE) {m_dwOSPlatform = OS_PLATFORM_I386;}

    CString         m_csShortName;
    CString         m_csDesc;
    TAGID           m_tiTagID;
    CString         m_csDllFile;
    SdbPurpose      m_Purpose;
    BOOL            m_bApplyAllShims;
    GUID            m_ID;

    SdbArray<SdbCaller> m_rgCallers;

    void PropagateFilter(DWORD dwFilter)
    {
        SdbArrayElement::PropagateFilter(dwFilter);

        m_rgCallers.PropagateFilter(m_dwFilter);
    }

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbCaller
//
// The SdbCaller object contains inclusion/exclusion information for shims.
// It allows hooked APIs to be cased by the calling instruction address. For
// example, it is known that ATL.DLL requires accurate OS version information,
// and so any calls to GetVersionExA from ATL.DLL are assured to call the
// original API, rather than the shim hook. This is achieved by adding
// an EXCLUDE subtag to the SHIM tag.
//
class SdbCaller : public SdbArrayElement
{
public:
    CString         m_csModule;
    SdbCallerType   m_CallerType;

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbShimRef
//
// The SdbShimRef object is simply a reference to a SdbShim object that exists
// in a library. It has separate inclusion/exclusion information, which is
// given higher priority than any such information in the SHIM tag within the
// corresponding library. It can contain an optional command line, which is
// passed in to the shim DLL via GetHookAPIs.
//
class SdbShimRef : public SdbArrayElement
{
public:
    SdbShimRef() :
      m_dwRecID(NULL),
      m_pShim(NULL) {}

    DWORD       m_dwRecID;
    SdbShim*    m_pShim;
    CString     m_csCommandLine;

    SdbArray<SdbCaller> m_rgCallers;
    SdbArray<SdbData>   m_rgData;


    void PropagateFilter(DWORD dwFilter)
    {
        SdbArrayElement::PropagateFilter(dwFilter);

        m_rgCallers.PropagateFilter(m_dwFilter);
        m_rgData.PropagateFilter(m_dwFilter);
    }

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbPatch
//
// The SdbPatch object contains the patch binary that is parsed by the app
// compat mechanism at run-time. It contains patching instructions, including
// any bits to patch an executable's code with.
//
class SdbPatch : public SdbArrayElement
{
private:
    BYTE*       m_pBlob;
    DWORD       m_dwBlobMemSize;
    DWORD       m_dwBlobSize;

public:
    TAGID       m_tiTagID;
    BOOL        m_bUsed;
    GUID        m_ID;

    SdbPatch() :
        m_pBlob(NULL),
        m_tiTagID(0),
        m_dwBlobMemSize(0),
        m_dwBlobSize(0),
        m_ID(GUID_NULL),
        m_bUsed(FALSE) {m_dwOSPlatform = OS_PLATFORM_I386;}

    virtual ~SdbPatch()
    {
        if( m_pBlob != NULL )
            delete m_pBlob;
    }


    PBYTE   GetBlobBytes(void) {return m_pBlob;}
    DWORD   GetBlobSize(void)  {return m_dwBlobSize;}

    void    AddBlobBytes( LPVOID pBytes, DWORD dwSize );
    void    ClearBlob();

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);
    BOOL WriteRefToSDB(PDB pdb);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbFlag
//
// The SdbFlag object contains a mask which is used by kernel-mode
// components in special compatibility casing constructs. These flags can be
// turned on by adding the FLAG subtag to an EXE tag.
//
class SdbFlag : public SdbArrayElement
{
public:
    CString     m_csDesc;
    ULONGLONG   m_ullMask;
    DWORD       m_dwType;
    TAGID       m_tiTagID;
    SdbPurpose  m_Purpose;
    GUID        m_ID;

    SdbFlag() :
      m_ID(GUID_NULL),
      m_tiTagID(0),
      m_Purpose(SDB_PURPOSE_SPECIFIC),
      m_ullMask(0) {m_dwOSPlatform = OS_PLATFORM_I386;}

    static ULONGLONG MakeMask(SdbRefArray<SdbFlag>* prgFlags, DWORD dwType);
    static TAG TagFromType(DWORD dwType);

    BOOL SetType(CString csType);

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbFlagRef
//
// The SdbFlagRef object is simply a reference to a SdbFlag object that exists
// in a library.
//
class SdbFlagRef : public SdbArrayElement
{
public:
    SdbFlagRef() :
      m_pFlag(NULL) {}

    SdbFlag* m_pFlag;

    CString  m_csCommandLine;

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbLayer
//
// The SdbLayer object contains a set of shims and/or kernel flags that can be
// turned on to invoke a "compatibility mode". Presently, if the environment
// variable __COMPAT_LAYER is set to the name of this object, all shims and
// kernel flags contained by the layer will be invoked.
//
class SdbLayer : public SdbArrayElement
{
public:
    CString                     m_csDesc;
    CString                     m_csDisplayName;
    TAGID                       m_tiTagID;
    GUID                        m_ID;

    SdbArray<SdbShimRef>        m_rgShimRefs;
    SdbArray<SdbFlagRef>        m_rgFlagRefs;

    SdbLayer ():
        m_ID(GUID_NULL){m_dwOSPlatform = OS_PLATFORM_I386;}

    void PropagateFilter(DWORD dwFilter)
    {
        SdbArrayElement::PropagateFilter(dwFilter);

        m_rgShimRefs.PropagateFilter(m_dwFilter);
        m_rgFlagRefs.PropagateFilter(m_dwFilter);
    }

    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbLayerRef
//
// The SdbLayerRef object contains a reference to a layer that exists in the
// library. It exists to allow <EXE> entries that reference a layer defined
// in another database.
//
class SdbLayerRef : public SdbArrayElement
{
public:
    SdbLayerRef() :
      m_pLayer(NULL) {}

    SdbLayer*                   m_pLayer;
    SdbArray<SdbData>           m_rgData;


    BOOL ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL WriteToSDB(PDB pdb);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbData
//
// The SdbData object contains a name-value pair that can be queried
// at runtime for any data.
//
class SdbData : public SdbArrayElement
{
private:
    SdbDataValueType    m_DataType;
    DWORD               m_dwDataSize;
    //
    // nested Data elements
    //
    SdbArray<SdbData>   m_rgData;

public:

    union {
        DWORD        m_dwValue;    // m_DataType == REG_DWORD
        ULONGLONG    m_ullValue;   // m_DataType == REG_QWORD
        LPTSTR       m_szValue;    // m_DataType == REG_SZ
        LPBYTE       m_pBinValue;  // m_DataType == REG_BINARY
    };

    SdbData() :
        m_DataType(eValueNone),
        m_dwDataSize(0) {}

    ~SdbData() {
        Clear();
    }

    void PropagateFilter(DWORD dwFilter)
    {
        SdbArrayElement::PropagateFilter(dwFilter);

        m_rgData.PropagateFilter(m_dwFilter);
    }

    SdbDataValueType GetValueType() { return m_DataType; }

    void    Clear();
    BOOL    SetValue(SdbDataValueType DataType, LPCTSTR lpValue);

    BOOL    ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL    WriteToSDB(PDB pdb);
};

///////////////////////////////////////////////////////////////////////////////
//
// SdbAction
//
// The SdbAction object contains the type of the action and Data elements that
// provide any data needed to perform this action.
//
class SdbAction: public SdbArrayElement
{
private:
    CString             m_csType;
    SdbArray<SdbData>   m_rgData;

public:

    SdbAction() {}
    ~SdbAction() {}

    void PropagateFilter(DWORD dwFilter)
    {
        SdbArrayElement::PropagateFilter(dwFilter);

        m_rgData.PropagateFilter(m_dwFilter);
    }

    BOOL    ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
    BOOL    WriteToSDB(PDB pdb);
};

class SdbMatchOperation : public SdbArrayElement
{
public:
    SdbMatchOperationType       m_Type;

    SdbArray<SdbMatchingFile>   m_rgMatchingFiles;
    SdbArray<SdbMatchOperation> m_rgSubMatchOps;

    SdbMatchOperation() :
        m_Type(SDB_MATCH_ALL) {}

    void PropagateFilter(DWORD dwFilter)
    {
        SdbArrayElement::PropagateFilter(dwFilter);

        m_rgMatchingFiles.PropagateFilter(m_dwFilter);
        m_rgSubMatchOps.PropagateFilter(m_dwFilter);
    }

    BOOL    ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
};


class SdbWin9xMigration : public SdbArrayElement
{
public:
    SdbWin9xMigration() :
      m_pApp(NULL),
      m_bShowInSimplifiedView(FALSE) {}

    CString     m_csSection;
    CString     m_csMessage;
    GUID        m_ID;
    BOOL        m_bShowInSimplifiedView;

    SdbApp*     m_pApp;

    SdbMatchOperation m_MatchOp;

    BOOL    ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
};

class SdbMatchingRegistryEntry : public SdbArrayElement
{
public:
    CString     m_csValueName;
    CString     m_csValue;

    BOOL    ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
};

class SdbWinNTUpgrade : public SdbArrayElement
{
public:
    SdbWinNTUpgrade() :
      m_ID(GUID_NULL),
      m_pApp(NULL) {}

    SdbAppHelpRef            m_AppHelpRef;
    SdbMatchingFile          m_MatchingFile;
    SdbMatchingRegistryEntry m_MatchingRegistryEntry;

    SdbApp*         m_pApp;
    GUID            m_ID;

    void PropagateFilter(DWORD dwFilter)
    {
        SdbArrayElement::PropagateFilter(dwFilter);

        m_AppHelpRef.PropagateFilter(m_dwFilter == SDB_FILTER_EXCLUDE_ALL ? SDB_FILTER_EXCLUDE_ALL : SDB_FILTER_NTCOMPAT);
    }

    BOOL    ReadFromXML(IXMLDOMNode* pNode, SdbDatabase* pDB);
};

#endif // !defined(AFX_OBJ_H__5C16373A_D713_46CD_B8BF_7755216C62E0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\mig.h ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    mig.h
//
// History: 01-Jan-01   VadimB      Resurrected.
//
// Desc:    This file contains all object definitions used by the
//          Migdb-related code.
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef __MIG_H__
#define __MIG_H__

///////////////////////////////////////////////////////////////////////////////
//
// MigDb support
// objects that translate the entries into MigDB entries
//

//
// Migration entry matching operation
// for our purposes we always use MIGOP_AND
//

typedef enum tagMIGMATCHOPERATION {
    MIGOP_AND,
    MIGOP_OR
} MIGMATCHOPERATION;

//
// attribute types used by migdb
//
typedef enum tagMIGATTRTYPE {
    NONE,
    COMPANYNAME,
    FILEDESCRIPTION,
    FILEVERSION,
    INTERNALNAME,
    LEGALCOPYRIGHT,
    ORIGINALFILENAME,
    PRODUCTNAME,
    PRODUCTVERSION,
    FILESIZE,
    ISMSBINARY,
    ISWIN9XBINARY,
    INWINDIR,
    INCATDIR,
    INHLPDIR,
    INSYSDIR,
    INPROGRAMFILES,
    ISNOTSYSROOT,
    CHECKSUM,
    EXETYPE,
    DESCRIPTION,
    INPARENTDIR,
    INROOTDIR,
    PNPID,
    HLPTITLE,
    ISWIN98,
    HASVERSION,
    REQFILE,
    BINFILEVER,
    BINPRODUCTVER,
    FILEDATEHI,
    FILEDATELO,
    FILEVEROS,
    FILEVERTYPE,
    FC,
    UPTOBINPRODUCTVER,
    UPTOBINFILEVER,
    SECTIONKEY,
    REGKEYPRESENT,
    ATLEASTWIN98,
    ARG
} MIGATTRTYPE;

//
// Attribute table entry --
// used to describe how particular attribute appears in Migdb vs our XML
//
typedef struct tagATTRLISTENTRY {
    MIGATTRTYPE MigAttrType;     // type as it appears in migration db (tag)
    TCHAR*      szOutputName;    // attribute as it's supposed to appear  in .inx file

    DWORD       XMLAttrType;     // type as it appears in xml (dword/mask)
    TCHAR*      szAttributeName; // attribute as it appears in .xml file (ascii)
} ATTRLISTENTRY, *PATTRLISTENTRY;

//
// Macro to define migdb entry when the entry name is the same for both xml and inf
//
#define MIGDB_ENTRY(entry) { entry, NULL, SDB_MATCHINGINFO_##entry, _T(#entry) }

//
// Macro to define migdb entry when the entry name is not the same
// entry with equivalent entry being present in xml
//
#define MIGDB_ENTRY2(entry, entXML, entInf) \
    { entry, _T(#entInf), SDB_MATCHINGINFO_##entXML, _T(#entXML) }

//
// entry with no equivalence in xml
//
#define MIGDB_ENTRY3(entry, entInf) \
    { entry, _T(#entInf), 0, NULL }

#define MIGDB_ENTRY4(entry) \
    { entry, _T(#entry), 0, NULL }

#define MIGDB_ENTRY5(entry, entInc, entXML) \
    { entry, _T(#entry), SDB_MATCHINGINFO_##entInc, _T(#entXML) }

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MigDB parser
//
//

class MigEntry;     // collection of attributes
class MigSection;   // section (collection of entries or other sections)
class MigAttribute; // indivitual attribute
class MigDatabase;  // migration database

// this is a "named" collection of attributes
// equivalent to a line in an inf file
//
//
class MigEntry : public SdbArrayElement {

public:

// construction
    MigEntry(MigDatabase* pMigDB) :
        m_pMigDB(pMigDB) {};

// properties

    //
    // implied: m_csName
    //
    SdbArray<MigAttribute>   m_rgAttrs;         // attributes (collection of pointers of type MigAttribute*)

    //
    // pointer to mig database
    //
    MigDatabase*             m_pMigDB;

// methods

    //
    //  Dump inf into a file
    //
    CString dump(void);

    // format entry name (exe name)
    //
    CString FormatName(void);

    //
    // translate from the matching file into MigEntry
    //
    MigEntry& operator=(SdbMatchingFile& rMatchingFile);

};

//
// these are "matching exes" - aka "Section"
//
//
class MigSection : public SdbArrayElement {
    // implied: m_csName (aka "section name or exe name")
public:
    // each element of the array
    // may be of the type MigMatchingFile OR
    //                    MigSection
    // we determine which one that is using rtti
    //
    MigSection(MigDatabase* pMigDB) :
            m_pMigDB(pMigDB),
            m_nEntry(0),
            m_bTopLevel(FALSE),
            m_Operation(MIGOP_AND) {};

    SdbArray<SdbArrayElement>  m_rgEntries;        // these are matching exes or subsections
    MIGMATCHOPERATION          m_Operation;        // operation (AND/OR)
    BOOL                       m_bTopLevel;        // top level Section or not

    LONG                       m_nEntry;

    MigDatabase*               m_pMigDB;


    MigSection& operator=(SdbMatchOperation& rMatch);
    //
    // method to dump the section into the file
    //
    CString dump(LPCTSTR lpszDescription = NULL, int* pIndexContents = NULL, BOOL bNoHeader = FALSE, BOOL bInline = TRUE);

};

//
//  MigAttribute
//

class MigAttribute : public SdbArrayElement {

public: // methods
    MigAttribute(MigDatabase* pMigDB) :
            m_pMigDB(pMigDB),
            m_type(NONE),
            m_bNot(FALSE),
            m_pSection(NULL) {};

    ~MigAttribute() {
        if (m_pSection != NULL) {
            delete m_pSection;
        }
    }

    // implied m_csName

public: // data
    MIGATTRTYPE  m_type;

    BOOL         m_bNot; // is operation NOT applied

    union {
        LONG           m_lValue;   // long value for the attribute
        ULONG          m_ulValue;  // ulong value
        DWORD          m_dwValue;
        ULONGLONG      m_ullValue; // unsigned long long
        ULARGE_INTEGER m_uliValue; // unsigned large integer
        // if this attribute is REQFile then we use special
        // value along with the pointer to Attribute collection
    };

    CString            m_csValue;          // string value
    MigSection*        m_pSection;     // section (used for ARG and REQFILE)
    MigDatabase*       m_pMigDB;

    CString dump(void);

};

class MigApp : public SdbArrayElement {

public:
    MigApp(MigDatabase* pMigDB) :
        m_pMigDB(pMigDB),
        m_pSection(NULL),
        m_bShowInSimplifiedView(FALSE) {}

    ~MigApp() {
        if (m_pSection != NULL) {
            delete m_pSection;
        }
    }

    // implied m_csName
    CString      m_csSection;     // name used in .inf file
    CString      m_csDescription; // description from .inf file
    // section that is used (can represent single file or a real section)
    MigSection*  m_pSection;      // section (contents of the app tag)
    BOOL         m_bShowInSimplifiedView;

    SdbArray<SdbArrayElement>  m_rgArgs;        // ARGs that go with this...

    MigDatabase* m_pMigDB;        // Mig db

    CString dump(VOID);
    MigApp& operator=(SdbWin9xMigration& rMig);

};


class MigDatabase {

public:

    MigDatabase() :
        m_dwStringCount(0),
        m_dwExeCount(0) { }


    ~MigDatabase() {
        POSITION pos = m_mapSections.GetStartPosition();
        CString  csSection;
        SdbArray<SdbArrayElement>* prgApp;
        while(pos) {
            m_mapSections.GetNextAssoc(pos, csSection, (LPVOID&)prgApp);
            delete prgApp;
        }
    }

    //
    // methods:
    //

    CString GetAppTitle(
        SdbWin9xMigration* pAppMig
        );

    BOOL MigDatabase::AddApp(  // adds application to the migdb
        MigApp*       pApp
        );

    CString GetSectionFromExe(
        SdbExe* pExe
        );

    CString GetDescriptionStringID(
        SdbWin9xMigration* pMigration
        );

    CString GetDescriptionString(
        SdbWin9xMigration* pMigration
        );

    CString FormatDescriptionStringID(
        SdbWin9xMigration* pMigration
        );

    BOOL Populate(
        VOID
        );

    BOOL PopulateStrings(
        VOID
        );

    BOOL DumpMigDBStrings(
        LPCTSTR lpszFilename
        );

    BOOL DumpMigDBInf(
        LPCTSTR lpszFilename
        );


    //
    // just the temporary storage for db we're working with (this is the db that has exes -> which is AppHelpDatabase)
    //
    SdbDatabase*    m_pFixDatabase;

    SdbDatabase*    m_pAppHelpDatabase;
    SdbDatabase*    m_pMessageDatabase;


    //
    // output - supplemental sections
    //
    CStringArray        m_rgOut; // output strings that contain supplemental sections

    //
    // String table, maps string ids to string content
    //
    CMapStringToString  m_mapStringsOut;

    //
    // maps section names to arrays of objects of type MigApp
    //
    CMapStringToPtr     m_mapSections;

    //
    // simple counter for strings to aid in the process of generating unique names
    //
    DWORD               m_dwStringCount;

    //
    // count of exes to keep entries unique
    //
    DWORD               m_dwExeCount;

};

class CMigDBException : public CException {
public:
    CMigDBException(LPCTSTR lpszError = NULL) {
        if (lpszError != NULL) {
            m_csError = lpszError;
        }
    }
    virtual BOOL GetErrorMessage(LPTSTR lpszMessage, UINT nMaxError, PUINT puiHelpContext = NULL) {
        if (m_csError.GetLength() > 0 && nMaxError > (UINT)m_csError.GetLength()) {
            StringCchCopy(lpszMessage, nMaxError, (LPCTSTR)m_csError);
            return TRUE;
        }

        return FALSE;
    }

    CString m_csError;

};


BOOL WriteMigDBFile(
    SdbDatabase*        pFixDatabase,
    SdbDatabase* pAppHelpDatabase,
    SdbDatabase*    pMessageDatabase,
    LPCTSTR                lpszFileName
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\registry.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    registry.cpp
//
// History: 21-Mar-00   markder     Created.
//          13-Dec-00   markder     Renamed from appshelp.cpp
//
// Desc:    This file contains all code needed to produce matching info registry
//          files and setup files (INX) for the Windows 2000 (RTM) shim mechanism.
//
////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "registry.h"

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   DumpString, DumpDword, DumpBinVersion, InsertString
//
//  Desc:   Helper functions for CreateMessageBlob.
//
void DumpString( DWORD dwId, PBYTE* ppBlob, LONG* pnTotalBytes, CString& csString )
{
    DWORD   dwLen;

    **(DWORD**)ppBlob = dwId;
    *ppBlob += sizeof(DWORD);

    dwLen = csString.GetLength();
    **(DWORD**)ppBlob = ( dwLen + 1) * sizeof(WCHAR);
    *ppBlob += sizeof(DWORD);

    CopyMemory(*ppBlob, T2W((LPTSTR) (LPCTSTR) csString), (dwLen + 1) * sizeof(WCHAR));
    *ppBlob += (dwLen + 1) * sizeof(WCHAR);
    *pnTotalBytes += ((dwLen + 1) * sizeof(WCHAR) + 2 * sizeof(DWORD));
}

void DumpDword( DWORD dwId, PBYTE* ppBlob, LONG* pnTotalBytes, DWORD dwVal )
{
    **(DWORD**)ppBlob = dwId;
    *ppBlob += sizeof(DWORD);

    **(DWORD**)ppBlob = sizeof(DWORD);
    *ppBlob += sizeof(DWORD);

    **(DWORD**)ppBlob = dwVal;
    *ppBlob += sizeof(DWORD);

    *pnTotalBytes += 3 * sizeof(DWORD);
}

void DumpBinVersion(DWORD dwId, PBYTE* ppBlob, LONG* pnTotalBytes, ULONGLONG ullVersion)
{
   ULONGLONG ullMask  = 0;
   ULONGLONG ullVer   = 0;
   WORD      wVerPart = 0;
   LONG      j;
   PBYTE     pBlob    = *ppBlob;

   for( j = 0; j < 4; j++ ) {
      wVerPart = (WORD) (ullVersion >> (j*16));
      if (wVerPart != 0xFFFF) {
            ullVer += ((ULONGLONG)wVerPart) << (j*16);
            ullMask += ((ULONGLONG) 0xFFFF) << (j*16);
      }
   }

   //
   // id
   //
   *(DWORD*)pBlob = dwId;
   pBlob += sizeof(DWORD);

   // size
   *(DWORD*)pBlob = 2 * sizeof(ULONGLONG);
   pBlob += sizeof(DWORD);

   // version
   CopyMemory(pBlob, &ullVer, sizeof(ULONGLONG));
   pBlob += sizeof(ULONGLONG);

   // mask
   CopyMemory(pBlob, &ullMask, sizeof(ULONGLONG));
   pBlob += sizeof(ULONGLONG);

   *pnTotalBytes += (2 * sizeof(ULONGLONG) + 2 * sizeof(DWORD));
   *ppBlob = pBlob;
}

void InsertString( CString* pcs, DWORD dwIndex, CString csInsertedString )
{
    *pcs = pcs->Left( dwIndex ) + csInsertedString + pcs->Right( pcs->GetLength() - dwIndex );
}

BOOL WriteStringToFile(
    HANDLE hFile,
    CString& csString)
{
    CHAR  szBuffer[1024];
    DWORD dwConvBufReqSize;
    DWORD dwConvBufSize = sizeof(szBuffer);
    BOOL  b; // this will be set if default char is used, we make no use of this
    LPSTR szConvBuf = szBuffer;
    BOOL  bAllocated = FALSE;
    BOOL  bSuccess;
    DWORD dwBytesWritten;


    dwConvBufReqSize = WideCharToMultiByte(CP_ACP, 0, csString, -1, NULL, NULL, 0, &b);
    if (dwConvBufReqSize > sizeof(szBuffer)) {
        szConvBuf = (LPSTR) new CHAR[dwConvBufReqSize];
        dwConvBufSize  = dwConvBufReqSize;
        bAllocated = TRUE;
    }

    WideCharToMultiByte(CP_ACP, 0, csString, -1, szConvBuf, dwConvBufSize, 0, &b);

    bSuccess = WriteFile( hFile, szConvBuf, dwConvBufReqSize - 1, &dwBytesWritten, NULL);
    if (bAllocated) {
        delete [] szConvBuf;
    }

    return bSuccess;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   FreeRegistryBlob, CreateRegistryBlob
//
//  Desc:   Creates a binary blob in the format of Windows 2000's
//          Message registry keys.
//
void FreeRegistryBlob( PBYTE pBlob )
{
    delete pBlob;
}

BOOL CreateRegistryBlob(
   SdbExe* pExe,
   PBYTE* ppBlob,
   DWORD* pdwSize,
   DWORD dwMessageID = 0,  // these two are optional
   DWORD dwBlobType  = 6)
{
    USES_CONVERSION;

    BOOL    bSuccess = FALSE;

    PBYTE   pBlob = (PBYTE) new BYTE[4096];
    PBYTE   pStartOfBlob = pBlob;

    DWORD   dwBufSize = 4096;
    DWORD   dwReqBufSize = 0;
    LONG    nTotalBytes = 0;
    LONG    i, j;
    LONG    nBytes;

    SdbMatchingFile* pMFile;
    FILETIME FileTime;
    CString* pcsFilename;
    ULONGLONG ullMask = 0;
    WORD wVerPart = 0;
    ULONGLONG ullVer = 0;

    *pdwSize = 0;

    // Prolog
    *((DWORD*)pBlob + 0) = 3 * sizeof(DWORD);

    // message id

    *((DWORD*)pBlob + 1) = dwMessageID;

    // type is not shim anymore

    *((DWORD*)pBlob + 2) = dwBlobType; // shim type

    pBlob += 3 * sizeof(DWORD);
    nTotalBytes += 3 * sizeof(DWORD);

    for( i = 0; i < pExe->m_rgMatchingFiles.GetSize(); i++ )
    {
        pMFile = (SdbMatchingFile *) pExe->m_rgMatchingFiles[i];

        if( pMFile->m_csName == _T("*") ) {
            pcsFilename = &(pExe->m_csName);
        } else {
            pcsFilename = &(pMFile->m_csName);
        }

        DumpString( VTID_REQFILE, &pBlob, &nTotalBytes, *pcsFilename );

        if( pMFile->m_dwMask & SDB_MATCHINGINFO_SIZE )
            DumpDword( VTID_FILESIZE, &pBlob, &nTotalBytes, pMFile->m_dwSize );

        if( pMFile->m_dwMask & SDB_MATCHINGINFO_CHECKSUM )
            DumpDword( VTID_CHECKSUM, &pBlob, &nTotalBytes, pMFile->m_dwChecksum );

        if( pMFile->m_dwMask & SDB_MATCHINGINFO_COMPANY_NAME )
            DumpString( VTID_COMPANYNAME, &pBlob, &nTotalBytes, pMFile->m_csCompanyName );

        if( pMFile->m_dwMask & SDB_MATCHINGINFO_PRODUCT_NAME )
            DumpString( VTID_PRODUCTNAME, &pBlob, &nTotalBytes, pMFile->m_csProductName );

        if( pMFile->m_dwMask & SDB_MATCHINGINFO_PRODUCT_VERSION )
            DumpString( VTID_PRODUCTVERSION, &pBlob, &nTotalBytes, pMFile->m_csProductVersion );

        if( pMFile->m_dwMask & SDB_MATCHINGINFO_FILE_DESCRIPTION )
            DumpString( VTID_FILEDESCRIPTION, &pBlob, &nTotalBytes, pMFile->m_csFileDescription );

        if( pMFile->m_dwMask & SDB_MATCHINGINFO_BIN_FILE_VERSION )
            DumpBinVersion(VTID_BINFILEVER, &pBlob, &nTotalBytes, pMFile->m_ullBinFileVersion);

        if( pMFile->m_dwMask & SDB_MATCHINGINFO_BIN_PRODUCT_VERSION )
            DumpBinVersion(VTID_BINPRODUCTVER, &pBlob, &nTotalBytes, pMFile->m_ullBinProductVersion);

        if (pMFile->m_dwMask & SDB_MATCHINGINFO_MODULE_TYPE)
           DumpDword( VTID_EXETYPE, &pBlob, &nTotalBytes, pMFile->m_dwModuleType );

        if (pMFile->m_dwMask & SDB_MATCHINGINFO_VERFILEDATEHI)
           DumpDword( VTID_FILEDATEHI, &pBlob, &nTotalBytes, pMFile->m_dwFileDateMS );

        if (pMFile->m_dwMask & SDB_MATCHINGINFO_VERFILEDATELO)
           DumpDword( VTID_FILEDATELO, &pBlob, &nTotalBytes, pMFile->m_dwFileDateLS );

        if (pMFile->m_dwMask & SDB_MATCHINGINFO_VERFILEOS)
           DumpDword( VTID_FILEVEROS, &pBlob, &nTotalBytes, pMFile->m_dwFileOS );

        if (pMFile->m_dwMask & SDB_MATCHINGINFO_VERFILETYPE)
           DumpDword( VTID_FILEVERTYPE, &pBlob, &nTotalBytes, pMFile->m_dwFileType );

        if (pMFile->m_dwMask & SDB_MATCHINGINFO_PE_CHECKSUM)
           DumpDword( VTID_PECHECKSUM, &pBlob, &nTotalBytes, (DWORD)pMFile->m_ulPECheckSum );

        if (pMFile->m_dwMask & SDB_MATCHINGINFO_FILE_VERSION)
           DumpString( VTID_FILEVERSION, &pBlob, &nTotalBytes, pMFile->m_csFileVersion );

        if (pMFile->m_dwMask & SDB_MATCHINGINFO_ORIGINAL_FILENAME)
           DumpString( VTID_ORIGINALFILENAME, &pBlob, &nTotalBytes, pMFile->m_csOriginalFileName );

        if (pMFile->m_dwMask & SDB_MATCHINGINFO_INTERNAL_NAME)
           DumpString( VTID_INTERNALNAME, &pBlob, &nTotalBytes, pMFile->m_csInternalName );

        if (pMFile->m_dwMask & SDB_MATCHINGINFO_LEGAL_COPYRIGHT)
           DumpString( VTID_LEGALCOPYRIGHT, &pBlob, &nTotalBytes, pMFile->m_csLegalCopyright );

        if (pMFile->m_dwMask & SDB_MATCHINGINFO_16BIT_DESCRIPTION)
           DumpString( VTID_16BITDESCRIPTION, &pBlob, &nTotalBytes, pMFile->m_cs16BitDescription );

        if (pMFile->m_dwMask & SDB_MATCHINGINFO_UPTO_BIN_PRODUCT_VERSION)
           DumpBinVersion(VTID_UPTOBINPRODUCTVER, &pBlob, &nTotalBytes, pMFile->m_ullUpToBinProductVersion);

        if (pMFile->m_dwMask & SDB_MATCHINGINFO_LINK_DATE) {
           SDBERROR(_T("LINK_DATE not allowed for Win2k registry matching."));
           goto eh;
        }

        if (pMFile->m_dwMask & SDB_MATCHINGINFO_UPTO_LINK_DATE) {
           SDBERROR(_T("UPTO_LINK_DATE not allowed for Win2k registry matching."));
           goto eh;
        }
    }

    // Terminator
    *((DWORD*)pBlob) = 0;
    pBlob += sizeof(DWORD);
    nTotalBytes += sizeof(DWORD);

    bSuccess = TRUE;

eh:

    if( bSuccess ) {
        *pdwSize = nTotalBytes;
        *ppBlob = pStartOfBlob;
    } else if( pStartOfBlob ) {
        FreeRegistryBlob( pStartOfBlob );
        *pdwSize = 0;
        *ppBlob = NULL;
    }

    return bSuccess;
}

BOOL RegistryBlobToString(PBYTE pBlob, DWORD dwBlobSize, CString& csBlob)
{
   DWORD i;
   CString csTemp;

   csBlob = "";
   for (i = 0; i < dwBlobSize; i++, ++pBlob) {
      csTemp.Format( _T("%02X"), (DWORD)*pBlob );

      if (i == dwBlobSize - 1) {   // this is the last char
         csTemp += _T("\r\n");
      }
      else {
         if ((i+1) % 27 == 0) {    // time to do end of the line ?
            csTemp += _T(",\\\r\n");
         }
         else {
            csTemp += _T(",");    // just add comma
         }
      }
      csBlob += csTemp;
   }

   return(TRUE);
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   CreateMessageRegEntry, WriteMessageRegistryFiles
//
//  Desc:   These functions create Win2k-style registry entries for the old
//          Message mechanism, which exists in SHELL32!ShellExecute.
//
BOOL CreateMessageRegEntry(
   SdbExe* pExe,
   DWORD dwExeCount,
   CString& csReg,
   CString& csInx)
{
   PBYTE pBlob = NULL;
   BOOL bSuccess = FALSE;
   DWORD dwBlobSize = 0;
   CString csRegEntry, csInxEntry;
   CString csApp;
   CString csBlob;
   CString csTemp;

   if (!CreateRegistryBlob(pExe,
                           &pBlob,
                           &dwBlobSize,
                           (DWORD)_ttol(pExe->m_AppHelpRef.m_pAppHelp->m_csName),
                           pExe->m_AppHelpRef.m_pAppHelp->m_Type)) {
       SDBERROR(_T("Error in CreateRegistryBlob()"));
       goto eh;
   }

    csApp = pExe->m_pApp->m_csName;
    csApp.Remove(_T(' '));

    csTemp.Format(_T("[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility\\%s]\r\n\"%05X %s\"=hex:"),
    pExe->m_csName, dwExeCount, csApp.Left(25));

    csRegEntry = csTemp;

    csTemp.Format(_T("HKLM,\"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility\\%s\",\"%05X %s\",0x00030003,\\\r\n"),
    pExe->m_csName, dwExeCount, csApp.Left(25) );

    csInxEntry = csTemp;

    //
    // now grab the blob
    //
    if (!RegistryBlobToString(pBlob, dwBlobSize, csBlob)) {
       SDBERROR(_T("Error in RegistryBlobToString()"));
       goto eh;
    }

    csRegEntry += csBlob;
    csInxEntry += csBlob;

    csReg = csRegEntry;
    csInx = csInxEntry;

    bSuccess = TRUE;

eh:

    if (NULL != pBlob) {
    FreeRegistryBlob( pBlob );
    }

    return(bSuccess);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   CreateRegistryBlob, WriteRegistryFiles
//
//  Desc:   These functions create a Win2k-style registry entries for both
//          Message as well as a stub entry for shimming that provides no
//          additional matching info past EXE name. This allows the 'new'
//          Win2k version of the shim engine to 'bootstrap' itself into memory
//          via the original mechanism and then perform more detailed matching
//          in its own way.
//
BOOL CreateWin2kExeStubRegistryBlob(
   SdbExe* pExe,
   PBYTE* ppBlob,
   DWORD* pdwSize,
   DWORD dwMessageID = 0,  // these two are optional
   DWORD dwBlobType  = 6)
{
    USES_CONVERSION;

    BOOL    bSuccess = FALSE;
    DWORD   dwBufSize = sizeof(DWORD) * 4;
    LONG    nTotalBytes = 0;
    PBYTE   pStartOfBlob;

    PBYTE   pBlob = (PBYTE) new BYTE[dwBufSize];
    pStartOfBlob = pBlob;                                       
    *pdwSize = 0;
    if (NULL != pBlob) {

        // Prolog
        *((DWORD*)pBlob + 0) = 3 * sizeof(DWORD); // 0x0C 00 00 00

        // message id
        *((DWORD*)pBlob + 1) = dwMessageID;       // 0x00 00 00 00 

        // type is shim 
        *((DWORD*)pBlob + 2) = dwBlobType;        // 0x06 00 00 00

        pBlob += 3 * sizeof(DWORD);
        nTotalBytes += 3 * sizeof(DWORD);

        // Terminator
        *((DWORD*)pBlob) = 0;
        pBlob += sizeof(DWORD);
        nTotalBytes += sizeof(DWORD);

        *pdwSize = (DWORD)nTotalBytes;
        *ppBlob = pStartOfBlob;
        bSuccess = TRUE;
    }
    
    return bSuccess;
}


BOOL WriteRegistryFiles(
    SdbDatabase* pDatabase,
    CString csRegFile,
    CString csInxFile,
    BOOL bAddExeStubs)
{
    CString csRegEntry, csInxEntry, csTemp, csCmdLineREG, csCmdLineINX,
            csTemp1, csApp, csExeName;
    SdbExe* pExe;
    SdbApp* pApp;
    long i, j, l, m;
    DWORD k, dwBlobSize, dwBytesWritten, dwExeCount = 0;
    PBYTE pBlob;
    BOOL b, bSuccess = FALSE;
    CMapStringToPtr mapNames;
    SdbApp* pAppValue;
    
    HANDLE hRegFile = NULL;
    HANDLE hInxFile = NULL;

    hRegFile = CreateFile( csRegFile, GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
    hInxFile = CreateFile( csInxFile, GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

    if( hRegFile == INVALID_HANDLE_VALUE ||
        hInxFile == INVALID_HANDLE_VALUE ) {
        SDBERROR_FORMAT((_T("Error creating registry files:\n%s\n%s\n"), csRegFile, csInxFile));
        goto eh;
    }

    if( ! WriteFile( hRegFile, "REGEDIT4\r\n\r\n", strlen("REGEDIT4\r\n\r\n"), &dwBytesWritten, NULL ) ) {
        SDBERROR(_T("Error writing header to .reg file.\n"));
        goto eh;
    }


    //
    // loop through all the apps, make apphelp entries
    //
    for (i = 0; i < pDatabase->m_rgExes.GetSize(); i++) {

        pExe = (SdbExe *) pDatabase->m_rgExes[i];

        if (pExe->m_AppHelpRef.m_pAppHelp == NULL) { // not an apphelp entry
            continue;
        }

        if (!(pExe->m_dwFilter & g_dwCurrentWriteFilter)) {
            continue;
        }


        b = CreateMessageRegEntry(pExe, dwExeCount, csRegEntry, csInxEntry);
        if (!b) {
            SDBERROR(_T("Error creating reg entry.\n"));
            goto eh;
        }

        if (!WriteStringToFile(hRegFile, csRegEntry)) {
            SDBERROR(_T("Error writing reg entry.\n"));
            goto eh;
        }

        if (!WriteStringToFile(hInxFile, csInxEntry)) {
            SDBERROR(_T("Error writing inx entry.\n"));
            goto eh;
        }

        ++dwExeCount;
    }

    //
    // Add the Win2k EXE stubs to bootstrap the new shim mechanism
    //
    if (bAddExeStubs) {

        for( i = 0; i < pDatabase->m_rgApps.GetSize(); i++ )
        {
            pApp = (SdbApp *) pDatabase->m_rgApps[i];

            csApp = pApp->m_csName;
            csApp.Remove(_T(' '));

            for( j = 0; j < pApp->m_rgExes.GetSize(); j++ )
            {
                pExe = (SdbExe *) pApp->m_rgExes[j];


                //
                // check whether this entry is apphelp-only
                // if so, skip to the next exe
                //
                if (pExe->m_AppHelpRef.m_pAppHelp) {
                    if (pExe->m_AppHelpRef.m_bApphelpOnly) {
                        continue;
                    }
                }

                if (pExe->m_bWildcardInName) {
                    continue;
                }

                if (!(pExe->m_dwFilter & g_dwCurrentWriteFilter)) {
                    continue;
                }

                csExeName = pExe->m_csName;
                csExeName.MakeUpper();
    
                // now we have to create an application entry -- if we have not hit this
                // exe name before
                if (mapNames.Lookup(csExeName, (VOID*&)pAppValue)) {
                    continue;
                }


                csRegEntry.Empty();
                csInxEntry.Empty();


                if (!CreateWin2kExeStubRegistryBlob(pExe, &pBlob, &dwBlobSize)) {
                    SDBERROR(_T("Error creating EXE stub.\n"));
                    goto eh;
                }


                //
                // To reduce the amount of space that we take, we substitute
                // app name for something short
                //
                csApp = _T("x");

                csTemp.Format( _T("[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility\\%s]\r\n\"%s\"=hex:"),
                                   pExe->m_csName, csApp.Left(25) );

                csRegEntry += csTemp;

                csTemp.Format( _T("HKLM,\"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility\\%s\",\"%s\",0x00030003,\\\r\n"),
                                   pExe->m_csName, csApp.Left(25) );

                csInxEntry += csTemp;

                RegistryBlobToString(pBlob, dwBlobSize, csTemp);
                csRegEntry += csTemp;
                csInxEntry += csTemp;

                csCmdLineREG.Empty();
                csCmdLineINX.Empty();

                csTemp.Format( _T("\"DllPatch-%s\"=\"%s\"\r\n"),
                               csApp.Left(25), csCmdLineREG );

                csRegEntry += csTemp;

                csTemp.Format( _T("HKLM,\"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility\\%s\",\"DllPatch-%s\",0x00000002,\"%s\"\r\n"),
                               pExe->m_csName, csApp.Left(25), csCmdLineINX );

                csInxEntry += csTemp;

                csRegEntry += _T("\r\n");
                csInxEntry += _T("\r\n");

                if (!WriteStringToFile(hRegFile, csRegEntry)) {
                    SDBERROR(_T("Error writing reg line.\n"));
                    goto eh;
                }

                if (!WriteStringToFile(hInxFile, csInxEntry)) {
                    SDBERROR(_T("Error writing inx line.\n"));
                    goto eh;
                }

                ++dwExeCount;

                // now update the map
                mapNames.SetAt(csExeName, (PVOID)pExe);

                FreeRegistryBlob( pBlob );
            }
        }
    }

    bSuccess = TRUE;

eh:
    if( hRegFile )
        CloseHandle( hRegFile );

    if( hInxFile )
        CloseHandle( hInxFile );

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\read.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    read.cpp
//
// History: 16-Nov-00   markder     Created.
//          15-Jan-02   jdoherty    Modified code to add ID to additional tags.
//
// Desc:    This file contains all code needed to manipulate the MSXML
//          COM object, walk the document object model (DOM) for an XML
//          file, and populate the SdbDatabase internal C++ object.
//
////////////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "xml.h"
#include "make.h"
#include "typeinfo.h"

typedef struct tagAttrStringTableEntry {
    LPCTSTR pszName;
    DWORD   dwValue;
}  ATTRSTRINGTABLEENTRY, *PATTRSTRINGTABLEENTRY;


ATTRSTRINGTABLEENTRY g_rgStringSeverity[] = {
    { _T("HARDBLOCK"  ), SDB_APPHELP_HARDBLOCK},
    { _T("MINORPROBLEM"), SDB_APPHELP_MINORPROBLEM},
    { _T("NOBLOCK"    ), SDB_APPHELP_NOBLOCK},
    { _T("REINSTALL"  ), SDB_APPHELP_REINSTALL},
    { _T("SHIM"       ), SDB_APPHELP_SHIM},
    { _T("VERSIONSUB" ), SDB_APPHELP_VERSIONSUB},
    { _T("NONE"       ), SDB_APPHELP_NONE}
};

ATTRSTRINGTABLEENTRY g_rgStringModuleType[] = {
    { _T("NONE"),         MT_UNKNOWN_MODULE},
    { _T("UNKNOWN"),      MT_UNKNOWN_MODULE},
    { _T("WIN16"),        MT_W16_MODULE},
    { _T("WIN32"),        MT_W32_MODULE},
    { _T("DOS"),          MT_DOS_MODULE},
};

ATTRSTRINGTABLEENTRY g_rgStringYesNo[] = {
    { _T("YES"),          TRUE},
    { _T("NO"),           FALSE}
};

ATTRSTRINGTABLEENTRY g_rgStringDataType[] = {
    { _T("DWORD"),        eValueDWORD},
    { _T("QWORD"),        eValueQWORD},
    { _T("STRING"),       eValueString},
    { _T("BINARY"),       eValueBinary},
    { _T("NONE"),         eValueNone}
};

ATTRSTRINGTABLEENTRY g_rgStringOSSKUType[] = {
    { _T("PER"),          OS_SKU_PER},
    { _T("PRO"),          OS_SKU_PRO},
    { _T("SRV"),          OS_SKU_SRV},
    { _T("ADS"),          OS_SKU_ADS},
    { _T("DTC"),          OS_SKU_DTC},
    { _T("BLA"),          OS_SKU_BLA},
    { _T("TAB"),          OS_SKU_TAB},
    { _T("MED"),          OS_SKU_MED},
};

ATTRSTRINGTABLEENTRY g_rgStringOSPlatform[] = {
    { _T("I386"),         OS_PLATFORM_I386},
    { _T("IA64"),         OS_PLATFORM_IA64}
};

ATTRSTRINGTABLEENTRY g_rgStringRuntimePlatformType[] = {
    { _T("X86"),          PROCESSOR_ARCHITECTURE_INTEL},   // x86
    { _T("IA64"),         PROCESSOR_ARCHITECTURE_IA64},    // ia64
    { _T("AMD64"),        PROCESSOR_ARCHITECTURE_AMD64},   // amd64
    { _T("IA3264"),       PROCESSOR_ARCHITECTURE_IA32_ON_WIN64} // this means running in wow on ia64
};

ATTRSTRINGTABLEENTRY g_rgStringFilter[] = {
    { _T("FIX"),          SDB_FILTER_FIX},
    { _T("APPHELP"),      SDB_FILTER_APPHELP},
    { _T("MSI"),          SDB_FILTER_MSI},
    { _T("DRIVER"),       SDB_FILTER_DRIVER},
    { _T("NTCOMPAT"),     SDB_FILTER_NTCOMPAT},
    { _T("CUSTOM"),       SDB_FILTER_INCLUDE_ALL}
};

ATTRSTRINGTABLEENTRY g_rgStringOutputType[] = {
    { _T("SDB"),                    SDB_OUTPUT_TYPE_SDB},
    { _T("HTMLHELP"),               SDB_OUTPUT_TYPE_HTMLHELP},
    { _T("MIGDB_INX"),              SDB_OUTPUT_TYPE_MIGDB_INX},
    { _T("MIGDB_TXT"),              SDB_OUTPUT_TYPE_MIGDB_TXT},
    { _T("WIN2K_REGISTRY"),         SDB_OUTPUT_TYPE_WIN2K_REGISTRY},
    { _T("REDIR_MAP"),              SDB_OUTPUT_TYPE_REDIR_MAP},
    { _T("NTCOMPAT_INF"),           SDB_OUTPUT_TYPE_NTCOMPAT_INF},
    { _T("NTCOMPAT_MESSAGE_INF"),   SDB_OUTPUT_TYPE_NTCOMPAT_MESSAGE_INF},
    { _T("APPHELP_REPORT"),         SDB_OUTPUT_TYPE_APPHELP_REPORT}
};

ATTRSTRINGTABLEENTRY g_rgStringMatchModeType[] = {
    { _T("NORMAL"),         MATCHMODE_NORMAL_SHIMDBC     },
    { _T("EXCLUSIVE"),      MATCHMODE_EXCLUSIVE_SHIMDBC  },
    { _T("ADDITIVE"),       MATCHMODE_ADDITIVE_SHIMDBC   }
};

LPCTSTR EncodeStringAttribute(
    DWORD                 dwValue,
    PATTRSTRINGTABLEENTRY pTable,
    int                   nSize)
{
    static LPCTSTR pszUnknown = _T("UNKNOWN");
    int            i;

    for (i = 0; i < nSize; ++i, ++pTable) {
        if (dwValue == pTable->dwValue) {
            return(pTable->pszName);
        }
    }
    return pszUnknown;
}

BOOL DecodeStringAttribute(
    LPCTSTR               lpszAttribute,
    PATTRSTRINGTABLEENTRY pTable,
    int                   nSize,
    DWORD*                pdwValue)
{
    int i;

    //
    // Find the indicator and return the flag
    //
    for (i = 0; i < nSize; ++i, ++pTable) {
        if (0 == _tcsicmp(lpszAttribute, pTable->pszName)) {
            if (NULL != pdwValue) {
                *pdwValue = pTable->dwValue;
            }
            break;
        }
    }

    return i < nSize;
}

LPCTSTR SeverityIndicatorToStr(SdbAppHelpType Severity)
{
    return(EncodeStringAttribute((DWORD)Severity, g_rgStringSeverity, ARRAYSIZE(g_rgStringSeverity)));
}

LPCTSTR ModuleTypeIndicatorToStr(DWORD ModuleType)
{
    return(EncodeStringAttribute(ModuleType, g_rgStringModuleType, ARRAYSIZE(g_rgStringModuleType)));
}


#define GetSeverityIndicator(lpszSeverity, pSeverity) \
   DecodeStringAttribute(lpszSeverity, g_rgStringSeverity, ARRAYSIZE(g_rgStringSeverity), (DWORD*)pSeverity)

#define GetModuleTypeIndicator(lpszModuleType, pModuleType) \
   DecodeStringAttribute(lpszModuleType, g_rgStringModuleType, ARRAYSIZE(g_rgStringModuleType), pModuleType)

#define GetVersionSubIndicator(lpszVersionSub, pVersionSub) \
   DecodeStringAttribute(lpszVersionSub, g_rgStringVersionSub, ARRAYSIZE(g_rgStringVersionSub), pVersionSub)

#define GetYesNoIndicator(lpszYesNo, pYesNo) \
   DecodeStringAttribute(lpszYesNo, g_rgStringYesNo, ARRAYSIZE(g_rgStringYesNo), pYesNo)

#define GetDataTypeIndicator(lpszDataType, pDataType) \
    DecodeStringAttribute(lpszDataType, g_rgStringDataType, ARRAYSIZE(g_rgStringDataType), pDataType)


DWORD GetOSSKUType(LPCTSTR szOSSKUType)
{
    DWORD dwReturn = OS_SKU_NONE;

    DecodeStringAttribute(szOSSKUType, g_rgStringOSSKUType, ARRAYSIZE(g_rgStringOSSKUType), &dwReturn);

    return dwReturn;
}

DWORD GetOSPlatform(LPCTSTR szOSPlatform)
{
    DWORD dwReturn = OS_PLATFORM_NONE;

    DecodeStringAttribute(szOSPlatform, g_rgStringOSPlatform, ARRAYSIZE(g_rgStringOSPlatform), &dwReturn);

    return dwReturn;
}

DWORD GetRuntimePlatformType(LPCTSTR szPlatformType)
{
    DWORD dwReturn = PROCESSOR_ARCHITECTURE_UNKNOWN;

    DecodeStringAttribute(szPlatformType, g_rgStringRuntimePlatformType, ARRAYSIZE(g_rgStringRuntimePlatformType), &dwReturn);

    return dwReturn;
}

DWORD GetFilter(LPCTSTR szFilter)
{
    DWORD dwReturn = SDB_FILTER_EXCLUDE_ALL;
    CString csFilter(szFilter);
    CString csFilterBit;
    DWORD dwFilterBit = 0;
    long i;

    for (i = 0; i <= csFilter.GetLength(); i++) {

        switch (csFilter.GetAt(i)) {
        case _T(' '):
            break;

        case _T('|'):
        case _T('\0'):
            DecodeStringAttribute(csFilterBit, g_rgStringFilter, ARRAYSIZE(g_rgStringFilter), &dwFilterBit);
            dwReturn |= dwFilterBit;
            csFilterBit.Empty();
            break;

        default:
            csFilterBit += csFilter.GetAt(i);
            break;
        }
    }


    return dwReturn;
}

SdbOutputType GetOutputType(LPCTSTR szOutputType)
{
    DWORD dwReturn = SDB_OUTPUT_TYPE_UNKNOWN;

    DecodeStringAttribute(szOutputType, g_rgStringOutputType, ARRAYSIZE(g_rgStringOutputType), &dwReturn);

    return (SdbOutputType) dwReturn;
}

//////////////////////////////////////////////////////////////////////////////////////
//
// ProcureGuidIDAttribute
//
// retrieve Guid "ID" attribute for a given node, possibly update the source and
// generate the attribute if it was not found
//

BOOL ProcureGuidIDAttribute(
    SdbDatabase* pDB,
    IXMLDOMNode* pNode,
    GUID*        pGuid,
    CString*     pcsGUID
    )
{
    CString csID;
    BOOL    bSuccess = FALSE;

    if (!GetAttribute(_T("ID"), pNode, &csID)) {

        if (!GenerateIDAttribute(pNode, &csID, pGuid)) {
            SDBERROR_FORMAT((_T("Error generating ID attribute for the node\n%s\n"),
                             GetXML(pNode)));
            goto eh;
        }

        pDB->m_pCurrentInputFile->m_bSourceUpdated = TRUE;

    } else {
        if (!GUIDFromString(csID, pGuid)) {
            //
            // This is the case when we cannot parse the guid and it appears to be
            // an invalid guid.
            //
            SDBERROR_FORMAT((_T("ID attribute is not a valid GUID\n%s\n"), csID));
            goto eh;
        }
    }

    if (pcsGUID != NULL) {
        *pcsGUID = csID;
    }

    bSuccess = TRUE;
eh:
    return bSuccess;

}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   GetNextSequentialID
//
//  Desc:   Determines the next available sequential to be generated.
//
DWORD SdbDatabase::GetNextSequentialID(CString csType)
{
    CString csMaxID, csID;
    IXMLDOMNodePtr cpXMLAppHelp;
    DWORD dwMaxID = 0;
    DWORD dwMaxReportedID = 0;
    DWORD dwMaxEmpiricalID = 0;
    XMLNodeList XQL;
    long i;

    //
    // Determine largest ID
    //
    if (GetAttribute(_T("MAX_") + csType,
         m_cpCurrentDatabaseNode,
         &csMaxID)) {
        dwMaxReportedID = _ttol(csMaxID);
    }

    DWORD dwID = 0;

    if (!XQL.Query(m_cpCurrentDatabaseNode, _T("//@") + csType)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    for (i = 0; i < XQL.GetSize(); i++) {

        if (!XQL.GetItem(i, &cpXMLAppHelp)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        csID = GetText(cpXMLAppHelp);
        if (csID.GetLength()) {
            dwID = _ttol(csID);
            if (dwID > dwMaxEmpiricalID) {
                dwMaxEmpiricalID = dwID;
            }
        }

        cpXMLAppHelp.Release();
    }

    if (dwMaxEmpiricalID > dwMaxReportedID) {
        dwMaxID = dwMaxEmpiricalID;
    } else {
        dwMaxID = dwMaxReportedID;
    }

    dwMaxID++;
    csMaxID.Format(_T("%d"), dwMaxID);

    if (!AddAttribute(m_cpCurrentDatabaseNode,
            _T("MAX_") + csType, csMaxID)) {
    }

    m_pCurrentInputFile->m_bSourceUpdated = TRUE;

eh:

    return dwMaxID;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   ReadDatabase
//
//  Desc:   Opens an XML file and calls read on the database object.
//
BOOL ReadDatabase(
    SdbInputFile* pInputFile,
    SdbDatabase* pDatabase)
{
    BOOL                bSuccess            = FALSE;
    IXMLDOMNodePtr      cpRootNode;
    IXMLDOMNodePtr      cpDatabase;
    XMLNodeList         XQL;

    if (!OpenXML(pInputFile->m_csName, &cpRootNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!GetChild(_T("DATABASE"), cpRootNode, &cpDatabase)) {
        SDBERROR(_T("<DATABASE> object not found"));
        goto eh;
    }

    pDatabase->m_cpCurrentDatabaseNode = cpDatabase;

    if (!pDatabase->ReadFromXML(cpDatabase, pDatabase)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (pInputFile->m_bSourceUpdated) {
        //
        // We need to modify original XML file
        //
        if (!SaveXMLFile(pInputFile->m_csName, cpDatabase)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }
    }

    bSuccess = TRUE;

eh:
    pDatabase->m_cpCurrentDatabaseNode = NULL;

    return bSuccess;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   ReadCallers
//
//  Desc:   Reads in all <INCLUDE> and <EXCLUDE> child tags on node pNode and
//          adds them as SdbCaller objects to the array pointed to by prgCallers.
//
BOOL ReadCallers(
    SdbArray<SdbCaller>* prgCallers,
    SdbDatabase* pDB,
    IXMLDOMNode* pNode)
{
    USES_CONVERSION;

    BOOL                bSuccess        = FALSE;
    long                nIndex          = 0;
    long                nListLength     = 0;
    IXMLDOMNodePtr      cpCallerNode;
    XMLNodeList         NodeList;
    SdbCaller*          pSdbCaller      = NULL;
    CString             csNodeName, csTemp;

    if (!NodeList.GetChildNodes(pNode)) {
        //
        // No child nodes -- that's fine, return success.
        //
        bSuccess = TRUE;
        goto eh;
    }

    for (nIndex = 0; nIndex < NodeList.GetSize(); nIndex++) {
        if (!NodeList.GetItem(nIndex, &cpCallerNode)) {
            SDBERROR(_T("Could not retrieve INCLUDE/EXCLUDE item"));
            goto eh;
        }

        if (GetNodeName(cpCallerNode) == _T("INCLUDE") ||
            GetNodeName(cpCallerNode) == _T("EXCLUDE")) {
            pSdbCaller = new SdbCaller();

            if (pSdbCaller == NULL) {
                SDBERROR(_T("Error allocating SdbCaller object"));
                goto eh;
            }

            if (!pSdbCaller->ReadFromXML(cpCallerNode, pDB)) {
                SDBERROR_PROPOGATE();

                delete pSdbCaller;
                pSdbCaller = NULL;

                goto eh;
            }

            //
            // Add in reverse order to help the Shim engine's logic
            // building code
            //
            prgCallers->InsertAt(0, pSdbCaller);
            pSdbCaller = NULL;
        }

        cpCallerNode.Release();
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL ReadLocalizedNames(
    SdbArray<SdbLocalizedString>* prgNames,
    CString csTag,
    SdbDatabase* pDB,
    IXMLDOMNode* pNode)
{
    BOOL bSuccess = FALSE;
    IXMLDOMNodePtr cpTag;
    XMLNodeList XQL;
    CString csTemp, csLangID, csName;
    SdbLocalizedString* pLocString = NULL;

    long i;

    if (!XQL.Query(pNode, csTag)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    for (i = 0; i < XQL.GetSize(); i++) {

        CString csID;
        GUID ID = GUID_NULL;

        if (!XQL.GetItem(i, &cpTag)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (!GetAttribute(_T("LANGID"), cpTag, &csLangID)) {
            if (!pDB->m_csCurrentLangID.GetLength())
            {
                SDBERROR_FORMAT((
                    _T("LOCALIZED_NAME tag requires LANGID attribute if there is no LANGID on the DATABASE node\n%s\n"),
                    GetXML(cpTag)));
                goto eh;
            }
            csLangID = pDB->m_csCurrentLangID;
        }

        if (!ProcureGuidIDAttribute(pDB, cpTag, &ID, &csID)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (!GetAttribute(_T("NAME"), cpTag, &csName)) {
            SDBERROR_FORMAT((
                _T("LOCALIZED_NAME tag requires NAME attribute:\n%s\n"),
                GetXML(cpTag)));
            goto eh;
        }

        pLocString = new SdbLocalizedString();
        pLocString->m_csName = csName;
        pLocString->m_csLangID = csLangID;
        pLocString->m_csValue = GetInnerXML(cpTag);
        prgNames->Add(pLocString);
    }

    bSuccess = TRUE;

eh:

    return bSuccess;

}
BOOL SdbDatabase::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL                bSuccess            = FALSE;
    long                i;
    long                nListCount          = 0;
    IXMLDOMNodePtr      cpXMLLibrary;
    IXMLDOMNodePtr      cpXMLAppHelp;
    IXMLDOMNodePtr      cpXMLA;
    IXMLDOMNodePtr      cpXMLHTMLHELPTemplate;
    IXMLDOMNodePtr      cpXMLHTMLHELPFirstScreen;
    CString             csHTMLHELPID, csXQL, csHistoryClause;
    CString             csID, csRedirID, csRedirURL, csOSVersion;
    CString             csTemplateName;
    DWORD               dwHTMLHELPID = 0;
    XMLNodeList         XQL;
    SdbLocalizedString* pRedir                  = NULL;
    SdbLocalizedString* pHTMLHelpTemplate       = NULL;
    SdbLocalizedString* pHTMLHelpFirstScreen    = NULL;

    //
    // Read the name of the database
    //
    ReadName(pNode, &m_csName);

    //
    // Read the LangID for this database file
    //
    m_csCurrentLangID = _T("---");
    GetAttribute(_T("LANGID"), pNode, &m_csCurrentLangID);

    //
    // Read the default ID
    //
    if (!GetAttribute(_T("ID"), pNode, &csID)) {
        //
        // Guid was not found. We need to generate it.
        //
        if (!GenerateIDAttribute(pNode, &csID, &m_ID)) {
            SDBERROR_FORMAT((_T("Error generating ID attribute for the node\n%s\n"),
                             GetXML(pNode)));
            goto eh;
        }

        pDB->m_pCurrentInputFile->m_bSourceUpdated = TRUE;

    } else if (!GUIDFromString(csID, &m_ID)) {
        //
        // This is the case when we cannot parse the guid and it appears to be
        // an invalid guid.
        //
        SDBERROR_FORMAT((_T("ID attribute is not a valid GUID\n%s\n"), csID));
        goto eh;
    }

    //
    // Add REDIR_IDs to <A> tags if necessary
    //
    if (!XQL.Query(pNode, _T("//A"))) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    for (i = 0; i < XQL.GetSize(); i++) {

        if (!XQL.GetItem(i, &cpXMLA)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (!GetAttribute(_T("REDIR_ID"), cpXMLA, &csRedirID)) {
            //
            // Not there, generate it.
            //
            csRedirID.Format(_T("%d"), GetNextSequentialID(_T("REDIR_ID")));

            if (!AddAttribute(cpXMLA, _T("REDIR_ID"), csRedirID)) {
                SDBERROR_PROPOGATE();
                goto eh;
            }
        }

        if (!GetAttribute(_T("HREF"), cpXMLA, &csRedirURL)) {
            //
            // No HREF attribute. Take the link from the display name.
            //
            csRedirURL = GetText(cpXMLA);
        }

        pRedir = (SdbLocalizedString *) m_rgRedirs.LookupName(csRedirID, m_csCurrentLangID);
        if (pRedir) {
            SDBERROR_FORMAT((_T("Non-unique REDIR_ID:\n%s\n"), GetXML(cpXMLA)));
            goto eh;
        }

        pRedir = new SdbLocalizedString();
        pRedir->m_csName = csRedirID;
        pRedir->m_csLangID = m_csCurrentLangID;
        pRedir->m_csValue = csRedirURL;
        m_rgRedirs.Add(pRedir);

        cpXMLA = NULL;
    }

    //
    // Read HTMLHELP_TEMPLATE
    //
    if (!XQL.Query(pNode, _T("HTMLHELP_TEMPLATE"))) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    for (i = 0; i < XQL.GetSize(); i++) {

        if (!XQL.GetItem(i, &cpXMLHTMLHELPTemplate)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (!GetAttribute(_T("NAME"), cpXMLHTMLHELPTemplate, &csTemplateName)) {
            SDBERROR_FORMAT((_T("HTMLHELP_TEMPLATE requires NAME attribute:\n%s\n"),
                GetXML(cpXMLHTMLHELPTemplate)));
            goto eh;
        }

        pHTMLHelpTemplate = new SdbLocalizedString();
        pHTMLHelpTemplate->m_csName = csTemplateName;
        pHTMLHelpTemplate->m_csLangID = m_csCurrentLangID;
        pHTMLHelpTemplate->m_csValue = GetInnerXML(cpXMLHTMLHELPTemplate);
        m_rgHTMLHelpTemplates.Add(pHTMLHelpTemplate);
    }

    //
    // Read HTMLHELP_FIRST_SCREEN
    //
    if (!XQL.Query(pNode, _T("HTMLHELP_FIRST_SCREEN"))) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (XQL.GetSize() > 1) {
        SDBERROR(_T("More than one HTMLHELP_FIRST_SCREEN tags found:\n%s\n"));
        goto eh;
    }

    if (XQL.GetSize() == 1) {
        if (!XQL.GetItem(0, &cpXMLHTMLHELPFirstScreen)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }


        pHTMLHelpFirstScreen = new SdbLocalizedString();
        pHTMLHelpFirstScreen->m_csName = _T("HTMLHELP_FIRST_SCREEN");
        pHTMLHelpFirstScreen->m_csLangID = m_csCurrentLangID;
        pHTMLHelpFirstScreen->m_csValue = GetInnerXML(cpXMLHTMLHELPFirstScreen);
        m_rgHTMLHelpFirstScreens.Add(pHTMLHelpFirstScreen);
    }

    //
    // Read Library
    //
    if (!XQL.Query(pNode, _T("LIBRARY"))) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    for (i = 0; i < XQL.GetSize(); i++) {

        if (!XQL.GetItem(i, &cpXMLLibrary)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (!m_Library.ReadFromXML(cpXMLLibrary, this)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        cpXMLLibrary.Release();
    }


    //
    // Action tags
    //
    if (!m_rgAction.ReadFromXML(_T("ACTION"), pDB, pNode, NULL)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Construct XQL from m_prgHistoryKeywords
    //
    if (m_pCurrentMakefile->m_rgHistoryKeywords.GetSize() > 0) {
        for (i = 0; i < m_pCurrentMakefile->m_rgHistoryKeywords.GetSize(); i++) {
            if (i > 0) {
                csHistoryClause += _T(" or ");
            }
            csHistoryClause = _T("KEYWORD/@NAME = '") +
                m_pCurrentMakefile->m_rgHistoryKeywords.GetAt(i) + _T("'");
        }

        csXQL = _T("APP[") + csHistoryClause + _T("]");
        csXQL += _T(" | DRIVER[") + csHistoryClause + _T("]");
    } else {
        csXQL = _T("APP | DRIVER");
    }

    if (!m_rgApps.ReadFromXML(csXQL, pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_pDB = this;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbLibrary::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL                bSuccess            = FALSE;

    if (!m_rgFiles.ReadFromXML(_T(".//FILE"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!m_rgShims.ReadFromXML(_T("SHIM"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!m_rgPatches.ReadFromXML(_T("PATCH"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!m_rgFlags.ReadFromXML(_T("FLAG"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!m_rgLayers.ReadFromXML(_T("LAYER"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!m_rgMsiTransforms.ReadFromXML(_T("MSI_TRANSFORM"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!pDB->m_rgContactInfo.ReadFromXML(_T("CONTACT_INFO"), pDB, pNode, NULL, FALSE, _T("VENDOR"))) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!pDB->m_rgMessageTemplates.ReadFromXML(_T("TEMPLATE"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!pDB->m_rgMessages.ReadFromXML(_T("MESSAGE"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!ReadCallers(&m_rgCallers, pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!ReadLocalizedNames(
        &(pDB->m_rgLocalizedAppNames), _T("LOCALIZED_APP_NAME"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!ReadLocalizedNames(
        &(pDB->m_rgLocalizedVendorNames), _T("LOCALIZED_VENDOR_NAME"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbFile::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL    bSuccess            = FALSE;
    CString csFilter;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (GetAttribute(_T("FILTER"), pNode, &csFilter)) {
        m_dwFilter = GetFilter(csFilter) | SDB_FILTER_OVERRIDE;
    }

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbShim::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL            bSuccess        = FALSE;
    long            i;
    CString         csTemp, csID;
    IXMLDOMNodePtr  cpDesc;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!GetAttribute(_T("FILE"), pNode, &m_csDllFile) && g_bStrict) {
        SDBERROR_FORMAT((_T("<SHIM> requires FILE attribute:\n%s\n\n"),
                          GetXML(pNode)));
        goto eh;
    }

    if (!ProcureGuidIDAttribute(pDB, pNode, &m_ID, &csID)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (GetChild(_T("DESCRIPTION"), pNode, &cpDesc)) {
        m_csDesc = GetText(cpDesc);
    }

    csTemp.Empty();
    if (GetAttribute(_T("PURPOSE"), pNode, &csTemp)) {
        if (csTemp == _T("GENERAL")) {
            m_Purpose = SDB_PURPOSE_GENERAL;
        } else {
            m_Purpose = SDB_PURPOSE_SPECIFIC;
        }
    }

    //
    // Check what OS PLATFORM this entry is meant for
    //
    csTemp.Empty();
    if (GetAttribute(_T("OS_PLATFORM"), pNode, &csTemp)) {
        //
        // Decode it. This string is a semi-colon delimited set
        // of OS PLATFORMs.
        //
        if (!DecodeString(csTemp, &m_dwOSPlatform, GetOSPlatform)) {
            SDBERROR_FORMAT((_T("OS_PLATFORM attribute syntax error: %s"), csTemp));
            goto eh;
        }
    }

    csTemp.Empty();
    if (GetAttribute(_T("APPLY_ALL_SHIMS"), pNode, &csTemp)) {
        if (csTemp == _T("YES")) {
            m_bApplyAllShims = TRUE;
        }
    }

    if (!ReadCallers(&m_rgCallers, pDB, pNode)) {
        SDBERROR(_T("Could not read INCLUDE/EXCLUDE info of <SHIM> tag"));
        goto eh;
    }

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbShimRef::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL    bSuccess            = FALSE;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_pShim = (SdbShim *) pDB->m_Library.m_rgShims.LookupName(m_csName);

    if (m_pShim == NULL && g_bStrict) {
        SDBERROR_FORMAT((_T("SHIM \"%s\" not found in library:\n%s\n\n"),
                          m_csName, GetXML(pNode)));
        goto eh;
    }

    GetAttribute(_T("COMMAND_LINE"), pNode, &m_csCommandLine);

    if (!ReadCallers(&m_rgCallers, pDB, pNode)) {
        SDBERROR(_T("Could not read INCLUDE/EXCLUDE info of <SHIM> tag"));
        goto eh;
    }

    // finally, read all the child data elements
    if (!m_rgData.ReadFromXML(_T("DATA"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }


    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbPatch::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL                bSuccess        = FALSE;
    PATCHOP             PatchOp;
    PATCHWRITEDATA      PatchWriteData;
    PATCHMATCHDATA      PatchMatchData;
    XMLNodeList         NodeList;
    IXMLDOMNodePtr      cpOpNode;
    long                i;
    CString             csNodeName, csError;
    CString             csModule, csOffset;
    CString             csID;
    DWORD               dwByteCount     = 0;
    BYTE*               pBytes          = NULL;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!ProcureGuidIDAttribute(pDB, pNode, &m_ID, &csID)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // NOTE: We don't write the patch description in the binary database
    //       so there's no point reading it either.
    //

    NodeList.GetChildNodes(pNode);

    for (i = 0; i < NodeList.GetSize(); i++) {

        if (!NodeList.GetItem(i, &cpOpNode)) {
            SDBERROR(_T("Could not retrieve PATCH instructions"));
            goto eh;
        }

        csNodeName = GetNodeName(cpOpNode);

        if (csNodeName == _T("MATCH_BYTES")) {

            if (!GetAttribute(_T("MODULE"), cpOpNode, &csModule)) {
                csError.Format(_T("<MATCH_BYTES> requires MODULE attribute:\n%s\n"),
                                 GetXML(cpOpNode));
                SDBERROR(csError);
                goto eh;
            }

            if (!GetAttribute(_T("OFFSET"), cpOpNode, &csOffset)) {
                csError.Format(_T("<MATCH_BYTES> requires OFFSET attribute:\n%s\n"),
                                 GetXML(cpOpNode));
                SDBERROR(csError);
                goto eh;
            }

            PatchOp.dwOpcode = PMAT;

            PatchMatchData.rva.address = StringToDword(csOffset);

            if (csModule.GetLength() >= sizeof(PatchMatchData.rva.moduleName)) {
                csError.Format(_T("MODULE attribute greater than %d characters:\n%s\n"),
                                 sizeof(PatchMatchData.rva.moduleName) - 1,
                                 GetXML(cpOpNode));
                SDBERROR(csError);
                goto eh;
            }

            dwByteCount = GetByteStringSize(GetText(cpOpNode));

            if (dwByteCount == 0xFFFFFFFF) {
                csError.Format(_T("Bad byte string for patch operation:\n%s\n"),
                                 GetXML(cpOpNode));
                SDBERROR(csError);
                goto eh;
            }

            PatchMatchData.dwSizeData = dwByteCount;

            if (csModule == _T("%EXE%")) {
                PatchMatchData.rva.moduleName[0] = _T('\0');
            } else {
                StringCchCopy(PatchMatchData.rva.moduleName,
                              ARRAYSIZE(PatchMatchData.rva.moduleName),
                              csModule);
            }

            pBytes = (BYTE*) new BYTE[dwByteCount];

            if (pBytes == NULL) {
                SDBERROR(_T("Error allocating memory for <PATCH> block."));
                goto eh;
            }

            if (GetBytesFromString(GetText(cpOpNode), pBytes, dwByteCount) == 0xFFFFFFFF) {
                csError.Format(_T("Bad byte string for patch operation:\n%s\n"),
                                 GetXML(cpOpNode));
                SDBERROR(csError);
                goto eh;
            }

            PatchOp.dwNextOpcode = sizeof(DWORD) * 3
                                   + sizeof(RELATIVE_MODULE_ADDRESS)
                                   + dwByteCount;

            AddBlobBytes(&PatchOp, sizeof(DWORD) * 2);
            AddBlobBytes(&PatchMatchData, sizeof(DWORD) + sizeof(RELATIVE_MODULE_ADDRESS));
            AddBlobBytes(pBytes, dwByteCount);

            delete pBytes;
            pBytes = NULL;

        } else if (csNodeName == _T("WRITE_BYTES")) {

            if (!GetAttribute(_T("MODULE"), cpOpNode, &csModule)) {
                csError.Format(_T("<WRITE_BYTES> requires MODULE attribute:\n%s\n"),
                                 GetXML(cpOpNode));
                SDBERROR(csError);
                goto eh;
            }

            if (!GetAttribute(_T("OFFSET"), cpOpNode, &csOffset)) {
                csError.Format(_T("<WRITE_BYTES> requires OFFSET attribute:\n%s\n"),
                                 GetXML(cpOpNode));
                SDBERROR(csError);
                goto eh;
            }

            PatchOp.dwOpcode = PWD;

            PatchWriteData.rva.address = StringToDword(csOffset);

            if (csModule.GetLength() >= sizeof(PatchWriteData.rva.moduleName)) {
                csError.Format(_T("MODULE attribute greater than %d characters:\n%s\n"),
                                 sizeof(PatchWriteData.rva.moduleName) - 1,
                                 GetXML(cpOpNode));
                SDBERROR(csError);
                goto eh;
            }

            dwByteCount = GetByteStringSize(GetText(cpOpNode));

            if (dwByteCount == 0xFFFFFFFF) {
                csError.Format(_T("Bad byte string for patch operation:\n%s\n"),
                                 GetXML(cpOpNode));
                SDBERROR(csError);
                goto eh;
            }

            PatchWriteData.dwSizeData = dwByteCount;

            if (csModule == _T("%EXE%")) {
                PatchWriteData.rva.moduleName[0] = _T('\0');
            } else {
                StringCchCopy(PatchWriteData.rva.moduleName,
                              ARRAYSIZE(PatchWriteData.rva.moduleName),
                              csModule);
            }

            pBytes = (BYTE*) new BYTE[dwByteCount];

            if (pBytes == NULL) {
                SDBERROR(_T("Error allocating memory for <PATCH> block."));
                goto eh;
            }

            if (GetBytesFromString(GetText(cpOpNode), pBytes, dwByteCount) == 0xFFFFFFFF) {
                csError.Format(_T("Bad byte string for patch operation:\n%s\n"),
                                 GetXML(cpOpNode));
                SDBERROR(csError);
                goto eh;
            }

            PatchOp.dwNextOpcode = sizeof(DWORD) * 3
                                   + sizeof(RELATIVE_MODULE_ADDRESS)
                                   + dwByteCount;

            AddBlobBytes(&PatchOp, sizeof(DWORD) * 2);
            AddBlobBytes(&PatchWriteData, sizeof(DWORD) + sizeof(RELATIVE_MODULE_ADDRESS));
            AddBlobBytes(pBytes, dwByteCount);

            delete [] pBytes;
            pBytes = NULL;
        }

        cpOpNode.Release();
    }

    //
    // Add terminating NULL bytes
    //
    ZeroMemory(&PatchOp, sizeof(DWORD) * 2);
    AddBlobBytes(&PatchOp, sizeof(DWORD) * 2);

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbLayer::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL            bSuccess            = FALSE;
    CString         csID;
    CString         csTemp;
    IXMLDOMNodePtr  cpDesc;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (GetChild(_T("DESCRIPTION"), pNode, &cpDesc)) {
        m_csDesc = GetText(cpDesc);
    }

    //
    // Check what OS PLATFORM this entry is meant for
    //
    if (GetAttribute(_T("OS_PLATFORM"), pNode, &csTemp)) {
        //
        // Decode it. This string is a semi-colon delimited set
        // of OS PLATFORMs.
        //
        if (!DecodeString(csTemp, &m_dwOSPlatform, GetOSPlatform)) {
            SDBERROR_FORMAT((_T("OS_PLATFORM attribute syntax error: %s"), csTemp));
            goto eh;
        }
    }

    if (!m_rgShimRefs.ReadFromXML(_T("SHIM"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!m_rgFlagRefs.ReadFromXML(_T("FLAG"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!ProcureGuidIDAttribute(pDB, pNode, &m_ID, &csID)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    GetAttribute(_T("DISPLAY_NAME"), pNode, &m_csDisplayName);

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbLayerRef::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL    bSuccess            = FALSE;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_pLayer = (SdbLayer*) pDB->m_Library.m_rgLayers.LookupName(m_csName);

    //
    // finally, read all the child data elements
    //
    if (!m_rgData.ReadFromXML(_T("DATA"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbCaller::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL    bSuccess            = FALSE;
    CString csNodeName, csTemp;

    csNodeName = GetNodeName(pNode);
    if (csNodeName == _T("INCLUDE")) {
        m_CallerType = SDB_CALLER_INCLUDE;
    } else if (csNodeName == _T("EXCLUDE")) {
        m_CallerType = SDB_CALLER_EXCLUDE;
    }

    if (!GetAttribute(_T("MODULE"), pNode, &csTemp)) {
        SDBERROR_FORMAT((_T("<INCLUDE> or <EXCLUDE> requires MODULE attribute:\n%s\n"),
                       GetXML(pNode)));
        goto eh;
    }

    //
    // Convert %EXE% keyword to $ for optimization
    //
    if (csTemp.CompareNoCase(_T("%EXE%")) == 0) {
        csTemp = _T("$");
    }

    m_csModule = csTemp;

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbFlag::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL            bSuccess            = FALSE;
    CString         csMask;
    CString         csType;
    CString         csTemp;
    CString         csID;
    IXMLDOMNodePtr  cpDesc;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!ProcureGuidIDAttribute(pDB, pNode, &m_ID, &csID)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (GetChild(_T("DESCRIPTION"), pNode, &cpDesc)) {
        m_csDesc = GetText(cpDesc);
    }

    if (!GetAttribute(_T("TYPE"), pNode, &csType)) {
        //
        // By default the apphacks are for kernel.
        //
        SDBERROR_FORMAT((_T("<FLAG> requires TYPE attribute:\n%s\n"),
                       GetXML(pNode)));
        goto eh;
    }

    csTemp.Empty();
    if (GetAttribute(_T("PURPOSE"), pNode, &csTemp)) {
        if (csTemp == _T("GENERAL")) {
            m_Purpose = SDB_PURPOSE_GENERAL;
        } else {
            m_Purpose = SDB_PURPOSE_SPECIFIC;
        }
    }

    if (!SetType(csType)) {
        SDBERROR_FORMAT((_T("<FLAG> bad TYPE attribute:\n%s\n"),
                       GetXML(pNode)));
        goto eh;
    }

    if (!GetAttribute(_T("MASK"), pNode, &csMask)) {
        SDBERROR_FORMAT((_T("<FLAG> requires MASK attribute:\n%s\n"),
                       GetXML(pNode)));
        goto eh;
    }

    m_ullMask = StringToQword(csMask);

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbFlagRef::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL    bSuccess            = FALSE;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_pFlag = (SdbFlag *) pDB->m_Library.m_rgFlags.LookupName(m_csName);

    if (m_pFlag == NULL && g_bStrict) {
        SDBERROR_FORMAT((_T("SHIM \"%s\" not found in library:\n%s\n\n"),
                          m_csName, GetXML(pNode)));
        goto eh;
    }

    //
    // see if we have cmd line, applicable mostly to ntvdm flags
    //
    GetAttribute(_T("COMMAND_LINE"), pNode, &m_csCommandLine);

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbApp::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL            bSuccess            = FALSE;
    XMLNodeList     XQL;
    IXMLDOMNodePtr  cpHistoryNode;
    IXMLDOMNodePtr  cpAppHelpNode;
    SdbAppHelpRef*  pAppHelpRef1        = NULL;
    SdbAppHelpRef*  pAppHelpRef2        = NULL;
    long            i, j;
    CString         csTemp, csTemp2, csTemp3, csID;
    COleDateTime    odtLastRevision, odtCandidate;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    GetAttribute(_T("VENDOR"), pNode, &m_csVendor);
    GetAttribute(_T("VENDOR"), pNode, &m_csVendorXML, TRUE);
    GetAttribute(_T("VERSION"), pNode, &m_csVersion);

    if (!ProcureGuidIDAttribute(pDB, pNode, &m_ID, &csID)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!XQL.Query(pNode, _T("HISTORY"))) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Set the default modified date to 01/01/2000
    //
    odtLastRevision.ParseDateTime(_T("01/01/2001"), 0, 0x0409);
    for (i = 0; i < XQL.GetSize(); i++) {
        if (!XQL.GetItem(i, &cpHistoryNode)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (GetAttribute(_T("DATE"), cpHistoryNode, &csTemp)) {
            //
            // Validate format. It's important that the date format is
            // consistent to provide easy text searches.
            //
            if (!(_istdigit(csTemp[0]) && _istdigit(csTemp[1]) &&
                  csTemp[2] == _T('/') && _istdigit(csTemp[3]) &&
                  _istdigit(csTemp[4]) && csTemp[5] == _T('/') &&
                  _istdigit(csTemp[6]) && _istdigit(csTemp[7]) &&
                  _istdigit(csTemp[8]) && _istdigit(csTemp[9]) &&
                  csTemp[10] == _T('\0'))) {
                SDBERROR_FORMAT((_T("HISTORY DATE is not in format MM/DD/YYYY: \"%s\"\nFor app: \"%s\""),
                    csTemp, m_csName));
                goto eh;
            }

            if (!odtCandidate.ParseDateTime(csTemp, 0, 0x0409))
            {
                SDBERROR_FORMAT((_T("HISTORY DATE is not in format MM/DD/YYYY: \"%s\"\nFor app: \"%s\""),
                    csTemp, m_csName));
                goto eh;
            }

            if (odtCandidate > odtLastRevision)
            {
                odtLastRevision = odtCandidate;
            }
        }

        if (GetAttribute(_T("KEYWORDS"), cpHistoryNode, &csTemp)) {
            m_csKeywords += csTemp;
            m_csKeywords += _T(";");
        }

        cpHistoryNode.Release();
    }

    m_dtLastRevision = odtLastRevision.m_dt;

    //
    // Set m_pCurrentApp so that new SdbExe objects can grab their m_pApp pointer
    //
    pDB->m_pCurrentApp = this;

    //
    // Add the EXEs as in an "ordered" fashion
    //
    // SYS is the driver XML version of EXE
    //
    if (!m_rgExes.ReadFromXML(_T("EXE | SYS"), pDB, pNode, NULL, TRUE)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Add the WIN9X_MIGRATION entries
    //
    if (!m_rgWin9xMigEntries.ReadFromXML(_T("WIN9X_MIGRATION"), pDB, pNode, NULL, FALSE, NULL)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Add the WINNT_UPGRADE entries
    //
    if (!m_rgWinNTUpgradeEntries.ReadFromXML(_T("WINNT_UPGRADE"), pDB, pNode, NULL, FALSE, NULL)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Read MSI_PACKAGE tags, owner is this one (hence the NULL), add them ordered
    //
    if (!m_rgMsiPackages.ReadFromXML(_T("MSI_PACKAGE"), pDB, pNode, NULL, TRUE)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Run through the AppHelpRefs to make sure
    // they all have HTMLHELPIDs
    //
    for (i = 0; i < m_rgAppHelpRefs.GetSize(); i++) {
        pAppHelpRef1 = (SdbAppHelpRef *) m_rgAppHelpRefs[i];

        if (pAppHelpRef1->m_cpNode) {
            if (!pAppHelpRef1->ReadFromXML(pAppHelpRef1->m_cpNode,
                                           pDB)) {
                SDBERROR_PROPOGATE();
                goto eh;
            }

            pAppHelpRef1->m_cpNode = NULL;
        }
    }

    if (g_bStrict) {

        for (i = 0; i < m_rgAppHelpRefs.GetSize(); i++) {
            pAppHelpRef1 = (SdbAppHelpRef *) m_rgAppHelpRefs[i];

            for (j = 0; j < m_rgAppHelpRefs.GetSize(); j++) {
                pAppHelpRef2 = (SdbAppHelpRef *) m_rgAppHelpRefs[j];

                if (pAppHelpRef1->m_pAppHelp->m_csName != pAppHelpRef2->m_pAppHelp->m_csName &&
                    pAppHelpRef1->m_pAppHelp->m_csMessage == pAppHelpRef2->m_pAppHelp->m_csMessage &&
                    pAppHelpRef1->m_pAppHelp->m_Type == pAppHelpRef2->m_pAppHelp->m_Type &&
                    pAppHelpRef1->m_pAppHelp->m_bBlockUpgrade == pAppHelpRef2->m_pAppHelp->m_bBlockUpgrade &&
                    pAppHelpRef1->m_pAppHelp->m_csURL == pAppHelpRef2->m_pAppHelp->m_csURL) {
                    SDBERROR_FORMAT((_T("Different HTMLHELPIDs for same <APPHELP MESSAGE BLOCK BLOCK_UPGRADE DETAILS_URL>:\n%s\n"),
                        GetXML(pNode)));
                    goto eh;
                }
            }
        }
    }

    //
    // Set m_dtLastRevision for important children.
    //
    for (i = 0; i < m_rgExes.GetSize(); i++)
    {
        ((SdbArrayElement *) m_rgExes.GetAt(i))->m_dtLastRevision = m_dtLastRevision;
    }
    for (i = 0; i < this->m_rgAppHelpRefs.GetSize(); i++)
    {
        ((SdbAppHelpRef *) m_rgAppHelpRefs.GetAt(i))->m_pAppHelp->m_dtLastRevision = m_dtLastRevision;
    }
    for (i = 0; i < m_rgMsiPackages.GetSize(); i++)
    {
        ((SdbArrayElement *) m_rgMsiPackages.GetAt(i))->m_dtLastRevision = m_dtLastRevision;
    }
    for (i = 0; i < m_rgWin9xMigEntries.GetSize(); i++)
    {
        ((SdbArrayElement *) m_rgWin9xMigEntries.GetAt(i))->m_dtLastRevision = m_dtLastRevision;
    }
    for (i = 0; i < m_rgWinNTUpgradeEntries.GetSize(); i++)
    {
        ((SdbArrayElement *) m_rgWinNTUpgradeEntries.GetAt(i))->m_dtLastRevision = m_dtLastRevision;
    }

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    pDB->m_pCurrentApp = NULL;

    return bSuccess;
}

BOOL
CheckExeID(
    SdbDatabase* pDB,
    SdbArrayElement* pElement,
    LPCTSTR lpszID
    )
{
    SdbArrayElement* pOtherExe = NULL;
    LPCTSTR pszName = NULL;
    LPCTSTR pszTag = NULL;

    if (pDB->m_mapExeIDtoExe.Lookup(lpszID, (PVOID&)pOtherExe)) {

        //
        // see what kind of an object we caught with this duplicate id
        //
        const type_info& TypeInfoObj = typeid(*pOtherExe);
        if (typeid(SdbMsiPackage) == TypeInfoObj) {
            pszName = ((SdbMsiPackage*)pOtherExe)->m_pApp->m_csName;
            pszTag  = _T("<MSI_PACKAGE NAME=");
        } else if (typeid(SdbExe) == TypeInfoObj) {
            pszName = ((SdbExe*)pOtherExe)->m_pApp->m_csName;
            pszTag  = _T("<EXE NAME=");
        } else {
            // deep poop - we don't know what this is
            pszName = _T("???");
            pszTag  = _T("<???");
        }

        SDBERROR_FORMAT((_T("EXE ID %s is not unique\n")
                         _T("\tNested within <APP NAME=\"%s\">\n\tAnd also within %s\"%s\">\r\n"),
                        lpszID, pszName, pszTag, pElement->m_csName));

        return FALSE;
    }

    pDB->m_mapExeIDtoExe.SetAt(lpszID, pElement);

    return TRUE;
}

BOOL SdbExe::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL    bSuccess            = FALSE;
    long    i;
    CString csID, csTemp;
    BOOL    bGenerateWinNTUpgrade = FALSE;

    XMLNodeList      XQL;
    IXMLDOMNodePtr   cpSXS;
    IXMLDOMNodePtr   cpMessage;
    SdbMatchingFile* pMFile     = NULL;
    SdbData*         pData      = NULL;
    SdbData*         pPolicy    = NULL;
    SdbWinNTUpgrade* pNTUpg     = NULL;

    VARIANT vType;
    VARIANT vValue;
    IXMLDOMDocumentPtr      cpDocument;
    IXMLDOMNodePtr          cpNewNode;
    IXMLDOMNodePtr          cpXMLNSNode;
    IXMLDOMNodeListPtr      cpNodeList;
    IXMLDOMNamedNodeMapPtr  cpAttrs;

    VariantInit(&vType);
    VariantInit(&vValue);

    m_pApp = pDB->m_pCurrentApp;

    if (!GetAttribute(_T("NAME"), pNode, &m_csName)) {
        if (GetAttribute(_T("MODULE_NAME"), pNode, &m_csName)) {
            m_bMatchOnModule = TRUE;
        } else {
            SDBERROR_FORMAT((_T("NAME or MODULE_NAME attribute required:\n%s\n\n"),
                              GetXML(pNode)));
            goto eh;
        }
    }

    if (!ProcureGuidIDAttribute(pDB, pNode, &m_ID, &csID)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (g_bStrict) {
        if (!CheckExeID(pDB, this, csID)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }
    }

    //
    // Look for a match mode entry
    //

    if (GetAttribute(_T("MATCH_MODE"), pNode, &csTemp)) {
        if (!DecodeStringAttribute(csTemp,
                                   g_rgStringMatchModeType,
                                   ARRAYSIZE(g_rgStringMatchModeType),
                                   &m_dwMatchMode)) {
            //
            // try to decode using the hex (direct) format
            //
            if (!StringToMask(&m_dwMatchMode, csTemp)) {
                SDBERROR_FORMAT((_T("MATCH_MODE attribute is invalid\n%s\n"),
                                 GetXML(pNode)));
                goto eh;
            }
        }
    }

    if (GetAttribute(_T("RUNTIME_PLATFORM"), pNode, &csTemp)) {
        if (!DecodeRuntimePlatformString(csTemp, &m_dwRuntimePlatform)) {
            SDBERROR_FORMAT((_T("RUNTIME_PLATFORM no in recognized format: \"%s\"\n%s\n"),
                              (LPCTSTR)csTemp, GetXML(pNode)));
            goto eh;
        }
    }

    GetAttribute(_T("OS_VERSION"), pNode, &m_csOSVersionSpec);

    //
    // Check what OS SKU this entry is meant for
    //
    if (GetAttribute(_T("OS_SKU"), pNode, &csTemp)) {
        //
        // Decode it. This string is a semi-colon delimited set
        // of OS SKUs.
        //
        if (!DecodeString(csTemp, &m_dwOSSKU, GetOSSKUType)) {
            SDBERROR_FORMAT((_T("OS_SKU attribute syntax error: %s"), csTemp));
            goto eh;
        }
    }

    //
    // Check what OS PLATFORM this entry is meant for
    //
    if (GetAttribute(_T("OS_PLATFORM"), pNode, &csTemp)) {
        //
        // Decode it. This string is a semi-colon delimited set
        // of OS PLATFORMs.
        //
        if (!DecodeString(csTemp, &m_dwOSPlatform, GetOSPlatform)) {
            SDBERROR_FORMAT((_T("OS_PLATFORM attribute syntax error: %s"), csTemp));
            goto eh;
        }
    }

    //
    // Add EXE as matching file
    //
    pMFile = new SdbMatchingFile();

    if (pMFile == NULL) {
        SDBERROR(_T("Error allocating SdbMatchingFile object"));
        goto eh;
    }

    m_rgMatchingFiles.Add(pMFile, pDB);

    if (!pMFile->ReadFromXML(pNode, pDB)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Change name to "*" -- that is the alias for the EXE. This is done
    // to allow matching on a wildcard executable name.
    //
    pMFile->m_csName = _T("*");

    if (!m_rgMatchingFiles.ReadFromXML(_T("MATCHING_FILE"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!m_rgShimRefs.ReadFromXML(_T("SHIM"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!m_rgLayerRefs.ReadFromXML(_T("LAYER"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!m_rgPatches.ReadFromXML(_T("PATCH"), pDB, pNode, &(pDB->m_Library.m_rgPatches))) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!m_rgFlagRefs.ReadFromXML(_T("FLAG"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Data tags
    //
    if (!m_rgData.ReadFromXML(_T("(DATA | DRIVER_POLICY)"), pDB, pNode, NULL)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Driver database 'hack': We look for CRITICAL="NO" on the SYS tag
    // and add a Policy = 0x1 <DATA> element if found. This is to help
    // readability.
    //

    //
    // Check if policy already exists
    //
    for (i = 0; i < m_rgData.GetSize(); i++) {
        pData = (SdbData *) m_rgData.GetAt(i);

        if (pData->m_csName.CompareNoCase(_T("Policy")) == 0) {
            pPolicy = pData;
            break;
        }
    }

    if (GetAttribute(_T("CRITICAL"), pNode, &csTemp)) {

        if (csTemp.CompareNoCase(_T("NO")) == 0) {

            if (pPolicy == NULL) {
                pPolicy = new SdbData;
                pPolicy->m_csName = _T("Policy");
                pPolicy->SetValue(eValueDWORD, _T("0x0"));
                m_rgData.Add(pPolicy, pDB);
            }

            pPolicy->m_dwValue |= 1;
        }
    }

    if (GetAttribute(_T("USER_MODE_BLOCK"), pNode, &csTemp)) {

        if (csTemp.CompareNoCase(_T("NO")) == 0) {

            if (pPolicy == NULL) {
                pPolicy = new SdbData;
                pPolicy->m_csName = _T("Policy");
                pPolicy->SetValue(eValueDWORD, _T("0x0"));
                m_rgData.Add(pPolicy, pDB);
            }

            pPolicy->m_dwValue |= 2;
        }
    }

    //
    // Action tags
    //
    if (!m_rgAction.ReadFromXML(_T("ACTION"), pDB, pNode, NULL)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Read APPHELP refs
    //
    if (!XQL.Query(pNode, _T("APPHELP"))) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (XQL.GetSize() > 1) {
        SDBERROR_FORMAT((_T("Multiple <APPHELP> tags per <EXE> not allowed\n%s\n"),
                         GetXML(pNode)));
        goto eh;
    }

    if (XQL.GetSize() == 1) {
        if (!XQL.GetItem(0, &cpMessage)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (!m_AppHelpRef.ReadFromXML(cpMessage, pDB)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (m_rgShimRefs.GetSize() == 0 &&
            m_rgPatches.GetSize() == 0 &&
            m_rgFlagRefs.GetSize() == 0 &&
            m_rgLayerRefs.GetSize() == 0) {
            m_AppHelpRef.m_bApphelpOnly = TRUE;
        }

        //
        // <SYS> entries automatically get an <WINNT_UPGRADE> entry
        //

        if (GetNodeName(pNode) == _T("SYS")) {

            bGenerateWinNTUpgrade = TRUE;

            if (GetAttribute(_T("GENERATE_UPGRADE_REPORT_ENTRY"), pNode, &csTemp)) {
                if (0 == csTemp.CompareNoCase(_T("NO"))) {
                    bGenerateWinNTUpgrade = FALSE;
                }
            }

            if (bGenerateWinNTUpgrade) {
                pNTUpg = new SdbWinNTUpgrade;
                pNTUpg->m_pDB = pDB;
                pNTUpg->m_pApp = pDB->m_pCurrentApp;

                if (!pNTUpg->m_AppHelpRef.ReadFromXML(cpMessage, pDB)) {
                    SDBERROR_PROPOGATE();
                    goto eh;
                }

                csTemp = m_csName;
                ReplaceStringNoCase(csTemp, _T(".SYS"), _T(""));
                pNTUpg->m_MatchingFile.m_csServiceName = csTemp;
                pNTUpg->m_MatchingFile.m_csName.Format(_T("%%SystemRoot%%\\System32\\Drivers\\%s"), m_csName);
                pNTUpg->m_MatchingFile.m_dwMask = pMFile->m_dwMask;
                pNTUpg->m_MatchingFile.m_ullBinProductVersion = pMFile->m_ullBinProductVersion;
                pNTUpg->m_MatchingFile.m_ullUpToBinProductVersion = pMFile->m_ullUpToBinProductVersion;
                pNTUpg->m_MatchingFile.m_timeLinkDate = pMFile->m_timeLinkDate;
                pNTUpg->m_MatchingFile.m_timeUpToLinkDate = pMFile->m_timeUpToLinkDate;

                m_pApp->m_rgWinNTUpgradeEntries.Add(pNTUpg, pDB);
                pDB->m_rgWinNTUpgradeEntries.Add(pNTUpg, pDB);
            }
        }
    }

    //
    // Read SXS manifest
    //
    if (!XQL.Query(pNode, _T("SXS"))) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (XQL.GetSize() > 1) {
        SDBERROR_FORMAT((_T("Multiple <SXS> tags per <EXE> not allowed\n%s\n"),
                         GetXML(pNode)));
        goto eh;
    }

    if (XQL.GetSize() == 1) {
        if (!XQL.GetItem(0, &cpSXS)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        m_csSXSManifest = TrimParagraph(GetInnerXML(cpSXS));
        if (m_csSXSManifest.IsEmpty()) {
            SDBERROR_FORMAT((_T("Failed to read SXS manifest:\n%s\n"),
                             GetXML(cpSXS)));
            goto eh;
        }
    }

    //
    // Check whether the EXE name contains a wildcard
    //
    m_bWildcardInName = (0 <= m_csName.FindOneOf(_T("*?")));

    //
    // Differentiate between driver.xml entries and dbu.xml
    //
    if (GetNodeName(pNode) == _T("SYS")) {
        //
        // Set filter
        //
        m_dwFilter = SDB_FILTER_DRIVER | SDB_FILTER_OVERRIDE;

        if (m_bWildcardInName) {
            SDBERROR_FORMAT((_T("Wildcards not allowed in SYS entries:\n%s\n"),
                             GetXML(pNode)));
            goto eh;
        } else {
            pDB->m_rgExes.Add(this, pDB, TRUE);
        }
    } else {

        //
        // Check if we're compiling for Win2k and make
        // sure Win2k supports all the matching operations.
        //
        if (g_bStrict) {
            if (!IsValidForWin2k(GetXML(pNode))) {
                if (GetAttribute(_T("OS_VERSION"), pNode, &csTemp)) {
                    SDBERROR_PROPOGATE();
                    goto eh;
                }

                if (!AddAttribute(pNode, _T("OS_VERSION"), _T("gte5.1"))) {
                    SDBERROR_PROPOGATE();
                    goto eh;
                }

                SDBERROR_CLEAR();

                pDB->m_pCurrentInputFile->m_bSourceUpdated = TRUE;
            }
        }

        if (m_bWildcardInName) {
            pDB->m_rgWildcardExes.Add(this, pDB, TRUE);
        } else if (m_bMatchOnModule) {
            pDB->m_rgModuleExes.Add(this, pDB, TRUE);
        } else {
            pDB->m_rgExes.Add(this, pDB, TRUE);
        }
    }

    m_AppHelpRef.m_pDB = pDB;
    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    VariantClear(&vType);
    VariantClear(&vValue);

    return bSuccess;
}

////////////////////////////////////////////////////////////////////////
//
// Read in MSI Package tag
//      <MSI_PACKAGE NAME="my msi package" ID="{xxxxx}">
//          <DATA NAME="Additional Data" VALUETYPE="DWORD" VALUE="0x233"/>
//          <MSI_TRANSFORM NAME="Apply Me for a fix"/>
//      </MSI_PACKAGE>
//

SdbDatabase* CastDatabaseToFixDatabase(SdbDatabase* pDB)
{
    const type_info& TypeInfoFixDB = typeid(SdbDatabase);
    const type_info& TypeInfoDB    = typeid(*pDB);
    if (TypeInfoDB == TypeInfoFixDB) {
        return (SdbDatabase*)pDB;
    }

    //
    // bad error
    //
    SDBERROR_FORMAT((_T("Internal Compiler Error: Bad cast operation on Database object\n")));

    return NULL;
}


BOOL SdbMsiPackage::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL bSuccess = FALSE;
    CString csID;
    CString csTemp;
    XMLNodeList    XQL;
    IXMLDOMNodePtr cpMessage;

    SdbDatabase* pFixDB = CastDatabaseToFixDatabase(pDB);
    if (pFixDB == NULL) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_pApp = pFixDB->m_pCurrentApp;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!ProcureGuidIDAttribute(pDB, pNode, &m_ID, &csID)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (g_bStrict) {
        if (!CheckExeID(pDB, this, csID)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }
    }

    if (!GetAttribute(_T("PRODUCT_CODE"), pNode, &csID)) {
        //
        // Guid was not found. We do not generate ids for packages -- they are
        // statically defined attributes provided to identify the package
        //
        SDBERROR_FORMAT((_T("MSI_PACKAGE requires PRODUCT_CODE attribute\n%s\n"),
                             GetXML(pNode)));
        goto eh;
    }

    if (!GUIDFromString(csID, &m_MsiPackageID)) {
        //
        // This is the case when we cannot parse the guid and it appears to be
        // an invalid guid.
        //
        SDBERROR_FORMAT((_T("ID attribute is not a valid GUID\n%s\n"), csID));
        goto eh;
    }

    //
    // procure RUNTIME_PLATFORM attribute
    //

    if (GetAttribute(_T("RUNTIME_PLATFORM"), pNode, &csTemp)) {
        if (!DecodeRuntimePlatformString(csTemp, &m_dwRuntimePlatform)) {
            SDBERROR_FORMAT((_T("RUNTIME_PLATFORM no in recognized format: \"%s\"\n%s\n"),
                              (LPCTSTR)csTemp, GetXML(pNode)));
            goto eh;
        }
    }

    //
    // Check what OS SKU this entry is meant for
    //
    if (GetAttribute(_T("OS_SKU"), pNode, &csTemp)) {
        //
        // Decode it. This string is a semi-colon delimited set
        // of OS SKUs.
        //
        if (!DecodeString(csTemp, &m_dwOSSKU, GetOSSKUType)) {
            SDBERROR_FORMAT((_T("OS_SKU attribute syntax error: %s"), csTemp));
            goto eh;
        }
    }

    //
    // read supplemental data for this object
    //
    if (!m_rgData.ReadFromXML(_T("DATA"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // we have name, guid(id) and supplemental data, read fixes for this package
    //
    if (!m_rgMsiTransformRefs.ReadFromXML(_T("MSI_TRANSFORM"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!m_rgCustomActions.ReadFromXML(_T("CUSTOM_ACTION"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Read APPHELP refs
    //
    if (!XQL.Query(pNode, _T("APPHELP"))) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (XQL.GetSize() > 1) {
        SDBERROR_FORMAT((_T("Multiple <APPHELP> tags per <MSI_PACKAGE> not allowed\n%s\n"),
                         GetXML(pNode)));
        goto eh;
    }

    if (XQL.GetSize() == 1) {
        if (!XQL.GetItem(0, &cpMessage)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (!m_AppHelpRef.ReadFromXML(cpMessage, pDB)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }
    }

    pDB->m_rgMsiPackages.Add(this, pDB, TRUE);

    m_AppHelpRef.m_pDB = pDB;
    m_pDB = pDB;

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL
SdbMsiCustomAction::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB
    )
{

    BOOL bSuccess = FALSE;

    if (!GetAttribute(_T("NAME"), pNode, &m_csName)) {
        SDBERROR_FORMAT((_T("<CUSTOM_ACTION> requires NAME attribute:\n%s\n\n"),
                         GetXML(pNode)));
        goto eh;
    }

    if (!m_rgShimRefs.ReadFromXML(_T("SHIM"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!m_rgLayerRefs.ReadFromXML(_T("LAYER"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_pDB = pDB;

    bSuccess = TRUE;
eh:

    return bSuccess;

}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Read in MSI_TRANSFORM tag
//      <MSI_TRANSFORM NAME="This is transform name" FILE="This is filename.foo">
//          <DESCRIPTION>
//              blah blah blah
//          </DESCRIPTION>
//      </MSI_TRANSFORM>
//

BOOL SdbMsiTransform::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL bSuccess = FALSE;
    IXMLDOMNodePtr cpDesc, cpFile;
    XMLNodeList XQL;

    SdbDatabase* pFixDB = CastDatabaseToFixDatabase(pDB);
    if (pFixDB == NULL) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    // read msi Transform from the library
    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!XQL.Query(pNode, _T("FILE"))) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (XQL.GetSize() == 0 ||
        XQL.GetSize() > 1) {
        SDBERROR_FORMAT((_T("<MSI_TRANSFORM> requires one and only one <FILE> child:\n%s\n\n"),
                         GetXML(pNode)));
        goto eh;
    }

    if (!XQL.GetItem(0, &cpFile)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!GetAttribute(_T("NAME"), cpFile, &m_csMsiTransformFile)) {
        SDBERROR_FORMAT((_T("<FILE> requires NAME attribute:\n%s\n\n"),
                         GetXML(pNode)));
        goto eh;
    }

    if (GetChild(_T("DESCRIPTION"), pNode, &cpDesc)) {
        GetNodeText(cpDesc, m_csDesc);
    }

    //
    // name should be unique for each of thesee transforms, enforce
    //

    if (pFixDB->m_Library.m_rgMsiTransforms.LookupName(m_csName) != NULL) {
        SDBERROR_FORMAT((_T("MSI_TRANSFORM NAME attribute is not unique\n%s\n\n"),
                         GetXML(pNode)));
        goto eh;
    }

    //
    // find corresponding file object
    //
    if (m_csMsiTransformFile.GetLength()) {
        m_pSdbFile = (SdbFile*)pFixDB->m_Library.m_rgFiles.LookupName(m_csMsiTransformFile);
        if (g_bStrict && m_pSdbFile == NULL) {
            SDBERROR_FORMAT((_T("<MSI_TRANSFORM specifies FILE which is not available in the library\n%s\n\n"),
                             GetXML(pNode)));
            goto eh;
        }
    }

    bSuccess = TRUE;

eh:
    return bSuccess;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Read the reference to the transform object
//      <MSI_TRANSFORM NAME="name-reference-to the transform in library"/>
//

BOOL SdbMsiTransformRef::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL    bSuccess            = FALSE;
    SdbDatabase* pFixDB      = NULL;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    pFixDB = CastDatabaseToFixDatabase(pDB);
    if (pFixDB == NULL) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_pMsiTransform = (SdbMsiTransform *) pFixDB->m_Library.m_rgMsiTransforms.LookupName(m_csName);
    if (m_pMsiTransform == NULL && g_bStrict) {
        SDBERROR_FORMAT((_T("MSI_TRANSFORM \"%s\" not found in library:\n%s\n\n"),
                          m_csName, GetXML(pNode)));
        goto eh;
    }


    m_pDB = pDB; // set the root db pointer (why???)

    bSuccess = TRUE;

eh:
    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////////////////////////

BOOL SdbMatchingFile::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL            bSuccess    = FALSE;
    CString         csTemp;

    GetAttribute(_T("SERVICE_NAME"), pNode, &m_csServiceName);

    if (!GetAttribute(_T("NAME"), pNode, &m_csName)) {
        if (GetNodeName(pNode) == _T("EXE")) {
            m_csName = _T("*");
        } else if (m_csServiceName.IsEmpty()) {
            SDBERROR_FORMAT((_T("NAME attribute required:\n%s\n\n"),
                              GetXML(pNode)));
            goto eh;
        }
    }

    if (GetParentNodeName(pNode) == _T("WIN9X_MIGRATION") ||
        GetNodeName(pNode) == _T("MATCH_ANY") ||
        GetNodeName(pNode) == _T("MATCH_ALL")) {
        if (-1 != m_csName.Find(_T("\\"))) {
            SDBERROR_FORMAT((_T("<MATCHING_FILE> inside <WIN9X_MIGRATION> cannot contain relative paths:\n%s\n"),
                              GetXML(pNode)));
            goto eh;
        }
    }

    m_dwMask = 0;

    if (GetAttribute(_T("SIZE"), pNode, &csTemp)) {
        m_dwSize = StringToDword(csTemp);
        m_dwMask |= SDB_MATCHINGINFO_SIZE;
    } else {
        m_dwSize = 0;
    }

    if (GetAttribute(_T("CHECKSUM"), pNode, &csTemp)) {
        m_dwChecksum = StringToDword(csTemp);
        m_dwMask |= SDB_MATCHINGINFO_CHECKSUM;
    } else
        m_dwChecksum = 0;

    if (GetAttribute(_T("COMPANY_NAME"), pNode, &(m_csCompanyName))) {
        m_dwMask |= SDB_MATCHINGINFO_COMPANY_NAME;
    }

    if (GetAttribute(_T("PRODUCT_NAME"), pNode, &(m_csProductName))) {
        m_dwMask |= SDB_MATCHINGINFO_PRODUCT_NAME;
    }

    if (GetAttribute(_T("PRODUCT_VERSION"), pNode, &(m_csProductVersion))) {
        m_dwMask |= SDB_MATCHINGINFO_PRODUCT_VERSION;
    }

    if (GetAttribute(_T("FILE_DESCRIPTION"), pNode, &(m_csFileDescription))) {
        m_dwMask |= SDB_MATCHINGINFO_FILE_DESCRIPTION;
    }

    if (GetAttribute(_T("BIN_FILE_VERSION"), pNode, &csTemp)) {
        if (!VersionToQword(csTemp, &m_ullBinFileVersion)) {
            SDBERROR_FORMAT((_T("Bad BIN_FILE_VERSION attribute:\n\n%s\n"), GetXML(pNode)));
            goto eh;
        }
        m_dwMask |= SDB_MATCHINGINFO_BIN_FILE_VERSION;
    }

    if (GetAttribute(_T("BIN_PRODUCT_VERSION"), pNode, &csTemp)) {
        if (!VersionToQword(csTemp, &m_ullBinProductVersion)) {
            SDBERROR_FORMAT((_T("Bad BIN_PRODUCT_VERSION attribute:\n\n%s\n"), GetXML(pNode)));
            goto eh;
        }
        m_dwMask |= SDB_MATCHINGINFO_BIN_PRODUCT_VERSION;
    }

    if (GetAttribute(_T("MODULE_TYPE"), pNode, &csTemp)) {
        if (!GetModuleTypeIndicator(csTemp, &m_dwModuleType)) {
            SDBERROR_FORMAT((_T("<MATCHING_FILE> MODULE_TYPE attribute unrecognized:\n%s\n"),
                              GetXML(pNode)));
            goto eh;
        }
        m_dwMask |= SDB_MATCHINGINFO_MODULE_TYPE;
    }

    if (GetAttribute(_T("VERFILEDATELO"), pNode, &csTemp)) {
        m_dwFileDateLS = StringToDword(csTemp);
        m_dwMask |= SDB_MATCHINGINFO_VERFILEDATELO;
    }

    if (GetAttribute(_T("VERFILEDATEHI"), pNode, &csTemp)) {
        m_dwFileDateMS = StringToDword(csTemp);
        m_dwMask |= SDB_MATCHINGINFO_VERFILEDATEHI;
    }

    if (GetAttribute(_T("VERFILEOS"), pNode, &csTemp)) {
        m_dwFileOS = StringToDword(csTemp);
        m_dwMask |= SDB_MATCHINGINFO_VERFILEOS;
    }

    if (GetAttribute(_T("VERFILETYPE"), pNode, &csTemp)) {
        m_dwFileType = StringToDword(csTemp);
        m_dwMask |= SDB_MATCHINGINFO_VERFILETYPE;
    }

    if (GetAttribute(_T("PE_CHECKSUM"), pNode, &csTemp)) {
        m_ulPECheckSum = StringToULong(csTemp);
        m_dwMask |= SDB_MATCHINGINFO_PE_CHECKSUM;
    }

    if (GetAttribute(_T("LINKER_VERSION"), pNode, &csTemp)) {
        m_dwLinkerVersion = StringToDword(csTemp);
        m_dwMask |= SDB_MATCHINGINFO_LINKER_VERSION;
    }

    if (GetAttribute(_T("FILE_VERSION"), pNode, &m_csFileVersion)) {
        m_dwMask |= SDB_MATCHINGINFO_FILE_VERSION;
    }

    if (GetAttribute(_T("ORIGINAL_FILENAME"), pNode, &m_csOriginalFileName)) {
        m_dwMask |= SDB_MATCHINGINFO_ORIGINAL_FILENAME;
    }

    if (GetAttribute(_T("INTERNAL_NAME"), pNode, &m_csInternalName)) {
        m_dwMask |= SDB_MATCHINGINFO_INTERNAL_NAME;
    }

    if (GetAttribute(_T("LEGAL_COPYRIGHT"), pNode, &m_csLegalCopyright)) {
        m_dwMask |= SDB_MATCHINGINFO_LEGAL_COPYRIGHT;
    }

    if (GetAttribute(_T("S16BIT_DESCRIPTION"), pNode, &m_cs16BitDescription)) {
        m_dwMask |= SDB_MATCHINGINFO_16BIT_DESCRIPTION;
    }

    if (GetAttribute(_T("S16BIT_MODULE_NAME"),  pNode, &m_cs16BitModuleName)) {
        m_dwMask |= SDB_MATCHINGINFO_16BIT_MODULE_NAME;
    }

    if (GetAttribute(_T("UPTO_BIN_PRODUCT_VERSION"), pNode, &csTemp)) {
        if (!VersionToQword(csTemp, &m_ullUpToBinProductVersion)) {
            SDBERROR_FORMAT((_T("Bad UPTO_BIN_PRODUCT_VERSION attribute:\n\n%s\n"), GetXML(pNode)));
            goto eh;
        }
        m_dwMask |= SDB_MATCHINGINFO_UPTO_BIN_PRODUCT_VERSION;
    }

    if (GetAttribute(_T("UPTO_BIN_FILE_VERSION"), pNode, &csTemp)) {
        if (!VersionToQword(csTemp, &m_ullUpToBinFileVersion)) {
            SDBERROR_FORMAT((_T("Bad UPTO_BIN_FILE_VERSION attribute:\n\n%s\n"), GetXML(pNode)));
            goto eh;
        }
        m_dwMask |= SDB_MATCHINGINFO_UPTO_BIN_FILE_VERSION;
    }

    if (GetAttribute(_T("PREVOSMAJORVERSION"), pNode, &csTemp)) {
        m_dwPrevOSMajorVersion = StringToDword(csTemp);
        m_dwMask |= SDB_MATCHINGINFO_PREVOSMAJORVERSION;
    }

    if (GetAttribute(_T("PREVOSMINORVERSION"), pNode, &csTemp)) {
        m_dwPrevOSMinorVersion = StringToDword(csTemp);
        m_dwMask |= SDB_MATCHINGINFO_PREVOSMINORVERSION;
    }

    if (GetAttribute(_T("PREVOSPLATFORMID"), pNode, &csTemp)) {
        m_dwPrevOSPlatformID = StringToDword(csTemp);
        m_dwMask |= SDB_MATCHINGINFO_PREVOSPLATFORMID;
    }

    if (GetAttribute(_T("PREVOSBUILDNO"), pNode, &csTemp)) {
        m_dwPrevOSBuildNo = StringToDword(csTemp);
        m_dwMask |= SDB_MATCHINGINFO_PREVOSBUILDNO;
    }

    if (GetAttribute(_T("LINK_DATE"), pNode, &csTemp)) {
        if (!MakeUTCTime(csTemp, &m_timeLinkDate)) {
            SDBERROR_FORMAT((_T("LINK_DATE not in recognized time format: \"%s\"\n%s\n"),
                              csTemp,
                              GetXML(pNode)));
            goto eh;
        }
        m_dwMask |= SDB_MATCHINGINFO_LINK_DATE;
    }

    if (GetAttribute(_T("UPTO_LINK_DATE"), pNode, &csTemp)) {
        if (!MakeUTCTime(csTemp, &m_timeUpToLinkDate)) {
            SDBERROR_FORMAT((_T("UPTO_LINK_DATE not in recognized time format: \"%s\"\n%s\n"),
                              csTemp,
                              GetXML(pNode)));
            goto eh;
        }
        m_dwMask |= SDB_MATCHINGINFO_UPTO_LINK_DATE;
    }

    if (GetAttribute(_T("VER_LANGUAGE"), pNode, &csTemp)) {

        if (!ParseLanguageID(csTemp, &m_dwVerLanguage)) {
            SDBERROR_FORMAT((_T("VER_LANGUAGE not in recognized format: \"%s\"\n%s\n"),
                             (LPCTSTR)csTemp,
                             GetXML(pNode)));
            goto eh;
        }

        m_dwMask |= SDB_MATCHINGINFO_VER_LANGUAGE;
    }


    if (GetAttribute(_T("REGISTRY_ENTRY"), pNode, &m_csRegistryEntry)) {
        m_dwMask |= SDB_MATCHINGINFO_REGISTRY_ENTRY;
    }

    if (GetAttribute(_T("LOGIC"), pNode, &csTemp)) {
        if (0 == csTemp.CompareNoCase(_T("NOT"))) {
            m_bMatchLogicNot = TRUE;
        }
    }

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbMatchingRegistryEntry::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL            bSuccess    = FALSE;
    CString         csTemp;

    if (!GetAttribute(_T("KEY"), pNode, &m_csName)) {
        SDBERROR_FORMAT((_T("<MATCHING_REGISTRY_ENTRY> requires KEY attribute:\n%s\n\n"),
                          GetXML(pNode)));
        goto eh;
    }

    GetAttribute(_T("VALUE_NAME"), pNode, &m_csValueName);
    GetAttribute(_T("VALUE"), pNode, &m_csValue);

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbAppHelpRef::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL            bSuccess        = FALSE;
    SdbMessage*     pMessage        = NULL;
    SdbAppHelpRef*  pAppHelpRef     = NULL;
    BOOL            bBlockUpgrade   = FALSE;
    long i;
    CString     csHTMLHELPID, csType, csURL, csMessage;
    IXMLDOMNodePtr  cpParentNode;
    SdbAppHelpType Type = SDB_APPHELP_NOBLOCK;

    if (FAILED(pNode->get_parentNode(&cpParentNode))) {
        SDBERROR_FORMAT((_T("Error retrieving parent node of APPHELP: %s\n"),
            GetXML(pNode)));
        goto eh;
    }

    if (!GetAttribute(_T("MESSAGE"), pNode, &csMessage)) {
        SDBERROR_FORMAT((_T("<APPHELP> requires MESSAGE attribute:\n%s\n"),
                       GetXML(pNode)));
        goto eh;
    }

    //
    // get a custom URL, if one is available
    //
    GetAttribute(_T("DETAILS_URL"), pNode, &csURL);

    //
    // Get BLOCK attribute
    //
    Type = SDB_APPHELP_NOBLOCK;
    if (GetAttribute(_T("BLOCK"), pNode, &csType)) {
        if (GetNodeName(cpParentNode) == _T("WINNT_UPGRADE") ||
            GetNodeName(cpParentNode) == _T("SYS")) {
            SDBERROR_FORMAT((_T("<APPHELP> within <WINNT_UPGRADE> or <SYS> ")
                             _T("cannot use BLOCK attribute. Use BLOCK_UPGRADE instead.\n\n%s\n"),
                             GetXML(cpParentNode)));
            goto eh;
        }

        if (csType == _T("YES")) {
            Type = SDB_APPHELP_HARDBLOCK;
        }
    }

    if (GetAttribute(_T("BLOCK_UPGRADE"), pNode, &csType)) {
        if (GetNodeName(cpParentNode) != _T("WINNT_UPGRADE") &&
            GetNodeName(cpParentNode) != _T("SYS")) {
            SDBERROR_FORMAT((_T("<APPHELP> not within <WINNT_UPGRADE> or <SYS> ")
                             _T("cannot use BLOCK_UPGRADE attribute.\n\n%s\n"),
                             GetXML(cpParentNode)));
            goto eh;
        }

        if (csType == _T("YES")) {
            bBlockUpgrade = TRUE;
        }
    }

    if (m_cpNode == NULL &&
        !GetAttribute(_T("HTMLHELPID"), pNode, &csHTMLHELPID)) {
        //
        // Need to generate a new HTMLHELPID. Wait until
        // the rest of the <APPHELP> tags for this app have
        // been parsed and then we'll pass over this again.
        //
        pDB->m_pCurrentApp->m_rgAppHelpRefs.Add(this);
        m_cpNode = pNode;
        bSuccess = TRUE;
        goto eh;
    }

    if (!GetAttribute(_T("HTMLHELPID"), pNode, &csHTMLHELPID)) {

        //
        // HTMLHELPID not found. Generate it.
        //
        for (i = 0; i < pDB->m_pCurrentApp->m_rgAppHelpRefs.GetSize(); i++) {
            pAppHelpRef = (SdbAppHelpRef *) pDB->m_pCurrentApp->m_rgAppHelpRefs.GetAt(i);

            if (pAppHelpRef->m_pAppHelp) {
                if (pAppHelpRef->m_pAppHelp->m_csMessage == csMessage &&
                    pAppHelpRef->m_pAppHelp->m_Type == Type &&
                    pAppHelpRef->m_pAppHelp->m_csURL == csURL &&
                    pAppHelpRef->m_pAppHelp->m_bBlockUpgrade == bBlockUpgrade) {
                    csHTMLHELPID = pAppHelpRef->m_pAppHelp->m_csName;
                }
            }
        }

        if (csHTMLHELPID.IsEmpty()) {
            csHTMLHELPID.Format(_T("%d"), pDB->GetNextSequentialID(_T("HTMLHELPID")));
        }

        if (!AddAttribute(pNode, _T("HTMLHELPID"), csHTMLHELPID)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        pDB->m_pCurrentInputFile->m_bSourceUpdated = TRUE;
    }

    //
    // Create an AppHelp entry if one isn't there
    //
    m_pAppHelp = (SdbAppHelp *) pDB->m_rgAppHelps.LookupName(csHTMLHELPID);

    if (m_pAppHelp == NULL) {
        m_pAppHelp = new SdbAppHelp;

        m_pAppHelp->m_csName = csHTMLHELPID;
        m_pAppHelp->m_csMessage = csMessage;
        m_pAppHelp->m_csURL = csURL;
        m_pAppHelp->m_pApp = pDB->m_pCurrentApp;
        m_pAppHelp->m_Type = Type;
        m_pAppHelp->m_bBlockUpgrade = bBlockUpgrade;

        pDB->m_rgAppHelps.Add(m_pAppHelp, pDB);
    } else {
        if (m_pAppHelp->m_pApp != pDB->m_pCurrentApp ||
            m_pAppHelp->m_csMessage != csMessage ||
            m_pAppHelp->m_Type != Type ||
            m_pAppHelp->m_bBlockUpgrade != bBlockUpgrade ||
            m_pAppHelp->m_csURL != csURL) {
            SDBERROR_FORMAT((_T("Duplicate HTMLHELPID with differing APP, MESSAGE, BLOCK or DETAILS_URL: %s\n"),
                csHTMLHELPID));
            goto eh;
        }
    }

    pDB->m_pCurrentApp->m_rgAppHelpRefs.Add(this);
    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}


BOOL SdbMessage::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL                bSuccess        = FALSE;
    IXMLDOMNodePtr      cpChild;
    CString             csTemplate, csID;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_csLangID = pDB->m_csCurrentLangID;

    if (GetAttribute(_T("TEMPLATE"), pNode, &csTemplate)) {
        m_pTemplate = (SdbMessageTemplate *)
            pDB->m_rgMessageTemplates.LookupName(csTemplate, m_csLangID);

        if (m_pTemplate == NULL) {
            SDBERROR_FORMAT((_T("Template \"%s\" not previously declared."), csTemplate));
            goto eh;
        }
    }

    if (!ProcureGuidIDAttribute(pDB, pNode, &m_ID, &csID)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (GetChild(_T("CONTACT_INFO"), pNode, &cpChild)) {
        m_csContactInfoXML = GetInnerXML(cpChild);
        cpChild.Release();
    }

    if (GetChild(_T("SUMMARY"), pNode, &cpChild)) {
        m_csSummaryXML = GetInnerXML(cpChild);
        cpChild.Release();
    }

    if (GetChild(_T("DETAILS"), pNode, &cpChild)) {
        m_csDetailsXML = GetInnerXML(cpChild);
        cpChild.Release();
    } else {
        m_csDetailsXML = m_csSummaryXML;
    }

    if (!m_rgFields.ReadFromXML(_T("FIELD"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbMessageTemplate::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL            bSuccess            = FALSE;
    IXMLDOMNodePtr  cpChild;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_csLangID = pDB->m_csCurrentLangID;

    if (GetChild(_T("SUMMARY"), pNode, &cpChild)) {
        m_csSummaryXML = GetInnerXML(cpChild);
        cpChild.Release();
    }

    if (GetChild(_T("DETAILS"), pNode, &cpChild)) {
        m_csDetailsXML = GetInnerXML(cpChild);
        cpChild.Release();
    } else {
        m_csDetailsXML = m_csSummaryXML;
    }

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbContactInfo::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL    bSuccess            = FALSE;
    CString csID;

    if (!GetAttribute(_T("VENDOR"), pNode, &m_csName)) {
        SDBERROR_FORMAT((_T("<CONTACT_INFO> requires VENDOR attribute:\n%s\n"), GetXML(pNode)));
        goto eh;
    }

    m_csLangID = pDB->m_csCurrentLangID;

    if (!ProcureGuidIDAttribute(pDB, pNode, &m_ID, &csID)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_csXML = GetInnerXML(pNode);

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}


BOOL SdbData::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL    bSuccess            = FALSE;
    CString csValueType;
    CString csValueAttr;
    CString csValueText;
    DWORD   dwType;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!GetAttribute(_T("VALUETYPE"), pNode, &csValueType)) {
        SDBERROR(_T("<DATA> requires VALUETYPE attribute."));
        goto eh;
    }

    if (!GetDataTypeIndicator(csValueType, &dwType)) {
        SDBERROR_FORMAT((_T("<DATA> VALUETYPE \"%s\" not recognized."), csValueType));
        goto eh;
    }

    GetNodeText(pNode, csValueText);

    GetAttribute(_T("VALUE"), pNode, &csValueAttr);

    if (csValueText.GetLength() && csValueAttr.GetLength()) {
        SDBERROR_FORMAT((_T("<DATA NAME=\"%s\"> cannot contain both VALUE attribute and inner text."), m_csName));
        goto eh;
    } else if (csValueText.GetLength()) {
        SetValue((SdbDataValueType) dwType, csValueText);
    } else if (csValueAttr.GetLength()) {
        SetValue((SdbDataValueType) dwType, csValueAttr);
    }

    m_DataType = (SdbDataValueType) dwType;

    // finally, read all the child data elements
    if (!m_rgData.ReadFromXML(_T("DATA"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbAction::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL    bSuccess            = FALSE;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    GetAttribute(_T("TYPE"), pNode, &m_csType);

    if (!m_rgData.ReadFromXML(_T("DATA"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbMessageField::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL    bSuccess            = FALSE;

    if (!ReadName(pNode, &m_csName)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_csValue = GetInnerXML(pNode);

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbMatchOperation::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB
    )
{
    BOOL    bSuccess            = FALSE;

    if (GetNodeName(pNode) == _T("MATCH_ANY")) {
        m_Type = SDB_MATCH_ANY;
    } else {
        m_Type = SDB_MATCH_ALL;
    }

    if (!m_rgMatchingFiles.ReadFromXML(_T("MATCHING_FILE"), pDB, pNode)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!m_rgSubMatchOps.ReadFromXML(_T("MATCH_ALL | MATCH_ANY"), pDB, pNode, NULL, FALSE, NULL)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL SdbWin9xMigration::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL    bSuccess            = FALSE;
    CString csID, csTemp;

    m_pApp = pDB->m_pCurrentApp; // grab app pointer from the db

    if (!GetAttribute(_T("SECTION"), pNode, &m_csSection)) {
        SDBERROR_FORMAT((_T("<WIN9X_MIGRATION> tag requires SECTION attribute:\n%s\n"),
                       GetXML(pNode)));
        goto eh;
    }

    GetAttribute(_T("MESSAGE"), pNode, &m_csMessage);

    if (!ProcureGuidIDAttribute(pDB, pNode, &m_ID, &csID)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (g_bStrict) {
        if (!CheckExeID(pDB, this, csID)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }
    }

    if (GetAttribute(_T("SHOW_IN_SIMPLIFIED_VIEW"), pNode, &csTemp)) {
        m_bShowInSimplifiedView = (csTemp.CompareNoCase(_T("YES")) == 0);
    }

    if (!m_MatchOp.ReadFromXML(pNode, pDB)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    m_pDB = pDB;

    bSuccess = TRUE;

eh:
    return bSuccess;
}


BOOL SdbWinNTUpgrade::ReadFromXML(
    IXMLDOMNode* pNode,
    SdbDatabase* pDB)
{
    BOOL    bSuccess            = FALSE;
    BOOL    bMF                 = FALSE;
    CString csType, csHTMLHELPID, csID;
    XMLNodeList XQL;
    IXMLDOMNodePtr cpNewNode, cpAppNode;

    m_pApp = pDB->m_pCurrentApp; // grab app pointer from the db

    XQL.Query(pNode, _T("APPHELP"));

    if (XQL.GetSize() > 1) {
        SDBERROR_FORMAT((_T("<WINNT_UPGRADE> blocks can only contain one <APPHELP> entry:\n%s\n"),
                       GetXML(pNode)));
        goto eh;
    } else if (XQL.GetSize() == 1) {

        if (!XQL.GetItem(0, &cpNewNode)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (!m_AppHelpRef.ReadFromXML(cpNewNode, pDB)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }
    }

    if (!ProcureGuidIDAttribute(pDB, pNode, &m_ID, &csID)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    XQL.Query(pNode, _T("MATCHING_FILE"));

    if (XQL.GetSize() > 1) {
        SDBERROR_FORMAT((_T("<WINNT_UPGRADE> blocks can only contain one <MATCHING_xxx> entry:\n%s\n"),
                       GetXML(pNode)));
        goto eh;
    } else if (XQL.GetSize() == 1) {

        if (!XQL.GetItem(0, &cpNewNode)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (!m_MatchingFile.ReadFromXML(cpNewNode, pDB)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        bMF = TRUE;
    }

    XQL.Query(pNode, _T("MATCHING_REGISTRY_ENTRY"));

    if (XQL.GetSize() > 1 ||
       (XQL.GetSize() == 1 && bMF)) {
        SDBERROR_FORMAT((_T("<WINNT_UPGRADE> blocks can only contain one <MATCHING_xxx> entry:\n%s\n"),
                       GetXML(pNode)));
        goto eh;
    } else if(XQL.GetSize() == 1) {

        if (!XQL.GetItem(0, &cpNewNode)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (!m_MatchingRegistryEntry.ReadFromXML(cpNewNode, pDB)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        bMF = TRUE;
    }

    m_AppHelpRef.m_pDB = pDB;
    m_pDB = pDB;

    pDB->m_rgWinNTUpgradeEntries.Add(this, pDB);

    bSuccess = TRUE;

eh:
    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by shimdbc.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\sources.inc ===
!IF 0

Copyright (c) 1999  Microsoft Corporation

!ENDIF
MAJORCOMP=appcompat
MINORCOMP=shimdbc

USE_MFCUNICODE=1
USE_LATEST_MFC=1


C_DEFINES=/D_UNICODE
CXX_COMPILER_FLAGS=/GR

USER_INCLUDES=$(WINDOWS_INC_PATH)

INCLUDES=$(INCLUDES);..

TARGETNAME=shimdbc
TARGETPATH=$(_OBJ_DIR)

WIN32_WINNT_VERSION=0x0400

MSC_WARNING_LEVEL=/W3 /WX

SOURCES= \
    ..\shimdbc.rc          \
    ..\shimdbc.cpp         \
    ..\obj.cpp             \
    ..\xml.cpp             \
    ..\read.cpp            \
    ..\globals.cpp         \
    ..\fileio.cpp          \
    ..\write.cpp           \
    ..\chm.cpp             \
    ..\registry.cpp        \
    ..\utils.c             \
    ..\stats.cpp           \
    ..\mig.cpp             \
    ..\ntcompat.cpp        \
    ..\make.cpp


PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\shimdbc.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    shimdbc.cpp
//
// History: 19-Nov-99   markder     Created.
//           1-Feb-00   markder     Revised to read/write to ShimDB.
//           1-Apr-00   vadimb      Revised to work with apphelp entries
//          13-Dec-00   markder     Version 2
//          13-Dec-00   vadimb      Version 2.00.10 MSI support
//          03-Dec-01   vadimb      Version 2.01.13 Fix Memory patch write routine
//          15-Feb-01   markder/vadimb 2.01.14 Fix Install section format for migdb
//          07-Feb-01   vadimb      Version 2.01.15 MSI support (nested DATA)
//          21-Feb-01   vadimb      Version 2.01.16 16-bit module name attribute,
//                                  fix 16-bit description
//          06-Mar-01   markder     Version 2.02.11 MSI filter support
//          12-Mar-01   vadimb      Version 2.03.00 Migration support, part deux
//          28-Mar-01   markder     Version 2.04.00 Driver DB support, NtCompat support
//          29-Mar-01   vadimb      Version 2.04.11 Driver DB indexing
//          11-Apr-01   dmunsil     Version 2.04.12 Driver DB support, NtCompat support
//          12-Apr-01   vadimb      Version 2.04.13 MSI shimming support
//          18-Apr-01   vadimb      Version 2.04.15 MSI dynamic shim bugfix
//          15-Jan-02   jdoherty    Version 2.04.59 Add ID to additional tags.
//          19-Mar-02   kinshu      Version 2.04.63 Bug# 529272
//          22-Mar-02   markder     Version 2.05.00 Multi-language database support
//          22-Apr-02   rparsons    Version 2.05.01 Fix regression in patch write routine
//          08-Apr-02   maonis      Version 2.05.02 Adding 2 new OS_SKU tags to recognize
//                                  TabletPC and eHome
//          22-May-02   vadimb      Version 2.05.03 Add OS_SKU to msi package entries

//
// Desc:    This file contains the entry point and main functions
//          of the Shim database compiler.
//
////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "typeinfo.h"
#include "registry.h"
#include "ntcompat.h"
#include "chm.h"
#include "mig.h"
#include "make.h"
#include "stats.h"

#ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////////////////////////////////////////////////////////////////////////
//          Global variables
////////////////////////////////////////////////////////////////////////////////////

#ifdef USE_CWIN
CWinApp      theApp;                           // Needed for MFC
#endif // USE_CWIN

BOOL         g_bQuiet      = FALSE;            // Quiet mode
TCHAR        g_szVersion[] = _T("v2.05.04a");   // Version string
BOOL         g_bStrict     = FALSE;            // Strict checking
CStringArray g_rgErrors;                       // Error message stack

////////////////////////////////////////////////////////////////////////////////////
//          Forward declarations of functions
////////////////////////////////////////////////////////////////////////////////////
void PrintHelp();

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   main
//
//  Desc:   Entry point.
//
extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
    int                     nRetCode    = 1;
    int                     i;
    DOUBLE                  flOSVersion = 0.0;

    SdbDatabase*            pDatabase = new SdbDatabase();
    CString                 csOutputFile;
    CString                 csOutputDir;
    CString                 csInputDir;
    CString                 csTemp;
    CString                 csMigDBFile;
    CString                 csMakefile;
    SdbMakefile             Makefile;
    SdbInputFile*           pInputFile = NULL;
    SdbInputFile*           pRefFile = NULL;
    SdbOutputFile*          pOutputFile = NULL;
    SdbOutputFile*          pOtherFile = NULL;

    BOOL                    bCreateHTMLHelpFiles    = FALSE;
    BOOL                    bCreateRegistryFiles    = FALSE;
    BOOL                    bAddExeStubs            = FALSE;
    BOOL                    bCreateMigDBFiles       = FALSE;
    BOOL                    bUseNameInAppHelpURL    = FALSE;
    LONG                    nPrintStatistics        = 0;

    //
    // Initialize MFC and print and error on failure
    //

    if (!AfxWinInit(::GetModuleHandle(NULL), NULL, ::GetCommandLine(), 0)) {
        PrintError(_T("Fatal Error: MFC initialization failed\n"));
        goto eh;
    }

    //
    // Print banner
    //
    if (!g_bQuiet) {
        Print(_T("\nMicrosoft Application Compatibility Database Compiler  %s\n"), g_szVersion);
        Print(_T("Copyright (C) Microsoft Corp 2000-2002.  All rights reserved.\n\n"));
    }

    if (argc < 2) {
        PrintHelp();
        return 0;
    }

    //
    // Initialize COM
    //
    if (FAILED(CoInitialize(NULL))) {
        PrintError(_T("Could not initialize COM to get the MSXML object.\n"));
        goto eh;
    }

    //
    // Create default files (populated by command switches)
    //
    pInputFile = new SdbInputFile();
    pRefFile = new SdbInputFile();
    pOutputFile = new SdbOutputFile();

    //
    // Determine compile mode
    //
    pOutputFile->m_dwFilter = GetFilter(argv[1]);

    //
    // Parse command line
    //
    for (i = 2; i < argc; i++) {
        if (argv[i][0] == _T('-') || argv[i][0] == _T('/')) {
            switch (argv[i][1]) {
            case '?':
                PrintHelp();
                return 0;

            case 'a':
            case 'A':
                if (argv[i][2] == _T('n') ||
                    argv[i][2] == _T('N')) {
                    bUseNameInAppHelpURL = TRUE;
                }

                if (i < argc - 1) {
                    pRefFile->m_csName = MakeFullPath(argv[++i]);
                    Makefile.m_rgInputFiles.Add(pRefFile);
                } else {
                    PrintError(_T("Error -- not enough parameters.\n"));
                    goto eh;
                }
                break;

            case 'f':
            case 'F':
                if (i < argc - 1) {
                    csTemp = argv[++i];
                } else {
                    PrintError(_T("Error -- not enough parameters.\n"));
                    goto eh;
                }

                if (csTemp.Right(1) != _T("\\")) {
                    csTemp += _T("\\");
                }

                pOutputFile->m_mapParameters.SetAt(
                    _T("INCLUDE FILES"), csTemp );

                break;

            case 'h':
            case 'H':
                bCreateHTMLHelpFiles = TRUE;
                break;

            case 'l':
            case 'L':
                Makefile.m_csLangID = argv[++i];
                Makefile.m_csLangID.MakeUpper();
                break;

            case 'm':
            case 'M':
                bCreateMigDBFiles = TRUE;
                break;

            case 'o':
            case 'O':
                if (argv[i][2] == _T('v') ||
                    argv[i][2] == _T('V')) {
                    Makefile.m_flOSVersion = _tcstod(argv[++i], NULL);
                }
                if (argv[i][2] == _T('p') ||
                    argv[i][2] == _T('P')) {
                    Makefile.m_dwOSPlatform = GetOSPlatform(argv[++i]);
                }
                break;

            case 'q':
            case 'Q':
                g_bQuiet = TRUE;
                break;

            case 'r':
            case 'R':
                bCreateRegistryFiles = TRUE;
                if (argv[i][2] == _T('s') ||
                    argv[i][2] == _T('S')) {
                    bAddExeStubs = TRUE;
                }
                break;

            case 'k':
            case 'K':
                if (i < argc - 1) {
                    Makefile.AddHistoryKeywords(argv[++i]);
                } else {
                    PrintError(_T("Error -- not enough parameters.\n"));
                    goto eh;
                }
                break;

            case 's':
            case 'S':
                g_bStrict = TRUE;
                break;

            case 'v':
            case 'V':
                nPrintStatistics = 1;
                if (argv[i][2] == _T('s') ||
                    argv[i][2] == _T('S')) {
                    nPrintStatistics = 2;
                }
                break;

            case 'x':
            case 'X':
                if (i < argc - 1) {
                    csMakefile = MakeFullPath(argv[++i]);
                    if (!Makefile.ReadMakefile(csMakefile)) {
                        PrintErrorStack();
                        goto eh;
                    }
                } else {
                    PrintError(_T("Error -- not enough parameters.\n"));
                    goto eh;
                }

                break;
            }
        } else {
            //
            // The last entry is the output file.
            //
            if (pInputFile->m_csName.IsEmpty()) {
                pInputFile->m_csName = MakeFullPath(argv[i]);
            } else if (pOutputFile->m_csName.IsEmpty()) {
                pOutputFile->m_csName = MakeFullPath(argv[i]);
            } else {
                PrintError(_T("Too many parameters.\n"));
                goto eh;
            }
        }
    }

    //
    // Add default lang map entry
    //
    SdbLangMap* pNewMap = new SdbLangMap();
    pNewMap->m_csName = _T("---");
    pNewMap->m_dwCodePage = 1252;
    pNewMap->m_lcid = 0x409;

    Makefile.m_rgLangMaps.Add(pNewMap);

    //
    // Determine input/output directory
    //
    for (i = pInputFile->m_csName.GetLength() - 1; i >= 0; i--) {
        if (pInputFile->m_csName.GetAt(i) == _T('\\')) {
            csInputDir = pInputFile->m_csName.Left(i + 1);
            break;
        }
    }

    for (i = pOutputFile->m_csName.GetLength() - 1; i >= 0; i--) {
        if (pOutputFile->m_csName.GetAt(i) == _T('\\')) {
            csOutputDir = pOutputFile->m_csName.Left(i + 1);
            break;
        }
    }

    //
    // Strip .SDB from output file to allow easy extension concatenation
    //
    csTemp = pOutputFile->m_csName.Right(4);
    if (0 == csTemp.CompareNoCase(_T(".sdb"))) {
        csOutputFile = pOutputFile->m_csName.Left(
            pOutputFile->m_csName.GetLength() - 4);
    }

    //
    // Add additional output files if necessary
    //
    if (bCreateHTMLHelpFiles) {
        pOtherFile = new SdbOutputFile();
        Makefile.m_rgOutputFiles.Add(pOtherFile);

        pOtherFile->m_OutputType = SDB_OUTPUT_TYPE_HTMLHELP;
        pOtherFile->m_csName = csOutputDir + _T("apps.chm");

        if (bUseNameInAppHelpURL) {
            pOtherFile->m_mapParameters.SetAt(_T("USE NAME IN APPHELP URL"), _T("TRUE"));
        }

        pOtherFile->m_mapParameters.SetAt(_T("HTMLHELP TEMPLATE"), _T("WindowsXP"));
    }

    if (bCreateMigDBFiles) {

        //
        // INX file
        //
        if (pOutputFile->m_dwFilter == SDB_FILTER_FIX) {
            pOtherFile = new SdbOutputFile();
            Makefile.m_rgOutputFiles.Add(pOtherFile);

            pOtherFile->m_OutputType = SDB_OUTPUT_TYPE_MIGDB_INX;
            pOtherFile->m_csName = csOutputDir + _T("MigApp.inx");
        }

        if (pOutputFile->m_dwFilter == SDB_FILTER_APPHELP) {
            //
            // TXT file
            //
            pOtherFile = new SdbOutputFile();
            Makefile.m_rgOutputFiles.Add(pOtherFile);

            pOtherFile->m_OutputType = SDB_OUTPUT_TYPE_MIGDB_TXT;
            pOtherFile->m_csName = csOutputDir + _T("MigApp.txt");
        }
    }

    if (bCreateRegistryFiles) {

        pOtherFile = new SdbOutputFile();
        Makefile.m_rgOutputFiles.Add(pOtherFile);

        pOtherFile->m_OutputType = SDB_OUTPUT_TYPE_WIN2K_REGISTRY;
        pOtherFile->m_csName = csOutputFile;

        if (bAddExeStubs) {
            pOtherFile->m_mapParameters.SetAt(_T("ADD EXE STUBS"), _T("TRUE"));
        }
    }

    //
    // If default input/output files weren't used, delete them
    //
    if (pInputFile->m_csName.IsEmpty()) {
        delete pInputFile;
    } else {
        Makefile.m_rgInputFiles.Add(pInputFile);
    }

    if (pOutputFile->m_csName.IsEmpty()) {
        delete pOutputFile;
    } else {
        Makefile.m_rgOutputFiles.Add(pOutputFile);
    }

    pInputFile = NULL;
    pOutputFile = NULL;

    //
    // Check for at least one input and one output file
    //
    if (Makefile.m_rgInputFiles.GetSize() == 0) {
        PrintError(_T("No input file(s) specified.\n"));
        goto eh;
    }

    if (Makefile.m_rgOutputFiles.GetSize() == 0) {
        PrintError(_T("No output file(s) specified.\n"));
        goto eh;
    }

    pDatabase->m_pCurrentMakefile = &Makefile;

    //
    // Ensure that there is a valid LangMap specified
    //
    if (Makefile.GetLangMap(Makefile.m_csLangID) == NULL) {
        PrintError(_T("No LANG_MAP available for \"%s\".\n"), Makefile.m_csLangID);
        goto eh;
    }

    //
    // Read input file(s)
    //
    for (i = 0; i < Makefile.m_rgInputFiles.GetSize(); i++) {

        pInputFile = (SdbInputFile *) Makefile.m_rgInputFiles[i];

        Print(_T("           Reading XML file - %s"), pInputFile->m_csName);

        pDatabase->m_pCurrentInputFile = pInputFile;

        if (!ReadDatabase(pInputFile, pDatabase)) {
            PrintErrorStack();
            goto eh;
        }

        Print(_T("%s\n"), pInputFile->m_bSourceUpdated ? _T(" - updated") : _T("") );

        pDatabase->m_pCurrentInputFile = NULL;
    }

    Print(_T("\n"));

    //
    // Propagate filters
    //
    pDatabase->PropagateFilter(SDB_FILTER_DEFAULT);

    //
    // Write output file(s)
    //
    for (i = 0; i < Makefile.m_rgOutputFiles.GetSize(); i++) {

        pOutputFile = (SdbOutputFile *) Makefile.m_rgOutputFiles[i];

        Print(_T("%27s - %s\n"),
              pOutputFile->GetFriendlyNameForType(),
              pOutputFile->m_csName);

        pDatabase->m_pCurrentOutputFile = pOutputFile;
        g_dwCurrentWriteFilter = pOutputFile->m_dwFilter;
        g_dtCurrentWriteRevisionCutoff = pOutputFile->m_dtRevisionCutoff;

        switch (pOutputFile->m_OutputType) {

        case SDB_OUTPUT_TYPE_SDB:

            if (!WriteDatabase(pOutputFile, pDatabase)) {
                PrintErrorStack();
                goto eh;
            }
            break;

        case SDB_OUTPUT_TYPE_HTMLHELP:

            if (!ChmWriteProject(pOutputFile,
                                 pDatabase)) {
                PrintErrorStack();
                goto eh;
            }
            break;

        case SDB_OUTPUT_TYPE_MIGDB_TXT:

            if (!WriteMigDBFile(NULL,
                                pDatabase,
                                pDatabase,
                                pOutputFile->m_csName)) {
                PrintErrorStack();
                goto eh;
            }
            break;

        case SDB_OUTPUT_TYPE_MIGDB_INX:

            if (!WriteMigDBFile(pDatabase,
                                pDatabase,
                                NULL,
                                pOutputFile->m_csName)) {
                PrintErrorStack();
                goto eh;
            }
            break;

        case SDB_OUTPUT_TYPE_WIN2K_REGISTRY:

            csTemp.Empty();
            pOutputFile->m_mapParameters.Lookup(_T("ADD EXE STUBS"), csTemp);
            if (!WriteRegistryFiles(pDatabase,
                                    pOutputFile->m_csName + _T(".reg"),
                                    pOutputFile->m_csName + _T(".inx"),
                                    csTemp == _T("TRUE"))) {
                PrintErrorStack();
                goto eh;
            }
            break;

        case SDB_OUTPUT_TYPE_REDIR_MAP:

            csTemp.Empty();
            pOutputFile->m_mapParameters.Lookup(_T("TEMPLATE"), csTemp);

            if (csTemp.IsEmpty()) {
                PrintError (_T("REDIR_MAP output type requires TEMPLATE parameter\n"));
                goto eh;
            }

            if (!WriteRedirMapFile(pOutputFile->m_csName, csTemp, pDatabase)) {
                PrintErrorStack();
                goto eh;
            }
            break;

        case SDB_OUTPUT_TYPE_NTCOMPAT_INF:

            if (!NtCompatWriteInfAdditions(pOutputFile, pDatabase)) {
                PrintErrorStack();
                goto eh;
            }
            break;

        case SDB_OUTPUT_TYPE_NTCOMPAT_MESSAGE_INF:

            if (!NtCompatWriteMessageInf(pOutputFile, pDatabase)) {
                PrintErrorStack();
                goto eh;
            }
            break;

        case SDB_OUTPUT_TYPE_APPHELP_REPORT:

            if (!WriteAppHelpReport(pOutputFile, pDatabase)) {
                PrintErrorStack();
                goto eh;
            }
            break;

        }

        pDatabase->m_pCurrentOutputFile = NULL;
    }

    //
    // Indicate success and print statistics
    //

    nRetCode = 0;
    Print(_T("\nCompilation successful.\n\n"));


    Print(_T("       Executables: %d\n"), pDatabase->m_rgExes.GetSize() +
                                    pDatabase->m_rgWildcardExes.GetSize());
    Print(_T("             Shims: %d\n"),   pDatabase->m_Library.m_rgShims.GetSize());
    Print(_T("           Patches: %d\n"),   pDatabase->m_Library.m_rgPatches.GetSize());
    Print(_T("             Files: %d\n"),   pDatabase->m_Library.m_rgFiles.GetSize());
    Print(_T("            Layers: %d\n\n"), pDatabase->m_Library.m_rgLayers.GetSize());

    Print(_T(" AppHelp Instances: %d\n"),   pDatabase->m_rgAppHelps.GetSize());
    Print(_T(" Localized Vendors: %d\n"),   pDatabase->m_rgContactInfo.GetSize());
    Print(_T("         Templates: %d\n"),   pDatabase->m_rgMessageTemplates.GetSize());

    Print(_T("\n"));

    //
    // Print statistics if requested
    //
    if (nPrintStatistics > 0) {
        DumpVerboseStats(pDatabase, nPrintStatistics == 2);
    }

eh:
    if (pDatabase) {
        delete pDatabase;
    }

    CoUninitialize();

    return nRetCode;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   PrintHelp
//
//  Desc:   Prints the tool's help information.
//
void PrintHelp()
{
    Print(_T("    Usage:\n\n"));
    Print(_T("        ShimDBC [mode] [command switches] [input file] [output file]\n\n"));
    Print(_T("    Modes:\n\n"));
    Print(_T("        Fix                Compiles a Fix database (e.g., sysmain.sdb).\n\n"));
    Print(_T("        AppHelp            Compiles an AppHelp database (e.g., apphelp.sdb).\n\n"));
    Print(_T("        MSI                Compiles an MSI database (e.g., msimain.sdb).\n\n"));
    Print(_T("        Driver             Compiles a Driver database (e.g., drvmain.sdb).\n\n"));
    Print(_T("    Command switches:\n\n"));
    Print(_T("        -a <file path>     Specifies the reference XML for the AppHelp database\n"));
    Print(_T("                           This is usually the fix database (AppHelp mode only)\n\n"));
    Print(_T("        -h                 Creates HTMLHelp files in the output file's directory\n"));
    Print(_T("                           used to create .CHM files. (AppHelp mode only)\n\n"));
    Print(_T("        -f <file path>     Include FILE binaries in database <file path> is\n"));
    Print(_T("                           directory to grab binaries from. (Fix mode only)\n\n"));
    Print(_T("        -k <keyword>       Specifies a <HISTORY> keyword to filter on.\n\n"));
    Print(_T("        -m                 Writes out Migration support files\n\n"));
    Print(_T("        -ov <version>      Specifies what OS version to compile for.\n\n"));
    Print(_T("        -op <platform>     Specifies what OS platform to compile for.\n\n"));
    Print(_T("        -l <language>      Specifies the language to compile for.\n\n"));
    Print(_T("        -q                 Quiet mode.\n\n"));
    Print(_T("        -r[s]              Creates Win2k-style registry files for use in\n"));
    Print(_T("                           migration or Win2k update packages. If -rs is used,\n"));
    Print(_T("                           then shimming stubs are added. (Fix mode only)\n\n"));
    Print(_T("        -s                 Strict compile, additional checking is performed.\n\n"));
    Print(_T("        -v[s]              Verbose statistics. -vs indicates summary form.\n\n"));
    Print(_T("        -x <file path>     Use the makefile specified.\n\n"));
}

extern "C" BOOL
ShimdbcExecute(
    LPCWSTR lpszCmdLine
    )
{
    LPWSTR* argv;
    int     argc = 0;

    argv = CommandLineToArgvW(lpszCmdLine, &argc);

    return 1 - _tmain(argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\registry.h ===
///////////////////////////////////////////////////////////////////////////////
//
// File:    registry.h
//
// History: 04-Dec-00   markder     Created.
//
// Desc:    This file contains AppsHelp enumerations taken from Win2K
//          RTM sources.
//
///////////////////////////////////////////////////////////////////////////////

//
// These are the attribute IDs for all the attributes
//
// Do not change any values in this enum. You can only add new values
// immediately above VTID_LASTID
//
typedef enum {
    VTID_BAD_VTID           = 0,    // do not use or change !!!
    VTID_REQFILE            = 1,    // this should never change !!!
    VTID_FILESIZE           = VTID_REQFILE + 1,
    VTID_EXETYPE            = VTID_REQFILE + 2,
    VTID_BINFILEVER         = VTID_REQFILE + 3,
    VTID_BINPRODUCTVER      = VTID_REQFILE + 4,
    VTID_FILEDATEHI         = VTID_REQFILE + 5,
    VTID_FILEDATELO         = VTID_REQFILE + 6,
    VTID_FILEVEROS          = VTID_REQFILE + 7,
    VTID_FILEVERTYPE        = VTID_REQFILE + 8,
    VTID_CHECKSUM           = VTID_REQFILE + 9,
    VTID_PECHECKSUM         = VTID_REQFILE +10,
    VTID_COMPANYNAME        = VTID_REQFILE +11,
    VTID_PRODUCTVERSION     = VTID_REQFILE +12,
    VTID_PRODUCTNAME        = VTID_REQFILE +13,
    VTID_FILEDESCRIPTION    = VTID_REQFILE +14,
    VTID_FILEVERSION        = VTID_REQFILE +15,
    VTID_ORIGINALFILENAME   = VTID_REQFILE +16,
    VTID_INTERNALNAME       = VTID_REQFILE +17,
    VTID_LEGALCOPYRIGHT     = VTID_REQFILE +18,
    VTID_16BITDESCRIPTION   = VTID_REQFILE +19,
    VTID_UPTOBINPRODUCTVER  = VTID_REQFILE +20,

    // add new versions here

    VTID_LASTID
};

BOOL WriteRegistryFiles(
    SdbDatabase* pDatabase,
    CString csRegFile,
    CString csInxFile,
    BOOL bAddExeStubs);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\stats.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    stats.cpp
//
// History: 20-Dec-00   markder     Ported from v1.
//
// Desc:    This file contains statistic dumping routines.
//
////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "globals.h"

///////////////////////////////////////////////////////////////////////////////
//
// Func: DumpVerboseStats
//
// Desc: Dumps out info about layer coverage and a shim cross-reference
//
VOID DumpVerboseStats(SdbDatabase* pDatabase, BOOL bSummary)
{
    int i, j, k, l, m;
    DWORD dwTotal = 0;

    // start by listing the how many exes would be fixed
    // by each layer in the DB

    // initialize the SEEN flag for exes
    for (i = 0; i < pDatabase->m_rgExes.GetSize(); i++) {
        ((SdbExe *)pDatabase->m_rgExes[i])->m_bSeen = FALSE;
    }


    for (k = 0; k < pDatabase->m_Library.m_rgLayers.GetSize(); k++) {
        SdbLayer *pLayer = (SdbLayer *) pDatabase->m_Library.m_rgLayers[k];
        DWORD dwExesFixedByLayer = 0;

        Print(_T("========================================\n"));
        if (!bSummary) {
            Print(_T("Exe entries fixed by shims from layer \"%s\":\n\n"), pLayer->m_csName);
        }

        for (i = 0; i < pDatabase->m_rgExes.GetSize(); i++) {
            SdbExe *pExe = (SdbExe *)pDatabase->m_rgExes[i];

            if (!pExe->m_rgShimRefs.GetSize()) {

                // this has no shims and isn't a fix entry, or doesn't use shims to fix
                goto nextExe;
            }

            for (j = 0; j < pExe->m_rgShimRefs.GetSize(); j++) {
                SdbShimRef *pShimRef = (SdbShimRef *) pExe->m_rgShimRefs[j];

                for (l = 0; l < pLayer->m_rgShimRefs.GetSize(); l++) {
                    SdbShimRef *pLayerShimRef = (SdbShimRef *) pLayer->m_rgShimRefs[l];

                    if (pLayerShimRef->m_pShim == pShimRef->m_pShim) {
                        goto nextShim;
                    }
                }

                // if we didn't find the shim in any layer, this isn't fixed by
                // a layer, and we can try the next EXE
                goto nextExe;
                nextShim:
                ;
            }

            // we got all the way through all the shim entries, now check
            // if there are any patches. If so, this couldn't be fixed
            // by a layer anyhow. And if it's been seen, don't bother
            // reporting it again.
            if (!pExe->m_rgPatches.GetSize() && !pExe->m_bSeen) {
                pExe->m_bSeen = TRUE;
                if (!bSummary) {
                    Print(_T("    Exe \"%s,\" App \"%s.\"\n"), pExe->m_csName, pExe->m_pApp->m_csName);
                }
                dwExesFixedByLayer++;
            }
            nextExe:
            ;
        }

        Print(_T("\nTotal exes fixed by shims contained in Layer \"%s\": %d\n"),
              pLayer->m_csName, dwExesFixedByLayer);
        Print(_T("Total exes in DB: %d\n"), pDatabase->m_rgExes.GetSize());
        Print(_T("Percentage of exes fixed by layer \"%s\": %.1f%%\n\n"),
              pLayer->m_csName, (double)dwExesFixedByLayer * 100.0 /  pDatabase->m_rgExes.GetSize());
        dwTotal += dwExesFixedByLayer;
    }

    Print(_T("========================================\n"));
    Print(_T("\nTotal exes fixed by shims contained in ANY layer: %d\n"),
          dwTotal);
    Print(_T("Total exes in DB: %d\n"), pDatabase->m_rgExes.GetSize());
    Print(_T("Percentage of exes fixed by ANY layer: %.1f%%\n\n"),
          (double)dwTotal * 100.0 /  pDatabase->m_rgExes.GetSize());

    // now check entire apps to see if they are fixed by any layers

    // initialize the SEEN flag for Apps
    for (i = 0; i < pDatabase->m_rgApps.GetSize(); i++) {
        ((SdbApp *)pDatabase->m_rgApps[i])->m_bSeen = FALSE;
    }
    dwTotal = 0;

    for (k = 0; k < pDatabase->m_Library.m_rgLayers.GetSize(); k++) {
        SdbLayer *pLayer = (SdbLayer *) pDatabase->m_Library.m_rgLayers[k];
        DWORD dwAppsFixedByLayer = 0;

        Print(_T("========================================\n"));
        if (!bSummary) {
            Print(_T("App entries fixed by only shims from layer \"%s\":\n\n"), pLayer->m_csName);
        }

        for (m = 0; m < pDatabase->m_rgApps.GetSize(); ++m) {
            SdbApp *pApp = (SdbApp *)pDatabase->m_rgApps[m];

            for (i = 0; i < pApp->m_rgExes.GetSize(); i++) {
                SdbExe *pExe = (SdbExe *)pApp->m_rgExes[i];

                if (!pExe->m_rgShimRefs.GetSize()) {

                    // this has no shims and isn't a fix entry, or doesn't use shims to fix
                    goto nextApp2;
                }

                for (j = 0; j < pExe->m_rgShimRefs.GetSize(); j++) {
                    SdbShimRef *pShimRef = (SdbShimRef *) pExe->m_rgShimRefs[j];
                    BOOL bShimInLayer = FALSE;

                    for (l = 0; l < pLayer->m_rgShimRefs.GetSize(); l++) {
                        SdbShimRef *pLayerShimRef = (SdbShimRef *) pLayer->m_rgShimRefs[l];

                        if (pLayerShimRef->m_pShim == pShimRef->m_pShim) {
                            bShimInLayer = TRUE;
                            goto nextShim2;
                        }
                    }

                    // if we didn't find the shim in any layer, this isn't fixed by
                    // a layer, and we can try the next APP
                    if (!bShimInLayer) {
                        goto nextApp2;
                    }
                    nextShim2:
                    ;
                }

                // we got all the way through all the shim entries, now check
                // if there are any patches. If so, this couldn't be fixed
                // by a layer anyhow.
                if (pExe->m_rgPatches.GetSize()) {
                    goto nextApp2;
                }
            }
            // well, we got all the way through the exes, and they were all
            // fixed, so count this one.
            if (!pApp->m_bSeen) {
                dwAppsFixedByLayer++;
                pApp->m_bSeen = TRUE;
                if (!bSummary) {
                    Print(_T("    App \"%s.\"\n"), pApp->m_csName);
                }
            }
            nextApp2:
            ;
        }

        Print(_T("\nTotal apps fixed by shims contained in Layer \"%s\": %d\n"),
              pLayer->m_csName, dwAppsFixedByLayer);
        Print(_T("Total apps in DB: %d\n"), pDatabase->m_rgApps.GetSize());
        Print(_T("Percentage of apps fixed by layer \"%s\": %.1f%%\n\n"),
              pLayer->m_csName, (double)dwAppsFixedByLayer * 100.0 /  pDatabase->m_rgApps.GetSize());
        dwTotal += dwAppsFixedByLayer;
    }

    Print(_T("========================================\n"));
    Print(_T("\nTotal apps fixed by shims contained in ANY layer: %d\n"),
          dwTotal);
    Print(_T("Total apps in DB: %d\n"), pDatabase->m_rgApps.GetSize());
    Print(_T("Percentage of apps fixed by ANY layer: %.1f%%\n\n"),
          (double)dwTotal * 100.0 /  pDatabase->m_rgApps.GetSize());

    // Now do a cross reference of shims to apps and exes.

    Print(_T("\n========================================\n"));
    Print(_T("Cross Reference of Shims to Apps & Exes\n"));

    for (i = 0; i < pDatabase->m_Library.m_rgShims.GetSize(); ++i) {
        SdbShim *pShim = (SdbShim *)pDatabase->m_Library.m_rgShims[i];
        DWORD dwExes = 0;
        DWORD dwApps = 0;
        TCHAR *szAppEnd = _T("s");
        TCHAR *szExeEnd = _T("s");

        Print(_T("\n----------------------------------------\n"));
        Print(_T("shim \"%s\":\n"), pShim->m_csName);

        for (j = 0; j < pDatabase->m_rgApps.GetSize(); ++j) {
            SdbApp *pApp = (SdbApp*)pDatabase->m_rgApps[j];
            BOOL bPrintedApp = FALSE;

            for (k = 0; k < pApp->m_rgExes.GetSize(); ++k) {
                SdbExe *pExe = (SdbExe*)pApp->m_rgExes[k];

                for (l = 0; l < pExe->m_rgShimRefs.GetSize(); ++l) {
                    SdbShimRef *pShimRef = (SdbShimRef*)pExe->m_rgShimRefs[l];

                    if (pShimRef->m_pShim == pShim) {
                        if (!bPrintedApp) {
                            if (!bSummary) {
                                Print(_T("\n    App \"%s\"\n"), pApp->m_csName);
                            }
                            bPrintedApp = TRUE;
                            dwApps++;
                        }

                        if (!bSummary) {
                            Print(_T("        Exe \"%s\"\n"), pExe->m_csName);
                        }
                        dwExes++;
                    }
                }
            }
        }

        if (dwApps == 1) {
            szAppEnd = _T("");
        }
        if (dwExes == 1) {
            szExeEnd = _T("");
        }

        Print(_T("\nTotals for shim \"%s\": %d App%s, %d Exe%s.\n"),
              pShim->m_csName, dwApps, szAppEnd, dwExes, szExeEnd);


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\utils.h ===
#ifndef __UTILS_H__
#define __UTILS_H__

#ifdef __cplusplus
extern "C" {
#endif

BOOL GUIDFromString(LPCTSTR lpszGuid, GUID* pGuid);
BOOL StringFromGUID(LPTSTR lpszGuid, GUID* pGuid);
ULONGLONG ullMakeKey(LPCTSTR lpszStr);

#ifdef __cplusplus
}
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\stats.h ===
///////////////////////////////////////////////////////////////////////////////
//
// File:    stats.h
//
// History: 21-Dec-00   markder     Created.
//
// Desc:    This file contains statistic dumping routines.
//
///////////////////////////////////////////////////////////////////////////////

class SdbDatabase;

VOID DumpVerboseStats(SdbDatabase* pDatabase, BOOL bSummary);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\stdafx.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    stdafx.cpp
//
// History: 19-Nov-99   markder     Created.
// 
// Desc:    Source file that includes just the standard includes
//          for the precompiled header.
//
////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\utils.c ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    utils.c
//
// History:    May-00   vadimb      Created.
//
// Desc:    Utilties for creating a 64-bit key for sorting elements.
//
////////////////////////////////////////////////////////////////////////////////////

#define WIN
#define FLAT_32
#define TRUE_IF_WIN32   1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define _WINDOWS
#include <windows.h>
#include "shimdb.h"

// we are in the world of nt now

BOOL GUIDFromString(LPCTSTR lpszGuid, GUID* pGuid)
{
   UNICODE_STRING ustrGuid;
   NTSTATUS status;

   // convert from ansi to unicode
#ifdef _UNICODE
   RtlInitUnicodeString(&ustrGuid, lpszGuid);
#else
   ANSI_STRING astrGuid;

   RtlInitAnsiString(&astrGuid, lpszGuid);
   RtlAnsiStringToUnicodeString(&ustrGuid, &astrGuid, TRUE);
#endif

   // now convert
   status = RtlGUIDFromString(&ustrGuid, pGuid);

#ifndef _UNICODE
   RtlFreeUnicodeString(&ustrGuid);
#endif

   return NT_SUCCESS(status);
}

ULONGLONG ullMakeKey(LPCTSTR lpszStr)
{
#ifdef _UNICODE
    return SdbMakeIndexKeyFromString(lpszStr);
#else
    // we are ANSI
    ULONGLONG ullKey;

    char     szAnsiKey[8];    // need 8 + 1 for the zero byte
    char     szFlippedKey[8]; // flipped to deal with little-endian issues
    NTSTATUS status;
    int      i;

    ZeroMemory(szAnsiKey, 8);

    strncpy(szAnsiKey, lpszStr, 8);

    // flip the key
    for (i = 0; i < 8; ++i) {
        szFlippedKey[i] = szAnsiKey[7-i];
    }

    return *((ULONGLONG*)szFlippedKey);
#endif

}

BOOL
StringFromGUID(
    LPTSTR lpszGuid,
    GUID*  pGuid
    )
{
    UNICODE_STRING ustrGuid;
    NTSTATUS       Status;

    Status = RtlStringFromGUID(pGuid, &ustrGuid);
    if (NT_SUCCESS(Status)) {

#ifdef _UNICODE
        wcscpy(lpszGuid, ustrGuid.Buffer);
#else
        sprintf(lpszGuid, "%ls", ustrGuid.Buffer);
#endif

        RtlFreeUnicodeString(&ustrGuid);

        return TRUE;
    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\stdafx.h ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    stdafx.h
//
// History: 19-Nov-99   markder     Created.
//
// Desc:    Include file for standard system include files,
//
////////////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_STDAFX_H__237011AC_FA3E_4B43_843F_76DC71B6AD16__INCLUDED_)
#define AFX_STDAFX_H__237011AC_FA3E_4B43_843F_76DC71B6AD16__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afx.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>
#include <afxpriv.h>
#include <afxtempl.h>

#include <comdef.h>

#include <msxml.h>
#include <shlwapi.h>

extern "C" {
#include "shimdb.h"
}

#define STRSAFE_NO_CB_FUNCTIONS
#include <strsafe.h>

extern TCHAR g_szVersion[];

#define SDBERROR_PROPOGATE()
#define SDBERROR_CLEAR() g_rgErrors.RemoveAll();
#define SDBERROR(text) g_rgErrors.Add( text );
#define SDBERROR_FORMAT(__x__) \
{                              \
    CString __csError;         \
    __csError.Format __x__ ;   \
    SDBERROR(__csError);       \
}


_COM_SMARTPTR_TYPEDEF(IXMLDOMNode, __uuidof(IXMLDOMNode));
_COM_SMARTPTR_TYPEDEF(IXMLDOMNodeList, __uuidof(IXMLDOMNodeList));
_COM_SMARTPTR_TYPEDEF(IXMLDOMNamedNodeMap, __uuidof(IXMLDOMNamedNodeMap));
_COM_SMARTPTR_TYPEDEF(IXMLDOMParseError, __uuidof(IXMLDOMParseError));
_COM_SMARTPTR_TYPEDEF(IXMLDOMDocument, __uuidof(IXMLDOMDocument));

#include "obj.h"
#include "globals.h"

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__237011AC_FA3E_4B43_843F_76DC71B6AD16__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\write.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    write.cpp
//
// History: 16-Nov-00   markder     Created.
//
// Desc:    This file contains all code needed to create SDB files
//          from the SdbDatabase internal C++ object.
//
////////////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "make.h"

DWORD g_dwCurrentWriteFilter = SDB_FILTER_INCLUDE_ALL;
DATE  g_dtCurrentWriteRevisionCutoff = 0;

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   GetUniqueCount
//
//  Desc:   Returns the count of unique index entries given an "ordered"
//          array of exes
//
DWORD GetUniqueCount(SdbRefArray<SdbExe>* prgExes, DWORD dwFilter, DATE dtRevisionCutoff, BOOL bWildCard)
{
    int i;
    SdbExe* pExe;
    DWORD dwCount = 0;
    ULONGLONG ullKey = 0;

    for (i = 0; i < prgExes->GetSize(); ++i) {
        pExe = (SdbExe*)prgExes->GetAt(i);

        if (!(pExe->m_bWildcardInName ^ bWildCard)) { // XOR is 1 if the args are different and
                                                      //     is 0 if the args are the same
            if ((pExe->m_dwFilter & dwFilter) &&
                dtRevisionCutoff <= pExe->m_dtLastRevision) {
                if (ullKey != pExe->m_ullKey) {
                    ullKey = pExe->m_ullKey;
                    ++dwCount;
                }
            }
        }
    }
    return dwCount;
}


BOOL WriteDatabase(
    SdbOutputFile* pOutputFile,
    SdbDatabase* pDatabase)
{
    BOOL                bSuccess = FALSE;
    PDB                 pdb = NULL;

    pdb = SdbCreateDatabase(pOutputFile->m_csName, DOS_PATH);
    if (pdb == NULL) {
        SDBERROR_FORMAT((_T("Error creating database \"%s\".\n"), pOutputFile->m_csName));
        goto eh;
    }

    pDatabase->m_Library.SanitizeTagIDs();

    if (!pDatabase->WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    bSuccess = TRUE;

eh:
    if (pdb) {
        SdbCloseDatabase(pdb);
    }

    if (bSuccess == FALSE) {
        //
        // We need to delete the .SDB that has been created. We had an error
        // but shimdbc has made the .SDB for the XML till it hit the error. This is typically
        // in the case when we hit a tag in the summary part of a XML for a custom SDB
        // that is not allowed in the summary part. For e.g if we have
        // *********************************************************************
        // <LIBRARY>
        //  <MESSAGE NAME="1" ID="{5DE255AF-350F-4A94-896E-249561039F13}">
        //      <SUMMARY>
        //        <B>sd</B>
        //      </SUMMARY>
        //  </MESSAGE>
        // </LIBRARY>
        //
        //**********************************************************************
        // Such an .SDB is an invalid .SDB and should be removed
        //
        DeleteFile(pOutputFile->GetFullPath());
    }

    return bSuccess;
}


VOID SdbLibrary::SanitizeTagIDs(VOID)
{
    INT i;

    for (i = 0; i < m_rgShims.GetSize(); ++i) {
        SdbShim* pShim = (SdbShim*)m_rgShims.GetAt(i);
        pShim->m_tiTagID = TAGID_NULL;
    }

    for (i = 0; i < m_rgPatches.GetSize(); ++i) {
        SdbPatch* pPatch = (SdbPatch*)m_rgPatches.GetAt(i);
        pPatch->m_tiTagID = TAGID_NULL;
    }

    for (i = 0; i < m_rgLayers.GetSize(); ++i) {
        SdbLayer* pLayer = (SdbLayer*)m_rgLayers.GetAt(i);
        pLayer->m_tiTagID = TAGID_NULL;
    }

    for (i = 0; i < m_rgFiles.GetSize(); ++i) {
        SdbFile* pFile = (SdbFile*)m_rgFiles.GetAt(i);
        pFile->m_tiTagID = TAGID_NULL;
    }

    for (i = 0; i < m_rgMsiTransforms.GetSize(); ++i) {
        SdbMsiTransform* pTransform = (SdbMsiTransform*)m_rgMsiTransforms.GetAt(i);
        pTransform->m_tiTagID = TAGID_NULL;
    }

}

BOOL SdbDatabase::WriteToSDB(PDB pdb)
{
    BOOL                bSuccess = FALSE;
    BOOL                bAtLeastOneIndex = FALSE;

    TAGID               tiDatabase;

    FILETIME            ftBuildStamp;
    LARGE_INTEGER       liBuildStamp;

    DWORD               dwHTMLHelpID;
    LANGID              langID;
    DWORD               dwUniqueCount = 0;

    long                i, j;
    SdbAppHelp*         pAppHelp;
    SdbMessage*         pMessage;

    CString csURL, csLinkText, csContactInfo;
    CString csAppTitle, csSummary, csDetails, csID, csDBName;
    CString csLanguagesParam, csLangID;
    CStringArray rgLanguages;

    csLanguagesParam = m_pCurrentOutputFile->GetParameter(_T("LANGUAGES"));
    if (csLanguagesParam.GetLength()) {
        if (!ParseLanguagesString(csLanguagesParam, &rgLanguages)) {
            SDBERROR_FORMAT((_T("Error parsing LANGUAGES parameter in makefile: %s\n"), csLanguagesParam));
            goto eh;
        }
    } else {
        rgLanguages.Add(m_pCurrentMakefile->m_csLangID);
    }

    //
    // Allocate indexes
    //
    dwUniqueCount = GetUniqueCount(&m_rgExes, m_pCurrentOutputFile->m_dwFilter, g_dtCurrentWriteRevisionCutoff, FALSE);

    if (m_pCurrentOutputFile->m_dwFilter & (SDB_FILTER_FIX | SDB_FILTER_DRIVER)) {

        if (!SdbDeclareIndex(pdb, TAG_EXE, TAG_NAME, dwUniqueCount, TRUE, &m_iiExeIndex)) {
            SDBERROR(_T("Error declaring index for Exes.\n"));
            goto eh;
        }

        bAtLeastOneIndex = TRUE;
    }

    if (m_pCurrentOutputFile->m_dwFilter & SDB_FILTER_FIX) {

        if (!SdbDeclareIndex(pdb,
                             TAG_EXE,
                             TAG_WILDCARD_NAME,
                             (DWORD)m_rgWildcardExes.GetFilteredCount(m_pCurrentOutputFile->m_dwFilter, g_dtCurrentWriteRevisionCutoff),
                             FALSE,
                             &m_iiWildcardExeIndex)) {
            SDBERROR(_T("Error declaring index for wildcard Exes.\n"));
            goto eh;
        }

        if (!SdbDeclareIndex(pdb,
                             TAG_EXE,
                             TAG_16BIT_MODULE_NAME,
                             (DWORD)m_rgModuleExes.GetFilteredCount(m_pCurrentOutputFile->m_dwFilter, g_dtCurrentWriteRevisionCutoff),
                             FALSE,
                             &m_iiModuleExeIndex)) {
            SDBERROR(_T("Error declaring index for wildcard Exes.\n"));
            goto eh;
        }

        if (!SdbDeclareIndex(pdb,
                             TAG_SHIM,
                             TAG_NAME,
                             (DWORD)m_Library.m_rgShims.GetFilteredCount(m_pCurrentOutputFile->m_dwFilter, 0),
                             FALSE,
                             &m_iiShimIndex)) {
            SDBERROR(_T("Error declaring index for Shims.\n"));
            goto eh;
        }

        bAtLeastOneIndex = TRUE;
    }

    if (m_pCurrentOutputFile->m_dwFilter & SDB_FILTER_APPHELP) {

        if (!SdbDeclareIndex(pdb,
                             TAG_APPHELP,
                             TAG_HTMLHELPID,
                             (DWORD) (m_rgAppHelps.GetFilteredCount(m_pCurrentOutputFile->m_dwFilter, g_dtCurrentWriteRevisionCutoff)
                                * rgLanguages.GetSize()),
                             FALSE,
                             &m_iiHtmlHelpID)) {
            SDBERROR(_T("Error declaring index for HTMLHELPID\n"));
            goto eh;
        }

        bAtLeastOneIndex = TRUE;
    }

    if (m_pCurrentOutputFile->m_dwFilter & SDB_FILTER_MSI) {

        //
        // MSI_TRANSFORM index, unique style (it's more efficient) - these are "fixes"
        //
        if (!SdbDeclareIndex(pdb,
                             TAG_MSI_TRANSFORM,
                             TAG_NAME,
                             (DWORD)m_Library.m_rgMsiTransforms.GetFilteredCount(m_pCurrentOutputFile->m_dwFilter, g_dtCurrentWriteRevisionCutoff),
                             TRUE,
                             &m_iiMsiTransformIndex)) {
            SDBERROR(_T("Error declaring index for MSI Transforms.\n"));
            goto eh;
        }

        //
        // MSI_PACKAGE index, unique style (it's more efficient, again)
        //
        if (!SdbDeclareIndex(pdb,
                             TAG_MSI_PACKAGE,
                             TAG_MSI_PACKAGE_ID,
                             m_rgMsiPackages.GetFilteredCount(m_pCurrentOutputFile->m_dwFilter, g_dtCurrentWriteRevisionCutoff),
                             FALSE,
                             &m_iiMsiPackageIndex)) {
            SDBERROR(_T("Error declaring index for MSI Packages.\n"));
            goto eh;
        }

        if (!SdbDeclareIndex(pdb,
                             TAG_MSI_PACKAGE,
                             TAG_EXE_ID,
                             m_rgMsiPackages.GetFilteredCount(m_pCurrentOutputFile->m_dwFilter, g_dtCurrentWriteRevisionCutoff),
                             TRUE,
                             &m_iiMsiIDIndex)) {
            SDBERROR(_T("Error declaring index for MSI Exe IDs.\n"));
            goto eh;
        }

        bAtLeastOneIndex = TRUE;
    }

    if (m_pCurrentOutputFile->m_dwFilter & SDB_FILTER_DRIVER) {
        if (!SdbDeclareIndex(pdb,
                             TAG_EXE,
                             TAG_EXE_ID,
                             m_rgExes.GetFilteredCount(m_pCurrentOutputFile->m_dwFilter, g_dtCurrentWriteRevisionCutoff),
                             FALSE,
                             &m_iiDrvIDIndex)) {
            SDBERROR(_T("Error declaring index for DRIVER ID\n"));
            goto eh;
        }

        bAtLeastOneIndex = TRUE;
    }

    if (bAtLeastOneIndex) {

        if (!SdbCommitIndexes(pdb)) {
            SDBERROR(_T("Error ending index declarations.\n"));
            goto eh;
        }
    }

    //
    // Open tag
    //
    tiDatabase = SdbBeginWriteListTag(pdb, TAG_DATABASE);
    if (!tiDatabase) {
        SDBERROR(_T("Error writing DATABASE tag\n"));
        goto eh;
    }

    //
    // Stamp the build time
    //
    GetSystemTimeAsFileTime(&ftBuildStamp);
    liBuildStamp.LowPart = ftBuildStamp.dwLowDateTime;
    liBuildStamp.HighPart = ftBuildStamp.dwHighDateTime;

    if (!SdbWriteQWORDTag(pdb, TAG_TIME, liBuildStamp.QuadPart)) {
        SDBERROR(_T("Error writing TIME\n"));
        goto eh;
    }

    //
    // Stamp the compiler version
    //
    if (!SdbWriteStringTag(pdb, TAG_COMPILER_VERSION, g_szVersion)) {
        SDBERROR(_T("Error writing COMPILER_VERSION\n"));
        goto eh;
    }

    //
    // Look for name from makefile
    //
    csDBName = m_pDB->m_pCurrentOutputFile->GetParameter(_T("DATABASE NAME"));

    if (csDBName.IsEmpty()) {
        csDBName = m_csName;
    }

    //
    // Write the name of the database
    //
    if (!SdbWriteStringTag(pdb, TAG_NAME, csDBName)) {
        SDBERROR(_T("Error writing TAG_NAME\n"));
        goto eh;
    }

    //
    // Look for GUID from makefile
    //
    csID = m_pDB->m_pCurrentOutputFile->GetParameter(_T("DATABASE ID"));

    if (csID.GetLength()) {
        if (!GUIDFromString(csID, &m_CurrentDBID)) {
            SDBERROR_FORMAT((_T("Bad GUID specified for DATABASE_ID: %s\n"), csID));
            goto eh;
        }
    } else {
        //
        // Not there, take the ID from the XML file
        //
        m_CurrentDBID = m_ID;
    }


    //
    // Write the GUID
    //
    if (!SdbWriteBinaryTag(pdb, TAG_DATABASE_ID, (PBYTE)&m_CurrentDBID, sizeof(m_CurrentDBID))) {
        SDBERROR(_T("Error writing TAG_DATABASE_ID\n"));
        goto eh;
    }

    if (m_pCurrentOutputFile->m_dwFilter & ~SDB_FILTER_DRIVER) {
        //
        // Write the Library
        //
        if (!m_Library.WriteToSDB(pdb)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }
    }

    //
    // Action
    //
    if (!m_rgAction.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (m_pCurrentOutputFile->m_dwFilter & SDB_FILTER_FIX) {

        //
        // First write all the EXEs with wild-card names
        //
        if (!SdbStartIndexing(pdb, m_iiWildcardExeIndex)) {
            SDBERROR(_T("Error starting to index wildcard Exes.\n"));
            goto eh;
        }

        //
        // Wildcard Exes
        //
        if (!m_rgWildcardExes.WriteToSDB(pdb)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        //
        // Done indexing the wildcard exes
        //
        if (!SdbStopIndexing(pdb, m_iiWildcardExeIndex)) {
            SDBERROR(_T("Error stopping indexing wildcard Exes.\n"));
            goto eh;
        }

        //
        // Next write all the EXEs with module names
        //
        if (!SdbStartIndexing(pdb, m_iiModuleExeIndex)) {
            SDBERROR(_T("Error starting to index Module Exes.\n"));
            goto eh;
        }

        //
        // Module Exes
        //
        if (!m_rgModuleExes.WriteToSDB(pdb)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        //
        // Done indexing the module exes
        //
        if (!SdbStopIndexing(pdb, m_iiModuleExeIndex)) {
            SDBERROR(_T("Error stopping indexing Module Exes.\n"));
            goto eh;
        }
    }

    if (m_pCurrentOutputFile->m_dwFilter & (SDB_FILTER_FIX | SDB_FILTER_DRIVER)) {
        //
        // Go ahead and start indexing normal exes
        //
        if (!SdbStartIndexing(pdb, m_iiExeIndex)) {
            SDBERROR(_T("Error starting to index Exes.\n"));
            goto eh;
        }

        if (m_pCurrentOutputFile->m_dwFilter & SDB_FILTER_DRIVER) {
            if (!SdbStartIndexing(pdb, m_iiDrvIDIndex)) {
                SDBERROR(_T("Error starting to index driver IDs\n"));
                goto eh;
            }
        }

        if (!m_rgExes.WriteToSDB(pdb)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (m_pCurrentOutputFile->m_dwFilter & SDB_FILTER_DRIVER) {
            if (!SdbStopIndexing(pdb, m_iiDrvIDIndex)) {
                SDBERROR(_T("Error stopping indexing driver IDs\n"));
                goto eh;
            }
        }

        //
        // Done indexing the exes
        //
        if (!SdbStopIndexing(pdb, m_iiExeIndex)) {
            SDBERROR(_T("Error stopping indexing Exes.\n"));
            goto eh;
        }
    }

    if (m_pCurrentOutputFile->m_dwFilter & SDB_FILTER_MSI) {
        //
        // MSI Packages, they are just like EXEs
        // but indexed not by name but by their GUID IDs
        //
        if (!SdbStartIndexing(pdb, m_iiMsiPackageIndex)) {
            SDBERROR(_T("Error starting to index MSI Packages.\n"));
            goto eh;
        }
        if (!SdbStartIndexing(pdb, m_iiMsiIDIndex)) {
            SDBERROR(_T("Error starting to index MSI packages by exe id\n"));
            goto eh;
        }

        if (!m_rgMsiPackages.WriteToSDB(pdb)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (!SdbStopIndexing(pdb, m_iiMsiIDIndex)) {
            SDBERROR(_T("Error stopping indexing of MSI packages by exe id\n"));
            goto eh;
        }

        if (!SdbStopIndexing(pdb, m_iiMsiPackageIndex)) {
            SDBERROR(_T("Error stopping indexing MSI Packages.\n"));
            goto eh;
        }
    }

    if (m_pCurrentOutputFile->m_dwFilter & SDB_FILTER_APPHELP) {
        //
        // Start indexing apphelps
        //
        if (!SdbStartIndexing(pdb, m_iiHtmlHelpID)) {
            SDBERROR( _T("Error starting to index HTMLHELPID.\n"));
            goto eh;
        }

        for (i = 0; i < m_rgAppHelps.GetSize(); i++) {
            pAppHelp = (SdbAppHelp *) m_rgAppHelps[i];

            if (!(pAppHelp->m_dwFilter & m_pCurrentOutputFile->m_dwFilter)) {
                continue;
            }

            if (g_dtCurrentWriteRevisionCutoff > pAppHelp->m_dtLastRevision) {
                continue;
            }

            for (j = 0; j < rgLanguages.GetSize(); j++) {

                csLangID = rgLanguages[j];

                pMessage = (SdbMessage *) m_rgMessages.LookupName(pAppHelp->m_csMessage, csLangID);

                if (pMessage == NULL) {
                    SDBERROR_FORMAT((_T("Localized MESSAGE not found for\n    NAME:       %s\n    HTMLHELPID: %s\n    LANG:       %s\n"),
                        pAppHelp->m_csMessage, pAppHelp->m_csName, csLangID));
                    goto eh;
                }

                if (!ConstructMessageParts(
                    pAppHelp,
                    pMessage,
                    csLangID,
                    &dwHTMLHelpID,
                    &csURL,
                    &csContactInfo,
                    &csAppTitle,
                    &csSummary,
                    &csDetails)) {
                    SDBERROR_PROPOGATE();
                    goto eh;
                }

                if (g_bStrict) {

                    if (csURL.IsEmpty()) {
                        SDBERROR_FORMAT((_T("ERROR: Empty string for URL on\n    NAME:       %s\n    HTMLHELPID: %s\n    LANG:       %s\n\n"),
                            pAppHelp->m_pApp->m_csName, pAppHelp->m_csName, csLangID));
                        goto eh;
                    }

                    if (csAppTitle.IsEmpty()) {
                        SDBERROR_FORMAT((_T("ERROR: Empty string for APP_TITLE on\n    NAME:       %s\n    HTMLHELPID: %s\n    LANG:       %s\n\n"),
                            pAppHelp->m_pApp->m_csName, pAppHelp->m_csName, csLangID));
                        goto eh;
                    }

                    if (csSummary.IsEmpty()) {
                        SDBERROR_FORMAT((_T("ERROR: Empty string for SUMMARY on\n    NAME:       %s\n    HTMLHELPID: %s\n    LANG:       %s\n\n"),
                            pAppHelp->m_pApp->m_csName, pAppHelp->m_csName, csLangID));
                        goto eh;
                    }
                }

                if (!WriteAppHelpRefTag(
                    pdb,
                    pAppHelp->m_csName,
                    csLangID == _T("---") ? 0 : m_pCurrentMakefile->GetLangMap(csLangID)->m_lcid,
                    csURL,
                    csAppTitle,
                    csSummary)) {
                    SDBERROR_PROPOGATE();
                    goto eh;
                }
            }
        }

        //
        // Stop indexing apphelps
        //
        if (!SdbStopIndexing(pdb, m_iiHtmlHelpID)) {
           SDBERROR( _T("Error stopping indexing HTMLHELPID.\n"));
           goto eh;
        }
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiDatabase)) {
        SDBERROR(_T("Error writing TAG_DATABASE\n"));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL SdbLibrary::WriteToSDB(PDB pdb)
{
    BOOL                bSuccess = FALSE;

    TAGID               tiLibrary;

    //
    // Open tag
    //
    tiLibrary = SdbBeginWriteListTag(pdb, TAG_LIBRARY);
    if (!tiLibrary) {
        SDBERROR(_T("Error writing TAG_LIBRARY\n"));
        goto eh;
    }

    if (m_pDB->m_pCurrentOutputFile->m_dwFilter & SDB_FILTER_FIX) {
        //
        // Global exclusion list
        //
        if (!m_rgCallers.WriteToSDB(pdb)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        //
        // Index the shims
        //
        if (!SdbStartIndexing(pdb, m_pDB->m_iiShimIndex)) {
            SDBERROR(_T("Error starting to index Dlls.\n"));
            goto eh;
        }

        //
        // Shims
        //
        if (!m_rgShims.WriteToSDB(pdb)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        //
        // Done indexing the shims
        //
        if (!SdbStopIndexing(pdb, m_pDB->m_iiShimIndex)) {
            SDBERROR(_T("Error stopping indexing shims.\n"));
            goto eh;
        }

        //
        // Patches
        //
        if (!m_rgPatches.WriteToSDB(pdb)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        //
        // Flags
        //
        if (!m_rgFlags.WriteToSDB(pdb)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }
    }

    //
    // Included files
    //
    if (!m_rgFiles.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (m_pDB->m_pCurrentOutputFile->m_dwFilter & SDB_FILTER_MSI) {
        //
        // Msi Transforms, indexed by the their respective name
        //
        if (!SdbStartIndexing(pdb, m_pDB->m_iiMsiTransformIndex)) {
            SDBERROR(_T("Error starting to index MSI Transforms.\n"));
            goto eh;
        }

        if (!m_rgMsiTransforms.WriteToSDB(pdb)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }

        if (!SdbStopIndexing(pdb, m_pDB->m_iiMsiTransformIndex)) {
            SDBERROR(_T("Error stopping indexing MSI Transforms.\n"));
            goto eh;
        }
    }


    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiLibrary)) {
        SDBERROR(_T("Error ending TAG_LIBRARY\n"));
        goto eh;
    }

    if (m_pDB->m_pCurrentOutputFile->m_dwFilter & SDB_FILTER_FIX) {
        //
        // Layers
        //
        // BUGBUG: Layers should be *inside* the library
        //
        if (!m_rgLayers.WriteToSDB(pdb)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL SdbExe::WriteToSDB(PDB pdb)
{
    BOOL        bSuccess = FALSE;

    TAGID       tiExe;
    long        i;
    ULONGLONG   ullFlagsNTVDM1 = 0;
    ULONGLONG   ullFlagsNTVDM2 = 0;
    ULONGLONG   ullFlagsNTVDM3 = 0;

    //
    // Open tag
    //
    tiExe = SdbBeginWriteListTag(pdb, TAG_EXE);
    if (!tiExe) {
        SDBERROR(_T("Error writing TAG_EXE\n"));
        goto eh;
    }

    //
    // NAME (i.e., EXE filename)
    //
    if (m_csName.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_NAME, m_csName)) {
            SDBERROR(_T("Error writing TAG_NAME\n"));
            goto eh;
        }

        //
        // If there's a wildcard in the name, write WILDCARD_NAME
        // as well, for the indexing
        //
        if (m_bWildcardInName) {
            if (!SdbWriteStringTag(pdb, TAG_WILDCARD_NAME, m_csName)) {
                SDBERROR(_T("Error writing TAG_WILDCARD_NAME\n"));
                goto eh;
            }
        }
        //
        // If this is supposed to match on module name, write that out too
        //
        if (m_bMatchOnModule) {
            if (!SdbWriteStringTag(pdb, TAG_16BIT_MODULE_NAME, m_csName)) {
                SDBERROR(_T("Error writing TAG_16BIT_MODULE_NAME\n"));
                goto eh;
            }
        }
    }

    //
    // APP_NAME (i.e., application title)
    //
    if (m_pApp != NULL) {
        if (m_pApp->m_csName.GetLength()) {
            if (!SdbWriteStringTag(pdb, TAG_APP_NAME, m_pApp->m_csName)) {
                SDBERROR(_T("Error writing TAG_APP_NAME\n"));
                goto eh;
            }
        }
    }

    //
    // VENDOR
    //
    if (m_pApp != NULL) {
        if (m_pApp->m_csVendor.GetLength()) {
            if (!SdbWriteStringTag(pdb, TAG_VENDOR, m_pApp->m_csVendor)) {
                SDBERROR(_T("Error writing TAG_VENDOR\n"));
                goto eh;
            }
        }
    }

    //
    // GUID (Unique ID)
    //
    if (!SdbWriteBinaryTag(pdb, TAG_EXE_ID, (PBYTE)&m_ID, sizeof(m_ID))) {
        SDBERROR(_T("Error writing TAG_EXE_ID\n"));
        goto eh;
    }

    //
    // OS SERVICE PACK mask if it's anything other than 0xFFFFFFFF
    //
    if (m_dwSPMask != 0xFFFFFFFF) {
        if (!SdbWriteDWORDTag(pdb, TAG_OS_SERVICE_PACK, m_dwSPMask)) {
            SDBERROR(_T("Error writing TAG_OS_SERVICE_PACK\n"));
            goto eh;
        }
    }

    //
    // Write the MATCH_MODE tag if it's anything other than NORMAL
    //
    if (m_dwMatchMode != MATCH_DEFAULT) {
        BOOL bWriteMatchMode = FALSE;

        if (m_pDB->IsStandardDatabase()) {
            //
            // standard db, we write match mode if it's not "normal"
            // since normal is the default
            //
            bWriteMatchMode = (m_dwMatchMode != MATCHMODE_DEFAULT_MAIN);
        } else {
            //
            // for custom dbs default match mode is additive
            //
            bWriteMatchMode = (m_dwMatchMode != MATCHMODE_DEFAULT_CUSTOM);
        }

        if (bWriteMatchMode && !SdbWriteWORDTag(pdb, TAG_MATCH_MODE, (WORD)m_dwMatchMode)) {
            SDBERROR(_T("Error writing TAG_MATCH_MODE\n"));
            goto eh;
        }
    }

    //
    // Write the RUNTIME_PLATFORM tag if it's anything other than RUNTIME_PLATFORM_ANY
    //
    if (m_dwRuntimePlatform != RUNTIME_PLATFORM_ANY) {
        if (!SdbWriteDWORDTag(pdb, TAG_RUNTIME_PLATFORM, m_dwRuntimePlatform)) {
            SDBERROR(_T("Error writing RUNTIME_PLATFORM\n"));
            goto eh;
        }
    }

    //
    // Write the OS_SKU tag if it's anything other than OS_SKU_ALL
    //
    if (m_dwOSSKU != OS_SKU_ALL) {
        if (!SdbWriteDWORDTag(pdb, TAG_OS_SKU, m_dwOSSKU)) {
            SDBERROR(_T("Error writing OS_SKU\n"));
            goto eh;
        }
    }

    //
    // Message reference
    //
    if (m_AppHelpRef.m_pAppHelp) {
        if (!m_AppHelpRef.WriteToSDB(pdb)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }
    }

    //
    // Matching Files
    //
    if (!m_rgMatchingFiles.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Shim references
    //
    if (!m_rgShimRefs.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Flag references
    //
    if (!m_rgFlagRefs.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Patches (by reference)
    //
    if (!m_rgPatches.WriteToSDB(pdb, TRUE)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Layers references
    //
    if (!m_rgLayerRefs.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!m_csSXSManifest.IsEmpty()) {
        //
        // Add XML header tag
        //
        WCHAR wszXMLHeader[] = L"<?xml version=\"1.0\" encoding=\"UCS-2\" standalone=\"yes\"?>";

        //
        // The whole manifest consists of the Unicode byte marker (1 byte), the XML header,
        // the manifest itself, and a NULL terminator (1 byte).
        //
        DWORD  dwSXSEntryLen = wcslen(wszXMLHeader) + m_csSXSManifest.GetLength() + 2;
        LPWSTR wszSXSEntry = (LPWSTR) (malloc(dwSXSEntryLen * sizeof(WCHAR)));

        //
        // Begin with 0xFF 0xFE Unicode byte order marker
        //
        UCHAR*  szSXSEntry = (UCHAR*) wszSXSEntry;
        szSXSEntry[0] = 0xFF;
        szSXSEntry[1] = 0xFE;

        //
        // Add the XML header
        //
        StringCchCopy(wszSXSEntry + 1, dwSXSEntryLen, wszXMLHeader);

        //
        // Add the manifest
        //
        StringCchCat(wszSXSEntry, dwSXSEntryLen, m_csSXSManifest);

        if (!SdbWriteStringTag(pdb, TAG_SXS_MANIFEST, wszSXSEntry)) {
            goto eh;
        }

        free(wszSXSEntry);
    }

    //
    // Data
    //
    if (!m_rgData.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Action
    //
    if (!m_rgAction.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiExe)) {
        SDBERROR(_T("Error ending TAG_EXE\n"));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}


BOOL SdbMsiPackage::WriteToSDB(PDB pdb)
{
    BOOL bSuccess = FALSE;
    TAGID tiMsiPackage;


    //
    // Open tag
    //
    tiMsiPackage = SdbBeginWriteListTag(pdb, TAG_MSI_PACKAGE);
    if (!tiMsiPackage) {
        SDBERROR(_T("Error writing TAG_MSI_PACKAGE\n"));
        goto eh;
    }

    //
    // NAME (i.e., EXE filename)
    //
    if (m_csName.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_NAME, m_csName)) {
            SDBERROR(_T("Error writing TAG_NAME for MSI_PACKAGE\n"));
            goto eh;
        }
    }

    //
    // APP_NAME (i.e., application title)
    //
    if (m_pApp != NULL) {
        if (m_pApp->m_csName.GetLength()) {
            if (!SdbWriteStringTag(pdb, TAG_APP_NAME, m_pApp->m_csName)) {
                SDBERROR(_T("Error writing TAG_APP_NAME for MSI_PACKAGE\n"));
                goto eh;
            }
        }
    }

    //
    // GUID (unique ID)
    //
    if (!SdbWriteBinaryTag(pdb, TAG_EXE_ID, (PBYTE)&m_ID, sizeof(m_ID))) {
        SDBERROR(_T("Error writing TAG_EXE_ID\n"));
        goto eh;
    }

    //
    // GUID (non-Unique ID)
    //
    if (!SdbWriteBinaryTag(pdb, TAG_MSI_PACKAGE_ID, (PBYTE)&m_MsiPackageID, sizeof(m_MsiPackageID))) {
        SDBERROR(_T("Error writing TAG_MSI_PACKAGE_ID\n"));
        goto eh;
    }

    //
    // RUNTIME_PLATFORM data
    //
    if (m_dwRuntimePlatform != RUNTIME_PLATFORM_ANY) {
        if (!SdbWriteDWORDTag(pdb, TAG_RUNTIME_PLATFORM, m_dwRuntimePlatform)) {
            SDBERROR(_T("Error writing RUNTIME_PLATFORM\n"));
            goto eh;
        }
    }

    //
    // Write the OS_SKU tag if it's anything other than OS_SKU_ALL
    //
    if (m_dwOSSKU != OS_SKU_ALL) {
        if (!SdbWriteDWORDTag(pdb, TAG_OS_SKU, m_dwOSSKU)) {
            SDBERROR(_T("Error writing OS_SKU\n"));
            goto eh;
        }
    }

    //
    // Supplemental data
    //

    if (!m_rgData.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // applicable fixes (reference to transforms)
    //

    if (!m_rgMsiTransformRefs.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }


    //
    // Message reference
    //
    if (m_AppHelpRef.m_pAppHelp) {
        if (!m_AppHelpRef.WriteToSDB(pdb)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }
    }

    //
    // custom actions
    //
    if (!m_rgCustomActions.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiMsiPackage)) {
        SDBERROR(_T("Error ending TAG_MSI_PACKAGE\n"));
        goto eh;
    }


    bSuccess = TRUE;
eh:
    return bSuccess;
}

BOOL SdbMsiCustomAction::WriteToSDB(PDB pdb)
{
    TAGID tiMsiCustomAction;
    BOOL  bSuccess = FALSE;

    //
    // Open tag
    //
    tiMsiCustomAction = SdbBeginWriteListTag(pdb, TAG_MSI_CUSTOM_ACTION);
    if (!tiMsiCustomAction) {
        SDBERROR(_T("Error writing TAG_MSI_CUSTOM_ACTION\n"));
        goto eh;
    }

    //
    // NAME (i.e., EXE filename)
    //
    if (m_csName.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_NAME, m_csName)) {
            SDBERROR(_T("Error writing TAG_NAME for MSI_CUSTOM_ACTION\n"));
            goto eh;
        }
    }

    //
    // Shim references
    //
    if (!m_rgShimRefs.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!m_rgLayerRefs.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiMsiCustomAction)) {
        SDBERROR(_T("Error ending TAG_MSI_CUSTOM_ACTION\n"));
        goto eh;
    }


    bSuccess = TRUE;

eh:
    return bSuccess;


}


BOOL SdbCaller::WriteToSDB(PDB pdb)
{
    BOOL        bSuccess = FALSE;
    TAGID       tiCaller;

    //
    // Open tag
    //
    tiCaller = SdbBeginWriteListTag(pdb, TAG_INEXCLUDE);
    if (!tiCaller) {
        SDBERROR(_T("Error writing TAG_INEXCLUDE\n"));
        goto eh;
    }

    //
    // If it's an <INCLUDE> tag, write out the indicator
    //
    if (m_CallerType == SDB_CALLER_INCLUDE) {
        if (!SdbWriteNULLTag(pdb, TAG_INCLUDE)) {
            SDBERROR(_T("Error writing TAG_INCLUDE\n"));
            goto eh;
        }
    }

    //
    // Module
    //
    if (m_csModule.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_MODULE, m_csModule)) {
            SDBERROR(_T("Error writing TAG_MODULE\n"));
            goto eh;
        }
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiCaller)) {
        SDBERROR(_T("Error ending TAG_INEXCLUDE\n"));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL SdbFile::WriteToSDB(PDB pdb)
{
    BOOL        bSuccess = FALSE;
    TAGID       tiFile;
    CString     csFileDir, csFilename;

    csFileDir = MakeFullPath(m_pDB->m_pCurrentOutputFile->GetParameter(_T("INCLUDE FILES")));

    //
    // Check if filtered out
    //
    if (!(m_dwFilter & m_pDB->m_pCurrentOutputFile->m_dwFilter)) {
        //
        // Filtered out, return success
        //
        return TRUE;
    }

    //
    // Open tag
    //
    tiFile = SdbBeginWriteListTag(pdb, TAG_FILE);
    if (!tiFile) {
        SDBERROR(_T("Error writing TAG_FILE\n"));
        goto eh;
    }

    //
    // NAME
    //
    if (m_csName.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_NAME, m_csName)) {
            SDBERROR(_T("Error writing TAG_NAME\n"));
            goto eh;
        }
    }

    //
    // Binary data
    //
    if (csFileDir.GetLength()) {
        csFilename = csFileDir;
        csFilename += m_csName;

        if (!SdbWriteBinaryTagFromFile(pdb, TAG_FILE_BITS, csFilename)) {
            if (g_bStrict) {
                SDBERROR_FORMAT((_T("Can't find FILE \"%s\". No bits written.\n"), csFilename));
                goto eh;
            }
        }
    } else {
        if (g_bStrict) {
            SDBERROR_FORMAT((_T("Can't find FILE \"%s\". -f compiler flag required.\n"), m_csName));
            goto eh;
        }
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiFile)) {
        SDBERROR(_T("Error ending TAG_FILE\n"));
        goto eh;
    }

    m_tiTagID = tiFile; // this is the tagid as it was written into the database

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL SdbShimRef::WriteToSDB(PDB pdb)
{
    BOOL        bSuccess = FALSE;
    TAGID       tiShimRef;

    //
    // Open tag
    //
    tiShimRef = SdbBeginWriteListTag(pdb, TAG_SHIM_REF);
    if (!tiShimRef) {
        SDBERROR(_T("Error writing TAG_SHIM_REF\n"));
        goto eh;
    }

    //
    // NAME
    //
    if (!SdbWriteStringTag(pdb, TAG_NAME, m_csName)) {
        SDBERROR(_T("Error writing NAME tag\n"));
        goto eh;
    }

    //
    // Write TAGID of the SHIM in the LIBRARY, if any
    //
    if (m_pShim && m_pShim->m_tiTagID) {
        if (!SdbWriteDWORDTag(pdb, TAG_SHIM_TAGID, m_pShim->m_tiTagID)) {
            SDBERROR(_T("Error writing TAG_SHIM_TAGID\n"));
            goto eh;
        }
    }

    //
    // COMMAND_LINE
    //
    if (m_csCommandLine.GetLength()) {

        //
        // process this command line first
        //
        CString csProcessedCmdLine = ProcessShimCmdLine(m_csCommandLine, m_pDB->m_CurrentDBID, tiShimRef);

        if (!SdbWriteStringTag(pdb, TAG_COMMAND_LINE, csProcessedCmdLine)) {
            SDBERROR(_T("Error writing COMMAND_LINE tag\n"));
            goto eh;
        }
    }

    //
    // Inclusion/exclusion list
    //
    if (!m_rgCallers.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // child data tags
    //
    if (!m_rgData.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }


    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiShimRef)) {
        SDBERROR(_T("Error ending TAG_SHIM_REF\n"));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL SdbShim::WriteToSDB(PDB pdb)
{
    BOOL        bSuccess = FALSE;
    TAGID       tiShim;

    //
    // Open tag
    //
    tiShim = SdbBeginWriteListTag(pdb, TAG_SHIM);
    if (!tiShim) {
        SDBERROR(_T("Error writing TAG_SHIM\n"));
        goto eh;
    }

    m_tiTagID = tiShim;

    //
    // NAME
    //
    if (m_csName.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_NAME, m_csName)) {
            SDBERROR(_T("Error writing TAG_NAME\n"));
            goto eh;
        }
    }

    if (m_csDllFile.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_DLLFILE, m_csDllFile)) {
            SDBERROR(_T("Error writing TAG_DLLFILE\n"));
            goto eh;
        }
    }

    //
    // DESCRIPTION, only written for general-purpose shims
    //
    if (m_csDesc.GetLength() && m_Purpose == SDB_PURPOSE_GENERAL) {
        //
        // Remove all extra white space and new line characters
        // via TrimParagraph()
        //
        if (!SdbWriteStringTag(pdb, TAG_DESCRIPTION, TrimParagraph(m_csDesc))) {
            SDBERROR(_T("Error writing TAG_DESCRIPTION\n"));
            goto eh;
        }
    }

    //
    // Purpose (if general)
    //
    if (m_Purpose == SDB_PURPOSE_GENERAL) {
        if (!SdbWriteNULLTag(pdb, TAG_GENERAL)) {
            SDBERROR(_T("Error writing TAG_GENERAL\n"));
            goto eh;
        }
    }

    //
    // APPLY_ALL_SHIMS flag
    //
    if (m_bApplyAllShims) {
        if (!SdbWriteNULLTag(pdb, TAG_APPLY_ALL_SHIMS)) {
            SDBERROR(_T("Error writing TAG_APPLY_ALL_SHIMS\n"));
            goto eh;
        }
    }

    //
    // Inclusion/exclusion list
    //
    if (!m_rgCallers.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiShim)) {
        SDBERROR(_T("Error ending TAG_SHIM\n"));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL SdbPatch::WriteToSDB(PDB pdb)
{
    BOOL        bSuccess = FALSE;
    TAGID       tiPatch;

    //
    // Open tag
    //
    tiPatch = SdbBeginWriteListTag(pdb, TAG_PATCH);
    if (!tiPatch) {
        SDBERROR(_T("Error writing TAG_PATCH\n"));
        goto eh;
    }

    m_tiTagID = tiPatch;

    //
    // NAME
    //
    if (m_csName.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_NAME, m_csName)) {
            SDBERROR(_T("Error writing TAG_NAME\n"));
            goto eh;
        }
    }

    //
    // Patch bits
    //
    if (GetBlobSize()) {
        if (!SdbWriteBinaryTag(pdb, TAG_PATCH_BITS, GetBlobBytes(), GetBlobSize())) {
            SDBERROR_FORMAT((_T("Error writing patch bytes \"%s\"\n"), m_csName));
            goto eh;
        }
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiPatch)) {
        SDBERROR(_T("Error ending TAG_PATCH\n"));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL SdbPatch::WriteRefToSDB(PDB pdb)
{
    BOOL        bSuccess = FALSE;
    TAGID       tiPatch;

    //
    // Open tag
    //
    tiPatch = SdbBeginWriteListTag(pdb, TAG_PATCH_REF);
    if (!tiPatch) {
        SDBERROR(_T("Error writing TAG_PATCH\n"));
        goto eh;
    }

    //
    // NAME
    //
    if (m_csName.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_NAME, m_csName)) {
            SDBERROR(_T("Error writing TAG_NAME\n"));
            goto eh;
        }
    }

    //
    // Write TAGID of the PATCH in the LIBRARY, if any
    //
    if (m_tiTagID) {
        if (!SdbWriteDWORDTag(pdb, TAG_PATCH_TAGID, m_tiTagID)) {
            SDBERROR(_T("Error writing TAG_PATCH_TAGID\n"));
            goto eh;
        }
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiPatch)) {
        SDBERROR(_T("Error ending TAG_PATCH\n"));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL SdbFlag::WriteToSDB(PDB pdb)
{
    BOOL        bSuccess = FALSE;
    TAGID       tiFlag;

    //
    // Open tag
    //
    tiFlag = SdbBeginWriteListTag(pdb, TAG_FLAG);
    if (!tiFlag) {
        SDBERROR(_T("Error writing TAG_FLAG\n"));
        goto eh;
    }

    m_tiTagID = tiFlag;

    //
    // NAME
    //
    if (m_csName.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_NAME, m_csName)) {
            SDBERROR(_T("Error writing TAG_NAME\n"));
            goto eh;
        }
    }

    //
    // DESCRIPTION, only general-purpose descriptions
    //
    if (m_csDesc.GetLength() && m_Purpose == SDB_PURPOSE_GENERAL) {
        //
        // Remove all extra white space and new line characters
        // via TrimParagraph()
        //
        if (!SdbWriteStringTag(pdb, TAG_DESCRIPTION, TrimParagraph(m_csDesc))) {
            SDBERROR(_T("Error writing TAG_DESCRIPTION\n"));
            goto eh;
        }
    }

    //
    // Mask
    //
    if (!SdbWriteQWORDTag(pdb, TagFromType(m_dwType), m_ullMask)) {
        SDBERROR(_T("Error writing <FLAG> in <LIBRARY>\n"));
        goto eh;
    }

    //
    // Purpose (if general)
    //
    if (m_Purpose == SDB_PURPOSE_GENERAL) {
        if (!SdbWriteNULLTag(pdb, TAG_GENERAL)) {
            SDBERROR(_T("Error writing TAG_GENERAL\n"));
            goto eh;
        }
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiFlag)) {
        SDBERROR(_T("Error ending TAG_FLAG\n"));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL SdbFlagRef::WriteToSDB(PDB pdb)
{
    BOOL        bSuccess = FALSE;
    TAGID       tiFlagRef;

    //
    // Open tag
    //
    tiFlagRef = SdbBeginWriteListTag(pdb, TAG_FLAG_REF);
    if (!tiFlagRef) {
        SDBERROR(_T("Error writing TAG_FLAG_REF\n"));
        goto eh;
    }

    //
    // NAME
    //
    if (!SdbWriteStringTag(pdb, TAG_NAME, m_csName)) {
        SDBERROR(_T("Error writing NAME tag\n"));
        goto eh;
    }

    //
    // Write TAGID of the FLAG in the LIBRARY, if any
    //
    if (m_pFlag && m_pFlag->m_tiTagID) {
        if (!SdbWriteDWORDTag(pdb, TAG_FLAG_TAGID, m_pFlag->m_tiTagID)) {
            SDBERROR(_T("Error writing TAG_FLAG_TAGID\n"));
            goto eh;
        }
    }

    //
    // Write Command Line tag
    //

    if (m_csCommandLine.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_COMMAND_LINE, m_csCommandLine)) {
            SDBERROR(_T("Error writing COMMAND_LINE tag for flag\n"));
            goto eh;
        }
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiFlagRef)) {
        SDBERROR(_T("Error ending TAG_FLAG_REF\n"));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}


BOOL SdbMsiTransformRef::WriteToSDB(PDB pdb)
{
    BOOL bSuccess = FALSE;
    TAGID tiMsiTransformRef;

    tiMsiTransformRef = SdbBeginWriteListTag(pdb, TAG_MSI_TRANSFORM_REF);
    if (!tiMsiTransformRef) {
        SDBERROR(_T("Error writing TAG_MSI_TRANSFORM_REF\n"));
        goto eh;
    }

    //
    // write out the reference to the transform by name first
    //
    if (m_csName.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_NAME, m_csName)) {
            SDBERROR(_T("Error writing TAG_NAME\n"));
            goto eh;
        }
    }

    //
    // now -- satisfy the judgement by writing reference to the
    // actual transform object if available
    //
    if (m_pMsiTransform != NULL) {

        if (!SdbWriteDWORDTag(pdb, TAG_MSI_TRANSFORM_TAGID, m_pMsiTransform->m_tiTagID)) {
            SDBERROR(_T("Error writing TAG_MSI_TRANSFORM_TAGID for MSI_TRANSFORM_REF\n"));
            goto eh;
        }
    }

    if (!SdbEndWriteListTag(pdb, tiMsiTransformRef)) {
        SDBERROR(_T("Error ending TAG_MSI_TRANSFORM_REF\n"));
        goto eh;
    }

    bSuccess = TRUE;

eh:
    return bSuccess;
}

BOOL SdbMsiTransform::WriteToSDB(PDB pdb)
{
    BOOL bSuccess = FALSE;
    TAGID tiMsiTransform;

    //
    // write out the name of the transform

    tiMsiTransform = SdbBeginWriteListTag(pdb, TAG_MSI_TRANSFORM);
    if (!tiMsiTransform) {
        SDBERROR(_T("Error writing TAG_MSI_TRANSFORM\n"));
        goto eh;
    }

    //
    // NAME
    //
    if (m_csName.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_NAME, m_csName)) {
            SDBERROR(_T("Error writing TAG_NAME\n"));
            goto eh;
        }
    }

    //
    // MSI transform file name
    //
    if (m_csMsiTransformFile.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_MSI_TRANSFORM_FILE, m_csMsiTransformFile)) {
            SDBERROR(_T("Error writing TAG_MSI_TRANSFORM_FILE\n"));
            goto eh;
        }
    }

    //
    // REFERENCE the Actual file bits
    //
    if (m_pSdbFile != NULL && m_pSdbFile->m_tiTagID != TAGID_NULL) {
        if (!SdbWriteDWORDTag(pdb, TAG_MSI_TRANSFORM_TAGID, m_pSdbFile->m_tiTagID)) {
            SDBERROR(_T("Error writing TAG_MSI_TRANSFORM_TAGID\n"));
            goto eh;
        }
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiMsiTransform)) {
        SDBERROR(_T("Error ending TAG_MSI_TRANSFORM\n"));
        goto eh;
    }


    m_tiTagID = tiMsiTransform;

    bSuccess = TRUE;
eh:
    return bSuccess;
}


BOOL SdbLayer::WriteToSDB(PDB pdb)
{
    BOOL        bSuccess = FALSE;
    TAGID       tiLayer;
    long        i;

    //
    // Open tag
    //
    tiLayer = SdbBeginWriteListTag(pdb, TAG_LAYER);
    if (!tiLayer) {
        SDBERROR(_T("Error writing TAG_LAYER\n"));
        goto eh;
    }

    m_tiTagID = tiLayer;

    //
    // NAME
    //
    if (m_csName.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_NAME, m_csName)) {
            SDBERROR(_T("Error writing TAG_NAME\n"));
            goto eh;
        }
    }

    //
    // Display name
    //
    if (m_csDisplayName.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_LAYER_DISPLAYNAME, m_csDisplayName)) {
            SDBERROR(_T("Error writing TAG_LAYER_DISPLAYNAME\n"));
            goto eh;
        }
    }

    //
    // Shim references
    //
    if (!m_rgShimRefs.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Flags
    //
    if (!m_rgFlagRefs.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiLayer)) {
        SDBERROR(_T("Error ending TAG_LAYER\n"));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}


BOOL SdbLayerRef::WriteToSDB(PDB pdb)
{
    BOOL        bSuccess = FALSE;
    TAGID       tiLayer;

    //
    // Open tag
    //
    tiLayer = SdbBeginWriteListTag(pdb, TAG_LAYER);
    if (!tiLayer) {
        SDBERROR(_T("Error writing TAG_LAYER\n"));
        goto eh;
    }

    //
    // NAME
    //
    if (m_csName.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_NAME, m_csName)) {
            SDBERROR(_T("Error writing TAG_NAME\n"));
            goto eh;
        }
    }

    //
    // Write TAGID of the LAYER in the LIBRARY, if any
    //
    if (m_pLayer) {
        if (m_pLayer->m_tiTagID) {
            if (!SdbWriteDWORDTag(pdb, TAG_LAYER_TAGID, m_pLayer->m_tiTagID)) {
                SDBERROR(_T("Error writing TAG_LAYER_TAGID\n"));
                goto eh;
            }
        }
    }

    //
    // child data tags
    //
    if (!m_rgData.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiLayer)) {
        SDBERROR(_T("Error ending TAG_LAYER\n"));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL SdbMatchingFile::WriteToSDB(PDB pdb)
{
    BOOL        bSuccess = FALSE;
    TAGID       tiMatchingFile;

    //
    // Open tag
    //
    tiMatchingFile = SdbBeginWriteListTag(pdb, TAG_MATCHING_FILE);
    if (!tiMatchingFile) {
        SDBERROR(_T("Error writing TAG_MATCHING_FILE\n"));
        goto eh;
    }

    //
    // NAME
    //
    if (m_csName.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_NAME, m_csName)) {
            SDBERROR(_T("Error writing TAG_NAME\n"));
            goto eh;
        }
    }

    //
    // platform should be first if it exists -- along with the logic bit
    //


    if (m_bMatchLogicNot) {
        if (!SdbWriteNULLTag(pdb, TAG_MATCH_LOGIC_NOT)) {
            SDBERROR(_T("Error writing MATCH_LOGIC_NOT\n"));
            goto eh;
        }
    }

    // matching information

    if (m_dwMask & SDB_MATCHINGINFO_SIZE) {
        if (!SdbWriteDWORDTag(pdb, TAG_SIZE, m_dwSize)) {
            SDBERROR(_T("Error writing SIZE\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_CHECKSUM) {
        if (!SdbWriteDWORDTag(pdb, TAG_CHECKSUM, m_dwChecksum)) {
            SDBERROR(_T("Error writing CHECKSUM\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_COMPANY_NAME) {
        if (!SdbWriteStringTag(pdb, TAG_COMPANY_NAME, m_csCompanyName)) {
            SDBERROR(_T("Error writing COMPANY_NAME tag\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_PRODUCT_NAME) {
        if (!SdbWriteStringTag(pdb, TAG_PRODUCT_NAME, m_csProductName)) {
            SDBERROR(_T("Error writing PRODUCT_NAME tag\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_PRODUCT_VERSION) {
        if (!SdbWriteStringTag(pdb, TAG_PRODUCT_VERSION, m_csProductVersion)) {
            SDBERROR(_T("Error writing PRODUCT_VERSION tag\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_FILE_DESCRIPTION) {
        if (!SdbWriteStringTag(pdb, TAG_FILE_DESCRIPTION, m_csFileDescription)) {
            SDBERROR(_T("Error writing FILE_DESCRIPTION tag\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_BIN_FILE_VERSION) {
        if (!SdbWriteQWORDTag(pdb, TAG_BIN_FILE_VERSION, m_ullBinFileVersion)) {
            SDBERROR(_T("Error writing BIN_FILE_VERSION\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_BIN_PRODUCT_VERSION) {
        if (!SdbWriteQWORDTag(pdb, TAG_BIN_PRODUCT_VERSION, m_ullBinProductVersion)) {
            SDBERROR(_T("Error writing BIN_PRODUCT_VERSION\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_MODULE_TYPE) {
        if (!SdbWriteDWORDTag(pdb, TAG_MODULE_TYPE, m_dwModuleType)) {
            SDBERROR(_T("Error writing MODULE_TYPE\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_VERFILEDATEHI) {
        if (!SdbWriteDWORDTag(pdb, TAG_VERDATEHI, m_dwFileDateMS)) {
            SDBERROR(_T("Error writing MODULE_TYPE\n"));
            goto eh;
        }

    }

    if (m_dwMask & SDB_MATCHINGINFO_VERFILEDATELO) {
        if (!SdbWriteDWORDTag(pdb, TAG_VERDATELO, m_dwFileDateLS)) {
            SDBERROR(_T("Error writing MODULE_TYPE\n"));
            goto eh;
        }

    }

    if (m_dwMask & SDB_MATCHINGINFO_VERFILEOS) {
        if (!SdbWriteDWORDTag(pdb, TAG_VERFILEOS, m_dwFileOS)) {
            SDBERROR(_T("Error writing VERFILEOS\n"));
            goto eh;
        }

    }

    if (m_dwMask & SDB_MATCHINGINFO_VERFILETYPE) {
        if (!SdbWriteDWORDTag(pdb, TAG_VERFILETYPE, m_dwFileType)) {
            SDBERROR(_T("Error writing VERFILETYPE\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_PE_CHECKSUM) {
        if (!SdbWriteDWORDTag(pdb, TAG_PE_CHECKSUM, m_ulPECheckSum)) {
            SDBERROR(_T("Error writing PE_CHECKSUM\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_LINKER_VERSION) {
        if (!SdbWriteDWORDTag(pdb, TAG_LINKER_VERSION, m_dwLinkerVersion)) {
            SDBERROR(_T("Error writing LINKER_VERSION\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_FILE_VERSION) {
        if (!SdbWriteStringTag(pdb, TAG_FILE_VERSION, m_csFileVersion)) {
            SDBERROR(_T("Error writing FILE_VERSION\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_ORIGINAL_FILENAME) {
        if (!SdbWriteStringTag(pdb, TAG_ORIGINAL_FILENAME, m_csOriginalFileName)) {
            SDBERROR(_T("Error writing ORIGINAL_FILENAME\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_INTERNAL_NAME) {
        if (!SdbWriteStringTag(pdb, TAG_INTERNAL_NAME, m_csInternalName)) {
            SDBERROR(_T("Error writing INTERNAL_NAME\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_LEGAL_COPYRIGHT) {
        if (!SdbWriteStringTag(pdb, TAG_LEGAL_COPYRIGHT, m_csLegalCopyright)) {
            SDBERROR(_T("Error writing LEGAL_COPYRIGHT\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_16BIT_DESCRIPTION) {
        if (!SdbWriteStringTag(pdb, TAG_16BIT_DESCRIPTION, m_cs16BitDescription)) {
            SDBERROR(_T("Error writing 16BIT_DESCRIPTION\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_16BIT_MODULE_NAME) {
        if (!SdbWriteStringTag(pdb, TAG_16BIT_MODULE_NAME, m_cs16BitModuleName)) {
            SDBERROR(_T("Error Writing 16BIT_MODULE_NAME\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_UPTO_BIN_PRODUCT_VERSION) {
        if (!SdbWriteQWORDTag(pdb, TAG_UPTO_BIN_PRODUCT_VERSION, m_ullUpToBinProductVersion)) {
            SDBERROR(_T("Error writing UPTO_BIN_PRODUCT_VERSION\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_UPTO_BIN_FILE_VERSION) {
        if (!SdbWriteQWORDTag(pdb, TAG_UPTO_BIN_FILE_VERSION, m_ullUpToBinFileVersion)) {
            SDBERROR(_T("Error writing UPTO_BIN_FILE_VERSION\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_PREVOSMAJORVERSION) {
        if (!SdbWriteDWORDTag(pdb, TAG_PREVOSMAJORVER, m_dwPrevOSMajorVersion)) {
            SDBERROR(_T("Error writing PREVOSMAJORVER\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_PREVOSMINORVERSION) {
        if (!SdbWriteDWORDTag(pdb, TAG_PREVOSMINORVER, m_dwPrevOSMinorVersion)) {
            SDBERROR(_T("Error writing PREVOSMINORVER\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_PREVOSPLATFORMID) {
        if (!SdbWriteDWORDTag(pdb, TAG_PREVOSPLATFORMID, m_dwPrevOSPlatformID)) {
            SDBERROR(_T("Error writing PREVOSPLATFORMID\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_PREVOSBUILDNO) {
        if (!SdbWriteDWORDTag(pdb, TAG_PREVOSBUILDNO, m_dwPrevOSBuildNo)) {
            SDBERROR(_T("Error writing PREVOSBUILDNO\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_LINK_DATE) {
        if (!SdbWriteDWORDTag(pdb, TAG_LINK_DATE, (DWORD) m_timeLinkDate)) {
            SDBERROR(_T("Error writing LINK_DATE\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_UPTO_LINK_DATE) {
        if (!SdbWriteDWORDTag(pdb, TAG_UPTO_LINK_DATE, (DWORD) m_timeUpToLinkDate)) {
            SDBERROR(_T("Error writing UPTO_LINK_DATE\n"));
            goto eh;
        }
    }

    if (m_dwMask & SDB_MATCHINGINFO_VER_LANGUAGE) {
        if (!SdbWriteDWORDTag(pdb, TAG_VER_LANGUAGE, m_dwVerLanguage)) {
            SDBERROR(_T("Error writing VER_LANGUAGE tag\n"));
            goto eh;
        }
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiMatchingFile)) {
        SDBERROR(_T("Error ending TAG_MATCHING_FILE\n"));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL SdbAppHelpRef::WriteToSDB(PDB pdb)
{
    BOOL        bSuccess = FALSE;
    TAGID       tiAppHelp;
    CString     cs;

    //
    // Open tag
    //
    tiAppHelp = SdbBeginWriteListTag(pdb, TAG_APPHELP);
    if (!tiAppHelp) {
        SDBERROR(_T("Error writing TAG_APPHELP\n"));
        goto eh;
    }

    if (m_pDB->m_pCurrentOutputFile->m_dwFilter & ~SDB_FILTER_DRIVER) {
        //
        // If this EXE entry contains only APPHELP entries, set
        // a flag.
        //
        if (m_bApphelpOnly) {
            if (!SdbWriteDWORDTag(pdb, TAG_FLAGS, SHIMDB_APPHELP_ONLY)) {
                SDBERROR(_T("Error writing FLAGS in APPHELP entry\n"));
                goto eh;
            }
        }

        //
        // Severity
        //
        if (!SdbWriteDWORDTag(pdb, TAG_PROBLEMSEVERITY, (DWORD)m_pAppHelp->m_Type)) {
            SDBERROR( _T("Error writing PROBLEM_SEVERITY\n"));
            goto eh;
        }
    }

    //
    // HTMLHELPID
    //
    if (!SdbWriteDWORDTag(pdb, TAG_HTMLHELPID, (DWORD)_ttol(m_pAppHelp->m_csName))) {
        SDBERROR( _T("Error writing HTMLHELPID\n"));
        goto eh;
    }

    //
    // Check for service pack parameters.
    //
    cs = m_pDB->m_pCurrentOutputFile->GetParameter("DATE AFTER WHICH TO USE SERVICE PACK APPHELP SDB");
    if (cs.GetLength()) {
        COleDateTime odt;
        if (!odt.ParseDateTime(cs)) {
            SDBERROR_FORMAT((_T("Error parsing DATE AFTER WHICH TO USE SERVICE PACK APPHELP SDB parameter: \"%s\"\n"), cs));
            goto eh;
        }

        if (odt.m_dt <= m_pAppHelp->m_dtLastRevision) {
            if (!SdbWriteNULLTag(pdb, TAG_USE_SERVICE_PACK_FILES)) {
                SDBERROR( _T("Error writing USE_SERVICE_PACK_FILES\n"));
                goto eh;
            }
        }
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiAppHelp)) {
        SDBERROR(_T("Error ending TAG_APPHELP\n"));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL SdbDatabase::ConstructMigrationMessage(
    SdbWin9xMigration* pMigApp,
    SdbMessage*        pMessage,
    CString*           pcsMessage
    )
{
    BOOL                bSuccess = FALSE;
    CString             csSummaryXML, csRedirURL;

    SdbRefArray<SdbMessageField> rgFields;
    SdbMessageField     TitleField;
    SdbMessageField     VendorField;

    if (pMessage->m_csSummaryXML.IsEmpty()) {
        if (pMessage->m_pTemplate != NULL) {
            csSummaryXML = pMessage->m_pTemplate->m_csSummaryXML;
        }
    } else {
        csSummaryXML = pMessage->m_csSummaryXML;
    }

    TitleField.m_csName = _T("TITLE");
    TitleField.m_csValue = pMigApp->m_pApp->GetLocalizedAppName();
    VendorField.m_csName = _T("VENDOR");
    VendorField.m_csValue = pMigApp->m_pApp->GetLocalizedVendorName();

    rgFields.Add(&TitleField);
    rgFields.Add(&VendorField);
    rgFields.Append(pMessage->m_rgFields);

    if (!ReplaceFields(csSummaryXML, pcsMessage, &rgFields)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    csRedirURL = m_pCurrentOutputFile->GetParameter(_T("REDIR URL"));

    if (!RedirectLinks(pcsMessage,
        m_pCurrentMakefile->GetLangMap(m_pCurrentOutputFile->m_csLangID)->m_lcid, csRedirURL)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (g_bStrict) {

        if (pcsMessage->IsEmpty()) {
            SDBERROR_FORMAT((_T("ERROR: Empty string for SUMMARY on\n    NAME:       %s\n       MESSAGE: %s\n    LANG:       %s\n\n"),
                pMigApp->m_pApp->m_csName, pMigApp->m_csMessage, m_pCurrentMakefile->m_csLangID));
            goto eh;
        }

    }

    //
    // Remove redundant spacing
    //
    *pcsMessage = TrimParagraph(*pcsMessage);

    //
    // Replace <BR/> with \r\n
    //
    ReplaceStringNoCase(*pcsMessage, _T("<BR/>"), _T("<BR>"));
    ReplaceStringNoCase(*pcsMessage, _T("<P/>"), _T("<BR>"));
    ReplaceStringNoCase(*pcsMessage, _T("&amp;"), _T("&"));

    bSuccess = TRUE;

eh:

    return bSuccess;
}


BOOL SdbDatabase::ConstructMessageParts(
    SdbAppHelp* pAppHelp,
    SdbMessage* pMessage,
    CString& csLangID,
    DWORD* pdwHTMLHelpID,
    CString* pcsURL,
    CString* pcsContactInfo,
    CString* pcsAppTitle,
    CString* pcsSummary,
    CString* pcsDetails)
{
    BOOL                bSuccess = FALSE;
    SdbContactInfo*     pContactInfo;
    SdbMessageTemplate* pTemplate;
    SdbMessageField*    pField;
    CString             csContactInfoXML, csSummaryXML, csDetailsXML;
    CString             csField, csRedirURL, csBaseURL, csLCID;
    long                i;

    SdbRefArray<SdbMessageField> rgFields;
    SdbMessageField     TitleField;
    SdbMessageField     VendorField;

    //
    // If there's a custom URL for this apphelp, use it. If a base content URL was given
    // via the makefile, use that to construct the URL.
    //
    csBaseURL = m_pCurrentOutputFile->GetParameter(_T("BASE ONLINE CONTENT URL"));

    *pdwHTMLHelpID = (DWORD)_ttol(pAppHelp->m_csName);

    if (pAppHelp->m_csURL.GetLength()) {
        *pcsURL = pAppHelp->m_csURL;
    } else if (csBaseURL.GetLength()) {
        *pcsURL = csBaseURL;
        ReplaceStringNoCase(*pcsURL, _T("$HTMLHELPID$"), pAppHelp->m_csName);
        ReplaceStringNoCase(*pcsURL, _T("$LANGID$"), csLangID);
        csLCID.Format(_T("%X"), m_pCurrentMakefile->GetLangMap(csLangID)->m_lcid);
        ReplaceStringNoCase(*pcsURL, _T("$LCID$"), csLCID);
    }

    if (pMessage->m_csContactInfoXML.IsEmpty()) {
        pContactInfo = (SdbContactInfo *) m_rgContactInfo.LookupName(pAppHelp->m_pApp->m_csVendor, csLangID);

        if (pContactInfo == NULL) {
            pContactInfo = (SdbContactInfo *) m_rgContactInfo.LookupName(_T("__DEFAULT__"), csLangID);
        }

        if (pContactInfo == NULL) {
            if (g_bStrict) {
                SDBERROR_FORMAT((_T("ERROR: Localized CONTACT_INFO not found for\n    NAME:       %s\n    HTMLHELPID: %s\n    LANG:       %s\n\n"),
                    pAppHelp->m_pApp->m_csVendor, pAppHelp->m_csName, csLangID));
                goto eh;
            } else {
                csContactInfoXML = pAppHelp->m_pApp->m_csVendorXML;
            }
        } else {
            csContactInfoXML = pContactInfo->m_csXML;
        }
    } else {
        csContactInfoXML = pMessage->m_csContactInfoXML;
    }

    *pcsAppTitle = pAppHelp->m_pApp->GetLocalizedAppName(csLangID);

    if (pMessage->m_csSummaryXML.IsEmpty()) {
        if (pMessage->m_pTemplate != NULL) {
            csSummaryXML = pMessage->m_pTemplate->m_csSummaryXML;
        }
    } else {
        csSummaryXML = pMessage->m_csSummaryXML;
    }

    if (pMessage->m_csDetailsXML.IsEmpty()) {
        if (pMessage->m_pTemplate != NULL) {
            csDetailsXML = pMessage->m_pTemplate->m_csDetailsXML;
        }
    } else {
        csDetailsXML = pMessage->m_csDetailsXML;
    }

    TitleField.m_csName = _T("TITLE");
    TitleField.m_csValue = pAppHelp->m_pApp->GetLocalizedAppName(csLangID);
    VendorField.m_csName = _T("VENDOR");
    VendorField.m_csValue = pAppHelp->m_pApp->GetLocalizedVendorName(csLangID);

    rgFields.Add(&TitleField);
    rgFields.Add(&VendorField);
    rgFields.Append(pMessage->m_rgFields);

    if (!ReplaceFields(csContactInfoXML, pcsContactInfo, &rgFields)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (pcsSummary) {
        if (!ReplaceFields(csSummaryXML, pcsSummary, &rgFields)) {
            SDBERROR_PROPOGATE();
            goto eh;
        }
    }

    if (!ReplaceFields(csDetailsXML, pcsDetails, &rgFields)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    csRedirURL = m_pCurrentOutputFile->GetParameter(_T("REDIR URL"));

    if (!RedirectLinks(pcsContactInfo,
        m_pCurrentMakefile->GetLangMap(csLangID)->m_lcid, csRedirURL)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    if (!RedirectLinks(pcsDetails,
        m_pCurrentMakefile->GetLangMap(csLangID)->m_lcid, csRedirURL)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Remove redundant spacing
    //
    *pcsURL = TrimParagraph(*pcsURL);
    *pcsAppTitle = TrimParagraph(*pcsAppTitle);

    if (pcsSummary) {
        *pcsSummary = TrimParagraph(*pcsSummary);

        //
        // Replace various HTML entities with equivalents
        //
        ReplaceStringNoCase(*pcsSummary, _T("<BR/>"), _T("\r\n"));
        ReplaceStringNoCase(*pcsSummary, _T("<P/>"), _T("\r\n"));
        ReplaceStringNoCase(*pcsSummary, _T("&amp;"), _T("&"));

        if (-1 != pcsSummary->Find(_T('<'))) {
            SDBERROR_FORMAT((_T("ERROR: <SUMMARY> can only contain <BR/> and <P/> formatting tags:\n%s\n"),
                *pcsSummary));
            goto eh;
        }
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL SdbDatabase::WriteAppHelpRefTag(
    PDB pdb,
    CString csHTMLHelpID,
    LCID lcid,
    CString csURL,
    CString csAppTitle,
    CString csSummary)
{
    TAGID tiMessageSummary;
    TAGID tiLink;
    INT i;
    BOOL bReturn = FALSE;

    tiMessageSummary = SdbBeginWriteListTag(pdb, TAG_APPHELP);
    if (!tiMessageSummary) {
         SDBERROR(_T("Error writing APPHELP_DETAILS tag\n"));
         goto eh;
    }

    if (!SdbWriteDWORDTag(pdb, TAG_HTMLHELPID, (DWORD)_ttol(csHTMLHelpID))) {
        SDBERROR( _T("Error writing HTMLHELPID\n"));
        goto eh;
    }

    if (lcid != 0) {
        if (!SdbWriteDWORDTag(pdb, TAG_LANGID, lcid)) {
            SDBERROR( _T("Error writing LANGID\n"));
            goto eh;
        }
    }

    // for each, write a list tag
    tiLink = SdbBeginWriteListTag(pdb,TAG_LINK);
    if (!tiLink) {
        SDBERROR(_T("Error writing APPHELP LINK tag\n"));
        goto eh;
    }

    if (!SdbWriteStringTag(pdb, TAG_LINK_URL, csURL)) {
        SDBERROR(_T("Error writing APPHELP URL tag\n"));
        goto eh;
    }

    if (!SdbEndWriteListTag(pdb, tiLink)) {
        SDBERROR(_T("Error closing APPHELP LINK tag\n"));
        goto eh;
    }

    if (!csAppTitle.IsEmpty() &&
        !SdbWriteStringTag(pdb, TAG_APPHELP_TITLE, csAppTitle)) {
        SDBERROR(_T("Error writing APPHELP_TITLE tag\n"));
        goto eh;
    }

    if (!csSummary.IsEmpty() &&
        !SdbWriteStringTag(pdb, TAG_APPHELP_DETAILS, csSummary)) {
        SDBERROR(_T("Error writing APPHELP_DETAILS tag\n"));
        goto eh;
    }

    if (!SdbEndWriteListTag(pdb, tiMessageSummary)) {
      SDBERROR(_T("Error closing APPHELP_DETAILS tag\n"));
      goto eh;
   }

   bReturn = TRUE;

eh:

   return bReturn;
}
BOOL SdbData::WriteToSDB(PDB pdb)
{
    BOOL                bSuccess = FALSE;

    TAGID               tiData;

    //
    // Open tag
    //
    tiData = SdbBeginWriteListTag(pdb, TAG_DATA);
    if (!tiData) {
        SDBERROR(_T("Error writing TAG_DATA\n"));
        goto eh;
    }

    //
    // NAME
    //
    if (m_csName.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_NAME, m_csName)) {
            SDBERROR(_T("Error writing TAG_NAME\n"));
            goto eh;
        }
    }

    //
    // Value type
    //
    if (!SdbWriteDWORDTag(pdb, TAG_DATA_VALUETYPE, m_DataType)) {
        SDBERROR(_T("Error writing TAG_DATA_VALUETYPE for DRIVER_POLICY\n"));
        goto eh;
    }

    //
    // Value
    //
    switch(m_DataType) {
    case eValueNone:
        break;

    case eValueString:
        if (m_szValue != NULL && !SdbWriteStringTag(pdb, TAG_DATA_STRING, m_szValue)) {
            SDBERROR(_T("Error writing TAG_DATA_STRING\n"));
            goto eh;
        }
        break;

    case eValueDWORD:
        if (!SdbWriteDWORDTag(pdb, TAG_DATA_DWORD, m_dwValue)) {
            SDBERROR(_T("Error writing TAG_DATA_DWORD\n"));
            goto eh;
        }
        break;

    case eValueQWORD:
        if (!SdbWriteQWORDTag(pdb, TAG_DATA_QWORD, m_ullValue)) {
            SDBERROR(_T("Error writing TAG_DATA_QWORD\n"));
            goto eh;
        }
        break;

    case eValueBinary:
        if (!SdbWriteBinaryTag(pdb, TAG_DATA_BITS, m_pBinValue, m_dwDataSize)) {
            SDBERROR(_T("Error writing TAG_DATA_BITS\n"));
            goto eh;
        }
        break;
    }

    //
    // Data
    //
    if (!m_rgData.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiData)) {
        SDBERROR(_T("Error ending TAG_DATA\n"));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

BOOL SdbAction::WriteToSDB(PDB pdb)
{
    BOOL        bSuccess = FALSE;
    TAGID       tiAction;

    //
    // Open tag
    //
    tiAction = SdbBeginWriteListTag(pdb, TAG_ACTION);
    if (!tiAction) {
        SDBERROR(_T("Error writing TAG_ACTION\n"));
        goto eh;
    }

    //
    // NAME
    //
    if (!SdbWriteStringTag(pdb, TAG_NAME, m_csName)) {
        SDBERROR(_T("Error writing NAME tag\n"));
        goto eh;
    }

    //
    // TYPE
    //
    if (m_csType.GetLength()) {
        if (!SdbWriteStringTag(pdb, TAG_ACTION_TYPE, m_csType)) {
            SDBERROR(_T("Error writing TAG_ACTION_TYPE tag\n"));
            goto eh;
        }
    }

    //
    // child data tags
    //
    if (!m_rgData.WriteToSDB(pdb)) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    //
    // Close tag
    //
    if (!SdbEndWriteListTag(pdb, tiAction)) {
        SDBERROR(_T("Error ending TAG_ACTION\n"));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\xml.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    xml.cpp
//
// History: 16-Nov-00   markder     Created.
//
// Desc:    This file contains helper functions to manipulate
//          the MSXML's document object model (DOM).
//
////////////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "xml.h"

void __stdcall _com_issue_error(long)
{
    SDBERROR(_T("Unknown COM error!!"));
}

////////////////////////////////////////////////////////////////////////////////////
//
//  XMLNodeList Implementation
//
//  This class is a wrapper for the IXMLDOMNodeList interface. It simplifies
//  C++ access by exposing functions for executing XQL queries and iterating
//  through the elements in a node list.
//
////////////////////////////////////////////////////////////////////////////////////

XMLNodeList::XMLNodeList()
{
    m_nSize = 0;
}

XMLNodeList::~XMLNodeList()
{
    Clear();
}

void XMLNodeList::Clear()
{
    m_nSize = 0;
    m_csXQL.Empty();

    if (m_cpList) {
        m_cpList.Release();
    }
}

LONG XMLNodeList::GetSize()
{
    return m_nSize;
}

BOOL XMLNodeList::Query(IXMLDOMNode* pNode, LPCTSTR szXQL)
{
    BOOL    bSuccess    = FALSE;
    BSTR    bsXQL       = NULL;

    CString csXQL(szXQL);
    bsXQL = csXQL.AllocSysString();

    Clear();

    if (FAILED(pNode->selectNodes(bsXQL, &m_cpList))) {
        CString csFormat;
        csFormat.Format(_T("Error executing XQL \"%s\""), szXQL);
        SDBERROR(csFormat);
        goto eh;
    }

    if (FAILED(m_cpList->get_length(&m_nSize))) {
        CString csFormat;
        csFormat.Format(_T("Error executing XQL \"%s\""), szXQL);
        SDBERROR(csFormat);
        goto eh;
    }

    m_csXQL = szXQL;

    bSuccess = TRUE;

eh:
    if (bsXQL != NULL) {
        SysFreeString(bsXQL);
    }

    if (!bSuccess) {
        Clear();
    }

    return bSuccess;
}

BOOL XMLNodeList::GetChildNodes(IXMLDOMNode* pNode)
{
    BOOL bSuccess = FALSE;

    Clear();

    if (FAILED(pNode->get_childNodes(&m_cpList))) {
        SDBERROR(_T("Error retrieving child nodes"));
        goto eh;
    }

    if (FAILED(m_cpList->get_length(&m_nSize))) {
        SDBERROR(_T("Error retrieving child nodes"));
        goto eh;
    }

    bSuccess = TRUE;

eh:

    if (!bSuccess) {
        Clear();
    }

    return bSuccess;
}

BOOL XMLNodeList::GetItem(LONG nIndex, IXMLDOMNode** ppNode)
{
    BOOL bSuccess = FALSE;

    if (nIndex < 0 || nIndex >= m_nSize) {
        CString csFormat;
        csFormat.Format(_T("XMLNodeList index %d out of range for XQL \"%s\""), nIndex, m_csXQL);
        SDBERROR(csFormat);
        goto eh;
    }

    if (FAILED(m_cpList->get_item(nIndex, ppNode))) {
        CString csFormat;
        csFormat.Format(_T("XMLNodeList get_item failed for XQL \"%s\""), m_csXQL);
        SDBERROR(csFormat);
        goto eh;
    }

    bSuccess = TRUE;

eh:

    return bSuccess;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   OpenXML
//
//  Desc:   Opens an XML file or stream and returns the root node.
//
BOOL OpenXML(
    CString csFileOrStream,
    IXMLDOMNode** ppRootNode,
    BOOL bStream,
    IXMLDOMDocument** ppDoc)
{
    long                    i;
    long                    nErrorLine          = 0;
    long                    nErrorLinePos       = 0;
    long                    nListCount          = 0;
    BOOL                    bSuccess            = FALSE;
    BSTR                    bsSrcText           = NULL;
    BSTR                    bsErrorReason       = NULL;
    HRESULT                 hr                  = E_FAIL;
    VARIANT                 vFileOrStream;
    VARIANT_BOOL            vbSuccess           = VARIANT_FALSE;
    IXMLDOMDocument*        pDoc                = NULL;
    IXMLDOMParseErrorPtr    cpXMLParseError;

    VariantInit(&vFileOrStream);
    VariantClear(&vFileOrStream);

    if (ppDoc == NULL) {
        ppDoc = &pDoc;
    }

    if (*ppDoc == NULL) {
        if (FAILED(CoCreateInstance(CLSID_DOMDocument,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IXMLDOMDocument,
                                    (LPVOID*)ppDoc))) {

            SDBERROR(_T("Could not instantiate MSXML object.\n"));
            goto eh;
        }
    }

    vFileOrStream.vt = VT_BSTR;
    vFileOrStream.bstrVal = csFileOrStream.AllocSysString();

    //
    // This statement prevents XML parser from replacing white space
    // characters with tabs
    //

    if (bStream) {
        hr = (*ppDoc)->loadXML(vFileOrStream.bstrVal, &vbSuccess);
    } else {
        (*ppDoc)->put_preserveWhiteSpace(VARIANT_TRUE);
        (*ppDoc)->put_validateOnParse(g_bStrict ? VARIANT_TRUE : VARIANT_FALSE);

        hr = (*ppDoc)->load(vFileOrStream, &vbSuccess);
    }


    if (FAILED(hr) || vbSuccess == VARIANT_FALSE) {

        if (FAILED((*ppDoc)->get_parseError(&cpXMLParseError))) {
            SDBERROR(_T("Could not retrieve XMLDOMParseError object"));
            goto eh;
        }

        if (FAILED(cpXMLParseError->get_line(&nErrorLine))) {
            SDBERROR(_T("Could not retrieve line number from XMLDOMParseError object"));
            goto eh;
        }

        if (FAILED(cpXMLParseError->get_linepos(&nErrorLinePos))) {
            SDBERROR(_T("Could not retrieve line position from XMLDOMParseError object"));
            goto eh;
        }

        if (FAILED(cpXMLParseError->get_srcText(&bsSrcText))) {
            SDBERROR(_T("Could not retrieve source text from XMLDOMParseError object"));
            goto eh;
        }

        if (FAILED(cpXMLParseError->get_reason(&bsErrorReason))) {
            SDBERROR(_T("Could not retrieve error reason from XMLDOMParseError object"));
            goto eh;
        }

        CString csError;
        csError.Format(_T("XML parsing error on line %d:\n\n%ls\n\n%ls\n"),
                         nErrorLine, bsErrorReason, bsSrcText);

        while (nErrorLinePos--) {
            csError += " ";
        }

        csError += _T("^----- Error\n\n");
        SDBERROR(csError);

        goto eh;
    }

    if (FAILED((*ppDoc)->QueryInterface(IID_IXMLDOMNode, (LPVOID*)ppRootNode))) {
        SDBERROR(_T("Could not retrieve XMLDOMNode object from XMLDOMDocument interface"));
        goto eh;
    }

    bSuccess = TRUE;

eh:
    if (pDoc) {
        pDoc->Release();
    }

    if (bsSrcText) {
        SysFreeString(bsSrcText);
    }

    if (bsErrorReason) {
        SysFreeString(bsErrorReason);
    }

    VariantClear(&vFileOrStream);

    return bSuccess;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   SaveXMLFile
//
//  Desc:   Saves an XML file.
//
BOOL SaveXMLFile(
    CString csFile,
    IXMLDOMNode* pNode)
{
    BOOL                bSuccess            = FALSE;

    DWORD               dwAttr;
    DWORD               dwErr;
    CString             csFormat;
    VARIANT             vFilename;
    HRESULT             hr;

    IXMLDOMDocumentPtr      cpDocument;

    VariantInit(&vFilename);

    //
    // Check file attributes
    //
    dwAttr = GetFileAttributes(csFile);
    if ((DWORD)-1 == dwAttr) {
        dwErr = GetLastError();
        if (ERROR_FILE_NOT_FOUND != dwErr) {
            csFormat.Format(_T("Error accessing XML file: %s (0x%lx)\n"), dwErr);
            SDBERROR(csFormat);
            goto eh;
        }

    } else if (dwAttr & FILE_ATTRIBUTE_READONLY) {
        csFormat.Format(_T("File \"%s\" appears to be read-only and cannot be updated\n"),
                     csFile);
        SDBERROR(csFormat);
        goto eh;
    }

    if (FAILED(pNode->get_ownerDocument(&cpDocument))) {
        SDBERROR(_T("Could not retrieve ownerDocument property of node."));
        goto eh;
    }

    vFilename.vt = VT_BSTR;
    vFilename.bstrVal = csFile.AllocSysString();
    hr = cpDocument->save(vFilename);

    if (FAILED(hr)) {
        csFormat.Format(_T("Could not update XML file: %s (0x%lx)\n"), csFile, (DWORD)hr);
        SDBERROR(csFormat);
        goto eh;
    }

    bSuccess = TRUE;

eh:

    VariantClear(&vFilename);

    return bSuccess;
}

CString ReplaceAmp(
    LPCTSTR lpszXML)
{
    LPTSTR  pchStart = (LPTSTR)lpszXML;
    LPTSTR  pchEnd;
    LPTSTR  pchHRef;
    LPTSTR  pchTag;
    TCHAR   ch;
    CString csXML = ""; // << this is what we return
    CString csHRef;

    do {
        pchHRef = _tcsstr(pchStart, _T("href"));

        if (NULL == pchHRef) {
            pchHRef = _tcsstr(pchStart, _T("HREF"));
        }

        if (NULL != pchHRef) {
            //
            // Find the closing bracket
            //
            pchEnd = _tcschr(pchHRef, _T('>'));

            if (NULL == pchEnd) {
                csXML += pchStart;
                pchHRef = NULL;
            } else {

                //
                // Now see where this thing starts
                //
                ch = *pchHRef;
                *pchHRef = _T('\0');

                //
                // Search back to the first '<'
                //
                pchTag = _tcsrchr(pchStart, _T('<'));
                *pchHRef = ch;

                if (NULL == pchTag) {
                    pchTag = pchStart;
                }

                //
                // Now we have < >
                //
                csHRef = CString(pchTag, (int)(pchEnd - pchTag + 1));

                csHRef.Replace(_T("%26"),   _T("&"));
                csHRef.Replace(_T("&amp;"), _T("&"));

                csXML += CString(pchStart, (int)(pchTag-pchStart)) + csHRef;
                pchStart = pchEnd + 1;
            }
        } else {
            csXML += pchStart;
        }


    } while (NULL != pchHRef);

    return csXML;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   GetInnerXML
//
//  Desc:   Returns the XML between the begin/end tag of pNode.
//
CString GetInnerXML(
    IXMLDOMNode* pNode)
{
    USES_CONVERSION;

    long             nIndex         = 0;
    long             nListLength    = 0;
    IXMLDOMNode*     pNodeChild     = NULL;
    IXMLDOMNodeList* pNodeList      = NULL;
    DOMNodeType      NodeType;
    CString          csNodeXML;
    CString          csHRef;
    CString          csFixedHRef;
    CString          strXML;

    strXML.Empty();

    if (FAILED(pNode->get_childNodes(&pNodeList)) || pNodeList == NULL) {
        SDBERROR(_T("get_childNodes failed while retrieving innerXML"));
        goto eh;
    }

    if (FAILED(pNodeList->get_length(&nListLength))) {
        SDBERROR(_T("get_length failed while retrieving innerXML"));
        goto eh;
    }

    while (nIndex < nListLength) {

        if (FAILED(pNodeList->get_item(nIndex, &pNodeChild))) {
            SDBERROR(_T("get_item failed while retrieving innerXML"));
            goto eh;
        }

        csNodeXML = GetXML(pNodeChild);

        strXML += csNodeXML;

        pNodeChild->Release();
        pNodeChild = NULL;
        ++nIndex;
    }

    ReplaceStringNoCase(strXML, _T(" xmlns=\"x-schema:schema.xml\""), _T(""));
    

eh:

    if (NULL != pNodeList) {
        pNodeList->Release();
    }

    if (NULL != pNodeChild) {
        pNodeChild->Release();
    }

    return strXML;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   GetAttribute
//
//  Desc:   Returns the text value of the attribute specified by lpszAttribute on node
//          pNode. If the the attribute doesn't exist, the function returns FALSE.
//
BOOL GetAttribute(
    LPCTSTR         lpszAttribute,
    IXMLDOMNodePtr  pNode,
    CString*        pcsValue,
    BOOL            bXML)
{
    USES_CONVERSION;

    BOOL                    bSuccess        = FALSE;
    BSTR                    bsQuery          = NULL;
    CString                 csQuery;
    IXMLDOMNodePtr          cpAttrNode;

    csQuery = _T("@");
    csQuery += lpszAttribute;
    bsQuery = csQuery.AllocSysString();

    //
    // g_csError will not be set in this function. It is up
    // to the caller to handle a FALSE return from this function
    // and report appropriately.
    //
    if (FAILED(pNode->selectSingleNode(bsQuery, &cpAttrNode))) {
        goto eh;
    }

    if (cpAttrNode == NULL) {
        goto eh;
    }

    if (bXML) {
        *pcsValue = GetXML(cpAttrNode);
    } else {
        *pcsValue = GetText(cpAttrNode);
    }

    bSuccess = TRUE;

eh:

    if (bsQuery != NULL) {
        SysFreeString(bsQuery);
    }

    return bSuccess;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   RemoveAttribute
//
//  Desc:   Removes the specified attribute from the element.
//
BOOL RemoveAttribute(
    CString         csName,
    IXMLDOMNodePtr  pNode)
{
    USES_CONVERSION;

    BOOL                    bSuccess        = FALSE;
    BSTR                    bsName          = NULL;
    IXMLDOMNamedNodeMap*    pNodeMap        = NULL;
    IXMLDOMNode*            pAttrNode       = NULL;

    //
    // g_csError will not be set in this function. It is up
    // to the caller to handle a FALSE return from this function
    // and report appropriately.
    //

    if (FAILED(pNode->get_attributes(&pNodeMap)) || pNodeMap == NULL) {
        goto eh;
    }

    bsName = csName.AllocSysString();

    if (FAILED(pNodeMap->removeNamedItem(bsName, &pAttrNode))) {
        goto eh;
    }

    bSuccess = TRUE;

eh:
    if (pNodeMap != NULL) {
        pNodeMap->Release();
    }

    if (pAttrNode != NULL) {
        pAttrNode->Release();
    }

    if (bsName != NULL) {
        SysFreeString(bsName);
    }

    return bSuccess;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   GetChild
//
//  Desc:   Returns the child node corresponding to the specified tag name.
//
BOOL GetChild(
    LPCTSTR         lpszTag,
    IXMLDOMNode*    pParentNode,
    IXMLDOMNode**   ppChildNode)
{
    BOOL                    bSuccess        = FALSE;
    XMLNodeList             XQL;

    if (!XQL.Query(pParentNode, lpszTag)) {
        goto eh;
    }

    if (XQL.GetSize() == 0) {
        goto eh;
    }

    if (XQL.GetSize() > 1) {
        goto eh;
    }

    if (!XQL.GetItem(0, ppChildNode)) {
        goto eh;
    }

    bSuccess = TRUE;

eh:
    return bSuccess;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   GetText
//
//  Desc:   Returns the value of the text property on node pNode.
//
CString GetText(
    IXMLDOMNode* pNode)
{
    CString csText;
    BSTR    bsText = NULL;
    HRESULT hr;

    hr = pNode->get_text(&bsText);
    if (SUCCEEDED(hr)) {
        csText = bsText;

        if (bsText) {
            SysFreeString(bsText);
        }
    }

    //
    // If get_text fails, then csText is blank.
    //

    return csText;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   GetText
//
//  Desc:   Returns the value of the node pNode, in string form
//

CString GetNodeValue(
    IXMLDOMNode* pNode)
{
    CString csVal;
    VARIANT var;

    VariantInit(&var);

    // BUGBUG: what if some of these calls fail!

    if (S_OK == pNode->get_nodeValue(&var)) {
        if (VT_BSTR == var.vt) {
            csVal = var.bstrVal;
            if (NULL != var.bstrVal) {
                SysFreeString(var.bstrVal);
            }
        }
    }
    return csVal;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   GetText
//
//  Desc:   Retrieves the value of the text property on node pNode.
//          excludes any comment text 
//          Returns FALSE in case of an error
//

BOOL GetNodeText(
    IXMLDOMNode* pNode,
    CString&     csNodeText
    )
{
    USES_CONVERSION;

    BOOL                bSuccess        = FALSE;
    long                nIndex          = 0;
    long                nListLength     = 0;
    IXMLDOMNode*        pNodeText       = NULL;
    IXMLDOMNodeList*    pNodeList       = NULL;
    DOMNodeType         NodeType;
    CString             csText;

    csNodeText.Empty();

    if (FAILED(pNode->get_childNodes(&pNodeList)) || pNodeList == NULL) {
        // BUGBUG: display some error
        goto eh;
    }

    if (FAILED(pNodeList->get_length(&nListLength))) {
        // BUGBUG: display some error
        goto eh;
    }

    while (nIndex < nListLength) {

        if (FAILED(pNodeList->get_item(nIndex, &pNodeText))) {
            // BUGBUG: display some error
            goto eh; // can't get the item
        }

        if (FAILED(pNodeText->get_nodeType(&NodeType))) {
            // BUGBUG: display some error
            goto eh; // can't get node type
        }

        if (NODE_TEXT == NodeType) {
            //
            // now this node is a body text
            //
            csText = GetNodeValue(pNodeText);
            csText.TrimLeft();
            csText.TrimRight();

            if (!csText.IsEmpty()) {
                csNodeText += CString(_T(' ')) + csText;
            }
        }
        pNodeText->Release();
        pNodeText = NULL;

        ++nIndex;
    }

    //
    // we have gathered all the text from this node
    //

    bSuccess = !csNodeText.IsEmpty();


eh:

    if (NULL != pNodeList) {
        pNodeList->Release();
    }

    if (NULL != pNodeText) {
        pNodeText->Release();
    }

    return bSuccess;
}



////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   GetNodeName
//
//  Desc:   Returns the nodeName value from the specified node.
//
CString GetNodeName(
    IXMLDOMNode* pNode)
{
    CString csName;
    BSTR    bsName = NULL;

    if (SUCCEEDED(pNode->get_nodeName(&bsName))) {
        csName = bsName;
    }

    if (bsName)
        SysFreeString(bsName);

    //
    // If get_nodeName fails, then csName is blank.
    //

    return csName;
}

CString GetParentNodeName(
    IXMLDOMNode* pNode)
{
    CString csName;
    IXMLDOMNodePtr cpParent;

    if (FAILED(pNode->get_parentNode(&cpParent))) {
        return CString();
    }

    return GetNodeName(cpParent);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   GetXML
//
//  Desc:   Returns the value of the xml property on node pNode.
//
CString GetXML(
    IXMLDOMNode* pNode)
{
    CString csXML;
    BSTR    bsXML = NULL;
    HRESULT hr;

    hr = pNode->get_xml(&bsXML);
    if (SUCCEEDED(hr)) {
        csXML = bsXML;

        if (bsXML) {
            SysFreeString(bsXML);
        }
    }

    //
    // If get_xml fails, then csXML is blank.
    //
    return csXML;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   MapStringToLangID
//
//  Desc:   Returns a LANGID corresponding to the passed in string.
//
LANGID MapStringToLangID(
    CString& csLang)
{
    typedef struct _LANG_MAP {
        LPTSTR      szLang;
        LANGID      LangID;
    } LANG_MAP, *PLANG_MAP;

    static LANG_MAP s_LangMap[] = {
        { _T("usa"),    MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US) },
        { _T(""),       NULL }
    };

    long    i;
    BOOL    bSuccess = FALSE;
    LANGID  LangID   = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

    if (csLang.Left(2) == _T("0x") ||
        csLang.Left(2) == _T("0X")) {
        _stscanf(csLang, _T("0x%x"), &LangID);
        return LangID;
    }

    i = 0;
    while (TRUE) {
        if (s_LangMap[i].szLang[0] == _T('\0')) {
            //
            // End of map.
            //
            break;
        }

        if (0 == _tcsicmp(csLang, s_LangMap[i].szLang)) {
            //
            // Found string.
            //
            LangID = s_LangMap[i].LangID;
            bSuccess = TRUE;
        }

        if (bSuccess) {
            break;
        }

        i++;
    }
    
    if (!bSuccess) {
        //
        // Couldn't map it. Give a useful error; list all recognized values.
        //
        CString csError;
        CString csFormat;

        i = 0;

        csError = _T("LANG attribute on DATABASE is not one of recognized values:\n\n");

        while (TRUE) {
            if (s_LangMap[i].szLang[0] == _T('\0')) {
                break;
            }
            csFormat.Format(_T("    %s\n"), s_LangMap[i].szLang);
            csError += csFormat;

            i++;
        }

        SDBERROR(csError);
    }

    return LangID;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   AddAttribute
//
//  Desc:   Adds an attribute to the specified XML node.
//
BOOL AddAttribute(
    IXMLDOMNode*    pNode,
    CString         csAttribute,
    CString         csValue)
{
    USES_CONVERSION;

    BOOL                    bSuccess    = FALSE;
    BSTR                    bsAttribute = NULL;
    VARIANT                 vType;
    VARIANT                 vValue;
    IXMLDOMDocumentPtr      cpDocument;
    IXMLDOMNamedNodeMapPtr  cpNodeMap;
    IXMLDOMNodePtr          cpAttrNode;
    IXMLDOMNodePtr          cpNamedAttr;

    VariantInit(&vType);
    VariantInit(&vValue);

    vValue.bstrVal = csValue.AllocSysString();

    if (vValue.bstrVal == NULL) {
        SDBERROR(_T("CString::AllocSysString failed"));
        goto eh;
    }

    vValue.vt = VT_BSTR;

    vType.vt = VT_I4;
    vType.lVal = NODE_ATTRIBUTE;

    bsAttribute = csAttribute.AllocSysString();

    if (bsAttribute == NULL) {
        SDBERROR(_T("CString::AllocSysString failed"));
        goto eh;
    }

    if (FAILED(pNode->get_ownerDocument(&cpDocument))) {
        SDBERROR(_T("createNode failed while adding attribute"));
        goto eh;
    }

    if (FAILED(cpDocument->createNode(vType, bsAttribute, NULL, &cpAttrNode))) {
        SDBERROR(_T("createNode failed while adding attribute"));
        goto eh;
    }

    if (FAILED(cpAttrNode->put_nodeValue(vValue))) {
        SDBERROR(_T("put_nodeValue failed while adding attribute"));
        goto eh;
    }

    if (FAILED(pNode->get_attributes(&cpNodeMap))) {
        SDBERROR(_T("get_attributes failed while adding adding attribute"));
        goto eh;
    }

    if (FAILED(cpNodeMap->setNamedItem(cpAttrNode, &cpNamedAttr))) {
        SDBERROR(_T("setNamedItem failed while adding adding attribute"));
        goto eh;
    }

    bSuccess = TRUE;

eh:
    VariantClear(&vType);
    VariantClear(&vValue);

    if (bsAttribute != NULL) {
        SysFreeString(bsAttribute);
    }

    return bSuccess;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   GenerateIDAttribute
//
//  Desc:   Adds an ID attribute to the specified XML node. The ID is in the
//          traditional Windows GUID format.
//
BOOL GenerateIDAttribute(
    IXMLDOMNode*    pNode,
    CString*        pcsGuid,
    GUID*           pGuid)
{
    BOOL                    bSuccess   = FALSE;
    BSTR                    bsGUID     = NULL;
    GUID                    id;

    //
    // Generate guid
    //
    if (FAILED(CoCreateGuid(&id))) {
        SDBERROR(_T("CoCreateGuid failed"));
        goto eh;
    }

    if (NULL != pGuid) {
        *pGuid = id;
    }

    bsGUID = SysAllocStringLen(NULL, 64);

    if (bsGUID == NULL) {
        SDBERROR(_T("SysAllocStringLen failed"));
        goto eh;
    }

    StringFromGUID2(id, bsGUID, 64);

    if (!AddAttribute( pNode, _T("ID"), CString(bsGUID) )) {
        SDBERROR_PROPOGATE();
        goto eh;
    }

    *pcsGuid = bsGUID;

    bSuccess = TRUE;

eh:
    if (bsGUID) {
        SysFreeString(bsGUID);
    }

    return bSuccess;
}

BOOL ReplaceXMLNode(IXMLDOMNode* pNode, IXMLDOMDocument* pDoc, BSTR bsText)
{
    BOOL bSuccess = FALSE;
    IXMLDOMNodePtr cpNewTextNode;
    IXMLDOMNodePtr cpParentNode;
    IXMLDOMNodePtr cpOldNode;
    VARIANT vType;

    VariantInit(&vType);

    vType.vt = VT_I4;
    vType.lVal = NODE_TEXT;

    if (FAILED(pDoc->createNode(vType, NULL, NULL, &cpNewTextNode))) {
        SDBERROR(_T("createNode failed while adding attribute"));
        goto eh;
    }
    
    if (FAILED(cpNewTextNode->put_text(bsText))) {
        SDBERROR(_T("Could not set text property of object."));
        goto eh;
    }

    if (FAILED(pNode->get_parentNode(&cpParentNode))) {
        SDBERROR(_T("Could not retrieve parent node of object."));
        goto eh;
    }

    if (FAILED(cpParentNode->replaceChild(cpNewTextNode, pNode, &cpOldNode))) {
        SDBERROR(_T("Could not replace node with text node."));
        goto eh;
    }

    bSuccess = TRUE;

eh:
    VariantClear(&vType);

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimengines\engiat\notifycallback.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    NotifyCallback.h

Abstract:

    This is the header file for NotifyCallback.c which implements
    the trampoline at the EXE's entry point.

Author:

    clupu created 19-February-2001

Revision History:

--*/

#ifndef _SHIMENG_NOTIFYCALLBACK_H_
#define _SHIMENG_NOTIFYCALLBACK_H_

void
RestoreOriginalCode(
    void
    );

BOOL
InjectNotificationCode(
    PVOID entryPoint
    );


#endif // _SHIMENG_NOTIFYCALLBACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimengines\engiat\shimeng.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    ShimEng.h

Abstract:

    This is the header file for ShimEng.c which implements
    the shim hooking using IAT thunking.

Author:

    clupu created 11-July-2000

Revision History:

--*/

#ifndef _SHIMENG_IAT_H_
#define _SHIMENG_IAT_H_


typedef enum 
{    
    dlNone     = 0,
    dlPrint,
    dlError,
    dlWarning,
    dlInfo

} DEBUGLEVEL;


#define DEBUG_SPEW

extern BOOL g_bDbgPrintEnabled;

#ifdef DEBUG_SPEW
    void __cdecl DebugPrintfEx(DEBUGLEVEL dwDetail, LPSTR pszFmt, ...);
    
    #define DPF if (g_bDbgPrintEnabled) DebugPrintfEx
#else
    #define DPF
#endif // DEBUG_SPEW


typedef PVOID (*PFNRTLALLOCATEHEAP)(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

typedef BOOLEAN (*PFNRTLFREEHEAP)(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

void
NotifyShimDlls(
    void
    );

#endif // _SHIMENG_IAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimengines\engiat\shimeng.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    ShimEng.c

Abstract:

    This module implements the shim hooking using IAT thunking. The file
    is shared between the Windows2000 and Whistler implementations.

Author:

    clupu created 11 July 2000

Revision History:

    clupu updated 12 Dec  2000      - one file for both Win2k and Whistler
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <string.h>

#include <windef.h>
#include <winbase.h>
#include <stdio.h>
#include <apcompat.h>
#include "shimdb.h"
#include "ShimEng.h"

#ifdef SE_WIN2K
#include "NotifyCallback.h"
#endif // SE_WIN2K

#ifndef SE_WIN2K
extern BOOL
LdrInitShimEngineDynamic(
    PVOID pShimengModule
    );
#endif


BOOL       g_bDbgPrintEnabled;
DEBUGLEVEL g_DebugLevel;

//
// The number of SHIMs that can be added dynamically by calling SE_DynamicShim
//
#define MAX_DYNAMIC_SHIMS   128

//
// Flags used in HOOKAPI.dwFlags
//
#define HAF_CHAINED         0x00000004
#define HAF_BOTTOM_OF_CHAIN 0x00000008

//
// Flags used in SHIMINFO.dwFlags
//
#define SIF_RESOLVED        0x00000001

//
// Pipe name for sending messages
//
#define PIPE_NAME           L"\\Device\\NamedPipe\\ShimViewer"

typedef struct tagINEXMOD {
    char*              pszModule;
    struct tagINEXMOD* pNext;
} INEXMOD, *PINEXMOD;

typedef enum tagINEX_MODE {
    INEX_UNINITIALIZED = 0,
    EXCLUDE_SYSTEM32,
    EXCLUDE_ALL,
    INCLUDE_ALL
} INEX_MODE, *PINEX_MODE;

#define MAX_SHIM_NAME_LEN 63

typedef struct tagSHIMINFO {
    DWORD       dwHookedAPIs;       // the number of APIs hooked by this shim DLL
    PVOID       pDllBase;           // the base address for this shim DLL
    DWORD       dwFlags;            // internal flags
    PINEXMOD    pFirstInclude;      // local inclusion/exclusion list
    PINEXMOD    pFirstExclude;      // local inclusion/exclusion list
    INEX_MODE   eInExMode;          // what inclusion mode are we in?

    PLDR_DATA_TABLE_ENTRY pLdrEntry;            // pointer to the loader entry for this
                                                // shim DLL.
    WCHAR       wszName[MAX_SHIM_NAME_LEN + 1]; // name of shim
} SHIMINFO, *PSHIMINFO;

typedef struct tagHOOKEDMODULE {
    PVOID   pDllBase;               // the base address of the loaded module
    ULONG   ulSizeOfImage;          // the size of the DLL image
    char    szModuleName[128];      // the name of the loaded module
    BOOL    bInSystem32;            // tru if the DLL hooked is in system32

} HOOKEDMODULE, *PHOOKEDMODULE;

//
// The prototypes of the internal stubs.
//
typedef PVOID     (*PFNGETPROCADDRESS)(HMODULE hMod, char* pszProc);
typedef HINSTANCE (*PFNLOADLIBRARYA)(LPCSTR lpLibFileName);
typedef HINSTANCE (*PFNLOADLIBRARYW)(LPCWSTR lpLibFileName);
typedef HINSTANCE (*PFNLOADLIBRARYEXA)(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
typedef HINSTANCE (*PFNLOADLIBRARYEXW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
typedef BOOL      (*PFNFREELIBRARY)(HMODULE hLibModule);


BOOL
SeiSendDataToPipe(
    void
    );

#ifdef SE_WIN2K

BOOL PatchNewModules(
    BOOL bDynamic
    );

#else

BOOL
SeiDisplayAppHelp(
    HSDB                hSDB,
    PSDBQUERYRESULT     pSdbQuery
    );

#endif // SE_WIN2K


//
// Global function hooks the shim uses to keep from recursing itself
//
PFNRTLALLOCATEHEAP g_pfnRtlAllocateHeap;
PFNRTLFREEHEAP     g_pfnRtlFreeHeap;

// Shim's private heap
PVOID           g_pShimHeap;

// The global inclusion list.
PINEXMOD        g_pGlobalInclusionList = NULL;

// Array with all the HOOKAPI list for all the shim DLLs
PHOOKAPI*       g_pHookArray = NULL;

// this variable will only be valid on dynamic cases
HMODULE         g_hModule = NULL;


// Internal HOOKAPI for the stubs that the shim engine provides

#define IHA_GetProcAddress      0

#ifdef SE_WIN2K
#define IHA_LoadLibraryA        1
#define IHA_LoadLibraryW        2
#define IHA_LoadLibraryExA      3
#define IHA_LoadLibraryExW      4
#define IHA_FreeLibrary         5
#define IHA_COUNT               6
#else
#define IHA_COUNT               1
#endif // SE_WIN2K

HOOKAPI         g_IntHookAPI[IHA_COUNT];

// BUGBUG: comment here
HOOKAPIEX       g_IntHookEx[IHA_COUNT];

// Extra info for all the shim DLLs
PSHIMINFO       g_pShimInfo;

// The number of all shims applied to this process
DWORD           g_dwShimsCount = 0;

// The maximum number of shims that can be applied.
DWORD           g_dwMaxShimsCount = 0;

#define SHIM_MAX_HOOKED_MODULES 512

// The array of hooked modules
HOOKEDMODULE    g_hHookedModules[SHIM_MAX_HOOKED_MODULES];

// The number of modules hooked
DWORD           g_dwHookedModuleCount;

// True if the statically linked modules have been hooked
BOOL            g_bShimInitialized = FALSE;

// Don will comment here
BOOL            g_bShimDuringInit = FALSE;

#define SHIM_MAX_PATCH_COUNT    64

// The array of in memory patches
PBYTE           g_pMemoryPatches[SHIM_MAX_PATCH_COUNT];

// The number of in memory patches
DWORD           g_dwMemoryPatchCount;

// This shim engine's module handle
PVOID           g_pShimEngModHandle;

// The system32 directory
WCHAR           g_szSystem32[MAX_PATH] = L"";

// The length of the System32 directory string;
DWORD           g_dwSystem32StrLen = 0;

// The SxS directory
WCHAR           g_szSxS[MAX_PATH] = L"";

// The length of the SxS directory string;
DWORD           g_dwSxSStrLen = 0;

// The windows directory
WCHAR           g_szWindir[MAX_PATH] = L"";

// The exe name for sending data to our named pipe
WCHAR           g_szExeName[MAX_PATH] = L"";

// The length of the windows directory string;
DWORD           g_dwWindirStrLen = 0;

// Cmd.exe full path
WCHAR           g_szCmdExePath[MAX_PATH];

// Are we using an exe entry to get shims from?
BOOL            g_bUsingExe;

// Are we using a layer entry to get shims from?
BOOL            g_bUsingLayer;

PLDR_DATA_TABLE_ENTRY g_pShimEngLdrEntry;

// This boolean tells if some global vars have been initialized.
BOOL            g_bInitGlobals;

// This boolean tells if we shimmed the internal hooks.
BOOL            g_bInternalHooksUsed;

// Pipe data
WCHAR           g_szPipeData[1024];


#ifndef SE_WIN2K

// The name of the shim DLL that the engine is just about to load.
WCHAR           g_wszShimDllInLoading[128];

PVOID           g_hApphelpDllHelper;

UNICODE_STRING  Kernel32String = RTL_CONSTANT_STRING(L"kernel32.dll");
UNICODE_STRING  NtdllString = RTL_CONSTANT_STRING(L"ntdll.dll");
UNICODE_STRING  VerifierdllString = RTL_CONSTANT_STRING(L"verifier.dll");

// This tells if the image shimmed is a COM+ image.
BOOL            g_bComPlusImage;

#endif // SE_WIN2K


#ifdef DEBUG_SPEW

void
__cdecl
DebugPrintfEx(
    DEBUGLEVEL dwDetail,
    LPSTR      pszFmt,
    ...
    )
/*++
    Return: void

    Desc:   This function prints debug spew in the debugger.
--*/
{
    char    szT[1024];
    va_list arglist;
    int     len;

    va_start(arglist, pszFmt);
    _vsnprintf(szT, 1023, pszFmt, arglist);
    szT[1022] = 0;
    va_end(arglist);

    //
    // Make sure we have a '\n' at the end of the string
    //
    len = strlen(szT);

    if (szT[len - 1] != '\n')  {
        strcpy(szT + len, "\n");
    }

    if (dwDetail <= g_DebugLevel) {
        switch (dwDetail) {
        case dlPrint:
            DbgPrint("[MSG ] ");
            break;

        case dlError:
            DbgPrint("[FAIL] ");
            break;

        case dlWarning:
            DbgPrint("[WARN] ");
            break;

        case dlInfo:
            DbgPrint("[INFO] ");
            break;
        }

        DbgPrint("%s", szT);
    }
}


void
SeiInitDebugSupport(
    void
    )
/*++
    Return: void

    Desc:   This function initializes g_bDbgPrintEnabled based on an env variable.
--*/
{
    NTSTATUS            status;
    UNICODE_STRING      EnvName;
    UNICODE_STRING      EnvValue;
    WCHAR               wszEnvValue[128];

    RtlInitUnicodeString(&EnvName, L"SHIMENG_DEBUG_LEVEL");

    EnvValue.Buffer = wszEnvValue;
    EnvValue.Length = 0;
    EnvValue.MaximumLength = sizeof(wszEnvValue);

    status = RtlQueryEnvironmentVariable_U(NULL, &EnvName, &EnvValue);

    if (NT_SUCCESS(status)) {

        WCHAR c = EnvValue.Buffer[0];

        g_bDbgPrintEnabled = TRUE;

        switch (c) {
        case L'0':
            g_DebugLevel = dlNone;
            g_bDbgPrintEnabled = FALSE;
            break;

        case L'1':
            g_DebugLevel = dlPrint;
            break;

        case L'2':
            g_DebugLevel = dlError;
            break;

        case L'3':
            g_DebugLevel = dlWarning;
            break;

        case L'4':
        default:
            g_DebugLevel = dlInfo;
            break;
        }
    }
}
#endif // DEBUG_SPEW


PHOOKAPI
SeiConstructChain(
    IN  PVOID  pfnOld,          // Original API function pointer to resolve.
    OUT DWORD* pdwDllIndex      // Will receive the index of the shim DLL
                                // that provides the returning PHOOKAPI.
    )
/*++
    Return: Top-of-chain PHOOKAPI structure.

    Desc:   Scans HOOKAPI arrays for pfnOld and either constructs the
            chain or returns the top-of-chain PHOOKAPI if the chain
            already exists.
--*/
{
    LONG     i; // use LONG because we decrement this and compare it for positive
    DWORD    j;
    PHOOKAPI pTopHookAPI    = NULL;
    PHOOKAPI pBottomHookAPI = NULL;

    *pdwDllIndex = 0;

    //
    // Scan all HOOKAPI entries for corresponding function pointer.
    //
    for (i = (LONG)g_dwShimsCount - 1; i >= 0; i--) {
        
        for (j = 0; j < g_pShimInfo[i].dwHookedAPIs; j++) {

            if (g_pHookArray[i][j].pfnOld == pfnOld) {

                if (pTopHookAPI != NULL) {

                    //
                    // The chain has already begun, so tack this one on
                    // to the end.
                    //
                    pBottomHookAPI->pfnOld = g_pHookArray[i][j].pfnNew;
                    if (pBottomHookAPI->pHookEx) {
                        pBottomHookAPI->pHookEx->pNext = &(g_pHookArray[i][j]);
                    }

                    pBottomHookAPI = &(g_pHookArray[i][j]);

                    if (pBottomHookAPI->pHookEx) {
                        pBottomHookAPI->pHookEx->pTopOfChain = pTopHookAPI;
                    }

                    pBottomHookAPI->dwFlags |= HAF_CHAINED;

                    DPF(dlInfo, " 0x%p ->", pBottomHookAPI->pfnNew);

                } else {
                    //
                    // This is the top of the chain. The inclusion/exclusion list
                    // from the DLL at the top of the chain is used to determine if
                    // an import entry in a particular DLL is hooked or not.
                    // See SeiHookImports for use of pdwIndex.
                    //
                    *pdwDllIndex = i;

                    if (g_pHookArray[i][j].pHookEx && g_pHookArray[i][j].pHookEx->pTopOfChain) {

                        //
                        // Chain has already been constructed.
                        //
                        return g_pHookArray[i][j].pHookEx->pTopOfChain;
                    }

                    //
                    // Not hooked yet. Set to top of chain.
                    //
                    pTopHookAPI = &(g_pHookArray[i][j]);

                    if (pTopHookAPI->pHookEx) {
                        pTopHookAPI->pHookEx->pTopOfChain = pTopHookAPI;
                    }

                    pTopHookAPI->dwFlags |= HAF_CHAINED;

                    pBottomHookAPI = pTopHookAPI;

                    if ((ULONG_PTR)pTopHookAPI->pszFunctionName < 0x0000FFFF) {
                        DPF(dlInfo, "[SeiConstructChain] %s!#%d 0x%p ->",
                            pTopHookAPI->pszModule,
                            pTopHookAPI->pszFunctionName,
                            pTopHookAPI->pfnNew);
                    } else {
                        DPF(dlInfo, "[SeiConstructChain] %s!%-20s 0x%p ->",
                            pTopHookAPI->pszModule,
                            pTopHookAPI->pszFunctionName,
                            pTopHookAPI->pfnNew);
                    }
                }
            }
        }
    }

    if (pBottomHookAPI != NULL) {
        pBottomHookAPI->dwFlags |= HAF_BOTTOM_OF_CHAIN;

        DPF(dlInfo, " 0x%p\n", pBottomHookAPI->pfnOld);
    }

    return pTopHookAPI;
}

PVOID
SeiGetPatchAddress(
    IN  PRELATIVE_MODULE_ADDRESS pRelAddress    // A RELATIVE_MODULE_ADDRESS structure
                                                // that defines the memory location as
                                                // an offset from a loaded module.
    )
/*++
    Return: The actual memory address of the specified module + offset.

    Desc:   Resolves a RELATIVE_MODULE_ADDRESS structure into an actual memory address.
--*/
{
    WCHAR           wszModule[MAX_PATH];
    PVOID           ModuleHandle = NULL;
    UNICODE_STRING  UnicodeString;
    NTSTATUS        status;
    PPEB            Peb = NtCurrentPeb();

    if (pRelAddress->moduleName[0] != 0) {

        //
        // Copy the module name from the patch since it will typically be misaligned.
        //
        wcscpy(wszModule, pRelAddress->moduleName);

        RtlInitUnicodeString(&UnicodeString, wszModule);

        //
        // Make sure the module is loaded before calculating address ranges.
        //
        status = LdrGetDllHandle(NULL, NULL, &UnicodeString, &ModuleHandle);

        if (!NT_SUCCESS(status)) {
            DPF(dlWarning,
                "[SeiGetPatchAddress] Dll \"%S\" not yet loaded for memory patching.\n",
                wszModule);
            return NULL;
        }

        //
        // We're done, return the address
        //
        return (PVOID)((ULONG_PTR)ModuleHandle + (ULONG_PTR)pRelAddress->address);
    }

    //
    // This patch is for the main EXE.
    //
    return (PVOID)((ULONG_PTR)Peb->ImageBaseAddress + (ULONG_PTR)pRelAddress->address);
}

int
SeiApplyPatch(
    IN  PBYTE pPatch            // A patch code blob.
    )
/*++
    Return: 1 for success, 0 for failure.

    Desc:   Attempts to execute all commands in a patch code blob. If DLLs are not loaded,
            this function will return 0.
--*/
{
    PPATCHMATCHDATA pMatchData;
    PPATCHWRITEDATA pWriteData;
    PPATCHOP        pPatchOP;
    NTSTATUS        status;
    PVOID           pAddress;
    PVOID           pProtectFuncAddress = NULL;
    SIZE_T          dwProtectSize = 0;
    DWORD           dwOldFlags = 0;

    //
    // Grab the opcode and see what we have to do.
    //
    while (TRUE) {
        pPatchOP = (PPATCHOP)pPatch;

        switch (pPatchOP->dwOpcode) {
        case PEND:
            return 1;

        case PWD:
            //
            // This is a patch write data primitive - write the data.
            //
            pWriteData = (PPATCHWRITEDATA)pPatchOP->data;

            //
            // Grab the physical address to do this operation.
            //
            pAddress = SeiGetPatchAddress(&(pWriteData->rva));

            if (pAddress == NULL) {
                DPF(dlWarning, "[SeiApplyPatch] DLL not loaded for memory patching.\n");
                return 0;
            }

            //
            // Fixup the page attributes.
            //
            dwProtectSize = pWriteData->dwSizeData;
            pProtectFuncAddress = pAddress;
            status = NtProtectVirtualMemory(NtCurrentProcess(),
                                            (PVOID)&pProtectFuncAddress,
                                            &dwProtectSize,
                                            PAGE_READWRITE,
                                            &dwOldFlags);
            if (!NT_SUCCESS(status)) {
                DPF(dlError, "[SeiApplyPatch] NtProtectVirtualMemory failed 0x%X.\n",
                    status);
                return 0;
            }

            //
            // Copy the patch bytes.
            //
            RtlCopyMemory((PVOID)pAddress, (PVOID)pWriteData->data, pWriteData->dwSizeData);

            //
            // Restore the page protection.
            //
            dwProtectSize = pWriteData->dwSizeData;
            pProtectFuncAddress = pAddress;
            status = NtProtectVirtualMemory(NtCurrentProcess(),
                                            (PVOID)&pProtectFuncAddress,
                                            &dwProtectSize,
                                            dwOldFlags,
                                            &dwOldFlags);
            if (!NT_SUCCESS(status)) {
                DPF(dlError, "[SeiApplyPatch] NtProtectVirtualMemory failed 0x%X.\n",
                    status);
                return 0;
            }

            status = NtFlushInstructionCache(NtCurrentProcess(),
                                             pProtectFuncAddress,
                                             dwProtectSize);

            if (!NT_SUCCESS(status)) {
                DPF(dlError,
                    "[SeiApplyPatch] NtFlushInstructionCache failed w/ status 0x%X.\n",
                    status);
            }

            break;

        case PMAT:
            //
            // This is a patch match data at offset primitive.
            //
            pMatchData = (PPATCHMATCHDATA)pPatchOP->data;

            //
            // Grab the physical address to do this operation
            //
            pAddress = SeiGetPatchAddress(&(pMatchData->rva));
            if (pAddress == NULL) {
                DPF(dlWarning, "[SeiApplyPatch] SeiGetPatchAddress failed.\n");
                return 0;
            }

            //
            // Make sure there is a match with what we expect to be there.
            //
            if (!RtlEqualMemory(pMatchData->data, (PBYTE)pAddress, pMatchData->dwSizeData)) {
                DPF(dlError, "[SeiApplyPatch] Failure matching on patch data.\n");
                return 0;
            }

            break;

        default:
            //
            // If this happens we got an unexpected operation and we have to fail.
            //
            DPF(dlError, "[SeiApplyPatch] Unknown patch opcode 0x%X.\n",
                pPatchOP->dwOpcode);
            ASSERT(0);

            return 0;
        }

        //
        // Next opcode.
        //
        pPatch = (PBYTE)(pPatchOP->dwNextOpcode + pPatch);
    }

    return 1;
}

void
SeiAttemptPatches(
    void
    )
/*++
    Return: void.

    Desc:   Attempts all patches in the global array.
--*/
{
    DWORD  i, dwSucceeded = 0;

    for (i = 0; i < g_dwMemoryPatchCount; i++) {
        dwSucceeded += SeiApplyPatch(g_pMemoryPatches[i]);
    }

    if (g_dwMemoryPatchCount > 0) {
        DPF(dlInfo, "[SeiAttemptPatches] Applied %d of %d patches.\n",
            dwSucceeded,
            g_dwMemoryPatchCount);
        
        swprintf(g_szPipeData, L"%s - Applied %d of %d patches",
                 g_szExeName,
                 dwSucceeded,
                 g_dwMemoryPatchCount);
        
        SeiSendDataToPipe();
    }
}

void
SeiResolveAPIs(
    void
    )
/*++
    Return: void

    Desc:   Loops through the array of HOOKAPI and sets pfnOld if it wasn't
            already set.
--*/
{
    DWORD             i, j;
    ANSI_STRING       AnsiString;
    UNICODE_STRING    UnicodeString;
    WCHAR             wszBuffer[MAX_PATH];
    STRING            ProcedureNameString;
    PVOID             pfnOld;
    PVOID             ModuleHandle = NULL;
    NTSTATUS          status;
    BOOL              bAllApisResolved;
    char*             pszFunctionName;

    UnicodeString.Buffer = wszBuffer;

    for (i = 0; i < g_dwShimsCount; i++) {

        //
        // See if we've already resolved all the APIs this shim DLL wanted to hook.
        //
        if (g_pShimInfo[i].dwFlags & SIF_RESOLVED) {
            continue;
        }

        bAllApisResolved = TRUE;

        for (j = 0; j < g_pShimInfo[i].dwHookedAPIs; j++) {
            //
            // Ignore resolved APIs.
            //
            if (g_pHookArray[i][j].pfnOld != NULL) {
                continue;
            }

            //
            // Don't try to load unspecified modules.
            //
            if (g_pHookArray[i][j].pszModule == NULL) {
                continue;
            }

            //
            // Is this DLL mapped in the address space?
            //
            RtlInitAnsiString(&AnsiString, g_pHookArray[i][j].pszModule);

            UnicodeString.MaximumLength = sizeof(wszBuffer);

            if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeString,
                                                         &AnsiString,
                                                         FALSE))){

                DPF(dlError,
                    "[SeiResolveAPIs] Failed to convert string \"%s\" to UNICODE.\n",
                    g_pHookArray[i][j].pszModule);
                continue;
            }

            status = LdrGetDllHandle(NULL,
                                     NULL,
                                     &UnicodeString,
                                     &ModuleHandle);

            if (!NT_SUCCESS(status)) {
                bAllApisResolved = FALSE;
                continue;
            }

            //
            // Get the original entry point for this hook.
            //
            pszFunctionName = g_pHookArray[i][j].pszFunctionName;

            if ((ULONG_PTR)pszFunctionName < 0x0000FFFF) {

                status = LdrGetProcedureAddress(ModuleHandle,
                                                NULL,
                                                (ULONG)(ULONG_PTR)pszFunctionName,
                                                &pfnOld);
            } else {
                RtlInitString(&ProcedureNameString, pszFunctionName);

                status = LdrGetProcedureAddress(ModuleHandle,
                                                &ProcedureNameString,
                                                0,
                                                &pfnOld);
            }

            if (!NT_SUCCESS(status) || pfnOld == NULL) {
                bAllApisResolved = FALSE;

                if ((ULONG_PTR)pszFunctionName < 0x0000FFFF) {
                    DPF(dlError, "[SeiResolveAPIs] There is no \"%s!#%d\" !\n",
                        g_pHookArray[i][j].pszModule,
                        pszFunctionName);
                } else {
                    DPF(dlError, "[SeiResolveAPIs] There is no \"%s!%s\" !\n",
                        g_pHookArray[i][j].pszModule,
                        pszFunctionName);
                }

                continue;
            }

            g_pHookArray[i][j].pfnOld = pfnOld;

            if ((ULONG_PTR)pszFunctionName < 0x0000FFFF) {
                DPF(dlInfo, "[SeiResolveAPIs] Resolved \"%s!#%d\" to 0x%p\n",
                    g_pHookArray[i][j].pszModule,
                    pszFunctionName,
                    pfnOld);
            } else {
                DPF(dlInfo, "[SeiResolveAPIs] Resolved \"%s!%s\" to 0x%p\n",
                    g_pHookArray[i][j].pszModule,
                    pszFunctionName,
                    pfnOld);
            }
        }

        //
        // See if all the APIs were resolved for this shim DLL.
        //
        if (bAllApisResolved) {
            g_pShimInfo[i].dwFlags |= SIF_RESOLVED;
        }
    }
}

BOOL
SeiIsExcluded(
    IN  LPCSTR   pszModule,     // The module to test for exclusion.
    IN  PHOOKAPI pTopHookAPI,   // The HOOKAPI for which we test for exclusion.
    IN  BOOL     bInSystem32    // Whether the module is located in the System32 directory.
    )
/*++
    Return: TRUE if the requested module shouldn't be patched.

    Desc:   Checks the inclusion/exclusion list of the shim DLL specified by
            dwCounter and then checks the global exclusion list also.
--*/
{
    BOOL     bExclude = TRUE;
    BOOL     bShimWantsToExclude = FALSE; // was there a shim that wanted to exclude?
    PHOOKAPI pHook = pTopHookAPI;

    //
    // The current process is to only exclude a chain if every shim in the chain wants to
    // exclude. If one shim needs to be included, the whole chain is included.
    //
    while (pHook && pHook->pHookEx) {

        DWORD dwCounter;

        dwCounter = pHook->pHookEx->dwShimID;

        switch (g_pShimInfo[dwCounter].eInExMode) {
        case INCLUDE_ALL:
        {
            //
            // We include everything except what's in the exclude list.
            //
            PINEXMOD pExcludeMod;

            pExcludeMod = g_pShimInfo[dwCounter].pFirstExclude;

            while (pExcludeMod != NULL) {
                if (_stricmp(pExcludeMod->pszModule, pszModule) == 0) {
                    if ((ULONG_PTR)pTopHookAPI->pszFunctionName < 0x0000FFFF) {
                        DPF(dlInfo,
                            "[SeiIsExcluded] Module \"%s\" excluded for shim %S, API \"%s!#%d\", because it is in the exclude list (MODE: IA).\n",
                            pszModule,
                            g_pShimInfo[dwCounter].wszName,
                            pTopHookAPI->pszModule,
                            pTopHookAPI->pszFunctionName);
                    } else {
                        DPF(dlInfo,
                            "[SeiIsExcluded] Module \"%s\" excluded for shim %S, API \"%s!%s\", because it is in the exclude list (MODE: IA).\n",
                            pszModule,
                            g_pShimInfo[dwCounter].wszName,
                            pTopHookAPI->pszModule,
                            pTopHookAPI->pszFunctionName);
                    }

                    //
                    // this wants to be excluded, so we go to the next
                    // shim, and see if it wants to be included
                    //
                    bShimWantsToExclude = TRUE;
                    goto nextShim;
                }
                pExcludeMod = pExcludeMod->pNext;
            }

            //
            // we should include this shim, and therefore, the whole chain
            //
            bExclude = FALSE;
            goto out;
            break;
        }

        case EXCLUDE_SYSTEM32:
        {
            //
            // In this case, we first check the include list,
            // then exclude it if it's in System32, then exclude it if
            // it's in the exclude list.
            //

            PINEXMOD pIncludeMod;
            PINEXMOD pExcludeMod;

            pIncludeMod = g_pShimInfo[dwCounter].pFirstInclude;
            pExcludeMod = g_pShimInfo[dwCounter].pFirstExclude;

            //
            // First, check the include list.
            //
            while (pIncludeMod != NULL) {
                if (_stricmp(pIncludeMod->pszModule, pszModule) == 0) {

                    //
                    // we should include this shim, and therefore, the whole chain
                    //
                    bExclude = FALSE;
                    goto out;
                }
                pIncludeMod = pIncludeMod->pNext;
            }

            //
            // it wasn't in the include list, so is it in System32?
            //
            if (bInSystem32) {
                if ((ULONG_PTR)pTopHookAPI->pszFunctionName < 0x0000FFFF) {
                    DPF(dlInfo,
                        "[SeiIsExcluded] module \"%s\" excluded for shim %S, API \"%s!#%d\", because it is in System32.\n",
                        pszModule,
                        g_pShimInfo[dwCounter].wszName,
                        pTopHookAPI->pszModule,
                        pTopHookAPI->pszFunctionName);
                } else {
                    DPF(dlInfo,
                        "[SeiIsExcluded] module \"%s\" excluded for shim %S, API \"%s!%s\", because it is in System32.\n",
                        pszModule,
                        g_pShimInfo[dwCounter].wszName,
                        pTopHookAPI->pszModule,
                        pTopHookAPI->pszFunctionName);
                }

                //
                // this wants to be excluded, so we go to the next
                // shim, and see if it wants to be included
                //
                bShimWantsToExclude = TRUE;
                goto nextShim;
            }

            //
            // it wasn't in System32, so is it in the exclude list?
            //
            while (pExcludeMod != NULL) {
                if (_stricmp(pExcludeMod->pszModule, pszModule) == 0) {
                    if ((ULONG_PTR)pTopHookAPI->pszFunctionName < 0x0000FFFF) {
                        DPF(dlInfo,
                            "[SeiIsExcluded] module \"%s\" excluded for shim %S, API \"%s!#%d\", because it is in the exclude list (MODE: ES).\n",
                            pszModule,
                            g_pShimInfo[dwCounter].wszName,
                            pTopHookAPI->pszModule,
                            pTopHookAPI->pszFunctionName);
                    } else {
                        DPF(dlInfo,
                            "[SeiIsExcluded] module \"%s\" excluded for shim %S, API \"%s!%s\", because it is in the exclude list (MODE: ES).\n",
                            pszModule,
                            g_pShimInfo[dwCounter].wszName,
                            pTopHookAPI->pszModule,
                            pTopHookAPI->pszFunctionName);
                    }

                    //
                    // this wants to be excluded, so we go to the next
                    // shim, and see if it wants to be included
                    //
                    bShimWantsToExclude = TRUE;
                    goto nextShim;
                }
                pExcludeMod = pExcludeMod->pNext;
            }

            //
            // we should include this shim, and therefore, the whole chain
            //
            bExclude = FALSE;
            goto out;
            break;
        }

        case EXCLUDE_ALL:
        {
            //
            // We exclude everything except what is in the include list.
            //

            PINEXMOD pIncludeMod;

            pIncludeMod = g_pShimInfo[dwCounter].pFirstInclude;

            while (pIncludeMod != NULL) {
                if (_stricmp(pIncludeMod->pszModule, pszModule) == 0) {
                    //
                    // we should include this shim, and therefore, the whole chain
                    //
                    bExclude = FALSE;
                    goto out;
                }
                pIncludeMod = pIncludeMod->pNext;
            }

            if ((ULONG_PTR)pTopHookAPI->pszFunctionName < 0x0000FFFF) {
                DPF(dlInfo,
                    "[SeiIsExcluded] module \"%s\" excluded for shim %S, API \"%s!#%d\", because it is not in the include list (MODE: EA).\n",
                    pszModule,
                    g_pShimInfo[dwCounter].wszName,
                    pTopHookAPI->pszModule,
                    pTopHookAPI->pszFunctionName);
            } else {
                DPF(dlInfo,
                    "[SeiIsExcluded] module \"%s\" excluded for shim %S, API \"%s!%s\", because it is not in the include list (MODE: EA).\n",
                    pszModule,
                    g_pShimInfo[dwCounter].wszName,
                    pTopHookAPI->pszModule,
                    pTopHookAPI->pszFunctionName);
            }

            //
            // this wants to be excluded, so we go to the next
            // shim, and see if it wants to be included
            //
            bShimWantsToExclude = TRUE;
            goto nextShim;
            break;
        }
        }

nextShim:

        pHook = pHook->pHookEx->pNext;
    }


out:
    if (!bExclude && bShimWantsToExclude) {
        if ((ULONG_PTR)pTopHookAPI->pszFunctionName < 0x0000FFFF) {
            DPF(dlError,
                "[SeiIsExcluded] Module \"%s\" mixed inclusion/exclusion for "
                "API \"%s!#%d\". Included.\n",
                pszModule,
                pTopHookAPI->pszModule,
                pTopHookAPI->pszFunctionName);
        } else {
            DPF(dlError,
                "[SeiIsExcluded] Module \"%s\" mixed inclusion/exclusion for "
                "API \"%s!%s\". Included.\n",
                pszModule,
                pTopHookAPI->pszModule,
                pTopHookAPI->pszFunctionName);
        }
    }

    return bExclude;
}


BOOL
SeiHookImports(
    IN  PBYTE           pDllBase,       // The base address of the DLL to be hooked
    IN  ULONG           ulSizeOfImage,  // The size of the DLL image
    IN  PUNICODE_STRING pstrDllName,    // The name of the DLL to be hooked
    IN  BOOL            bInSystem32     // TRUE if this is a system32 DLL
    )
/*++
    Return: TRUE if successful.

    Desc:   Walks the import table of the specified module and patches the APIs
            that need to be hooked.
--*/
{
    CHAR                        szBaseDllName[MAX_PATH];
    ANSI_STRING                 AnsiString = { 0, sizeof(szBaseDllName), szBaseDllName };
    NTSTATUS                    status;
    BOOL                        bAnyHooked = FALSE;
    PIMAGE_DOS_HEADER           pIDH       = (PIMAGE_DOS_HEADER)pDllBase;
    PIMAGE_NT_HEADERS           pINTH;
    PIMAGE_IMPORT_DESCRIPTOR    pIID;
    DWORD                       dwImportTableOffset;
    PHOOKAPI                    pTopHookAPI;
    DWORD                       dwOldProtect, dwOldProtect2;
    SIZE_T                      dwProtectSize;
    DWORD                       i, j;
    PVOID                       pfnOld;

    status = RtlUnicodeStringToAnsiString(&AnsiString, pstrDllName, FALSE);

    if (!NT_SUCCESS(status)) {
        DPF(dlError, "[SeiHookImports] Cannot convert \"%S\" to ANSI\n",
            pstrDllName->Buffer);
        return FALSE;
    }

    //
    // Get the import table.
    //
    pINTH = (PIMAGE_NT_HEADERS)(pDllBase + pIDH->e_lfanew);

    dwImportTableOffset = pINTH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

    if (dwImportTableOffset == 0) {
        //
        // No import table found. This is probably ntdll.dll
        //
        return TRUE;
    }

    DPF(dlInfo, "[SeiHookImports] Hooking module 0x%p \"%s\"\n", pDllBase, szBaseDllName);

    pIID = (PIMAGE_IMPORT_DESCRIPTOR)(pDllBase + dwImportTableOffset);

    //
    // Loop through the import table and search for the APIs that we want to patch
    //
    while (TRUE) {

        LPSTR             pszImportEntryModule;
        PIMAGE_THUNK_DATA pITDA;

        //
        // Return if no first thunk (terminating condition).
        //
        if (pIID->FirstThunk == 0) {
            break;
        }

        pszImportEntryModule = (LPSTR)(pDllBase + pIID->Name);

        //
        // If we're not interested in this module jump to the next.
        //
        bAnyHooked = FALSE;

        for (i = 0; i < g_dwShimsCount; i++) {
            for (j = 0; j < g_pShimInfo[i].dwHookedAPIs; j++) {
                if (g_pHookArray[i][j].pszModule != NULL &&
                    _stricmp(g_pHookArray[i][j].pszModule, pszImportEntryModule) == 0) {
                    bAnyHooked = TRUE;
                    goto ScanDone;
                }
            }
        }

ScanDone:
        if (!bAnyHooked) {
            pIID++;
            continue;
        }

        //
        // We have APIs to hook for this module!
        //
        pITDA = (PIMAGE_THUNK_DATA)(pDllBase + (DWORD)pIID->FirstThunk);

        while (TRUE) {

            SIZE_T dwFuncAddr;

            pfnOld = (PVOID)pITDA->u1.Function;

            //
            // Done with all the imports from this module? (terminating condition)
            //
            if (pITDA->u1.Ordinal == 0) {
                break;
            }

            pTopHookAPI = SeiConstructChain(pfnOld, &i);

            if (pTopHookAPI == NULL || SeiIsExcluded(szBaseDllName, pTopHookAPI, bInSystem32)) {
                pITDA++;
                continue;
            }

            if ((ULONG_PTR)pTopHookAPI->pszFunctionName < 0x0000FFFF) {
                DPF(dlInfo,
                    "[SeiHookImports] Hooking API \"%s!#%d\" for DLL \"%s\"\n",
                    pTopHookAPI->pszModule,
                    pTopHookAPI->pszFunctionName,
                    szBaseDllName);
            } else {
                DPF(dlInfo,
                    "[SeiHookImports] Hooking API \"%s!%s\" for DLL \"%s\"\n",
                    pTopHookAPI->pszModule,
                    pTopHookAPI->pszFunctionName,
                    szBaseDllName);
            }

            //
            // Make the code page writable and overwrite new function pointer
            // in the import table.
            //
            dwProtectSize = sizeof(DWORD);

            dwFuncAddr = (SIZE_T)&pITDA->u1.Function;

            status = NtProtectVirtualMemory(NtCurrentProcess(),
                                            (PVOID)&dwFuncAddr,
                                            &dwProtectSize,
                                            PAGE_READWRITE,
                                            &dwOldProtect);

            if (NT_SUCCESS(status)) {
                pITDA->u1.Function = (SIZE_T)pTopHookAPI->pfnNew;

                dwProtectSize = sizeof(DWORD);

                status = NtProtectVirtualMemory(NtCurrentProcess(),
                                                (PVOID)&dwFuncAddr,
                                                &dwProtectSize,
                                                dwOldProtect,
                                                &dwOldProtect2);
                if (!NT_SUCCESS(status)) {
                    DPF(dlError, "[SeiHookImports] Failed to change back the protection\n");
                }
            } else {
                DPF(dlError,
                    "[SeiHookImports] Failed 0x%X to change protection to PAGE_READWRITE."
                    " Addr 0x%p\n",
                    status,
                    &pITDA->u1.Function);
            }
            pITDA++;

        }
        pIID++;
    }

    //
    // Add the hooked module to the list of hooked modules
    //
    g_hHookedModules[g_dwHookedModuleCount].pDllBase      = pDllBase;
    g_hHookedModules[g_dwHookedModuleCount].ulSizeOfImage = ulSizeOfImage;
    g_hHookedModules[g_dwHookedModuleCount].bInSystem32   = bInSystem32;

    strcpy(g_hHookedModules[g_dwHookedModuleCount++].szModuleName, szBaseDllName);

    return TRUE;
}


//
// NOTE: This used to be an exported function in the Win2k shim engine so
//       let's not change its name.
//

BOOL
PatchNewModules(
    BOOL bDynamic
    )
/*++
    Return: STATUS_SUCCESS if successful

    Desc:   Walks the loader list of loaded modules and attempts to patch all
            the modules that are not already patched. It also attempts to
            install the in memory patches.
--*/
{
    PPEB        Peb = NtCurrentPeb();
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;
    DWORD       i;
    BOOL        bInSystem32;

    //
    // Resolve any APIs that became available from newly loaded modules.
    //
    SeiResolveAPIs();

    if (g_bShimInitialized) {
        DPF(dlInfo, "[PatchNewModules] Dynamic loaded modules\n");
    }

    //
    // Try to apply memory patches.
    //
    SeiAttemptPatches();

    //
    // Return if only patches were required.
    //
    if (g_dwShimsCount == 0) {
        return TRUE;
    }

    //
    // Loop through the loaded modules
    //
    LdrHead = &Peb->Ldr->InMemoryOrderModuleList;

    LdrNext = LdrHead->Flink;

    while (LdrNext != LdrHead) {

        PLDR_DATA_TABLE_ENTRY LdrEntry;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        if ((SSIZE_T)LdrEntry->DllBase < 0) {
            DPF(dlWarning, "[PatchNewModules] Not hooking kernel-mode DLL \"%S\"\n",
                LdrEntry->BaseDllName.Buffer);
            goto Continue;
        }

        //
        // Don't hook our shim DLLs!
        //
        for (i = 0; i < g_dwShimsCount; i++) {
            if (g_pShimInfo[i].pDllBase == LdrEntry->DllBase) {
                goto Continue;
            }
        }

        //
        // Don't hook the shim engine!
        //
        if (LdrEntry->DllBase == g_pShimEngModHandle) {
            goto Continue;
        }

        //
        // Do nothing if it's already hooked.
        //
        if (!bDynamic) {
            for (i = 0; i < g_dwHookedModuleCount; i++) {
                if (LdrEntry->DllBase == g_hHookedModules[i].pDllBase) {
                    goto Continue;
                }
            }
        }

        //
        // Make sure we're not hooking more DLLs than we can.
        //
        if (g_dwHookedModuleCount == SHIM_MAX_HOOKED_MODULES - 1) {
            DPF(dlError, "\n[PatchNewModules] Too many modules hooked!!!\n\n");
            ASSERT(g_dwHookedModuleCount < SHIM_MAX_HOOKED_MODULES - 1);
            break;
        }

        //
        // Check if this DLL is in System32 (or WinSxS), and hence a possible candidate for blanket
        // exclusion.
        //
        if ((g_dwSystem32StrLen && _wcsnicmp(g_szSystem32,
                LdrEntry->FullDllName.Buffer, g_dwSystem32StrLen) == 0) ||
                (g_dwSxSStrLen && _wcsnicmp(g_szSxS,
                LdrEntry->FullDllName.Buffer, g_dwSxSStrLen) == 0)) {
            bInSystem32 = TRUE;
        } else {
            bInSystem32 = FALSE;
        }

        //
        // This is a candidate for hooking.
        //
        SeiHookImports(LdrEntry->DllBase,
                       LdrEntry->SizeOfImage,
                       &LdrEntry->BaseDllName,
                       bInSystem32);

Continue:
        LdrNext = LdrEntry->InMemoryOrderLinks.Flink;
    }

    return TRUE;
}

void
SeiBuildGlobalInclList(
    IN  HSDB hSDB               // the handle to the database channel
    )
/*++
    Return: void

    Desc:   This function builds the global inclusion list by reading it from the
            database.
--*/
{
    TAGREF         trDatabase, trLibrary, trInExList, trModule;
    WCHAR          wszModule[MAX_PATH];
    CHAR           szModule[MAX_PATH];
    ANSI_STRING    AnsiString = { 0, sizeof(szModule),  szModule  };
    UNICODE_STRING UnicodeString;
    PINEXMOD       pInExMod;
    SIZE_T         len;
    NTSTATUS       status;

    //
    // See if the list is not already built.
    //
    if (g_pGlobalInclusionList) {
        return;
    }

    trDatabase = SdbFindFirstTagRef(hSDB, TAGID_ROOT, TAG_DATABASE);

    if (trDatabase == TAGREF_NULL) {
        DPF(dlError, "[SeiBuildGlobalInclList] Corrupt database. TAG_DATABASE\n");
        ASSERT(trDatabase != TAGREF_NULL);
        return;
    }

    trLibrary = SdbFindFirstTagRef(hSDB, trDatabase, TAG_LIBRARY);

    if (trLibrary == TAGREF_NULL) {
        DPF(dlError, "[SeiBuildGlobalInclList] Corrupt database. TAG_LIBRARY\n");
        ASSERT(trLibrary != TAGREF_NULL);
        return;
    }

    trInExList = SdbFindFirstTagRef(hSDB, trLibrary, TAG_INEXCLUDE);

    if (trInExList == TAGREF_NULL) {
        DPF(dlWarning, "[SeiBuildGlobalInclList] no global inclusion list.\n");

        //
        // This is not a problem. It just means there is no
        // global inclusion list.
        //
        return;
    }

    if (trInExList != TAGREF_NULL) {
        DPF(dlInfo, "[SeiBuildGlobalInclList] Global inclusion list:\n");
    }

    while (trInExList != TAGREF_NULL) {

        trModule = SdbFindFirstTagRef(hSDB, trInExList, TAG_MODULE);

        if (trModule == TAGREF_NULL) {
            DPF(dlError,
                "[SeiBuildGlobalInclList] Corrupt database. Global exclusion list w/o module\n");
            ASSERT(trModule != TAGREF_NULL);
            return;
        }

        if (!SdbReadStringTagRef(hSDB, trModule, wszModule, MAX_PATH * sizeof(WCHAR))) {
            DPF(dlError,
                "[SeiBuildGlobalInclList] Corrupt database. Inclusion list w/ bad module\n");
            ASSERT(0);
            return;
        }

        //
        // Check for EXE name. The EXE should not be in the global inclusion list.
        //
        if (wszModule[0] == L'$') {
            //
            // The EXE name should not be specified in the global exclusion list.
            //
            DPF(dlError,
                "[SeiBuildGlobalInclList] EXE name used in the global exclusion list!\n");
            ASSERT(0);
            goto Continue;
        }

        RtlInitUnicodeString(&UnicodeString, wszModule);

        status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);

        if (!NT_SUCCESS(status)) {
            DPF(dlError,
                "[SeiBuildGlobalInclList] 0x%X Cannot convert UNICODE \"%S\" to ANSI\n",
                status, wszModule);
            ASSERT(0);
            return;
        }

        pInExMod = (PINEXMOD)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                     HEAP_ZERO_MEMORY,
                                                     sizeof(INEXMOD));

        if (pInExMod == NULL) {
            DPF(dlError,
                "[SeiBuildGlobalInclList] Failed to allocate %d bytes\n",
                sizeof(INEXMOD));
            return;
        }

        len = strlen(szModule) + 1;

        pInExMod->pszModule = (char*)(*g_pfnRtlAllocateHeap)(g_pShimHeap, 0, len);

        if (pInExMod->pszModule == NULL) {
            DPF(dlError, "[SeiBuildGlobalInclList] Failed to allocate %d bytes\n", len);
            return;
        }

        RtlCopyMemory(pInExMod->pszModule, szModule, len);

        //
        // Link it in the list.
        //
        pInExMod->pNext = g_pGlobalInclusionList;
        g_pGlobalInclusionList = pInExMod;

        DPF(dlInfo, "\t\"%s\"\n", pInExMod->pszModule);

Continue:
        trInExList = SdbFindNextTagRef(hSDB, trLibrary, trInExList);
    }
}

void
SeiEmptyInclExclList(
    IN  DWORD dwCounter
    )
/*++
    Return: void

    Desc:   This function empties the inclusion and exclusion lists for the specified
            shim.
--*/
{
    PINEXMOD pInExMod;
    PINEXMOD pInExFree;

    //
    // First the include list.
    //
    pInExMod = g_pShimInfo[dwCounter].pFirstInclude;

    while (pInExMod != NULL) {
        pInExFree = pInExMod;
        pInExMod  = pInExMod->pNext;

        (*g_pfnRtlFreeHeap)(g_pShimHeap, 0, pInExFree->pszModule);
        (*g_pfnRtlFreeHeap)(g_pShimHeap, 0, pInExFree);
    }

    g_pShimInfo[dwCounter].pFirstInclude = NULL;

    //
    // Now the exclude list.
    //
    pInExMod = g_pShimInfo[dwCounter].pFirstExclude;

    while (pInExMod != NULL) {
        pInExFree = pInExMod;
        pInExMod  = pInExMod->pNext;

        (*g_pfnRtlFreeHeap)(g_pShimHeap, 0, pInExFree->pszModule);
        (*g_pfnRtlFreeHeap)(g_pShimHeap, 0, pInExFree);
    }

    g_pShimInfo[dwCounter].pFirstExclude = NULL;
}


#define MAX_LOCAL_INCLUDES 64     // max of 64 Incl/Excl statements

BOOL
SeiBuildInclExclListForShim(
    IN  HSDB            hSDB,           // handle to the database channel
    IN  TAGREF          trShim,         // TAGREF to the shim entry
    IN  DWORD           dwCounter,      // the index for the shim
    IN  LPCWSTR         pwszExePath     // full path to the EXE
    )
/*++
    Return: STATUS_SUCCESS on success, STATUS_UNSUCCESSFUL on failure.

    Desc:   This function builds the inclusion and exclusion lists for the
            specified shim.
--*/
{
    TAGREF         trInExList, trModule, trInclude;
    WCHAR          wszModule[MAX_PATH];
    CHAR           szModule[MAX_PATH];
    ANSI_STRING    AnsiString = { 0, sizeof(szModule), szModule };
    UNICODE_STRING UnicodeString;
    PINEXMOD       pInExMod;
    SIZE_T         len;
    int            nInEx;
    BOOL           bInclude;
    DWORD          trArrInEx[MAX_LOCAL_INCLUDES];
    NTSTATUS       status;

    trInExList = SdbFindFirstTagRef(hSDB, trShim, TAG_INEXCLUDE);

    nInEx = 0;

    //
    // Count the number of inclusion/exclusion statements. We need to do
    // this first because the statements are written into the sdb file
    // from bottom to top.
    //
    while (trInExList != TAGREF_NULL && nInEx < MAX_LOCAL_INCLUDES) {

        trArrInEx[nInEx++] = trInExList;

        trInExList = SdbFindNextTagRef(hSDB, trShim, trInExList);

        ASSERT(nInEx <= MAX_LOCAL_INCLUDES);
    }

    if (nInEx == 0) {
        return TRUE;
    }

    nInEx--;

    while (nInEx >= 0) {

        trInExList = trArrInEx[nInEx];

        trInclude = SdbFindFirstTagRef(hSDB, trInExList, TAG_INCLUDE);

        bInclude = (trInclude != TAGREF_NULL);

        trModule = SdbFindFirstTagRef(hSDB, trInExList, TAG_MODULE);

        if (trModule == TAGREF_NULL) {
            DPF(dlError,
                "[SeiBuildInclExclListForShim] Corrupt database. Incl/Excl list w/o module\n");
            ASSERT(trModule != TAGREF_NULL);
            return FALSE;
        }

        if (!SdbReadStringTagRef(hSDB, trModule, wszModule, MAX_PATH * sizeof(WCHAR))) {
            DPF(dlError,
                "[SeiBuildInclExclListForShim] Corrupt database. Incl/Excl list w/ bad module\n");
            ASSERT(0);
            return FALSE;
        }

        //
        // Special case for '*'. '*' means all modules.
        //
        // NOTE: this option is ignored for dynamic shimming.
        //
        if (wszModule[0] == L'*') {

            if (bInclude) {
                //
                // This is INCLUDE MODULE="*"
                // Mark that we are in INCLUDE_ALL mode.
                //
                g_pShimInfo[dwCounter].eInExMode = INCLUDE_ALL;
            } else {
                //
                // This is EXCLUDE MODULE="*"
                // Mark that we are in EXCLUDE_ALL mode.
                //
                g_pShimInfo[dwCounter].eInExMode = EXCLUDE_ALL;
            }

            SeiEmptyInclExclList(dwCounter);

        } else {

            if (wszModule[0] == L'$') {
                //
                // Special case for EXE name. Get the name of the executable.
                //
                LPCWSTR pwszWalk = pwszExePath + wcslen(pwszExePath);

                while (pwszWalk >= pwszExePath) {
                    if (*pwszWalk == '\\') {
                        break;
                    }
                    pwszWalk--;
                }

                wcscpy(wszModule, pwszWalk + 1);

                DPF(dlInfo,
                    "[SeiBuildInclExclListForShim] EXE name resolved to \"%S\".\n",
                    wszModule);
            }

            RtlInitUnicodeString(&UnicodeString, wszModule);

            status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);

            if (!NT_SUCCESS(status)) {
                DPF(dlError,
                    "[SeiBuildInclExclListForShim] 0x%X Cannot convert UNICODE \"%S\" to ANSI\n",
                    status, wszModule);
                ASSERT(0);

                return FALSE;
            }

            //
            // Add the module to the correct list.
            //
            pInExMod = (PINEXMOD)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                         HEAP_ZERO_MEMORY,
                                                         sizeof(INEXMOD));
            if (pInExMod == NULL) {
                DPF(dlError,
                    "[SeiBuildInclExclListForShim] Failed to allocate %d bytes\n",
                    sizeof(INEXMOD));
                return FALSE;
            }

            len = strlen(szModule) + 1;

            pInExMod->pszModule = (char*)(*g_pfnRtlAllocateHeap)(g_pShimHeap, 0, len);

            if (pInExMod->pszModule == NULL) {
                DPF(dlError,
                    "[SeiBuildInclExclListForShim] Failed to allocate %d bytes\n", len);
                return FALSE;
            }

            RtlCopyMemory(pInExMod->pszModule, szModule, len);

            //
            // Link it in the list.
            //
            if (bInclude) {
                pInExMod->pNext = g_pShimInfo[dwCounter].pFirstInclude;
                g_pShimInfo[dwCounter].pFirstInclude = pInExMod;
            } else {
                pInExMod->pNext = g_pShimInfo[dwCounter].pFirstExclude;
                g_pShimInfo[dwCounter].pFirstExclude = pInExMod;
            }

            //
            // See if this module is in the other list, and take it out.
            //
            {
                PINEXMOD  pInExFree;
                PINEXMOD* ppInExModX;

                if (bInclude) {
                    ppInExModX = &g_pShimInfo[dwCounter].pFirstExclude;
                } else {
                    ppInExModX = &g_pShimInfo[dwCounter].pFirstInclude;
                }

                while (*ppInExModX != NULL) {

                    if (_stricmp((*ppInExModX)->pszModule, szModule) == 0) {

                        pInExFree = *ppInExModX;

                        *ppInExModX = pInExFree->pNext;

                        (*g_pfnRtlFreeHeap)(g_pShimHeap, 0, pInExFree->pszModule);
                        (*g_pfnRtlFreeHeap)(g_pShimHeap, 0, pInExFree);
                        break;
                    }

                    ppInExModX = &(*ppInExModX)->pNext;
                }
            }
        }

        nInEx--;
    }

    return TRUE;
}

BOOL
SeiCopyGlobalInclList(
    IN  DWORD dwCounter
    )
/*++
    Return: STATUS_SUCCESS on success, STATUS_UNSUCCESSFUL on failure.

    Desc:   This function copies the global inclusion list.
--*/
{
    PINEXMOD pInExModX;
    SIZE_T   len;
    PINEXMOD pInExMod = g_pGlobalInclusionList;

    //
    // Don't do it if we already added it.
    //
    if (g_pShimInfo[dwCounter].pFirstInclude != NULL) {
        return TRUE;
    }

    while (pInExMod != NULL) {
        pInExModX = (PINEXMOD)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                      HEAP_ZERO_MEMORY,
                                                      sizeof(INEXMOD));
        if (pInExModX == NULL) {
            DPF(dlError,
                "[SeiCopyGlobalInclList] (1) Failed to allocate %d bytes\n",
                sizeof(INEXMOD));
            return FALSE;
        }

        len = strlen(pInExMod->pszModule) + 1;

        pInExModX->pszModule = (char*)(*g_pfnRtlAllocateHeap)(g_pShimHeap, 0, len);

        if (pInExModX->pszModule == NULL) {
            DPF(dlError,
                "[SeiCopyGlobalInclList] (2) Failed to allocate %d bytes\n", len);
            return FALSE;
        }

        RtlCopyMemory(pInExModX->pszModule, pInExMod->pszModule, len);

        //
        // Link it in the list.
        //
        pInExModX->pNext = g_pShimInfo[dwCounter].pFirstInclude;
        g_pShimInfo[dwCounter].pFirstInclude = pInExModX;

        pInExMod = pInExMod->pNext;
    }

    return TRUE;
}


BOOL
SeiBuildInclListWithOneModule(
    IN  DWORD  dwCounter,
    IN  LPCSTR lpszModuleToShim
    )
{
    PINEXMOD pInExMod;
    int      len;

    g_pShimInfo[dwCounter].eInExMode = EXCLUDE_ALL;

    //
    // Add the module to the correct list.
    //
    pInExMod = (PINEXMOD)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                 HEAP_ZERO_MEMORY,
                                                 sizeof(INEXMOD));
    if (pInExMod == NULL) {
        DPF(dlError,
            "[SeiBuildInclListWithOneModule] Failed to allocate %d bytes\n",
            sizeof(INEXMOD));
        return FALSE;
    }

    len = strlen(lpszModuleToShim) + 1;

    pInExMod->pszModule = (char*)(*g_pfnRtlAllocateHeap)(g_pShimHeap, 0, len);

    if (pInExMod->pszModule == NULL) {
        DPF(dlError,
            "[SeiBuildInclListWithOneModule] Failed to allocate %d bytes\n", len);
        return FALSE;
    }

    RtlCopyMemory(pInExMod->pszModule, lpszModuleToShim, len);

    //
    // Add it to the list.
    //
    pInExMod->pNext = g_pShimInfo[dwCounter].pFirstInclude;
    g_pShimInfo[dwCounter].pFirstInclude = pInExMod;

    return TRUE;
}

BOOL
SeiBuildInclExclList(
    IN  HSDB            hSDB,       // handle to the database channel
    IN  TAGREF          trShimRef,  // The TAGREF to the shim DLL for which to read the
                                    // inclusion or exclusion list from the database.
    IN  DWORD           dwCounter,  // Index in the g_pShimInfo array for this shim DLL.
    IN  LPCWSTR         pwszExePath // The full path name of the main EXE.
    )
/*++
    Return: STATUS_SUCCESS if successful.

    Desc:   This function builds the inclusion or exclusion list for the specified
            shim DLL by reading it from the database.
--*/
{
    TAGREF trShim;

    //
    // Set the default mode to EXCLUDE_SYSTEM32
    //
    g_pShimInfo[dwCounter].eInExMode = EXCLUDE_SYSTEM32;

    trShim = SdbGetShimFromShimRef(hSDB, trShimRef);

    if (trShim == TAGREF_NULL) {
        DPF(dlError,
            "[SeiBuildInclExclList] Corrupt database. Couldn't get the DLL from "
            "the LIBRARY section\n");
        return FALSE;
    }

    //
    // Make a copy of the global exclusion list first.
    //
    if (!SeiCopyGlobalInclList(dwCounter)) {
        DPF(dlError,
            "[SeiBuildInclExclList] SeiCopyGlobalInclList failed\n");
        return FALSE;
    }

    //
    // Get DLL specific incl/excl list first.
    //
    if (!SeiBuildInclExclListForShim(hSDB, trShim, dwCounter, pwszExePath)) {
        DPF(dlError,
            "[SeiBuildInclExclList] (1) Corrupt database. Couldn't build incl/excl list\n");
        return FALSE;
    }

    //
    // Now get the incl/excl specified for this shim within its parent EXE tag.
    //
    if (!SeiBuildInclExclListForShim(hSDB, trShimRef, dwCounter, pwszExePath)) {
        DPF(dlError,
            "[SeiBuildInclExclList] (2) Corrupt database. Couldn't build incl/excl list\n");
        return FALSE;
    }

#if DBG
    //
    // Print the incl/excl list for this shim.
    //
    if (g_pShimInfo[dwCounter].pFirstInclude != NULL) {
        PINEXMOD pInExMod;

        DPF(dlInfo, "[SeiBuildInclExclList] Inclusion list for \"%S\"\n",
            g_pShimInfo[dwCounter].pLdrEntry->BaseDllName.Buffer);

        pInExMod = g_pShimInfo[dwCounter].pFirstInclude;

        while (pInExMod != NULL) {
            DPF(dlInfo, "\t\"%s\"\n", pInExMod->pszModule);

            pInExMod = pInExMod->pNext;
        }
    }

    if (g_pShimInfo[dwCounter].pFirstExclude != NULL) {
        PINEXMOD pInExMod;

        DPF(dlInfo, "[SeiBuildInclExclList] Exclusion list for \"%S\"\n",
            g_pShimInfo[dwCounter].pLdrEntry->BaseDllName.Buffer);

        pInExMod = g_pShimInfo[dwCounter].pFirstExclude;

        while (pInExMod != NULL) {
            DPF(dlInfo, "\t\"%s\"\n", pInExMod->pszModule);

            pInExMod = pInExMod->pNext;
        }
    }
#endif // DBG

    return TRUE;
}

PLDR_DATA_TABLE_ENTRY
SeiGetLoaderEntry(
    IN  PPEB  Peb,              // The PEB
    IN  PVOID pDllBase          // The address of the shim DLL to be removed from
                                // the loader's lists.
    )
/*++
    Return: Pointer to the loader entry for the shim DLL being removed.

    Desc:   This function removes the shim DLLs from the loader's lists.
--*/
{
    PLIST_ENTRY           LdrHead;
    PLIST_ENTRY           LdrNext;
    PLDR_DATA_TABLE_ENTRY LdrEntry;

    LdrHead = &Peb->Ldr->InMemoryOrderModuleList;

    LdrNext = LdrHead->Flink;

    while (LdrNext != LdrHead) {

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        if (LdrEntry->DllBase == pDllBase) {
            break;
        }

        LdrNext = LdrEntry->InMemoryOrderLinks.Flink;
    }

    if (LdrNext != LdrHead) {
        return LdrEntry;
    }

    DPF(dlError, "[SeiGetLoaderEntry] Couldn't find shim DLL in the loader list!\n");
    ASSERT(0);

    return NULL;
}

void
SeiLoadPatches(
    IN  HSDB   hSDB,            // handle to the database channel
    IN  TAGREF trExe            // TAGREF of the EXE for which to get the memory
                                // patches from the database
    )
/*++
    Return: void

    Desc:   This function reads the memory patches from the database and
            stores them in the g_pMemoryPatches array.
--*/
{
    TAGREF trPatchRef;
    DWORD  dwSize;

    //
    // Read the patches for this EXE.
    //
    trPatchRef = SdbFindFirstTagRef(hSDB, trExe, TAG_PATCH_REF);

    while (trPatchRef != TAGREF_NULL) {
        //
        // Get the size of this patch.
        //
        dwSize = 0;

        SdbReadPatchBits(hSDB, trPatchRef, NULL, &dwSize);

        if (dwSize == 0) {
            DPF(dlError, "[SeiLoadPatches] returned 0 for patch size.\n");
            ASSERT(dwSize != 0);
            return;
        }

        if (g_dwMemoryPatchCount == SHIM_MAX_PATCH_COUNT) {
            DPF(dlError, "[SeiLoadPatches] Too many patches.\n");
            return;
        }

        //
        // Allocate memory for the patch bits.
        //
        g_pMemoryPatches[g_dwMemoryPatchCount] = (PBYTE)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                                                HEAP_ZERO_MEMORY,
                                                                                dwSize);

        if (g_pMemoryPatches[g_dwMemoryPatchCount] == NULL) {
            DPF(dlError, "[SeiLoadPatches] Failed to allocate %d bytes for patch.\n",
                dwSize);
            return;
        }

        //
        // Read the patch bits from the database.
        //
        if (!SdbReadPatchBits(hSDB,
                              trPatchRef,
                              g_pMemoryPatches[g_dwMemoryPatchCount],
                              &dwSize)) {
            DPF(dlError, "[SeiLoadPatches] Failure getting patch bits.\n");
            ASSERT(0);
            return;
        }

        g_dwMemoryPatchCount++;

        //
        // Get the next patch.
        //
        trPatchRef = SdbFindNextTagRef(hSDB, trExe, trPatchRef);
    }
}

BOOL
SeiGetModuleHandle(
    IN  LPSTR  pszModule,
    OUT PVOID* pModuleHandle
    )
/*++
    Return: void

    Desc:   This function loops through the loaded modules and gets the
            handle of the specified named module.
--*/
{
    ANSI_STRING       AnsiString;
    WCHAR             wszDllName[128];
    UNICODE_STRING    UnicodeString  = { 0, sizeof(wszDllName), wszDllName };
    NTSTATUS          status;

    RtlInitAnsiString(&AnsiString, pszModule);

    if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeString,
                                                 &AnsiString,
                                                 FALSE))){

        DPF(dlError,
            "[SeiGetModuleHandle] Failed to convert \"%s\" to UNICODE.\n",
            pszModule);
        return FALSE;
    }

    status = LdrGetDllHandle(NULL,
                             NULL,
                             &UnicodeString,
                             pModuleHandle);

    if (!NT_SUCCESS(status)) {
        DPF(dlError,
            "[SeiGetModuleHandle] Failed to get the handle for \"%s\".\n",
            pszModule);
        return FALSE;
    }

    return TRUE;
}

void
SeiRemoveDll(
    IN  LPSTR pszBaseDllName    // the named of the unloaded module
    )
/*++
    Return: void

    Desc:   This function loops through the loaded shims info and resets
            the resolved APIs that belong to the specified module that had
            just been unloaded.
--*/
{
    DWORD i, j;

    for (i = 0; i < g_dwShimsCount; i++) {
        for (j = 0; j < g_pShimInfo[i].dwHookedAPIs; j++) {
            if (g_pHookArray[i][j].pszModule != NULL &&
                _strcmpi(g_pHookArray[i][j].pszModule, pszBaseDllName) == 0) {

                if ((ULONG_PTR)g_pHookArray[i][j].pszFunctionName < 0x0000FFFF) {
                    DPF(dlWarning,
                        "[SeiRemoveDll] \"%s!#%d\" not resolved again\n",
                        g_pHookArray[i][j].pszModule,
                        g_pHookArray[i][j].pszFunctionName);
                } else {
                    DPF(dlWarning,
                        "[SeiRemoveDll] \"%s!%s\" not resolved again\n",
                        g_pHookArray[i][j].pszModule,
                        g_pHookArray[i][j].pszFunctionName);
                }

                g_pHookArray[i][j].pfnOld = NULL;
                g_pShimInfo[i].dwFlags &= ~SIF_RESOLVED;
            }
        }
    }
}

BOOL
SeiGetModuleByAddress(
    PVOID   pAddress,
    CHAR*   pszModuleName,
    BOOL*   pbInSystem32
    )
{
    DWORD i;
    
    for (i = 0; i < g_dwHookedModuleCount; i++) {
        if ((ULONG_PTR)pAddress >= (ULONG_PTR)g_hHookedModules[i].pDllBase &&
            (ULONG_PTR)pAddress < (ULONG_PTR)g_hHookedModules[i].pDllBase + (ULONG_PTR)g_hHookedModules[i].ulSizeOfImage) {

            //
            // We found the DLL in the hooked list.
            //
            strcpy(pszModuleName, g_hHookedModules[i].szModuleName);
            
            *pbInSystem32 = g_hHookedModules[i].bInSystem32;

            return TRUE;
        }
    }
    
    return FALSE;
}

PVOID
StubGetProcAddress(
    IN  HMODULE hMod,
    IN  LPSTR   pszProc
    )
/*++
    Return: The address of the function specified.

    Desc:   Intercepts calls to GetProcAddress to look for hooked functions. If
            a function was hooked, return the top-most stub function.
--*/
{
    DWORD             i, j;
    DWORD             dwDllIndex;
    PHOOKAPI          pTopHookAPI = NULL;
    PVOID             pfn;
    PFNGETPROCADDRESS pfnOld;
    PVOID             retAddress = NULL;
    ULONG             ulHash;
    CHAR              szBaseDllName[MAX_PATH];
    BOOL              bInSystem32;

    pfnOld = g_IntHookAPI[IHA_GetProcAddress].pfnOld;

    pfn = (*pfnOld)(hMod, pszProc);

    if (pfn == NULL) {
        return NULL;
    }

    for (i = 0; i < g_dwShimsCount; i++) {
        for (j = 0; j < g_pShimInfo[i].dwHookedAPIs; j++) {
            if (g_pHookArray[i][j].pfnOld == pfn) {

                pTopHookAPI = SeiConstructChain(pfn, &dwDllIndex);

                if (pTopHookAPI == NULL) {
                    DPF(dlError,
                        "[StubGetProcAddress] failed to construct the chain for pfn 0x%p\n",
                        pfn);
                    return pfn;
                }

                //
                // Probably we care about inclusion/exclusion lists here as well.
                //
                
                RtlCaptureStackBackTrace(1, 1, &retAddress, &ulHash);
                
                DPF(dlPrint,
                    "[StubGetProcAddress] Stack capture caller 0x%p\n",
                    retAddress);

                if (retAddress && SeiGetModuleByAddress(retAddress, szBaseDllName, &bInSystem32)) {
                    
                    if (SeiIsExcluded(szBaseDllName, pTopHookAPI, bInSystem32)) {
                        return pfn;
                    }
                }
                
                if ((ULONG_PTR)pTopHookAPI->pszFunctionName < 0x0000FFFF) {
                    DPF(dlInfo,
                        "[StubGetProcAddress] called for \"%s!#%d\" 0x%p changed to 0x%p\n",
                        pTopHookAPI->pszModule,
                        pTopHookAPI->pszFunctionName,
                        pfn,
                        pTopHookAPI->pfnNew);
                } else {
                    DPF(dlInfo,
                        "[StubGetProcAddress] called for \"%s!%s\" 0x%p changed to 0x%p\n",
                        pTopHookAPI->pszModule,
                        pTopHookAPI->pszFunctionName,
                        pfn,
                        pTopHookAPI->pfnNew);
                }

                return pTopHookAPI->pfnNew;
            }
        }
    }

    return pfn;
}

#ifdef SE_WIN2K

//
// The Win2k engine needs to hook a few other APIs as well.
//

HMODULE
StubLoadLibraryA(
    IN  LPCSTR pszModule
    )
{
    HMODULE         hMod;
    PFNLOADLIBRARYA pfnOld;
    DWORD           i;

    pfnOld = g_IntHookAPI[IHA_LoadLibraryA].pfnOld;

    hMod = (*pfnOld)(pszModule);

    if (hMod == NULL) {
        return NULL;
    }

    //
    // Was this DLL already loaded ?
    //
    for (i = 0; i < g_dwHookedModuleCount; i++) {
        if (hMod == g_hHookedModules[i].pDllBase) {
            DPF(dlInfo,
                "[StubLoadLibraryA] DLL \"%s\" was already loaded.\n",
                pszModule);
            return hMod;
        }
    }

    PatchNewModules(FALSE);

    return hMod;
}

HMODULE
StubLoadLibraryW(
    IN  LPCWSTR pszModule
    )
{
    HMODULE         hMod;
    PFNLOADLIBRARYW pfnOld;
    DWORD           i;

    pfnOld = g_IntHookAPI[IHA_LoadLibraryW].pfnOld;

    hMod = (*pfnOld)(pszModule);

    if (hMod == NULL) {
        return NULL;
    }

    //
    // Was this DLL already loaded ?
    //
    for (i = 0; i < g_dwHookedModuleCount; i++) {
        if (hMod == g_hHookedModules[i].pDllBase) {
            DPF(dlInfo,
                "[StubLoadLibraryW] DLL \"%S\" was already loaded.\n",
                pszModule);
            return hMod;
        }
    }

    PatchNewModules(FALSE);

    return hMod;
}

HMODULE
StubLoadLibraryExA(
    IN  LPCSTR pszModule,
    IN  HANDLE hFile,
    IN  DWORD  dwFlags
    )
{
    HMODULE           hMod;
    PFNLOADLIBRARYEXA pfnOld;
    DWORD             i;

    pfnOld = g_IntHookAPI[IHA_LoadLibraryExA].pfnOld;

    hMod = (*pfnOld)(pszModule, hFile, dwFlags);

    if (hMod == NULL) {
        return NULL;
    }

    //
    // Was this DLL already loaded ?
    //
    for (i = 0; i < g_dwHookedModuleCount; i++) {
        if (hMod == g_hHookedModules[i].pDllBase) {
            DPF(dlInfo,
                "[StubLoadLibraryExA] DLL \"%s\" was already loaded.\n",
                pszModule);
            return hMod;
        }
    }

    PatchNewModules(FALSE);

    return hMod;
}

HMODULE
StubLoadLibraryExW(
    IN  LPCWSTR pszModule,
    IN  HANDLE  hFile,
    IN  DWORD   dwFlags
    )
{
    HMODULE           hMod;
    PFNLOADLIBRARYEXW pfnOld;
    DWORD             i;

    pfnOld = g_IntHookAPI[IHA_LoadLibraryExW].pfnOld;

    hMod = (*pfnOld)(pszModule, hFile, dwFlags);

    if (hMod == NULL) {
        return NULL;
    }

    //
    // Was this DLL already loaded ?
    //
    for (i = 0; i < g_dwHookedModuleCount; i++) {
        if (hMod == g_hHookedModules[i].pDllBase) {
            DPF(dlInfo,
                "[StubLoadLibraryExW] DLL \"%S\" was already loaded.\n",
                pszModule);
            return hMod;
        }
    }

    PatchNewModules(FALSE);

    return hMod;
}

BOOL
SeiIsDllLoaded(
    IN  HMODULE                hMod,
    IN  PLDR_DATA_TABLE_ENTRY* pLdrEntry
    )
{
    PPEB        Peb = NtCurrentPeb();
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;
    DWORD       i;

    //
    // Loop through the loaded modules.
    //
    LdrHead = &Peb->Ldr->InMemoryOrderModuleList;

    LdrNext = LdrHead->Flink;

    while (LdrNext != LdrHead) {

        PLDR_DATA_TABLE_ENTRY LdrEntry;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        if (LdrEntry->DllBase == hMod) {
            *pLdrEntry = LdrEntry;
            return TRUE;
        }

        LdrNext = LdrEntry->InMemoryOrderLinks.Flink;
    }

    return FALSE;
}

BOOL
StubFreeLibrary(
    IN  HMODULE hLibModule
    )
{
    DWORD                 i, j;
    PFNFREELIBRARY        pfnOld;
    BOOL                  bRet;
    PLDR_DATA_TABLE_ENTRY LdrEntry;
    char                  szBaseDllName[128];

    pfnOld = g_IntHookAPI[IHA_FreeLibrary].pfnOld;

    bRet = (*pfnOld)(hLibModule);

    //
    // See if this DLL is one that we hooked.
    //
    for (i = 0; i < g_dwHookedModuleCount; i++) {
        if (g_hHookedModules[i].pDllBase == hLibModule) {
            break;
        }
    }

    if (i >= g_dwHookedModuleCount) {
        return bRet;
    }

    //
    // Is the DLL still loaded ?
    //
    if (SeiIsDllLoaded(hLibModule, &LdrEntry)) {
        DPF(dlInfo,
            "[StubFreeLibrary] Dll \"%S\" still loaded.\n",
            LdrEntry->BaseDllName.Buffer);
        return bRet;
    }

    strcpy(szBaseDllName, g_hHookedModules[i].szModuleName);

    DPF(dlInfo,
        "[StubFreeLibrary] Removing hooked DLL 0x%p \"%s\"\n",
        hLibModule,
        szBaseDllName);

    //
    // Take it out of the list of hooked modules.
    //
    for (j = i; j < g_dwHookedModuleCount - 1; j++) {
        RtlCopyMemory(g_hHookedModules + j, g_hHookedModules + j + 1, sizeof(HOOKEDMODULE));
    }

    g_hHookedModules[j].pDllBase = NULL;
    strcpy(g_hHookedModules[j].szModuleName, "removed!");

    g_dwHookedModuleCount--;

    //
    // Remove the pfnOld from the HOOKAPIs that were
    // resolved to this DLL
    //
    SeiRemoveDll(szBaseDllName);

    return bRet;
}

#endif // SE_WIN2K


BOOL
SeiInitFileLog(
    IN  LPCWSTR pwszAppName      // The full path of the starting EXE
    )
/*++
    Return: TRUE if the log was initialized.

    Desc:   This function checks an environment variable to determine if logging
            is enabled. If so, it will append a header that tells a new app is
            started.
--*/
{
    NTSTATUS            status;
    UNICODE_STRING      EnvName;
    UNICODE_STRING      EnvValue;
    UNICODE_STRING      FilePath;
    UNICODE_STRING      NtSystemRoot;
    WCHAR               wszEnvValue[128];
    WCHAR               wszLogFile[MAX_PATH];
    HANDLE              hfile;
    OBJECT_ATTRIBUTES   ObjA;
    LARGE_INTEGER       liOffset;
    RTL_RELATIVE_NAME   RelativeName;
    ULONG               uBytes;
    char                szHeader[512];
    char                szFormatHeader[] = "-------------------------------------------\r\n"
                                           " Log  \"%S\"\r\n"
                                           "-------------------------------------------\r\n";
    IO_STATUS_BLOCK     ioStatusBlock;

    RtlInitUnicodeString(&EnvName, L"SHIM_FILE_LOG");

    EnvValue.Buffer = wszEnvValue;
    EnvValue.Length = 0;
    EnvValue.MaximumLength = sizeof(wszEnvValue);

    status = RtlQueryEnvironmentVariable_U(NULL, &EnvName, &EnvValue);

    if (!NT_SUCCESS(status)) {
        DPF(dlInfo, "[SeiInitFileLog] Logging not enabled\n");
        return FALSE;
    }

    FilePath.Buffer = wszLogFile;
    FilePath.Length = 0;
    FilePath.MaximumLength = sizeof(wszLogFile);

    RtlInitUnicodeString(&NtSystemRoot, USER_SHARED_DATA->NtSystemRoot);
    RtlAppendUnicodeStringToString(&FilePath, &NtSystemRoot);
    RtlAppendUnicodeToString(&FilePath, L"\\AppPatch\\");
    RtlAppendUnicodeStringToString(&FilePath, &EnvValue);

    if (!RtlDosPathNameToNtPathName_U(FilePath.Buffer,
                                      &FilePath,
                                      NULL,
                                      &RelativeName)) {
        DPF(dlError,
            "[SeiInitFileLog] Failed to convert path name \"%S\"\n",
            wszLogFile);
        return FALSE;
    }

    InitializeObjectAttributes(&ObjA,
                               &FilePath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // Open/Create the log file.
    //
    status = NtCreateFile(&hfile,
                          FILE_APPEND_DATA | SYNCHRONIZE,
                          &ObjA,
                          &ioStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OPEN_IF,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    RtlFreeUnicodeString(&FilePath);

    if (!NT_SUCCESS(status)) {
        DPF(dlError,
            "[SeiInitFileLog] 0x%X Cannot open/create log file \"%S\"\n",
            status, wszLogFile);
        return FALSE;
    }

    //
    // Now write a new line in the log file
    //
    ioStatusBlock.Status = 0;
    ioStatusBlock.Information = 0;

    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    uBytes = (ULONG)sprintf(szHeader, szFormatHeader, pwszAppName);

    status = NtWriteFile(hfile,
                         NULL,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         (PVOID)szHeader,
                         uBytes,
                         &liOffset,
                         NULL);

    NtClose(hfile);

    if (!NT_SUCCESS(status)) {
        DPF(dlError,
            "[SeiInitFileLog] 0x%X Cannot write into the log file \"%S\"\n",
            status, wszLogFile);
        return FALSE;
    }

    return TRUE;
}

LPWSTR
SeiGetLayerName(
    IN  HSDB   hSDB,
    IN  TAGREF trLayer
    )
/*++
    Return: BUGBUG

    Desc:   BUGBUG
--*/
{
    PDB    pdb;
    TAGID  tiLayer, tiName;
    LPWSTR pwszName;

    if (!SdbTagRefToTagID(hSDB, trLayer, &pdb, &tiLayer)) {
        DPF(dlError, "[SeiGetLayerName] Failed to get tag id from tag ref\n");
        return NULL;
    }

    tiName = SdbFindFirstTag(pdb, tiLayer, TAG_NAME);

    if (tiName == TAGID_NULL) {
        DPF(dlError,
            "[SeiGetLayerName] Failed to get the name tag id\n");
        return NULL;
    }

    pwszName = SdbGetStringTagPtr(pdb, tiName);

    if (pwszName == NULL) {
        DPF(dlError,
            "[SeiGetLayerName] Cannot read the name of the layer tag\n");
    }

    return pwszName;
}

void
SeiClearLayerEnvVar(
    void
    )
/*++
    Return: BUGBUG

    Desc:   BUGBUG
--*/
{
    UNICODE_STRING EnvName;
    NTSTATUS       status;

    RtlInitUnicodeString(&EnvName, L"__COMPAT_LAYER");

    status = RtlSetEnvironmentVariable(NULL, &EnvName, NULL);

    if (NT_SUCCESS(status)) {
        DPF(dlInfo, "[SeiClearLayerEnvVar] Cleared env var __COMPAT_LAYER.\n");
    } else {
        DPF(dlError, "[SeiClearLayerEnvVar] Failed to clear __COMPAT_LAYER. 0x%X\n", status);
    }
}

BOOL
SeiIsLayerEnvVarSet(
    void
    )
/*++
    Return: BUGBUG

    Desc:   BUGBUG
--*/
{

    NTSTATUS       status;
    UNICODE_STRING EnvName;
    UNICODE_STRING EnvValue;
    WCHAR          wszEnvValue[128];

    RtlInitUnicodeString(&EnvName, L"__COMPAT_LAYER");

    EnvValue.Buffer = wszEnvValue;
    EnvValue.Length = 0;
    EnvValue.MaximumLength = sizeof(wszEnvValue);

    status = RtlQueryEnvironmentVariable_U(NULL, &EnvName, &EnvValue);

    return NT_SUCCESS(status);
}

BOOL
SeiCheckLayerEnvVarFlags(
    BOOL* pbApplyExes,
    BOOL* pbApplyToSystemExes
    )
/*++
    Return: BUGBUG

    Desc:   BUGBUG
--*/
{
    NTSTATUS       status;
    UNICODE_STRING EnvName;
    UNICODE_STRING EnvValue;
    WCHAR          wszEnvValue[128] = L"";
    LPWSTR         pwszEnvTemp;

    if (pbApplyExes) {
        *pbApplyExes = TRUE;
    }
    if (pbApplyToSystemExes) {
        *pbApplyToSystemExes = FALSE;
    }

    RtlInitUnicodeString(&EnvName, L"__COMPAT_LAYER");

    EnvValue.Buffer = wszEnvValue;
    EnvValue.Length = 0;
    EnvValue.MaximumLength = sizeof(wszEnvValue);

    status = RtlQueryEnvironmentVariable_U(NULL, &EnvName, &EnvValue);

    //
    // Skip over and handle special flag characters
    //    '!' means don't use any EXE entries from the DB
    //    '#' means go ahead and apply layers to system EXEs
    //
    if (NT_SUCCESS(status)) {
        pwszEnvTemp = EnvValue.Buffer;

        while (*pwszEnvTemp) {
            if (*pwszEnvTemp == L'!') {

                if (pbApplyExes) {
                    *pbApplyExes = FALSE;
                }
            } else if (*pwszEnvTemp == L'#') {

                if (pbApplyToSystemExes) {
                    *pbApplyToSystemExes = TRUE;
                }

            } else {
                break;
            }
            pwszEnvTemp++;
        }
    }

    return NT_SUCCESS(status);
}

void
SeiSetLayerEnvVar(
    WCHAR* pwszName
    )
/*++
    Return: BUGBUG

    Desc:   BUGBUG
--*/
{
    NTSTATUS       status;
    UNICODE_STRING EnvName;
    UNICODE_STRING EnvValue;
    WCHAR          wszEnvValue[128];

    RtlInitUnicodeString(&EnvName, L"__COMPAT_LAYER");

    EnvValue.Buffer = wszEnvValue;
    EnvValue.Length = 0;
    EnvValue.MaximumLength = sizeof(wszEnvValue);

    status = RtlQueryEnvironmentVariable_U(NULL, &EnvName, &EnvValue);

    if (NT_SUCCESS(status) && (EnvValue.Buffer[0] == L'!' || EnvValue.Buffer[1] == L'!')) {

        //
        // There should be no way to add extra layers to the list,
        // So we should leave it alone.
        //
        return;
    }

    //
    // We need to set the environment variable.
    //
    if (pwszName != NULL) {

        RtlInitUnicodeString(&EnvValue, pwszName);

        status = RtlSetEnvironmentVariable(NULL, &EnvName, &EnvValue);
        if (NT_SUCCESS(status)) {
            DPF(dlInfo, "[SeiSetLayerEnvVar] Env var set __COMPAT_LAYER=\"%S\"\n", pwszName);
        } else {
            DPF(dlError, "[SeiSetLayerEnvVar] Failed to set __COMPAT_LAYER. 0x%X\n", status);
        }
    }
}


BOOL
SeiAddInternalHooks(
    DWORD dwCounter
    )
/*++
    Return: FALSE if the internal hooks have been already added, TRUE otherwise

    Desc:   BUGBUG
--*/
{
    if (g_bInternalHooksUsed) {
        return FALSE;
    }

    g_bInternalHooksUsed = TRUE;

    ZeroMemory(g_IntHookAPI, sizeof(HOOKAPI) * IHA_COUNT);
    ZeroMemory(g_IntHookEx, sizeof(HOOKAPIEX) * IHA_COUNT);

    g_IntHookAPI[IHA_GetProcAddress].pszModule       = "kernel32.dll";
    g_IntHookAPI[IHA_GetProcAddress].pszFunctionName = "GetProcAddress";
    g_IntHookAPI[IHA_GetProcAddress].pfnNew          = (PVOID)StubGetProcAddress;
    g_IntHookAPI[IHA_GetProcAddress].pHookEx         = &g_IntHookEx[IHA_GetProcAddress];
    g_IntHookAPI[IHA_GetProcAddress].pHookEx->dwShimID = dwCounter;

#ifdef SE_WIN2K

    g_IntHookAPI[IHA_LoadLibraryA].pszModule         = "kernel32.dll";
    g_IntHookAPI[IHA_LoadLibraryA].pszFunctionName   = "LoadLibraryA";
    g_IntHookAPI[IHA_LoadLibraryA].pfnNew            = (PVOID)StubLoadLibraryA;
    g_IntHookAPI[IHA_LoadLibraryA].pHookEx           = &g_IntHookEx[IHA_LoadLibraryA];
    g_IntHookAPI[IHA_LoadLibraryA].pHookEx->dwShimID = dwCounter;

    g_IntHookAPI[IHA_LoadLibraryW].pszModule         = "kernel32.dll";
    g_IntHookAPI[IHA_LoadLibraryW].pszFunctionName   = "LoadLibraryW";
    g_IntHookAPI[IHA_LoadLibraryW].pfnNew            = (PVOID)StubLoadLibraryW;
    g_IntHookAPI[IHA_LoadLibraryW].pHookEx           = &g_IntHookEx[IHA_LoadLibraryW];
    g_IntHookAPI[IHA_LoadLibraryW].pHookEx->dwShimID = dwCounter;

    g_IntHookAPI[IHA_LoadLibraryExA].pszModule       = "kernel32.dll";
    g_IntHookAPI[IHA_LoadLibraryExA].pszFunctionName = "LoadLibraryExA";
    g_IntHookAPI[IHA_LoadLibraryExA].pfnNew          = (PVOID)StubLoadLibraryExA;
    g_IntHookAPI[IHA_LoadLibraryExA].pHookEx         = &g_IntHookEx[IHA_LoadLibraryExA];
    g_IntHookAPI[IHA_LoadLibraryExA].pHookEx->dwShimID = dwCounter;

    g_IntHookAPI[IHA_LoadLibraryExW].pszModule       = "kernel32.dll";
    g_IntHookAPI[IHA_LoadLibraryExW].pszFunctionName = "LoadLibraryExW";
    g_IntHookAPI[IHA_LoadLibraryExW].pfnNew          = (PVOID)StubLoadLibraryExW;
    g_IntHookAPI[IHA_LoadLibraryExW].pHookEx         = &g_IntHookEx[IHA_LoadLibraryExW];
    g_IntHookAPI[IHA_LoadLibraryExW].pHookEx->dwShimID = dwCounter;

    g_IntHookAPI[IHA_FreeLibrary].pszModule          = "kernel32.dll";
    g_IntHookAPI[IHA_FreeLibrary].pszFunctionName    = "FreeLibrary";
    g_IntHookAPI[IHA_FreeLibrary].pfnNew             = (PVOID)StubFreeLibrary;
    g_IntHookAPI[IHA_FreeLibrary].pHookEx            = &g_IntHookEx[IHA_FreeLibrary];
    g_IntHookAPI[IHA_FreeLibrary].pHookEx->dwShimID  = dwCounter;

#endif // SE_WIN2K

    //
    // Add the info for our internal hook
    //
    g_pShimInfo[dwCounter].dwHookedAPIs = IHA_COUNT;
    g_pShimInfo[dwCounter].pDllBase     = g_pShimEngModHandle;
    g_pShimInfo[dwCounter].pLdrEntry    = g_pShimEngLdrEntry;
    g_pShimInfo[dwCounter].eInExMode    = INCLUDE_ALL;
    
    wcscpy(g_pShimInfo[dwCounter].wszName, L"SHIMENG.DLL");

    g_pHookArray[dwCounter] = g_IntHookAPI;

    return TRUE;
}

void
NotifyShims(
    int      nReason,
    UINT_PTR extraInfo
    )
{
    DWORD           i, j;
    NTSTATUS        status;
    ANSI_STRING     ProcedureNameString;
    PFNNOTIFYSHIMS  pfnNotifyShims = NULL;

    for (i = 0; i < g_dwShimsCount; i++) {

        for (j = 0; j < i; j++) {
            if (g_pShimInfo[i].pDllBase == g_pShimInfo[j].pDllBase) {
                break;
            }
        }

        if (i == j && g_pShimInfo[i].pLdrEntry != g_pShimEngLdrEntry) {
            //
            // Get the NotifyShims entry point
            //
            RtlInitString(&ProcedureNameString, "NotifyShims");

            status = LdrGetProcedureAddress(g_pShimInfo[i].pDllBase,
                                            &ProcedureNameString,
                                            0,
                                            (PVOID*)&pfnNotifyShims);

            if (!NT_SUCCESS(status) || pfnNotifyShims == NULL) {
                DPF(dlError,
                    "[NotifyShims] Failed to get 'NotifyShims' address, DLL \"%S\"\n",
                    g_pShimInfo[i].wszName);
            } else {
                //
                // Call the notification function.
                //
                (*pfnNotifyShims)(nReason, extraInfo);
            }
        }
    }

    return;
}


void
NotifyShimDlls(
    void
    )
/*++
    Return: void

    Desc:   Notify the shim DLLs that all the static linked modules have run
            their init routines.
--*/
{
    NotifyShims(SN_STATIC_DLLS_INITIALIZED, 0);

#ifdef SE_WIN2K
    //
    // On Win2k we need to restore the code at the entry point.
    //
    RestoreOriginalCode();
#endif // SE_WIN2K

    return;
}



BOOL
SeiGetExeName(
    PPEB   Peb,
    LPWSTR pwszExeName
    )
/*++
    Return: BUGBUG

    Desc:   BUGBUG
--*/
{
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY           Head;

    Head = &Peb->Ldr->InLoadOrderModuleList;
    Head = Head->Flink;

    Entry = CONTAINING_RECORD(Head, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

    wcscpy(pwszExeName, Entry->FullDllName.Buffer);

    //
    // Save the exe name in our global
    //
    wcscpy(g_szExeName, Entry->BaseDllName.Buffer);

#ifdef SE_WIN2K
    InjectNotificationCode(Entry->EntryPoint);
#endif // SE_WIN2K

    return TRUE;
}

#ifndef SE_WIN2K

int
SE_IsShimDll(
    IN  PVOID pDllBase          // The address of a loaded DLL
    )
/*++
    Return: TRUE if the DLL is one of our shim DLLs

    Desc:   This function checks to see if a DLL is one of the shim DLLs
            loaded in this process.
--*/
{
    DWORD i;

    for (i = 0; i < g_dwShimsCount; i++) {
        if (g_pShimInfo[i].pDllBase == pDllBase) {
            return 1;
        }
    }
    
    //
    // Special hack for the apphelp case
    //
    if (pDllBase == g_hApphelpDllHelper) {
        return 1;
    }
    
    return 0;
}


void
SeiSetEntryProcessed(
    IN  PPEB Peb
    )
/*++
    Return: void

    Desc:   This function hacks the loader list of loaded DLLs and marks them
            to tell the loader that they executed their init routines even if
            that is not the case. This needs to be done so that our shim mechanism
            is effective before the staticly loaded module get to execute their
            init routines.
--*/
{
    PLIST_ENTRY           LdrHead;
    PLIST_ENTRY           LdrNext;
    PLDR_DATA_TABLE_ENTRY LdrEntry;

    if (g_bComPlusImage) {
        //
        // COM+ images mess with the loader in ntdll. Don't step on ntdll's
        // toes by messing with LDRP_ENTRY_PROCESSED.
        //
        return;
    }

    //
    // Loop through the loaded modules and set LDRP_ENTRY_PROCESSED as
    // needed. Don't do this for ntdll.dll and kernel32.dll.
    // This needs to be done so when we load the shim DLLs the routines for
    // the statically linked libraries don't get called.
    //
    LdrHead = &Peb->Ldr->InInitializationOrderModuleList;

    LdrNext = LdrHead->Flink;

    while (LdrNext != LdrHead) {

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InInitializationOrderLinks);

        if (RtlCompareUnicodeString(&Kernel32String, &LdrEntry->BaseDllName, TRUE) != 0 &&
            RtlCompareUnicodeString(&VerifierdllString, &LdrEntry->BaseDllName, TRUE) != 0 &&
            RtlCompareUnicodeString(&NtdllString, &LdrEntry->BaseDllName, TRUE) != 0 &&
            !SE_IsShimDll(LdrEntry->DllBase) &&
            _wcsicmp(LdrEntry->BaseDllName.Buffer, g_wszShimDllInLoading) != 0) {

            LdrEntry->Flags |= LDRP_ENTRY_PROCESSED;

            DPF(dlWarning,
                "[SeiSetEntryProcessed] Touching        0x%X \"%S\"\n",
                LdrEntry->DllBase,
                LdrEntry->BaseDllName.Buffer);
        } else {
            DPF(dlWarning,
                "[SeiSetEntryProcessed] Don't mess with 0x%X \"%S\"\n",
                LdrEntry->DllBase,
                LdrEntry->BaseDllName.Buffer);
        }

        LdrNext = LdrEntry->InInitializationOrderLinks.Flink;
    }

#if DBG

    DPF(dlInfo, "[SeiSetEntryProcessed] In memory:\n");

    LdrHead = &Peb->Ldr->InMemoryOrderModuleList;

    LdrNext = LdrHead->Flink;

    while (LdrNext != LdrHead) {

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        DPF(dlInfo,
            "\t0x%X \"%S\"\n",
            LdrEntry->DllBase,
            LdrEntry->BaseDllName.Buffer);

        LdrNext = LdrEntry->InMemoryOrderLinks.Flink;
    }


    DPF(dlInfo, "\n[SeiSetEntryProcessed] In load:\n");

    LdrHead = &Peb->Ldr->InLoadOrderModuleList;

    LdrNext = LdrHead->Flink;

    while (LdrNext != LdrHead) {

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

        DPF(dlInfo,
            "\t0x%X \"%S\"\n",
            LdrEntry->DllBase,
            LdrEntry->BaseDllName.Buffer);

        LdrNext = LdrEntry->InLoadOrderLinks.Flink;
    }
#endif // DBG

}

void
SeiResetEntryProcessed(
    PPEB Peb
    )
/*++
    Return: void

    Desc:   This function restores the flag in the loader's list
            of loaded DLLs that tells they need to run their init
            routines (see LdrpSetEntryProcessed)
--*/
{
    PLIST_ENTRY    LdrHead;
    PLIST_ENTRY    LdrNext;

    if (g_bComPlusImage) {
        //
        // COM+ images mess with the loader in ntdll. Don't step on ntdll's
        // toes by messing with LDRP_ENTRY_PROCESSED.
        //
        return;
    }
    
    //
    // Loop through the loaded modules and remove LDRP_ENTRY_PROCESSED as
    // needed. Don't do this for ntdll.dll, kernel32.dll and all the shim DLLs
    //
    LdrHead = &Peb->Ldr->InInitializationOrderModuleList;

    LdrNext = LdrHead->Flink;

    while (LdrNext != LdrHead) {

        PLDR_DATA_TABLE_ENTRY LdrEntry;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InInitializationOrderLinks);

        if (RtlCompareUnicodeString(&Kernel32String, &LdrEntry->BaseDllName, TRUE) != 0 &&
            RtlCompareUnicodeString(&VerifierdllString, &LdrEntry->BaseDllName, TRUE) != 0 &&
            RtlCompareUnicodeString(&NtdllString, &LdrEntry->BaseDllName, TRUE) != 0 &&
            LdrEntry->DllBase != g_pShimEngModHandle &&
            !SE_IsShimDll(LdrEntry->DllBase)) {

            LdrEntry->Flags &= ~LDRP_ENTRY_PROCESSED;

            DPF(dlWarning,
                "[SeiResetEntryProcessed] Reseting        \"%S\"\n",
                LdrEntry->BaseDllName.Buffer);
        } else {
            DPF(dlWarning,
                "[SeiResetEntryProcessed] Don't mess with \"%S\"\n",
                LdrEntry->BaseDllName.Buffer);
        }

        LdrNext = LdrEntry->InInitializationOrderLinks.Flink;
    }
}

void
SE_GetProcAddress(
    PVOID* pProcedureAddress    // Pointer containing the return from the original
                                // LdrGetProcedureAddress. This  functions fils this
                                // pointer with the eventual replacement from the
                                // HOOKAPI arrays
    )
/*++
    Return: void

    Desc:   Scans HOOKAPI arrays for pfnOld and return pfnNew if this is
            a shimmed API
--*/
{
    return;
    UNREFERENCED_PARAMETER(pProcedureAddress);
}

void
SE_DllLoaded(
    PLDR_DATA_TABLE_ENTRY LdrEntry
    )
{
    if (g_bShimInitialized) {

#if DBG
        DWORD i;

        //
        // Was this DLL already loaded ?
        //
        for (i = 0; i < g_dwHookedModuleCount; i++) {
            if (LdrEntry->DllBase == g_hHookedModules[i].pDllBase) {
                DPF(dlError,
                    "[SE_DllLoaded] DLL \"%s\" was already loaded.\n",
                    g_hHookedModules[i].szModuleName);
            }
        }
#endif // DBG

        DPF(dlInfo,
            "[SE_DllLoaded] AFTER INIT. loading DLL \"%S\".\n",
            LdrEntry->BaseDllName.Buffer);

        PatchNewModules(FALSE);

    } else if (g_bShimDuringInit) {
        DPF(dlInfo,
            "[SE_DllLoaded] INIT. loading DLL \"%S\".\n",
            LdrEntry->BaseDllName.Buffer);

        SeiSetEntryProcessed(NtCurrentPeb());
    }

    return;

    UNREFERENCED_PARAMETER(LdrEntry);
}


void
SE_DllUnloaded(
    PLDR_DATA_TABLE_ENTRY Entry // The pointer to the loader entry for the DLL that is
                                // being unloaded.
    )
/*++
    Return: void

    Desc:   This notification comes from LdrUnloadDll. This function looks up
            to see if we have HOOKAPI that have their original functions in
            this DLL. If that is the case then HOOKAPI.pfnOld is set back to
            NULL.
--*/
{
    DWORD       i, j;
    CHAR        szBaseDllName[128];
    ANSI_STRING AnsiString = { 0, sizeof(szBaseDllName), szBaseDllName };

    if (g_dwShimsCount == 0) {
        return;
    }

    //
    // See if this DLL is one that we hooked.
    //
    for (i = 0; i < g_dwHookedModuleCount; i++) {
        if (g_hHookedModules[i].pDllBase == Entry->DllBase) {
            break;
        }
    }

    if (i >= g_dwHookedModuleCount) {
        return;
    }

    DPF(dlWarning,
        "[SEi_DllUnloaded] Removing hooked DLL 0x%p \"%S\"\n",
        Entry->DllBase,
        Entry->BaseDllName.Buffer);

    //
    // Take it out of the list of hooked modules.
    //
    for (j = i; j < g_dwHookedModuleCount - 1; j++) {
        RtlCopyMemory(g_hHookedModules + j, g_hHookedModules + j + 1, sizeof(HOOKEDMODULE));
    }

    g_hHookedModules[j].pDllBase = NULL;
    strcpy(g_hHookedModules[j].szModuleName, "removed!");

    g_dwHookedModuleCount--;

    //
    // Remove the pfnOld from the HOOKAPIs that were
    // resolved to this DLL.
    //
    if (!NT_SUCCESS(RtlUnicodeStringToAnsiString(&AnsiString, &Entry->BaseDllName, FALSE))) {
        DPF(dlError,
            "[SEi_DllUnloaded] Cannot convert \"%S\" to ANSI\n",
            Entry->BaseDllName.Buffer);
        return;
    }

    SeiRemoveDll(szBaseDllName);
}

BOOLEAN
SE_InstallAfterInit(
    IN  PUNICODE_STRING UnicodeImageName,   // The name of the starting EXE
    IN  PVOID           pShimExeData        // The pointer provided by apphelp.dll
    )
/*++
    Return: FALSE if the shim engine should be unloaded, TRUE otherwise

    Desc:   Calls the notification function for static linked modules.
--*/
{
    NotifyShimDlls();

    if (g_dwShimsCount == 0 && g_dwMemoryPatchCount == 0) {
        return FALSE;
    }

    return TRUE;

    UNREFERENCED_PARAMETER(UnicodeImageName);
    UNREFERENCED_PARAMETER(pShimExeData);
}

#endif // SE_WIN2K

LPWSTR
SeiGetShortName(
    IN  LPCWSTR pwszDLLPath
    )
/*++
    Return: The pointer to the short name from the full path

    Desc:   Gets the pointer to the short name from the full path.
--*/
{
    LPWSTR pwsz;

    pwsz = (LPWSTR)pwszDLLPath + wcslen(pwszDLLPath);

    while (pwsz >= pwszDLLPath) {
        if (*pwsz == L'\\') {
            break;
        }
        pwsz--;
    }

    return pwsz + 1;
}


BOOL
SeiInitGlobals(
    IN  LPCWSTR lpszFullPath
    )
{
    PPEB Peb = NtCurrentPeb();
    BOOL bResult;
    BOOL bWow64 = FALSE;

    if (g_bInitGlobals) {
        return TRUE;
    }

    //
    // Nab the system32 and windows directory path and length.
    //
    wcscpy(g_szSystem32, USER_SHARED_DATA->NtSystemRoot);
    
    IsWow64Process(GetCurrentProcess(), &bWow64);
    
    if (bWow64) {
        wcscat(g_szSystem32, L"\\SysWow64\\");
    } else {
        wcscat(g_szSystem32, L"\\System32\\");
    }

    g_dwSystem32StrLen = wcslen(g_szSystem32);

    wcscpy(g_szSxS, USER_SHARED_DATA->NtSystemRoot);
    wcscat(g_szSxS, L"\\WinSxS\\");

    g_dwSxSStrLen = wcslen(g_szSxS);

    wcscpy(g_szWindir, USER_SHARED_DATA->NtSystemRoot);
    wcscat(g_szWindir, L"\\");
    g_dwWindirStrLen = wcslen(g_szWindir);

    wcscpy(g_szCmdExePath, g_szSystem32);
    wcscat(g_szCmdExePath, L"cmd.exe");

    //
    // Initialize our global function pointers.
    //
    // This is done because these functions may be hooked by a shim and
    // we don't want to trip over a shim hook internally. If one of these
    // functions is hooked, these global pointers will be overwritten
    // with thunk addresses.
    //
    g_pfnRtlAllocateHeap = RtlAllocateHeap;
    g_pfnRtlFreeHeap     = RtlFreeHeap;

    //
    // Set up our own shim heap.
    //
    g_pShimHeap = RtlCreateHeap(HEAP_GROWABLE,
                                0,          // location isn't important
                                64 * 1024,  // 64k is the initial heap size
                                8 * 1024,   // bring in an 1/8 of the reserved pages
                                0,
                                0);
    if (g_pShimHeap == NULL) {
        //
        // We didn't get our heap.
        //
        DPF(dlError, "[SeiInitGlobals] Can't create shim heap.\n");
        return FALSE;
    }

    //
    // Get the DLL handle for this shim engine
    //
#ifdef SE_WIN2K
    bResult = SeiGetModuleHandle("Shim.dll", &g_pShimEngModHandle);
#else
    bResult = SeiGetModuleHandle("ShimEng.dll", &g_pShimEngModHandle);
#endif // SE_WIN2K

    if (!bResult) {
        DPF(dlError, "[SeiInitGlobals] Failed to get the shim engine's handle\n");
        return FALSE;
    }

    g_pShimEngLdrEntry = SeiGetLoaderEntry(Peb, g_pShimEngModHandle);

    //
    // Setup the log file.
    //
    SeiInitFileLog(lpszFullPath);

    g_bInitGlobals = TRUE;

    return TRUE;
}


void
SeiLayersCheck(
    IN  LPCWSTR         lpszFullPath,
    OUT LPBOOL          lpbApplyExes,
    OUT LPBOOL          lpbApplyToSystemExes,
    OUT SDBQUERYRESULT* psdbQuery
    )
{
    BOOL bLayerEnvSet = FALSE;
    BOOL bCmdExe      = FALSE;

    //
    // Get the flags from the environment variable, if any.
    //
    bLayerEnvSet = SeiCheckLayerEnvVarFlags(lpbApplyExes, lpbApplyToSystemExes);

    //
    // make sure we are not cmd.exe
    //
    bCmdExe = (_wcsicmp(lpszFullPath, g_szCmdExePath) == 0);

    //
    // Unless the environment variable has the flag that allows layer shimming of
    // system exes, check for the EXE being in System32 or Windir.
    // If it is, disable any layer that is coming from the environment variable,
    // and clear the environment variable so the layer won't be propagated.
    //
    if (bLayerEnvSet && !*lpbApplyToSystemExes) {
        if (g_dwSystem32StrLen &&
            _wcsnicmp(g_szSystem32, lpszFullPath, g_dwSystem32StrLen) == 0) {

            //
            // In this case, we'll exclude anything in System32 or any
            // subdirectories.
            //
            DPF(dlWarning,
                "[SeiLayersCheck] Won't apply layer to \"%S\" because it is in System32.\n",
                lpszFullPath);

            psdbQuery->atrLayers[0] = TAGREF_NULL;
            if (!bCmdExe) {
                SeiClearLayerEnvVar();
            }

        } else if (!*lpbApplyToSystemExes &&
                   g_dwWindirStrLen &&
                   _wcsnicmp(g_szWindir, lpszFullPath, g_dwWindirStrLen) == 0) {

            DWORD i;
            BOOL  bInWindir = TRUE;

            //
            // The app is somewhere in the windows tree, but we only want to exclude
            // the windows directory, not the subdirectories.
            //
            for (i = g_dwWindirStrLen; lpszFullPath[i] != 0; ++i) {
                if (lpszFullPath[i] == L'\\') {
                    //
                    // It's in a subdirectory.
                    //
                    bInWindir = FALSE;
                    break;
                }
            }

            if (bInWindir) {
                DPF(dlWarning,
                    "[SeiLayersCheck] Won't apply layer(s) to \"%S\" because"
                    " it is in Windows dir.\n",
                    lpszFullPath);
                psdbQuery->atrLayers[0] = TAGREF_NULL;
                if (!bCmdExe) {
                    SeiClearLayerEnvVar();
                }
            }
        }
    }
}

void
SeiPropagateLayers(
    IN  HSDB            hSDB,
    IN  SDBQUERYRESULT* psdbQuery,
    IN  BOOL            bApplyExes,
    IN  BOOL            bApplyToSystemExes,
    OUT LPDWORD         lpdwShimsCount
    )
{
    int    i;
    WCHAR  szFullEnvVar[MAX_PATH];
    TAGREF trShimRef;

    //
    // Count the DLLs that trLayer uses, and put together the environment variable
    //
    szFullEnvVar[0] = 0;

    //
    // Make sure to propagate the flags.
    //
    if (!bApplyExes) {
        wcscat(szFullEnvVar, L"!");
    }

    if (bApplyToSystemExes) {
        wcscat(szFullEnvVar, L"#");
    }

    for (i = 0; i < SDB_MAX_LAYERS && psdbQuery->atrLayers[i] != TAGREF_NULL; ++i) {
        WCHAR* pszEnvVar;

        //
        // Get the environment var and tack it onto the full string
        //
        pszEnvVar = SeiGetLayerName(hSDB, psdbQuery->atrLayers[i]);

        if (pszEnvVar) {
            wcscat(szFullEnvVar, pszEnvVar);
            wcscat(szFullEnvVar, L" ");
        }

        //
        // Keep counting the dlls.
        //
        trShimRef = SdbFindFirstTagRef(hSDB, psdbQuery->atrLayers[i], TAG_SHIM_REF);

        while (trShimRef != TAGREF_NULL) {
            (*lpdwShimsCount)++;
            trShimRef = SdbFindNextTagRef(hSDB, psdbQuery->atrLayers[i], trShimRef);
        }
    }

    //
    // Set the layer environment variable if not set
    //
    if (szFullEnvVar[0] && psdbQuery->atrLayers[0]) {
        SeiSetLayerEnvVar(szFullEnvVar);
    }
}


BOOL
SeiGetShimCommandLine(
    HSDB    hSDB,
    TAGREF  trShimRef,
    LPSTR   lpszCmdLine
    )
{
    TAGREF          trCmdLine;
    WCHAR           wszCmdLine[SHIM_COMMAND_LINE_MAX_BUFFER];


    //
    // Check for command line
    //
    lpszCmdLine[0] = 0;

    trCmdLine = SdbFindFirstTagRef(hSDB, trShimRef, TAG_COMMAND_LINE);

    if (trCmdLine == TAGREF_NULL) {
        return FALSE;
    }

    wszCmdLine[0] = 0;

    if (SdbReadStringTagRef(hSDB, trCmdLine, wszCmdLine, SHIM_COMMAND_LINE_MAX_BUFFER)) {

        UNICODE_STRING  UnicodeString;
        ANSI_STRING     AnsiString = { 0, SHIM_COMMAND_LINE_MAX_BUFFER, lpszCmdLine };
        NTSTATUS        status;

        RtlInitUnicodeString(&UnicodeString, wszCmdLine);

        status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);

        //
        // If conversion is unsuccessful, reset to zero-length string.
        //
        if (!NT_SUCCESS(status)) {
            lpszCmdLine[0] = 0;
            return FALSE;
        }
    }

    return TRUE;
}

#ifndef SE_WIN2K

BOOL
SeiSetApphackFlags(
    HSDB            hSDB,
    SDBQUERYRESULT* psdbQuery
    )
{
    ULARGE_INTEGER  uliKernel;
    ULARGE_INTEGER  uliUser;
    BOOL            bUsingApphackFlags = FALSE;
    PPEB            Peb = NtCurrentPeb();

    SdbQueryFlagMask(hSDB, psdbQuery, TAG_FLAG_MASK_KERNEL, &uliKernel.QuadPart, NULL);
    SdbQueryFlagMask(hSDB, psdbQuery, TAG_FLAG_MASK_USER, &uliUser.QuadPart, NULL);

    Peb->AppCompatFlags.QuadPart     = uliKernel.QuadPart;
    Peb->AppCompatFlagsUser.QuadPart = uliUser.QuadPart;

    if (uliKernel.QuadPart != 0) {
        DPF(dlPrint, "[SeiSetApphackFlags] Using kernel apphack flags 0x%x.\n", uliKernel.LowPart);
        
        swprintf(g_szPipeData, L"%s - Using kernel apphack flags 0x%x",
                 g_szExeName,
                 uliKernel.LowPart);
        
        SeiSendDataToPipe();
        
        bUsingApphackFlags = TRUE;
    }

    if (uliUser.QuadPart != 0) {
        DPF(dlPrint, "[SeiSetApphackFlags] Using user apphack flags 0x%x.\n", uliUser.LowPart);
        
        swprintf(g_szPipeData, L"%s - Using user apphack flags 0x%x",
                 g_szExeName,
                 uliUser.LowPart);
        
        SeiSendDataToPipe();
        
        bUsingApphackFlags = TRUE;
    }

    return bUsingApphackFlags;
}

#endif

typedef struct tagTRSHIM {
    TAGREF trShimRef;
    BOOL   bPlaceholder;
} TRSHIM, *PTRSHIM;

typedef struct tagTRSHIMARRAY {
    int     nShimRefCount;
    int     nShimRefMax;
    TRSHIM* parrShimRef;
} TRSHIMARRAY, *PTRSHIMARRAY;

#define TR_DELTA    4

BOOL
SeiAddShim(
    IN PTRSHIMARRAY pShimArray,
    IN TAGREF       trShimRef,
    IN BOOL         bPlaceholder
    )
{
    if (pShimArray->nShimRefCount >= pShimArray->nShimRefMax) {
        PTRSHIM parrShimRef;
        DWORD   dwSize;

        dwSize = (pShimArray->nShimRefMax + TR_DELTA) * sizeof(TRSHIM);

        parrShimRef = (PTRSHIM)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                       HEAP_ZERO_MEMORY,
                                                       dwSize);

        if (parrShimRef == NULL) {
            DPF(dlError, "[SeiAddShim] Failed to allocate %d bytes.\n", dwSize);
            return FALSE;
        }

        memcpy(parrShimRef, pShimArray->parrShimRef, pShimArray->nShimRefMax * sizeof(TRSHIM));

        pShimArray->nShimRefMax += TR_DELTA;

        (*g_pfnRtlFreeHeap)(g_pShimHeap, 0, pShimArray->parrShimRef);

        pShimArray->parrShimRef = parrShimRef;
    }

    pShimArray->parrShimRef[pShimArray->nShimRefCount].trShimRef    = trShimRef;
    pShimArray->parrShimRef[pShimArray->nShimRefCount].bPlaceholder = bPlaceholder;

    (pShimArray->nShimRefCount)++;

    return TRUE;
}

PTRSHIMARRAY
SeiBuildShimRefArray(
    IN  HSDB            hSDB,
    IN  SDBQUERYRESULT* psdbQuery,
    OUT LPDWORD         lpdwShimCount,
    IN  BOOL            bApplyExes,
    IN  BOOL            bApplyToSystemExes,
    IN  BOOL            bIsSetup
    )
{
    DWORD        dw;
    TAGREF       trExe;
    TAGREF       trLayer;
    TAGREF       trShimRef;
    DWORD        dwShimsCount = 0;
    WCHAR        szFullEnvVar[MAX_PATH];
    PTRSHIMARRAY pShimArray;

    *lpdwShimCount = 0;

    pShimArray = (PTRSHIMARRAY)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                       HEAP_ZERO_MEMORY,
                                                       sizeof(TRSHIMARRAY));
    if (pShimArray == NULL) {
        DPF(dlError, "[SeiBuildShimRefArray] Failed to allocate %d bytes.\n", sizeof(TRSHIMARRAY));
        return NULL;
    }

    for (dw = 0; dw < SDB_MAX_EXES; dw++) {

        trExe = psdbQuery->atrExes[dw];

        if (trExe == TAGREF_NULL) {
            break;
        }

        //
        // Count the SHIMs that this EXE uses.
        //
        trShimRef = SdbFindFirstTagRef(hSDB, trExe, TAG_SHIM_REF);

        while (trShimRef != TAGREF_NULL) {

            SeiAddShim(pShimArray, trShimRef, FALSE);
            dwShimsCount++;

            trShimRef = SdbFindNextTagRef(hSDB, trExe, trShimRef);
        }
    }

    //
    // Count the DLLs that trLayer uses, and put together the environment variable
    //
    szFullEnvVar[0] = 0;

    //
    // Make sure to propagate the flags.
    //
    if (!bApplyExes) {
        wcscat(szFullEnvVar, L"!");
    }

    if (bApplyToSystemExes) {
        wcscat(szFullEnvVar, L"#");
    }

    for (dw = 0; dw < SDB_MAX_LAYERS && psdbQuery->atrLayers[dw] != TAGREF_NULL; dw++) {
        WCHAR* pszEnvVar;

        trLayer = psdbQuery->atrLayers[dw];

        //
        // Get the environment var and tack it onto the full string
        //
        pszEnvVar = SeiGetLayerName(hSDB, trLayer);

        if (bIsSetup && !wcscmp(pszEnvVar, L"LUA")) {

            //
            // If the user is trying to apply the LUA layer to a setup program,
            // we ignore it.
            //
            continue;
        }

        if (pszEnvVar) {
            wcscat(szFullEnvVar, pszEnvVar);
            wcscat(szFullEnvVar, L" ");
        }

        //
        // Keep counting the shims.
        //
        trShimRef = SdbFindFirstTagRef(hSDB, trLayer, TAG_SHIM_REF);

        while (trShimRef != TAGREF_NULL) {

            SeiAddShim(pShimArray, trShimRef, FALSE);
            dwShimsCount++;

            trShimRef = SdbFindNextTagRef(hSDB, trLayer, trShimRef);
        }
    }

    //
    // Set the layer environment variable if not set
    //
    if (szFullEnvVar[0] && psdbQuery->atrLayers[0]) {
        SeiSetLayerEnvVar(szFullEnvVar);
    }

    *lpdwShimCount = dwShimsCount;

    return pShimArray;
}

BOOL
SeiIsSetup(
    IN  LPCWSTR pwszFullPath
    )
{
    WCHAR   wszModuleName[MAX_PATH];
    LPWSTR  pwszModuleName = NULL;

    wcsncpy(wszModuleName, pwszFullPath, MAX_PATH);
    wszModuleName[MAX_PATH - 1] = 0;

    pwszModuleName = wcsrchr(wszModuleName, L'\\') + 1;
    _wcslwr(pwszModuleName);

    if (wcsstr(pwszModuleName, L"setup") || wcsstr(pwszModuleName, L"install")) {

        return TRUE;

    } else {

        LPWSTR pwsz;

        if (pwsz = wcsstr(pwszModuleName, L"_ins")) {

            if (wcsstr(pwsz + 4, L"_mp")) {

                return TRUE;
            }
        }
    }

    return FALSE;
}

BOOL
SeiInit(
    IN  LPCWSTR         pwszFullPath,
    IN  HSDB            hSDB,
    OUT SDBQUERYRESULT* psdbQuery,
    IN  LPCSTR          lpszModuleToShim,
    IN  BOOL            bDynamic
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Injects all the shims and patches specified for this EXE
            in the database.
--*/
{
    PPEB         Peb = NtCurrentPeb();
    BOOL         bResult = FALSE;
    TAGREF       trShimRef;
    NTSTATUS     status;
    DWORD        dwCounter = 0;
    WCHAR        wszDLLPath[MAX_PATH];
    WCHAR        wszShimName[MAX_PATH];
    CHAR         szCmdLine[SHIM_COMMAND_LINE_MAX_BUFFER];
    DWORD        dwTotalHooks = 0;
    BOOL         bApplyExes = TRUE;
    BOOL         bApplyToSystemExes = FALSE;
    BOOL         bUsingApphackFlags = FALSE;
    DWORD        dwAPIsHooked = 0;
    DWORD        dw;
    DWORD        dwShimsCount = 0;
    PHOOKAPI*    pHookArray = NULL;
    PSHIMINFO    pShimInfo;
    int          nShimRef;
    PTRSHIMARRAY pShimArray = NULL;
    BOOL         bIsSetup;

    g_bShimDuringInit = TRUE;

#ifndef SE_WIN2K
    if (!bDynamic) {
        //
        // Mark almost all loaded DLLs as if they already run their init routines.
        //
        SeiSetEntryProcessed(Peb);
        
        if (psdbQuery->trAppHelp) {
            if (!SeiDisplayAppHelp(hSDB, psdbQuery)) {
                //
                // We should never end up here because SeiDisplayApphelp
                // calls TerminateProcess before returning FALSE.
                //
                goto cleanup;
            }
        }
    }

#endif // SE_WIN2K

    bIsSetup = SeiIsSetup(pwszFullPath);

    if (!SeiInitGlobals(pwszFullPath)) {
        DPF(dlError, "[SeiInit] Failed to initialize global data\n");
        goto cleanup;
    }

    SeiLayersCheck(pwszFullPath, &bApplyExes, &bApplyToSystemExes, psdbQuery);

    //
    // This should be taken care of by apphelp, but
    // we're taking a belt-and-suspenders approach here.
    //
    if (!bApplyExes) {
        psdbQuery->atrExes[0] = TAGREF_NULL;
    }

    pShimArray = SeiBuildShimRefArray(hSDB,
                                      psdbQuery,
                                      &dwShimsCount,
                                      bApplyExes,
                                      bApplyToSystemExes,
                                      bIsSetup);

    if (pShimArray == NULL) {
        DPF(dlError, "[SeiInit] Failed to build the shimref array\n");
        goto cleanup;
    }

    //
    // Set some global variables so we'll know if we're using a layer,
    // an exe entry, or both.
    //
    // These variables are only used for debug purposes.
    //
    if (psdbQuery->atrExes[0] != TAGREF_NULL) {
        g_bUsingExe = TRUE;
    }

    if (psdbQuery->atrLayers[0] != TAGREF_NULL) {
        g_bUsingLayer = TRUE;
    }

    //
    // Debug spew for matching notification.
    //
    DPF(dlPrint, "[SeiInit] Matched entry: \"%S\"\n", pwszFullPath);

    //
    // Send the name of the process to the pipe
    //
    swprintf(g_szPipeData, L"New process created: %s", pwszFullPath);
    SeiSendDataToPipe();

#ifndef SE_WIN2K

    //
    // Get the apphack flags. These can only be enabled if the shimengine is not
    // dynamically initialized.
    //
    if (!bDynamic && !(bUsingApphackFlags = SeiSetApphackFlags(hSDB, psdbQuery))) {
        DPF(dlPrint, "[SeiInit] No apphack flags for this app \"%S\".\n", pwszFullPath);
    }

#endif // SE_WIN2K

    //
    // See if there are any shims.
    //
    if (dwShimsCount == 0) {
        DPF(dlPrint, "[SeiInit] No new SHIMs for this app \"%S\".\n", pwszFullPath);
        goto OnlyPatches;
    }

    //
    // We need to load the global inclusion/exclusion list if any.
    //
    SeiBuildGlobalInclList(hSDB);

    if (g_dwShimsCount == 0) {
        //
        // Increment the shims count to allow for our internal stubs.
        // Also reserve space for up to MAX_DYNAMIC_SHIMS more dynamic shims.
        //
        dwShimsCount++;

        g_dwMaxShimsCount = dwShimsCount + MAX_DYNAMIC_SHIMS;

        //
        // Allocate a storage pointer for the hook information.
        //
        g_pHookArray = (PHOOKAPI*)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                          HEAP_ZERO_MEMORY,
                                                          sizeof(PHOOKAPI) * g_dwMaxShimsCount);
        if (g_pHookArray == NULL) {
            DPF(dlError,
                "[SeiInit] Failure allocating %d bytes for the hook array\n",
                sizeof(PHOOKAPI) * g_dwMaxShimsCount);
            goto cleanup;
        }

        //
        // Allocate the array that keeps information about the shims.
        //
        g_pShimInfo = (PSHIMINFO)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                         HEAP_ZERO_MEMORY,
                                                         sizeof(SHIMINFO) * g_dwMaxShimsCount);
        if (g_pShimInfo == NULL) {
            DPF(dlError,
                "[SeiInit] Failure allocating %d bytes for the SHIMINFO array\n",
                sizeof(SHIMINFO) * g_dwMaxShimsCount);
            goto cleanup;
        }

        //
        // Point the local variables to the beginning of the arrays.
        //
        pHookArray = g_pHookArray;
        pShimInfo = g_pShimInfo;
    } else {

        if (g_dwShimsCount + dwShimsCount >= g_dwMaxShimsCount) {
            DPF(dlError, "[SeiInit] Too many shims\n");
            goto cleanup;
        }

        //
        // Point the local variables to the end of the existing arrays.
        //
        pHookArray = g_pHookArray + g_dwShimsCount;
        pShimInfo = g_pShimInfo + g_dwShimsCount;
    }

    //
    // Get the first shim.
    //
    nShimRef = 0;

    while (nShimRef < pShimArray->nShimRefCount) {

        PVOID               pModuleHandle = NULL;
        UNICODE_STRING      UnicodeString;
        ANSI_STRING         ProcedureNameString;
        PFNGETHOOKAPIS      pfnGetHookApis = NULL;
        TAGREF              trShimName = TAGREF_NULL;
        LPWSTR              pwszDllShortName;
        DWORD               i, dwShimIndex;

        trShimRef = pShimArray->parrShimRef[nShimRef].trShimRef;

        //
        // Retrieve the shim name.
        //
        wszShimName[0] = 0;
        trShimName = SdbFindFirstTagRef(hSDB, trShimRef, TAG_NAME);
        if (trShimName == TAGREF_NULL) {
            DPF(dlError, "[SeiInit] Could not retrieve shim name tag from entry.\n");
            goto cleanup;
        }

        if (!SdbReadStringTagRef(hSDB, trShimName, wszShimName, MAX_PATH)) {
            DPF(dlError, "[SeiInit] Could not retrieve shim name from entry.\n");
            goto cleanup;
        }

        //
        // Check for duplicate shims.
        //
        for (i = 0; i < g_dwShimsCount + dwCounter; ++i) {
            if (_wcsnicmp(g_pShimInfo[i].wszName, wszShimName, MAX_SHIM_NAME_LEN) == 0) {
                dwShimIndex = i;
                goto nextShim;
            }
        }

        //
        // Save off the name of the shim.
        //
        wcsncpy(pShimInfo[dwCounter].wszName, wszShimName, MAX_SHIM_NAME_LEN);
        pShimInfo[dwCounter].wszName[MAX_SHIM_NAME_LEN] = 0;

        if (!SdbGetDllPath(hSDB, trShimRef, wszDLLPath)) {
            DPF(dlError, "[SeiInit] Failed to get DLL Path\n");
            goto cleanup;
        }

        pwszDllShortName = SeiGetShortName(wszDLLPath);

        RtlInitUnicodeString(&UnicodeString, wszDLLPath);

        //
        // Check if we already loaded this DLL.
        //
        status = LdrGetDllHandle(NULL,
                                 NULL,
                                 &UnicodeString,
                                 &pModuleHandle);

        if (!NT_SUCCESS(status)) {

            //
            // Load the DLL that hosts this shim.
            //

#ifndef SE_WIN2K
            //
            // Save the name of the DLL that we're about to load so we don't screw
            // it's init routine.
            //
            wcscpy(g_wszShimDllInLoading, pwszDllShortName);
#endif // SE_WIN2K

            status = LdrLoadDll(UNICODE_NULL, NULL, &UnicodeString, &pModuleHandle);

            if (!NT_SUCCESS(status)) {
                DPF(dlError,
                    "[SeiInit] Failed to load DLL \"%S\" Status 0x%lx\n",
                    wszDLLPath, status);
                goto cleanup;
            }

            DPF(dlPrint,
                "[SeiInit] Shim DLL 0x%X \"%S\" loaded\n",
                pModuleHandle,
                wszDLLPath);
        }

        DPF(dlPrint, "[SeiInit] Using SHIM \"%S!%S\"\n",
            wszShimName, pwszDllShortName);

        pShimInfo[dwCounter].pDllBase = pModuleHandle;

        //
        // Check for command line.
        //
        if (SeiGetShimCommandLine(hSDB, trShimRef, szCmdLine)) {
            DPF(dlPrint,
                "[SeiInit] Command line for Shim \"%S\" : \"%s\"\n",
                wszShimName,
                szCmdLine);
        }

        //
        // Send this shim name to the pipe
        //
        swprintf(g_szPipeData,
                 L"%s - Applying shim %s(%S) from %s",
                 g_szExeName,
                 wszShimName,
                 szCmdLine,
                 pwszDllShortName);
        
        SeiSendDataToPipe();
        
        //
        // Get the GetHookApis entry point.
        //
        RtlInitString(&ProcedureNameString, "GetHookAPIs");

        status = LdrGetProcedureAddress(pModuleHandle,
                                        &ProcedureNameString,
                                        0,
                                        (PVOID*)&pfnGetHookApis);

        if (!NT_SUCCESS(status) || pfnGetHookApis == NULL) {
            DPF(dlError,
                "[SeiInit] Failed to get 'GetHookAPIs' address, DLL \"%S\"\n",
                wszDLLPath);
            goto cleanup;
        }

        dwTotalHooks = 0;

        //
        // Call the proc and then store away its hook params.
        //
        pHookArray[dwCounter] = (*pfnGetHookApis)(szCmdLine, wszShimName, &dwTotalHooks);
        
        dwAPIsHooked += dwTotalHooks;

        DPF(dlInfo,
            "[SeiInit] GetHookAPIs returns %d hooks for DLL \"%S\" SHIM \"%S\"\n",
            dwTotalHooks, wszDLLPath, wszShimName);

        pShimInfo[dwCounter].dwHookedAPIs = dwTotalHooks;
        pShimInfo[dwCounter].pLdrEntry    = SeiGetLoaderEntry(Peb, pModuleHandle);

        if (dwTotalHooks > 0) {

            //
            // Initialize the HOOKAPIEX structure.
            //
            for (i = 0; i < dwTotalHooks; ++i) {
                PHOOKAPIEX pHookEx;

                pHookEx = (PHOOKAPIEX)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                              HEAP_ZERO_MEMORY,
                                                              sizeof(HOOKAPIEX));

                if (!pHookEx) {
                    DPF(dlError,
                        "[SeiInit] Failed to allocate %d bytes (HOOKAPIEX)\n",
                        sizeof(HOOKAPIEX));
                    goto cleanup;
                }

                pHookArray[dwCounter][i].pHookEx = pHookEx;
                pHookArray[dwCounter][i].pHookEx->dwShimID = g_dwShimsCount + dwCounter;
            }

#if DBG
            //
            // Give a debugger warning if uninitialized HOOKAPI structures
            // are used.
            //
            {
                DWORD dwUninitCount = 0;

                for (i = 0; i < dwTotalHooks; ++i) {
                    if (pHookArray[dwCounter][i].pszModule == NULL ||
                        pHookArray[dwCounter][i].pszFunctionName == NULL) {

                        dwUninitCount++;
                    }
                }

                if (dwUninitCount > 0) {
                    DPF(dlWarning,
                        "[SeiInit] Shim \"%S\" using %d uninitialized HOOKAPI structures.\n",
                        pShimInfo[dwCounter].wszName, dwUninitCount);
                }
            }
#endif // DBG
        }

        dwShimIndex = g_dwShimsCount + dwCounter;
        dwCounter++;

nextShim:
        //
        // Read the inclusion/exclusion list for this shim.
        //
        if (bDynamic && lpszModuleToShim != NULL) {

            if (!SeiBuildInclListWithOneModule(dwShimIndex, lpszModuleToShim)) {
                DPF(dlError,
                    "[SeiInit] Couldn't build the inclusion list w/ one module for Shim \"%S\"\n",
                    wszShimName);
                goto cleanup;
            }
        } else {
            if (!SeiBuildInclExclList(hSDB, trShimRef, dwShimIndex, pwszFullPath)) {
                DPF(dlError,
                    "[SeiInit] Couldn't build the inclusion/exclusion list for Shim \"%S\"\n",
                    wszShimName);
                goto cleanup;
            }
        }

        //
        // Go to the next shim ref.
        //
        nShimRef++;
    }

    if (dwAPIsHooked > 0) {
        //
        // We need to add our internal hooks
        //
        if (SeiAddInternalHooks(dwCounter)) {
            dwCounter++;
        }
    }

    //
    // Update the shim counter.
    //
    g_dwShimsCount += dwCounter;

OnlyPatches:

    for (dw = 0; dw < SDB_MAX_EXES; dw++) {

        if (psdbQuery->atrExes[dw] == TAGREF_NULL) {
            break;
        }

        //
        // Loop through available in-memory patches for this EXE.
        //
        SeiLoadPatches(hSDB, psdbQuery->atrExes[dw]);
    }

    if (g_dwMemoryPatchCount == 0) {
        DPF(dlPrint, "[SeiInit] No patches for this app \"%S\".\n", pwszFullPath);

    }

    if (g_dwMemoryPatchCount == 0 && g_dwShimsCount == 0 && !bUsingApphackFlags) {
        DPF(dlError, "[SeiInit] No fixes in the DB for this app \"%S\".\n", pwszFullPath);
        goto cleanup;
    }

    //
    // Walk the hook list and fixup available APIs
    //
    if (!PatchNewModules(bDynamic)) {
        DPF(dlError, "[SeiInit] Unsuccessful fixing up APIs, EXE \"%S\"\n", pwszFullPath);
        goto cleanup;
    }

    //
    // Notify the shims that static link DLLs have run their init routine.
    //
    if (bDynamic) {
        NotifyShims(SN_STATIC_DLLS_INITIALIZED, 1);
    }

    //
    // The shim has successfuly initialized
    //
    g_bShimInitialized = TRUE;
    bResult = TRUE;

cleanup:

    //
    // Cleanup
    //
    if (pShimArray) {
        if (pShimArray->parrShimRef) {
            (*g_pfnRtlFreeHeap)(g_pShimHeap, 0, pShimArray->parrShimRef);
        }
        (*g_pfnRtlFreeHeap)(g_pShimHeap, 0, pShimArray);
    }

    if (!bDynamic) {
        //
        // We can pass back any one of the exes. The first is fine.
        //
        if (psdbQuery->atrExes[0] != TAGREF_NULL) {
            SdbReleaseMatchingExe(hSDB, psdbQuery->atrExes[0]);
        }

        if (hSDB != NULL) {
            SdbReleaseDatabase(hSDB);
        }

#ifndef SE_WIN2K
        SeiResetEntryProcessed(Peb);
#endif // SE_WIN2K
    }

    g_bShimDuringInit = FALSE;

    if (!bResult) {
#if DBG
        if (!bUsingApphackFlags) {
            DbgPrint("[SeiInit] Shim engine failed to initialize.\n");
        }
#endif // DBG

        //
        // Unload the shim DLLs that are loaded so far.
        //
        // Don't do this during dynamic shimming.
        //
        if (!bDynamic) {
            if (g_pShimInfo != NULL) {
                for (dwCounter = 0; dwCounter < g_dwShimsCount; dwCounter++) {
                    if (g_pShimInfo[dwCounter].pDllBase == NULL) {
                        break;
                    }

                    LdrUnloadDll(g_pShimInfo[dwCounter].pDllBase);
                }
            }

            if (g_pShimHeap != NULL) {
                RtlDestroyHeap(g_pShimHeap);
                g_pShimHeap = NULL;
            }
        }
    }

    return bResult;
}

HSDB
SeiGetShimData(
    IN  PPEB    Peb,
    IN  PVOID   pShimData,
    OUT LPWSTR  pwszFullPath,       // this is supplied on Whistler and returned on Win2k
    OUT SDBQUERYRESULT* psdbQuery
    )
{
    HSDB  hSDB = NULL;
    BOOL  bResult;

#ifdef DEBUG_SPEW
    SeiInitDebugSupport();
#endif // DEBUG_SPEW

    //
    // Get the name of the executable being run.
    //
    if (!SeiGetExeName(Peb, pwszFullPath)) {
        DPF(dlError, "[SeiGetShimData] Can't get EXE name\n");
        return NULL;
    }

    if (!_wcsicmp(g_szExeName, L"ntsd.exe") ||
        !_wcsicmp(g_szExeName, L"windbg.exe")) {
        DPF(dlPrint, "[SeiGetShimData] not shimming ntsd.exe\n");
        return NULL;
    }

    //
    // Open up the Database and see if there's any blob information about this EXE.
    //
    hSDB = SdbInitDatabase(0, NULL);

    if (hSDB == NULL) {
        DPF(dlError, "[SeiGetShimData] Can't open shim DB.\n");
        return NULL;
    }

    //
    // Ensure that the sdbQuery starts out clean.
    //
    ZeroMemory(psdbQuery, sizeof(SDBQUERYRESULT));

#ifdef SE_WIN2K
    bResult = SdbGetMatchingExe(hSDB, pwszFullPath, NULL, NULL, 0, psdbQuery);
#else
    bResult = SdbUnpackAppCompatData(hSDB, pwszFullPath, pShimData, psdbQuery);
#endif // SE_WIN2K

    if (!bResult) {
        DPF(dlError, "[SeiGetShimData] Can't get EXE data\n");
        goto failure;
    }

    return hSDB;

failure:
    SdbReleaseDatabase(hSDB);
    return NULL;
}


#ifdef SE_WIN2K

BOOL
LoadPatchDll(
    IN LPCSTR pszCmdLine        // The command line from the registry.
                                // Unused parameter.
    )
/*++
    Return: TRUE on success, FALSE otherwise. However user32.dll ignores the return
            value of this function.

    Desc:   This function is called from user32.dll to initialize the shim engine.
            It queries the shim database and loads all the shim DLLs and patches that
            are available for this EXE.
--*/
{
    PPEB            Peb = NtCurrentPeb();
    WCHAR           wszFullPath[MAX_PATH];
    HSDB            hSDB;
    SDBQUERYRESULT  sdbQuery;

    hSDB = SeiGetShimData(Peb, NULL, wszFullPath, &sdbQuery);

    if (hSDB == NULL) {
        DPF(dlError, "[LoadPatchDll] Failed to get shim data\n");
        return FALSE;
    }

    return SeiInit(wszFullPath, hSDB, &sdbQuery, NULL, FALSE);
}

#else

BOOL
SeiDisplayAppHelp(
    IN  HSDB            hSDB,
    IN  PSDBQUERYRESULT pSdbQuery
    )
/*++
    Return: void

    Desc:   This function launches apphelp for the starting EXE.
--*/
{
    PDB                 pdb;
    TAGID               tiExe;
    GUID                guidDB;
    WCHAR               wszGuid[MAX_PATH];
    WCHAR               wszCommandLine[MAX_PATH];
    DWORD               dwExit;
    char                szName[50];
    PVOID               hModule, pAddress;
    WCHAR               wszTemp[MAX_PATH];
    UNICODE_STRING      ustrTemp;
    UNICODE_STRING      ustrGuid;
    ANSI_STRING         strName;
    STARTUPINFOW        StartupInfo;
    PROCESS_INFORMATION ProcessInfo;

    //
    // If we have any errors along the way, go ahead and run the app.
    //
    if (!SdbTagRefToTagID(hSDB, pSdbQuery->trAppHelp, &pdb, &tiExe)) {
        DPF(dlError, "[SeiDisplayAppHelp] Failed to convert tagref to tagid.\n");
        return TRUE;
    }

    if (!SdbGetDatabaseGUID(hSDB, pdb, &guidDB)) {
        DPF(dlError, "[SeiDisplayAppHelp] Failed to get DB guid.\n");
        return TRUE;
    }

    ustrGuid.Buffer = wszGuid;
    ustrGuid.Length = 0;
    ustrGuid.MaximumLength = MAX_PATH;

    if (RtlStringFromGUID(&guidDB, &ustrGuid) != STATUS_SUCCESS) {
        DPF(dlError, "[SeiDisplayAppHelp] Failed to convert guid to string.\n");
        return TRUE;
    }

    swprintf(wszCommandLine, L"ahui.exe %s 0x%x", ustrGuid.Buffer, tiExe);

    //
    // We need a hack here to get kernel32.dll to initialize. We load aclayers.dll
    // to trigger the init routine of kernel32.
    //
    SdbpGetAppPatchDir(wszTemp);
    wcscat(wszTemp, L"\\aclayers.dll");
    RtlInitUnicodeString(&ustrTemp, wszTemp);

    //
    // Save the name of the DLL that we're about to load so we don't screw
    // it's init routine.
    //
    wcscpy(g_wszShimDllInLoading, L"aclayers.dll");
    
    LdrLoadDll(UNICODE_NULL, NULL, &ustrTemp, &hModule);

    g_hApphelpDllHelper = hModule;

    RtlZeroMemory(&StartupInfo, sizeof(StartupInfo));
    RtlZeroMemory(&ProcessInfo, sizeof(ProcessInfo));
    StartupInfo.cb = sizeof(StartupInfo);

    if (!CreateProcessW(NULL, wszCommandLine, NULL, NULL, FALSE, 0, NULL, NULL,
                        &StartupInfo, &ProcessInfo)) {
        DPF(dlError, "[SeiDisplayAppHelp] Failed to launch apphelp process.\n");
        return TRUE;
    }

    WaitForSingleObject(ProcessInfo.hProcess, INFINITE);

    GetExitCodeProcess(ProcessInfo.hProcess, &dwExit);

    if (!dwExit) {
        SeiResetEntryProcessed(NtCurrentPeb());
        TerminateProcess(GetCurrentProcess(), 0);
        return FALSE;
    }

    return TRUE;

}

#ifdef SE_WIN2K

#define SeiCheckComPlusImage(Peb)

#else
void
SeiCheckComPlusImage(
    PPEB Peb
    )
{
    PIMAGE_NT_HEADERS NtHeader;
    ULONG Cor20HeaderSize;
    
    NtHeader = RtlImageNtHeader(Peb->ImageBaseAddress);
    
    g_bComPlusImage = FALSE;
    
    g_bComPlusImage = (RtlImageDirectoryEntryToData(Peb->ImageBaseAddress,
                                                    TRUE,
                                                    IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                                                    &Cor20HeaderSize) != NULL);
    
    DPF(dlPrint, "[SeiCheckComPlusImage] COM+ executable %s\n",
        (g_bComPlusImage ? "TRUE" : "FALSE"));
}

#endif // SE_WIN2K

void
SE_InstallBeforeInit(
    IN  PUNICODE_STRING pstrFullPath,   // The name of the starting EXE
    IN  PVOID           pShimExeData    // The pointer provided by apphelp.dll
    )
/*++
    Return: void

    Desc:   This function installs the shim support for the starting EXE.
--*/
{
    PPEB            Peb = NtCurrentPeb();
    HSDB            hSDB;
    SDBQUERYRESULT  sdbQuery;

    hSDB = SeiGetShimData(Peb, pShimExeData, pstrFullPath->Buffer, &sdbQuery);

    if (hSDB == NULL) {
        DPF(dlError, "[SE_InstallBeforeInit] Failed to get shim data\n");
        return;
    }

    //
    // Check if the image is a COM+ image
    //
    SeiCheckComPlusImage(Peb);

    SeiInit(pstrFullPath->Buffer, hSDB, &sdbQuery, NULL, FALSE);

    if (pShimExeData != NULL) {

        SIZE_T dwSize;

        dwSize = SdbGetAppCompatDataSize(pShimExeData);

        if (dwSize > 0) {
            NtFreeVirtualMemory(NtCurrentProcess(),
                                &pShimExeData,
                                &dwSize,
                                MEM_RELEASE);
        }
    }

    return;
}

#endif // SE_WIN2K


#ifndef SE_WIN2K

void
SE_ProcessDying(
    void
    )
{
    NotifyShims(SN_PROCESS_DYING, 0);
    return;
}

#endif // SE_WIN2K


BOOL
SE_DynamicShim(
    IN  LPCWSTR         lpszFullPath,
    IN  HSDB            hSDB,
    IN  SDBQUERYRESULT* psdbQuery,
    IN  LPCSTR          lpszModuleToShim
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function attempts to inject shims dynamically.
--*/
{
    SeiInitDebugSupport();

    if (lpszModuleToShim != NULL && *lpszModuleToShim == 0) {
        lpszModuleToShim = NULL;
    }

    SeiInit(lpszFullPath, hSDB, psdbQuery, lpszModuleToShim, TRUE);

#ifndef SE_WIN2K
    LdrInitShimEngineDynamic(g_hModule);
#endif

    return TRUE;
}


BOOL
SeiSendDataToPipe(
    void
    )
{
    OBJECT_ATTRIBUTES       ObjA;
    FILE_PIPE_INFORMATION   fpi;
    UNICODE_STRING          uName;
    IO_STATUS_BLOCK         ioStatusBlock;
    HANDLE                  hPipe;
    NTSTATUS                status;
    LARGE_INTEGER           liOffset;
    ULONG                   uBytes;
    DWORD                   dwRet, dwCount;

    RtlInitUnicodeString(&uName, PIPE_NAME);

    InitializeObjectAttributes(&ObjA,
                               &uName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    ioStatusBlock.Status = 0;
    ioStatusBlock.Information = 0;

    //
    // Open the named pipe
    //
    status = NtCreateFile(&hPipe,
                          FILE_GENERIC_WRITE,
                          &ObjA,
                          &ioStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OPEN,
                          0,
                          NULL,
                          0);

    if ((!NT_SUCCESS(status) || INVALID_HANDLE_VALUE == hPipe)) {
        dwRet = RtlNtStatusToDosError(status);
        
        DPF(dlError,
            "[SeiSendDataToPipe] Failed to open named pipe. Error code: %d\n",
            dwRet);
        return FALSE;
    }

    //
    // Change the mode of the named pipe to message mode
    //
    fpi.ReadMode       = FILE_PIPE_MESSAGE_MODE;
    fpi.CompletionMode = FILE_PIPE_QUEUE_OPERATION;

    status = NtSetInformationFile(hPipe,
                                  &ioStatusBlock,
                                  &fpi,
                                  sizeof(FILE_PIPE_INFORMATION),
                                  FilePipeInformation);

    if (!NT_SUCCESS(status)) {
        dwRet = RtlNtStatusToDosError(status);
        
        DPF(dlError,
            "[SeiSendDataToPipe] Failed to change handle state. Error code: %d\n",
            dwRet);
        return FALSE;
    }

    ioStatusBlock.Status = 0;
    ioStatusBlock.Information = 0;

    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    //
    // Send the data to the named pipe
    //
    uBytes = wcslen(g_szPipeData) * sizeof(WCHAR);

    status = NtWriteFile(hPipe,
                         NULL,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         (PVOID)g_szPipeData,
                         uBytes,
                         &liOffset,
                         NULL);

    if (!NT_SUCCESS(status)) {
        dwRet = RtlNtStatusToDosError(status);
        DPF(dlError,
            "[SeiSendDataToPipe] Failed to send data. Error code: %d\n",
            dwRet);
        NtClose(hPipe);
        return FALSE;
    }

    NtClose(hPipe);

    return TRUE;
}

BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD     dwreason,
    LPVOID    reserved
    )
{
    //
    // The init routine for DLL_PROCESS_ATTACH will NEVER be called because
    // ntdll calls LdrpLoadDll for this shim engine w/o calling the init routine.
    // Look in ntdll\ldrinit.c LdrpLoadShimEngine.
    // The only case when we will have hInstance is when we are loaded dynamically
    //
    if (dwreason == DLL_PROCESS_ATTACH) {
        g_hModule = (HMODULE)hInstance;
    }
    return TRUE;

    UNREFERENCED_PARAMETER(reserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimdbc\xml.h ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    xml.h
//
// History: 16-Nov-00   markder     Created.
//
// Desc:    This file contains all object definitions used by the
//          XML parsing code.
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef __XML_H__
#define __XML_H__

#include <msxml.h>

BOOL        AddAttribute(IXMLDOMNode* pNode, CString csAttribute, CString csValue);
BOOL        GetAttribute(LPCTSTR lpszAttribute, IXMLDOMNodePtr pNode, CString* pcsValue, BOOL bXML = FALSE);
BOOL        RemoveAttribute(CString csName, IXMLDOMNodePtr  pNode);
BOOL        GetChild(LPCTSTR lpszTag, IXMLDOMNode* pParentNode, IXMLDOMNode** ppChildNode);
CString     GetText(IXMLDOMNode* pNode);
BOOL        GetNodeText(IXMLDOMNode* pNode, CString& csNodeText);
CString     GetNodeName(IXMLDOMNode* pNode);
CString     GetParentNodeName(IXMLDOMNode* pNode);
CString     GetXML(IXMLDOMNode* pNode);
CString     GetInnerXML(IXMLDOMNode* pNode);
LANGID      MapStringToLangID(CString& csLang);
CString     GetInnerXML(IXMLDOMNode* pNode);
BOOL        OpenXML(CString csFileOrStream, IXMLDOMNode** ppRootNode, BOOL bStream = FALSE, IXMLDOMDocument** ppDoc = NULL);
BOOL        SaveXMLFile(CString csFile, IXMLDOMNode* pNode);
BOOL        GenerateIDAttribute(IXMLDOMNode* pNode, CString* pcsGuid, GUID* pGuid);
BOOL        ReplaceXMLNode(IXMLDOMNode* pNode, IXMLDOMDocument* pDoc, BSTR bsText);

////////////////////////////////////////////////////////////////////////////////////
//
//  XMLNodeList
//
//  This class is a wrapper for the IXMLDOMNodeList interface. It simplifies
//  C++ access by exposing functions for executing XQL queries and iterating
//  through the elements in a node list.
//
class XMLNodeList
{
private:
    LONG               m_nSize;
    IXMLDOMNodeListPtr m_cpList;
    CString            m_csXQL;

public:
    XMLNodeList();
    ~XMLNodeList();

    void            Clear();
    LONG            GetSize();
    BOOL            Query(IXMLDOMNode* pNode, LPCTSTR szXQL);
    BOOL            GetChildNodes(IXMLDOMNode* pNode);
    BOOL            GetItem(LONG nIndex, IXMLDOMNode** ppNode);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimengines\engiat\notifycallback.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    NotifyCallback.c

Abstract:

    This module implements the code that (on win2k) implements
    the callback into the shim DLLs to notify them that all the
    static linked modules have run their init routines.

Author:

    clupu created 19 February 2001

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <string.h>

#include <windef.h>
#include <winbase.h>

#include "ShimEng.h"

//
// The structure of the code for injection must be byte aligned.
//
#pragma pack(push)
#pragma pack(1)
    typedef struct tagINJECTION_CODE
    {
        BYTE        PUSH_RETURN;
        PVOID       retAddr;
        BYTE        JMP;
        PVOID       injCodeStart;
    } INJECTION_CODE, *PINJECTION_CODE;
#pragma pack(pop)



BYTE   g_originalCode[sizeof(INJECTION_CODE)];
PVOID  g_entryPoint;


void
InitInjectionCode(
    IN  PVOID           entryPoint,
    IN  PVOID           injCodeStart,
    OUT PINJECTION_CODE pInjCode
    )
/*++
    Return: void

    Desc:   This function initializes the structure that contains
            the code to be injected at the entry point.
--*/
{
    //
    // Push the return address first so the ret in
    // the cleanup function will remove it from the stack and use it
    // as the return address.
    //
    pInjCode->PUSH_RETURN  = 0x68;
    pInjCode->retAddr      = entryPoint;

    pInjCode->JMP          = 0xE9;
    
    //
    // The DWORD used in the JMP opcode is relative to the EIP after the JMP.
    // That's why we need to subtract sizeof(ONJECTION_CODE).
    //
    pInjCode->injCodeStart = (PVOID)((ULONG)injCodeStart -
                                     (ULONG)entryPoint -
                                     sizeof(INJECTION_CODE));
}

void
RestoreOriginalCode(
    void
    )
/*++
    Return: void

    Desc:   This function restores the code that was injected at
            the entry point.
--*/
{
    NTSTATUS status;
    SIZE_T   codeSize = sizeof(INJECTION_CODE);
    ULONG    uOldProtect, uOldProtect2;
    PVOID    entryPoint = g_entryPoint;
    
    //
    // WARNING: NtProtectVirtualMemory will change the second parameter so
    //          we need to keep a copy of it on the stack.
    //
    status = NtProtectVirtualMemory(NtCurrentProcess(),
                                    &entryPoint,
                                    &codeSize,
                                    PAGE_READWRITE,
                                    &uOldProtect);

    if (!NT_SUCCESS(status)) {
        DPF(dlError,
            "[RestoreOriginalCode] Failed 0x%x to change the protection.\n",
            status);
        return;
    }

    //
    // Copy back the original code the the entry point.
    //
    RtlCopyMemory(g_entryPoint, g_originalCode, sizeof(INJECTION_CODE));
    
    entryPoint = g_entryPoint;
    codeSize = sizeof(INJECTION_CODE);

    status = NtProtectVirtualMemory(NtCurrentProcess(),
                                    &entryPoint,
                                    &codeSize,
                                    uOldProtect,
                                    &uOldProtect2);

    if (!NT_SUCCESS(status)) {
        DPF(dlError,
            "[RestoreOriginalCode] Failed 0x%x to change back the protection.\n",
            status);
        return;
    }
}

BOOL
InjectNotificationCode(
    IN  PVOID entryPoint
    )
/*++
    Return: void

    Desc:   This function places a trampoline at the EXE's entry point so
            that we can notify the shim DLLs that all the static linked
            modules have run their init routines.
--*/
{
    INJECTION_CODE  injectionCode;
    SIZE_T          nBytes;
    NTSTATUS        status;
    SIZE_T          codeSize = sizeof(INJECTION_CODE);
    ULONG           uOldProtect, uOldProtect2;

    g_entryPoint = entryPoint;
    
    InitInjectionCode(entryPoint, NotifyShimDlls, &injectionCode);

    status = NtProtectVirtualMemory(NtCurrentProcess(),
                                    &g_entryPoint,
                                    &codeSize,
                                    PAGE_READWRITE,
                                    &uOldProtect);

    if (!NT_SUCCESS(status)) {
        DPF(dlError,
            "[InjectNotificationCode] Failed 0x%x to change the protection.\n",
            status);
        return FALSE;
    }
    
    //
    // Save the code that was originally at the entry point.
    //
    RtlCopyMemory(g_originalCode, entryPoint, sizeof(INJECTION_CODE));
    
    //
    // Place the trampoline at the entry point.
    //
    RtlCopyMemory(entryPoint, &injectionCode, sizeof(INJECTION_CODE));

    g_entryPoint = entryPoint;
    
    //
    // Restore the protection.
    //
    codeSize = sizeof(INJECTION_CODE);

    status = NtProtectVirtualMemory(NtCurrentProcess(),
                                    &g_entryPoint,
                                    &codeSize,
                                    uOldProtect,
                                    &uOldProtect2);

    if (!NT_SUCCESS(status)) {
        DPF(dlError,
            "[InjectNotificationCode] Failed 0x%x to change back the protection.\n",
            status);
        return FALSE;
    }
    
    g_entryPoint = entryPoint;
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimengines\shimengv\86dis.h ===
/********************************** module *********************************/
/*                                                                         */
/*                                 disasmtb                                */
/*                           disassembler for CodeView                     */
/*                                                                         */
/***************************************************************************/
/*                                                                         */
/*    @ Purpose:                                                           */
/*                                                                         */
/*    @ Functions included:                                                */
/*                                                                         */
/*                                                                         */
/*    @ Author: Gerd Immeyer              @ Version:                       */
/*                                                                         */
/*    @ Creation Date: 10.19.89           @ Modification Date:             */
/*                                                                         */
/***************************************************************************/

#ifndef _86DIS_H_
#define _86DIS_H_

/* Strings: Operand mnemonics, Segment overrides, etc. for disasm          */

char dszAAA[]       = "aaa";
char dszAAD[]       = "aad";
char dszAAM[]       = "aam";
char dszAAS[]       = "aas";
char dszADC[]       = "adc";
char dszADD[]       = "add";
char dszADDRPRFX[]  = "";
char dszAND[]       = "and";
char dszARPL[]      = "arpl";
char dszBOUND[]     = "bound";
char dszBSF[]       = "bsf";
char dszBSR[]       = "bsr";
char dszBST[]       = "bst";
char dszBSWAP[]     = "bswap";
char dszBT[]        = "bt";
char dszBTC[]       = "btc";
char dszBTR[]       = "btr";
char dszBTS[]       = "bts";
char dszCALL[]      = "call";
char dszCBW[]       = "cbw";
char dszCDQ[]       = "cdq";
char dszCLC[]       = "clc";
char dszCLD[]       = "cld";
char dszCLI[]       = "cli";
char dszCLTS[]      = "clts";
char dszCMC[]       = "cmc";
char dszCMOVO[]     = "cmovo";
char dszCMOVNO[]    = "cmovno";
char dszCMOVB[]     = "cmovb";
char dszCMOVNB[]    = "cmovnb";
char dszCMOVE[]     = "cmove";
char dszCMOVNE[]    = "cmovne";
char dszCMOVBE[]    = "cmovbe";
char dszCMOVA[]     = "cmova";
char dszCMOVS[]     = "cmovs";
char dszCMOVNS[]    = "cmovns";
char dszCMOVP[]     = "cmovp";
char dszCMOVNP[]    = "cmovnp";
char dszCMOVL[]     = "cmovl";
char dszCMOVGE[]    = "cmovge";
char dszCMOVLE[]    = "cmovle";
char dszCMOVNLE[]   = "cmovnle";
char dszCMP[]       = "cmp";
char dszCMPS[]      = "cmps";
char dszCMPSB[]     = "cmpsb";
char dszCMPSD[]     = "cmpsd";
char dszCMPSW[]     = "cmpsw";
char dszCMPXCHG[]   = "cmpxchg";
char dszCMPXCHG8B[] = "cmpxchg8b";
char dszCPUID[]     = "cpuid";
char dszCS_[]       = "cs:";
char dszCWD[]       = "cwd";
char dszCWDE[]      = "cwde";
char dszDAA[]       = "daa";
char dszDAS[]       = "das";
char dszDEC[]       = "dec";
char dszDIV[]       = "div";
char dszDS_[]       = "ds:";
char dszEMMS[]      = "emms";
char dszENTER[]     = "enter";
char dszES_[]       = "es:";
char dszF2XM1[]     = "f2xm1";
char dszFABS[]      = "fabs";
char dszFADD[]      = "fadd";
char dszFADDP[]     = "faddp";
char dszFBLD[]      = "fbld";
char dszFBSTP[]     = "fbstp";
char dszFCHS[]      = "fchs";
char dszFCLEX[]     = "fclex";
char dszFCMOVB[]    = "fcmovb";
char dszFCMOVE[]    = "fcmove";
char dszFCMOVBE[]   = "fcmovbe";
char dszFCMOVU[]    = "fcmovu";
char dszFCMOVNB[]   = "fcmovnb";
char dszFCMOVNE[]   = "fcmovne";
char dszFCMOVNBE[]  = "fcmovnbe";
char dszFCMOVNU[]   = "fcmovnu";
char dszFCOM[]      = "fcom";
char dszFCOMI[]     = "fcomi";
char dszFCOMIP[]    = "fcomip";
char dszFCOMP[]     = "fcomp";
char dszFCOMPP[]    = "fcompp";
char dszFCOS[]      = "fcos";
char dszFDECSTP[]   = "fdecstp";
char dszFDISI[]     = "fdisi";
char dszFDIV[]      = "fdiv";
char dszFDIVP[]     = "fdivp";
char dszFDIVR[]     = "fdivr";
char dszFDIVRP[]    = "fdivrp";
char dszFENI[]      = "feni";
char dszFFREE[]     = "ffree";
char dszFIADD[]     = "fiadd";
char dszFICOM[]     = "ficom";
char dszFICOMP[]    = "ficomp";
char dszFIDIV[]     = "fidiv";
char dszFIDIVR[]    = "fidivr";
char dszFILD[]      = "fild";
char dszFIMUL[]     = "fimul";
char dszFINCSTP[]   = "fincstp";
char dszFINIT[]     = "finit";
char dszFIST[]      = "fist";
char dszFISTP[]     = "fistp";
char dszFISUB[]     = "fisub";
char dszFISUBR[]    = "fisubr";
char dszFLD[]       = "fld";
char dszFLD1[]      = "fld1";
char dszFLDCW[]     = "fldcw";
char dszFLDENV[]    = "fldenv";
char dszFLDL2E[]    = "fldl2e";
char dszFLDL2T[]    = "fldl2t";
char dszFLDLG2[]    = "fldlg2";
char dszFLDLN2[]    = "fldln2";
char dszFLDPI[]     = "fldpi";
char dszFLDZ[]      = "fldz";
char dszFMUL[]      = "fmul";
char dszFMULP[]     = "fmulp";
char dszFNCLEX[]    = "fnclex";
char dszFNDISI[]    = "fndisi";
char dszFNENI[]     = "fneni";
char dszFNINIT[]    = "fninit";
char dszFNOP[]      = "fnop";
char dszFNSAVE[]    = "fnsave";
char dszFNSTCW[]    = "fnstcw";
char dszFNSTENV[]   = "fnstenv";
char dszFNSTSW[]    = "fnstsw";
char dszFNSTSWAX[]  = "fnstswax";
char dszFPATAN[]    = "fpatan";
char dszFPREM[]     = "fprem";
char dszFPREM1[]    = "fprem1";
char dszFPTAN[]     = "fptan";
char dszFRNDINT[]   = "frndint";
char dszFRSTOR[]    = "frstor";
char dszFSAVE[]     = "fsave";
char dszFSCALE[]    = "fscale";
char dszFSETPM[]    = "fsetpm";
char dszFSIN[]      = "fsin";
char dszFSINCOS[]   = "fsincos";
char dszFSQRT[]     = "fsqrt";
char dszFST[]       = "fst";
char dszFSTCW[]     = "fstcw";
char dszFSTENV[]    = "fstenv";
char dszFSTP[]      = "fstp";
char dszFSTSW[]     = "fstsw";
char dszFSTSWAX[]   = "fstswax";
char dszFSUB[]      = "fsub";
char dszFSUBP[]     = "fsubp";
char dszFSUBR[]     = "fsubr";
char dszFSUBRP[]    = "fsubrp";
char dszFS_[]       = "fs:";
char dszFTST[]      = "ftst";
char dszFUCOM[]     = "fucom";
char dszFUCOMI[]    = "fucomi";
char dszFUCOMIP[]   = "fucomip";
char dszFUCOMP[]    = "fucomp";
char dszFUCOMPP[]   = "fucompp";
char dszFWAIT[]     = "fwait";
char dszFXAM[]      = "fxam";
char dszFXCH[]      = "fxch";
char dszFXTRACT[]   = "fxtract";
char dszFYL2X[]     = "fyl2x";
char dszFYL2XP1[]   = "fyl2xp1";
char dszGS_[]       = "gs:";
char dszHLT[]       = "hlt";
char dszIBTS[]      = "ibts";
char dszIDIV[]      = "idiv";
char dszIMUL[]      = "imul";
char dszIN[]        = "in";
char dszINC[]       = "inc";
char dszINS[]       = "ins";
char dszINSB[]      = "insb";
char dszINSD[]      = "insd";
char dszINSW[]      = "insw";
char dszINT[]       = "int";
char dszINTO[]      = "into";
char dszINVD[]      = "invd";
char dszINVLPG[]    = "invlpg";
char dszIRET[]      = "iret";
char dszIRETD[]     = "iretd";
char dszJA[]        = "ja";
char dszJAE[]       = "jae";
char dszJB[]        = "jb";
char dszJBE[]       = "jbe";
char dszJC[]        = "jc";
char dszJCXZ[]      = "jcxz";
char dszJE[]        = "je";
char dszJECXZ[]     = "jecxz";
char dszJG[]        = "jg";
char dszJGE[]       = "jge";
char dszJL[]        = "jl";
char dszJLE[]       = "jle";
char dszJMP[]       = "jmp";
char dszJNA[]       = "jna";
char dszJNAE[]      = "jnae";
char dszJNB[]       = "jnb";
char dszJNBE[]      = "jnbe";
char dszJNC[]       = "jnc";
char dszJNE[]       = "jne";
char dszJNG[]       = "jng";
char dszJNGE[]      = "jnge";
char dszJNL[]       = "jnl";
char dszJNLE[]      = "jnle";
char dszJNO[]       = "jno";
char dszJNP[]       = "jnp";
char dszJNS[]       = "jns";
char dszJNZ[]       = "jnz";
char dszJO[]        = "jo";
char dszJP[]        = "jp";
char dszJPE[]       = "jpe";
char dszJPO[]       = "jpo";
char dszJS[]        = "js";
char dszJZ[]        = "jz";
char dszLAHF[]      = "lahf";
char dszLAR[]       = "lar";
char dszLDS[]       = "lds";
char dszLEA[]       = "lea";
char dszLEAVE[]     = "leave";
char dszLES[]       = "les";
char dszLFS[]       = "lfs";
char dszLGDT[]      = "lgdt";
char dszLGS[]       = "lgs";
char dszLIDT[]      = "lidt";
char dszLLDT[]      = "lldt";
char dszLMSW[]      = "lmsw";
char dszLOADALL[]   = "loadall";
char dszLOCK[]      = "lock";
char dszLODS[]      = "lods";
char dszLODSB[]     = "lodsb";
char dszLODSD[]     = "lodsd";
char dszLODSW[]     = "lodsw";
char dszLOOP[]      = "loop";
char dszLOOPE[]     = "loope";
char dszLOOPNE[]    = "loopne";
char dszLOOPNZ[]    = "loopnz";
char dszLOOPZ[]     = "loopz";
char dszLSL[]       = "lsl";
char dszLSS[]       = "lss";
char dszLTR[]       = "ltr";
char dszMOV[]       = "mov";
char dszMOVD[]      = "movd";
char dszMOVQ[]      = "movq";
char dszMOVS[]      = "movs";
char dszMOVSB[]     = "movsb";
char dszMOVSD[]     = "movsd";
char dszMOVSW[]     = "movsw";
char dszMOVSX[]     = "movsx";
char dszMOVZX[]     = "movzx";
char dszMUL[]       = "mul";
char dszNEG[]       = "neg";
char dszNOP[]       = "nop";
char dszNOT[]       = "not";
char dszOPPRFX[]    = "";
char dszOR[]        = "or";
char dszOUT[]       = "out";
char dszOUTS[]      = "outs";
char dszOUTSB[]     = "outsb";
char dszOUTSD[]     = "outsd";
char dszOUTSW[]     = "outsw";
char dszPACKSSDW[]  = "packssdw";
char dszPACKSSWB[]  = "packsswb";
char dszPACKUSWB[]  = "packuswb";
char dszPADDB[]     = "paddb";
char dszPADDD[]     = "paddd";
char dszPADDSB[]    = "paddsb";
char dszPADDSW[]    = "paddsw";
char dszPADDUSB[]   = "paddusb";
char dszPADDUSW[]   = "paddusw";
char dszPADDW[]     = "paddw";
char dszPAND[]      = "pand";
char dszPANDN[]     = "pandn";
char dszPCMPEQB[]   = "pcmpeqb";
char dszPCMPEQD[]   = "pcmpeqd";
char dszPCMPEQW[]   = "pcmpeqw";
char dszPCMPGTB[]   = "pcmpgtb";
char dszPCMPGTD[]   = "pcmpgtd";
char dszPCMPGTW[]   = "pcmpgtw";
char dszPMADDWD[]   = "pmaddwd";
char dszPMULHW[]    = "pmulhw";
char dszPMULLW[]    = "pmullw";
char dszPOP[]       = "pop";
char dszPOPA[]      = "popa";
char dszPOPAD[]     = "popad";
char dszPOPF[]      = "popf";
char dszPOPFD[]     = "popfd";
char dszPOR[]       = "por";
char dszPSLLD[]     = "pslld";
char dszPSLLW[]     = "psllw";
char dszPSLLQ[]     = "psllq";
char dszPSRAD[]     = "psrad";
char dszPSRAW[]     = "psraw";
char dszPSRLD[]     = "psrld";
char dszPSRLQ[]     = "psrlq";
char dszPSRLW[]     = "psrlw";
char dszPSUBB[]     = "psubb";
char dszPSUBD[]     = "psubd";
char dszPSUBSB[]    = "psubsb";
char dszPSUBSW[]    = "psubsw";
char dszPSUBUSB[]   = "psubusb";
char dszPSUBUSW[]   = "psubusw";
char dszPSUBW[]     = "psubw";
char dszPUNPCKLBW[] = "punpcklbw";
char dszPUNPCKLDQ[] = "punpckldq";
char dszPUNPCKLWD[] = "punpcklwd";
char dszPUNPCKHBW[] = "punpckhbw";
char dszPUNPCKHDQ[] = "punpckhdq";
char dszPUNPCKHWD[] = "punpckhwd";
char dszPUSH[]      = "push";
char dszPUSHA[]     = "pusha";
char dszPUSHAD[]    = "pushad";
char dszPUSHF[]     = "pushf";
char dszPUSHFD[]    = "pushfd";
char dszPXOR[]      = "pxor";
char dszRCL[]       = "rcl";
char dszRCR[]       = "rcr";
char dszRDTSC[]     = "rdtsc";
char dszRDMSR[]     = "rdmsr";
char dszRDPMC[]     = "rdpmc";
char dszREP[]       = "rep ";
char dszREPE[]      = "repe";
char dszREPNE[]     = "repne ";
char dszREPNZ[]     = "repnz";
char dszREPZ[]      = "repz";
char dszRET[]       = "ret";
char dszRETF[]      = "retf";
char dszRETN[]      = "retn";
char dszROL[]       = "rol";
char dszROR[]       = "ror";
char dszRSM[]       = "rsm";
char dszSAHF[]      = "sahf";
char dszSAL[]       = "sal";
char dszSAR[]       = "sar";
char dszSBB[]       = "sbb";
char dszSCAS[]      = "scas";
char dszSCASB[]     = "scasb";
char dszSCASD[]     = "scasd";
char dszSCASW[]     = "scasw";
char dszSETA[]      = "seta";
char dszSETAE[]     = "setae";
char dszSETB[]      = "setb";
char dszSETBE[]     = "setbe";
char dszSETC[]      = "setc";
char dszSETE[]      = "sete";
char dszSETG[]      = "setg";
char dszSETGE[]     = "setge";
char dszSETL[]      = "setl";
char dszSETLE[]     = "setle";
char dszSETNA[]     = "setna";
char dszSETNAE[]    = "setnae";
char dszSETNB[]     = "setnb";
char dszSETNBE[]    = "setnbe";
char dszSETNC[]     = "setnc";
char dszSETNE[]     = "setne";
char dszSETNG[]     = "setng";
char dszSETNGE[]    = "setnge";
char dszSETNL[]     = "setnl";
char dszSETNLE[]    = "setnle";
char dszSETNO[]     = "setno";
char dszSETNP[]     = "setnp";
char dszSETNS[]     = "setns";
char dszSETNZ[]     = "setnz";
char dszSETO[]      = "seto";
char dszSETP[]      = "setp";
char dszSETPE[]     = "setpe";
char dszSETPO[]     = "setpo";
char dszSETS[]      = "sets";
char dszSETZ[]      = "setz";
char dszSGDT[]      = "sgdt";
char dszSHL[]       = "shl";
char dszSHLD[]      = "shld";
char dszSHR[]       = "shr";
char dszSHRD[]      = "shrd";
char dszSIDT[]      = "sidt";
char dszSLDT[]      = "sldt";
char dszSMSW[]      = "smsw";
char dszSS_[]       = "ss:";
char dszSTC[]       = "stc";
char dszSTD[]       = "std";
char dszSTI[]       = "sti";
char dszSTOS[]      = "stos";
char dszSTOSB[]     = "stosb";
char dszSTOSD[]     = "stosd";
char dszSTOSW[]     = "stosw";
char dszSTR[]       = "str";
char dszSUB[]       = "sub";
char dszTEST[]      = "test";
char dszUD2[]       = "ud2";
char dszVERR[]      = "verr";
char dszVERW[]      = "verw";
char dszWAIT[]      = "wait";
char dszWBINVD[]    = "wbinvd";
char dszWRMSR[]     = "wrmsr";
char dszXADD[]      = "xadd";
char dszXBTS[]      = "xbts";
char dszXCHG[]      = "xchg";
char dszXLAT[]      = "xlat";
char dszXOR[]       = "xor";
char dszRESERVED[]  = "???";
char dszMULTI[]     = "";
char dszDB[]        = "db";

#define MRM        0x40
#define COM        0x80
#define END        0xc0

/* Enumeration of valid actions that can be included in the action table */

enum oprtyp { ADDRP,  ADR_OVR, ALSTR,   ALT,     AXSTR,  BOREG,
              BREG,   BRSTR,   xBYTE,   CHR,     CREG,   xDWORD,
              EDWORD, EGROUPT, FARPTR,  GROUP,   GROUPT, IB,
              IST,    IST_ST,  IV,      IW,      LMODRM, MODRM,
              NOP,    OFFS,    OPC0F,   OPR_OVR, QWORD,  REL16,
              REL8,   REP,     SEG_OVR, SREG2,   SREG3,  ST_IST,
              STROP,  TBYTE,   UBYTE,   VAR,     VOREG,  VREG,
              xWORD,  WREG,    WRSTR,   MMWREG,  MMQWORD
            };

/* Enumeration of indices into the action table for instruction classes */

#define O_DoDB          0
#define O_NoOperands    0
#define O_NoOpAlt5      O_NoOperands+1
#define O_NoOpAlt4      O_NoOpAlt5+2
#define O_NoOpAlt3      O_NoOpAlt4+2
#define O_NoOpAlt1      O_NoOpAlt3+2
#define O_NoOpAlt0      O_NoOpAlt1+2
#define O_NoOpStrSI     O_NoOpAlt0+2
#define O_NoOpStrDI     O_NoOpStrSI+2
#define O_NoOpStrSIDI   O_NoOpStrDI+2
#define O_bModrm_Reg    O_NoOpStrSIDI+2
#define O_vModrm_Reg    O_bModrm_Reg+3
#define O_Modrm_Reg     O_vModrm_Reg+3
#define O_bReg_Modrm    O_Modrm_Reg+3
#define O_fReg_Modrm    O_bReg_Modrm+3
#define O_Reg_Modrm     O_fReg_Modrm+3
#define O_AL_Ib         O_Reg_Modrm+3
#define O_AX_Iv         O_AL_Ib+2
#define O_sReg2         O_AX_Iv+2
#define O_oReg          O_sReg2+1
#define O_DoBound       O_oReg+1
#define O_Iv            O_DoBound+3
#define O_wModrm_Reg    O_Iv+1
#define O_Ib            O_wModrm_Reg+3
#define O_Imulb         O_Ib+1
#define O_Imul          O_Imulb+4
#define O_Rel8          O_Imul+4
#define O_bModrm_Ib     O_Rel8+1
#define O_Modrm_Ib      O_bModrm_Ib+3
#define O_Modrm_Iv      O_Modrm_Ib+3
#define O_Modrm_sReg3   O_Modrm_Iv+3
#define O_sReg3_Modrm   O_Modrm_sReg3+3
#define O_Modrm         O_sReg3_Modrm+3
#define O_FarPtr        O_Modrm+2
#define O_AL_Offs       O_FarPtr+1
#define O_Offs_AL       O_AL_Offs+2
#define O_AX_Offs       O_Offs_AL+2
#define O_Offs_AX       O_AX_Offs+2
#define O_oReg_Ib       O_Offs_AX+2
#define O_oReg_Iv       O_oReg_Ib+2
#define O_Iw            O_oReg_Iv+2
#define O_Enter         O_Iw+1
#define O_Ubyte_AL      O_Enter+2
#define O_Ubyte_AX      O_Ubyte_AL+2
#define O_AL_Ubyte      O_Ubyte_AX+2
#define O_AX_Ubyte      O_AL_Ubyte+2
#define O_DoInAL        O_AX_Ubyte+2
#define O_DoInAX        O_DoInAL+3
#define O_DoOutAL       O_DoInAX+3
#define O_DoOutAX       O_DoOutAL+3
#define O_Rel16         O_DoOutAX+3
#define O_ADR_OVERRIDE  O_Rel16+1
#define O_OPR_OVERRIDE  O_ADR_OVERRIDE+1
#define O_SEG_OVERRIDE  O_OPR_OVERRIDE+1
#define O_DoInt3        O_SEG_OVERRIDE+1

#if (O_DoInt3 != 115)
#error "operand table has been modified!"
#endif
/* #define O_DoInt      O_DoInt3+2 */

#define O_DoInt         117
#define O_OPC0F         O_DoInt+1
#define O_GROUP11       O_OPC0F+1
#define O_GROUP13       O_GROUP11+5
#define O_GROUP12       O_GROUP13+5
#define O_GROUP21       O_GROUP12+5
#define O_GROUP22       O_GROUP21+5
#define O_GROUP23       O_GROUP22+5
#define O_GROUP24       O_GROUP23+6
#define O_GROUP25       O_GROUP24+6
#define O_GROUP26       O_GROUP25+6
#define O_GROUP4        O_GROUP26+6
#define O_GROUP6        O_GROUP4+4
#define O_GROUP8        O_GROUP6+4
#define O_GROUP31       O_GROUP8+5
#define O_GROUP32       O_GROUP31+3
#define O_GROUP5        O_GROUP32+3
#define O_GROUP7        O_GROUP5+3
#define O_x87_ESC       O_GROUP7+3
#define O_bModrm        O_x87_ESC+2
#define O_wModrm        O_bModrm+2
#define O_dModrm        O_wModrm+2
#define O_fModrm        O_dModrm+2
#define O_vModrm        O_fModrm+2
#define O_vModrm_Iv     O_vModrm+2
#define O_Reg_bModrm    O_vModrm_Iv+3
#define O_Reg_wModrm    O_Reg_bModrm+3
#define O_Modrm_Reg_Ib  O_Reg_wModrm+3
#define O_Modrm_Reg_CL  O_Modrm_Reg_Ib+4
#define O_ST_iST        O_Modrm_Reg_CL+5
#define O_iST           O_ST_iST+2
#define O_iST_ST        O_iST+2
#define O_qModrm        O_iST_ST+2
#define O_tModrm        O_qModrm+2
#define O_DoRep         O_tModrm+2
#define O_Modrm_CReg    O_DoRep+1
#define O_CReg_Modrm    O_Modrm_CReg+3
#define O_AX_oReg       O_CReg_Modrm+3
#define O_MmReg_qModrm  O_AX_oReg+2
#define O_qModrm_MmReg  O_MmReg_qModrm+3
#define O_MmReg_dModrm  O_qModrm_MmReg+3
#define O_dModrm_MmReg  O_MmReg_dModrm+3
#define O_qModrm_Ib     O_dModrm_MmReg+3
#define O_PSHimw        O_qModrm_Ib+3
#define O_PSHimd        O_PSHimw+5
#define O_PSHimq        O_PSHimd+5
#define O_length        O_PSHimq+5

typedef unsigned short ActionIndex;

#if( O_length > 65535 )
#error "operand table too large!"
#endif


/* The action table: range of lists of actions to be taken for each possible */
/*   instruction class.                                                      */

static unsigned char actiontbl[] = {
/* NoOperands  */ NOP+END,
/* NoOpAlt5    */ ALT+END,   5,
/* NoOpAlt4    */ ALT+END,   4,
/* NoOpAlt3    */ ALT+END,   3,
/* NoOpAlt1    */ ALT+END,   1,
/* NoOpAlt0    */ ALT+END,   0,
/* NoOpStrSI   */ STROP+END, 1,
/* NoOpStrDI   */ STROP+END, 2,
/* NoOpStrSIDI */ STROP+END, 3,
/* bModrm_Reg  */ xBYTE+MRM, MODRM+COM,  BREG+END,
/* vModrm_Reg  */ VAR+MRM,   LMODRM+COM, BREG+END,
/* Modrm_Reg   */ VAR+MRM,   MODRM+COM,  VREG+END,
/* bReg_Modrm  */ xBYTE+MRM, BREG+COM,   MODRM+END,
/* fReg_Modrm  */ FARPTR+MRM,VREG+COM,   MODRM+END,
/* Reg_Modrm   */ VAR+MRM,   VREG+COM,   MODRM+END,
/* AL_Ib       */ ALSTR+COM, IB+END,
/* AX_Iv       */ AXSTR+COM, IV+END,
/* sReg2       */ SREG2+END,
/* oReg        */ VOREG+END,
/* DoBound     */ VAR+MRM,   VREG+COM,   MODRM+END,
/* Iv          */ IV+END,
/* wModrm_Reg  */ xWORD+MRM, LMODRM+COM, WREG+END,
/* Ib          */ IB+END,
/* Imulb       */ VAR+MRM,   VREG+COM,   MODRM+COM, IB+END,
/* Imul        */ VAR+MRM,   VREG+COM,   MODRM+COM, IV+END,
/* REL8        */ REL8+END,
/* bModrm_Ib   */ xBYTE+MRM, LMODRM+COM, IB+END,
/* Modrm_Ib    */ VAR+MRM,   LMODRM+COM, IB+END,
/* Modrm_Iv    */ VAR+MRM,   LMODRM+COM, IV+END,
/* Modrm_sReg3 */ xWORD+MRM, MODRM+COM,  SREG3+END,
/* sReg3_Modrm */ xWORD+MRM, SREG3+COM,  MODRM+END,
/* Modrm       */ VAR+MRM,   MODRM+END,
/* FarPtr      */ ADDRP+END,
/* AL_Offs     */ ALSTR+COM, OFFS+END,
/* Offs_AL     */ OFFS+COM,  ALSTR+END,
/* AX_Offs     */ AXSTR+COM, OFFS+END,
/* Offs_AX     */ OFFS+COM,  AXSTR+END,
/* oReg_Ib     */ BOREG+COM, IB+END,
/* oReg_Iv     */ VOREG+COM, IV+END,
/* Iw          */ IW+END,
/* enter       */ IW+COM,    IB+END,
/* Ubyte_AL    */ UBYTE+COM, ALSTR+END,
/* Ubyte_AX    */ UBYTE+COM, AXSTR+END,
/* AL_Ubyte    */ ALSTR+COM, UBYTE+END,
/* AX_Ubyte    */ AXSTR+COM, UBYTE+END,
/* DoInAL      */ ALSTR+COM, WRSTR+END,  2,
/* DoInAX      */ AXSTR+COM, WRSTR+END,  2,
/* DoOutAL     */ WRSTR+COM, 2,          ALSTR+END,
/* DoOutAX     */ WRSTR+COM, 2,          AXSTR+END,
/* REL16       */ REL16+END,
/* ADR_OVERRIDE*/ ADR_OVR,
/* OPR_OVERRIDE*/ OPR_OVR,
/* SEG_OVERRIDE*/ SEG_OVR,
/* DoInt3      */ CHR+END,   '3',
/* DoInt       */ UBYTE+END,
/* Opcode0F    */ OPC0F,
/* group1_1    */ xBYTE+MRM, GROUP,      0,         LMODRM+COM, IB+END,
/* group1_3    */ VAR+MRM,   GROUP,      0,         LMODRM+COM, IB+END,
/* group1_2    */ VAR+MRM,   GROUP,      0,         LMODRM+COM, IV+END,
/* group2_1    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, IB+END,
/* group2_2    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, IB+END,
/* group2_3    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, CHR+END, '1',
/* group2_4    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, CHR+END, '1',
/* group2_5    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, BRSTR+END, 1,
/* group2_6    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, BRSTR+END, 1,
/* group4      */ xBYTE+MRM, GROUP,      2,         LMODRM+END,
/* group6      */ xWORD+MRM, GROUP,      3,         LMODRM+END,
/* group8      */ xWORD+MRM, GROUP,      4,         LMODRM+COM, IB+END,
/* group3_1    */ xBYTE+MRM, GROUPT,     20,
/* group3_2    */ VAR+MRM,   GROUPT,     21,
/* group5      */ VAR+MRM,   GROUPT,     22,
/* group7      */ NOP+MRM,   GROUPT,     23,
/* x87_ESC     */ NOP+MRM,   EGROUPT,
/* bModrm      */ xBYTE+MRM, LMODRM+END,
/* wModrm      */ xWORD+MRM, LMODRM+END,
/* dModrm      */ xDWORD+MRM,LMODRM+END,
/* fModrm      */ FARPTR+MRM,LMODRM+END,
/* vModrm      */ VAR+MRM,   LMODRM+END,
/* vModrm_Iv   */ VAR+MRM,   LMODRM+COM, IV+END,
/* reg_bModrm  */ xBYTE+MRM, VREG+COM,   LMODRM+END,
/* reg_wModrm  */ xWORD+MRM, VREG+COM,   LMODRM+END,
/* Modrm_Reg_Ib*/ VAR+MRM,   MODRM+COM,  VREG+COM,   IB+END,
/* Modrm_Reg_CL*/ VAR+MRM,   MODRM+COM,  VREG+COM,   BRSTR+END, 1,
/* ST_iST      */ NOP+MRM,   ST_IST+END,
/* iST         */ NOP+MRM,   IST+END,
/* iST_ST      */ NOP+MRM,   IST_ST+END,
/* qModrm      */ QWORD+MRM, LMODRM+END,
/* tModrm      */ TBYTE+MRM, LMODRM+END,
/* REP         */ REP,
/* Modrm_CReg  */ EDWORD+MRM,MODRM+COM,  CREG+END,
/* CReg_Modrm  */ EDWORD+MRM,CREG+COM,   MODRM+END,
/* AX_oReg     */ AXSTR+COM, VOREG+END,
/* MmReg_qModrm*/ MMQWORD+MRM, MMWREG+COM, LMODRM+END,
/* qModrm_MmReg*/ MMQWORD+MRM, MODRM+COM,  MMWREG+END,
/* MmReg_dModrm*/ xDWORD+MRM, MMWREG+COM,LMODRM+END,
/* dModrm_MmReg*/ xDWORD+MRM, MODRM+COM, MMWREG+END,
/* qModrm_Ib   */ MMQWORD+MRM, MODRM+COM,IB+END,
/* PSHimw      */ MMQWORD+MRM, GROUP,    5,          LMODRM+COM, IB+END,
/* PSHimd      */ MMQWORD+MRM, GROUP,    6,          LMODRM+COM, IB+END,
/* PSHimq      */ MMQWORD+MRM, GROUP,    7,          LMODRM+COM, IB+END,
                  };

#if defined(_M_IX86)
#define BUILDING_ON_X86 1
#else
#define BUILDING_ON_X86 0
#endif

#if BUILDING_ON_X86 == 1
#pragma pack(1)
#endif

typedef struct Tdistbl{
    char *instruct;
    ActionIndex opr;
    } Tdistbl;

#if BUILDING_ON_X86 == 1
#pragma pack()
#endif

//
// Secondary opcode table is compressed - only "filled" locations are
// allocated space in distbl. Offsets for indexing into the secondary
// opcode table are calculcated as follows and defined below.
//
//  Pack#  Opcodes in Pack  #Ops before   Offset(add to opcode)
//     1     0h -  Bh            0            256 (# of primary opcodes)
//     2    20h - 26h           12        256-32+12 = 236
//     3    30h - 33h           19        256-48+19 = 227
//     4    40h - 4fh           23        256-64+23 = 215
//     5    60h - feh           39        256-96+39 = 199
//

#define SECTAB_OFFSET_1 256
#define SECTAB_OFFSET_2 236
#define SECTAB_OFFSET_3 227
#define SECTAB_OFFSET_4 215
#define SECTAB_OFFSET_5 199
#define SECTAB_OFFSET_UNDEF 260

/* List of ordered pairs for each instruction:                           */
/*    (pointer to string literal mnemonic,                               */
/*     instruction class index for action table)                         */

static Tdistbl distbl[] = {
    dszADD,   O_bModrm_Reg,             /* 00 ADD mem/reg, reg (byte)    */
    dszADD,   O_Modrm_Reg,              /* 01 ADD mem/reg, reg (word)    */
    dszADD,   O_bReg_Modrm,             /* 02 ADD reg, mem/reg (byte)    */
    dszADD,   O_Reg_Modrm,              /* 03 ADD reg, mem/reg (word)    */
    dszADD,   O_AL_Ib,                  /* 04 ADD AL, I                  */
    dszADD,   O_AX_Iv,                  /* 05 ADD AX, I                  */
    dszPUSH,  O_sReg2,                  /* 06 PUSH ES                    */
    dszPOP,   O_sReg2,                  /* 07 POP ES                     */
    dszOR,    O_bModrm_Reg,             /* 08 OR mem/reg, reg (byte)     */
    dszOR,    O_Modrm_Reg,              /* 09 OR mem/reg, reg (word)     */
    dszOR,    O_bReg_Modrm,             /* 0A OR reg, mem/reg (byte)     */
    dszOR,    O_Reg_Modrm,              /* 0B OR reg, mem/reg (word)     */
    dszOR,    O_AL_Ib,                  /* 0C OR AL, I                   */
    dszOR,    O_AX_Iv,                  /* 0D OR AX, I                   */
    dszPUSH,  O_sReg2,                  /* 0E PUSH CS                    */
    dszMULTI, O_OPC0F,                  /* 0F CLTS & protection ctl(286) */
    dszADC,   O_bModrm_Reg,             /* 10 ADC mem/reg, reg (byte)    */
    dszADC,   O_Modrm_Reg,              /* 11 ADC mem/reg, reg (word)    */
    dszADC,   O_bReg_Modrm,             /* 12 ADC reg, mem/reg (byte)    */
    dszADC,   O_Reg_Modrm,              /* 13 ADC reg, mem/reg (word)    */
    dszADC,   O_AL_Ib,                  /* 14 ADC AL, I                  */
    dszADC,   O_AX_Iv,                  /* 15 ADC AX, I                  */
    dszPUSH,  O_sReg2,                  /* 16 PUSH SS                    */
    dszPOP,   O_sReg2,                  /* 17 POP SS                     */
    dszSBB,   O_bModrm_Reg,             /* 18 SBB mem/reg, reg (byte)    */
    dszSBB,   O_Modrm_Reg,              /* 19 SBB mem/reg, reg (word)    */
    dszSBB,   O_bReg_Modrm,             /* 1A SBB reg, mem/reg (byte)    */
    dszSBB,   O_Reg_Modrm,              /* 1B SBB reg, mem/reg (word)    */
    dszSBB,   O_AL_Ib,                  /* 1C SBB AL, I                  */
    dszSBB,   O_AX_Iv,                  /* 1D SBB AX, I                  */
    dszPUSH,  O_sReg2,                  /* 1E PUSH DS                    */
    dszPOP,   O_sReg2,                  /* 1F POP DS                     */
    dszAND,   O_bModrm_Reg,             /* 20 AND mem/reg, reg (byte)    */
    dszAND,   O_Modrm_Reg,              /* 21 AND mem/reg, reg (word)    */
    dszAND,   O_bReg_Modrm,             /* 22 AND reg, mem/reg (byte)    */
    dszAND,   O_Reg_Modrm,              /* 23 AND reg, mem/reg (word)    */
    dszAND,   O_AL_Ib,                  /* 24 AND AL, I                  */
    dszAND,   O_AX_Iv,                  /* 25 AND AX, I                  */
    dszES_,   O_SEG_OVERRIDE,           /* 26 SEG ES:                    */
    dszDAA,   O_NoOperands,             /* 27 DAA                        */
    dszSUB,   O_bModrm_Reg,             /* 28 SUB mem/reg, reg (byte)    */
    dszSUB,   O_Modrm_Reg,              /* 29 SUB mem/reg, reg (word)    */
    dszSUB,   O_bReg_Modrm,             /* 2A SUB reg, mem/reg (byte)    */
    dszSUB,   O_Reg_Modrm,              /* 2B SUB reg, mem/reg (word)    */
    dszSUB,   O_AL_Ib,                  /* 2C SUB AL, I                  */
    dszSUB,   O_AX_Iv,                  /* 2D SUB AX, I                  */
    dszCS_,   O_SEG_OVERRIDE,           /* 2E SEG CS:                    */
    dszDAS,   O_NoOperands,             /* 2F DAS                        */
    dszXOR,   O_bModrm_Reg,             /* 30 XOR mem/reg, reg (byte)    */
    dszXOR,   O_Modrm_Reg,              /* 31 XOR mem/reg, reg (word)    */
    dszXOR,   O_bReg_Modrm,             /* 32 XOR reg, mem/reg (byte)    */
    dszXOR,   O_Reg_Modrm,              /* 33 XOR reg, mem/reg (word)    */
    dszXOR,   O_AL_Ib,                  /* 34 XOR AL, I                  */
    dszXOR,   O_AX_Iv,                  /* 35 XOR AX, I                  */
    dszSS_,   O_SEG_OVERRIDE,           /* 36 SEG SS:                    */
    dszAAA,   O_NoOperands,             /* 37 AAA                        */
    dszCMP,   O_bModrm_Reg,             /* 38 CMP mem/reg, reg (byte)    */
    dszCMP,   O_Modrm_Reg,              /* 39 CMP mem/reg, reg (word)    */
    dszCMP,   O_bReg_Modrm,             /* 3A CMP reg, mem/reg (byte)    */
    dszCMP,   O_Reg_Modrm,              /* 3B CMP reg, mem/reg (word)    */
    dszCMP,   O_AL_Ib,                  /* 3C CMP AL, I                  */
    dszCMP,   O_AX_Iv,                  /* 3D CMP AX, I                  */
    dszDS_,   O_SEG_OVERRIDE,           /* 3E SEG DS:                    */
    dszAAS,   O_NoOperands,             /* 3F AAS                        */
    dszINC,   O_oReg,                   /* 40 INC AX                     */
    dszINC,   O_oReg,                   /* 41 INC CX                     */
    dszINC,   O_oReg,                   /* 42 INC DX                     */
    dszINC,   O_oReg,                   /* 43 INC BX                     */
    dszINC,   O_oReg,                   /* 44 INC SP                     */
    dszINC,   O_oReg,                   /* 45 INC BP                     */
    dszINC,   O_oReg,                   /* 46 INC SI                     */
    dszINC,   O_oReg,                   /* 47 INC DI                     */
    dszDEC,   O_oReg,                   /* 48 DEC AX                     */
    dszDEC,   O_oReg,                   /* 49 DEC CX                     */
    dszDEC,   O_oReg,                   /* 4A DEC DX                     */
    dszDEC,   O_oReg,                   /* 4B DEC BX                     */
    dszDEC,   O_oReg,                   /* 4C DEC SP                     */
    dszDEC,   O_oReg,                   /* 4D DEC BP                     */
    dszDEC,   O_oReg,                   /* 4E DEC SI                     */
    dszDEC,   O_oReg,                   /* 4F DEC DI                     */
    dszPUSH,  O_oReg,                   /* 50 PUSH AX                    */
    dszPUSH,  O_oReg,                   /* 51 PUSH CX                    */
    dszPUSH,  O_oReg,                   /* 52 PUSH DX                    */
    dszPUSH,  O_oReg,                   /* 53 PUSH BX                    */
    dszPUSH,  O_oReg,                   /* 54 PUSH SP                    */
    dszPUSH,  O_oReg,                   /* 55 PUSH BP                    */
    dszPUSH,  O_oReg,                   /* 56 PUSH SI                    */
    dszPUSH,  O_oReg,                   /* 57 PUSH DI                    */
    dszPOP,   O_oReg,                   /* 58 POP AX                     */
    dszPOP,   O_oReg,                   /* 59 POP CX                     */
    dszPOP,   O_oReg,                   /* 5A POP DX                     */
    dszPOP,   O_oReg,                   /* 5B POP BX                     */
    dszPOP,   O_oReg,                   /* 5C POP SP                     */
    dszPOP,   O_oReg,                   /* 5D POP BP                     */
    dszPOP,   O_oReg,                   /* 5E POP SI                     */
    dszPOP,   O_oReg,                   /* 5F POP DI                     */
    dszPUSHA, O_NoOpAlt5,               /* 60 PUSHA (286) / PUSHAD (386) */
    dszPOPA,  O_NoOpAlt4,               /* 61 POPA (286) / POPAD (286)   */
    dszBOUND, O_DoBound,                /* 62 BOUND reg, Modrm (286)     */
    dszARPL,  O_Modrm_Reg,              /* 63 ARPL Modrm, reg (286)      */
    dszFS_,   O_SEG_OVERRIDE,           /* 64                            */
    dszGS_,   O_SEG_OVERRIDE,           /* 65                            */
    dszOPPRFX,O_OPR_OVERRIDE,           /* 66                            */
    dszADDRPRFX,O_ADR_OVERRIDE,         /* 67                            */
    dszPUSH,  O_Iv,                     /* 68 PUSH word (286)            */
    dszIMUL,  O_Imul,                   /* 69 IMUL (286)                 */
    dszPUSH,  O_Ib,                     /* 6A PUSH byte (286)            */
    dszIMUL,  O_Imulb,                  /* 6B IMUL (286)                 */
    dszINSB,  O_NoOperands,             /* 6C INSB (286)                 */
    dszINSW,  O_NoOpAlt3,               /* 6D INSW (286) / INSD (386)    */
    dszOUTSB, O_NoOperands,             /* 6E OUTSB (286)                */
    dszOUTSW, O_NoOpAlt4,               /* 6F OUTSW (286) / OUTSD (386)  */
    dszJO,    O_Rel8,                   /* 70 JO                         */
    dszJNO,   O_Rel8,                   /* 71 JNO                        */
    dszJB,    O_Rel8,                   /* 72 JB or JNAE or JC           */
    dszJNB,   O_Rel8,                   /* 73 JNB or JAE or JNC          */
    dszJZ,    O_Rel8,                   /* 74 JE or JZ                   */
    dszJNZ,   O_Rel8,                   /* 75 JNE or JNZ                 */
    dszJBE,   O_Rel8,                   /* 76 JBE or JNA                 */
    dszJA,    O_Rel8,                   /* 77 JNBE or JA                 */
    dszJS,    O_Rel8,                   /* 78 JS                         */
    dszJNS,   O_Rel8,                   /* 79 JNS                        */
    dszJPE,   O_Rel8,                   /* 7A JP or JPE                  */
    dszJPO,   O_Rel8,                   /* 7B JNP or JPO                 */
    dszJL,    O_Rel8,                   /* 7C JL or JNGE                 */
    dszJGE,   O_Rel8,                   /* 7D JNL or JGE                 */
    dszJLE,   O_Rel8,                   /* 7E JLE or JNG                 */
    dszJG,    O_Rel8,                   /* 7F JNLE or JG                 */
    dszMULTI, O_GROUP11,                /* 80                            */
    dszMULTI, O_GROUP12,                /* 81                            */
    dszRESERVED, O_DoDB,                /* 82                            */
    dszMULTI, O_GROUP13,                /* 83                            */
    dszTEST,  O_bModrm_Reg,             /* 84 TEST reg, mem/reg (byte)   */
    dszTEST,  O_Modrm_Reg,              /* 85 TEST reg, mem/reg (word)   */
    dszXCHG,  O_bModrm_Reg,             /* 86 XCHG reg, mem/reg (byte)   */
    dszXCHG,  O_Modrm_Reg,              /* 87 XCHG reg, mem/reg (word)   */
    dszMOV,   O_bModrm_Reg,             /* 88 MOV mem/reg, reg (byte)    */
    dszMOV,   O_Modrm_Reg,              /* 89 MOV mem/reg, reg (word)    */
    dszMOV,   O_bReg_Modrm,             /* 8A MOV reg, mem/reg (byte)    */
    dszMOV,   O_Reg_Modrm,              /* 8B MOV reg, mem/reg (word)    */
    dszMOV,   O_Modrm_sReg3,            /* 8C MOV mem/reg, segreg        */
    dszLEA,   O_Reg_Modrm,              /* 8D LEA reg, mem               */
    dszMOV,   O_sReg3_Modrm,            /* 8E MOV segreg, mem/reg        */
    dszPOP,   O_Modrm,                  /* 8F POP mem/reg                */
    dszNOP,   O_NoOperands,             /* 90 NOP                        */
    dszXCHG,  O_AX_oReg,                /* 91 XCHG AX,CX                 */
    dszXCHG,  O_AX_oReg,                /* 92 XCHG AX,DX                 */
    dszXCHG,  O_AX_oReg,                /* 93 XCHG AX,BX                 */
    dszXCHG,  O_AX_oReg,                /* 94 XCHG AX,SP                 */
    dszXCHG,  O_AX_oReg,                /* 95 XCHG AX,BP                 */
    dszXCHG,  O_AX_oReg,                /* 96 XCHG AX,SI                 */
    dszXCHG,  O_AX_oReg,                /* 97 XCHG AX,DI                 */
    dszCBW,   O_NoOpAlt0,               /* 98 CBW / CWDE (386)           */
    dszCWD,   O_NoOpAlt1,               /* 99 CWD / CDQ (386)            */
    dszCALL,  O_FarPtr,                 /* 9A CALL seg:off               */
    dszWAIT,  O_NoOperands,             /* 9B WAIT                       */
    dszPUSHF, O_NoOpAlt5,               /* 9C PUSHF / PUSHFD (386)       */
    dszPOPF,  O_NoOpAlt4,               /* 9D POPF / POPFD (386)         */
    dszSAHF,  O_NoOperands,             /* 9E SAHF                       */
    dszLAHF,  O_NoOperands,             /* 9F LAHF                       */
    dszMOV,   O_AL_Offs,                /* A0 MOV AL, mem                */
    dszMOV,   O_AX_Offs,                /* A1 MOV AX, mem                */
    dszMOV,   O_Offs_AL,                /* A2 MOV mem, AL                */
    dszMOV,   O_Offs_AX,                /* A3 MOV mem, AX                */
    dszMOVSB, O_NoOpStrSIDI,            /* A4 MOVSB                      */
    dszMOVSW, O_NoOpStrSIDI,            /* A5 MOVSW / MOVSD (386)        */
    dszCMPSB, O_NoOpStrSIDI,            /* A6 CMPSB                      */
    dszCMPSW, O_NoOpStrSIDI,            /* A7 CMPSW / CMPSD (386)        */
    dszTEST,  O_AL_Ib,                  /* A8 TEST AL, I                 */
    dszTEST,  O_AX_Iv,                  /* A9 TEST AX, I                 */
    dszSTOSB, O_NoOpStrDI,              /* AA STOSB                      */
    dszSTOSW, O_NoOpStrDI,              /* AB STOSW / STOSD (386)        */
    dszLODSB, O_NoOpStrSI,              /* AC LODSB                      */
    dszLODSW, O_NoOpStrSI,              /* AD LODSW / LODSD (386)        */
    dszSCASB, O_NoOpStrDI,              /* AE SCASB                      */
    dszSCASW, O_NoOpStrDI,              /* AF SCASW / SCASD (386)        */
    dszMOV,   O_oReg_Ib,                /* B0 MOV AL, I                  */
    dszMOV,   O_oReg_Ib,                /* B1 MOV CL, I                  */
    dszMOV,   O_oReg_Ib,                /* B2 MOV DL, I                  */
    dszMOV,   O_oReg_Ib,                /* B3 MOV BL, I                  */
    dszMOV,   O_oReg_Ib,                /* B4 MOV AH, I                  */
    dszMOV,   O_oReg_Ib,                /* B5 MOV CH, I                  */
    dszMOV,   O_oReg_Ib,                /* B6 MOV DH, I                  */
    dszMOV,   O_oReg_Ib,                /* B7 MOV BH, I                  */
    dszMOV,   O_oReg_Iv,                /* B8 MOV AX, I                  */
    dszMOV,   O_oReg_Iv,                /* B9 MOV CX, I                  */
    dszMOV,   O_oReg_Iv,                /* BA MOV DX, I                  */
    dszMOV,   O_oReg_Iv,                /* BB MOV BX, I                  */
    dszMOV,   O_oReg_Iv,                /* BC MOV SP, I                  */
    dszMOV,   O_oReg_Iv,                /* BD MOV BP, I                  */
    dszMOV,   O_oReg_Iv,                /* BE MOV SI, I                  */
    dszMOV,   O_oReg_Iv,                /* BF MOV DI, I                  */
    dszMULTI, O_GROUP21,                /* C0 shifts & rotates (286)     */
    dszMULTI, O_GROUP22,                /* C1 shifts & rotates (286)     */
    dszRET,   O_Iw,                     /* C2 RET Rel16                  */
    dszRET,   O_NoOperands,             /* C3 RET                        */
    dszLES,   O_fReg_Modrm,             /* C4 LES reg, mem               */
    dszLDS,   O_fReg_Modrm,             /* C5 LDS reg, mem               */
    dszMOV,   O_bModrm_Ib,              /* C6 MOV mem/reg, I(byte)       */
    dszMOV,   O_Modrm_Iv,               /* C7 MOV mem/reg, I(word)       */
    dszENTER, O_Enter,                  /* C8 ENTER (286)                */
    dszLEAVE, O_NoOperands,             /* C9 LEAVE (286)                */
    dszRETF,  O_Iw,                     /* CA RETF I(word)               */
    dszRETF,  O_NoOperands,             /* CB RETF                       */
    dszINT,   O_DoInt3,                 /* CC INT 3                      */
    dszINT,   O_DoInt,                  /* CD INT                        */
    dszINTO,  O_NoOperands,             /* CE INTO                       */
    dszIRET,  O_NoOpAlt4,               /* CF IRET / IRETD (386)         */
    dszMULTI, O_GROUP23,                /* D0 shifts & rotates,1 (byte)  */
    dszMULTI, O_GROUP24,                /* D1 shifts & rotates,1 (word)  */
    dszMULTI, O_GROUP25,                /* D2 shifts & rotates,CL (byte) */
    dszMULTI, O_GROUP26,                /* D3 shifts & rotates,CL (word) */
    dszAAM,   O_Ib,                     /* D4 AAM                        */
    dszAAD,   O_Ib,                     /* D5 AAD                        */
    dszRESERVED, O_DoDB,                /* D6                            */
    dszXLAT,  O_NoOperands,             /* D7 XLAT                       */
    dszMULTI, O_x87_ESC,                /* D8 ESC                        */
    dszMULTI, O_x87_ESC,                /* D9 ESC                        */
    dszMULTI, O_x87_ESC,                /* DA ESC                        */
    dszMULTI, O_x87_ESC,                /* DB ESC                        */
    dszMULTI, O_x87_ESC,                /* DC ESC                        */
    dszMULTI, O_x87_ESC,                /* DD ESC                        */
    dszMULTI, O_x87_ESC,                /* DE ESC                        */
    dszMULTI, O_x87_ESC,                /* DF ESC                        */
    dszLOOPNE,O_Rel8,                   /* E0 LOOPNE or LOOPNZ           */
    dszLOOPE, O_Rel8,                   /* E1 LOOPE or LOOPZ             */
    dszLOOP,  O_Rel8,                   /* E2 LOOP                       */
    dszJCXZ,  O_Rel8,                   /* E3 JCXZ / JECXZ (386)         */
    dszIN,    O_AL_Ubyte,               /* E4 IN AL, I                   */
    dszIN,    O_AX_Ubyte,               /* E5 IN AX, I                   */
    dszOUT,   O_Ubyte_AL,               /* E6 OUT I, AL                  */
    dszOUT,   O_Ubyte_AX,               /* E7 OUT I, AX                  */
    dszCALL,  O_Rel16,                  /* E8 CALL Rel16                 */
    dszJMP,   O_Rel16,                  /* E9 JMP Rel16                  */
    dszJMP,   O_FarPtr,                 /* EA JMP seg:off                */
    dszJMP,   O_Rel8,                   /* EB JMP Rel8                   */
    dszIN,    O_DoInAL,                 /* EC IN AL, DX                  */
    dszIN,    O_DoInAX,                 /* ED IN AX, DX                  */
    dszOUT,   O_DoOutAL,                /* EE OUT DX, AL                 */
    dszOUT,   O_DoOutAX,                /* EF OUT DX, AX                 */
    dszLOCK,  O_DoRep,                  /* F0 LOCK                       */
    dszRESERVED, O_DoDB,                /* F1                            */
    dszREPNE, O_DoRep,                  /* F2 REPNE or REPNZ             */
    dszREP,   O_DoRep,                  /* F3 REP or REPE or REPZ        */
    dszHLT,   O_NoOperands,             /* F4 HLT                        */
    dszCMC,   O_NoOperands,             /* F5 CMC                        */
    dszMULTI, O_GROUP31,                /* F6 TEST, NOT, NEG, MUL, IMUL, */
    dszMULTI, O_GROUP32,                /* F7 DIv, IDIv F6=Byte F7=Word  */
    dszCLC,   O_NoOperands,             /* F8 CLC                        */
    dszSTC,   O_NoOperands,             /* F9 STC                        */
    dszCLI,   O_NoOperands,             /* FA CLI                        */
    dszSTI,   O_NoOperands,             /* FB STI                        */
    dszCLD,   O_NoOperands,             /* FC CLD                        */
    dszSTD,   O_NoOperands,             /* FD STD                        */
    dszMULTI, O_GROUP4,                 /* FE INC, DEC mem/reg (byte)    */
    dszMULTI, O_GROUP5,                 /* FF INC, DEC, CALL, JMP, PUSH  */

    // secondary opcode table begins. Only "filled" locations are stored
    // to compress the secondary table. Hence while disassembling
    // opcode needs to be displaced appropriately to account for the.
    // The displacements are defined in 86dis.c and need to be reevaluated
    // if new opcodes are added here.

    dszMULTI, O_GROUP6,                 /* 0 MULTI                       */
    dszMULTI, O_GROUP7,                 /* 1 MULTI                       */
    dszLAR,   O_Reg_Modrm,              /* 2 LAR                         */
    dszLSL,   O_Reg_Modrm,              /* 3 LSL                         */
    dszRESERVED, O_DoDB,                /* 4                             */
    dszLOADALL, O_NoOperands,           /* 5 LOADALL                     */
    dszCLTS,  O_NoOperands,             /* 6 CLTS                        */
    dszMULTI, O_GROUP7,                 /* 7 MULTI                       */
    dszINVD,  O_NoOperands,             /* 8 INVD                        */
    dszWBINVD,O_NoOperands,             /* 9 WBINVD                      */
    dszRESERVED, O_DoDB,                /* A                             */
    dszUD2,   O_NoOperands,             /* B UD2 undefined               */
    dszMOV,   O_Modrm_CReg,             /* 20 MOV Rd,Cd                  */
    dszMOV,   O_Modrm_CReg,             /* 21 MOV Rd,Dd                  */
    dszMOV,   O_CReg_Modrm,             /* 22 MOV Cd,Rd                  */
    dszMOV,   O_CReg_Modrm,             /* 23 MOV Dd,Rd                  */
    dszMOV,   O_Modrm_CReg,             /* 24 MOV Rd,Td                  */
    dszRESERVED, O_DoDB,                /* 25                            */
    dszMOV,   O_CReg_Modrm,             /* 26 MOV Td,Rd                  */

    dszWRMSR, O_NoOperands,             /* 30 WRMSR                      */
    dszRDTSC, O_NoOperands,             /* 31 RDTSC                      */
    dszRDMSR, O_NoOperands,             /* 32 RDMSR                      */
    dszRDPMC, O_NoOperands,             /* 33 RDPMC                      */

    dszCMOVO,  O_Reg_Modrm,             /* 40 CMOVO                      */
    dszCMOVNO, O_Reg_Modrm,             /* 41 CMOVNO                     */
    dszCMOVB,  O_Reg_Modrm,             /* 42 CMOVB                      */
    dszCMOVNB, O_Reg_Modrm,             /* 43 CMOVNB                     */
    dszCMOVE,  O_Reg_Modrm,             /* 44 CMOVE                      */
    dszCMOVNE, O_Reg_Modrm,             /* 45 CMOVNE                     */
    dszCMOVBE, O_Reg_Modrm,             /* 46 CMOVBE                     */
    dszCMOVA,  O_Reg_Modrm,             /* 47 CMOVNBE                    */
    dszCMOVS,  O_Reg_Modrm,             /* 48 CMOVS                      */
    dszCMOVNS, O_Reg_Modrm,             /* 49 CMOVNS                     */
    dszCMOVP,  O_Reg_Modrm,             /* 4A CMOVP                      */
    dszCMOVNP, O_Reg_Modrm,             /* 4B CMOVNP                     */
    dszCMOVL,  O_Reg_Modrm,             /* 4C CMOVL                      */
    dszCMOVGE, O_Reg_Modrm,             /* 4D CMOVGE                     */
    dszCMOVLE, O_Reg_Modrm,             /* 4E CMOVLE                     */
    dszCMOVNLE,O_Reg_Modrm,             /* 4F CMOVNLE                    */

    dszPUNPCKLBW,O_MmReg_qModrm,        /* 60 PUNPCKLBW                  */
    dszPUNPCKLWD,O_MmReg_qModrm,        /* 61 PUNPCKLWD                  */
    dszPUNPCKLDQ,O_MmReg_qModrm,        /* 62 PUNPCKLDQ                  */
    dszPACKSSWB, O_MmReg_qModrm,        /* 63 PACKSSWB                   */
    dszPCMPGTB,  O_MmReg_qModrm,        /* 64 PCMPGTB                    */
    dszPCMPGTW,  O_MmReg_qModrm,        /* 65 PCMPGTW                    */
    dszPCMPGTD,  O_MmReg_qModrm,        /* 66 PCMPGTD                    */
    dszPACKUSWB, O_MmReg_qModrm,        /* 67 PACKUSWB                   */
    dszPUNPCKHBW,O_MmReg_qModrm,        /* 68 PUNPCKHBW                  */
    dszPUNPCKHWD,O_MmReg_qModrm,        /* 69 PUNPCKHWD                  */
    dszPUNPCKHDQ,O_MmReg_qModrm,        /* 6A PUNPCKHDQ                  */
    dszPACKSSDW, O_MmReg_qModrm,        /* 6B PACKSSDW                   */
    dszRESERVED, O_DoDB,                /* 6C                            */
    dszRESERVED, O_DoDB,                /* 6D                            */
    dszMOVD,     O_MmReg_dModrm,        /* 6E MOVD                       */
    dszMOVQ,     O_MmReg_qModrm,        /* 6F MOVQ                       */
    dszRESERVED, O_DoDB,                /* 70                            */
    dszMULTI,    O_PSHimw,              /* 71 PS[LR][AL]W immediate      */
    dszMULTI,    O_PSHimd,              /* 72 PS[LR][AL]D immediate      */
    dszMULTI,    O_PSHimq,              /* 73 PS[LR]LQ immediate         */
    dszPCMPEQB,  O_MmReg_qModrm,        /* 74 PCMPEQB                    */
    dszPCMPEQW,  O_MmReg_qModrm,        /* 75 PCMPEQW                    */
    dszPCMPEQD,  O_MmReg_qModrm,        /* 76 PCMPEQD                    */
    dszEMMS,     O_NoOperands,          /* 77 EMMS                       */
    dszRESERVED, O_DoDB,                /* 78                            */
    dszRESERVED, O_DoDB,                /* 79                            */
    dszRESERVED, O_DoDB,                /* 7A                            */
    dszRESERVED, O_DoDB,                /* 7B                            */
    dszRESERVED, O_DoDB,                /* 7C                            */
    dszSETNL,    O_bModrm,              /* 7D SETNL                      */
    dszMOVD,     O_dModrm_MmReg,        /* 7E MOVD                       */
    dszMOVQ,     O_qModrm_MmReg,        /* 7F MOVQ                       */
    dszJO,    O_Rel16,                  /* 80 JO                         */
    dszJNO,   O_Rel16,                  /* 81 JNO                        */
    dszJB,    O_Rel16,                  /* 82 JB                         */
    dszJNB,   O_Rel16,                  /* 83 JNB                        */
    dszJE,    O_Rel16,                  /* 84 JE                         */
    dszJNE,   O_Rel16,                  /* 85 JNE                        */
    dszJBE,   O_Rel16,                  /* 86 JBE                        */
    dszJNBE,  O_Rel16,                  /* 87 JNBE                       */
    dszJS,    O_Rel16,                  /* 88 JS                         */
    dszJNS,   O_Rel16,                  /* 89 JNS                        */
    dszJP,    O_Rel16,                  /* 8A JP                         */
    dszJNP,   O_Rel16,                  /* 8B JNP                        */
    dszJL,    O_Rel16,                  /* 8C JL                         */
    dszJNL,   O_Rel16,                  /* 8D JNL                        */
    dszJLE,   O_Rel16,                  /* 8E JLE                        */
    dszJNLE,  O_Rel16,                  /* 8F JNLE                       */
    dszSETO,  O_bModrm,                 /* 90 SETO                       */
    dszSETNO, O_bModrm,                 /* 91 SETNO                      */
    dszSETB,  O_bModrm,                 /* 92 SETB                       */
    dszSETNB, O_bModrm,                 /* 93 SETNB                      */
    dszSETE,  O_bModrm,                 /* 94 SETE                       */
    dszSETNE, O_bModrm,                 /* 95 SETNE                      */
    dszSETBE, O_bModrm,                 /* 96 SETBE                      */
    dszSETA,  O_bModrm,                 /* 97 SETNBE                     */
    dszSETS,  O_bModrm,                 /* 98 SETS                       */
    dszSETNS, O_bModrm,                 /* 99 SETNS                      */
    dszSETP,  O_bModrm,                 /* 9A SETP                       */
    dszSETNP, O_bModrm,                 /* 9B SETNP                      */
    dszSETL,  O_bModrm,                 /* 9C SETL                       */
    dszSETGE, O_bModrm,                 /* 9D SETGE                      */
    dszSETLE, O_bModrm,                 /* 9E SETLE                      */
    dszSETNLE,O_bModrm,                 /* 9F SETNLE                     */
    dszPUSH,  O_sReg2,                  /* A0 PUSH FS                    */
    dszPOP,   O_sReg2,                  /* A1 POP FS                     */
    dszCPUID, O_NoOperands,             /* A2 CPUID                      */
    dszBT,    O_Modrm_Reg,              /* A3 BT                         */
    dszSHLD,  O_Modrm_Reg_Ib,           /* A4 SHLD                       */
    dszSHLD,  O_Modrm_Reg_CL,           /* A5 SHLD                       */
    dszRESERVED, O_DoDB,                /* A6                            */
    dszRESERVED, O_DoDB,                /* A7                            */
    dszPUSH,  O_sReg2,                  /* A8 PUSH GS                    */
    dszPOP,   O_sReg2,                  /* A9 POP GS                     */
    dszRSM,   O_NoOperands,             /* AA RSM                        */
    dszBTS,   O_vModrm_Reg,             /* AB BTS                        */
    dszSHRD,  O_Modrm_Reg_Ib,           /* AC SHRD                       */
    dszSHRD,  O_Modrm_Reg_CL,           /* AD SHRD                       */
    dszRESERVED, O_DoDB,                /* AE                            */
    dszIMUL,  O_Reg_Modrm,              /* AF IMUL                       */
    dszCMPXCHG,O_bModrm_Reg,            /* B0 CMPXCH                     */
    dszCMPXCHG,O_Modrm_Reg,             /* B1 CMPXCH                     */
    dszLSS,   O_fReg_Modrm,             /* B2 LSS                        */
    dszBTR,   O_Modrm_Reg,              /* B3 BTR                        */
    dszLFS,   O_fReg_Modrm,             /* B4 LFS                        */
    dszLGS,   O_fReg_Modrm,             /* B5 LGS                        */
    dszMOVZX, O_Reg_bModrm,             /* B6 MOVZX                      */
    dszMOVZX, O_Reg_wModrm,             /* B7 MOVZX                      */
    dszRESERVED, O_DoDB,                /* B8                            */
    dszRESERVED, O_DoDB,                /* B9                            */
    dszMULTI, O_GROUP8,                 /* BA MULTI                      */
    dszBTC,   O_Modrm_Reg,              /* BB BTC                        */
    dszBSF,   O_Reg_Modrm,              /* BC BSF                        */
    dszBSR,   O_Reg_Modrm,              /* BD BSR                        */
    dszMOVSX, O_Reg_bModrm,             /* BE MOVSX                      */
    dszMOVSX, O_Reg_wModrm,             /* BF MOVSX                      */
    dszXADD,  O_bModrm_Reg,             /* C0 XADD                       */
    dszXADD,  O_Modrm_Reg,              /* C1 XADD                       */
    dszRESERVED, O_DoDB,                /* C2                            */
    dszRESERVED, O_DoDB,                /* C3                            */
    dszRESERVED, O_DoDB,                /* C4                            */
    dszRESERVED, O_DoDB,                /* C5                            */
    dszRESERVED, O_DoDB,                /* C6                            */
    dszCMPXCHG8B,O_qModrm,              /* C7 CMPXCHG8B                  */
    dszBSWAP,    O_oReg,                /* C8 BSWAP                      */
    dszBSWAP,    O_oReg,                /* C9 BSWAP                      */
    dszBSWAP,    O_oReg,                /* CA BSWAP                      */
    dszBSWAP,    O_oReg,                /* CB BSWAP                      */
    dszBSWAP,    O_oReg,                /* CC BSWAP                      */
    dszBSWAP,    O_oReg,                /* CD BSWAP                      */
    dszBSWAP,    O_oReg,                /* CE BSWAP                      */
    dszBSWAP,    O_oReg,                /* CF BSWAP                      */
    dszRESERVED, O_DoDB,                /* D0                            */
    dszPSRLW,    O_MmReg_qModrm,        /* D1 PSRLW                      */
    dszPSRLD,    O_MmReg_qModrm,        /* D2 PSRLD                      */
    dszPSRLQ,    O_MmReg_qModrm,        /* D3 PSRLQ                      */
    dszRESERVED, O_DoDB,                /* D4                            */
    dszPMULLW,   O_MmReg_qModrm,        /* D5 PMULLW                     */
    dszRESERVED, O_DoDB,                /* D6                            */
    dszRESERVED, O_DoDB,                /* D7                            */
    dszPSUBUSB,  O_MmReg_qModrm,        /* D8 PSUBUSB                    */
    dszPSUBUSW,  O_MmReg_qModrm,        /* D9 PSUBUSW                    */
    dszRESERVED, O_DoDB,                /* DA                            */
    dszPAND,     O_MmReg_qModrm,        /* DB PAND                       */
    dszPADDUSB,  O_MmReg_qModrm,        /* DC PADDUSB                    */
    dszPADDUSW,  O_MmReg_qModrm,        /* DD PADDUSW                    */
    dszRESERVED, O_DoDB,                /* DE                            */
    dszPANDN,    O_MmReg_qModrm,        /* DF PANDN                      */
    dszRESERVED, O_DoDB,                /* E0                            */
    dszPSRAW,    O_MmReg_qModrm,        /* E1 PSRAW                      */
    dszPSRAD,    O_MmReg_qModrm,        /* E2 PSRAD                      */
    dszRESERVED, O_DoDB,                /* E3                            */
    dszRESERVED, O_DoDB,                /* E4                            */
    dszPMULHW,   O_MmReg_qModrm,        /* E5 PMULHW                     */
    dszRESERVED, O_DoDB,                /* E6                            */
    dszRESERVED, O_DoDB,                /* E7                            */
    dszPSUBSB,   O_MmReg_qModrm,        /* E8 PSUBSB                     */
    dszPSUBSW,   O_MmReg_qModrm,        /* E9 PSUBSW                     */
    dszRESERVED, O_DoDB,                /* EA                            */
    dszPOR,      O_MmReg_qModrm,        /* EB POR                        */
    dszPADDSB,   O_MmReg_qModrm,        /* EC PADDSB                     */
    dszPADDSW,   O_MmReg_qModrm,        /* ED PADDSW                     */
    dszRESERVED, O_DoDB,                /* EE                            */
    dszPXOR,     O_MmReg_qModrm,        /* EF PXOR                       */
    dszRESERVED, O_DoDB,                /* F0                            */
    dszPSLLW,    O_MmReg_qModrm,        /* F1 PSLLW                      */
    dszPSLLD,    O_MmReg_qModrm,        /* F2 PSLLD                      */
    dszPSLLQ,    O_MmReg_qModrm,        /* F3 PSLLQ                      */
    dszRESERVED, O_DoDB,                /* F4                            */
    dszPMADDWD,  O_MmReg_qModrm,        /* F5 PMADDWD                    */
    dszRESERVED, O_DoDB,                /* F6                            */
    dszRESERVED, O_DoDB,                /* F7                            */
    dszPSUBB,    O_MmReg_qModrm,        /* F8 PSUBB                      */
    dszPSUBW,    O_MmReg_qModrm,        /* F9 PSUBW                      */
    dszPSUBD,    O_MmReg_qModrm,        /* FA PSUBD                      */
    dszRESERVED, O_DoDB,                /* FB                            */
    dszPADDB,    O_MmReg_qModrm,        /* FC PADDB                      */
    dszPADDW,    O_MmReg_qModrm,        /* FD PADDW                      */
    dszPADDD,    O_MmReg_qModrm,        /* FE PADDD                      */
};

/* Auxilary lists of mnemonics for groups of two byte instructions:      */
/*   All of the instructions within each of these groups are of the same */
/*   class, so only the mnemonic string is needed, the index into the    */
/*   action table is implicit.                                           */

static char *group[][8] = {

/* 00 */    {dszADD,  dszOR,    dszADC,  dszSBB,    /* group 1 */
             dszAND,  dszSUB,   dszXOR,  dszCMP},

/* 01 */    {dszROL,  dszROR,   dszRCL,      dszRCR,    /* group 2 */
             dszSHL,  dszSHR,   dszRESERVED, dszSAR},

/* 02 */    {dszINC,      dszDEC,      dszRESERVED, dszRESERVED, /* group 4 */
             dszRESERVED, dszRESERVED, dszRESERVED, dszRESERVED},

/* 03 */    {dszSLDT, dszSTR,   dszLLDT,     dszLTR,    /* group 6 */
             dszVERR, dszVERW,  dszRESERVED, dszRESERVED},

/* 04 */    {dszRESERVED, dszRESERVED, dszRESERVED, dszRESERVED, /* group 8 */
             dszBT,       dszBTS,      dszBTR,      dszBTC},

/* 05 */    {dszRESERVED, dszRESERVED, dszPSRLW,    dszRESERVED, /* PSHimw */
             dszPSRAW,    dszRESERVED, dszPSLLW,    dszRESERVED},
            
/* 06 */    {dszRESERVED, dszRESERVED, dszPSRLD,    dszRESERVED, /* PSHimd */
             dszPSRAD,    dszRESERVED, dszPSLLD,    dszRESERVED},
            
/* 07 */    {dszRESERVED, dszRESERVED, dszPSRLQ,    dszRESERVED, /* PSHimq */
             dszRESERVED, dszRESERVED, dszPSLLQ,    dszRESERVED},
            
            };

/* Auxilary orderd pairs for groups of two byte instructions structured  */
/*   the same was as distbl above.                                       */

static Tdistbl groupt[][8] = {

/* 00  00                     x87-D8-1                   */
            { dszFADD,     O_dModrm,     /* D8-0 FADD    */
              dszFMUL,     O_dModrm,     /* D8-1 FMUL    */
              dszFCOM,     O_dModrm,     /* D8-2 FCOM    */
              dszFCOMP,    O_dModrm,     /* D8-3 FCOMP   */
              dszFSUB,     O_dModrm,     /* D8-4 FSUB    */
              dszFSUBR,    O_dModrm,     /* D8-5 FSUBR   */
              dszFDIV,     O_dModrm,     /* D8-6 FDIV    */
              dszFDIVR,    O_dModrm },   /* D8-7 FDIVR   */

/* 01                         x87-D8-2                   */
            { dszFADD,     O_ST_iST,     /* D8-0 FADD    */
              dszFMUL,     O_ST_iST,     /* D8-1 FMUL    */
              dszFCOM,     O_iST,        /* D8-2 FCOM    */
              dszFCOMP,    O_iST,        /* D8-3 FCOMP   */
              dszFSUB,     O_ST_iST,     /* D8-4 FSUB    */
              dszFSUBR,    O_ST_iST,     /* D8-5 FSUBR   */
              dszFDIV,     O_ST_iST,     /* D8-6 FDIV    */
              dszFDIVR,    O_ST_iST },   /* D8-7 FDIVR   */

/* 02   01                    x87-D9-1                   */
            { dszFLD,      O_dModrm,     /* D9-0 FLD     */
              dszRESERVED, O_DoDB,       /* D9-1         */
              dszFST,      O_dModrm,     /* D9-2 FST     */
              dszFSTP,     O_dModrm,     /* D9-3 FSTP    */
              dszFLDENV,   O_Modrm,      /* D9-4 FLDENV  */
              dszFLDCW,    O_Modrm,      /* D9-5 FLDCW   */
              dszFSTENV,   O_Modrm,      /* D9-6 FSTENV  */
              dszFSTCW,    O_Modrm },    /* D9-7 FSTCW   */

/* 03   01                    x87-D9-2 TTT=0,1,2,3       */
            { dszFLD,      O_iST,        /* D9-0 FLD     */
              dszFXCH,     O_iST,        /* D9-1 FXCH    */
              dszFNOP,     O_NoOperands, /* D9-2 FNOP    */
              dszFSTP,     O_iST,        /* D9-3 FSTP    */
              dszRESERVED, O_DoDB,       /* D9-4         */
              dszRESERVED, O_DoDB,       /* D9-5         */
              dszRESERVED, O_DoDB,       /* D9-6         */
              dszRESERVED, O_DoDB   },   /* D9-7         */

/* 04  02                     x89-DA-1                   */
            { dszFIADD,    O_dModrm,     /* DA-0 FIADD   */
              dszFIMUL,    O_dModrm,     /* DA-1 FIMUL   */
              dszFICOM,    O_dModrm,     /* DA-2 FICOM   */
              dszFICOMP,   O_dModrm,     /* DA-3 FICOMP  */
              dszFISUB,    O_dModrm,     /* DA-4 FISUB   */
              dszFISUBR,   O_dModrm,     /* DA-5 FISUBR  */
              dszFIDIV,    O_dModrm,     /* DA-6 FIDIV   */
              dszFIDIVR,   O_dModrm },   /* DA-7 FIDIVR  */

/* 05                         x87-DA-2                   */
            { dszFCMOVB,   O_ST_iST,     /* DA-0 FCMOVB  */
              dszFCMOVE,   O_ST_iST,     /* DA-1 FCMOVE  */
              dszFCMOVBE,  O_ST_iST,     /* DA-2 FCMOVBE */
              dszFCMOVU,   O_ST_iST,     /* DA-3 FCMOVU  */
              dszRESERVED, O_DoDB,       /* DA-4         */
              dszFUCOMPP,  O_NoOperands, /* DA-5         */
              dszRESERVED, O_DoDB,       /* DA-6         */
              dszRESERVED, O_DoDB },     /* DA-7         */

/* 06  03                     x87-DB-1                   */
            { dszFILD,     O_dModrm,     /* DB-0 FILD    */
              dszRESERVED, O_DoDB,       /* DB-1         */
              dszFIST,     O_dModrm,     /* DB-2 FIST    */
              dszFISTP,    O_dModrm,     /* DB-3 FISTP   */
              dszRESERVED, O_DoDB,       /* DB-4         */
              dszFLD,      O_tModrm,     /* DB-5 FLD     */
              dszRESERVED, O_DoDB,       /* DB-6         */
              dszFSTP,     O_tModrm },   /* DB-7 FSTP    */

/* 07                      x87-DB-2 ttt=4        */
            { dszFENI,     O_NoOperands, /* DB-0 FENI    */
              dszFDISI,    O_NoOperands, /* DB-1 FDISI   */
              dszFCLEX,    O_NoOperands, /* DB-2 FCLEX   */
              dszFINIT,    O_NoOperands, /* DB-3 FINIT   */
              dszFSETPM,   O_DoDB,       /* DB-4 FSETPM  */
              dszRESERVED, O_DoDB,       /* DB-5         */
              dszRESERVED, O_DoDB,       /* DB-6         */
              dszRESERVED, O_DoDB },     /* DB-7         */

/* 08 04                      x87-DC-1                   */
            { dszFADD,     O_qModrm,     /* DC-0 FADD    */
              dszFMUL,     O_qModrm,     /* DC-1 FMUL    */
              dszFCOM,     O_qModrm,     /* DC-2 FCOM    */
              dszFCOMP,    O_qModrm,     /* DC-3 FCOMP   */
              dszFSUB,     O_qModrm,     /* DC-4 FSUB    */
              dszFSUBR,    O_qModrm,     /* DC-5 FSUBR   */
              dszFDIV,     O_qModrm,     /* DC-6 FDIV    */
              dszFDIVR,    O_qModrm },   /* DC-7 FDIVR   */

/* 09                         x87-DC-2                   */
            { dszFADD,     O_iST_ST,     /* DC-0 FADD    */
              dszFMUL,     O_iST_ST,     /* DC-1 FMUL    */
              dszFCOM,     O_iST,        /* DC-2 FCOM    */
              dszFCOMP,    O_iST,        /* DC-3 FCOMP   */
              dszFSUB,     O_iST_ST,     /* DC-4 FSUB    */
              dszFSUBR,    O_iST_ST,     /* DC-5 FSUBR   */
              dszFDIV,     O_iST_ST,     /* DC-6 FDIVR   */
              dszFDIVR,    O_iST_ST },   /* DC-7 FDIV    */

/* 10  05                     x87-DD-1                   */
            { dszFLD,      O_qModrm,     /* DD-0 FLD     */
              dszRESERVED, O_DoDB,       /* DD-1         */
              dszFST,      O_qModrm,     /* DD-2 FST     */
              dszFSTP,     O_qModrm,     /* DD-3 FSTP    */
              dszFRSTOR,   O_Modrm,      /* DD-4 FRSTOR  */
              dszRESERVED, O_DoDB,       /* DD-5         */
              dszFSAVE,    O_Modrm,      /* DD-6 FSAVE   */
              dszFSTSW,    O_Modrm },    /* DD-7 FSTSW   */

/* 11                         x87-DD-2                   */
            { dszFFREE,    O_iST,        /* DD-0 FFREE   */
              dszFXCH,     O_iST,        /* DD-1 FXCH    */
              dszFST,      O_iST,        /* DD-2 FST     */
              dszFSTP,     O_iST,        /* DD-3 FSTP    */
              dszFUCOM,    O_iST,        /* DD-4 FUCOM   */
              dszFUCOMP,   O_iST,        /* DD-5 FUCOMP  */
              dszRESERVED, O_DoDB,       /* DD-6         */
              dszRESERVED, O_DoDB },     /* DD-7         */

/* 12  06                     x87-DE-1                   */
            { dszFIADD,    O_wModrm,     /* DE-0 FIADD   */
              dszFIMUL,    O_wModrm,     /* DE-1 FIMUL   */
              dszFICOM,    O_wModrm,     /* DE-2 FICOM   */
              dszFICOMP,   O_wModrm,     /* DE-3 FICOMP  */
              dszFISUB,    O_wModrm,     /* DE-4 FISUB   */
              dszFISUBR,   O_wModrm,     /* DE-5 FISUBR  */
              dszFIDIV,    O_wModrm,     /* DE-6 FIDIV   */
              dszFIDIVR,   O_wModrm },   /* DE-7 FIDIVR  */

/* 13                         x87-DE-2                   */
            { dszFADDP,    O_iST_ST,     /* DE-0 FADDP   */
              dszFMULP,    O_iST_ST,     /* DE-1 FMULP   */
              dszFCOMP,    O_iST,        /* DE-2 FCOMP   */
              dszFCOMPP,   O_NoOperands, /* DE-3 FCOMPP  */
              dszFSUBP,    O_iST_ST,     /* DE-4 FSUBP   */
              dszFSUBRP,   O_iST_ST,     /* DE-5 FSUBRP  */
              dszFDIVP,    O_iST_ST,     /* DE-6 FDIVP   */
              dszFDIVRP,   O_iST_ST },   /* DE-7 FDIVRP  */

/* 14  07                     x87-DF-1                   */
            { dszFILD,     O_wModrm,     /* DF-0 FILD    */
              dszRESERVED, O_DoDB,       /* DF-1         */
              dszFIST,     O_wModrm,     /* DF-2 FIST    */
              dszFISTP,    O_wModrm,     /* DF-3 FISTP   */
              dszFBLD,     O_tModrm,     /* DF-4 FBLD    */
              dszFILD,     O_qModrm,     /* DF-5 FILD    */
              dszFBSTP,    O_tModrm,     /* DF-6 FBSTP   */
              dszFISTP,    O_qModrm },   /* DF-7 FISTP   */

/* 15                         x87-DF-2                   */
            { dszFFREE,    O_iST,        /* DF-0 FFREE   */
              dszFXCH,     O_iST,        /* DF-1 FXCH    */
              dszFST,      O_iST,        /* DF-2 FST     */
              dszFSTP,     O_iST,        /* DF-3 FSTP    */
              dszFSTSW,    O_NoOperands, /* DF-4 FSTSW   */
              dszFUCOMIP,  O_ST_iST,     /* DF-5 FUCOMIP */
              dszFCOMIP,   O_ST_iST,     /* DF-6 FCOMIP  */
              dszRESERVED, O_DoDB },     /* DF-7         */

/* 16   01            x87-D9 Mod=3 TTT=4                 */
            { dszFCHS,     O_NoOperands, /* D9-0 FCHS    */
              dszFABS,     O_NoOperands,  /* D9-1 FABS   */
              dszRESERVED, O_DoDB,       /* D9-2         */
              dszRESERVED, O_DoDB,       /* D9-3         */
              dszFTST,     O_NoOperands, /* D9-4 FTST    */
              dszFXAM,     O_NoOperands, /* D9-5 FXAM    */
              dszRESERVED, O_DoDB,       /* D9-6         */
              dszRESERVED, O_DoDB },     /* D9-7         */

/* 17   01            x87-D9 Mod=3 TTT=5                 */
            { dszFLD1,     O_NoOperands, /* D9-0 FLD1    */
              dszFLDL2T,   O_NoOperands, /* D9-1 FLDL2T  */
              dszFLDL2E,   O_NoOperands, /* D9-2 FLDL2E  */
              dszFLDPI,    O_NoOperands, /* D9-3 FLDPI   */
              dszFLDLG2,   O_NoOperands, /* D9-4 FLDLG2  */
              dszFLDLN2,   O_NoOperands, /* D9-5 FLDLN2  */
              dszFLDZ,     O_NoOperands, /* D9-6 FLDZ    */
              dszRESERVED, O_DoDB },     /* D9-7         */

/* 18   01            x87-D9 Mod=3 TTT=6                   */
            { dszF2XM1,    O_NoOperands,   /* D9-0 F2XM1   */
              dszFYL2X,    O_NoOperands,   /* D9-1 FYL2X   */
              dszFPTAN,    O_NoOperands,   /* D9-2 FPTAN   */
              dszFPATAN,   O_NoOperands,   /* D9-3 FPATAN  */
              dszFXTRACT,  O_NoOperands,   /* D9-4 FXTRACT */
              dszFPREM1,   O_NoOperands,   /* D9-5 FPREM1  */
              dszFDECSTP,  O_NoOperands,   /* D9-6 FDECSTP */
              dszFINCSTP,  O_NoOperands }, /* D9-7 FINCSTP */

/* 19   01            x87-D9 Mod=3 TTT=7                   */
            { dszFPREM,    O_NoOperands,   /* D9-0 FPREM   */
              dszFYL2XP1,  O_NoOperands,   /* D9-1 FYL2XP1 */
              dszFSQRT,    O_NoOperands,   /* D9-2 FSQRT   */
              dszFSINCOS,  O_NoOperands,   /* D9-3 FSINCOS */
              dszFRNDINT,  O_NoOperands,   /* D9-4 FRNDINT */
              dszFSCALE,   O_NoOperands,   /* D9-5 FSCALE  */
              dszFSIN,     O_NoOperands,   /* D9-6 FSIN    */
              dszFCOS,     O_NoOperands }, /* D9-7 FCOS    */

/* 20                  group 3                             */
            { dszTEST,     O_bModrm_Ib,    /* F6-0 TEST    */
              dszRESERVED, O_DoDB,         /* F6-1         */
              dszNOT,      O_bModrm,       /* F6-2 NOT     */
              dszNEG,      O_bModrm,       /* F6-3 NEG     */
              dszMUL,      O_bModrm,       /* F6-4 MUL     */
              dszIMUL,     O_bModrm,       /* F6-5 IMUL    */
              dszDIV,      O_bModrm,       /* F6-6 DIV     */
              dszIDIV,     O_bModrm },     /* F6-7 IDIV    */

/* 21                  group 3                             */
            { dszTEST,     O_vModrm_Iv,    /* F7-0 TEST    */
              dszRESERVED, O_DoDB,         /* F7-1         */
              dszNOT,      O_vModrm,       /* F7-2 NOT     */
              dszNEG,      O_vModrm,       /* F7-3 NEG     */
              dszMUL,      O_vModrm,       /* F7-4 MUL     */
              dszIMUL,     O_vModrm,       /* F7-5 IMUL    */
              dszDIV,      O_vModrm,       /* F7-6 DIV     */
              dszIDIV,     O_vModrm },     /* F7-7 IDIV    */

/* 22                  group 5                             */
            { dszINC,      O_vModrm,     /* FF-0 INC       */
              dszDEC,      O_vModrm,     /* FF-1 DEC       */
              dszCALL,     O_vModrm,     /* FF-2 CALL      */
              dszCALL,     O_fModrm,     /* FF-3 CALL      */
              dszJMP,      O_vModrm,     /* FF-4 JMP       */
              dszJMP,      O_fModrm,     /* FF-5 JMP       */
              dszPUSH,     O_vModrm,     /* FF-6 PUSH      */
              dszRESERVED, O_DoDB },     /* FF-7           */

/* 23                  group 7                             */
            { dszSGDT,     O_Modrm,      /* 0F-0 SGDT      */
              dszSIDT,     O_Modrm,      /* 0F-1 SIDT      */
              dszLGDT,     O_Modrm,      /* 0F-2 LGDT      */
              dszLIDT,     O_Modrm,      /* 0F-3 LIDT      */
              dszSMSW,     O_wModrm,     /* 0F-4 MSW       */
              dszRESERVED, O_DoDB,       /* 0F-5           */
              dszLMSW,     O_wModrm,     /* 0F-6 LMSW      */
              dszINVLPG,   O_Modrm },    /* 0F-7 INVLPG    */

/* 24                 x87-DB Mod=3 TTT != 4                */
            { dszFCMOVNB,  O_ST_iST,     /* DB-0 FCMOVNB   */
              dszFCMOVNE,  O_ST_iST,     /* DB-1 FCMOVNE   */
              dszFCMOVNBE, O_ST_iST,     /* DB-2 FCMOVNBE  */
              dszFCMOVNU,  O_ST_iST,     /* DB-3 FCMOVNU   */
              dszRESERVED, O_DoDB,       /* DB-4           */
              dszFUCOMI,   O_ST_iST,     /* DB-5 FUCOMI    */
              dszFCOMI,    O_ST_iST,     /* DB-6 FCOMI     */
              dszRESERVED, O_DoDB }      /* DB-7           */

            };

typedef struct _ADDR {
    USHORT      type;
    USHORT      seg;
    ULONG       off;
    union {
        ULONG flat;
        ULONGLONG flat64;
    };
} ADDR, *PADDR;

#endif //_86DIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimengines\shimengv\86dis.c ===
/*    @ Author: Gerd Immeyer              @ Version:                       */
/*                                                                         */
/*    @ Creation Date: 10.19.89           @ Modification Date:             */
/*                                                                         */
/***************************************************************************/

//
// Munged for my purposes on 10/20/99 (v-johnwh)
//
#include <string.h>

typedef unsigned long       DWORD;
typedef unsigned long ULONG;
typedef unsigned short USHORT;
typedef unsigned __int64 ULONGLONG;
typedef int                 BOOL;
typedef ULONG *PULONG;
typedef void * PVOID;
#define ADDR_V86        ((USHORT)0x0002)
#define ADDR_16         ((USHORT)0x0004)
#define FALSE               0
#define TRUE                1
#define BIT20(b) (b & 0x07)
#define BIT53(b) (b >> 3 & 0x07)
#define BIT76(b) (b >> 6 & 0x03)
#define MAXL     16
#define MAXOPLEN 10
#define REGDS           3
#define REGSS           15
#define REGEBX          6
#define REGEBP          10
#define REGEDI          4
#define REGESI          5
#define REGEAX          9
#define REGECX          8
#define REGEDX          7
#define REGESP          14
#define Off(x)          ((x).off)
#define Type(x)         ((x).type)

#define OBOFFSET 26
#define OBOPERAND 34
#define OBLINEEND 77
#define MAX_SYMNAME_SIZE  1024

#include "86dis.h"

ULONG      X86BrkptLength = 1L;
ULONG      X86TrapInstr = 0xcc;

/*****                     static tables and variables                 *****/
static char regtab[] = "alcldlblahchdhbhaxcxdxbxspbpsidi";  /* reg table */
static char *mrmtb16[] = { "bx+si",  /* modRM string table (16-bit) */
                           "bx+di",
                           "bp+si",
                           "bp+di",
                           "si",
                           "di",
                           "bp",
                           "bx"
                         };

static char *mrmtb32[] = { "eax",       /* modRM string table (32-bit) */
                           "ecx",
                           "edx",
                           "ebx",
                           "esp",
                           "ebp",
                           "esi",
                           "edi"
                         };

static char seg16[8]   = { REGDS,  REGDS,  REGSS,  REGSS,
                           REGDS,  REGDS,  REGSS,  REGDS };
static char reg16[8]   = { REGEBX, REGEBX, REGEBP, REGEBP,
                           REGESI, REGEDI, REGEBP, REGEBX };
static char reg16_2[4] = { REGESI, REGEDI, REGESI, REGEDI };

static char seg32[8]   = { REGDS,  REGDS,  REGDS,  REGDS,
                           REGSS,  REGSS,  REGDS,  REGDS };
static char reg32[8]   = { REGEAX, REGECX, REGEDX, REGEBX,
                           REGESP, REGEBP, REGESI, REGEDI };

static char sregtab[] = "ecsdfg";  // first letter of ES, CS, SS, DS, FS, GS

char    hexdigit[] = { '0', '1', '2', '3', '4', '5', '6', '7',
                       '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

typedef struct _DECODEDATA
{
  int              mod;            /* mod of mod/rm byte */
  int              rm;             /* rm of mod/rm byte */
  int              ttt;            /* return reg value (of mod/rm) */
  unsigned char    *pMem;          /* current position in instruction */
  ADDR             EAaddr[2];      //  offset of effective address
  int              EAsize[2];      //  size of effective address item
  char             *pchEAseg[2];   //  normal segment for operand
  BOOL             fMovX;          // indicates a MOVSX or MOVZX
  BOOL             fMmRegEa;       // Use mm? registers in reg-only EA.
} DECODEDATA;
/*...........................internal function..............................*/
/*                                                                          */
/*                       generate a mod/rm string                           */
/*                                                                          */

void DIdoModrm (char **ppchBuf, int segOvr, DECODEDATA *decodeData)
{
    int     mrm;                        /* modrm byte */
    char    *src;                       /* source string */
    int     sib;
    int     ss;
    int     ind;
    int     oldrm;

    mrm = *(decodeData->pMem)++;                      /* get the mrm byte from instruction */
    decodeData->mod = BIT76(mrm);                   /* get mod */
    decodeData->ttt = BIT53(mrm);                   /* get reg - used outside routine */
    decodeData->rm  = BIT20(mrm);                   /* get rm */

    if (decodeData->mod == 3) {                     /* register only mode */
        if (decodeData->fMmRegEa) {
            *(*ppchBuf)++ = 'm';
            *(*ppchBuf)++ = 'm';
            *(*ppchBuf)++ = decodeData->rm + '0';
        } else {
            src = &regtab[decodeData->rm * 2];          /* point to 16-bit register */
            if (decodeData->EAsize[0] > 1) {
                src += 16;                  /* point to 16-bit register */
                if (!(decodeData->fMovX))
                    *(*ppchBuf)++ = 'e';    /* make it a 32-bit register */
            }
            *(*ppchBuf)++ = *src++;         /* copy register name */
            *(*ppchBuf)++ = *src;
        }
        decodeData->EAsize[0] = 0;                  //  no EA value to output
        return;
        }

    if (1) {                       /* 32-bit addressing mode */
        oldrm = decodeData->rm;
        if (decodeData->rm == 4) {                  /* rm == 4 implies sib byte */
            sib = *(decodeData->pMem)++;              /* get s_i_b byte */
            decodeData->rm = BIT20(sib);            /* return base */
            }

        *(*ppchBuf)++ = '[';
        if (decodeData->mod == 0 && decodeData->rm == 5) {
            decodeData->pMem += 4;
            }

        if (oldrm == 4) {               //  finish processing sib
            ind = BIT53(sib);
            if (ind != 4) {
                *(*ppchBuf)++ = '+';
                ss = 1 << BIT76(sib);
                if (ss != 1) {
                    *(*ppchBuf)++ = '*';
                    *(*ppchBuf)++ = (char)(ss + '0');
                    }
            }
        }
	}

    //  output any displacement

    if (decodeData->mod == 1) {
        decodeData->pMem++;
        }
    else if (decodeData->mod == 2) {
        long tmp = 0;
        if (1) {
            decodeData->pMem += 4;
            }
        else {
            decodeData->pMem += 2;
            }
        }
}

DWORD GetInstructionLengthFromAddress(PVOID paddr)
{
    PULONG  pOffset = 0;
    int     G_mode_32;
    int     mode_32;                    /* local addressing mode indicator */
    int     opsize_32;                  /* operand size flag */
    int     opcode;                     /* current opcode */
    int     olen = 2;                   /* operand length */
    int     alen = 2;                   /* address length */
    int     end = FALSE;                /* end of instruction flag */
    int     mrm = FALSE;                /* indicator that modrm is generated*/
    unsigned char *action;              /* action for operand interpretation*/
    long    tmp;                        /* temporary storage field */
    int     indx;                       /* temporary index */
    int     action2;                    /* secondary action */
    int     instlen;                    /* instruction length */
    int     segOvr = 0;                 /* segment override opcode */
    unsigned char *membuf;              /* current instruction buffer */
    char    *pEAlabel = "";             /* optional label for operand */
    char    RepPrefixBuffer[32];        /* rep prefix buffer */
    char    *pchRepPrefixBuf = RepPrefixBuffer; /* pointer to prefix buffer */
    char    OpcodeBuffer[8];            /* opcode buffer */
    char    *pchOpcodeBuf = OpcodeBuffer; /*  pointer to opcode buffer */
    char    OperandBuffer[MAX_SYMNAME_SIZE + 20]; /*  operand buffer */
    char    *pchOperandBuf = OperandBuffer; /* pointer to operand buffer */
    char    ModrmBuffer[MAX_SYMNAME_SIZE + 20];   /* modRM buffer */
    char    *pchModrmBuf = ModrmBuffer; /* pointer to modRM buffer */
    char    EABuffer[42];               /* effective address buffer */
    char    *pchEABuf = EABuffer;       /* pointer to EA buffer */

    unsigned char BOPaction;
    int     subcode;                    /* bop subcode */
    DECODEDATA decodeData;

    decodeData.fMovX = FALSE;
    decodeData.fMmRegEa = FALSE;
    decodeData.EAsize[0] = decodeData.EAsize[1] = 0;          //  no effective address
    decodeData.pchEAseg[0] = dszDS_;
    decodeData.pchEAseg[1] = dszES_;

    G_mode_32 = 1;

    mode_32 = opsize_32 = (G_mode_32 == 1); /* local addressing mode */
    olen = alen = (1 + mode_32) << 1;   //  set operand/address lengths
                                        //  2 for 16-bit and 4 for 32-bit
#if MULTIMODE
    if (paddr->type & (ADDR_V86 | ADDR_16)) {
        mode_32 = opsize_32 = 0;
        olen = alen = 2;
        }
#endif

    membuf = (unsigned char *)paddr;
                                
    decodeData.pMem = membuf;                      /* point to begin of instruction */
    opcode = *(decodeData.pMem)++;                   /* get opcode */

    if ( opcode == 0xc4 && *(decodeData.pMem) == 0xC4 ) {
        (decodeData.pMem)++;
        action = &BOPaction;
        BOPaction = IB | END;
        subcode =  *(decodeData.pMem);
        if ( subcode == 0x50 || subcode == 0x52 || subcode == 0x53 || subcode == 0x54 || subcode == 0x57 || subcode == 0x58 || subcode == 0x58 ) {
            BOPaction = IW | END;
        }
    } else {
        action = actiontbl + distbl[opcode].opr; /* get operand action */
    }

/*****          loop through all operand actions               *****/

    do {
        action2 = (*action) & 0xc0;
        switch((*action++) & 0x3f) {
            case ALT:                   /* alter the opcode if 32-bit */
                if (opsize_32) {
                    indx = *action++;
                    pchOpcodeBuf = &OpcodeBuffer[indx];
                    if (indx == 0)
                       ;
                    else {
                        *pchOpcodeBuf++ = 'd';
                        if (indx == 1)
                            *pchOpcodeBuf++ = 'q';
                        }
                    }
                break;

            case STROP:
                //  compute size of operands in indx
                //  also if dword operands, change fifth
                //  opcode letter from 'w' to 'd'.

                if (opcode & 1) {
                    if (opsize_32) {
                        indx = 4;
                        OpcodeBuffer[4] = 'd';
                        }
                    else
                        indx = 2;
                    }
                else
                    indx = 1;

                if (*action & 1) {
                    }
                if (*action++ & 2) {
                    }
                break;

            case CHR:                   /* insert a character */
                *pchOperandBuf++ = *action++;
                break;

            case CREG:                  /* set debug, test or control reg */
                if ((opcode - SECTAB_OFFSET_2)&0x04) //remove bias from opcode
                    *pchOperandBuf++ = 't';
                else if ((opcode - SECTAB_OFFSET_2) & 0x01)
                    *pchOperandBuf++ = 'd';
                else
                    *pchOperandBuf++ = 'c';
                *pchOperandBuf++ = 'r';
                *pchOperandBuf++ = (char)('0' + decodeData.ttt);
                break;

            case SREG2:                 /* segment register */
                // Handle special case for fs/gs (OPC0F adds SECTAB_OFFSET_5
                // to these codes)
                if (opcode > 0x7e)
                    decodeData.ttt = BIT53((opcode-SECTAB_OFFSET_5));
                else
                decodeData.ttt = BIT53(opcode);    //  set value to fall through

            case SREG3:                 /* segment register */
                *pchOperandBuf++ = sregtab[decodeData.ttt];  // reg is part of modrm
                *pchOperandBuf++ = 's';
                break;

            case BRSTR:                 /* get index to register string */
                decodeData.ttt = *action++;        /*    from action table */
                goto BREGlabel;

            case BOREG:                 /* byte register (in opcode) */
                decodeData.ttt = BIT20(opcode);    /* register is part of opcode */
                goto BREGlabel;

            case ALSTR:
                decodeData.ttt = 0;                /* point to AL register */
BREGlabel:
            case BREG:                  /* general register */
                *pchOperandBuf++ = regtab[decodeData.ttt * 2];
                *pchOperandBuf++ = regtab[decodeData.ttt * 2 + 1];
                break;

            case WRSTR:                 /* get index to register string */
                decodeData.ttt = *action++;        /*    from action table */
                goto WREGlabel;

            case VOREG:                 /* register is part of opcode */
                decodeData.ttt = BIT20(opcode);
                goto VREGlabel;

            case AXSTR:
                decodeData.ttt = 0;                /* point to eAX register */
VREGlabel:
            case VREG:                  /* general register */
                if (opsize_32)          /* test for 32bit mode */
                    *pchOperandBuf++ = 'e';
WREGlabel:
            case WREG:                  /* register is word size */
                *pchOperandBuf++ = regtab[decodeData.ttt * 2 + 16];
                *pchOperandBuf++ = regtab[decodeData.ttt * 2 + 17];
                break;

            case MMWREG:
                *pchOperandBuf++ = 'm';
                *pchOperandBuf++ = 'm';
                *pchOperandBuf++ = decodeData.ttt + '0';
                break;

            case IST_ST:
                *(pchOperandBuf - 5) += (char)decodeData.rm;
                break;

            case ST_IST:
                ;
            case IST:
                ;
                *(pchOperandBuf - 2) += (char)decodeData.rm;
                break;

            case xBYTE:                 /* set instruction to byte only */
                decodeData.EAsize[0] = 1;
                break;

            case VAR:
                if (opsize_32)
                    goto DWORDlabel;

            case xWORD:
                decodeData.EAsize[0] = 2;
                break;

            case EDWORD:
                opsize_32 = 1;    //  for control reg move, use eRegs
            case xDWORD:
DWORDlabel:
                decodeData.EAsize[0] = 4;
                break;

            case MMQWORD:
                decodeData.fMmRegEa = TRUE;

            case QWORD:
                decodeData.EAsize[0] = 8;
                break;

            case TBYTE:
                decodeData.EAsize[0] = 10;
                break;

            case FARPTR:
                if (opsize_32) {
                    decodeData.EAsize[0] = 6;
                    }
                else {
                    decodeData.EAsize[0] = 4;
                    }
                break;

            case LMODRM:                //  output modRM data type
                if (decodeData.mod != 3)
                    ;
                else
                    decodeData.EAsize[0] = 0;

            case MODRM:                 /* output modrm string */
                if (segOvr)             /* in case of segment override */
                    0;
                break;

            case ADDRP:                 /* address pointer */
                decodeData.pMem += olen + 2;
                break;

            case REL8:                  /* relative address 8-bit */
                if (opcode == 0xe3 && mode_32) {
                    pchOpcodeBuf = OpcodeBuffer;
                    }
                tmp = (long)*(char *)(decodeData.pMem)++; /* get the 8-bit rel offset */
                goto DoRelDispl;

            case REL16:                 /* relative address 16-/32-bit */
                tmp = 0;
                if (mode_32)
                    memmove(&tmp,decodeData.pMem,sizeof(long));
                else
                    memmove(&tmp,decodeData.pMem,sizeof(short));
                decodeData.pMem += alen;           /* skip over offset */
DoRelDispl:
//                tmp += *pOffset + (decodeData.pMem - membuf); /* calculate address */
                                                   // address
                break;

            case UBYTE:                 //  unsigned byte for int/in/out
                decodeData.pMem++;
                break;

            case IB:                    /* operand is immediate byte */
                if ((opcode & ~1) == 0xd4) {  // postop for AAD/AAM is 0x0a
                    if (*(decodeData.pMem)++ != 0x0a) // test post-opcode byte
                        0;
                    break;
                    }
                olen = 1;               /* set operand length */
                goto DoImmed;

            case IW:                    /* operand is immediate word */
                olen = 2;               /* set operand length */

            case IV:                    /* operand is word or dword */
DoImmed:
                decodeData.pMem += olen;
                break;

            case OFFS:                  /* operand is offset */
                decodeData.EAsize[0] = (opcode & 1) ? olen : 1;

                if (segOvr)             /* in case of segment override */
                   0;

                decodeData.pMem += alen;
                break;

            case GROUP:                 /* operand is of group 1,2,4,6 or 8 */
                                        /* output opcode symbol */
				action++;
                break;

            case GROUPT:                /* operand is of group 3,5 or 7 */
                indx = *action;         /* get indx into group from action */
                goto doGroupT;

            case EGROUPT:               /* x87 ESC (D8-DF) group index */
                indx = BIT20(opcode) * 2; /* get group index from opcode */
                if (decodeData.mod == 3) {         /* some operand variations exists */
                                        /* for x87 and mod == 3 */
                    ++indx;             /* take the next group table entry */
                    if (indx == 3) {    /* for x87 ESC==D9 and mod==3 */
                        if (decodeData.ttt > 3) {  /* for those D9 instructions */
                            indx = 12 + decodeData.ttt; /* offset index to table by 12 */
                            decodeData.ttt = decodeData.rm;   /* set secondary index to rm */
                            }
                        }
                    else if (indx == 7) { /* for x87 ESC==DB and mod==3 */
                        if (decodeData.ttt == 4) {   /* if ttt==4 */
                            decodeData.ttt = decodeData.rm;     /* set secondary group table index */
                        } else if ((decodeData.ttt<4)||(decodeData.ttt>4 && decodeData.ttt<7)) {
                            // adjust for pentium pro opcodes
                            indx = 24;   /* offset index to table by 24*/
                        }
                    }
                }
doGroupT:
                /* handle group with different types of operands */
                action = actiontbl + groupt[indx][decodeData.ttt].opr;
                                                        /* get new action */
                break;
            //
            // The secondary opcode table has been compressed in the
            // original design. Hence while disassembling the 0F sequence,
            // opcode needs to be displaced by an appropriate amount depending
            // on the number of "filled" entries in the secondary table.
            // These displacements are used throughout the code.
            //

            case OPC0F:              /* secondary opcode table (opcode 0F) */
                opcode = *(decodeData.pMem)++;    /* get real opcode */
                decodeData.fMovX  = (BOOL)(opcode == 0xBF || opcode == 0xB7);
                if (opcode < 12) /* for the first 12 opcodes */
                    opcode += SECTAB_OFFSET_1; // point to begin of sec op tab
                else if (opcode > 0x1f && opcode < 0x27)
                    opcode += SECTAB_OFFSET_2; // adjust for undefined opcodes
                else if (opcode > 0x2f && opcode < 0x34)
                    opcode += SECTAB_OFFSET_3; // adjust for undefined opcodes
                else if (opcode > 0x3f && opcode < 0x50)
                    opcode += SECTAB_OFFSET_4; // adjust for undefined opcodes
                else if (opcode > 0x5f && opcode < 0xff)
                    opcode += SECTAB_OFFSET_5; // adjust for undefined opcodes
                else
                    opcode = SECTAB_OFFSET_UNDEF; // all non-existing opcodes
                goto getNxtByte1;

            case ADR_OVR:               /* address override */
                mode_32 = !G_mode_32;   /* override addressing mode */
                alen = (mode_32 + 1) << 1; /* toggle address length */
                goto getNxtByte;

            case OPR_OVR:               /* operand size override */
                opsize_32 = !G_mode_32; /* override operand size */
                olen = (opsize_32 + 1) << 1; /* toggle operand length */
                goto getNxtByte;

            case SEG_OVR:               /* handle segment override */
                segOvr = opcode;        /* save segment override opcode */
                pchOpcodeBuf = OpcodeBuffer;  // restart the opcode string
                goto getNxtByte;

            case REP:                   /* handle rep/lock prefixes */
                if (pchRepPrefixBuf != RepPrefixBuffer)
                    *pchRepPrefixBuf++ = ' ';
                pchOpcodeBuf = OpcodeBuffer;
getNxtByte:
                opcode = *(decodeData.pMem)++;        /* next byte is opcode */
getNxtByte1:
                action = actiontbl + distbl[opcode].opr;

            default:                    /* opcode has no operand */
                break;
            }
        switch (action2) {              /* secondary action */
            case MRM:                   /* generate modrm for later use */
                if (!mrm) {             /* ignore if it has been generated */
					DIdoModrm(&pchModrmBuf, segOvr, &decodeData);
                    mrm = TRUE;         /* remember its generation */
                    }
                break;

            case COM:                   /* insert a comma after operand */
                break;

            case END:                   /* end of instruction */
                end = TRUE;
                break;
            }
 } while (!end);                        /* loop til end of instruction */

  instlen = (decodeData.pMem) - membuf;

  return instlen;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimengines\shimengv\shimengv.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993-1998
//
// File:        ldrapeng.h
//
// Contents:    App compat backend code
//
// History:     13-Oct-99   v-johnwh        created
//
//---------------------------------------------------------------------------

#ifndef _SHIMENG_VEH_H_
#define _SHIMENG_VEH_H_


typedef struct _SETACTIVATEADDRESS {

   RELATIVE_MODULE_ADDRESS rva;             // relative address where this patch data is to be applied.

} SETACTIVATEADDRESS, *PSETACTIVATEADDRESS;

typedef struct _HOOKPATCHINFO {

   DWORD                  dwHookAddress;    // Address of a hooked function
   PSETACTIVATEADDRESS    pData;            // Pointer to the real patch data
   PVOID                  pThunkAddress;    // Pointer to the call thunk
   struct _HOOKPATCHINFO* pNextHook;

} HOOKPATCHINFO, *PHOOKPATCHINFO;


//
// Flags used in the shim HOOKAPIs to track chaining
//
#define HOOK_CHAIN_TOP 0x40000000
#define HOOK_CHAINED 0x80000000
#define HOOK_INDEX_MASK ~(HOOK_CHAINED | HOOK_CHAIN_TOP)

//
// x86 opcodes and sizes used in the thunk generation process
//
#define CLI_OR_STI_SIZE 1
#define CALL_REL_SIZE 5
#define JMP_SIZE 7
#define X86_ABSOLUTE_FAR_JUMP 0xEA
#define X86_REL_CALL_OPCODE 0xE8
#define X86_CALL_OPCODE 0xFF
#define X86_CALL_OPCODE2 0x15

#define REASON_APIHOOK 0xFA
#define REASON_PATCHHOOK 0xFB

//
// Flags used in maintaining state information about our module/DLL filtering
//
#define MODFILTER_INCLUDE 0x01
#define MODFILTER_EXCLUDE 0x02
#define MODFILTER_DLL     0x04
#define MODFILTER_GLOBAL  0x08

typedef struct _MODULEFILTER
{
   DWORD dwModuleStart;      // Starting address of the module to filter
   DWORD dwModuleEnd;        // Ending address of the module to filter
   DWORD dwCallerOffset;     // Offset added to beginning of module to form the caller's address
   DWORD dwCallerAddress;    // Caller address to operate upon
   DWORD dwFlags;            // Flags which define what this filter does
   WCHAR wszModuleName[96];
   struct _MODULEFILTER *pNextFilter;    // Used to iterate the module filter normally
   struct _MODULEFILTER *pNextLBFilter;  // Used to iterate the late bound DLLs
} MODULEFILTER, *PMODULEFILTER;

typedef struct _CHAININFO
{
   PVOID pAPI;
   PVOID pReturn;
   struct _CHAININFO *pNextChain;
} CHAININFO, *PCHAININFO;

typedef struct _HOOKAPIINFO
{
   DWORD dwAPIHookAddress;         // Address of a hooked function
   PHOOKAPI pTopLevelAPIChain;     // Top level hook address
   PVOID pCallThunkAddress;
   WCHAR wszModuleName[32];
   struct _HOOKAPIINFO *pNextHook;
   struct _HOOKAPIINFO *pPrevHook;
} HOOKAPIINFO, *PHOOKAPIINFO;

#pragma pack(push, 1)
typedef struct _SHIMJMP
{
   BYTE  PUSHAD;                //pushad   (60)
   BYTE  MOVEBPESP[2];          //mov ebp, esp (8b, ec)
   BYTE  MOVEAXDWVAL[5];        //mov eax, dwval (b8 dword val)
   BYTE  PUSHEAX;               //push eax (50)
   BYTE  LEAEAXEBPPLUS20[3];    //lea eax, [ebp + 20] (8f 45 20)
   BYTE  PUSHEAX2;              //push eax (50)
   BYTE  CALLROUTINE[6];        //call [address] (ff15 dword address)
   BYTE  MOVESPPLUS1CEAX[4];    //mov [esp+0x1c],eax (89 44 24 1c)
   BYTE  POPAD;                 //popad (61)
   BYTE  ADDESPPLUS4[3];        //add esp, 0x4 (83 c4 04)
   BYTE  JMPEAX[2];             //jmp eax (ff e0)
} SHIMJMP, *PSHIMJMP;

typedef struct _SHIMRET
{
   BYTE  PUSHEAX;               //push eax (50)
   BYTE  PUSHAD;                //pushad   (60)
   BYTE  CALLROUTINE[6];        //call [address] (ff15 dword address)
   BYTE  MOVESPPLUS20EAX[4];    //mov [esp+0x20],eax (89 44 24 20)
   BYTE  POPAD;                 //popad (61)
   BYTE  RET;                   //ret (c3)
} SHIMRET, *PSHIMRET;
#pragma pack(pop)

typedef NTSTATUS (*PFNLDRLOADDLL)(
    IN PWSTR DllPath OPTIONAL,
    IN PULONG DllCharacteristics OPTIONAL,
    IN PUNICODE_STRING DllName,
    OUT PVOID *DllHandle
    );

typedef NTSTATUS (*PFNLDRUNLOADDLL) (
    IN PVOID DllHandle
    );

typedef PVOID (*PFNRTLALLOCATEHEAP)(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

typedef BOOLEAN (*PFNRTLFREEHEAP)(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

NTSTATUS
SevInitializeData(
    PAPP_COMPAT_SHIM_INFO *pShimData);

NTSTATUS
SevExecutePatchPrimitive(
    PBYTE pPatch);

DWORD
SevGetPatchAddress(
    PRELATIVE_MODULE_ADDRESS pRelAddress);

VOID
SevValidateGlobalFilter(
    VOID);

NTSTATUS
SevFinishThunkInjection(
    DWORD dwAddress,
    PVOID pThunk,
    DWORD dwThunkSize,
    BYTE jReason);

NTSTATUS
SevBuildFilterException(
    HSDB          hSDB,
    TAGREF        trInclude,
    PMODULEFILTER pModFilter,
    BOOL*         pbLateBound);

NTSTATUS
SevBuildExeFilter(
    HSDB   hSDB,
    TAGREF trExe,
    DWORD  dwDllCount);


PVOID
SevBuildInjectionCode(
    PVOID  pAddress,
    PDWORD pdwThunkSize);

NTSTATUS
SevAddShimFilterException(
    WCHAR*        wszDLLPath,
    PMODULEFILTER pModFilter);

NTSTATUS
SevChainAPIHook(
    DWORD    dwHookEntryPoint,
    PVOID    pThunk,
    PHOOKAPI pAPIHook);

PVOID
SevFilterCaller(
    PMODULEFILTER pFilterList,
    PVOID pFunctionAddress,
    PVOID pExceptionAddress,
    PVOID pStubAddress,
    PVOID pCallThunkAddress);

NTSTATUS
SevPushCaller(
    PVOID pAPIAddress,
    PVOID pReturnAddress);

PVOID
SevPopCaller(
    VOID);

NTSTATUS
StubLdrLoadDll(
    IN PWSTR           DllPath OPTIONAL,
    IN PULONG          DllCharacteristics OPTIONAL,
    IN PUNICODE_STRING DllName,
    OUT PVOID*         DllHandle);

NTSTATUS
StubLdrUnloadDll(
    IN PVOID DllHandle);

NTSTATUS
SevFixupAvailableProcs(
    DWORD     dwHookCount,
    PHOOKAPI* pHookArray,
    PDWORD    pdwNumberHooksArray,
    PDWORD    pdwUnhookedCount);

LONG
SevExceptionHandler(
    struct _EXCEPTION_POINTERS *ExceptionInfo);

#endif // _SHIMENG_VEH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shimengines\shimengv\shimengv.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ShimEngV.c

Abstract:

    This module implements the shim hooking using vectored exception handling

Author:

    John Whited (v-johnwh) 13-Oct-1999

Revision History:

    Corneliu Lupu (clupu) 18-Jul-2000 - make it a separate shim engine

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <string.h>

#include <windef.h>
#include <winbase.h>
#include <stdio.h>
#include <apcompat.h>
#include "shimdb.h"
#include "ShimEngV.h"

//
// Global function hooks the shim uses to keep from recursing itself
//
HOOKAPI         g_InternalHookArray[2];
PFNLDRLOADDLL   g_pfnOldLdrLoadDLL;
PFNLDRLOADDLL   g_pfnLdrLoadDLL;
PFNLDRUNLOADDLL g_pfnLdrUnloadDLL;
PFNLDRUNLOADDLL g_pfnOldLdrUnloadDLL;
PFNRTLALLOCATEHEAP g_pfnRtlAllocateHeap;
PFNRTLFREEHEAP  g_pfnRtlFreeHeap;

//
// Shim doesn't share the same heap the apps use
//
PVOID g_pShimHeap;

//
// Data used for the shim call stack
//
static DWORD   dwCallArray[1];

SHIMRET fnHandleRet[1];

BOOL g_bDbgPrintEnabled;

#define DEBUG_SPEW

#ifdef DEBUG_SPEW
    #define DPF(_x_)                    \
    {                                   \
        if (g_bDbgPrintEnabled) {       \
            DbgPrint _x_ ;              \
        }                               \
    }
#else
    #define DPF
#endif // DEBUG_SPEW


DWORD
GetInstructionLengthFromAddress(
    PVOID paddr);


#ifdef DEBUG_SPEW
void
SevInitDebugSupport(
    void
    )
/*++

  Params: void

  Return: void

  Desc:   This function initializes g_bDbgPrintEnabled based on an env variable
--*/
{
    NTSTATUS            status;
    UNICODE_STRING      EnvName;
    UNICODE_STRING      EnvValue;
    WCHAR               wszEnvValue[128];

    RtlInitUnicodeString(&EnvName, L"SHIMENG_DEBUG_LEVEL");

    EnvValue.Buffer = wszEnvValue;
    EnvValue.Length = 0;
    EnvValue.MaximumLength = sizeof(wszEnvValue);

    status = RtlQueryEnvironmentVariable_U(NULL, &EnvName, &EnvValue);

    if (NT_SUCCESS(status)) {
        g_bDbgPrintEnabled = TRUE;
    }
}
#endif // DEBUG_SPEW


BOOL
SevInitFileLog(
    PUNICODE_STRING pstrAppName
    )
/*++

  Params: pstrAppName   The full path of the starting EXE

  Return: TRUE if the log was

  Desc:   This function checks an environment variable to determine if logging
          is enabled. If so, it will append a header that tells a new app is
          started.
--*/
{
    NTSTATUS            status;
    UNICODE_STRING      EnvName;
    UNICODE_STRING      EnvValue;
    UNICODE_STRING      FilePath;
    UNICODE_STRING      NtSystemRoot;
    WCHAR               wszEnvValue[128];
    WCHAR               wszLogFile[MAX_PATH];
    HANDLE              hfile;
    OBJECT_ATTRIBUTES   ObjA;
    LARGE_INTEGER       liOffset;
    RTL_RELATIVE_NAME   RelativeName;
    ULONG               uBytes;
    char                szHeader[512];
    char                szFormatHeader[] = "-------------------------------------------\r\n"
                                           " Log  \"%S\" using ShimEngV\r\n"
                                           "-------------------------------------------\r\n";
    IO_STATUS_BLOCK     ioStatusBlock;

    RtlInitUnicodeString(&EnvName, L"SHIM_FILE_LOG");

    EnvValue.Buffer = wszEnvValue;
    EnvValue.Length = 0;
    EnvValue.MaximumLength = sizeof(wszEnvValue);

    status = RtlQueryEnvironmentVariable_U(NULL, &EnvName, &EnvValue);

    if (!NT_SUCCESS(status)) {
        DPF(("[SevInitFileLog] Logging not enabled\n"));
        return FALSE;
    }

    FilePath.Buffer = wszLogFile;
    FilePath.Length = 0;
    FilePath.MaximumLength = sizeof(wszLogFile);

    RtlInitUnicodeString(&NtSystemRoot, USER_SHARED_DATA->NtSystemRoot);
    RtlAppendUnicodeStringToString(&FilePath, &NtSystemRoot);
    RtlAppendUnicodeToString(&FilePath, L"\\AppPatch\\");
    RtlAppendUnicodeStringToString(&FilePath, &EnvValue);

    if (!RtlDosPathNameToNtPathName_U(FilePath.Buffer,
                                      &FilePath,
                                      NULL,
                                      &RelativeName)) {
        DPF(("[SevInitFileLog] Failed to convert path name \"%S\"\n",
                  wszLogFile));
        return FALSE;
    }

    InitializeObjectAttributes(&ObjA,
                               &FilePath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // Open/Create the log file
    //
    status = NtCreateFile(&hfile,
                          FILE_APPEND_DATA | SYNCHRONIZE,
                          &ObjA,
                          &ioStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OPEN_IF,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    RtlFreeUnicodeString(&FilePath);

    if (!NT_SUCCESS(status)) {
        DPF(("[SevInitFileLog] 0x%X Cannot open/create log file \"%S\"\n",
                  status, wszLogFile));
        return FALSE;
    }

    //
    // Now write a new line in the log file
    //
    ioStatusBlock.Status = 0;
    ioStatusBlock.Information = 0;

    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    uBytes = (ULONG)sprintf(szHeader, szFormatHeader, pstrAppName->Buffer);

    status = NtWriteFile(hfile,
                         NULL,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         (PVOID)szHeader,
                         uBytes,
                         &liOffset,
                         NULL);

    NtClose(hfile);

    if (!NT_SUCCESS(status)) {
        DPF(("[SevInitFileLog] 0x%X Cannot write into the log file \"%S\"\n",
                  status, wszLogFile));
        return FALSE;
    }

    return TRUE;
}

void
SevSetLayerEnvVar(
    HSDB   hSDB,
    TAGREF trLayer
    )
{
    NTSTATUS            status;
    UNICODE_STRING      EnvName;
    UNICODE_STRING      EnvValue;
    WCHAR               wszEnvValue[128];
    PDB                 pdb;
    TAGID               tiLayer, tiName;
    WCHAR*              pwszName;

    RtlInitUnicodeString(&EnvName, L"__COMPAT_LAYER");

    EnvValue.Buffer = wszEnvValue;
    EnvValue.Length = 0;
    EnvValue.MaximumLength = sizeof(wszEnvValue);

    status = RtlQueryEnvironmentVariable_U(NULL, &EnvName, &EnvValue);

    if (NT_SUCCESS(status)) {
        DPF(("[SevSetLayerEnvVar] Env var set __COMPAT_LAYER=\"%S\"\n", wszEnvValue));
        return;
    }

    //
    // We need to set the environment variable
    //

    if (!SdbTagRefToTagID(hSDB, trLayer, &pdb, &tiLayer)) {
        DPF(("[SevSetLayerEnvVar] Failed to get tag id from tag ref\n"));
        return;
    }

    tiName = SdbFindFirstTag(pdb, tiLayer, TAG_NAME);

    if (tiName == TAGID_NULL) {
        DPF(("[SevSetLayerEnvVar] Failed to get the name tag id\n"));
        return;
    }

    pwszName = SdbGetStringTagPtr(pdb, tiName);

    if (pwszName == NULL) {
        DPF(("[SevSetLayerEnvVar] Cannot read the name of the layer tag\n"));
        return;
    }

    RtlInitUnicodeString(&EnvValue, pwszName);

    status = RtlSetEnvironmentVariable(NULL, &EnvName, &EnvValue);

    if (NT_SUCCESS(status)) {
        DPF(("[SevSetLayerEnvVar] Env var set __COMPAT_LAYER=\"%S\"\n", pwszName));
    } else {
        DPF(("[SevSetLayerEnvVar] Failed to set __COMPAT_LAYER. 0x%X\n", status));
    }
}

void
SE_InstallBeforeInit(
     IN PUNICODE_STRING UnicodeImageName,
     IN PVOID           pAppCompatExeData
     )
/*++

Routine Description:

    This function is called to install any api hooks, patches or flags for an exe.
    It's primary function is to initialize all the Shim data used in the hooking
    process.

Arguments:

    UnicodeImageName - This is a Unicode string which contains the name of the exe to
                       search for in the database.

Return Value:

    Success if we are able to iterate through the patch data without error.
    Otherwise we return STATUS_UNSUCCESSFUL which indicates a more serious problem
    occured.

--*/

{
    UNICODE_STRING          UnicodeString;
    ANSI_STRING             AnsiString;
    ANSI_STRING             ProcedureNameString;
    PVOID                   ModuleHandle = 0;
    PBYTE                   pAddress = 0;
    PBYTE                   pDLLBits = 0;
    PHOOKAPI                *ppHooks = 0;
    PHOOKAPI                *pHookArray = 0;
    PHOOKAPI                pTemp = 0;
    DWORD                   dwHookCount = 0;
    DWORD                   dwHookIndex = 0;
    BOOL                    bResult = FALSE;
    NTSTATUS                status;
    DWORD                   dwSize = 0;
    DWORD                   dwCounter = 0;
    PDWORD                  pdwNumberHooksArray = 0;
    PFNGETHOOKAPIS          pfnGetHookApis = 0;
    DWORD                   dwTotalHooks = 0;
    DWORD                   dwDLLCount = 0;
    DWORD                   dwFuncAddress = 0;
    DWORD                   dwUnhookedCount = 0;
    TAGREF                  trExe = TAGREF_NULL;
    TAGREF                  trLayer = TAGREF_NULL;
    TAGREF                  trDllRef = TAGREF_NULL;
    TAGREF                  trKernelFlags = TAGREF_NULL;
    TAGREF                  trPatchRef = TAGREF_NULL;
    TAGREF                  trCmdLine = TAGREF_NULL;
    TAGREF                  trName = TAGREF_NULL;
    TAGREF                  trShimName = TAGREF_NULL;
    ULARGE_INTEGER          likf;
    PAPP_COMPAT_SHIM_INFO   pShimData = 0;
    PPEB                    Peb;
    WCHAR                   wszDLLPath[MAX_PATH * 2];
    WCHAR                   wszShimName[MAX_PATH];
    WCHAR                   *pwszCmdLine = 0;
    CHAR                    *pszCmdLine = 0;
    BOOL                    bUsingExeRef = TRUE;
    HSDB                    hSDB = NULL;
    SDBQUERYRESULT          sdbQuery;
    DWORD                   dwNumExes = 0;

#ifdef DEBUG_SPEW
    SevInitDebugSupport();
#endif // DEBUG_SPEW

    //
    // Peb->pShimData is zeroed during process initialization
    //
    Peb = NtCurrentPeb();

    //
    // Zero out the compat flags
    //
    RtlZeroMemory(&Peb->AppCompatFlags, sizeof(LARGE_INTEGER));

    //
    // Initialize our global function pointers.
    //
    // This is done because these functions may be hooked by a shim and we don't want to trip
    // over a shim hook internally. If one of these functions is hooked, these global pointers
    // will be overwritten with thunk addresses.
    //

    g_pfnLdrLoadDLL = LdrLoadDll;
    g_pfnLdrUnloadDLL = LdrUnloadDll;
    g_pfnRtlAllocateHeap = RtlAllocateHeap;
    g_pfnRtlFreeHeap = RtlFreeHeap;

    //
    // check whether we have anything to do
    //
    if (pAppCompatExeData == NULL) {
        DPF(("[SE_InstallBeforeInit] NULL pAppCompatExeData\n"));
        goto cleanup;
    }

    //
    // Set up our own shim heap
    //
    g_pShimHeap = RtlCreateHeap(HEAP_GROWABLE,
                                0,          // location isn't important
                                64 * 1024,  // 64k is the initial heap size
                                8 * 1024,   // bring in an 1/8 of the reserved pages
                                0,
                                0);
    if (g_pShimHeap == NULL) {
        //
        // We didn't get our heap
        //
        DPF(("[SE_InstallBeforeInit] Can't create shim heap\n"));
        goto cleanup;
    }

    //
    // Open up the Database and see if there's any blob information about this Exe
    //
    hSDB = SdbInitDatabase(0, NULL);

    if (NULL == hSDB) {
        //
        // Return success even though the database failed to init.
        //
        DPF(("[SE_InstallBeforeInit] Can't open shim DB\n"));
        goto cleanup;
    }

    bResult = SdbUnpackAppCompatData(hSDB,
                                     UnicodeImageName->Buffer,
                                     pAppCompatExeData,
                                     &sdbQuery);
    if (!bResult) {
        //
        // Return success even though we didn't get the exe.
        // This way a corrupt database won't stop an application from running
        // The shim will not install itself.
        //
        DPF(("[SEv_InstallBeforeInit] bad appcompat data for \"%S\"\n",
             UnicodeImageName->Buffer));
        goto cleanup;
    }

    //
    // TBD - decide whether we're actually keeping this up to date, and if so, we should
    // put in support for multiple exes and layers.
    //

    for (dwNumExes = 0; dwNumExes < SDB_MAX_EXES; ++dwNumExes) {
        if (sdbQuery.atrExes[dwNumExes] == TAGREF_NULL) {
            break;
        }
    }

    if (dwNumExes) {
        trExe   = sdbQuery.atrExes[dwNumExes - 1];
    }
    trLayer = sdbQuery.atrLayers[0];

    //
    // Debug spew for matching notification
    //
    DPF(("[SE_InstallBeforeInit] Matched entry: %S\n", UnicodeImageName->Buffer));

    //
    // Compute the number of shim DLLs we need to inject
    //
    dwDLLCount = 0;

    if (trExe != TAGREF_NULL) {
        trDllRef = SdbFindFirstTagRef(hSDB, trExe, TAG_SHIM_REF);
        while (trDllRef) {
            dwDLLCount++;
            trDllRef = SdbFindNextTagRef(hSDB, trExe, trDllRef);
        }
    }

    if (trLayer != TAGREF_NULL) {
        //
        // Set the layer environment variable if not set
        //
        SevSetLayerEnvVar(hSDB, trLayer);

        trDllRef = SdbFindFirstTagRef(hSDB, trLayer, TAG_SHIM_REF);
        while (trDllRef) {
            dwDLLCount++;
            trDllRef = SdbFindNextTagRef(hSDB, trLayer, trDllRef);
        }
    }

    //
    // See if there are any shim DLLs
    //
    if (dwDLLCount == 0) {
        DPF(("[SE_InstallBeforeInit] No shim DLLs. Look for memory patches\n"));
        goto MemPatches;
    }

    //
    // Allocate our PEB data
    //
    if (Peb->pShimData == NULL) {
        status = SevInitializeData((PAPP_COMPAT_SHIM_INFO*)&(Peb->pShimData));

        if (status != STATUS_SUCCESS) {
            DPF(("[SE_InstallBeforeInit] Can't initialize shim data.\n"));
            goto cleanup;
        }
    }

    //
    // Allocate a storage pointer for our hook information
    // Note: The + 1 below is for our global hooks
    //
    pHookArray = (PHOOKAPI*)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                    HEAP_ZERO_MEMORY,
                                                    sizeof(PHOOKAPI) * (dwDLLCount + 1));


    if (pHookArray == NULL) {
        DPF(("[SE_InstallBeforeInit] Failure allocating hook array\n"));
        goto cleanup;
    }

    pdwNumberHooksArray = (PDWORD)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                          HEAP_ZERO_MEMORY,
                                                          sizeof(DWORD) * (dwDLLCount + 1));

    if (pdwNumberHooksArray == NULL) {
        DPF(("[SE_InstallBeforeInit] Failure allocating number hooks array\n"));
        goto cleanup;
    }

    dwCounter = 0;

    //
    // Setup the log file
    //
    SevInitFileLog(UnicodeImageName);

    if (trExe != TAGREF_NULL) {
        trDllRef = SdbFindFirstTagRef(hSDB, trExe, TAG_SHIM_REF);

        if (trDllRef == TAGREF_NULL) {
            bUsingExeRef = FALSE;
        }
    } else {
        bUsingExeRef = FALSE;
    }

    if (!bUsingExeRef) {
        trDllRef = SdbFindFirstTagRef(hSDB, trLayer, TAG_SHIM_REF);
    }

    while (trDllRef != TAGREF_NULL) {

        if (!SdbGetDllPath(hSDB, trDllRef, wszDLLPath)) {
            DPF(("[SE_InstallBeforeInit] Failed to get DLL Path\n"));
            goto cleanup;
        }

        RtlInitUnicodeString(&UnicodeString, wszDLLPath);

        //
        // Check if we already loaded this DLL
        //
        status = LdrGetDllHandle(NULL,
                                 NULL,
                                 &UnicodeString,
                                 &ModuleHandle);

        if (!NT_SUCCESS(status)) {
            status = LdrLoadDll(UNICODE_NULL, NULL, &UnicodeString, &ModuleHandle);
            if (!NT_SUCCESS(status)) {
                DPF(("[SE_InstallBeforeInit] Failed to load DLL \"%S\"\n", wszDLLPath));
                goto cleanup;
            }
        }

        //
        // Retrieve shim name
        //
        wszShimName[0] = 0;
        trShimName = SdbFindFirstTagRef(hSDB, trDllRef, TAG_NAME);
        if (trShimName == TAGREF_NULL) {
            DPF(("[SEi_InstallBeforeInit] Could not retrieve shim name from entry.\n"));
            goto cleanup;
        }

        if (!SdbReadStringTagRef(hSDB, trShimName, wszShimName, MAX_PATH)) {
            DPF(("[SEi_InstallBeforeInit] Could not retrieve shim name from entry.\n"));
            goto cleanup;
        }

        //
        // Check for command line
        //
        pwszCmdLine = (WCHAR*)(*g_pfnRtlAllocateHeap)(RtlProcessHeap(),
                                                      HEAP_ZERO_MEMORY,
                                                      SHIM_COMMAND_LINE_MAX_BUFFER * sizeof(WCHAR));

        if (pwszCmdLine == NULL) {
            DPF(("[SE_InstallBeforeInit] Failure allocating command line\n"));
            goto cleanup;
        }

        pszCmdLine = (CHAR*)(*g_pfnRtlAllocateHeap)(RtlProcessHeap(),
                                                    HEAP_ZERO_MEMORY,
                                                    SHIM_COMMAND_LINE_MAX_BUFFER * sizeof(CHAR));

        if (pszCmdLine == NULL) {
            DPF(("[SE_InstallBeforeInit] Failure allocating command line\n"));
            goto cleanup;
        }

        //
        // Default value
        //
        pszCmdLine[0] = '\0';

        trCmdLine = SdbFindFirstTagRef(hSDB, trDllRef, TAG_COMMAND_LINE);
        if (trCmdLine != TAGREF_NULL) {
            if (SdbReadStringTagRef(hSDB,
                                  trCmdLine,
                                  pwszCmdLine,
                                  SHIM_COMMAND_LINE_MAX_BUFFER)) {

                //
                // Convert command line to ANSI string
                //
                RtlInitUnicodeString(&UnicodeString, pwszCmdLine);
                RtlInitAnsiString(&AnsiString, pszCmdLine);

                AnsiString.MaximumLength = SHIM_COMMAND_LINE_MAX_BUFFER;

                status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);

                //
                // If conversion is unsuccessful, reset to zero-length string
                //
                if(!NT_SUCCESS(status)) {
                    pszCmdLine[0] = '\0';
                }
            }
        }

        //
        // Get the GetHookApis entry point
        //
        RtlInitString(&ProcedureNameString, "GetHookAPIs");
        status = LdrGetProcedureAddress(ModuleHandle,
                                        &ProcedureNameString,
                                        0,
                                        (PVOID*)&dwFuncAddress);

        if (!NT_SUCCESS(status)) {
            DPF(("[SE_InstallBeforeInit] Failed to get GetHookAPIs address, DLL \"%S\"\n",
                      wszDLLPath));
            goto cleanup;
        }

        pfnGetHookApis = (PFNGETHOOKAPIS)dwFuncAddress;
        if (pfnGetHookApis == NULL) {
            DPF(("[SE_InstallBeforeInit] GetHookAPIs address NULL, DLL \"%S\"\n", wszDLLPath));
            goto cleanup;
        }

        //
        // Call the proc and then store away its hook params
        //
        pHookArray[dwCounter] = (*pfnGetHookApis)(pszCmdLine, wszShimName, &dwTotalHooks);

        if (pHookArray[dwCounter] == NULL) {
            //
            // Failed to get a hook set
            //
            DPF(("[SE_InstallBeforeInit] GetHookAPIs returns 0 hooks, DLL \"%S\"\n",
                      wszDLLPath));
            pdwNumberHooksArray[dwCounter] = 0;
        } else {
            pdwNumberHooksArray[dwCounter] = dwTotalHooks;

            //
            // Set the DLL index number in the hook data
            //
            pTemp = pHookArray[dwCounter];
            for (dwHookIndex = 0; dwHookIndex < dwTotalHooks; dwHookIndex++) {
                //
                // Index information about the filter in maintained in the flags
                //
                pTemp[dwHookIndex].dwFlags = (WORD)dwCounter;
            }
        }

        dwCounter++;

        //
        // Get the next shim DLL ref
        //
        if (bUsingExeRef) {
            trDllRef = SdbFindNextTagRef(hSDB, trExe, trDllRef);

            if (trDllRef == TAGREF_NULL && trLayer != TAGREF_NULL) {
                bUsingExeRef = FALSE;
                trDllRef = SdbFindFirstTagRef(hSDB, trLayer, TAG_SHIM_REF);
            }
        } else {
            trDllRef = SdbFindNextTagRef(hSDB, trLayer, trDllRef);
        }
    }

    //
    // Build up our inclusion/exclusion filter
    //
    status = SevBuildExeFilter(hSDB, trExe, dwDLLCount);
    if (status != STATUS_SUCCESS) {
        //
        // Return success even though we didn't get the exe.
        // This way a corrupt database won't stop an application from running
        // The shim will not install itself.
        //
        DPF(("[SE_InstallBeforeInit] Unsuccessful building EXE filter, EXE \"%S\"\n",
                  UnicodeImageName->Buffer));
        goto cleanup;
    }

    //
    // Add our LdrLoadDll hook to the fixup list
    //
    g_InternalHookArray[0].pszModule = "NTDLL.DLL";
    g_InternalHookArray[0].pszFunctionName = "LdrLoadDll";
    g_InternalHookArray[0].pfnNew = (PVOID)StubLdrLoadDll;
    g_InternalHookArray[0].pfnOld = NULL;

    g_InternalHookArray[1].pszModule = "NTDLL.DLL";
    g_InternalHookArray[1].pszFunctionName = "LdrUnloadDll";
    g_InternalHookArray[1].pfnNew = (PVOID)StubLdrUnloadDll;
    g_InternalHookArray[1].pfnOld = NULL;

    pHookArray[dwCounter] = g_InternalHookArray;
    pdwNumberHooksArray[dwCounter] = 2;

    //
    // Walk the hook list and fixup available procs
    //
    status = SevFixupAvailableProcs((dwCounter + 1),
                                    pHookArray,
                                    pdwNumberHooksArray,
                                    &dwUnhookedCount);

    if (status != STATUS_SUCCESS) {
        DPF(("[SE_InstallBeforeInit] Unsuccessful fixing up Procs, EXE \"%S\"\n",
                  UnicodeImageName->Buffer));
        goto cleanup;
    }

    //
    // Compact the hook array for the unhooked funcs and hang it off the PEB
    //
    dwHookIndex = 0;
    ppHooks = 0;
    pShimData = (PAPP_COMPAT_SHIM_INFO)Peb->pShimData;

    if (dwUnhookedCount) {
        ppHooks = (PHOOKAPI*)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                     HEAP_ZERO_MEMORY,
                                                     sizeof(PHOOKAPI) * dwUnhookedCount);
        if (ppHooks == NULL){
            DPF(("[SE_InstallBeforeInit] Unsuccessful allocating ppHooks, EXE \"%S\"\n",
                      UnicodeImageName->Buffer));
            goto cleanup;
        }

        //
        // Iterate and copy the unhooked stuff
        //
        for (dwCounter = 0; dwCounter < dwDLLCount; dwCounter++) {
            for (dwHookCount = 0; dwHookCount < pdwNumberHooksArray[dwCounter]; dwHookCount++) {
                pTemp = pHookArray[dwCounter];

                if (pTemp && (0 == pTemp[dwHookCount].pfnOld)) {
                    //
                    // Wasn't hooked
                    //
                    ppHooks[dwHookIndex] = &pTemp[dwHookCount];

                    dwHookIndex++;
                }
            }
        }

        //
        // Update the PEB with this flat unhooked data
        //
        pShimData->ppHookAPI = ppHooks;
        pShimData->dwHookAPICount = dwUnhookedCount;
    }

    //
    // Done with shim DLLs. Look for memory patches now.
    //

MemPatches:

    if (trExe != TAGREF_NULL) {
        //
        // Walk the patch list and do the ops
        //
        trPatchRef = SdbFindFirstTagRef(hSDB, trExe, TAG_PATCH_REF);
        if (trPatchRef != TAGREF_NULL) {
            //
            // Initialize our PEB structure if we didn't get any API hooks
            //
            if (Peb->pShimData == NULL) {
                status = SevInitializeData((PAPP_COMPAT_SHIM_INFO*)&(Peb->pShimData));
                if (status != STATUS_SUCCESS) {
                    DPF(("[SE_InstallBeforeInit] Unsuccessful initializing shim data, EXE \"%S\"\n",
                              UnicodeImageName->Buffer));
                    goto cleanup;
                }
            }

            while (trPatchRef != TAGREF_NULL) {
                //
                // Grab our patch blobs and get them hooked in for execution
                //
                dwSize = 0;

                SdbReadPatchBits(hSDB, trPatchRef, NULL, &dwSize);

                if (dwSize == 0) {
                    DPF(("[SE_InstallBeforeInit] returned 0 for patch size, EXE \"%S\"\n",
                              UnicodeImageName->Buffer));
                    goto cleanup;
                }

                pAddress = (*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                   HEAP_ZERO_MEMORY,
                                                   dwSize);

                if (!SdbReadPatchBits(hSDB, trPatchRef, pAddress, &dwSize)) {
                    DPF(("[SE_InstallBeforeInit] Failure getting patch bits, EXE \"%S\"\n",
                              UnicodeImageName->Buffer));
                    goto cleanup;
                }


                //
                // Do the initial operations
                //
                status = SevExecutePatchPrimitive(pAddress);
                if (status != STATUS_SUCCESS) {
                    //
                    // If the patch failed, ignore the error and continue trying additional patches
                    //
                    DPF(("[SE_InstallBeforeInit] Failure executing patch, EXE \"%S\"\n",
                              UnicodeImageName->Buffer));
                }

                //
                // At this point the patch is hooked if necessary
                //
                trPatchRef = SdbFindNextTagRef(hSDB, trExe, trPatchRef);
            }
        }

        //
        // Set the flags for this exe in the PEB
        //
        ZeroMemory(&likf, sizeof(LARGE_INTEGER));
        trKernelFlags = SdbFindFirstTagRef(hSDB, trExe, TAG_FLAG_MASK_KERNEL);

        if (trKernelFlags != TAGREF_NULL) {
            likf.QuadPart = SdbReadQWORDTagRef(hSDB, trKernelFlags, 0);
        }

        if (likf.LowPart || likf.HighPart) {
            //
            // Initialize our PEB structure if we didn't get any API hooks or patches
            //
            if (Peb->pShimData == NULL) {
                status = SevInitializeData((PAPP_COMPAT_SHIM_INFO*)&(Peb->pShimData));
                if ( STATUS_SUCCESS != status ) {
                    DPF(("[SE_InstallBeforeInit] Unsuccessful initializing shim data, EXE \"%S\"\n",
                              UnicodeImageName->Buffer));
                    goto cleanup;
                }
            }

            //
            // Store the flags in our kernel mode struct for access later
            //
            Peb->AppCompatFlags = likf;
        }
    }


cleanup:

    //
    // Cleanup
    //
    if (pHookArray != NULL) {
        (*g_pfnRtlFreeHeap)(g_pShimHeap, 0, pHookArray);
    }

    if (pdwNumberHooksArray != NULL) {
        (*g_pfnRtlFreeHeap)(g_pShimHeap, 0, pdwNumberHooksArray);
    }

    if (pszCmdLine != NULL) {
        (*g_pfnRtlFreeHeap)(RtlProcessHeap(), 0, pszCmdLine);
    }

    if (pwszCmdLine != NULL) {
        (*g_pfnRtlFreeHeap)(RtlProcessHeap(), 0, pwszCmdLine);
    }

    if (trExe != TAGREF_NULL) {
        SdbReleaseMatchingExe(hSDB, trExe);
    }

    if (pAppCompatExeData != NULL) {
        dwSize = SdbGetAppCompatDataSize(pAppCompatExeData);

        if (dwSize != 0) {
            NtFreeVirtualMemory(NtCurrentProcess(),
                                &pAppCompatExeData,
                                &dwSize,
                                MEM_RELEASE);
        }
    }

    if (hSDB != NULL) {
        SdbReleaseDatabase(hSDB);
    }

    return;
}

void
SE_InstallAfterInit(
     IN PUNICODE_STRING UnicodeImageName,
     IN PVOID           pAppCompatExeData
     )
{
    return;

    UNREFERENCED_PARAMETER(UnicodeImageName);
    UNREFERENCED_PARAMETER(pAppCompatExeData);
}

void
SE_DllLoaded(
    PLDR_DATA_TABLE_ENTRY LdrEntry
    )
{
    PAPP_COMPAT_SHIM_INFO pShimData;
    PHOOKPATCHINFO pPatchHookList;
    PPEB Peb = NtCurrentPeb();

    pShimData = (PAPP_COMPAT_SHIM_INFO)Peb->pShimData;

    //
    // Call the shim patcher so we have a chance to modify any memory before
    // the initialize routine takes over
    //
    if (pShimData) {
       pPatchHookList = (PHOOKPATCHINFO)pShimData->pHookPatchList;

       RtlEnterCriticalSection((CRITICAL_SECTION *)pShimData->pCritSec);

       while (pPatchHookList) {
          //
          // See if this patch is hooked with a thunk
          //
          if (0 == pPatchHookList->dwHookAddress &&
              0 == pPatchHookList->pThunkAddress) {
             //
             // Patch is for DLL load
             //
             SevExecutePatchPrimitive((PBYTE)pPatchHookList->pData);
          }

          pPatchHookList = pPatchHookList->pNextHook;
       }

       RtlLeaveCriticalSection((CRITICAL_SECTION *)pShimData->pCritSec);

       //
       // Potentially one of our exception DLLs got rebased. Re-validate our filter data
       //
       SevValidateGlobalFilter();
    }
}

void
SE_DllUnloaded(
    PLDR_DATA_TABLE_ENTRY LdrEntry
    )
{
    return;

    UNREFERENCED_PARAMETER(LdrEntry);
}

void
SE_GetProcAddress(
    PVOID* pProcedureAddress
    )
{
    return;
}

BOOL
SE_IsShimDll(
    PVOID pDllBase
    )
{
    return 0;
}


NTSTATUS
SevBuildExeFilter(
    HSDB   hSDB,
    TAGREF trExe,
    DWORD  dwDLLCount)

/*++

Routine Description:

    This function is a shim internal use facility which builds an API filter list.

Arguments:

    dwDLLCount - Count of the number of DLLs used in this shim
    pBlob0     - Pointer to the shim database blob 0
    pExeMatch  - Pointer to the exe for which we're bulding a filter list

Return Value:

    Return is STATUS_SUCCESS if the exception list is built successfully, or an error otherwise.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PAPP_COMPAT_SHIM_INFO pShimData = 0;
    PMODULEFILTER *pDLLVector = 0;
    PMODULEFILTER pModFilter = 0;
    PMODULEFILTER pLastGlobal = 0;
    PMODULEFILTER pLast = 0;
    DWORD dwDLLIndex = 0;
    TAGREF trDatabase = TAGREF_NULL;
    TAGREF trLibrary = TAGREF_NULL;
    TAGREF trDll = TAGREF_NULL;
    TAGREF trDllRef = TAGREF_NULL;
    TAGREF trInclude = TAGREF_NULL;
    TAGREF trName = TAGREF_NULL;
    WCHAR wszDLLPath[MAX_PATH * 2];
    BOOL bLateBound = FALSE;

    pShimData = (PAPP_COMPAT_SHIM_INFO)NtCurrentPeb()->pShimData;
    if (0 == pShimData) {
       DPF(("[SevBuildExeFilter] Bad shim data.\n"));

       return STATUS_UNSUCCESSFUL;
    }

    if (0 == trExe) {
       DPF(("[SevBuildExeFilter] Bad trExe.\n"));
       return STATUS_UNSUCCESSFUL;
    }

    //
    // Allocate our DLL exception list vector
    //
    pShimData->pExeFilter = (PVOID)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                           HEAP_ZERO_MEMORY,
                                                           sizeof(PMODULEFILTER) * dwDLLCount);

    if (0 == pShimData->pExeFilter) {
       DPF(("[SevBuildExeFilter] Failure allocating Exe filter.\n"));
       return STATUS_UNSUCCESSFUL;
    }

    //
    // Walk the EXE DLL filter data (if any exists)
    //
    pDLLVector = (PMODULEFILTER *)pShimData->pExeFilter;

    trDllRef = SdbFindFirstTagRef(hSDB, trExe, TAG_SHIM_REF);
    dwDLLIndex = 0;

    while (trDllRef) {

        //
        // Grab the dll filter info and walk it
        //
        trInclude = SdbFindFirstTagRef(hSDB, trDllRef, TAG_INEXCLUDE);
        while (trInclude) {
            //
            // Allocate some memory for this filter
            //
            pModFilter = (PMODULEFILTER)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                                HEAP_ZERO_MEMORY,
                                                                sizeof(MODULEFILTER));

            if (0 == pModFilter) {
               DPF(("[SevBuildExeFilter] Failure allocating pModFilter.\n"));
               return STATUS_UNSUCCESSFUL;
            }

            status = SevBuildFilterException(hSDB,
                                             trInclude,
                                             pModFilter,
                                             &bLateBound);
            if (STATUS_SUCCESS != status) {
               DPF(("[SevBuildExeFilter] Failure SevBuildFilterException.\n"));
               return status;
            }

            //
            // Add entry to the list
            //
            if (0 == pDLLVector[dwDLLIndex]) {
               pDLLVector[dwDLLIndex] = pModFilter;
            } else if (pLast != NULL) {
               //
               // Add this to the tail end
               //
               pLast->pNextFilter = pModFilter;
            }

            pLast = pModFilter;

            //
            // See if we need to be in the late bound list
            //
            if (bLateBound) {
               pModFilter->pNextLBFilter = (PMODULEFILTER)pShimData->pLBFilterList;
               pShimData->pLBFilterList = (PVOID)pModFilter;
            }

            trInclude = SdbFindNextTagRef(hSDB, trDllRef, trInclude);
        }

        //
        // Add dll ref to the global exclusion filter
        //
        if (!SdbGetDllPath(hSDB, trDllRef, wszDLLPath)) {
           DPF(("[SevBuildExeFilter] Failure SdbGetDllPath.\n"));
           return status;
        }

        //
        // Allocate some memory for this filter
        //
        pModFilter = (PMODULEFILTER)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                            HEAP_ZERO_MEMORY,
                                                            sizeof(MODULEFILTER));

        if (0 == pModFilter) {
           DPF(("[SevBuildExeFilter] Failure allocating pModFilter.\n"));
           return STATUS_UNSUCCESSFUL;
        }

        status = SevAddShimFilterException(wszDLLPath,
                                           pModFilter);
        if (STATUS_SUCCESS != status) {
           //
           // If this happens its most likely a shim DLL wasn't loadable - this is fatal for the shim
           //
           DPF(("[SevBuildExeFilter] Failure SevAddShimFilterException.\n"));
           return status;
        }

        //
        // Add entry to the list
        //
        if (0 == pShimData->pGlobalFilterList) {
           pShimData->pGlobalFilterList = (PVOID)pModFilter;
        }
        else {
           //
           // Add this to the tail end
           //
           pLastGlobal->pNextFilter = pModFilter;
        }

        pLastGlobal = pModFilter;

        dwDLLIndex++;

        trDllRef = SdbFindNextTagRef(hSDB, trExe, trDllRef);
    }

    //
    // Walk the DLL filter data and add any additional exceptions to the EXE DLL list
    //
    trDllRef = SdbFindFirstTagRef(hSDB, trExe, TAG_SHIM_REF);
    dwDLLIndex = 0;

    while (trDllRef) {
        //
        // Lookup the EXE DLL in the DLL library
        //
        WCHAR wszName[MAX_PATH];

        trDll = SdbGetShimFromShimRef(hSDB, trDllRef);

        if (!trDll) {
            trDllRef = SdbFindNextTagRef(hSDB, trExe, trDllRef);
            continue;
        }

        wszName[0] = 0;
        trName = SdbFindFirstTagRef(hSDB, trDll, TAG_NAME);
        if (trName) {
            SdbReadStringTagRef(hSDB, trName, wszName, MAX_PATH * sizeof(WCHAR));
        }

        //
        // Debug spew for DLL injection notification
        //
        DPF(("[SevBuildExeFilter] Injected DLL: %S\n", wszName));

        //
        // Add these includes to the DLL exception list for this exe
        //
        trInclude = SdbFindFirstTagRef(hSDB, trDll, TAG_INEXCLUDE);
        while(trInclude) {
            //
            // Allocate some memory for this filter
            //
            pModFilter = (PMODULEFILTER)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                                HEAP_ZERO_MEMORY,
                                                                sizeof(MODULEFILTER));

            if (0 == pModFilter) {
               DPF(("[SevBuildExeFilter] Failure allocating pModFilter.\n"));
               return STATUS_UNSUCCESSFUL;
            }

            status = SevBuildFilterException(hSDB,
                                             trInclude,
                                             pModFilter,
                                             &bLateBound);
            if (STATUS_SUCCESS != status) {
               DPF(("[SevBuildExeFilter] Failure SevBuildFilterException.\n"));
               return status;
            }

            //
            // Add entry to the list
            //
            if (0 == pDLLVector[dwDLLIndex]) {
               pDLLVector[dwDLLIndex] = pModFilter;
            }
            else {
               //
               // Add this to the tail end
               //
               pLast->pNextFilter = pModFilter;
            }

            pLast = pModFilter;

            //
            // See if we need to be in the late bound list
            //
            if (bLateBound) {
               pModFilter->pNextLBFilter = (PMODULEFILTER)pShimData->pLBFilterList;
               pShimData->pLBFilterList = (PVOID)pModFilter;
            }

            trInclude = SdbFindNextTagRef(hSDB, trDll, trInclude);
        }

        dwDLLIndex++;

        trDllRef = SdbFindNextTagRef(hSDB, trExe, trDllRef);
    }

    //
    // Walk the global exclusion data
    //

    //
    // Set our list pointer to the last global exclusion added, if any
    //
    pLast = pLastGlobal;

    trDatabase = SdbFindFirstTagRef(hSDB, TAGREF_ROOT, TAG_DATABASE);
    if (!trDatabase) {
        DPF(("[SevBuildExeFilter] Failure finding DATABASE.\n"));
        goto cleanup;
    }

    trLibrary = SdbFindFirstTagRef(hSDB, trDatabase, TAG_LIBRARY);
    if (!trLibrary) {
        DPF(("[SevBuildExeFilter] Failure finding LIBRARY.\n"));
        goto cleanup;
    }

    trInclude = SdbFindFirstTagRef(hSDB, trLibrary, TAG_INEXCLUDE);
    while (trInclude) {
        //
        // Allocate some memory for this filter
        //
        pModFilter = (PMODULEFILTER)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                            HEAP_ZERO_MEMORY,
                                                            sizeof(MODULEFILTER));


        if (0 == pModFilter) {
           DPF(("[SevBuildExeFilter] Failure allocating pModFilter.\n"));
           return STATUS_UNSUCCESSFUL;
        }

        status = SevBuildFilterException(hSDB,
                                         trInclude,
                                         pModFilter,
                                         &bLateBound);
        if (STATUS_SUCCESS != status) {
           DPF(("[SevBuildExeFilter] Failure SevBuildFilterException.\n"));
           return status;
        }

        //
        // Add entry to the list
        //
        if (0 == pShimData->pGlobalFilterList) {
           pShimData->pGlobalFilterList = (PVOID)pModFilter;
        }
        else {
           //
           // Add this to the tail end
           //
           pLast->pNextFilter = pModFilter;
        }

        pLast = pModFilter;

        //
        // See if we need to be in the late bound list
        //
        if (bLateBound) {
           pModFilter->pNextLBFilter = (PMODULEFILTER)pShimData->pLBFilterList;
           pShimData->pLBFilterList = (PVOID)pModFilter;
        }

        trInclude = SdbFindNextTagRef(hSDB, trLibrary, trInclude);
    }

cleanup:
    return status;
}

NTSTATUS
SevBuildFilterException(
    HSDB          hSDB,
    TAGREF        trInclude,
    PMODULEFILTER pModFilter,
    BOOL*         pbLateBound)

/*++

Routine Description:

    This function is a shim internal use facility which builds an API filter.

Arguments:

    trInclude   - Tag ref from the database about the inclusion information to build
    pModFilter  - Filter structure to build used in the inclusion/exclusion filtering
    pbLateBound - Boolean value which is set TRUE if a DLL needed to build the internal filter
                  wasn't present in the address space of the process.

Return Value:

    Return is STATUS_SUCCESS if the exception is built successfully, or an error otherwise.

--*/

{
    PVOID ModuleHandle = 0;
    WCHAR *pwszDllName = 0;
    UNICODE_STRING UnicodeString;
    NTSTATUS status = STATUS_SUCCESS;
    PIMAGE_NT_HEADERS NtHeaders = 0;
    WCHAR wszModule[MAX_PATH];
    DWORD dwModuleOffset = 0;
    TAGREF trModule = TAGREF_NULL;
    TAGREF trOffset = TAGREF_NULL;

    *pbLateBound = FALSE;

    //
    // Mark this filter exception as inclusion/exclusion
    //
    if (SdbFindFirstTagRef(hSDB, trInclude, TAG_INCLUDE)) {
       pModFilter->dwFlags |= MODFILTER_INCLUDE;
    } else {
       pModFilter->dwFlags |= MODFILTER_EXCLUDE;
    }

    //
    // Convert addresses to absolute values and store
    //
    trModule = SdbFindFirstTagRef(hSDB, trInclude, TAG_MODULE);
    if (!SdbReadStringTagRef(hSDB, trModule, wszModule, MAX_PATH * sizeof(WCHAR))) {

        DPF(("[SevBuildFilterException] Failure reading module name.\n"));
        return STATUS_UNSUCCESSFUL;
    }

    if ( L'*' == wszModule[0]) {
       pModFilter->dwFlags |= MODFILTER_GLOBAL;

       return status;
    }

    //
    // Is this a global filter?
    //
    trOffset = SdbFindFirstTagRef(hSDB, trInclude, TAG_OFFSET);
    if (trOffset) {
        dwModuleOffset = SdbReadDWORDTagRef(hSDB, trOffset, 0);
    }

    if (0 == dwModuleOffset) {
       pModFilter->dwFlags |= MODFILTER_DLL;
       pModFilter->dwCallerOffset = dwModuleOffset;
    }

    if (L'$' == wszModule[0]) {
       //
       // Precalculate the caller address or call range
       //
       if (pModFilter->dwFlags & MODFILTER_DLL) {
          //
          // Set the address range
          //
          NtHeaders = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);

          pModFilter->dwModuleStart = (DWORD)NtCurrentPeb()->ImageBaseAddress;
          pModFilter->dwModuleEnd = pModFilter->dwModuleStart + (DWORD)(NtHeaders->OptionalHeader.SizeOfImage);
       }
       else {
          pModFilter->dwCallerAddress = (DWORD)NtCurrentPeb()->ImageBaseAddress + pModFilter->dwCallerOffset;
       }
    }
    else {

       RtlInitUnicodeString(&UnicodeString, wszModule);

       //
       // Make sure our module is loaded before calculating address ranges
       //
       status = LdrGetDllHandle(
                   NULL,
                   NULL,
                   &UnicodeString,
                   &ModuleHandle);
       if (STATUS_SUCCESS != status) {
          //
          // We most likely have a late bound DLL which doesn't exist in the search path
          //
          *pbLateBound = TRUE;

          pwszDllName = wszModule + wcslen(wszModule);

          while(pwszDllName > wszModule) {
             if ('\\' == *pwszDllName) {
                break;
             }

             pwszDllName--;
          }

          //
          // Check to see if we're at the beginning of the string or we hit a slash
          //
          if (pwszDllName > wszModule){
             //
             // Adjust our buffer pointer
             //
             pwszDllName++;
          }

          wcscpy(pModFilter->wszModuleName, pwszDllName);

          return STATUS_SUCCESS;
       }

       //
       // Precalculate the caller address or call range
       //
       if (pModFilter->dwFlags & MODFILTER_DLL) {
          //
          // Set the address range
          //
          NtHeaders = RtlImageNtHeader(ModuleHandle);

          pModFilter->dwModuleStart = (DWORD)ModuleHandle;
          pModFilter->dwModuleEnd = pModFilter->dwModuleStart + (DWORD)(NtHeaders->OptionalHeader.SizeOfImage);
       }
       else {
          pModFilter->dwCallerAddress = (DWORD)ModuleHandle + pModFilter->dwCallerOffset;
       }
    }

    //
    // Copy just the DLL name
    //
    pwszDllName = wszModule + wcslen(wszModule);

    while(pwszDllName > wszModule) {
       if ('\\' == *pwszDllName) {
          break;
       }

       pwszDllName--;
    }

    //
    // Check to see if we're at the beginning of the string or we hit a slash
    //
    if (pwszDllName > wszModule){
       //
       // Adjust our buffer pointer
       //
       pwszDllName++;
    }

    wcscpy(pModFilter->wszModuleName, pwszDllName);

    return status;
}

NTSTATUS
SevAddShimFilterException(WCHAR *wszDLLPath,
                              PMODULEFILTER pModFilter)

/*++

Routine Description:

    This function is a shim internal use facility which builds an API filter.

Arguments:

    wszDLLPath  - Shim DLL which needs to be filtered
    pModFilter  - Pointer to a filter entry to build

Return Value:

    Return is STATUS_SUCCESS if the exception is built successfully, or an error otherwise.

--*/

{
    PVOID ModuleHandle = 0;
    WCHAR *pwszDllName = 0;
    UNICODE_STRING UnicodeString;
    NTSTATUS status = STATUS_SUCCESS;
    PIMAGE_NT_HEADERS NtHeaders = 0;

    //
    // Mark this exception as exclude
    //
    pModFilter->dwFlags |= MODFILTER_EXCLUDE;

    //
    // Shim exclusion re-entrancy is global
    //
    pModFilter->dwFlags |= MODFILTER_GLOBAL;

    //
    // The address filtering is by range
    //
    pModFilter->dwFlags |= MODFILTER_DLL;

    //
    // Load our DLL bits and get the mapping exclusion
    //
    RtlInitUnicodeString(&UnicodeString, wszDLLPath);

    //
    // Make sure our module is loaded before calculating address ranges
    //
    status = LdrGetDllHandle(
                   NULL,
                   NULL,
                   &UnicodeString,
                   &ModuleHandle);
    if (STATUS_SUCCESS != status) {
       //
       // DLL wasn't loaded to do figure out the address mappings
       //
       DPF(("[SevAddShimFilterException] Failure LdrGetDllHandle.\n"));
       return STATUS_UNSUCCESSFUL;
    }

    //
    // Precalculate the caller address or call range
    //
    if (pModFilter->dwFlags & MODFILTER_DLL) {
       //
       // Set the address range
       //
       NtHeaders = RtlImageNtHeader(ModuleHandle);

       pModFilter->dwModuleStart = (DWORD)ModuleHandle;
       pModFilter->dwModuleEnd = pModFilter->dwModuleStart + (DWORD)(NtHeaders->OptionalHeader.SizeOfImage);
    }

    //
    // Copy just the DLL name
    //
    pwszDllName = wszDLLPath + wcslen(wszDLLPath);

    while(pwszDllName > wszDLLPath) {
       if ('\\' == *pwszDllName) {
          break;
       }

       pwszDllName--;
    }

    //
    // Check to see if we're at the beginning of the string or we hit a slash
    //
    if (pwszDllName > wszDLLPath){
       //
       // Adjust our buffer pointer
       //
       pwszDllName++;
    }

    wcscpy(pModFilter->wszModuleName, pwszDllName);

    return status;
}

NTSTATUS
SevFixupAvailableProcs(DWORD dwHookCount,
                           PHOOKAPI *pHookArray,
                           PDWORD pdwNumberHooksArray,
                           PDWORD pdwUnhookedCount)

/*++

Routine Description:

    The primary function of this proc is to get any defined API hooks snapped in to place.
    It has to build a call thunk and insert the hook mechanism into the API entry before any
    function is hooked.  An entry for the hooked function hangs off the PEB so the call can be
    redirected when the function is executed.

Arguments:

    dwHookCount         -       Number of hook blobs to walk
    pHookArray          -       Pointer to the array of hook blobs
    pdwNumberHooksArray -       Pointer to a dword array which contains the hooks per blob
    pdwUnhookedCount    -       Pointer to a dword which will contian the number of unhooked
                                functions on exit.

Return Value:

    Return is STATUS_SUCCESS if no problems occured

--*/

{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    WCHAR wBuffer[MAX_PATH*2];
    DWORD dwCounter = 0;
    DWORD dwApiCounter = 0;
    PHOOKAPI pCurrentHooks = 0;
    STRING ProcedureNameString;
    PVOID ModuleHandle = 0;
    DWORD dwFuncAddress = 0;
    DWORD dwInstruction = 0;
    NTSTATUS status = STATUS_SUCCESS;
    PAPP_COMPAT_SHIM_INFO pShimData = 0;
    PVOID pThunk = 0;
    DWORD dwThunkSize = 0;
    PHOOKAPIINFO pTopHookAPIInfo = 0;
    PHOOKAPI pCurrentHookTemp = 0;
    PPEB Peb = 0;
    BOOL bChained = FALSE;
    PHOOKAPI pHookTemp = 0;

    Peb = NtCurrentPeb();
    pShimData = (PAPP_COMPAT_SHIM_INFO)Peb->pShimData;

    if (0 == dwHookCount || 0 == pHookArray) {
       DPF(("[SevFixupAvailableProcs] Bad params.\n"));
       return STATUS_UNSUCCESSFUL;
    }

    *pdwUnhookedCount = 0;

    //
    // Add any hooks which haven't already been entered
    //
    for (dwCounter = 0; dwCounter < dwHookCount; dwCounter++) {

        //
        // Iterate our array and search for the function to hook
        //
        pCurrentHooks = pHookArray[dwCounter];
        if (0 == pCurrentHooks) {
           //
           // This was a hook which didn't initialize, skip over it
           //
           continue;
        }

        for (dwApiCounter = 0; dwApiCounter < pdwNumberHooksArray[dwCounter]; dwApiCounter++) {

            //
            // Is this DLL mapped in the address space?
            //
            RtlInitAnsiString(&AnsiString, pCurrentHooks[dwApiCounter].pszModule);

            UnicodeString.Buffer = wBuffer;
            UnicodeString.MaximumLength = sizeof(wBuffer);

            if ( STATUS_SUCCESS != RtlAnsiStringToUnicodeString(&UnicodeString,
                                                                &AnsiString,
                                                                FALSE)){
               DPF(("[SevFixupAvailableProcs] Failure LdrUnloadDll.\n"));
               return STATUS_UNSUCCESSFUL;
            }

            status = LdrGetDllHandle(
                         NULL,
                         NULL,
                         &UnicodeString,
                         &ModuleHandle);
            if (STATUS_SUCCESS != status) {
               (*pdwUnhookedCount)++;
               continue;
            }

            //
            // Get the entry point for our hook
            //
            RtlInitString( &ProcedureNameString, pCurrentHooks[dwApiCounter].pszFunctionName );

            status = LdrGetProcedureAddress(ModuleHandle,
                                            &ProcedureNameString,
                                            0,
                                            (PVOID *)&dwFuncAddress);
            if ( STATUS_SUCCESS != status ) {
               DPF(("[SevFixupAvailableProcs] Failure LdrGetProcedureAddress \"%s\".\n",
                         ProcedureNameString.Buffer));
               return STATUS_UNSUCCESSFUL;
            }

            //
            // Have we hooked this one already?
            //
            pTopHookAPIInfo = (PHOOKAPIINFO)pShimData->pHookAPIList;
            bChained = FALSE;

            //
            // Keep the list locked while we iterate through it
            //
            RtlEnterCriticalSection((CRITICAL_SECTION *)pShimData->pCritSec);

            while (pTopHookAPIInfo) {
               if (pTopHookAPIInfo->dwAPIHookAddress == dwFuncAddress) {
                  //
                  // We have already started an API hook chain
                  //
                  bChained = TRUE;

                  break;
               }

               pTopHookAPIInfo = pTopHookAPIInfo->pNextHook;
            }

            //
            // Release our lock on the list
            //
            RtlLeaveCriticalSection((CRITICAL_SECTION *)pShimData->pCritSec);

            //
            // We are chained - determine if this is a link we need to chain up
            //
            if (bChained) {
               //
               // Look at the chained flag and skip to the next API hook if already processed
               //
               if ((pCurrentHooks[dwApiCounter].dwFlags & HOOK_CHAINED) ||
                   (pCurrentHooks[dwApiCounter].dwFlags & HOOK_CHAIN_TOP)) {
                  //
                  // Already processed
                  //
                  continue;
               }
            }

            //
            // Insert the hook mechanism and build the call thunk
            //
            if (FALSE == bChained){
               //
               // Build the thunk for hooking this API
               //
               pThunk = SevBuildInjectionCode((PVOID)dwFuncAddress, &dwThunkSize);
               if (!pThunk) {
                  DPF(("[SevFixupAvailableProcs] Failure allocating pThunk.\n"));
                  return STATUS_UNSUCCESSFUL;
               }

               //
               // If we just created a call stub for a routine we're trying to step over
               // fixup its thunk address now.
               //

               //
               // We do this for LdrLoadDll...
               //
               if (0 == strcmp("LdrLoadDll",
                               pCurrentHooks[dwApiCounter].pszFunctionName)) {
                  g_pfnLdrLoadDLL = (PFNLDRLOADDLL)pThunk;
                  g_pfnOldLdrLoadDLL = (PFNLDRLOADDLL)dwFuncAddress;
               }

               //
               // and LdrUnloadDLL ...
               //
               if (0 == strcmp("LdrUnloadDll",
                               pCurrentHooks[dwApiCounter].pszFunctionName)) {
                  g_pfnLdrUnloadDLL = (PFNLDRUNLOADDLL)pThunk;
                  g_pfnOldLdrUnloadDLL = (PFNLDRUNLOADDLL)dwFuncAddress;
               }

               //
               // and RtlAllocateHeap ...
               //
               if (0 == strcmp("RtlAllocateHeap",
                               pCurrentHooks[dwApiCounter].pszFunctionName)) {
                  g_pfnRtlAllocateHeap = (PFNRTLALLOCATEHEAP)pThunk;
               }

               //
               // and RtlFreeHeap ...
               //
               if (0 == strcmp("RtlFreeHeap",
                               pCurrentHooks[dwApiCounter].pszFunctionName)) {
                  g_pfnRtlFreeHeap = (PFNRTLFREEHEAP)pThunk;
               }

               //
               // Mark the code to execute and get us into the entrypoint of our hooked function
               //
               status = SevFinishThunkInjection(dwFuncAddress,
                                                    pThunk,
                                                    dwThunkSize,
                                                    REASON_APIHOOK);
               if (STATUS_SUCCESS != status) {
                  return status;
               }

               //
               // Chain the newly created thunk to our hook list
               //
               status = SevChainAPIHook(dwFuncAddress,
                                            pThunk,
                                            &(pCurrentHooks[dwApiCounter]) );
               if (STATUS_SUCCESS != status) {
                  DPF(("[SevFixupAvailableProcs] Failure on SevChainAPIHook.\n"));
                  return status;
               }

               //
               // Set this as the top level hook
               //
               pCurrentHooks[dwApiCounter].dwFlags |= HOOK_CHAIN_TOP;
            }
            else {
               //
               // We are chaining APIs
               //

               //
               // See if our old top-level hook has been chained up for the exception filter
               //
               if (0 == (pTopHookAPIInfo->pTopLevelAPIChain->dwFlags & HOOK_CHAINED)) {
                  //
                  // Add this one to the exception filter
                  //

                  //
                  // Build the thunk for hooking this API
                  //
                  pThunk = SevBuildInjectionCode(pTopHookAPIInfo->pTopLevelAPIChain->pfnNew,
                                                     &dwThunkSize);
                  if (!pThunk) {
                     DPF(("[SevFixupAvailableProcs] Failure allocating pThunk.\n"));
                     return STATUS_UNSUCCESSFUL;
                  }

                  //
                  // Mark the code to execute and get us into the entrypoint of our hooked function
                  //
                  status = SevFinishThunkInjection((DWORD)pTopHookAPIInfo->pTopLevelAPIChain->pfnNew,
                                                       pThunk,
                                                       dwThunkSize,
                                                       REASON_APIHOOK);
                  if (STATUS_SUCCESS != status) {
                     return status;
                  }

                  //
                  // Create a HOOKAPI shim entry for filtering this shim stub
                  //
                  pHookTemp = (PHOOKAPI)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                                HEAP_ZERO_MEMORY,
                                                                sizeof(HOOKAPI));
                  if (!pHookTemp) {
                     DPF(("[SevFixupAvailableProcs] Failure allocating pHookTemp.\n"));
                     return STATUS_UNSUCCESSFUL;
                  }

                  //
                  // Add this to the end of the API chain list
                  //
                  pHookTemp->pfnOld = pTopHookAPIInfo->pTopLevelAPIChain->pfnOld;
                  pHookTemp->pfnNew = pThunk;
                  pHookTemp->dwFlags = (pTopHookAPIInfo->pTopLevelAPIChain->dwFlags & HOOK_INDEX_MASK);
                  pHookTemp->dwFlags |= HOOK_CHAINED;
                  pHookTemp->pszModule = pTopHookAPIInfo->pTopLevelAPIChain->pszModule;

                  //
                  // The call thunk below points to pfnOld which should skip us over this hook
                  // if its filtered
                  //
                  status = SevChainAPIHook((DWORD)pTopHookAPIInfo->pTopLevelAPIChain->pfnNew,
                                               pThunk,
                                               pHookTemp );
                  if (STATUS_SUCCESS != status) {
                     DPF(("[SevFixupAvailableProcs] Failure on SevChainAPIHook.\n"));
                     return status;
                  }

                  //
                  // Set this next hook pointer to NULL since it will always be the last link
                  //
                  pTopHookAPIInfo->pTopLevelAPIChain->pNextHook = 0;

                  //
                  // Clear the hooking flags so this isn't the top level chain
                  //
                  pTopHookAPIInfo->pTopLevelAPIChain->dwFlags &= HOOK_INDEX_MASK;
                  pTopHookAPIInfo->pTopLevelAPIChain->dwFlags |= HOOK_CHAINED;
               }
               else {
                  //
                  // Clear the hooking flags so this isn't the top level chain
                  //
                  pTopHookAPIInfo->pTopLevelAPIChain->dwFlags &= HOOK_INDEX_MASK;
                  pTopHookAPIInfo->pTopLevelAPIChain->dwFlags |= HOOK_CHAINED;
               }

               //
               // New hook needs to be in the filtering list now
               //
               if (0 == (pCurrentHooks[dwApiCounter].dwFlags & HOOK_CHAINED)) {
                  //
                  // Add this one to the exception filter
                  //

                  //
                  // Build the thunk for hooking this API
                  //
                  pThunk = SevBuildInjectionCode(pCurrentHooks[dwApiCounter].pfnNew,
                                                     &dwThunkSize);
                  if (!pThunk) {
                     DPF(("[SevFixupAvailableProcs] Failure allocating pThunk.\n"));
                     return STATUS_UNSUCCESSFUL;
                  }

                  //
                  // Mark the code to execute and get us into the entrypoint of our hooked function
                  //
                  status = SevFinishThunkInjection((DWORD)pCurrentHooks[dwApiCounter].pfnNew,
                                                       pThunk,
                                                       dwThunkSize,
                                                       REASON_APIHOOK);
                  if (STATUS_SUCCESS != status) {
                     return status;
                  }

                  //
                  // Create a HOOKAPI shim entry for filtering this shim stub
                  //
                  pHookTemp = (PHOOKAPI)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                                HEAP_ZERO_MEMORY,
                                                                sizeof(HOOKAPI));
                  if (!pHookTemp) {
                     DPF(("[SevFixupAvailableProcs] Failure allocating pHookTemp.\n"));
                     return STATUS_UNSUCCESSFUL;
                  }

                  //
                  // Insert our shim hook filter
                  //
                  pHookTemp->pfnOld = pCurrentHooks[dwApiCounter].pfnOld;
                  pHookTemp->pfnNew = pThunk;
                  pHookTemp->dwFlags = (pCurrentHooks[dwApiCounter].dwFlags & HOOK_INDEX_MASK);
                  pHookTemp->dwFlags |= HOOK_CHAINED;
                  pHookTemp->pszModule = pCurrentHooks[dwApiCounter].pszModule;

                  //
                  // The call thunk below points to pfnOld which should skip us over this hook
                  // if its filtered
                  //
                  status = SevChainAPIHook((DWORD)pCurrentHooks[dwApiCounter].pfnNew,
                                               pThunk,
                                               pHookTemp );
                  if (STATUS_SUCCESS != status) {
                     DPF(("[SevFixupAvailableProcs] Failure on SevChainAPIHook.\n"));
                     return status;
                  }

                  //
                  // Set the hook flags so this is the top level chain
                  //
                  pCurrentHooks[dwApiCounter].dwFlags &= HOOK_INDEX_MASK;
                  pCurrentHooks[dwApiCounter].dwFlags |= HOOK_CHAINED;
                  pCurrentHooks[dwApiCounter].dwFlags |= HOOK_CHAIN_TOP;
               }

               //
               // API chain list needs to be updated so the new hook is the top and points toward
               // our previous hook
               //
               pCurrentHooks[dwApiCounter].pNextHook = pTopHookAPIInfo->pTopLevelAPIChain;

               //
               // New hook needs to call the previous stub routine as the original
               //
               pCurrentHooks[dwApiCounter].pfnOld = pTopHookAPIInfo->pTopLevelAPIChain->pfnNew;

               //
               // In the shim PEB data, make this stub the top level handler on exception
               //
               pTopHookAPIInfo->pTopLevelAPIChain = &(pCurrentHooks[dwApiCounter]);
            }
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SevChainAPIHook (
    DWORD dwHookEntryPoint,
    PVOID pThunk,
    PHOOKAPI pAPIHook
    )

/*++

Routine Description:

    This routine adds a shimmed API to the internal API hook list.

Arguments:

    dwHookEntryPoint -  API entrypoint for which this hook exists
    pThunk           -  Address of the code to execute to walk around a shim's hook
    pAPIHook         -  Pointer to the HOOKAPI for this API hook

Return Value:

    Return is STATUS_SUCCESS if no errors occured.

--*/

{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    PHOOKAPIINFO pTempHookAPIInfo = 0;
    PAPP_COMPAT_SHIM_INFO pShimData = 0;
    WCHAR wBuffer[MAX_PATH*2];
    PPEB Peb = 0;

    Peb = NtCurrentPeb();
    pShimData = (PAPP_COMPAT_SHIM_INFO)Peb->pShimData;

    //
    // Allocate some memory for this hook
    //
    pTempHookAPIInfo = (PHOOKAPIINFO)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                             HEAP_ZERO_MEMORY,
                                                             sizeof(HOOKAPIINFO));
    if (!pTempHookAPIInfo) {
       DPF(("[SevChainAPIHook] Failure allocating pAPIHooks.\n"));
       return STATUS_UNSUCCESSFUL;
    }

    DPF(("[SevChainAPIHook] Hooking \"%s!%s\".\n",
              pAPIHook->pszModule,
              pAPIHook->pszFunctionName));

    pTempHookAPIInfo->pPrevHook = 0;
    pTempHookAPIInfo->pNextHook = 0;
    pTempHookAPIInfo->dwAPIHookAddress = dwHookEntryPoint;
    pTempHookAPIInfo->pTopLevelAPIChain = pAPIHook;
    pTempHookAPIInfo->pCallThunkAddress = pThunk;
    pAPIHook->pfnOld = pThunk;

    //
    // Convert our module name over to a Unicode string (shim chain filter doesn't have a set module)
    //
    if (pAPIHook->pszModule) {
       RtlInitAnsiString(&AnsiString, pAPIHook->pszModule);

       UnicodeString.Buffer = wBuffer;
       UnicodeString.MaximumLength = sizeof(wBuffer);

       if ( STATUS_SUCCESS != RtlAnsiStringToUnicodeString(&UnicodeString,
                                                           &AnsiString,
                                                           FALSE)){
          DPF(("[SevChainAPIHook] Failure RtlAnsiStringToUnicodeString.\n"));
          return STATUS_UNSUCCESSFUL;
       }

       wcscpy(pTempHookAPIInfo->wszModuleName, UnicodeString.Buffer);
    }

    //
    // Add to our hook list
    //

    //
    // Prev points to head of list
    //
    pTempHookAPIInfo->pNextHook = pShimData->pHookAPIList;
    pShimData->pHookAPIList = (PVOID)pTempHookAPIInfo;
    if (pTempHookAPIInfo->pNextHook) {
       pTempHookAPIInfo->pNextHook->pPrevHook = pTempHookAPIInfo;
    }

    return STATUS_SUCCESS;
}

LONG
SevExceptionHandler (
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )

/*++

Routine Description:

    This is where we trap all calls to "shimmed" APIs and patch hooks.  Here is where you would want to also
    want to handle any special priv mode instruction faults or any other exception type.

Arguments:

    ExceptionInfo   -  Pointer to the exception information

Return Value:

    Return is either EXCEPTION_CONTINUE_EXECUTION if we handled the exception, or
    EXCEPTION_CONTINUE_SEARCH if we didn't.

--*/

{
    PEXCEPTION_RECORD pExceptionRecord = 0;
    PCONTEXT pContextRecord = 0;
    PAPP_COMPAT_SHIM_INFO pShimData = 0;
    PHOOKAPIINFO pAPIHookList = 0;
    PHOOKPATCHINFO pPatchHookList = 0;
    PCHAININFO pTopChainInfo = 0;
    PBYTE pjReason = 0;
    PVOID pAddress = 0;
    DWORD dwFilterIndex = 0;
    PVOID pAPI = 0;
    PVOID pCaller = 0;
    PMODULEFILTER *pDLLVector = 0;
    NTSTATUS status;
    PPEB Peb = 0;
    PTEB Teb = 0;

    Peb = NtCurrentPeb();
    Teb = NtCurrentTeb();
    pShimData = Peb->pShimData;
    pExceptionRecord = ExceptionInfo->ExceptionRecord;
    pContextRecord = ExceptionInfo->ContextRecord;

    //
    // Handle any expected exception
    //
    switch(pExceptionRecord->ExceptionCode)
    {
        case STATUS_PRIVILEGED_INSTRUCTION:
             //
             // Move us to the reason for the exception
             //
             pjReason = (BYTE *)pExceptionRecord->ExceptionAddress;

             switch(*pjReason)
             {
                 case REASON_APIHOOK:
                      //
                      // Walk the APIHooks and then change our EIP
                      //
                      RtlEnterCriticalSection((CRITICAL_SECTION *)pShimData->pCritSec);

                      pAPIHookList = (PHOOKAPIINFO)pShimData->pHookAPIList;
                      while(pAPIHookList) {
                         //
                         // Is this our hooked function?
                         //
                         if ((DWORD)pExceptionRecord->ExceptionAddress == pAPIHookList->dwAPIHookAddress) {
                            //
                            // Push on our caller on this thread if this is a top level hook
                            //
                            if (pAPIHookList->pTopLevelAPIChain->dwFlags & HOOK_CHAIN_TOP) {
                               //
                               // Push our caller onto the shim call stack for this thread
                               //

                               //
                               // Note the + 1 is due to the fact the original call pushed another ret address on the stack
                               //
                               status = SevPushCaller(pExceptionRecord->ExceptionAddress,
                                                          (PVOID)(*(DWORD *)pContextRecord->Esp));
                               if (STATUS_SUCCESS != status) {
                                  //
                                  // This shouldn't fail but if it does ...
                                  //
                                  RtlLeaveCriticalSection((CRITICAL_SECTION *)pShimData->pCritSec);

                                  //
                                  // Try and give them the original function call to execute on failure
                                  //
                                  pContextRecord->Eip = (DWORD)pAPIHookList->pTopLevelAPIChain->pfnOld;

                                  return EXCEPTION_CONTINUE_EXECUTION;
                               }

                               //
                               // Change the ret address so the original call can pop its shim data for the chain
                               //
                               *(DWORD *)pContextRecord->Esp = (DWORD)fnHandleRet;
                            }

                            //
                            // Filter our calling module
                            //
                            pTopChainInfo = (PCHAININFO)Teb->pShimData;
                            pAPI = pTopChainInfo->pAPI;
                            pCaller = pTopChainInfo->pReturn;

                            //
                            // Retrieve the exe filter for this shim module
                            //
                            dwFilterIndex = pAPIHookList->pTopLevelAPIChain->dwFlags & HOOK_INDEX_MASK;
                            pDLLVector = (PMODULEFILTER *)pShimData->pExeFilter;

                            pAddress = SevFilterCaller(pDLLVector[dwFilterIndex],
                                                           pAPI,
                                                           pCaller,
                                                           pAPIHookList->pTopLevelAPIChain->pfnNew,
                                                           pAPIHookList->pTopLevelAPIChain->pfnOld);

                            RtlLeaveCriticalSection((CRITICAL_SECTION *)pShimData->pCritSec);

                            //
                            // Update our EIP to our pfnNew or PfnOld to continue
                            //
                            pContextRecord->Eip = (DWORD)pAddress;

                            return EXCEPTION_CONTINUE_EXECUTION;
                         }

                         pAPIHookList = pAPIHookList->pNextHook;
                      }

                      RtlLeaveCriticalSection((CRITICAL_SECTION *)pShimData->pCritSec);

                      //
                      // REASON_APIHOOK wasn't one generated by us
                      //
                      break;

                 case REASON_PATCHHOOK:
                      //
                      // Find our patch, do next patch opcode
                      //
                      pPatchHookList = (PHOOKPATCHINFO)pShimData->pHookPatchList;

                      RtlEnterCriticalSection((CRITICAL_SECTION *)pShimData->pCritSec);

                      while(pPatchHookList) {
                         //
                         // Is this our hooked function?
                         //
                         if ((DWORD)pExceptionRecord->ExceptionAddress == pPatchHookList->dwHookAddress){
                            //
                            // Execute the shim patch
                            //
                            status = SevExecutePatchPrimitive((PBYTE)((DWORD)pPatchHookList->pData + sizeof(SETACTIVATEADDRESS)));
                            if ( STATUS_SUCCESS != status ) {
                               //
                               // Patch failed to apply, silently abort it
                               //
                               DPF(("[SevExceptionHandler] Failed to execute patch.\n"));
                            }

                            RtlLeaveCriticalSection((CRITICAL_SECTION *)pShimData->pCritSec);

                            //
                            // Jump around the patch hook
                            //
                            pContextRecord->Eip = (DWORD)pPatchHookList->pThunkAddress;

                            return EXCEPTION_CONTINUE_EXECUTION;
                         }

                         pPatchHookList = pPatchHookList->pNextHook;
                      }

                      RtlLeaveCriticalSection((CRITICAL_SECTION *)pShimData->pCritSec);

                      //
                      // REASON_PATCHHOOK wasn't one generated by us
                      //
                      break;

                 default:
                      //
                      // Wasn't a priv mode fault we expected
                      //
                      0;
            }

            //
            // Fall out for the not handled case for priv mode faults
            //
            break;

        default:
            0;
    }

    //
    // Not handled
    //

    return EXCEPTION_CONTINUE_SEARCH;
}

NTSTATUS
SevPushCaller (PVOID pAPIAddress,
                   PVOID pReturnAddress)

/*++

Routine Description:

    This function pushes a top level shim onto the thread call stack to maintain caller
    across hooks.

Arguments:

    pAPIAddress    - Pointer to the entry point of the API
    pReturnAddress - Return address of the caller

Return Value:

    Return is STATUS_SUCCESS if no problem occured

--*/

{
    PCHAININFO pChainInfo = 0;
    PCHAININFO pTopChainInfo = 0;
    PTEB Teb = 0;

    Teb = NtCurrentTeb();
    pTopChainInfo = (PCHAININFO)Teb->pShimData;

    pChainInfo = (PCHAININFO)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                     HEAP_ZERO_MEMORY,
                                                     sizeof(CHAININFO));
    if (0 == pChainInfo){
       DPF(("[SevPushCaller] Failure allocating pChainInfo.\n"));
       return STATUS_UNSUCCESSFUL;
    }

    //
    // Fill the chain data
    //
    pChainInfo->pAPI = pAPIAddress;
    pChainInfo->pReturn = pReturnAddress;

    //
    // Add ourselves to the top of the chain
    //
    pChainInfo->pNextChain = pTopChainInfo;
    Teb->pShimData = (PVOID)pChainInfo;

    return STATUS_SUCCESS;
}

PVOID
SevPopCaller(VOID)

/*++

Routine Description:

    This function pops a top level shim off of the thread call stack to maintain caller
    across hooks.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PCHAININFO pTemp = 0;
    PCHAININFO pTopChainInfo = 0;
    PTEB Teb = 0;
    PVOID pReturnAddress = 0;

    Teb = NtCurrentTeb();

    pTopChainInfo = (PCHAININFO)Teb->pShimData;

    pReturnAddress = pTopChainInfo->pReturn;
    pTemp = pTopChainInfo->pNextChain;

    //
    // Pop the caller
    //
    Teb->pShimData = (PVOID)pTemp;

    //
    // Free our allocation
    //
    (*g_pfnRtlFreeHeap)(g_pShimHeap,
                        0,
                        pTopChainInfo);

    return pReturnAddress;
}

NTSTATUS
SevInitializeData (PAPP_COMPAT_SHIM_INFO *pShimData)

/*++

Routine Description:

    The primary function of the routine is to initialize the Shim data which hangs off the PEB
    such that later we can chain our API hooks and/or patches.

Arguments:

    pShimData -  Pointer to our PEB data pointer for the shim

Return Value:

    Return is STATUS_SUCCESS if no problem occured

--*/

{
    //
    // Allocate our PEB data
    //
    *pShimData = (PAPP_COMPAT_SHIM_INFO)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                                HEAP_ZERO_MEMORY,
                                                                sizeof(APP_COMPAT_SHIM_INFO));
    if (0 == *pShimData){
       DPF(("[SevExceptionHandler] Failure allocating pShimData.\n"));
       return STATUS_UNSUCCESSFUL;
    }

    //
    // Initialize our critical section
    //
    (*pShimData)->pCritSec = (PVOID)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                            HEAP_ZERO_MEMORY,
                                                            sizeof(CRITICAL_SECTION));
    if (0 == (*pShimData)->pCritSec){
       DPF(("[SevExceptionHandler] Failure allocating (*pShimData)->pCritSec.\n"));
       return STATUS_UNSUCCESSFUL;
    }

    RtlInitializeCriticalSection((*pShimData)->pCritSec);

    //
    // Add ourselves to the exception filtering chain
    //
    if (0 == RtlAddVectoredExceptionHandler(1,
                                            SevExceptionHandler)) {
       DPF(("[SevExceptionHandler] Failure chaining exception handler.\n"));
       return STATUS_UNSUCCESSFUL;
    }

    //
    // Store away our shim heap pointer
    //
    (*pShimData)->pShimHeap = g_pShimHeap;

    //
    // Initialize the call thunks
    //
    dwCallArray[0] = (DWORD)SevPopCaller;

    //
    // We return through this code stub to unchain the shim call stack
    //
    fnHandleRet->PUSHEAX = 0x50;               //push eax (50)
    fnHandleRet->PUSHAD = 0x60;                //pushad   (60)
    fnHandleRet->CALLROUTINE[0] = 0xff;        //call [address] (ff15 dword address)
    fnHandleRet->CALLROUTINE[1] = 0x15;
    *(DWORD *)(&(fnHandleRet->CALLROUTINE[2])) = (DWORD)&dwCallArray[0];
    fnHandleRet->MOVESPPLUS20EAX[0] = 0x89;    //mov [esp+0x20],eax (89 44 24 20)
    fnHandleRet->MOVESPPLUS20EAX[1] = 0x44;
    fnHandleRet->MOVESPPLUS20EAX[2] = 0x24;
    fnHandleRet->MOVESPPLUS20EAX[3] = 0x20;
    fnHandleRet->POPAD = 0x61;                 //popad (61)
    fnHandleRet->RET = 0xc3;                   //ret (c3)

    return STATUS_SUCCESS;
}

NTSTATUS
SevExecutePatchPrimitive(PBYTE pPatch)

/*++

Routine Description:

    This is the workhorse for the dynamic patching system.  An opcode/data primitive is passed
    through and the operation is completed in this routine if possible.

Arguments:

    pPatch -  Pointer to a data primitive to execute

Return Value:

    Return is STATUS_SUCCESS if no problem occured

--*/

{
    PPATCHMATCHDATA pMatchData = 0;
    PPATCHWRITEDATA pWriteData = 0;
    PSETACTIVATEADDRESS pActivateData = 0;
    PPATCHOP pPatchOP = 0;
    PHOOKPATCHINFO pPatchInfo = 0;
    NTSTATUS status = STATUS_SUCCESS;
    DWORD dwAddress = 0;
    PAPP_COMPAT_SHIM_INFO pShimData = 0;
    PHOOKPATCHINFO pPatchHookList = 0;
    PHOOKPATCHINFO pTempList = 0;
    PVOID pThunk = 0;
    DWORD dwInstruction = 0;
    DWORD dwThunkSize = 0;
    DWORD dwProtectSize = 0;
    DWORD dwProtectFuncAddress = 0;
    DWORD dwOldFlags = 0;
    BOOL bIteratePatch = TRUE;
    BOOL bInsertPatch = FALSE;
    PPEB Peb;

    Peb = NtCurrentPeb();
    pShimData = (PAPP_COMPAT_SHIM_INFO)Peb->pShimData;

    //
    // Grab the opcode and see what we have to do
    //
    while (bIteratePatch) {
        pPatchOP = (PPATCHOP)pPatch;

        switch(pPatchOP->dwOpcode)
        {
            case PEND:
                //
                // We are done, do nothing and return success
                //
                bIteratePatch = FALSE;
                break;

            case PSAA:
                //
                // This is a patch set application activate primitive - set it up
                //
                pActivateData = (PSETACTIVATEADDRESS)pPatchOP->data;

                //
                // Grab the physical address to do this operation
                //
                dwAddress = SevGetPatchAddress(&(pActivateData->rva));
                if (0 == dwAddress && (0 != pActivateData->rva.address)) {
                   DPF(("[SevExecutePatchPrimitive] Failure SevGetPatchAddress.\n"));
                   return STATUS_UNSUCCESSFUL;
                }

                //
                // See if we need a call thunk
                //
                if (0 != pActivateData->rva.address) {
                   //
                   // Build the thunk
                   //
                   pThunk = SevBuildInjectionCode((PVOID)dwAddress, &dwThunkSize);
                   if (!pThunk) {
                      DPF(("[SevExecutePatchPrimitive] Failure allocating pThunk.\n"));
                      return STATUS_UNSUCCESSFUL;
                   }

                   //
                   // Mark the code to execute and get us into the entrypoint of our hooked data
                   //
                   status = SevFinishThunkInjection(dwAddress,
                                                        pThunk,
                                                        dwThunkSize,
                                                        REASON_PATCHHOOK);
                   if (STATUS_SUCCESS != status) {
                      return status;
                   }
                }

                //
                // Add ourselves to the hooked list
                //
                pPatchInfo = (*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                     HEAP_ZERO_MEMORY,
                                                     sizeof(HOOKPATCHINFO));
                if (!pPatchInfo) {
                   DPF(("[SevExecutePatchPrimitive] Failure allocating pPatchInfo.\n"));
                   return STATUS_UNSUCCESSFUL;
                }

                pPatchHookList = (PHOOKPATCHINFO)pShimData->pHookPatchList;

                if (0 != pActivateData->rva.address) {
                   pPatchInfo->pNextHook = pPatchHookList;
                   pPatchInfo->dwHookAddress = dwAddress;
                   pPatchInfo->pThunkAddress = pThunk;
                   pPatchInfo->pData = (PSETACTIVATEADDRESS)((DWORD)pActivateData + sizeof(SETACTIVATEADDRESS));
                }
                else {
                   pPatchInfo->pNextHook = pPatchHookList;
                   pPatchInfo->dwHookAddress = 0;
                   pPatchInfo->pThunkAddress = 0;
                   pPatchInfo->pData = (PSETACTIVATEADDRESS)((DWORD)pActivateData + sizeof(SETACTIVATEADDRESS));
                }

                //
                // Add ourselves to the head of the list
                //
                pShimData->pHookPatchList = (PVOID)pPatchInfo;

                //
                // Break out since this is a continuation mode operation
                //
                bIteratePatch = FALSE;

                break;

            case PWD:
                //
                // This is a patch write data primitive - write the data
                //
                pWriteData = (PPATCHWRITEDATA)pPatchOP->data;

                //
                // Grab the physical address to do this operation
                //
                dwAddress = SevGetPatchAddress(&(pWriteData->rva));
                if (0 == dwAddress) {
                   DPF(("[SevExecutePatchPrimitive] Failure SevGetPatchAddress.\n"));
                   return STATUS_UNSUCCESSFUL;
                }

                //
                // Fixup the page attributes
                //
                dwProtectSize = pWriteData->dwSizeData;
                dwProtectFuncAddress = dwAddress;
                status = NtProtectVirtualMemory(NtCurrentProcess(),
                                                (PVOID)&dwProtectFuncAddress,
                                                &dwProtectSize,
                                                PAGE_READWRITE,
                                                &dwOldFlags);
                if (status) {
                   DPF(("[SevExecutePatchPrimitive] Failure NtProtectVirtualMemory.\n"));
                   return STATUS_UNSUCCESSFUL;
                }

                //
                // Copy our bytes
                //
                RtlCopyMemory((PVOID)dwAddress, (PVOID)pWriteData->data, pWriteData->dwSizeData);

                //
                // Restore the page protection
                //
                dwProtectSize = pWriteData->dwSizeData;
                dwProtectFuncAddress = dwAddress;
                status = NtProtectVirtualMemory(NtCurrentProcess(),
                                                (PVOID)&dwProtectFuncAddress,
                                                &dwProtectSize,
                                                dwOldFlags,
                                                &dwOldFlags);
                if (status) {
                   DPF(("[SevExecutePatchPrimitive] Failure NtProtectVirtualMemory.\n"));
                   return STATUS_UNSUCCESSFUL;
                }

                status = NtFlushInstructionCache(NtCurrentProcess(),
                                                 (PVOID)dwProtectFuncAddress,
                                                 dwProtectSize);

                if (!NT_SUCCESS(status)) {
                    DPF(("[SevExecutePatchPrimitive] NtFlushInstructionCache failed with status 0x%X.\n",
                              status));
                }

                //
                // Next opcode
                //
                pPatch = (PBYTE)(pPatchOP->dwNextOpcode + (DWORD)pPatch);
                break;

            case PNOP:
                //
                // This is a patch no operation primitive - just ignore this and queue next op
                //

                //
                // Next opcode
                //
                pPatch = (PBYTE)(pPatchOP->dwNextOpcode + (DWORD)pPatch);
                break;

            case PMAT:
                //
                // This is a patch match data at offset primitive
                //
                pMatchData = (PPATCHMATCHDATA)pPatchOP->data;

                //
                // Grab the physical address to do this operation
                //
                dwAddress = SevGetPatchAddress(&(pMatchData->rva));
                if (0 == dwAddress) {
                   DPF(("[SevExecutePatchPrimitive] Failure SevGetPatchAddress.\n"));
                   return STATUS_UNSUCCESSFUL;
                }

                //
                // Let's do a strncmp to verify our match
                //
                if (0 != strncmp(pMatchData->data, (PBYTE)dwAddress, pMatchData->dwSizeData)) {
                   DPF(("[SevExecutePatchPrimitive] Failure match on patch data.\n"));
                   return STATUS_UNSUCCESSFUL;
                }

                //
                // Next opcode
                //
                pPatch = (PBYTE)(pPatchOP->dwNextOpcode + (DWORD)pPatch);
                break;

            default:
                //
                // If this happens we got an unexpected operation and we have to fail
                //
                return STATUS_UNSUCCESSFUL;
        }
    }

    return status;
}

VOID
SevValidateGlobalFilter(VOID)

/*++

Routine Description:

    This routine does a quick iteration of the global filter to revalidate the filter
    address ranges of the DLLs not brought in through the original EXE imports

Arguments:

    None.

Return Value:

    Return is STATUS_SUCCESS if no problem occured

--*/

{
    NTSTATUS status;
    WCHAR *pwszDllName = 0;
    PMODULEFILTER pModFilter = 0;
    PAPP_COMPAT_SHIM_INFO pShimData = 0;
    PVOID ModuleHandle = 0;
    UNICODE_STRING UnicodeString;
    PIMAGE_NT_HEADERS NtHeaders = 0;

    pShimData = (PAPP_COMPAT_SHIM_INFO)NtCurrentPeb()->pShimData;
    pModFilter = (PMODULEFILTER)pShimData->pLBFilterList;

    //
    // Walk the global exclusion filter until we find this particular DLL load
    //
    while (pModFilter) {
        //
        // Fixup the addresses
        //
        RtlInitUnicodeString(&UnicodeString, pModFilter->wszModuleName);

        //
        // Make sure our module is loaded before calculating address ranges
        //
        status = LdrGetDllHandle(
                      NULL,
                      NULL,
                      &UnicodeString,
                      &ModuleHandle);
        if (STATUS_SUCCESS != status) {
           //
           // DLL not loaded - next pModFilter entry
           //
           pModFilter = pModFilter->pNextLBFilter;

           continue;
        }

        //
        // Precalculate the caller address or call range
        //
        if (pModFilter->dwFlags & MODFILTER_DLL) {
           //
           // Set the address range
           //
           NtHeaders = RtlImageNtHeader(ModuleHandle);

           pModFilter->dwModuleStart = (DWORD)ModuleHandle;
           pModFilter->dwModuleEnd = pModFilter->dwModuleStart + (DWORD)(NtHeaders->OptionalHeader.SizeOfImage);
        }
        else {
           //
           // Address is filtered by specific call
           //
           pModFilter->dwCallerAddress = (DWORD)ModuleHandle + pModFilter->dwCallerOffset;
        }

        pModFilter = pModFilter->pNextLBFilter;
    }

    return;
}

PVOID
SevBuildInjectionCode(
        PVOID pAddress,
        PDWORD pdwThunkSize)

/*++

Routine Description:

    This routine builds the call stub used in calling the originally hooked API.

Arguments:

    pAddress -  Pointer to the entry point for which we are building a stub.

Return Value:

    Return is non-zero if a stub was able to be generated successfully.

--*/

{
    DWORD dwPreThunkSize = 0;
    DWORD dwInstruction = 0;
    DWORD dwAdjustedInstruction = 0;
    DWORD dwStreamLength = 0;
    DWORD dwNumberOfCalls = 0;
    DWORD dwCallNumber = 0;
    DWORD dwSize = 0;
    PDWORD pdwTranslationArray = 0;
    PDWORD pdwRelativeAddress = 0;
    PVOID pThunk = 0;
    WORD SegCs = 0;

    dwStreamLength = 0;
    dwInstruction = 0;
    dwNumberOfCalls = 0;
    dwCallNumber = 0;

    //
    // Calculate the thunk size with any stream adjustments necessary for relative calls
    //
    while(dwInstruction < CLI_OR_STI_SIZE) {

       if ( *(PBYTE)((DWORD)pAddress + dwInstruction) == (BYTE)X86_REL_CALL_OPCODE) {
          dwNumberOfCalls++;
       }

       dwInstruction += GetInstructionLengthFromAddress((PVOID)((DWORD)pAddress + dwInstruction));
    }

    //
    // Call dword [xxxx] is 6 bytes and call relative is 5.
    //
    dwPreThunkSize = dwInstruction;
    dwStreamLength = dwInstruction + (1 * dwNumberOfCalls);

    //
    // Allocate our call dword [xxxx] translation array
    //
    if (dwNumberOfCalls) {
       pdwTranslationArray = (PDWORD)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                             HEAP_ZERO_MEMORY,
                                                             dwNumberOfCalls * sizeof(DWORD));

       if (!pdwTranslationArray){
          *pdwThunkSize = 0;
          return pThunk;
       }
    }

    //
    // Allocate our instruction stream with the size of the absolute jmp included
    //
    pThunk = (*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                     HEAP_ZERO_MEMORY,
                                     dwStreamLength + JMP_SIZE);
    if ( !pThunk ){
       *pdwThunkSize = 0;
       return pThunk;
    }

    //
    // Do any relative call translations
    //
    if (dwNumberOfCalls) {
       dwInstruction = 0;
       dwAdjustedInstruction = 0;

       do
       {
           dwSize = GetInstructionLengthFromAddress((PVOID)((DWORD)pAddress + dwInstruction));

           if (*(PBYTE)((DWORD)pAddress + dwInstruction) == (BYTE)X86_REL_CALL_OPCODE) {
              //
              // Calculate the call address (it's a dword following the opcode)
              //
              pdwRelativeAddress = (PDWORD)((DWORD)pAddress + dwInstruction + 1);

              //
              // Do the relative call translation
              //
              pdwTranslationArray[dwCallNumber] = *pdwRelativeAddress + (DWORD)pAddress + dwInstruction + CALL_REL_SIZE;

              //
              // Finally create the call dword code
              //
              *((BYTE *)((DWORD)pThunk + dwAdjustedInstruction)) = X86_CALL_OPCODE;
              *((BYTE *)((DWORD)pThunk + dwAdjustedInstruction + 1)) = X86_CALL_OPCODE2;
              *((DWORD *)((DWORD)pThunk + dwAdjustedInstruction + 1 + 1)) = (DWORD)&pdwTranslationArray[dwCallNumber];

              //
              // Make sure our index is in sync with our translation
              //
              dwCallNumber++;

              dwAdjustedInstruction += CLI_OR_STI_SIZE;
          }
          else {
             //
             // Copy the instruction bytes across -- it's not a call
             //
             RtlMoveMemory((PVOID)((DWORD)pThunk + dwAdjustedInstruction),
                           (PVOID)((DWORD)pAddress + dwInstruction),
                           dwSize);

             dwAdjustedInstruction += dwSize;
          }

          dwInstruction += dwSize;
       }
       while(dwInstruction < dwPreThunkSize);
    }
    else {
       //
       // Nothing to translate
       //
       RtlMoveMemory(pThunk, pAddress, dwStreamLength);
    }

    //
    // Grab the code segment for the thunk (we use this to build our absolute jump)
    //
    _asm {
        push cs
        pop eax
        mov SegCs, ax
    }

    //
    // Add the absolute jmp to the end of the stub
    //
    *((BYTE *)(dwStreamLength + (DWORD)pThunk )) = X86_ABSOLUTE_FAR_JUMP;
    *((DWORD *)(dwStreamLength + (DWORD)pThunk + 1)) = ((DWORD)pAddress + dwInstruction);
    *((WORD *)(dwStreamLength + (DWORD)pThunk + 1 + 4)) = SegCs;

    //
    // Set the size of the call thunk
    //
    *pdwThunkSize = dwStreamLength + JMP_SIZE;

    return pThunk;
}

DWORD
SevGetPatchAddress(PRELATIVE_MODULE_ADDRESS pRelAddress)

/*++

Routine Description:

    This routine is designed to calculate an absolute address for a relative offset and
    module name.

Arguments:

    pRelAddress -  Pointer to a RELATIVE_MODULE_ADDRESS data structure

Return Value:

    Return is non-zero if an address was calculatable, otherwise 0 is returned for failure.

--*/

{
    WCHAR wszModule[MAX_PATH*2];
    PVOID ModuleHandle = 0;
    UNICODE_STRING UnicodeString;
    DWORD dwAddress = 0;
    NTSTATUS status;
    PPEB Peb = 0;

    Peb = NtCurrentPeb();

    if (pRelAddress->moduleName[0] != L'\0') {
       //
       // Copy the module name from the patch since it will typically be misaligned
       //
       wcscpy(wszModule, pRelAddress->moduleName);

       //
       // Look up the module name and get the base address
       //

       //
       // Is this DLL mapped in the address space?
       //
       RtlInitUnicodeString(&UnicodeString, wszModule);

       //
       // Make sure our module is loaded before calculating address ranges
       //
       status = LdrGetDllHandle(
                   NULL,
                   NULL,
                   &UnicodeString,
                   &ModuleHandle);
       if (STATUS_SUCCESS != status) {
          //
          // This module should be present and it isn't - bail
          //
          DPF(("[SevGetPatchAddress] Failure LdrGetDllHandle.\n"));
          return 0;
       }

       //
       // We're done, return the address
       //
       return ( (DWORD)ModuleHandle + pRelAddress->address );
    }
    else {
       //
       // Go to the PEB and we're done
       //
       dwAddress = (DWORD)Peb->ImageBaseAddress + pRelAddress->address;

       return dwAddress;
    }

    DPF(("[SevGetPatchAddress] Failure; reached end of function.\n"));
    return 0;
}

NTSTATUS
StubLdrLoadDll (
    IN PWSTR DllPath OPTIONAL,
    IN PULONG DllCharacteristics OPTIONAL,
    IN PUNICODE_STRING DllName,
    OUT PVOID *DllHandle
    )

/*++

Routine Description:

    This is the stub API entry which catches all the dynamic DLL loading events. This
    routine is responsible for catching all the dynamic loading DLLs (non-import bound)
    with the intent of fixing up of their entry points so that they are "shimed"

Arguments:

    DllPath            -  See LdrLoadDll for a description of the parameters
    DllCharacteristics -
    DllName            -
    DllHandle          -

Return Value:

    Return is STATUS_SUCCESS if no problem occured

--*/

{
    PAPP_COMPAT_SHIM_INFO pShimData = 0;
    PFNLDRLOADDLL pfnOldFunction = 0;
    DWORD dwHookCount = 0;
    PHOOKAPI *pHookArray = 0;
    NTSTATUS status;
    DWORD dwCounter = 0;
    PDWORD pdwHookArrayCount = 0;
    DWORD dwUnhookedCount = 0;
    PPEB Peb = 0;

    Peb = NtCurrentPeb();
    pShimData = (PAPP_COMPAT_SHIM_INFO)Peb->pShimData;

    pfnOldFunction = g_InternalHookArray[0].pfnOld;

    status = (*pfnOldFunction)(DllPath,
                               DllCharacteristics,
                               DllName,
                               DllHandle);

    //
    // See if there's anything to hook with this module
    //
    if ( STATUS_SUCCESS == status ){
       dwHookCount = pShimData->dwHookAPICount;
       pHookArray = pShimData->ppHookAPI;

       //
       // There may not be any functions to hook
       //
       if (0 == dwHookCount) {
          //
          // Just return status as we're not needing to look for functions loading dynamically
          //
          return status;
       }

       pdwHookArrayCount = (PDWORD)(*g_pfnRtlAllocateHeap)(g_pShimHeap,
                                                           HEAP_ZERO_MEMORY,
                                                           sizeof(DWORD) * pShimData->dwHookAPICount);
       if (!pdwHookArrayCount) {
          DPF(("[StubLdrLoadDll] Failure allocating pdwHookArrayCount.\n"));
          return status;
       }

       for (dwCounter = 0; dwCounter < dwHookCount; dwCounter++) {
           pdwHookArrayCount[dwCounter] = 1;
       }

       RtlEnterCriticalSection((CRITICAL_SECTION *)pShimData->pCritSec);

       SevFixupAvailableProcs(dwHookCount,
                                  pHookArray,
                                  pdwHookArrayCount,
                                  &dwUnhookedCount);

       RtlLeaveCriticalSection((CRITICAL_SECTION *)pShimData->pCritSec);

       //
       // Don't care about success/failure
       //
       (*g_pfnRtlFreeHeap)(g_pShimHeap,
                           0,
                           pdwHookArrayCount);
    }

    return status;
}

NTSTATUS
StubLdrUnloadDll (
    IN PVOID DllHandle
    )

/*++

Routine Description:

    This is the stub API entry which catches all the dynamic DLL unloading events. we
    are here to do simple bookkeeping on what dyanamic DLLs API hooks are valid.

Arguments:

    DllHandle          - Pointer to the base address of the unloading module

Return Value:

    Return is STATUS_SUCCESS if no problem occured

--*/

{
    PAPP_COMPAT_SHIM_INFO pShimData = 0;
    PFNLDRUNLOADDLL pfnOldFunction = 0;
    PHOOKAPIINFO pAPIHookList = 0;
    PHOOKAPIINFO pTempHook = 0;
    PHOOKAPI     pHookTemp = 0;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    PVOID ModuleHandle = 0;
    NTSTATUS status;
    NTSTATUS status2;
    PPEB Peb = 0;

    Peb = NtCurrentPeb();
    pShimData = (PAPP_COMPAT_SHIM_INFO)Peb->pShimData;

    pfnOldFunction = g_InternalHookArray[1].pfnOld;

    status = (*pfnOldFunction)(DllHandle);

    //
    // See if we lost any hooks during this unload event
    //
    if ( STATUS_SUCCESS == status ){
       //
       // Walk the dyanamic list and drop any hooks which no longer have loaded modules
       //
       pAPIHookList = pShimData->pHookAPIList;

       while (pAPIHookList) {
           //
           // Is the module this hook belongs to unmapped now?
           //
           RtlInitUnicodeString(&UnicodeString, pAPIHookList->wszModuleName);

           status = LdrGetDllHandle(
                        NULL,
                        NULL,
                        &UnicodeString,
                        &ModuleHandle);
           if (STATUS_SUCCESS != status) {
              //
              // Ok, hooks on this module needs to go away now
              //
              RtlEnterCriticalSection((CRITICAL_SECTION *)pShimData->pCritSec);

              //
              // Clear the chaining flags since this API chain is going away
              //
              pHookTemp = pAPIHookList->pTopLevelAPIChain;
              while (pHookTemp) {
                 pHookTemp->dwFlags &= HOOK_INDEX_MASK;
                 pHookTemp = pHookTemp->pNextHook;
              }

              //
              // Save off pAPIHookList hook entry since its going away here shortly
              //
              pTempHook = pAPIHookList;

              //
              // Delete the node from the list
              //
              if (pTempHook->pNextHook) {
                 pTempHook->pNextHook->pPrevHook = pTempHook->pPrevHook;
              }

              if (pTempHook->pPrevHook) {
                 pTempHook->pPrevHook->pNextHook = pTempHook->pNextHook;
              }
              else {
                 pShimData->pHookAPIList = (PVOID)pTempHook->pNextHook;
              }

              RtlLeaveCriticalSection((CRITICAL_SECTION *)pShimData->pCritSec);

              //
              // Set our next API hook pointer
              //
              pAPIHookList = pTempHook->pNextHook;

              //
              // If we allocated memory for a shim chain stub, free this memory
              //
              if (pTempHook->pTopLevelAPIChain->pNextHook == 0 &&
                  pTempHook->pTopLevelAPIChain->pszFunctionName == 0) {
                  (*g_pfnRtlFreeHeap)(g_pShimHeap,
                                      0,
                                      pTempHook->pTopLevelAPIChain);
              }

              //
              // Dump the thunk data and this struct allocation
              //
              (*g_pfnRtlFreeHeap)(g_pShimHeap,
                                  0,
                                  pTempHook->pCallThunkAddress);

              (*g_pfnRtlFreeHeap)(g_pShimHeap,
                                  0,
                                  pTempHook);

              //
              // Next API hook
              //
              continue;
          }

          pAPIHookList = pAPIHookList->pNextHook;
       }
    }

    return status;
}

PVOID
SevFilterCaller(
     PMODULEFILTER pFilterList,
     PVOID pFunctionAddress,
     PVOID pExceptionAddress,
     PVOID pStubAddress,
     PVOID pCallThunkAddress)

/*++

Routine Description:

    This is a stub routine called by the shim to validate whether or not to process a given
    hooked instance.

Arguments:
    pFilterList       - List of exceptions to be applied against the caller
    pFunctionAddress  - Address of the API/Function being filtered
    pExceptionAddress - Address of the exception to filter (caller address)
    pStubAddress      - Address of the top level stub function
    pCallThunkAddress - Address of the call thunk to the original function

Return Value:

    If the call is not filtered then pStubAddress is returned, otherwise pCallThunkAddress is returned to
    avoid the shim call.

--*/

{
    PAPP_COMPAT_SHIM_INFO pShimData = 0;

    pShimData = (PAPP_COMPAT_SHIM_INFO)NtCurrentPeb()->pShimData;

    //
    // If this is a call for LdrLoadDLL or LdrUnloadDLL then we need to not filter these out
    //
    if ( (DWORD)g_pfnOldLdrUnloadDLL == (DWORD)pFunctionAddress ||
        (DWORD)g_pfnOldLdrLoadDLL == (DWORD)pFunctionAddress) {
       return pStubAddress;
    }

    //
    // Walk the exe filter for any specific inclusions/exclusions
    //
    while(pFilterList) {
        //
        // See if this is a global filtering or just for one call
        //
        if (pFilterList->dwFlags & MODFILTER_GLOBAL) {
           //
           // Apply the filter logic based on flags
           //
           if (pFilterList->dwFlags & MODFILTER_INCLUDE) {
              return pStubAddress;
           }
           else {
              return pCallThunkAddress;
           }
        }
        else if (pFilterList->dwFlags & MODFILTER_DLL) {
           //
           // Global check the caller
           //
           if ((DWORD)pExceptionAddress >= pFilterList->dwModuleStart &&
               (DWORD)pExceptionAddress <= pFilterList->dwModuleEnd) {
              //
              // Apply the filter logic based on flags
              //
              if (pFilterList->dwFlags & MODFILTER_INCLUDE) {
                 return pStubAddress;
              }
              else {
                 return pCallThunkAddress;
              }
           }
        }
        else {
           //
           // Quick check the caller
           //
           if ((DWORD)pExceptionAddress == pFilterList->dwCallerAddress) {
              //
              // Apply the filter logic based on flags
              //
              if (pFilterList->dwFlags & MODFILTER_INCLUDE) {
                 return pStubAddress;
              }
              else {
                 return pCallThunkAddress;
              }
           }
        }

        pFilterList = pFilterList->pNextFilter;
    }

    //
    // Check the global filter for any specific inclusions/exclusions
    //
    pFilterList = (PMODULEFILTER)pShimData->pGlobalFilterList;

    while(pFilterList) {
        //
        // See if this is a global filtering or just for one call
        //
        if (pFilterList->dwFlags & MODFILTER_DLL) {
           //
           // Global check the caller
           //
           if ((DWORD)pExceptionAddress >= pFilterList->dwModuleStart &&
               (DWORD)pExceptionAddress <= pFilterList->dwModuleEnd) {
              //
              // Apply the filter logic based on flags
              //
              if (pFilterList->dwFlags & MODFILTER_INCLUDE) {
                 return pStubAddress;
              }
              else {
                 return pCallThunkAddress;
              }
           }
        }
        else {
           //
           // Quick check the caller
           //
           if ((DWORD)pExceptionAddress == pFilterList->dwCallerAddress) {
              //
              // Apply the filter logic based on flags
              //
              if (pFilterList->dwFlags & MODFILTER_INCLUDE) {
                 return pStubAddress;
              }
              else {
                 return pCallThunkAddress;
              }
           }
        }

        pFilterList = pFilterList->pNextFilter;
    }

    //
    // Call wasn't filtered - default to include any chain
    //
    return pStubAddress;
}

NTSTATUS
SevFinishThunkInjection (
     DWORD dwAddress,
     PVOID pThunk,
     DWORD dwThunkSize,
     BYTE jReason)

/*++

Routine Description:

    This routine takes a generated thunk and fixes up its page protections.  It also finishes the
    injection process by putting the thunk mechanism into the entrypoint of the hooked function.
    For patches this code path is the same since the same fixup are done for arbitrary data we
    want to patch dynamically.

Arguments:
     dwAddress          - Entrypoint of a function which is being hooked
     pThunk             - Address of the thunk generated for the function being hooked
     dwThunkSize        - Size of the thunk passed here to be finalized.
     jReason            - byte which is used to determine the filter exception type

Return Value:

    STATUS_SUCCESS is returned if everything happened as expected.

--*/

{
    DWORD dwProtectSize;
    DWORD dwProtectFuncAddress;
    DWORD dwOldFlags = 0;
    NTSTATUS status;

    //
    // Mark this code for execution
    //
    dwProtectSize = dwThunkSize;
    dwProtectFuncAddress = (DWORD)pThunk;

    status = NtProtectVirtualMemory(NtCurrentProcess(),
                                    (PVOID)&dwProtectFuncAddress,
                                    &dwProtectSize,
                                    PAGE_EXECUTE_READWRITE,
                                    &dwOldFlags);
    if (status) {
        DPF(("[SevFinishThunkInjection] Failure NtProtectVirtualMemory.\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Fixup the page attributes
    //
    dwProtectSize = CLI_OR_STI_SIZE;
    dwProtectFuncAddress = dwAddress;
    status = NtProtectVirtualMemory(NtCurrentProcess(),
                                    (PVOID)&dwProtectFuncAddress,
                                    &dwProtectSize,
                                    PAGE_EXECUTE_READWRITE,
                                    &dwOldFlags);
    if (status) {
        DPF(("[SevFinishThunkInjection] Failure NtProtectVirtualMemory.\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Insert the CALL
    //
    *((BYTE*)(dwAddress)) = jReason;

    //
    // Restore the page protection
    //
    dwProtectSize = CLI_OR_STI_SIZE;
    dwProtectFuncAddress = dwAddress;

    status = NtProtectVirtualMemory(NtCurrentProcess(),
                                    (PVOID)&dwProtectFuncAddress,
                                    &dwProtectSize,
                                    dwOldFlags,
                                    &dwOldFlags);
    if (status) {
        DPF(("[SevFinishThunkInjection] Failure NtProtectVirtualMemory.\n"));
        return STATUS_UNSUCCESSFUL;
    }

    status = NtFlushInstructionCache(NtCurrentProcess(),
                                     (PVOID)dwProtectFuncAddress,
                                     dwProtectSize);

    if (!NT_SUCCESS(status)) {
        DPF(("[SevFinishThunkInjection] NtFlushInstructionCache failed !!!.\n"));
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

void
SE_ProcessDying(
    void
    )
{
    return;
}

BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD     dwreason,
    LPVOID    reserved
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\external\emulateopengl_glstubs.cpp ===
#include "precomp.h"
#include <stdio.h>
#include "EmulateOpenGL_opengl32.hpp"

//////////////////////////////////////////// NOT USED by QuakeGL ///////////////////////////////////////////////////////

void APIENTRY glAccum (GLenum op, GLfloat value)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glAccum" ); 
	#endif //DODPFS
}
GLboolean APIENTRY glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences)
{ 
	GLboolean dummy = FALSE;

	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glAreTexturesResident" ); 
	#endif //DODPFS

	return dummy;
}
void APIENTRY glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glBitmap" ); 
	#endif //DODPFS
}
void APIENTRY glCallList (GLuint list)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glCallList" ); 
	#endif //DODPFS
}
void APIENTRY glCallLists (GLsizei n, GLenum type, const GLvoid *lists)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glCallLists" ); 
	#endif //DODPFS
}
void APIENTRY glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glClearAccum" ); 
	#endif //DODPFS
}
void APIENTRY glClearIndex (GLfloat c)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glClearIndex" ); 
	#endif //DODPFS
}
void APIENTRY glColor3b (GLbyte red, GLbyte green, GLbyte blue)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor3b" ); 
	#endif //DODPFS
}
void APIENTRY glColor3bv (const GLbyte *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor3bv" ); 
	#endif //DODPFS
}
void APIENTRY glColor3d (GLdouble red, GLdouble green, GLdouble blue)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor3d" ); 
	#endif //DODPFS
}
void APIENTRY glColor3dv (const GLdouble *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor3dv" ); 
	#endif //DODPFS
}
void APIENTRY glColor3i (GLint red, GLint green, GLint blue)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor3i" ); 
	#endif //DODPFS
}
void APIENTRY glColor3iv (const GLint *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor3iv" ); 
	#endif //DODPFS
}
void APIENTRY glColor3s (GLshort red, GLshort green, GLshort blue)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor3s" ); 
	#endif //DODPFS
}
void APIENTRY glColor3sv (const GLshort *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor3sv" ); 
	#endif //DODPFS
}
void APIENTRY glColor3ub (GLubyte red, GLubyte green, GLubyte blue)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor3ub" ); 
	#endif //DODPFS
}
void APIENTRY glColor3ui (GLuint red, GLuint green, GLuint blue)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor3ui" ); 
	#endif //DODPFS
}
void APIENTRY glColor3uiv (const GLuint *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor3uiv" ); 
	#endif //DODPFS
}
void APIENTRY glColor3us (GLushort red, GLushort green, GLushort blue)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor3us" ); 
	#endif //DODPFS
}
void APIENTRY glColor3usv (const GLushort *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor3usv" ); 
	#endif //DODPFS
}
void APIENTRY glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor4b" ); 
	#endif //DODPFS
}
void APIENTRY glColor4bv (const GLbyte *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor4bv" ); 
	#endif //DODPFS
}
void APIENTRY glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor4d" ); 
	#endif //DODPFS
}
void APIENTRY glColor4dv (const GLdouble *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor4dv" ); 
	#endif //DODPFS
}
void APIENTRY glColor4i (GLint red, GLint green, GLint blue, GLint alpha)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor4i" ); 
	#endif //DODPFS
}
void APIENTRY glColor4iv (const GLint *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor4iv" ); 
	#endif //DODPFS
}
void APIENTRY glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor4s" ); 
	#endif //DODPFS
}
void APIENTRY glColor4sv (const GLshort *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor4sv" ); 
	#endif //DODPFS
}
void APIENTRY glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor4ui" ); 
	#endif //DODPFS
}
void APIENTRY glColor4uiv (const GLuint *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor4uiv" ); 
	#endif //DODPFS
}
void APIENTRY glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor4us" ); 
	#endif //DODPFS
}
void APIENTRY glColor4usv (const GLushort *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColor4usv" ); 
	#endif //DODPFS
}
void APIENTRY glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glColorMask" ); 
	#endif //DODPFS
}
void APIENTRY glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glCopyPixels" ); 
	#endif //DODPFS
}
void APIENTRY glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glCopyTexImage1D" ); 
	#endif //DODPFS
}
void APIENTRY glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glCopyTexImage2D" ); 
	#endif //DODPFS
}
void APIENTRY glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glCopyTexSubImage1D" ); 
	#endif	//DODPFS
}
void APIENTRY glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glCopyTexSubImage2D" ); 
	#endif	//DODPFS
}
void APIENTRY glDeleteLists (GLuint list, GLsizei range)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glDeleteLists" ); 
	#endif //DODPFS
}
void APIENTRY glDrawArrays (GLenum mode, GLint first, GLsizei count)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glDrawArrays" ); 
	#endif //DODPFS
}
void APIENTRY glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glDrawPixels" ); 
	#endif //DODPFS
}
void APIENTRY glEdgeFlag (GLboolean flag)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glEdgeFlag" ); 
	#endif //DODPFS
}
void APIENTRY glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glEdgeFlagPointer" ); 
	#endif //DODPFS
}
void APIENTRY glEdgeFlagv (const GLboolean *flag)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glEdgeFlagv" ); 
	#endif //DODPFS
}
void APIENTRY glEndList (void)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glEndList" ); 
	#endif //DODPFS
}
void APIENTRY glEvalCoord1d (GLdouble u)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glEvalCoord1d" ); 
	#endif //DODPFS
}
void APIENTRY glEvalCoord1dv (const GLdouble *u)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glEvalCoord1dv" ); 
	#endif //DODPFS
}
void APIENTRY glEvalCoord1f (GLfloat u)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glEvalCoord1f" ); 
	#endif //DODPFS
}
void APIENTRY glEvalCoord1fv (const GLfloat *u)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glEvalCoord1fv" ); 
	#endif //DODPFS
}
void APIENTRY glEvalCoord2d (GLdouble u, GLdouble v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glEvalCoord2d" ); 
	#endif //DODPFS
}
void APIENTRY glEvalCoord2dv (const GLdouble *u)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glEvalCoord2dv" ); 
	#endif //DODPFS
}
void APIENTRY glEvalCoord2f (GLfloat u, GLfloat v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glEvalCoord2f" ); 
	#endif //DODPFS
}
void APIENTRY glEvalCoord2fv (const GLfloat *u)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glEvalCoord2fv" ); 
	#endif //DODPFS
}
void APIENTRY glEvalMesh1 (GLenum mode, GLint i1, GLint i2)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glEvalMesh1" ); 
	#endif //DODPFS
}
void APIENTRY glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glEvalMesh2" ); 
	#endif //DODPFS
}
void APIENTRY glEvalPoint1 (GLint i)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glEvalPoint1" ); 
	#endif //DODPFS
}
void APIENTRY glEvalPoint2 (GLint i, GLint j)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glEvalPoint2" ); 
	#endif //DODPFS
}
void APIENTRY glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glFeedbackBuffer" ); 
	#endif //DODPFS
}
void APIENTRY glFinish (void)
{
	#ifdef DODPFS 
	//DebugPrintf( eDbgLevelInfo, "glFinish()" ); 
	#endif //DODPFS
}
void APIENTRY glFlush (void)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glFlush" ); 
	#endif //DODPFS
}
void APIENTRY glFogfv (GLenum pname, const GLfloat *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glFogfv" ); 
	#endif //DODPFS
}
void APIENTRY glFogiv (GLenum pname, const GLint *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glFogiv" ); 
	#endif //DODPFS
}
GLuint APIENTRY glGenLists (GLsizei range)
{ 
	GLuint dummy = 0;
		#ifdef DODPFS 
		DebugPrintf( eDbgLevelInfo, "glGenLists" ); 
		#endif //DODPFS
	return dummy;
}
void APIENTRY glGetBooleanv (GLenum pname, GLboolean *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetBooleanv" ); 
	#endif //DODPFS
}
void APIENTRY glGetClipPlane (GLenum plane, GLdouble *equation)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetClipPlane" ); 
	#endif //DODPFS
}
void APIENTRY glGetDoublev (GLenum pname, GLdouble *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetDoublev" ); 
	#endif //DODPFS
}
void APIENTRY glGetLightfv (GLenum light, GLenum pname, GLfloat *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetLightfv" ); 
	#endif //DODPFS
}
void APIENTRY glGetLightiv (GLenum light, GLenum pname, GLint *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetLightiv" ); 
	#endif //DODPFS
}
void APIENTRY glGetMapdv (GLenum target, GLenum query, GLdouble *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetMapdv" ); 
	#endif //DODPFS
}
void APIENTRY glGetMapfv (GLenum target, GLenum query, GLfloat *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetMapfv" ); 
	#endif //DODPFS
}
void APIENTRY glGetMapiv (GLenum target, GLenum query, GLint *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetMapiv" ); 
	#endif //DODPFS
}
void APIENTRY glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetMaterialfv" ); 
	#endif //DODPFS
}
void APIENTRY glGetMaterialiv (GLenum face, GLenum pname, GLint *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetMaterialiv" ); 
	#endif //DODPFS
}
void APIENTRY glGetPixelMapfv (GLenum map, GLfloat *values)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetPixelMapfv" ); 
	#endif //DODPFS
}
void APIENTRY glGetPixelMapuiv (GLenum map, GLuint *values)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetPixelMapuiv" ); 
	#endif //DODPFS
}
void APIENTRY glGetPixelMapusv (GLenum map, GLushort *values)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetPixelMapusv" ); 
	#endif //DODPFS
}
void APIENTRY glGetPointerv (GLenum pname, GLvoid* *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetPointerv" ); 
	#endif //DODPFS
}
void APIENTRY glGetPolygonStipple (GLubyte *mask)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetPolygonStipple" ); 
	#endif //DODPFS
}
void APIENTRY glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetTexEnvfv" ); 
	#endif //DODPFS
}
void APIENTRY glGetTexEnviv (GLenum target, GLenum pname, GLint *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetTexEnviv" ); 
	#endif //DODPFS
}
void APIENTRY glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetTexGendv" ); 
	#endif //DODPFS
}
void APIENTRY glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetTexGenfv" ); 
	#endif //DODPFS
}
void APIENTRY glGetTexGeniv (GLenum coord, GLenum pname, GLint *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetTexGeniv" ); 
	#endif //DODPFS
}
void APIENTRY glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetTexImage" ); 
	#endif //DODPFS
}
void APIENTRY glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetTexLevelParameterfv" ); 
	#endif //DODPFS
}
void APIENTRY glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetTexLevelParameteriv" ); 
	#endif //DODPFS
}
void APIENTRY glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetTexParameterfv" ); 
	#endif //DODPFS
}
void APIENTRY glGetTexParameteriv (GLenum target, GLenum pname, GLint *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glGetTexParameteriv" ); 
	#endif //DODPFS
}
void APIENTRY glHint (GLenum target, GLenum mode)
{
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glHint (0x%X, 0x%X)", target, mode); 
	#endif //DODPFS
}
void APIENTRY glIndexMask (GLuint mask)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glIndexMask" ); 
	#endif //DODPFS
}
void APIENTRY glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glIndexPointer" ); 
	#endif //DODPFS
}
void APIENTRY glIndexd (GLdouble c)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glIndexd" ); 
	#endif //DODPFS
}
void APIENTRY glIndexdv (const GLdouble *c)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glIndexdv" ); 
	#endif //DODPFS
}
void APIENTRY glIndexf (GLfloat c)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glIndexf" ); 
	#endif //DODPFS
}
void APIENTRY glIndexfv (const GLfloat *c)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glIndexfv" ); 
	#endif //DODPFS
}
void APIENTRY glIndexi (GLint c)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glIndexi" ); 
	#endif //DODPFS
}
void APIENTRY glIndexiv (const GLint *c)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glIndexiv" ); 
	#endif //DODPFS
}
void APIENTRY glIndexs (GLshort c)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glIndexs" ); 
	#endif //DODPFS
}
void APIENTRY glIndexsv (const GLshort *c)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glIndexsv" ); 
	#endif //DODPFS
}
void APIENTRY glIndexub (GLubyte c)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glIndexub" ); 
	#endif //DODPFS
}
void APIENTRY glIndexubv (const GLubyte *c)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glIndexubv" ); 
	#endif //DODPFS
}
void APIENTRY glInitNames (void)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glInitNames" ); 
	#endif //DODPFS
}
void APIENTRY glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glInterleavedArrays" ); 
	#endif //DODPFS
}
GLboolean APIENTRY glIsEnabled (GLenum cap)
{ 
	GLboolean dummy = FALSE;
		#ifdef DODPFS 
		DebugPrintf( eDbgLevelInfo, "glIsEnabled" ); 
		#endif //DODPFS
	return dummy;
}
GLboolean APIENTRY glIsList (GLuint list)
{ 
	GLboolean dummy = FALSE;
		#ifdef DODPFS 
		DebugPrintf( eDbgLevelInfo, "glIsList" ); 
		#endif //DODPFS
	return dummy;
}
void APIENTRY glLightModelf (GLenum pname, GLfloat param)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glLightModelf" ); 
	#endif //DODPFS
}
void APIENTRY glLightModeliv (GLenum pname, const GLint *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glLightModeliv" ); 
	#endif //DODPFS
}
void APIENTRY glLighti (GLenum light, GLenum pname, GLint param)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glLighti" ); 
	#endif //DODPFS
}
void APIENTRY glLightiv (GLenum light, GLenum pname, const GLint *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glLightiv" ); 
	#endif //DODPFS
}
void APIENTRY glLineStipple (GLint factor, GLushort pattern)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glLineStipple" ); 
	#endif //DODPFS
}
void APIENTRY glListBase (GLuint base)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glListBase" ); 
	#endif //DODPFS
}
void APIENTRY glLoadMatrixd (const GLdouble *m)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glLoadMatrixd" ); 
	#endif //DODPFS
}
void APIENTRY glLoadName (GLuint name)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glLoadName" ); 
	#endif //DODPFS
}
void APIENTRY glLogicOp (GLenum opcode)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glLogicOp" ); 
	#endif //DODPFS
}
void APIENTRY glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glMap1d" ); 
	#endif //DODPFS
}
void APIENTRY glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glMap1f" ); 
	#endif //DODPFS
}
void APIENTRY glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glMap2d" ); 
	#endif //DODPFS
}
void APIENTRY glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glMap2f" ); 
	#endif //DODPFS
}
void APIENTRY glMapGrid1d (GLint un, GLdouble u1, GLdouble u2)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glMapGrid1d" ); 
	#endif //DODPFS
}
void APIENTRY glMapGrid1f (GLint un, GLfloat u1, GLfloat u2)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glMapGrid1f" ); 
	#endif //DODPFS
}
void APIENTRY glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glMapGrid2d" ); 
	#endif //DODPFS
}
void APIENTRY glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glMapGrid2f" ); 
	#endif //DODPFS
}
void APIENTRY glMateriali (GLenum face, GLenum pname, GLint param)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glMateriali" ); 
	#endif //DODPFS
}
void APIENTRY glMaterialiv (GLenum face, GLenum pname, const GLint *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glMaterialiv" ); 
	#endif //DODPFS
}
void APIENTRY glNewList (GLuint list, GLenum mode)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glNewList" ); 
	#endif //DODPFS
}
void APIENTRY glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glNormal3b" ); 
	#endif //DODPFS
}
void APIENTRY glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glNormal3d" ); 
	#endif //DODPFS
}
void APIENTRY glNormal3dv (const GLdouble *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glNormal3dv" ); 
	#endif //DODPFS
}
void APIENTRY glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glNormal3f" ); 
	#endif //DODPFS
}
void APIENTRY glNormal3i (GLint nx, GLint ny, GLint nz)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glNormal3i" ); 
	#endif //DODPFS
}
void APIENTRY glNormal3iv (const GLint *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glNormal3iv" ); 
	#endif //DODPFS
}
void APIENTRY glNormal3s (GLshort nx, GLshort ny, GLshort nz)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glNormal3s" ); 
	#endif //DODPFS
}
void APIENTRY glNormal3sv (const GLshort *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glNormal3sv" ); 
	#endif //DODPFS
}
void APIENTRY glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glNormalPointer" ); 
	#endif //DODPFS
}
void APIENTRY glPassThrough (GLfloat token)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glPassThrough" ); 
	#endif //DODPFS
}
void APIENTRY glPixelMapfv (GLenum map, GLsizei mapsize, const GLfloat *values)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glPixelMapfv" ); 
	#endif //DODPFS
}
void APIENTRY glPixelMapuiv (GLenum map, GLsizei mapsize, const GLuint *values)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glPixelMapuiv" ); 
	#endif //DODPFS
}
void APIENTRY glPixelMapusv (GLenum map, GLsizei mapsize, const GLushort *values)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glPixelMapusv" ); 
	#endif //DODPFS
}
void APIENTRY glPixelStoref (GLenum pname, GLfloat param)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glPixelStoref" ); 
	#endif //DODPFS
}
void APIENTRY glPixelStorei (GLenum pname, GLint param)
{ 
}
void APIENTRY glPixelTransferf (GLenum pname, GLfloat param)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glPixelTransferf" ); 
	#endif //DODPFS
}
void APIENTRY glPixelTransferi (GLenum pname, GLint param)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glPixelTransferi" ); 
	#endif //DODPFS
}
void APIENTRY glPixelZoom (GLfloat xfactor, GLfloat yfactor)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glPixelZoom" ); 
	#endif //DODPFS
}
void APIENTRY glPointSize (GLfloat size)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glPointSize" ); 
	#endif //DODPFS
}
void APIENTRY glPolygonStipple (const GLubyte *mask)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glPolygonStipple" ); 
	#endif //DODPFS
}
void APIENTRY glPopClientAttrib (void)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glPopClientAttrib" ); 
	#endif //DODPFS
}
void APIENTRY glPopName (void)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glPopName" ); 
	#endif //DODPFS
}
void APIENTRY glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glPrioritizeTextures" ); 
	#endif //DODPFS
}
void APIENTRY glPushClientAttrib (GLbitfield mask)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glPushClientAttrib" ); 
	#endif //DODPFS
}
void APIENTRY glPushName (GLuint name)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glPushName" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos2d (GLdouble x, GLdouble y)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos2d" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos2dv (const GLdouble *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos2dv" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos2f (GLfloat x, GLfloat y)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos2f" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos2fv (const GLfloat *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos2fv" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos2i (GLint x, GLint y)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos2i" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos2iv (const GLint *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos2iv" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos2s (GLshort x, GLshort y)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos2s" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos2sv (const GLshort *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos2sv" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos3d (GLdouble x, GLdouble y, GLdouble z)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos3d" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos3dv (const GLdouble *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos3dv" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos3f (GLfloat x, GLfloat y, GLfloat z)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos3f" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos3fv (const GLfloat *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos3fv" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos3i (GLint x, GLint y, GLint z)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos3i" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos3iv (const GLint *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos3iv" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos3s (GLshort x, GLshort y, GLshort z)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos3s" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos3sv (const GLshort *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos3sv" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos4d" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos4dv (const GLdouble *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos4dv" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos4f" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos4fv (const GLfloat *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos4fv" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos4i (GLint x, GLint y, GLint z, GLint w)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos4i" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos4iv (const GLint *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos4iv" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos4s" ); 
	#endif //DODPFS
}
void APIENTRY glRasterPos4sv (const GLshort *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRasterPos4sv" ); 
	#endif //DODPFS
}
void APIENTRY glReadBuffer (GLenum mode)
{
	#ifdef DODPFS 
	//DebugPrintf( eDbgLevelInfo, "glReadBuffer(%X)",mode); 
	DebugPrintf( eDbgLevelInfo, "glReadBuffer" ); 
	#endif //DODPFS
}
void APIENTRY glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
{
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glReadPixels (x:%d y:%d width:%d height:%d format:0x%x type:0x%x pixels:0x%x", x, y, width, height, format, type, pixels ); 
	#endif //DODPFS
}
void APIENTRY glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRectd" ); 
	#endif //DODPFS
}
void APIENTRY glRectdv (const GLdouble *v1, const GLdouble *v2)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRectdv" ); 
	#endif //DODPFS
}
void APIENTRY glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRectf" ); 
	#endif //DODPFS
}
void APIENTRY glRectfv (const GLfloat *v1, const GLfloat *v2)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRectfv" ); 
	#endif //DODPFS
}
void APIENTRY glRecti (GLint x1, GLint y1, GLint x2, GLint y2)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRecti" ); 
	#endif //DODPFS
}
void APIENTRY glRectiv (const GLint *v1, const GLint *v2)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRectiv" ); 
	#endif //DODPFS
}
void APIENTRY glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRects" ); 
	#endif //DODPFS
}
void APIENTRY glRectsv (const GLshort *v1, const GLshort *v2)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRectsv" ); 
	#endif //DODPFS
}
GLint APIENTRY glRenderMode (GLenum mode)
{ 

	GLint dummy = 0;

		#ifdef DODPFS 
		DebugPrintf( eDbgLevelInfo, "glRenderMode" ); 
		#endif //DODPFS

	return dummy;
}
void APIENTRY glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glRotated" ); 
	#endif //DODPFS
}
void APIENTRY glScaled (GLdouble x, GLdouble y, GLdouble z)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glScaled" ); 
	#endif //DODPFS
}
void APIENTRY glSelectBuffer (GLsizei size, GLuint *buffer)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glSelectBuffer" ); 
	#endif //DODPFS
}
void APIENTRY glStencilFunc (GLenum func, GLint ref, GLuint mask)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glStencilFunc" ); 
	#endif //DODPFS
}
void APIENTRY glStencilMask (GLuint mask)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glStencilMask" ); 
	#endif //DODPFS
}
void APIENTRY glStencilOp (GLenum fail, GLenum zfail, GLenum zpass)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glStencilOp" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord1d (GLdouble s)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord1d" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord1dv (const GLdouble *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord1dv" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord1f (GLfloat s)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord1f" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord1fv (const GLfloat *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord1fv" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord1i (GLint s)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord1i" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord1iv (const GLint *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord1iv" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord1s (GLshort s)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord1s" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord1sv (const GLshort *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord1sv" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord2d (GLdouble s, GLdouble t)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord2d" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord2dv (const GLdouble *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord2dv" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord2i (GLint s, GLint t)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord2i" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord2iv (const GLint *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord2iv" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord2s (GLshort s, GLshort t)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord2s" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord2sv (const GLshort *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord2sv" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord3d (GLdouble s, GLdouble t, GLdouble r)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord3d" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord3dv (const GLdouble *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord3dv" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord3f (GLfloat s, GLfloat t, GLfloat r)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord3f" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord3fv (const GLfloat *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord3fv" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord3i (GLint s, GLint t, GLint r)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord3i" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord3iv (const GLint *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord3iv" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord3s (GLshort s, GLshort t, GLshort r)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord3s" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord3sv (const GLshort *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord3sv" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord4d" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord4dv (const GLdouble *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord4dv" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord4f" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord4fv (const GLfloat *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord4fv" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord4i (GLint s, GLint t, GLint r, GLint q)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord4i" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord4iv (const GLint *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord4iv" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord4s" ); 
	#endif //DODPFS
}
void APIENTRY glTexCoord4sv (const GLshort *v)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexCoord4sv" ); 
	#endif //DODPFS
}
void APIENTRY glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexEnvfv" ); 
	#endif //DODPFS
}
void APIENTRY glTexEnviv (GLenum target, GLenum pname, const GLint *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexEnviv" ); 
	#endif //DODPFS
}
void APIENTRY glTexGend (GLenum coord, GLenum pname, GLdouble param)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexGend" ); 
	#endif //DODPFS
}
void APIENTRY glTexGendv (GLenum coord, GLenum pname, const GLdouble *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexGendv" ); 
	#endif //DODPFS
}
void APIENTRY glTexGenf (GLenum coord, GLenum pname, GLfloat param)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexGenf" ); 
	#endif //DODPFS
}
void APIENTRY glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexGenfv" ); 
	#endif //DODPFS
}
void APIENTRY glTexGeniv (GLenum coord, GLenum pname, const GLint *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexGeniv" ); 
	#endif //DODPFS
}
void APIENTRY glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexImage1D" ); 
	#endif //DODPFS
}
void APIENTRY glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexParameterfv" ); 
	#endif //DODPFS
}
void APIENTRY glTexParameteriv (GLenum target, GLenum pname, const GLint *params)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexParameteriv" ); 
	#endif //DODPFS
}
void APIENTRY glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTexSubImage1D" ); 
	#endif //DODPFS
}
void APIENTRY glTranslated (GLdouble x, GLdouble y, GLdouble z)
{ 
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "glTranslated" ); 
	#endif //DODPFS
}
BOOL WINAPI wglCopyContext()
{
	BOOL dummy = FALSE;
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "wglCopyContext" ); 
	#endif //DODPFS
	return dummy;
}
BOOL WINAPI wglCreateLayerContext()
{
	BOOL dummy = FALSE;
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "wglCreateLayerContext" ); 
	#endif //DODPFS
	return dummy;
}
BOOL WINAPI wglDescribeLayerPlane()
{
	BOOL dummy = FALSE;
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "wglDescribeLayerPlane" ); 
	#endif //DODPFS
	return dummy;
}
BOOL WINAPI wglGetDefaultProcAddress()
{
	BOOL dummy = FALSE;
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "wglGetDefaultProcAddress" ); 
	#endif //DODPFS
	return dummy;
}
BOOL WINAPI wglGetLayerPaletteEntries()
{
	BOOL dummy = FALSE;
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "wglGetLayerPaletteEntries" ); 
	#endif //DODPFS
	return dummy;
}
BOOL WINAPI wglRealizeLayerPalette()
{
	BOOL dummy = FALSE;
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "wglRealizeLayerPalette" ); 
	#endif //DODPFS
	return dummy;
}
BOOL WINAPI wglSetLayerPaletteEntries()
{
	BOOL dummy = FALSE;
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "wglSetLayerPaletteEntries" ); 
	#endif //DODPFS
	return dummy;
}
BOOL WINAPI wglShareLists()
{
	BOOL dummy = FALSE;
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "wglShareLists" ); 
	#endif //DODPFS
	return dummy;
}
BOOL WINAPI wglSwapLayerBuffers()
{
	BOOL dummy = FALSE;
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "wglSwapLayerBuffers" ); 
	#endif //DODPFS
	return dummy;
}
BOOL WINAPI wglUseFontBitmapsA()
{
	BOOL dummy = FALSE;
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "wglUseFontBitmapsA" ); 
	#endif //DODPFS
	return dummy;
}
BOOL WINAPI wglUseFontBitmapsW()
{
	BOOL dummy = FALSE;
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "wglUseFontBitmapsW" ); 
	#endif //DODPFS
	return dummy;
}
BOOL WINAPI wglUseFontOutlinesA()
{
	BOOL dummy = FALSE;
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "wglUseFontOutlinesA" ); 
	#endif //DODPFS
	return dummy;
}
BOOL WINAPI wglUseFontOutlinesW()
{
	BOOL dummy = FALSE;
	#ifdef DODPFS 
	DebugPrintf( eDbgLevelInfo, "wglUseFontOutlinesW" ); 
	#endif //DODPFS
	return dummy;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\external\emulateopengl.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateOpenGL.cpp

 Abstract:

    

 Notes:

    This is a general purpose shim for Quake engine based games.

 History:

    09/02/2000 linstev  Created
    11/30/2000 a-brienw Converted to shim version 2.
    03/02/2001 a-brienw Cleared data structure on allocation and checked
                        to see that DX was released on detach

--*/

#include "precomp.h"
#include "EmulateOpenGL_opengl32.hpp"

extern Globals *g_OpenGLValues;
extern BOOL g_bDoTexelAlignmentHack;

IMPLEMENT_SHIM_BEGIN(EmulateOpenGL)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadLibraryA)
    APIHOOK_ENUM_ENTRY(FreeLibrary)
APIHOOK_ENUM_END

/*++

 Parse the command line.

--*/

BOOL ParseCommandLine(const char * commandLine)
{
    // Force the default values
    g_bDoTexelAlignmentHack = FALSE;

    // Search the beginning of the command line for these switches
    //
    // Switch                   Default     Meaning
    //================          =======     =========================================================
    // TexelAlignment           No          Translate geometry by (-0.5 pixels in x, -0.5 pixels in y)
    //                                      along the screen/viewport plane.  This is achieved by
    //                                      fudging the projection matrix that is passed to D3D.
    //                                      The purpose of this hack is to allow D3D rendering to accomodate  
    //                                      content that was authored for OpenGL with the dependency that 
    //                                      sampled texels end up pixel-aligned when drawn.  The root of the
    //                                      problem is that D3D and OpenGL definitions of texel center 
    //                                      differ by 0.5.
    //                                      The "ideal" fix would have perturbed texture coordinates 
    //                                      rather than geometry, perhaps using texture transform, 
    //                                      but this would be more of a perf. issue than just mucking with 
    //                                      the projection matrix.  The drawback to mucking with the 
    //                                      projection matrix is that all geometry gets
    //                                      drawn (very slightly) offset from the intended locations on screen.
    //                                      Hence, we make this hack optional. 
    //                                      (it is currently needed by Kingpin: Life of Crime - Whistler bug 402471)
    //                                      
    //

    CSTRING_TRY
    {
        CString csCl(commandLine);
        CStringParser csParser(csCl, L";");
    
        int argc = csParser.GetCount();
        if (csParser.GetCount() == 0)
        {
            return TRUE; // Not an error
        }
    
        for (int i = 0; i < argc; ++i)
        {
            CString & csArg = csParser[i];
    
            DPFN( eDbgLevelSpew, "Argv[%d] == (%S)", i, csArg.Get());
        
            if (csArg.CompareNoCase(L"TexelAlignment") == 0)
            {
                g_bDoTexelAlignmentHack = TRUE;
            }
            // else if(csArg.CompareNoCase(L"AddYourNewParametersHere") == 0) {}
        }
    }
    CSTRING_CATCH
    {
        return FALSE;
    }

    return TRUE;
}

/*++

 Determine if there are any accelerated pixel formats available. This is done
 by enumerating the pixel formats and testing for acceleration.

--*/

BOOL
IsGLAccelerated()
{
    HMODULE hMod = NULL;
    HDC hdc = NULL;
    int i;
    PIXELFORMATDESCRIPTOR pfd;
    _pfn_wglDescribePixelFormat pfnDescribePixelFormat;

    //
    // Cache the last result if we've been here before
    //
    
    static iFormat = -1;

    if (iFormat != -1)
    {
        goto Exit;
    }
    
    //
    // Load original opengl
    //

    hMod = LoadLibraryA("opengl32");
    if (!hMod)
    {
        LOG("EmulateOpenGL", eDbgLevelError, "Failed to load OpenGL32");
        goto Exit;
    }

    //
    // Get wglDescribePixelFormat so we can enumerate pixel formats
    //
    
    pfnDescribePixelFormat = (_pfn_wglDescribePixelFormat) GetProcAddress(
        hMod, "wglDescribePixelFormat");
    if (!pfnDescribePixelFormat)
    {
        LOG("EmulateOpenGL", eDbgLevelError, "API wglDescribePixelFormat not found in OpenGL32");
        goto Exit;
    }

    //
    // Get a Display DC for enumeration
    //
    
    hdc = GetDC(NULL);
    if (!hdc)
    {
        LOG("EmulateOpenGL", eDbgLevelError, "GetDC(NULL) Failed");
        goto Exit;
    }

    //
    // Run the list of pixel formats looking for any that are non-generic,
    //   i.e. accelerated by an ICD
    //
    
    i = 1;
    iFormat = 0;
    while ((*pfnDescribePixelFormat)(hdc, i, sizeof(PIXELFORMATDESCRIPTOR), &pfd))
    {
        if ((pfd.dwFlags & PFD_DRAW_TO_WINDOW) &&
            (pfd.dwFlags & PFD_SUPPORT_OPENGL) &&
            (!(pfd.dwFlags & PFD_GENERIC_FORMAT)))
        {
            iFormat = i;
            break;
        }

        i++;
    }

Exit:
    if (hdc)
    {
        ReleaseDC(NULL, hdc);
    }

    if (hMod)
    {
        FreeLibrary(hMod);
    }

    return (iFormat > 0);
}

/*++
 
 Redirect OpenGL LoadLibrary to the current DLL. Note we don't have to call 
 LoadLibrary ourselves to increase the ref count, since we hook FreeLibrary to 
 make sure we don't get freed.

--*/

HINSTANCE
APIHOOK(LoadLibraryA)(LPCSTR lpLibFileName)
{
    if (lpLibFileName &&
        (stristr(lpLibFileName, "opengl32") || stristr(lpLibFileName, "glide2x")))
    {
        if (!IsGLAccelerated())
        {
            #ifdef DODPFS
                LOG( "EmulateOpenGL",
                    eDbgLevelInfo,
                    "No OpenGL acceleration detected: QuakeGL wrapper enabled" );
            #endif
            return g_hinstDll;
        }
        else
        {
            #ifdef DODPFS
                LOG( "EmulateOpenGL",
                    eDbgLevelInfo,
                    "OpenGL acceleration detected: Wrapper disabled" );
            #endif
        }
    }

    return ORIGINAL_API(LoadLibraryA)(lpLibFileName);
}

/*++

 Since this module is the quake wrapper, make sure we don't free ourselves.

--*/

BOOL
APIHOOK(FreeLibrary)(HMODULE hLibModule)
{
    BOOL bRet;

    if (hLibModule == g_hinstDll)
    {
        bRet = TRUE;
    }
    else
    {
        bRet = ORIGINAL_API(FreeLibrary)(hLibModule);
    }
    
    return bRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(DWORD fdwReason)
{
    BOOL bSuccess = TRUE;

    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        g_OpenGLValues = new Globals;
        if (g_OpenGLValues != NULL)
        {
            memset(g_OpenGLValues, 0, sizeof(Globals));
        }

        bSuccess &= ParseCommandLine(COMMAND_LINE);
    }
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        if (g_OpenGLValues != NULL)
        {
            if (g_OpenGLValues->m_d3ddev != NULL)
            {
                g_OpenGLValues->m_d3ddev->Release();
                g_OpenGLValues->m_d3ddev = 0;
            }
        }
    }

    bSuccess &= (g_OpenGLValues != NULL);

    return bSuccess;
}

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryA)
    APIHOOK_ENTRY(KERNEL32.DLL, FreeLibrary)

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\external\emulateopengl_opengl32.cpp ===
#include "precomp.h"

#pragma warning(disable : 4273)
#define D3D_OVERLOADS

#include <math.h>
#include <stdio.h>
#include "EmulateOpenGL_opengl32.hpp"

#define HOOK_WINDOW_PROC                  0
#define GETPARMSFORDEBUG                  0
#define DODPFS                            0

void APIENTRY glEnd (void);
void APIENTRY glBegin (GLenum mode);
BOOL APIENTRY wglSwapIntervalEXT(GLint interval);

#define PI 3.1415926535897932384626433832795

Globals * g_OpenGLValues = NULL;

// The BOOL below comes from the shim command line.  It can't be part of the Globals struct above
// because wglCreateContext memsets g_OpenGLValues to 0, but this is after the shim command line
// has been processed. 
BOOL      g_bDoTexelAlignmentHack = FALSE;

#if GETPARMSFORDEBUG || DODPFS
// converts doubles to ascii for debug output. it only shows 6 place precision.
void ftoa( double d, char *buf )
{
    long l, i, j;
    char *s, *n;

    if( d < 0.0 )
    {
        d = -d;
        n = "-";
    }
    else
    {
        n = "";
    }
    
    i = (long)d;
    j = (long)((d - (double)i) * 100000);

    if( j < 10 )
        s = "00000";

    else if( j < 100 )
        s = "0000";

    else if( j < 1000 )
        s = "000";

    else if( j < 10000 )
        s = "00";

    else if( j < 100000 )
        s = "0";
    
    else s = "";

    sprintf( buf, "%s%d.%s%d", n, i, s, j );
}
#endif

inline void VertexBufferFilled()
{
    if(g_OpenGLValues->m_nfv + g_OpenGLValues->m_vcnt >= (VBUFSIZE - MAXVERTSPERPRIM))
    {
        if(g_OpenGLValues->m_prim == GL_TRIANGLES)
        {
            if(g_OpenGLValues->m_vcnt % 3 == 0)
            {
                glEnd();
                glBegin(GL_TRIANGLES);
            }
        }
        else if(g_OpenGLValues->m_prim == GL_QUADS)
        {
            if(g_OpenGLValues->m_vcnt % 4 == 0)
            {
                glEnd();
                glBegin(GL_QUADS);
            }
        }
        else if(g_OpenGLValues->m_prim == GL_LINES)
        {
            if(g_OpenGLValues->m_vcnt % 2 == 0)
            {
                glEnd();
                glBegin(GL_LINES);
            }
        }
    }
}

inline void QuakeSetVertexShader(DWORD vs)
{
    if(g_OpenGLValues->m_curshader != vs)
    {
        g_OpenGLValues->m_d3ddev->SetVertexShader(vs);
        g_OpenGLValues->m_curshader = vs;
    }
}

inline void QuakeSetStreamSource(DWORD i, IDirect3DVertexBuffer8 *pBuf, DWORD stride)
{
    if(g_OpenGLValues->m_pStreams[i] != pBuf || g_OpenGLValues->m_pStrides[i] != stride)
    {
        g_OpenGLValues->m_d3ddev->SetStreamSource(i, pBuf, stride);
        g_OpenGLValues->m_pStreams[i] = pBuf;
        g_OpenGLValues->m_pStrides[i] = stride;
    }
}

inline void MultiplyMatrix(D3DTRANSFORMSTATETYPE xfrm, const D3DMATRIX &min)
{
    D3DMATRIX &mout = g_OpenGLValues->m_xfrm[xfrm];
    for(unsigned i = 0; i < 4; ++i)
    {
        float a = mout.m[0][i];
        float b = mout.m[1][i];
        float c = mout.m[2][i];
        float d = mout.m[3][i];
        for(unsigned j = 0; j < 4; ++j)
        {
            mout.m[j][i] = min.m[j][0] * a + min.m[j][1] * b + min.m[j][2] * c + min.m[j][3] * d;
        }
    }
}

inline void MEMCPY(VOID *dst, const VOID *src, DWORD sz)
{
#ifdef _X86_
    if((sz & 0x3) == 0)
    {
        _asm
        {
            mov ecx, sz;
            mov esi, src;
            mov edi, dst;
            cld;            
            shr ecx, 2;
lp1:        movsd;
            dec ecx;
            jnz lp1;
        }
    }
    else
#endif
    {
        memcpy(dst, src, sz);
    }
}

inline void Clamp(float *v)
{
    if(*v < 0.f)
    {
        *v = 0.f;
    }
    else if(*v > 1.f)
    {
        *v = 1.f;
    }
}

inline void Clamp(double *v)
{
    if(*v < 0.)
    {
        *v = 0.;
    }
    else if(*v > 1.)
    {
        *v = 1.;
    }
}

void QuakeSetTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *m)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "QuakeSetTransform: 0x%X 0x%X", State, m );
#endif
    static D3DMATRIX unity = {1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f};
    if(State == D3DTS_PROJECTION)
    {
        D3DMATRIX f = *m;
        f._13 = (m->_13 + m->_14) * 0.5f;
        f._23 = (m->_23 + m->_24) * 0.5f;
        f._33 = (m->_33 + m->_34) * 0.5f;
        f._43 = (m->_43 + m->_44) * 0.5f;
        if(g_OpenGLValues->m_scissoring) 
        {
            FLOAT dvClipX, dvClipY, dvClipWidth, dvClipHeight;
            RECT scirect, vwprect, xrect;
            scirect.left   = g_OpenGLValues->m_scix;
            scirect.top    = g_OpenGLValues->m_sciy;
            scirect.right  = g_OpenGLValues->m_scix + g_OpenGLValues->m_sciw;
            scirect.bottom = g_OpenGLValues->m_sciy + g_OpenGLValues->m_scih;
            vwprect.left   = g_OpenGLValues->m_vwx;
            vwprect.top    = g_OpenGLValues->m_vwy;
            vwprect.right  = g_OpenGLValues->m_vwx + g_OpenGLValues->m_vww;
            vwprect.bottom = g_OpenGLValues->m_vwy + g_OpenGLValues->m_vwh;
            if(IntersectRect(&xrect, &scirect, &vwprect))
            {
                if(EqualRect(&xrect, &vwprect)) // Check whether viewport is completely within scissor rect
                {
                    dvClipX = -1.f;
                    dvClipY = 1.f;
                    dvClipWidth = 2.f;
                    dvClipHeight = 2.f;
                }
                else
                {
                    // We need to use xrect rather than scirect (ie clip scissor rect to viewport)
                    // and transform the clipped scissor rect into viewport relative coordinates
                    // to correctly compute the clip stuff
                    GLint scix = xrect.left - g_OpenGLValues->m_vwx;
                    GLint sciy = xrect.top - g_OpenGLValues->m_vwy;
                    GLsizei sciw = xrect.right - xrect.left;
                    GLsizei scih = xrect.bottom - xrect.top;
                    dvClipX = (2.f * scix) / g_OpenGLValues->m_vww - 1.0f;
                    dvClipY = (2.f * (sciy + scih)) / g_OpenGLValues->m_vwh - 1.0f;
                    dvClipWidth = (2.f * sciw) / g_OpenGLValues->m_vww;
                    dvClipHeight = (2.f * scih) / g_OpenGLValues->m_vwh;
                }
            }
            else
            {
#if DODPFS
                OutputDebugStringA("Wrapper: non-intersecting scissor and viewport rects not implemented\n" );
#endif
                return;
            }
            D3DMATRIX c;

            // to prevent divide by zero from possibly happening (check bug #259251 in Whistler database)
            if(dvClipWidth == 0.f)
                dvClipWidth = 1.f;

            if(dvClipHeight == 0.f)
                dvClipHeight = 1.f;

            c._11 = 2.f / dvClipWidth;
            c._21 = 0.f;
            c._31 = 0.f;
            c._41 = -1.f - 2.f * (dvClipX / dvClipWidth);
            c._12 = 0.f;
            c._22 = 2.f / dvClipHeight;
            c._32 = 0.f;
            c._42 = 1.f - 2.f * (dvClipY / dvClipHeight);
            c._13 = 0.f;
            c._23 = 0.f;
            c._33 = 1.f;
            c._43 = 0.f;
            c._14 = 0.f;
            c._24 = 0.f;
            c._34 = 0.f;
            c._44 = 1.f;
            D3DMATRIX t = g_OpenGLValues->m_xfrm[D3DTS_PROJECTION];
            g_OpenGLValues->m_xfrm[D3DTS_PROJECTION] = c;

#if GETPARMSFORDEBUG
            char buf1[40], buf2[40], buf3[40], buf4[40];
            ftoa( dvClipX, buf1 );
            ftoa( dvClipY, buf2 );
            ftoa( dvClipWidth, buf3 );
            ftoa( dvClipHeight, buf4 );

            LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "QuakeSetTransform: DVCLIP: %s %s %s %s SCIRECT: %d %d %d %d VWPRECT: %d %d %d %d XRECT: %d %d %d %d", buf1, buf2, buf3, buf4, scirect.left, scirect.top, scirect.right, scirect.bottom, vwprect.left, vwprect.top, vwprect.right, vwprect.bottom, xrect.left, xrect.top, xrect.right, xrect.bottom );
#endif
            MultiplyMatrix(D3DTS_PROJECTION, f);
            f = g_OpenGLValues->m_xfrm[D3DTS_PROJECTION];
            g_OpenGLValues->m_xfrm[D3DTS_PROJECTION] = t;
        }

        if( g_bDoTexelAlignmentHack )
        {
            // Translate all geometry by (-0.5 pixels in x, -0.5 pixels in y) along the screen/viewport plane.
            // This helps force texels that were authored to be sampled pixel-aligned on OpenGL to be pixel-aligned on D3D.
            float x = g_OpenGLValues->m_vport.Width ? (-1.f / g_OpenGLValues->m_vport.Width) : 0.0f;
            float y = g_OpenGLValues->m_vport.Height ? (1.0f / g_OpenGLValues->m_vport.Height) : 0.0f;
            f._11 = f._11 + f._14*x;
            f._12 = f._12 + f._14*y;
            f._21 = f._21 + f._24*x;
            f._22 = f._22 + f._24*y;
            f._31 = f._31 + f._34*x;
            f._32 = f._32 + f._34*y;
            f._41 = f._41 + f._44*x;
            f._42 = f._42 + f._44*y;
        }

        g_OpenGLValues->m_d3ddev->SetTransform(State, &f);
    }
    else if(State == D3DTS_TEXTURE0 || State == D3DTS_TEXTURE1)
    {
        D3DMATRIX f;
        f._11 = m->_11;
        f._12 = m->_12;
        f._13 = m->_14;
        f._14 = 0.f;
        f._21 = m->_21;
        f._22 = m->_22;
        f._23 = m->_24;
        f._24 = 0.f;
        f._31 = m->_41;
        f._32 = m->_42;
        f._33 = m->_44;
        f._34 = 0.f;
        f._41 = 0.f;
        f._42 = 0.f;
        f._43 = 0.f;
        f._44 = 0.f;
        g_OpenGLValues->m_d3ddev->SetTransform(State, &f);
        if(memcmp(&unity, m, sizeof(D3DMATRIX)) != 0)
        {
            g_OpenGLValues->m_d3ddev->SetTextureStageState((DWORD)(State - D3DTS_TEXTURE0), D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT3 | D3DTTFF_PROJECTED);
        }
        else
        {
            g_OpenGLValues->m_d3ddev->SetTextureStageState((DWORD)(State - D3DTS_TEXTURE0), D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);
        }
    }
    else
    {
        g_OpenGLValues->m_d3ddev->SetTransform(State, m);
    }
}

void QuakeUpdateViewport()
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "QuakeUpdateViewport" );
#endif
    if(g_OpenGLValues->m_scissoring) 
    {
        RECT scirect, vwprect, xrect;
        scirect.left   = g_OpenGLValues->m_scix;
        scirect.top    = g_OpenGLValues->m_sciy;
        scirect.right  = g_OpenGLValues->m_scix + g_OpenGLValues->m_sciw;
        scirect.bottom = g_OpenGLValues->m_sciy + g_OpenGLValues->m_scih;
        vwprect.left   = g_OpenGLValues->m_vwx;
        vwprect.top    = g_OpenGLValues->m_vwy;
        vwprect.right  = g_OpenGLValues->m_vwx + g_OpenGLValues->m_vww;
        vwprect.bottom = g_OpenGLValues->m_vwy + g_OpenGLValues->m_vwh;
        if(IntersectRect(&xrect, &scirect, &vwprect))
        {
            if(EqualRect(&xrect, &vwprect)) // Check whether viewport is completely within scissor rect
            {
                g_OpenGLValues->m_vport.X = g_OpenGLValues->m_vwx;
                g_OpenGLValues->m_vport.Y = g_OpenGLValues->m_winHeight - (g_OpenGLValues->m_vwy + g_OpenGLValues->m_vwh);
                g_OpenGLValues->m_vport.Width = g_OpenGLValues->m_vww;
                g_OpenGLValues->m_vport.Height = g_OpenGLValues->m_vwh;
                QuakeSetTransform(D3DTS_PROJECTION, &g_OpenGLValues->m_xfrm[D3DTS_PROJECTION]);
            }
            else
            {
                // We need to use xrect rather than scirect (ie clip scissor rect to viewport)
                g_OpenGLValues->m_vport.X = xrect.left;
                g_OpenGLValues->m_vport.Y = g_OpenGLValues->m_winHeight - xrect.bottom;
                g_OpenGLValues->m_vport.Width = xrect.right - xrect.left;
                g_OpenGLValues->m_vport.Height = xrect.bottom - xrect.top;
                QuakeSetTransform(D3DTS_PROJECTION, &g_OpenGLValues->m_xfrm[D3DTS_PROJECTION]);
            }
        }
        else
        {
#if DODPFS
            OutputDebugStringA("Wrapper: non-intersecting scissor and viewport rects not implemented\n");
#endif
            return;
        }        
    }
    else
    {
        g_OpenGLValues->m_vport.X = g_OpenGLValues->m_vwx;
        g_OpenGLValues->m_vport.Y = g_OpenGLValues->m_winHeight - (g_OpenGLValues->m_vwy + g_OpenGLValues->m_vwh);
        g_OpenGLValues->m_vport.Width = g_OpenGLValues->m_vww;
        g_OpenGLValues->m_vport.Height = g_OpenGLValues->m_vwh;
    }
    if(g_OpenGLValues->m_polyoffset && g_OpenGLValues->m_vport.MaxZ != 0.f)
    {
        D3DVIEWPORT8 vport(g_OpenGLValues->m_vport);
        vport.MaxZ -= .001f;

#if GETPARMSFORDEBUG
        char buf1[40], buf2[40];
        
        ftoa( vport.MinZ, buf1 );
        ftoa( vport.MaxZ, buf2 );
        LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "QuakeUpdateViewport: vport=%d %d %d %d %s %s", vport.X, vport.Y, vport.Width, vport.Height, buf1, buf2 );
#endif        
        g_OpenGLValues->m_d3ddev->SetViewport(&vport);
    }
    else
    {
#if GETPARMSFORDEBUG
        char buf1[40], buf2[40];
        ftoa( g_OpenGLValues->m_vport.MinZ, buf1 );
        ftoa( g_OpenGLValues->m_vport.MaxZ, buf2 );
        LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "QuakeUpdateViewport g_OpenGLValues->m_vport=%d %d %d %d %s %s", g_OpenGLValues->m_vport.X, g_OpenGLValues->m_vport.Y, g_OpenGLValues->m_vport.Width, g_OpenGLValues->m_vport.Height, buf1, buf2 );
#endif
        g_OpenGLValues->m_d3ddev->SetViewport(&g_OpenGLValues->m_vport);
    }
    g_OpenGLValues->m_updvwp = FALSE;
}

void QuakeUpdateLights()
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "QuakeUpdateLights" );
#endif
    for(unsigned i = 0; i < 8; ++i)
    {
        if(g_OpenGLValues->m_lightdirty & (1 << i))
        {
            D3DLIGHT8 light = g_OpenGLValues->m_light[i];
            if(g_OpenGLValues->m_lightPositionW[i] == 0.f)
            {
                if(light.Phi == 180.f)
                {
                    light.Type = D3DLIGHT_DIRECTIONAL;
                }
                else
                {
                    light.Type = D3DLIGHT_SPOT;
                    light.Attenuation0 = 1.f;
                    light.Attenuation1 = 0.f;
                    light.Attenuation2 = 0.f;
                }
            }
            else
            {
                if(light.Phi == 180.f)
                {
                    light.Type = D3DLIGHT_POINT;
                }
                else
                {
                    light.Type = D3DLIGHT_SPOT;
                }
            }
            light.Phi *= float(PI / 90.);
            g_OpenGLValues->m_d3ddev->SetLight(i, &light);
        }
    }
    g_OpenGLValues->m_lightdirty = 0;
}

void QuakeSetTexturingState()
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "QuakeSetTexturingState" );
#endif
    if(g_OpenGLValues->m_lightdirty != 0)
        QuakeUpdateLights();
    if(g_OpenGLValues->m_updvwp)
        QuakeUpdateViewport();
    if(g_OpenGLValues->m_texturing == TRUE) {
        if(g_OpenGLValues->m_texHandleValid == FALSE) {
            TexInfo &ti = g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[0]];
            if(ti.m_dwStage != 0)
            {
                g_OpenGLValues->m_d3ddev->DeleteStateBlock(ti.m_block);
                g_OpenGLValues->m_d3ddev->BeginStateBlock();
                g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ADDRESSU,ti.m_addu);
                g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ADDRESSV,ti.m_addv);
                g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_MAGFILTER,ti.m_magmode);
                g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_MINFILTER,ti.m_minmode);
                g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_MIPFILTER,ti.m_mipmode);
                g_OpenGLValues->m_d3ddev->SetTexture(0, ti.m_ddsurf);
                g_OpenGLValues->m_d3ddev->EndStateBlock(&ti.m_block);
                ti.m_dwStage = 0;
                ti.m_capture = FALSE;
            }
            if(ti.m_capture)
            {
                g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ADDRESSU,ti.m_addu);
                g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ADDRESSV,ti.m_addv);
                g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_MAGFILTER,ti.m_magmode);
                g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_MINFILTER,ti.m_minmode);
                g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_MIPFILTER,ti.m_mipmode);
                g_OpenGLValues->m_d3ddev->SetTexture(0, ti.m_ddsurf);
                g_OpenGLValues->m_d3ddev->CaptureStateBlock(ti.m_block);
                ti.m_capture = FALSE;
            }
            else
            {
                g_OpenGLValues->m_d3ddev->ApplyStateBlock(ti.m_block);
            }
            switch(g_OpenGLValues->m_blendmode[0]) {
            case GL_REPLACE:
                switch(ti.m_internalformat) {
                case 1:
                case GL_LUMINANCE:
                case GL_LUMINANCE8:
                case 3:
                case GL_RGB:
                case GL_RGB5:
                case GL_RGB8:
                    g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[0][0]);
                    break;
                case 4:
                case GL_RGBA:
                case GL_RGBA4:
                case GL_RGBA8:
                    g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[0][1]);
                    break;
                case GL_ALPHA:
                case GL_ALPHA8:
                    g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[0][8]);
                    break;
                }
                break;
            case GL_MODULATE:
                switch(ti.m_internalformat) {
                case 1:
                case GL_LUMINANCE:
                case GL_LUMINANCE8:
                case 3:
                case GL_RGB:
                case GL_RGB5:
                case GL_RGB8:
                    g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[0][2]);
                    break;
                case 4:
                case GL_RGBA:
                case GL_RGBA4:
                case GL_RGBA8:
                    g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[0][3]);
                    break;
                case GL_ALPHA:
                case GL_ALPHA8:
                    g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[0][9]);
                    break;
                }
                break;
            case GL_DECAL:
                switch(ti.m_internalformat) {
                case 3:
                case GL_RGB:
                case GL_RGB5:
                case GL_RGB8:
                    g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[0][4]);
                    break;
                case 4:
                case GL_RGBA:
                case GL_RGBA4:
                case GL_RGBA8:
                    g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[0][5]);
                    break;
                }
                break;
            case GL_BLEND:
                switch(ti.m_internalformat) {
                case 1:
                case GL_LUMINANCE:
                case GL_LUMINANCE8:
                case 3:
                case GL_RGB:
                case GL_RGB5:
                case GL_RGB8:
                    g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[0][6]);
                    break;
                case 4:
                case GL_RGBA:
                case GL_RGBA4:
                case GL_RGBA8:
                    g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[0][7]);
                    break;
                case GL_ALPHA:
                case GL_ALPHA8:
                    g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[0][9]);
                    break;
                }
                break;
            }
            
            if(g_OpenGLValues->m_mtex != FALSE) {
                TexInfo &ti2 = g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[1]];
                if(ti2.m_dwStage != 1)
                {
                    g_OpenGLValues->m_d3ddev->DeleteStateBlock(ti2.m_block);
                    g_OpenGLValues->m_d3ddev->BeginStateBlock();
                    g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ADDRESSU,ti2.m_addu);
                    g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ADDRESSV,ti2.m_addv);
                    g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_MAGFILTER,ti2.m_magmode);
                    g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_MINFILTER,ti2.m_minmode);
                    g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_MIPFILTER,ti2.m_mipmode);
                    g_OpenGLValues->m_d3ddev->SetTexture(1, ti2.m_ddsurf);
                    g_OpenGLValues->m_d3ddev->EndStateBlock(&ti2.m_block);
                    ti2.m_dwStage = 1;
                    ti2.m_capture = FALSE;
                }
                if(ti2.m_capture)
                {
                    g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ADDRESSU,ti2.m_addu);
                    g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ADDRESSV,ti2.m_addv);
                    g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_MAGFILTER,ti2.m_magmode);
                    g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_MINFILTER,ti2.m_minmode);
                    g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_MIPFILTER,ti2.m_mipmode);
                    g_OpenGLValues->m_d3ddev->SetTexture(1, ti2.m_ddsurf);
                    g_OpenGLValues->m_d3ddev->CaptureStateBlock(ti2.m_block);
                    ti2.m_capture = FALSE;
                }
                else
                {
                   g_OpenGLValues->m_d3ddev->ApplyStateBlock(ti2.m_block);
                }
                switch(g_OpenGLValues->m_blendmode[1]) {
                case GL_REPLACE:
                    switch(ti2.m_internalformat) {
                    case 1:
                    case GL_LUMINANCE:
                    case GL_LUMINANCE8:
                    case 3:
                    case GL_RGB:
                    case GL_RGB5:
                    case GL_RGB8:
                        g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[1][0]);
                        break;
                    case 4:
                    case GL_RGBA:
                    case GL_RGBA4:
                    case GL_RGBA8:
                        g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[1][1]);
                        break;
                    case GL_ALPHA:
                    case GL_ALPHA8:
                        g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[1][8]);
                        break;
                    }
                    break;
                case GL_MODULATE:
                    switch(ti2.m_internalformat) {
                    case 1:
                    case GL_LUMINANCE:
                    case GL_LUMINANCE8:
                    case 3:
                    case GL_RGB:
                    case GL_RGB5:
                    case GL_RGB8:
                        g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[1][2]);
                        break;
                    case 4:
                    case GL_RGBA:
                    case GL_RGBA4:
                    case GL_RGBA8:
                        g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[1][3]);
                        break;
                    case GL_ALPHA:
                    case GL_ALPHA8:
                        g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[1][9]);
                        break;
                    }
                    break;
                case GL_DECAL:
                    switch(ti2.m_internalformat) {
                    case 3:
                    case GL_RGB:
                    case GL_RGB5:
                    case GL_RGB8:
                        g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[1][4]);
                        break;
                    case 4:
                    case GL_RGBA:
                    case GL_RGBA4:
                    case GL_RGBA8:
                        g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[1][5]);
                        break;
                    }
                    break;
                case GL_BLEND:
                    switch(ti2.m_internalformat) {
                    case 1:
                    case GL_LUMINANCE:
                    case GL_LUMINANCE8:
                    case 3:
                    case GL_RGB:
                    case GL_RGB5:
                    case GL_RGB8:
                        g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[1][6]);
                        break;
                    case 4:
                    case GL_RGBA:
                    case GL_RGBA4:
                    case GL_RGBA8:
                        g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[1][7]);
                        break;
                    case GL_ALPHA:
                    case GL_ALPHA8:
                        g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_shaders[1][9]);
                        break;
                    }
                    break;
                }
            }
            g_OpenGLValues->m_texHandleValid = TRUE;
        }
    }
}

void RawToCanon(DWORD dwFormat, DWORD dwInternalFormat, DWORD dwWidth, DWORD dwHeight, const void *lpPixels, DWORD *lpdwCanon)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "RawToCanon: 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X", dwFormat, dwInternalFormat, dwWidth, dwHeight, lpPixels, lpdwCanon );
#endif
    if(dwFormat == GL_RGBA)
    {
        switch(dwInternalFormat) {
        case 1:
        case GL_LUMINANCE:
        case GL_LUMINANCE8:
        case 3:
        case 4:
        case GL_RGB:
        case GL_RGBA:
        case GL_RGB5:
        case GL_RGB8:
        case GL_RGBA4:
        case GL_RGBA8:
        case GL_ALPHA:
        case GL_ALPHA8:
            MEMCPY(lpdwCanon, lpPixels, dwWidth * dwHeight * sizeof(DWORD));
            break;
#if DODPFS
        default:
            char junk[256];
            sprintf( junk, "Wrapper: (RawToCanon:GL_RGBA) InternalFormat not implemented (dwInternalFormat:0x%X)\n", dwInternalFormat );
            OutputDebugStringA( junk );
#endif
        }
    }
    else if(dwFormat == GL_RGB)
    {
        switch(dwInternalFormat) {
        case 1:
        case GL_LUMINANCE:
        case GL_LUMINANCE8:
        case 3:
        case 4:
        case GL_RGB:
        case GL_RGBA:
        case GL_RGB5:
        case GL_RGB8:
        case GL_RGBA4:
        case GL_RGBA8:
            {
                int i, j = dwWidth * dwHeight;
                unsigned char *pixels = (unsigned char*)lpPixels;
                for(i = 0; i < j; ++i) {
                    lpdwCanon[i] = (unsigned(pixels[2]) << 16) | (unsigned(pixels[1]) << 8) | unsigned(pixels[0]);
                    pixels += 3;
                }
            }
            break;
#if DODPFS
        default:
            char junk[256];
            sprintf( junk, "Wrapper: (RawToCanon:GL_RGB) InternalFormat not implemented (dwInternalFormat:0x%X)\n", dwInternalFormat );
            OutputDebugStringA( junk );
#endif
        }
    }
    else if(dwFormat == GL_LUMINANCE)
    {
        switch(dwInternalFormat) {
        case 1:
        case GL_LUMINANCE:
        case GL_LUMINANCE8:
            {
                int i, j = dwWidth * dwHeight;
                for(i = 0; i < j; ++i) {
                    DWORD t = ((UCHAR*)lpPixels)[i];
                    lpdwCanon[i] = (t << 24) | (t << 16) | (t << 8) | t;
                }
            }
            break;
#if DODPFS
        default:
            char junk[256];
            sprintf( junk, "Wrapper: (RawToCanon:GL_LUMINANCE) InternalFormat not implemented (dwInternalFormat:0x%X)\n", dwInternalFormat );
            OutputDebugStringA( junk );
#endif
        }
    }
    else if(dwFormat == GL_ALPHA || dwFormat == GL_ALPHA8)
    {
        switch(dwInternalFormat) {
        case GL_ALPHA:
        case GL_ALPHA8:
            {
                int i, j = dwWidth * dwHeight;
                for(i = 0; i < j; ++i) {
                    DWORD t = ((UCHAR*)lpPixels)[i];
                    lpdwCanon[i] = (t << 24) | (t << 16) | (t << 8) | t;
                }
            }
            break;
#if DODPFS
        default:
            char junk[256];
            sprintf( junk, "Wrapper: (RawToCanon:GL_ALPHA) InternalFormat not implemented (dwInternalFormat:0x%X)\n", dwInternalFormat );
            OutputDebugStringA( junk );
#endif
        }
    }
#if DODPFS
    else
    {
        char junk[256];
        sprintf( junk, "Wrapper: Format not implemented (dwFormat:0x%X dwInternalFormat:0x%X)\n", dwFormat, dwInternalFormat );
        OutputDebugStringA( junk );
    }
#endif
}

void Resize(DWORD dwWidth, DWORD dwHeight, const DWORD *lpdwCanon,
            DWORD dwNewWidth, DWORD dwNewHeight, DWORD *lpdwNewCanon)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "Resize: 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X", dwWidth, dwHeight, lpdwCanon, dwNewWidth, dwNewHeight, lpdwNewCanon );
#endif
    DWORD i, j;
    double rx = (double)dwWidth / (double)dwNewWidth;
    double ry = (double)dwHeight / (double)dwNewHeight;
    for(i = 0; i < dwNewHeight; ++i)
        for(j = 0; j < dwNewWidth; ++j)
            lpdwNewCanon[i * dwNewWidth + j] = lpdwCanon[((DWORD)(i * ry)) * dwWidth + (DWORD)(j * rx)];
}

void CanonTo565(LPRECT lprect, const DWORD *lpdwCanon, D3DLOCKED_RECT* lpddsd)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "CanonTo565: 0x%X 0x%X 0x%X", lprect, lpdwCanon, lpddsd );
#endif
    LONG i, j, k, l;
    USHORT *lpPixels = (USHORT*)lpddsd->pBits;
    for(k = lprect->top, i = 0; k < lprect->bottom; ++k, lpPixels = (USHORT*)((UCHAR*)lpPixels + lpddsd->Pitch) ) 
    {
        for (j = lprect->left, l = 0; j < lprect->right; ++j, ++i, ++l)
        {
            lpPixels[l] = (USHORT)(((lpdwCanon[i] & 0xF8) << 8) | ((lpdwCanon[i] & 0xFC00) >> 5) | ((lpdwCanon[i] & 0xF80000) >> 19));
        }
    }
}

void CanonTo555(LPRECT lprect, const DWORD *lpdwCanon, D3DLOCKED_RECT* lpddsd)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "CanonTo555: 0x%X 0x%X 0x%X", lprect, lpdwCanon, lpddsd );
#endif
    LONG i, j, k, l;
    USHORT *lpPixels = (USHORT*)lpddsd->pBits;
    for(k = lprect->top, i = 0; k < lprect->bottom; ++k, lpPixels = (USHORT*)((UCHAR*)lpPixels + lpddsd->Pitch) ) 
    {
        for (j = lprect->left, l = 0; j < lprect->right; ++j, ++i, ++l)
        {
            lpPixels[l] = (USHORT)(((lpdwCanon[i] & 0xF8) << 7) | ((lpdwCanon[i] & 0xF800) >> 6) | ((lpdwCanon[i] & 0xF80000) >> 19));
        }
    }
}

void CanonTo4444(LPRECT lprect, const DWORD *lpdwCanon, D3DLOCKED_RECT* lpddsd)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "CanonTo4444: 0x%X 0x%X 0x%X", lprect, lpdwCanon, lpddsd );
#endif
    LONG i, j, k, l;
    USHORT *lpPixels = (USHORT*)lpddsd->pBits;
    for(k = lprect->top, i = 0; k < lprect->bottom; ++k, lpPixels = (USHORT*)((UCHAR*)lpPixels + lpddsd->Pitch) ) 
    {
        for (j = lprect->left, l = 0; j < lprect->right; ++j, ++i, ++l)
        {
            lpPixels[l] = (USHORT)(((lpdwCanon[i] & 0xF0) << 4) | ((lpdwCanon[i] & 0xF000) >> 8) | ((lpdwCanon[i] & 0xF00000) >> 20) | ((lpdwCanon[i] & 0xF0000000) >> 16));
        }
    }
}

void CanonTo8888(LPRECT lprect, const DWORD *lpdwCanon, D3DLOCKED_RECT* lpddsd)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "CanonTo8888: 0x%X 0x%X 0x%X", lprect, lpdwCanon, lpddsd );
#endif
    LONG i, j, k, l;
    DWORD *lpPixels = (DWORD*)lpddsd->pBits;
    for(k = lprect->top, i = 0; k < lprect->bottom; ++k, lpPixels = (DWORD*)((UCHAR*)lpPixels + lpddsd->Pitch) ) 
    {
        for (j = lprect->left, l = 0; j < lprect->right; ++j, ++i, ++l)
        {
            lpPixels[l] = ((lpdwCanon[i] & 0xFF00FF00) | ((lpdwCanon[i] & 0xFF) << 16) | ((lpdwCanon[i] & 0xFF0000) >> 16));
        }
    }
}

void CanonTo8(LPRECT lprect, const DWORD *lpdwCanon, D3DLOCKED_RECT* lpddsd)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "CanonTo8: 0x%X 0x%X 0x%X", lprect, lpdwCanon, lpddsd );
#endif
    LONG i, j, k, l;
    UCHAR *lpPixels = (UCHAR*)lpddsd->pBits;
    for(k = lprect->top, i = 0; k < lprect->bottom; ++k, lpPixels = (UCHAR*)lpPixels + lpddsd->Pitch ) 
    {
        for (j = lprect->left, l = 0; j < lprect->right; ++j, ++i, ++l)
        {
            lpPixels[l] = (UCHAR)(lpdwCanon[i] >> 24);
        }
    }
}

void LoadSurface(LPDIRECT3DSURFACE8 lpDDS, DWORD dwFormat, DWORD dwInternalFormat,
                 DWORD dwWidth, DWORD dwHeight, DWORD dwNewWidth, DWORD dwNewHeight,
                 const void *pixels)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "LoadSurface: 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X", lpDDS, dwFormat, dwInternalFormat, dwWidth, dwHeight, dwNewWidth, dwNewHeight, pixels );
#endif
    D3DLOCKED_RECT ddsd;
    HRESULT ddrval;
    DWORD *lpdwCanon, *lpdwNewCanon;	
    RECT rect;
    /*
     * Convert the GL texture into a canonical format (8888),
     * so that we can cleanly do image ops (such as resize) without 
     * having to worry about the bit format.
     */
    lpdwCanon = (DWORD*)malloc(dwWidth * dwHeight * sizeof(DWORD));

    if(lpdwCanon != NULL)
    {
        RawToCanon(dwFormat, dwInternalFormat, dwWidth, dwHeight, pixels, lpdwCanon);
        /* Now resize the canon image */
        if(dwWidth != dwNewWidth || dwHeight != dwNewHeight) {
            lpdwNewCanon = (DWORD*)malloc(dwNewWidth * dwNewHeight * sizeof(DWORD));

            if(lpdwNewCanon != NULL)
            {
                Resize(dwWidth, dwHeight, lpdwCanon, dwNewWidth, dwNewHeight, lpdwNewCanon);
                free(lpdwCanon);
            }
            else
            {
                lpdwNewCanon = lpdwCanon;
            }
        }
        else
            lpdwNewCanon = lpdwCanon;
        /*
         * Lock the surface so it can be filled with the texture
         */
        ddrval = lpDDS->LockRect(&ddsd, NULL, D3DLOCK_NOSYSLOCK);
        if (FAILED(ddrval)) {
#if DODPFS
            char junk[256];
            sprintf( junk, "Lock failed while loading surface (0x%X)\n", ddrval );
            OutputDebugStringA( junk );
#endif
            free(lpdwNewCanon);
            return;
        }
        D3DSURFACE_DESC sd;
        lpDDS->GetDesc(&sd);
        SetRect(&rect, 0, 0, sd.Width, sd.Height);
        /* Copy  the texture into the surface */
        if(sd.Format == D3DFMT_L8) {
            CanonTo8(&rect, lpdwNewCanon, &ddsd);
        }
        else if(sd.Format == D3DFMT_A8) {
            CanonTo8(&rect, lpdwNewCanon, &ddsd);
        }
        else if(sd.Format == D3DFMT_A4R4G4B4) {
            CanonTo4444(&rect, lpdwNewCanon, &ddsd);
        }
        else if(sd.Format == D3DFMT_R5G6B5) {
            CanonTo565(&rect, lpdwNewCanon, &ddsd);
        }
        else if(sd.Format == D3DFMT_X1R5G5B5) {
            CanonTo555(&rect, lpdwNewCanon, &ddsd);
        }
        else {
            CanonTo8888(&rect, lpdwNewCanon, &ddsd);
        }
        free(lpdwNewCanon);
        /*
         * unlock the surface
         */
        lpDDS->UnlockRect();
    }
    return;
}

HRESULT LoadSubSurface(LPDIRECT3DSURFACE8 lpDDS, DWORD dwFormat,
                       DWORD dwInternalFormat, DWORD dwWidth, DWORD dwHeight,
                       const void *pixels, LPRECT lpsubimage)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "LoadSubSurface: 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X", lpDDS, dwFormat, dwInternalFormat, dwWidth, dwHeight, pixels, lpsubimage );
#endif
    D3DLOCKED_RECT ddsd;
    HRESULT ddrval;
    DWORD *lpdwCanon, *lpdwNewCanon;	
    DWORD dwNewWidth=lpsubimage->right-lpsubimage->left;
    DWORD dwNewHeight=lpsubimage->bottom-lpsubimage->top;
    /*
    * Lock the surface so it can be filled with the texture
    */
    ddrval = lpDDS->LockRect(&ddsd, lpsubimage, D3DLOCK_NOSYSLOCK);
    if (FAILED(ddrval)) {
#if DODPFS
        char junk[256];
        sprintf( junk, "Lock failed while loading surface (0x%X)\n", ddrval );
        OutputDebugStringA( junk );
#endif
        return ddrval;
    }
    D3DSURFACE_DESC sd;
    lpDDS->GetDesc(&sd);
    if((dwInternalFormat == 3 || dwInternalFormat == GL_RGB || dwInternalFormat == GL_RGB5) && sd.Format == D3DFMT_R5G6B5 && 
        dwWidth == dwNewWidth && dwHeight == dwNewHeight) {
        CanonTo565(lpsubimage,(const unsigned long*)pixels,&ddsd);
    }
    else if((dwInternalFormat == 3 || dwInternalFormat == GL_RGB || dwInternalFormat == GL_RGB5) && sd.Format == D3DFMT_X1R5G5B5 && 
        dwWidth == dwNewWidth && dwHeight == dwNewHeight) {
        CanonTo555(lpsubimage,(const unsigned long*)pixels,&ddsd);
    }
    else if((dwInternalFormat == GL_RGB8 || dwInternalFormat == GL_RGBA || dwInternalFormat == GL_RGBA8) && (sd.Format == D3DFMT_X8R8G8B8 || sd.Format == D3DFMT_A8R8G8B8) && 
        dwWidth == dwNewWidth && dwHeight == dwNewHeight) {
        CanonTo8888(lpsubimage,(const unsigned long*)pixels,&ddsd);
    }
    else {
        /*
         * Convert the GL texture into a canonical format (8888),
         * so that we can cleanly do image ops (such as resize) without 
         * having to worry about the bit format.
         */
        lpdwCanon = (DWORD*)malloc(dwWidth * dwHeight * sizeof(DWORD));
        
        if(lpdwCanon != NULL)
        {
            RawToCanon(dwFormat, dwInternalFormat, dwWidth, dwHeight, pixels, lpdwCanon);
            if(dwWidth != dwNewWidth || dwHeight != dwNewHeight)
            {
                /* Now resize the canon image */
                lpdwNewCanon = (DWORD*)malloc(dwNewWidth * dwNewHeight * sizeof(DWORD));

                if(lpdwNewCanon != NULL)
                {
                    Resize(dwWidth, dwHeight, lpdwCanon, dwNewWidth, dwNewHeight, lpdwNewCanon);
                    free(lpdwCanon);
                }
                else
                {
                    lpdwNewCanon=lpdwCanon;
                }
            }
            else
            {
                lpdwNewCanon=lpdwCanon;
            }
            /* Copy  the texture into the surface */
            if(sd.Format == D3DFMT_L8) {
                CanonTo8(lpsubimage,lpdwNewCanon,&ddsd);
            }
            else if(sd.Format == D3DFMT_A8) {
                CanonTo8(lpsubimage,lpdwNewCanon,&ddsd);
            }
            else if(sd.Format == D3DFMT_A4R4G4B4) {
                CanonTo4444(lpsubimage,lpdwNewCanon,&ddsd);
            }
            else if(sd.Format == D3DFMT_R5G6B5) {
                CanonTo565(lpsubimage,lpdwNewCanon,&ddsd);
            }
            else if(sd.Format == D3DFMT_X1R5G5B5) {
                CanonTo555(lpsubimage, lpdwNewCanon, &ddsd);
            }
            else {
                CanonTo8888(lpsubimage, lpdwNewCanon, &ddsd);
            }
            free(lpdwNewCanon);
        }
    }
    /*
     * unlock the surface
     */
    lpDDS->UnlockRect();
    return S_OK;
}

HRESULT GrowVB(DWORD sz)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "GrowVB: 0x%X", sz );
#endif
    if(sz > g_OpenGLValues->m_vbufsz)
    {
        HRESULT hr;
        if(g_OpenGLValues->m_xyzbuf != 0)
        {
            g_OpenGLValues->m_xyzbuf->Release();
        }
        hr = g_OpenGLValues->m_d3ddev->CreateVertexBuffer(sz * 12, D3DUSAGE_WRITEONLY | D3DUSAGE_DYNAMIC, 0, D3DPOOL_DEFAULT, &g_OpenGLValues->m_xyzbuf);
        if( FAILED(hr) )
        {
#if DODPFS
            char junk[256];
            sprintf( junk, "Wrapper: GrowVB: CreateVertexBuffer(1) failed (0x%X)\n", hr );
            OutputDebugStringA( junk );
#endif
            return hr;
        }
        if(g_OpenGLValues->m_colbuf != 0)
        {
            g_OpenGLValues->m_colbuf->Release();
        }
        hr = g_OpenGLValues->m_d3ddev->CreateVertexBuffer(sz * 4, D3DUSAGE_WRITEONLY | D3DUSAGE_DYNAMIC, 0, D3DPOOL_DEFAULT, &g_OpenGLValues->m_colbuf);
        if( FAILED(hr) )
        {
#if DODPFS
            char junk[256];
            sprintf( junk, "Wrapper: GrowVB: CreateVertexBuffer(2) failed (0x%X)\n", hr );
            OutputDebugStringA( junk );
#endif
            return hr;
        }
        if(g_OpenGLValues->m_texbuf != 0)
        {
            g_OpenGLValues->m_texbuf->Release();
        }
        hr = g_OpenGLValues->m_d3ddev->CreateVertexBuffer(sz * 8, D3DUSAGE_WRITEONLY | D3DUSAGE_DYNAMIC, 0, D3DPOOL_DEFAULT, &g_OpenGLValues->m_texbuf);
        if( FAILED(hr) )
        {
#if DODPFS
            char junk[256];
            sprintf( junk, "Wrapper: GrowVB: CreateVertexBuffer(3) failed (0x%X)\n", hr );
            OutputDebugStringA( junk );
#endif
            return hr;
        }
        if(g_OpenGLValues->m_tex2buf != 0)
        {
            g_OpenGLValues->m_tex2buf->Release();
        }
        hr = g_OpenGLValues->m_d3ddev->CreateVertexBuffer(sz * 8, D3DUSAGE_WRITEONLY | D3DUSAGE_DYNAMIC, 0, D3DPOOL_DEFAULT, &g_OpenGLValues->m_tex2buf);
        if( FAILED(hr) )
        {
#if DODPFS
            char junk[256];
            sprintf( junk, "Wrapper: GrowVB: CreateVertexBuffer(4) failed (0x%X)\n", hr );
            OutputDebugStringA( junk );
#endif
            return hr;
        }
        g_OpenGLValues->m_vbufoff = 0;
        g_OpenGLValues->m_vbufsz = sz;
    }
    return S_OK;
}

HRESULT GrowIB(DWORD sz)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "GrowIB: 0x%X", sz );
#endif
    if(sz > g_OpenGLValues->m_ibufsz)
    {
        if(g_OpenGLValues->m_ibuf != 0)
        {
            g_OpenGLValues->m_ibuf->Release();
        }
        HRESULT hr = g_OpenGLValues->m_d3ddev->CreateIndexBuffer(sz * 2, D3DUSAGE_WRITEONLY | D3DUSAGE_DYNAMIC, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &g_OpenGLValues->m_ibuf);
        if( FAILED(hr) )
        {
#if DODPFS
            char junk[256];
            sprintf( junk, "Wrapper: GrowIB: CreateIndexBuffer failed (0x%X)\n", hr );
            OutputDebugStringA( junk );
#endif
            return hr;
        }
        g_OpenGLValues->m_d3ddev->SetIndices(g_OpenGLValues->m_ibuf, 0);
        g_OpenGLValues->m_ibufoff = 0;
        g_OpenGLValues->m_ibufsz = sz;        
    }
    return S_OK;
}

///////////////////////////// BEGIN API ENTRIES ///////////////////////////////////////////////////

void APIENTRY glActiveTextureARB(GLenum texture)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glActiveTextureARB: 0x%X", texture );
#endif
    g_OpenGLValues->m_curtgt = texture == GL_TEXTURE0_ARB ? 0 : 1;
}

void APIENTRY glAlphaFunc (GLenum func, GLclampf ref)
{
#if GETPARMSFORDEBUG
    char log[256];
    char l[40];
    ftoa( (double)ref, l );
    sprintf( log, "glAlphaFunc: 0x%X %s", func, l );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    DWORD funcvalue;
    switch(func) {
    case GL_NEVER:
        funcvalue=D3DCMP_NEVER;
        break;
    case GL_LESS: 
        funcvalue=D3DCMP_LESS;
        break;
    case GL_EQUAL: 
        funcvalue=D3DCMP_EQUAL;
        break;
    case GL_LEQUAL: 
        funcvalue=D3DCMP_LESSEQUAL;
        break;
    case GL_GREATER: 
        funcvalue=D3DCMP_GREATER;
        break;
    case GL_NOTEQUAL: 
        funcvalue=D3DCMP_NOTEQUAL;
        break;
    case GL_GEQUAL: 
        funcvalue=D3DCMP_GREATEREQUAL;
        break;
    case GL_ALWAYS: 
        funcvalue=D3DCMP_ALWAYS;
        break;
    }
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_ALPHAFUNC, funcvalue);
    Clamp(&ref);
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_ALPHAREF, (DWORD)(ref * 255.f));
}

void APIENTRY glArrayElement (GLint i)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glArrayElement: 0x%X", i );
#endif
   if(g_OpenGLValues->m_usetexcoordary[0])
    {
        g_OpenGLValues->m_tu = *((FLOAT*)((BYTE*)g_OpenGLValues->m_texcoordary[0] + i * g_OpenGLValues->m_texcoordarystride[0]));
        g_OpenGLValues->m_tv = *((FLOAT*)((BYTE*)g_OpenGLValues->m_texcoordary[0] + i * g_OpenGLValues->m_texcoordarystride[0]) + 1);
    }
    if(g_OpenGLValues->m_usetexcoordary[1])
    {
        g_OpenGLValues->m_tu2 = *((FLOAT*)((BYTE*)g_OpenGLValues->m_texcoordary[1] + i * g_OpenGLValues->m_texcoordarystride[1]));
        g_OpenGLValues->m_tv2 = *((FLOAT*)((BYTE*)g_OpenGLValues->m_texcoordary[1] + i * g_OpenGLValues->m_texcoordarystride[1]) + 1);
    }
    if(g_OpenGLValues->m_usecolorary)
    {
#ifdef _X86_
        const void * colorary = g_OpenGLValues->m_colorary;
        DWORD colorarystride = g_OpenGLValues->m_colorarystride;
        D3DCOLOR color;

        _asm
        {
            mov eax, i;
            mov ebx, colorary;
            mul colorarystride;
            mov edx, 0x00FF00FF;
            add eax, ebx;
            mov ecx, eax;
            and eax, edx;
            not edx;
            rol eax, 16;
            and ecx, edx;
            or  eax, ecx;
            mov color, eax;
        }

        g_OpenGLValues->m_color = color;
#else
        BYTE *glcolor = (BYTE*)g_OpenGLValues->m_colorary + i * g_OpenGLValues->m_colorarystride;
        g_OpenGLValues->m_color = RGBA_MAKE(glcolor[0], glcolor[1], glcolor[2], glcolor[3]);
#endif
    }
    
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = *((FLOAT*)((BYTE*)g_OpenGLValues->m_vertexary + i * g_OpenGLValues->m_vertexarystride));
    *(d3dv++) = *((FLOAT*)((BYTE*)g_OpenGLValues->m_vertexary + i * g_OpenGLValues->m_vertexarystride) + 1);
    *(d3dv++) = *((FLOAT*)((BYTE*)g_OpenGLValues->m_vertexary + i * g_OpenGLValues->m_vertexarystride) + 2);
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glBegin (GLenum mode)
{    
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glBegin: 0x%X", mode );
#endif
    g_OpenGLValues->m_prim = mode;
    g_OpenGLValues->m_withinprim = TRUE;
    g_OpenGLValues->m_vcnt = 0;
    QuakeSetTexturingState();
    if(g_OpenGLValues->m_nfv > (VBUFSIZE - MAXVERTSPERPRIM)) // check if space available
    {
        g_OpenGLValues->m_vbuf->Lock(0, 0, (BYTE**)&g_OpenGLValues->m_verts, D3DLOCK_DISCARD | D3DLOCK_NOSYSLOCK);
        g_OpenGLValues->m_nfv = 0;
    }
    else
    {
        g_OpenGLValues->m_vbuf->Lock(0, 0, (BYTE**)&g_OpenGLValues->m_verts, D3DLOCK_NOOVERWRITE | D3DLOCK_NOSYSLOCK);
        g_OpenGLValues->m_verts = &g_OpenGLValues->m_verts[g_OpenGLValues->m_nfv];
    }
}

void APIENTRY glBindTexture (GLenum target, GLuint texture)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glBindTexture: 0x%X 0x%X", target, texture );
#endif
    g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt] = texture;
    g_OpenGLValues->m_texHandleValid = FALSE;
}

void APIENTRY glBlendFunc (GLenum sfactor, GLenum dfactor)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glBlendFunc: 0x%X 0x%X", sfactor, dfactor );
#endif
    int svalue = -1, dvalue = -1;
    
    switch(sfactor) {
    case GL_ZERO:
        svalue=D3DBLEND_ZERO;
        break;
    case GL_ONE:
        svalue=D3DBLEND_ONE;
        break;
    case GL_DST_COLOR:
        svalue=D3DBLEND_DESTCOLOR;
        break;
    case GL_ONE_MINUS_DST_COLOR:
        svalue=D3DBLEND_INVDESTCOLOR;
        break;
    case GL_SRC_ALPHA:
        svalue=D3DBLEND_SRCALPHA;
        break;
    case GL_ONE_MINUS_SRC_ALPHA:
        svalue=D3DBLEND_INVSRCALPHA;
        break;
    case GL_DST_ALPHA:
        svalue=D3DBLEND_DESTALPHA;
        break;
    case GL_ONE_MINUS_DST_ALPHA:
        svalue=D3DBLEND_INVDESTALPHA;
        break;
    case GL_SRC_ALPHA_SATURATE:
        svalue=D3DBLEND_SRCALPHASAT;
        break;
    }
    switch(dfactor) {
    case GL_ZERO:
        dvalue=D3DBLEND_ZERO;
        break;
    case GL_ONE:
        dvalue=D3DBLEND_ONE;
        break;
    case GL_SRC_COLOR:
        dvalue=D3DBLEND_SRCCOLOR;
        break;
    case GL_ONE_MINUS_SRC_COLOR:
        dvalue=D3DBLEND_INVSRCCOLOR;
        break;
    case GL_SRC_ALPHA:
        dvalue=D3DBLEND_SRCALPHA;
        break;
    case GL_ONE_MINUS_SRC_ALPHA:
        dvalue=D3DBLEND_INVSRCALPHA;
        break;
    case GL_DST_ALPHA:
        dvalue=D3DBLEND_DESTALPHA;
        break;
    case GL_ONE_MINUS_DST_ALPHA:
        dvalue=D3DBLEND_INVDESTALPHA;
        break;
    }
    
    if (svalue >= 0) g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_SRCBLEND, (DWORD)svalue);
    if (dvalue >= 0) g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_DESTBLEND, (DWORD)dvalue);
}

void APIENTRY glClearStencil (GLint s)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glClearStencil: 0x%X", s );
#endif
    g_OpenGLValues->m_clearStencil = (DWORD)s;	
}

void APIENTRY glClear (GLbitfield mask)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glClear: 0x%X", mask );
#endif
    DWORD flags = 0;

    if(mask & GL_COLOR_BUFFER_BIT) {
        flags |= D3DCLEAR_TARGET;
    }
    
    if(mask & GL_DEPTH_BUFFER_BIT) {
        flags |= D3DCLEAR_ZBUFFER;
    }
    
    if(mask & GL_STENCIL_BUFFER_BIT) {
        flags |= D3DCLEAR_STENCIL;
    }
    
    if(g_OpenGLValues->m_updvwp)
        QuakeUpdateViewport();

    g_OpenGLValues->m_d3ddev->Clear(0, NULL, flags, g_OpenGLValues->m_clearColor, (FLOAT)g_OpenGLValues->m_clearDepth, g_OpenGLValues->m_clearStencil);
}

void APIENTRY glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
#if GETPARMSFORDEBUG
    char log[256];
    char r[40];
    char g[40];
    char b[40];
    char a[40];
    ftoa( (double)red, r );
    ftoa( (double)green, g );
    ftoa( (double)blue, b );
    ftoa( (double)alpha, a );
    sprintf( log, "glClearColor: %s %s %s %s", r, g, b, a );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    Clamp(&red);
    Clamp(&green);
    Clamp(&blue);
    Clamp(&alpha);
    unsigned int R, G, B, A;
    R = (unsigned int)(red * 255.f);
    G = (unsigned int)(green * 255.f);
    B = (unsigned int)(blue * 255.f);
    A = (unsigned int)(alpha * 255.f);
    g_OpenGLValues->m_clearColor = RGBA_MAKE(R, G, B, A);
}

void APIENTRY glClearDepth (GLclampd depth)
{ 
#if GETPARMSFORDEBUG
    char log[256];
    char d[40];
    ftoa( (double)depth, d );
    sprintf( log, "glClearDepth: %s", d );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    Clamp(&depth);
    g_OpenGLValues->m_clearDepth = depth;
}

void APIENTRY glClientActiveTextureARB(GLenum texture)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glClientActiveTextureARB: 0x%X", texture );
#endif
    g_OpenGLValues->m_client_active_texture_arb = texture == GL_TEXTURE0_ARB ? 0 : 1;
}

void APIENTRY glClipPlane (GLenum plane, const GLdouble *equation)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glClipPlane: 0x%X 0x%X", plane, equation );
#endif
    D3DMATRIX &m = g_OpenGLValues->m_xfrm[D3DTS_WORLD];
    m.m[0][3] = -(m.m[0][0] * m.m[3][0] + m.m[0][1] * m.m[3][1] + m.m[0][2] * m.m[3][2]);
    m.m[1][3] = -(m.m[1][0] * m.m[3][0] + m.m[1][1] * m.m[3][1] + m.m[1][2] * m.m[3][2]);
    m.m[2][3] = -(m.m[2][0] * m.m[3][0] + m.m[2][1] * m.m[3][1] + m.m[2][2] * m.m[3][2]);
    m.m[3][0] = 0.f; m.m[3][1] = 0.f; m.m[3][2] = 0.f;
    FLOAT eqn[4];
    eqn[0] = FLOAT(m.m[0][0] * equation[0] + m.m[1][0] * equation[1] + m.m[2][0] * equation[2] + m.m[3][0] * equation[3]);
    eqn[1] = FLOAT(m.m[0][1] * equation[0] + m.m[1][1] * equation[1] + m.m[2][1] * equation[2] + m.m[3][1] * equation[3]);
    eqn[2] = FLOAT(m.m[0][2] * equation[0] + m.m[1][2] * equation[1] + m.m[2][2] * equation[2] + m.m[3][2] * equation[3]);
    eqn[3] = FLOAT(m.m[0][3] * equation[0] + m.m[1][3] * equation[1] + m.m[2][3] * equation[2] + m.m[3][3] * equation[3]);
    g_OpenGLValues->m_d3ddev->SetClipPlane(plane - GL_CLIP_PLANE0, eqn);
}

void APIENTRY glColor3f (GLfloat red, GLfloat green, GLfloat blue)
{
#if GETPARMSFORDEBUG
    char log[256];
    char r[40];
    char g[40];
    char b[40];
    ftoa( (double)red, r );
    ftoa( (double)green, g );
    ftoa( (double)blue, b );
    sprintf( log, "glColor3f: %s %s %s", r, g, b );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    static float two55 = 255.f;
    unsigned int R, G, B;
#ifdef _X86_
    D3DCOLOR color;

    _asm {
        fld red;
        fld green;
        fld blue;
        fld two55;
        fmul st(1), st(0);
        fmul st(2), st(0);
        fmulp st(3), st(0);
        fistp B;
        fistp G;
        fistp R;
        mov eax, B;
        cmp eax, 255;
        jle pt1;
        mov eax, 255;
pt1:    mov ebx, G;
        cmp ebx, 255;
        jle pt2;
        mov ebx, 255;
pt2:    mov ecx, R;
        cmp ecx, 255;
        jle pt3;
        mov ecx, 255;
pt3:    shl ebx, 8;
        shl ecx, 16;
        or eax, ebx;
        or ecx, 0xFF000000;
        or eax, ecx;
        mov color, eax;
    }

    g_OpenGLValues->m_color = color;
#else
    R = (unsigned int)(red * two55);
    G = (unsigned int)(green * two55);
    B = (unsigned int)(blue * two55);
    if(R > 255)
        R = 255;
    if(G > 255)
        G = 255;
    if(B > 255)
        B = 255;
    g_OpenGLValues->m_color = RGBA_MAKE(R, G, B, 255);
#endif
}

void APIENTRY glColor3fv (const GLfloat *v)
{ 
#if GETPARMSFORDEBUG
    char log[256];
    char v0[40];
    char v1[40];
    char v2[40];
    ftoa( (double)v[0], v0 );
    ftoa( (double)v[1], v1 );
    ftoa( (double)v[2], v2 );
    sprintf( log, "glColor3fv: %s %s %s", v0, v1, v2 );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    static float two55 = 255.f;
    unsigned int R, G, B;
#ifdef _X86_
    D3DCOLOR color;

    _asm {
        mov ebx, v;
        fld [ebx];
        fld [ebx + 4];
        fld [ebx + 8];
        fld two55;
        fmul st(1), st(0);
        fmul st(2), st(0);
        fmulp st(3), st(0);
        fistp B;
        fistp G;
        fistp R;
        mov eax, B;
        cmp eax, 255;
        jle pt1;
        mov eax, 255;
pt1:    mov ebx, G;
        cmp ebx, 255;
        jle pt2;
        mov ebx, 255;
pt2:    mov ecx, R;
        cmp ecx, 255;
        jle pt3;
        mov ecx, 255;
pt3:    shl ebx, 8;
        shl ecx, 16;
        or eax, ebx;
        or ecx, 0xFF000000;
        or eax, ecx;
        mov color, eax;
    }

    g_OpenGLValues->m_color = color;
#else
    R = (unsigned int)(v[0] * two55);
    G = (unsigned int)(v[1] * two55);
    B = (unsigned int)(v[2] * two55);
    if(R > 255)
        R = 255;
    if(G > 255)
        G = 255;
    if(B > 255)
        B = 255;
    g_OpenGLValues->m_color = RGBA_MAKE(R, G, B, 255);
#endif
}

void APIENTRY glColor3ubv (const GLubyte *v)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glColor3ubv: 0x%X 0x%X 0x%X", v[0], v[1], v[2] );
#endif
    g_OpenGLValues->m_color = RGBA_MAKE(v[0], v[1], v[2], 255);
}

void APIENTRY glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glColor4ub: 0x%X 0x%X 0x%X 0x%X", red, green, blue, alpha );
#endif
    g_OpenGLValues->m_color = RGBA_MAKE(red, green, blue, alpha);
}

void APIENTRY glColor4ubv (const GLubyte *v)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glColor4ubv: 0x%X 0x%X 0x%X 0x%X", v[0], v[1], v[2], v[3] );
#endif
#ifdef _X86_
    D3DCOLOR color;

    _asm
    {
        mov ebx, v;
        mov edx, 0x00FF00FF;
        mov eax, [ebx];
        mov ecx, eax;
        and eax, edx;
        not edx;
        rol eax, 16;
        and ecx, edx;
        or  eax, ecx;
        mov color, eax;
    }

    g_OpenGLValues->m_color = color;
#else
    g_OpenGLValues->m_color = RGBA_MAKE(v[0], v[1], v[2], v[3]);
#endif
}

void APIENTRY glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
#if GETPARMSFORDEBUG
    char log[256];
    char r[40];
    char g[40];
    char b[40];
    char a[40];
    ftoa( (double)red, r );
    ftoa( (double)green, g );
    ftoa( (double)blue, b );
    ftoa( (double)alpha, a );
    sprintf( log, "glColor4f: %s %s %s %s", r, g, b, a );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    static float two55 = 255.f;
    unsigned int R, G, B, A;
#ifdef _X86_
    D3DCOLOR color;

    __asm {
        fld red;
        fld green;
        fld blue;
        fld alpha;
        fld two55;
        fmul st(1), st(0);
        fmul st(2), st(0);
        fmul st(3), st(0);
        fmulp st(4), st(0);
        fistp A;
        fistp B;
        fistp G;
        fistp R;
        mov edx, A;
        cmp edx, 255;
        jle pt1;
        mov edx, 255;
pt1:    mov eax, B;
        cmp eax, 255;
        jle pt2;
        mov eax, 255;
pt2:    mov ebx, G;
        cmp ebx, 255;
        jle pt3;
        mov ebx, 255;
pt3:    mov ecx, R;
        cmp ecx, 255;
        jle pt4;
        mov ecx, 255;
pt4:    shl ebx, 8;
        shl ecx, 16;
        shl edx, 24;
        or eax, ebx;
        or ecx, edx;
        or eax, ecx;
        mov color, eax;
    }

    g_OpenGLValues->m_color = color;
#else
    R = (unsigned int)(red * two55);
    G = (unsigned int)(green * two55);
    B = (unsigned int)(blue * two55);
    A = (unsigned int)(alpha * two55);
    if(R > 255)
        R = 255;
    if(G > 255)
        G = 255;
    if(B > 255)
        B = 255;
    if(A > 255)
        A = 255;
    g_OpenGLValues->m_color = RGBA_MAKE(R, G, B, A);
#endif
}

void APIENTRY glColor4fv (const GLfloat *v)
{
#if GETPARMSFORDEBUG
    char log[256];
    char v0[40];
    char v1[40];
    char v2[40];
    char v3[40];
    ftoa( (double)v[0], v0 );
    ftoa( (double)v[1], v1 );
    ftoa( (double)v[2], v2 );
    ftoa( (double)v[3], v3 );
    sprintf( log, "glColor4fv: %s %s %s %s", v0, v1, v2, v3 );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    static float two55 = 255.f;
    unsigned int R, G, B, A;
#ifdef _X86_
    D3DCOLOR color;

    _asm {
        mov ebx, v;
        fld [ebx];
        fld [ebx + 4];
        fld [ebx + 8];
        fld [ebx + 12];
        fld two55;
        fmul st(1), st(0);
        fmul st(2), st(0);
        fmul st(3), st(0);
        fmulp st(4), st(0);
        fistp A;
        fistp B;
        fistp G;
        fistp R;
        mov edx, A;
        cmp edx, 255;
        jle pt1;
        mov edx, 255;
pt1:    mov eax, B;
        cmp eax, 255;
        jle pt2;
        mov eax, 255;
pt2:    mov ebx, G;
        cmp ebx, 255;
        jle pt3;
        mov ebx, 255;
pt3:    mov ecx, R;
        cmp ecx, 255;
        jle pt4;
        mov ecx, 255;
pt4:    shl ebx, 8;
        shl ecx, 16;
        shl edx, 24;
        or eax, ebx;
        or ecx, edx;
        or eax, ecx;
        mov color, eax;
    }

    g_OpenGLValues->m_color = color;
#else
    R = (unsigned int)(v[0] * two55);
    G = (unsigned int)(v[1] * two55);
    B = (unsigned int)(v[2] * two55);
    A = (unsigned int)(v[3] * two55);
    if(R > 255)
        R = 255;
    if(G > 255)
        G = 255;
    if(B > 255)
        B = 255;
    if(A > 255)
        A = 255;
    g_OpenGLValues->m_color = RGBA_MAKE(R, G, B, A);
#endif
}

void APIENTRY glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glColorPointer: 0x%X 0x%X 0x%X 0x%X", size, type, stride, pointer );
#endif
    if(size == 4 && (type == GL_BYTE || type == GL_UNSIGNED_BYTE))
        g_OpenGLValues->m_colorary = (GLubyte*)pointer;
#if DODPFS
    else
    {
        char junk[256];
        sprintf( junk, "Color array not supported (size:0x%X type:0x%X)\n", size, type );
        OutputDebugStringA( junk );
    }
#endif
    if(stride == 0)
    {
        stride = 4;
    }
    g_OpenGLValues->m_colorarystride = stride;
}

void APIENTRY glCullFace (GLenum mode)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glCullFace: 0x%X", mode );
#endif
    g_OpenGLValues->m_cullMode = mode;
    if(g_OpenGLValues->m_cullEnabled == TRUE){
        DWORD statevalue;
        if(mode == GL_BACK)
            statevalue = g_OpenGLValues->m_FrontFace == GL_CCW ? D3DCULL_CW : D3DCULL_CCW;
        else
            statevalue = g_OpenGLValues->m_FrontFace == GL_CCW ? D3DCULL_CCW : D3DCULL_CW;
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_CULLMODE, statevalue);
    }
}

void APIENTRY glDeleteTextures (GLsizei n, const GLuint *textures)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glDeleteTextures: 0x%X 0x%X", n, textures );
#endif
    for(int i = 0; i < n; ++i) {
        TexInfo &ti = g_OpenGLValues->m_tex[textures[i]];
        if(ti.m_ddsurf != 0) {
            ti.m_ddsurf->Release();
            ti.m_ddsurf = 0;
        }
        if(ti.m_block != 0)
        {
            g_OpenGLValues->m_d3ddev->DeleteStateBlock(ti.m_block);
            ti.m_block = 0;
        }
        ti.m_capture = FALSE;
        ti.m_dwStage = 0;
        ti.m_minmode = D3DTEXF_POINT;
        ti.m_magmode = D3DTEXF_LINEAR;
        ti.m_mipmode = D3DTEXF_LINEAR;
        ti.m_addu = D3DTADDRESS_WRAP;
        ti.m_addv = D3DTADDRESS_WRAP;
        ti.m_next = g_OpenGLValues->m_free;
        ti.m_prev = -1;
        g_OpenGLValues->m_tex[g_OpenGLValues->m_free].m_prev = textures[i];
        g_OpenGLValues->m_free = textures[i];
    }
}

void APIENTRY glDepthFunc (GLenum func)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glDepthFunc: 0x%X", func );
#endif
    int state = -1;
    switch(func) {
    case GL_NEVER:
        state=D3DCMP_NEVER;
        break;
    case GL_LESS: 
        state=D3DCMP_LESS;
        break;
    case GL_EQUAL: 
        state=D3DCMP_EQUAL;
        break;
    case GL_LEQUAL: 
        state=D3DCMP_LESSEQUAL;
        break;
    case GL_GREATER: 
        state=D3DCMP_GREATER;
        break;
    case GL_NOTEQUAL: 
        state=D3DCMP_NOTEQUAL;
        break;
    case GL_GEQUAL: 
        state=D3DCMP_GREATEREQUAL;
        break;
    case GL_ALWAYS: 
        state=D3DCMP_ALWAYS;
        break;
    }
    if(state >= 0)
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_ZFUNC, state);
}

void APIENTRY glDepthMask (GLboolean flag)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glDepthMask: 0x%X", flag );
#endif
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_ZWRITEENABLE, flag);
}

void APIENTRY glDepthRange (GLclampd zNear, GLclampd zFar)
{
#if GETPARMSFORDEBUG
    char log[256];
    char zn[40];
    char zf[40];
    ftoa( (double)zNear, zn );
    ftoa( (double)zFar, zf );
    sprintf( log, "glDepthRange: %s %s", zn, zf );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    Clamp(&zNear);
    Clamp(&zFar);
    g_OpenGLValues->m_vport.MinZ = (FLOAT)zNear;
    g_OpenGLValues->m_vport.MaxZ = (FLOAT)zFar;
    if(g_OpenGLValues->m_polyoffset && g_OpenGLValues->m_vport.MaxZ != 0.f)
    {
        D3DVIEWPORT8 vport(g_OpenGLValues->m_vport);
        vport.MaxZ -= .001f;
        g_OpenGLValues->m_d3ddev->SetViewport(&vport);
    }
    else
    {
        g_OpenGLValues->m_d3ddev->SetViewport(&g_OpenGLValues->m_vport);
    }
}

void APIENTRY glEnd (void)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glEnd" );
#endif
    if(!g_OpenGLValues->m_withinprim)
        return;
    g_OpenGLValues->m_vbuf->Unlock();
    QuakeSetVertexShader(QUAKEVFMT);
    QuakeSetStreamSource(0, g_OpenGLValues->m_vbuf, sizeof(QuakeVertex));
    unsigned vcnt;

    vcnt = g_OpenGLValues->m_vcnt;

    switch(g_OpenGLValues->m_prim)
    {
    case GL_TRIANGLES:
        if(vcnt >= 3)
        {
            g_OpenGLValues->m_d3ddev->DrawPrimitive(D3DPT_TRIANGLELIST, g_OpenGLValues->m_nfv, vcnt / 3);
        }
#if DODPFS
        else
        {
            char junk[256];
            sprintf( junk, "Wrapper: glEnd: GL_TRIANGLES cnt=%d NOT STORED\n", vcnt );
            OutputDebugStringA( junk );
        }
#endif
        g_OpenGLValues->m_nfv += vcnt;
        break;
    case GL_QUADS:
        if(vcnt >= 4)
        {
            unsigned i;

            for(i = 0; i < vcnt; i += 4) 
            {
                g_OpenGLValues->m_d3ddev->DrawPrimitive(D3DPT_TRIANGLEFAN, g_OpenGLValues->m_nfv, 2);
                g_OpenGLValues->m_nfv += 4;
            }
        }
#if DODPFS
        else
        {
            char junk[256];
            sprintf( junk, "Wrapper: glEnd: GL_QUADS cnt=%d NOT STORED\n", vcnt );
            OutputDebugStringA( junk );
        }
#endif
        break;
    case GL_LINES:
        if(vcnt >= 2)
        {
            g_OpenGLValues->m_d3ddev->DrawPrimitive(D3DPT_LINELIST, g_OpenGLValues->m_nfv, vcnt / 2);
        }
#if DODPFS
        else
        {
            char junk[256];
            sprintf( junk, "Wrapper: glEnd: GL_LINES cnt=%d NOT STORED\n", vcnt );
            OutputDebugStringA( junk );
        }
#endif
        g_OpenGLValues->m_nfv += vcnt;
        break;
    case GL_TRIANGLE_STRIP:
    case GL_QUAD_STRIP:
        if(vcnt > 2)
        {
            g_OpenGLValues->m_d3ddev->DrawPrimitive(D3DPT_TRIANGLESTRIP, g_OpenGLValues->m_nfv, vcnt-2 );
        }
#if DODPFS
        else
        {
            char junk[256];
            sprintf( junk, "Wrapper: glEnd: GL_TRIANGLE_STRIP or GL_QUAD_STRIP cnt=%d NOT STORED\n", vcnt );
            OutputDebugStringA( junk );
        }
#endif
        g_OpenGLValues->m_nfv += vcnt;
        break;
    case GL_POLYGON:
    case GL_TRIANGLE_FAN:
        if(vcnt > 2)
        {
            g_OpenGLValues->m_d3ddev->DrawPrimitive(D3DPT_TRIANGLEFAN, g_OpenGLValues->m_nfv, vcnt-2);
        }
#if DODPFS
        else
        {
            char junk[256];
            sprintf( junk, "Wrapper: glEnd: GL_POLYGON or GL_TRIANGLE_FAN cnt=%d NOT STORED\n", vcnt );
            OutputDebugStringA( junk );
        }
#endif
        g_OpenGLValues->m_nfv += vcnt;
        break;
    case GL_POINTS:
        if(vcnt > 0)
        {
            g_OpenGLValues->m_d3ddev->DrawPrimitive(D3DPT_POINTLIST, g_OpenGLValues->m_nfv, vcnt);
        }
#if DODPFS
        else
        {
            char junk[256];
            sprintf( junk, "Wrapper: glEnd: GL_POINTS cnt=%d NOT STORED\n", vcnt );
            OutputDebugStringA( junk );
        }
#endif
        g_OpenGLValues->m_nfv += vcnt;
        break;
#if DODPFS
    default:
        char junk[256];
        sprintf( junk, "Wrapper: unimplemented primitive type=0x%X cnt=%d\n", g_OpenGLValues->m_prim, vcnt );
        OutputDebugStringA( junk );
#endif
    }
    g_OpenGLValues->m_withinprim = FALSE;
}

void APIENTRY glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glDrawElements: 0x%X 0x%X 0x%X 0x%X", mode, count, type, indices );
#endif
    QuakeSetTexturingState();
    if((DWORD)count > g_OpenGLValues->m_ibufsz)
    {
        GrowIB(count);
    }
    unsigned min, max, LockFlags;
    GLsizei i;
    if(g_OpenGLValues->m_lckcount != 0)
    {
        WORD *pIndices;
        min = g_OpenGLValues->m_lckfirst;
        max = g_OpenGLValues->m_lckfirst + g_OpenGLValues->m_lckcount - 1;
        if(max - min + 1 > g_OpenGLValues->m_vbufsz)
        {
            GrowVB(max - min + 1);
        }    
        if(g_OpenGLValues->m_vbufoff + max - min + 1 > g_OpenGLValues->m_vbufsz)
        {
            LockFlags = D3DLOCK_DISCARD | D3DLOCK_NOSYSLOCK;
            g_OpenGLValues->m_vbufoff = 0;
        }
        else
        {
            LockFlags = D3DLOCK_NOOVERWRITE | D3DLOCK_NOSYSLOCK;
        }
        if(g_OpenGLValues->m_ibufoff + count > g_OpenGLValues->m_ibufsz)
        {
            g_OpenGLValues->m_ibufoff = 0;
            g_OpenGLValues->m_ibuf->Lock(g_OpenGLValues->m_ibufoff * 2, count * 2, (BYTE**)&pIndices, D3DLOCK_DISCARD | D3DLOCK_NOSYSLOCK);
        }
        else
        {
            g_OpenGLValues->m_ibuf->Lock(g_OpenGLValues->m_ibufoff * 2, count * 2, (BYTE**)&pIndices, D3DLOCK_NOOVERWRITE | D3DLOCK_NOSYSLOCK);
        }
        switch(type)
        {
        case GL_UNSIGNED_BYTE:
            for(i = 0; i < count; ++i)
                pIndices[i] = (WORD)(((unsigned char*)indices)[i] - min + g_OpenGLValues->m_vbufoff);
            break;
        case GL_UNSIGNED_SHORT:
            for(i = 0; i < count; ++i)
                pIndices[i] = (WORD)(((unsigned short*)indices)[i] - min + g_OpenGLValues->m_vbufoff);
            break;
        case GL_UNSIGNED_INT:
            for(i = 0; i < count; ++i)
                pIndices[i] = (WORD)(((unsigned int*)indices)[i] - min + g_OpenGLValues->m_vbufoff);
            break;
        }
        g_OpenGLValues->m_ibuf->Unlock();
    }
    else
    {   
        WORD *pIndices;
        min = 65535;
        max = 0;
        switch(type)
        {
        case GL_UNSIGNED_BYTE:
            for(i = 0; i < count; ++i)
            {
                unsigned t = ((unsigned char*)indices)[i];
                if(t < min)
                    min = t;
                if(t > max)
                    max = t;
            }
            break;
        case GL_UNSIGNED_SHORT:
            for(i = 0; i < count; ++i)
            {
                unsigned t = ((unsigned short*)indices)[i];
                if(t < min)
                    min = t;
                if(t > max)
                    max = t;
            }
            break;
        case GL_UNSIGNED_INT:
            for(i = 0; i < count; ++i)
            {
                unsigned t = ((unsigned int*)indices)[i];
                if(t < min)
                    min = t;
                if(t > max)
                    max = t;
            }
            break;
        }
        if(max - min + 1 > g_OpenGLValues->m_vbufsz)
        {
            GrowVB(max - min + 1);
        }
        if(g_OpenGLValues->m_vbufoff + max - min + 1 > g_OpenGLValues->m_vbufsz)
        {
            LockFlags = D3DLOCK_DISCARD | D3DLOCK_NOSYSLOCK;
            g_OpenGLValues->m_vbufoff = 0;
        }
        else
        {
            LockFlags = D3DLOCK_NOOVERWRITE | D3DLOCK_NOSYSLOCK;
        }
        if(g_OpenGLValues->m_ibufoff + count > g_OpenGLValues->m_ibufsz)
        {
            g_OpenGLValues->m_ibufoff = 0;
            g_OpenGLValues->m_ibuf->Lock(g_OpenGLValues->m_ibufoff * 2, count * 2, (BYTE**)&pIndices, D3DLOCK_DISCARD | D3DLOCK_NOSYSLOCK);
        }
        else
        {
            g_OpenGLValues->m_ibuf->Lock(g_OpenGLValues->m_ibufoff * 2, count * 2, (BYTE**)&pIndices, D3DLOCK_NOOVERWRITE | D3DLOCK_NOSYSLOCK);
        }
        switch(type)
        {
        case GL_UNSIGNED_BYTE:
            for(i = 0; i < count; ++i)
            {
                pIndices[i] = (WORD)(((unsigned char*)indices)[i] - min + g_OpenGLValues->m_vbufoff);
            }
            break;
        case GL_UNSIGNED_SHORT:
            for(i = 0; i < count; ++i)
            {
                pIndices[i] = (WORD)(((unsigned short*)indices)[i] - min + g_OpenGLValues->m_vbufoff);
            }
            break;
        case GL_UNSIGNED_INT:
            for(i = 0; i < count; ++i)
            {
                pIndices[i] = (WORD)(((unsigned int*)indices)[i] - min + g_OpenGLValues->m_vbufoff);
            }
            break;
        }
        g_OpenGLValues->m_ibuf->Unlock();
    }
    if(g_OpenGLValues->m_usetexcoordary[1])
    {
        BYTE *pTex, *pSrcTex;
        g_OpenGLValues->m_texbuf->Lock(g_OpenGLValues->m_vbufoff * 8, 8 * (max - min + 1), &pTex, LockFlags);
        pSrcTex = (BYTE*)g_OpenGLValues->m_texcoordary[0] + min * g_OpenGLValues->m_texcoordarystride[0];
        for(unsigned i = min; i <= max; ++i)
        {
            MEMCPY(pTex, pSrcTex, 8);
            pTex += 8;
            pSrcTex += g_OpenGLValues->m_texcoordarystride[0];
        }
        g_OpenGLValues->m_texbuf->Unlock();
        BYTE *pTex2, *pSrcTex2;
        g_OpenGLValues->m_tex2buf->Lock(g_OpenGLValues->m_vbufoff * 8, 8 * (max - min + 1), &pTex2, LockFlags);
        pSrcTex2 = (BYTE*)g_OpenGLValues->m_texcoordary[1] + min * g_OpenGLValues->m_texcoordarystride[1];
        for(unsigned i = min; i <= max; ++i)
        {
            MEMCPY(pTex2, pSrcTex2, 8);
            pTex2 += 8;
            pSrcTex2 += g_OpenGLValues->m_texcoordarystride[1];
        }
        g_OpenGLValues->m_tex2buf->Unlock();
    }
    else if(g_OpenGLValues->m_usetexcoordary[0])
    {
        BYTE *pTex, *pSrcTex;
        g_OpenGLValues->m_texbuf->Lock(g_OpenGLValues->m_vbufoff * 8, 8 * (max - min + 1), &pTex, LockFlags);
        pSrcTex = (BYTE*)g_OpenGLValues->m_texcoordary[0] + min * g_OpenGLValues->m_texcoordarystride[0];
        for(unsigned i = min; i <= max; ++i)
        {
            MEMCPY(pTex, pSrcTex, 8); 
            pTex += 8;
            pSrcTex += g_OpenGLValues->m_texcoordarystride[0];
        }
        g_OpenGLValues->m_texbuf->Unlock();
    }
    if(g_OpenGLValues->m_usecolorary)
    {
        if(max - min + 1 > VBUFSIZE)
        {
#if DODPFS
            char junk[256];
            sprintf( junk, "Insufficient color buffer (amnt:0x%X size:0x%X)\n", (max-min+1), VBUFSIZE );
            OutputDebugStringA( junk );
#endif
            return;
        }
        DWORD *pColor;
        BYTE *pSrcColor;
        g_OpenGLValues->m_colbuf->Lock(g_OpenGLValues->m_vbufoff * 4, 4 * (max - min + 1), (BYTE**)&pColor, LockFlags);
#ifdef _X86_
        const void *colorary = g_OpenGLValues->m_colorary;
        DWORD colorarystride = g_OpenGLValues->m_colorarystride;

        _asm
        {
            mov esi, min;
            mov ecx, colorarystride;
            mov ebx, colorary;
            mov edi, pColor;
            mov eax, esi;
            mul ecx;
            mov edx, max;
            sub edx, esi;
            lea esi, [ebx + eax];
            inc edx;
lp1:        mov eax, [esi];
            add esi, ecx;
            mov ebx, eax;
            and eax, 0x00FF00FF;
            rol eax, 16;
            and ebx, 0xFF00FF00;
            or  eax, ebx;
            mov [edi], eax;
            add edi, 4;
            dec edx;
            jnz lp1;
        }
#else
        pSrcColor = (BYTE*)g_OpenGLValues->m_colorary + min * g_OpenGLValues->m_colorarystride;
        for(unsigned i = min; i <= max; ++i)
        {
            *(pColor++) = RGBA_MAKE(pSrcColor[0], pSrcColor[1], pSrcColor[2], pSrcColor[3]);
            pSrcColor += g_OpenGLValues->m_colorarystride;
        }
#endif
        g_OpenGLValues->m_colbuf->Unlock();
    }
    if(g_OpenGLValues->m_usevertexary)
    {
        BYTE *pXYZ, *pSrcXYZ;
        g_OpenGLValues->m_xyzbuf->Lock(g_OpenGLValues->m_vbufoff * 12, 12 * (max - min + 1), &pXYZ, LockFlags);
        pSrcXYZ = (BYTE*)g_OpenGLValues->m_vertexary + min * g_OpenGLValues->m_vertexarystride;
        for(unsigned i = min; i <= max; ++i)
        {
            MEMCPY(pXYZ, pSrcXYZ, 12);
            pXYZ += 12;
            pSrcXYZ += g_OpenGLValues->m_vertexarystride;
        }
        g_OpenGLValues->m_xyzbuf->Unlock();
    }
    QuakeSetStreamSource(0, g_OpenGLValues->m_xyzbuf, 12);
    if(g_OpenGLValues->m_usecolorary)
    {
        QuakeSetStreamSource(1, g_OpenGLValues->m_colbuf, 4);
        if(g_OpenGLValues->m_usetexcoordary[1])
        {
            QuakeSetStreamSource(2, g_OpenGLValues->m_texbuf, 8);
            QuakeSetStreamSource(3, g_OpenGLValues->m_tex2buf, 8);
            QuakeSetVertexShader(g_OpenGLValues->m_vshader[5]);
        }
        else if(g_OpenGLValues->m_usetexcoordary[0])
        {
            QuakeSetStreamSource(2, g_OpenGLValues->m_texbuf, 8);
            QuakeSetVertexShader(g_OpenGLValues->m_vshader[4]);
        }
        else
        {
            QuakeSetVertexShader(g_OpenGLValues->m_vshader[1]);
        }
    }
    else if(g_OpenGLValues->m_usetexcoordary[1])
    {
        QuakeSetStreamSource(1, g_OpenGLValues->m_texbuf, 8);
        QuakeSetStreamSource(2, g_OpenGLValues->m_tex2buf, 8);
        QuakeSetVertexShader(g_OpenGLValues->m_vshader[3]);
    }
    else if(g_OpenGLValues->m_usetexcoordary[0])
    {
        QuakeSetStreamSource(2, g_OpenGLValues->m_texbuf, 8);
        QuakeSetVertexShader(g_OpenGLValues->m_vshader[2]);
    }
    else
    {
        QuakeSetVertexShader(g_OpenGLValues->m_vshader[0]);
    }
    switch(mode) 
    {
    case GL_LINES:
        if(count >= 2)
        {
            g_OpenGLValues->m_d3ddev->DrawIndexedPrimitive(D3DPT_LINELIST, g_OpenGLValues->m_vbufoff, max - min + 1, g_OpenGLValues->m_ibufoff, count / 2);
        }
        break;
    case GL_TRIANGLES:
        if(count >= 3)
        {
            g_OpenGLValues->m_d3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, g_OpenGLValues->m_vbufoff, max - min + 1, g_OpenGLValues->m_ibufoff, count / 3);
        }
        break;
    case GL_TRIANGLE_STRIP:
    case GL_QUAD_STRIP:
        if(count > 2)
        {
            g_OpenGLValues->m_d3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLESTRIP, g_OpenGLValues->m_vbufoff, max - min + 1, g_OpenGLValues->m_ibufoff, count - 2);
        }
        break;
    case GL_POLYGON:
    case GL_TRIANGLE_FAN:
        if(count > 2)
        {
            g_OpenGLValues->m_d3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLEFAN, g_OpenGLValues->m_vbufoff, max - min + 1, g_OpenGLValues->m_ibufoff, count - 2);
        }
        break;
    case GL_QUADS:
        if(count >= 4)
        {
            for(i = 0; i < count; i += 4) 
                g_OpenGLValues->m_d3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLEFAN, g_OpenGLValues->m_vbufoff, max - min + 1, g_OpenGLValues->m_ibufoff, 2);
        }
        break;
#if DODPFS
    default:
        char junk[256];
        sprintf( junk, "Wrapper (4): unimplemented primitive type (0x%X)\n", mode );
        OutputDebugStringA( junk );
#endif
    }
    g_OpenGLValues->m_vbufoff += (max - min + 1);
    g_OpenGLValues->m_ibufoff += count;
}

void APIENTRY glFrontFace (GLenum mode)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glFrontFace: 0x%X", mode );
#endif
    g_OpenGLValues->m_FrontFace = mode;
}

void APIENTRY glViewport (GLint x, GLint y, GLsizei width, GLsizei height)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glViewport: 0x%X 0x%X 0x%X 0x%X", x, y, width, height );
#endif

    g_OpenGLValues->m_vwx = x;
    g_OpenGLValues->m_vwy = y;
    g_OpenGLValues->m_vww = width;
    g_OpenGLValues->m_vwh = height;
    g_OpenGLValues->m_updvwp = TRUE;
}

void APIENTRY glLineWidth (GLfloat width)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glLineWidth: 0x%X", width );
#endif
}

void APIENTRY glLoadIdentity (void)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glLoadIdentity" );
#endif
    D3DMATRIX unity;
    unity._11 = 1.0f; unity._12 = 0.0f; unity._13 = 0.0f; unity._14 = 0.0f;
    unity._21 = 0.0f; unity._22 = 1.0f; unity._23 = 0.0f; unity._24 = 0.0f;
    unity._31 = 0.0f; unity._32 = 0.0f; unity._33 = 1.0f; unity._34 = 0.0f;
    unity._41 = 0.0f; unity._42 = 0.0f; unity._43 = 0.0f; unity._44 = 1.0f;
    if(g_OpenGLValues->m_matrixMode == D3DTS_TEXTURE0)
    {
        g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt] = unity;
        QuakeSetTransform((D3DTRANSFORMSTATETYPE)(g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt), &unity);
    }
    else
    {
        g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode] = unity;
        QuakeSetTransform(g_OpenGLValues->m_matrixMode, &unity);
    }
}

void APIENTRY glMatrixMode (GLenum mode)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glMatrixMode: 0x%X", mode );
#endif
    switch(mode)
    {
    case GL_MODELVIEW:
        g_OpenGLValues->m_matrixMode = D3DTS_WORLD;
        break;
    case GL_PROJECTION:
        g_OpenGLValues->m_matrixMode = D3DTS_PROJECTION;
        break;
    case GL_TEXTURE:
        g_OpenGLValues->m_matrixMode = D3DTS_TEXTURE0;
        break;
    }
}

void APIENTRY glColorMaterial (GLenum face, GLenum mode)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glColorMaterial: 0x%X 0x%X", face, mode );
#endif
    if(face == GL_FRONT || face == GL_FRONT_AND_BACK)
    {
        switch(mode)
        {
        case GL_EMISSION:
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_MATERIAL);
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_MATERIAL); 
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_MATERIAL); 
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_COLOR1);
            break;
        case GL_AMBIENT:
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_MATERIAL);
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_MATERIAL); 
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_COLOR1); 
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
            break;
        case GL_DIFFUSE:
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_COLOR1);
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_MATERIAL); 
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_MATERIAL); 
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
            break;
        case GL_SPECULAR:
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_MATERIAL);
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_COLOR1); 
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_MATERIAL); 
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
            break;
        case GL_AMBIENT_AND_DIFFUSE:
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_COLOR1);
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_MATERIAL); 
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_COLOR1); 
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
            break;
        }
    }
#if DODPFS
    else
    {
        OutputDebugStringA("Wrapper: Back face ColorMaterial ignored\n");
    }
#endif
}

void APIENTRY glDisable (GLenum cap)
{
    switch(cap) {
    case GL_LIGHTING:
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_LIGHTING, FALSE);
        break;
    case GL_COLOR_MATERIAL:
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_COLORVERTEX, FALSE);
        break;
    case GL_DEPTH_TEST:
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_ZENABLE, FALSE);
        break;
    case GL_CULL_FACE:
        g_OpenGLValues->m_cullEnabled = FALSE;
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
        break;
    case GL_FOG:
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_FOGTABLEMODE, D3DFOG_NONE);
        break;
    case GL_BLEND:
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
        break;
    case GL_CLIP_PLANE0:
        g_OpenGLValues->m_clippstate &= ~0x01;
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_CLIPPLANEENABLE, g_OpenGLValues->m_clippstate);
        break;
    case GL_CLIP_PLANE1:
        g_OpenGLValues->m_clippstate &= ~0x02;
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_CLIPPLANEENABLE, g_OpenGLValues->m_clippstate);
        break;
    case GL_CLIP_PLANE2:
        g_OpenGLValues->m_clippstate &= ~0x04;
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_CLIPPLANEENABLE, g_OpenGLValues->m_clippstate);
        break;
    case GL_CLIP_PLANE3:
        g_OpenGLValues->m_clippstate &= ~0x08;
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_CLIPPLANEENABLE, g_OpenGLValues->m_clippstate);
        break;
    case GL_CLIP_PLANE4:
        g_OpenGLValues->m_clippstate &= ~0x10;
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_CLIPPLANEENABLE, g_OpenGLValues->m_clippstate);
        break;
    case GL_CLIP_PLANE5:
        g_OpenGLValues->m_clippstate &= ~0x20;
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_CLIPPLANEENABLE, g_OpenGLValues->m_clippstate);
        break;
    case GL_POLYGON_OFFSET_FILL:
        g_OpenGLValues->m_polyoffset = FALSE;
        glDepthRange(g_OpenGLValues->m_vport.MinZ, g_OpenGLValues->m_vport.MaxZ);
        break;
    case GL_STENCIL_TEST:
        break;
    case GL_SCISSOR_TEST:
        g_OpenGLValues->m_scissoring = FALSE;
        glViewport(g_OpenGLValues->m_vwx, g_OpenGLValues->m_vwy, g_OpenGLValues->m_vww, g_OpenGLValues->m_vwh);
        QuakeSetTransform(D3DTS_PROJECTION, &g_OpenGLValues->m_xfrm[D3DTS_PROJECTION]);
        break;
    case GL_TEXTURE_2D:
        if(g_OpenGLValues->m_curtgt == 0) {
            g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLOROP, D3DTOP_DISABLE);
            g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
            g_OpenGLValues->m_texturing = FALSE;
        }
        else {
            g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLOROP, D3DTOP_DISABLE);
            g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
            g_OpenGLValues->m_mtex = FALSE;
        }
        g_OpenGLValues->m_texHandleValid = FALSE;
        break;
    case GL_ALPHA_TEST:
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
        break;
    case GL_LIGHT0:
        g_OpenGLValues->m_d3ddev->LightEnable(0, FALSE);
        break;
    case GL_LIGHT1:
        g_OpenGLValues->m_d3ddev->LightEnable(1, FALSE);
        break;
    case GL_LIGHT2:
        g_OpenGLValues->m_d3ddev->LightEnable(2, FALSE);
        break;
    case GL_LIGHT3:
        g_OpenGLValues->m_d3ddev->LightEnable(3, FALSE);
        break;
    case GL_LIGHT4:
        g_OpenGLValues->m_d3ddev->LightEnable(4, FALSE);
        break;
    case GL_LIGHT5:
        g_OpenGLValues->m_d3ddev->LightEnable(5, FALSE);
        break;
    case GL_LIGHT6:
        g_OpenGLValues->m_d3ddev->LightEnable(6, FALSE);
        break;
    case GL_LIGHT7:
        g_OpenGLValues->m_d3ddev->LightEnable(7, FALSE);
        break;
    case GL_TEXTURE_GEN_S:
        g_OpenGLValues->m_texgen = FALSE;
        g_OpenGLValues->m_d3ddev->SetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0);
        if(g_OpenGLValues->m_usemtex == TRUE)
        {
            g_OpenGLValues->m_d3ddev->SetTextureStageState(1, D3DTSS_TEXCOORDINDEX, 1);
        }
        break;
    case GL_TEXTURE_GEN_T:
        break;
#if DODPFS
    default:
        char junk[256];
        sprintf( junk, "Wrapper: glDisable on this cap not supported (0x%X)\n", cap );
        OutputDebugStringA( junk );
#endif
    }
}

void APIENTRY glDisableClientState (GLenum array)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glDisableClientState: 0x%X", array );
#endif
    switch(array)
    {
    case GL_COLOR_ARRAY:
        g_OpenGLValues->m_usecolorary = FALSE;
        break;
    case GL_TEXTURE_COORD_ARRAY:
        g_OpenGLValues->m_usetexcoordary[g_OpenGLValues->m_client_active_texture_arb] = FALSE;
        break;
    case GL_VERTEX_ARRAY:
        g_OpenGLValues->m_usevertexary = FALSE;
        break;
#if DODPFS
    default:
        char junk[256];
        sprintf( junk, "Wrapper: Array not supported (0x%X)\n", array );
        OutputDebugStringA( junk );
#endif
    }
}

void APIENTRY glDrawBuffer (GLenum mode)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glDrawBuffer: 0x%X", mode );
#endif
}

void APIENTRY glEnable (GLenum cap)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glEnable: 0x%X", cap );
#endif
    switch(cap) {
    case GL_LIGHTING:
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_LIGHTING, TRUE);
        break;
    case GL_COLOR_MATERIAL:
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_COLORVERTEX, TRUE);
        break;
    case GL_DEPTH_TEST:
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_ZENABLE, TRUE);
        break;
    case GL_CULL_FACE:
        g_OpenGLValues->m_cullEnabled = TRUE;
        glCullFace(g_OpenGLValues->m_cullMode);
        break;
    case GL_FOG:
        break;
    case GL_BLEND:
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
        break;
    case GL_CLIP_PLANE0:
        g_OpenGLValues->m_clippstate |= 0x01;
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_CLIPPLANEENABLE, g_OpenGLValues->m_clippstate);
        break;
    case GL_CLIP_PLANE1:
        g_OpenGLValues->m_clippstate |= 0x02;
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_CLIPPLANEENABLE, g_OpenGLValues->m_clippstate);
        break;
    case GL_CLIP_PLANE2:
        g_OpenGLValues->m_clippstate |= 0x04;
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_CLIPPLANEENABLE, g_OpenGLValues->m_clippstate);
        break;
    case GL_CLIP_PLANE3:
        g_OpenGLValues->m_clippstate |= 0x08;
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_CLIPPLANEENABLE, g_OpenGLValues->m_clippstate);
        break;
    case GL_CLIP_PLANE4:
        g_OpenGLValues->m_clippstate |= 0x10;
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_CLIPPLANEENABLE, g_OpenGLValues->m_clippstate);
        break;
    case GL_CLIP_PLANE5:
        g_OpenGLValues->m_clippstate |= 0x20;
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_CLIPPLANEENABLE, g_OpenGLValues->m_clippstate);
        break;
    case GL_POLYGON_OFFSET_FILL:
        g_OpenGLValues->m_polyoffset = TRUE;
        glDepthRange(g_OpenGLValues->m_vport.MinZ, g_OpenGLValues->m_vport.MaxZ);
        break;
    case GL_SCISSOR_TEST:
        g_OpenGLValues->m_scissoring = TRUE;
        g_OpenGLValues->m_updvwp = TRUE;
        break;
    case GL_TEXTURE_2D:
        if(g_OpenGLValues->m_curtgt == 0)
            g_OpenGLValues->m_texturing = TRUE;
        else
            g_OpenGLValues->m_mtex = TRUE;
        g_OpenGLValues->m_texHandleValid = FALSE;
        break;
    case GL_ALPHA_TEST:
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
        break;
    case GL_LIGHT0:
        g_OpenGLValues->m_d3ddev->LightEnable(0, TRUE);
        break;
    case GL_LIGHT1:
        g_OpenGLValues->m_d3ddev->LightEnable(1, TRUE);
        break;
    case GL_LIGHT2:
        g_OpenGLValues->m_d3ddev->LightEnable(2, TRUE);
        break;
    case GL_LIGHT3:
        g_OpenGLValues->m_d3ddev->LightEnable(3, TRUE);
        break;
    case GL_LIGHT4:
        g_OpenGLValues->m_d3ddev->LightEnable(4, TRUE);
        break;
    case GL_LIGHT5:
        g_OpenGLValues->m_d3ddev->LightEnable(5, TRUE);
        break;
    case GL_LIGHT6:
        g_OpenGLValues->m_d3ddev->LightEnable(6, TRUE);
        break;
    case GL_LIGHT7:
        g_OpenGLValues->m_d3ddev->LightEnable(7, TRUE);
        break;
    case GL_TEXTURE_GEN_S:
        g_OpenGLValues->m_texgen = TRUE;
        g_OpenGLValues->m_d3ddev->SetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0 | D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR);
        if(g_OpenGLValues->m_usemtex == TRUE)
        {
            g_OpenGLValues->m_d3ddev->SetTextureStageState(1, D3DTSS_TEXCOORDINDEX, 1 | D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR);
        }
        break;
    case GL_TEXTURE_GEN_T:
        break;
#if DODPFS
    default:
        char junk[256];
        sprintf( junk, "Wrapper: glEnable on this cap not supported (0x%X)\n", cap );
        OutputDebugStringA( junk );
#endif
    }
}

void APIENTRY glEnableClientState (GLenum array)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glEnableClientState: 0x%X", array );
#endif
    switch(array)
    {
    case GL_COLOR_ARRAY:
        g_OpenGLValues->m_usecolorary = TRUE;
        break;
    case GL_TEXTURE_COORD_ARRAY:
        g_OpenGLValues->m_usetexcoordary[g_OpenGLValues->m_client_active_texture_arb] = TRUE;
        break;
    case GL_VERTEX_ARRAY:
        g_OpenGLValues->m_usevertexary = TRUE;
        break;
#if DODPFS
    default:
        char junk[256];
        sprintf( junk, "Wrapper: Array not supported (0x%X)\n", array );
        OutputDebugStringA( junk );
#endif
    }
}

void APIENTRY glFogf (GLenum pname, GLfloat param)
{ 
#if GETPARMSFORDEBUG
    char log[256];
    char p[40];
    ftoa( (double)param, p );
    sprintf( log, "glFogf: 0x%X %s", pname, p );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    FLOAT start, end;
    switch(pname)
    {
    case GL_FOG_MODE:
        switch((int)param)
        {
        case GL_LINEAR:
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_FOGTABLEMODE, D3DFOG_LINEAR);
            break;
        case GL_EXP:
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_FOGTABLEMODE, D3DFOG_EXP);
            break;
        case GL_EXP2:
            g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_FOGTABLEMODE, D3DFOG_EXP2);
            break;
        }
        break;
    case GL_FOG_START:
        start = param;
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_FOGSTART, *(DWORD*)(&start));
        break;
    case GL_FOG_END:
        end = param;
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_FOGEND, *(DWORD*)(&end));
        break;
#if DODPFS
    default:
        char junk[256];
        sprintf( junk, "Wrapper: Fog pname not supported  (0x%X)\n", pname );
        OutputDebugStringA( junk );
#endif
    }
}

void APIENTRY glFogi (GLenum pname, GLint param)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glFogi: 0x%X 0x%X", pname, param );
#endif
    glFogf(pname, (GLfloat)param);
}

void APIENTRY glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
#if GETPARMSFORDEBUG
    char log[256];
    char l[40];
    char r[40];
    char b[40];
    char t[40];
    char zn[40];
    char zf[40];
    ftoa( (double)left, l );
    ftoa( (double)right, r );
    ftoa( (double)bottom, b );
    ftoa( (double)top, t );
    ftoa( (double)zNear, zn );
    ftoa( (double)zFar, zf );
    sprintf( log, "glFrustum: %s %s %s %s %s %s", l, r, b, t, zn, zf );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    D3DMATRIX f;
    f._11 = (FLOAT)((2.0 * zNear) / (right - left));
    f._21 = 0.f;
    f._31 = (FLOAT)((right + left) / (right - left));
    f._41 = 0.f;
    f._12 = 0.f;
    f._22 = (FLOAT)((2.0 * zNear) / (top - bottom));
    f._32 = (FLOAT)((top + bottom) / (top - bottom));
    f._42 = 0.f;
    f._13 = 0.f;
    f._23 = 0.f;
    f._33 = (FLOAT)(-(zFar + zNear) / (zFar - zNear));
    f._43 = (FLOAT)(-(2.0 * zFar * zNear) / (zFar - zNear));
    f._14 = 0.f;
    f._24 = 0.f;
    f._34 = -1.f;
    f._44 = 0.f;
    if(g_OpenGLValues->m_matrixMode == D3DTS_TEXTURE0)
    {
        MultiplyMatrix((D3DTRANSFORMSTATETYPE)(g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt), f);
        QuakeSetTransform((D3DTRANSFORMSTATETYPE)(g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt), &g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt]);
    }
    else
    {
        MultiplyMatrix(g_OpenGLValues->m_matrixMode, f);
        QuakeSetTransform(g_OpenGLValues->m_matrixMode, &g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode]);
    }
}

void APIENTRY glGenTextures (GLsizei n, GLuint *textures)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glGenTextures: 0x%X 0x%X", n, textures );
#endif
    for(GLsizei i = 0; i < n; ++i)
    {
        textures[i] = g_OpenGLValues->m_free;
        int t = g_OpenGLValues->m_free;
        g_OpenGLValues->m_free = g_OpenGLValues->m_tex[g_OpenGLValues->m_free].m_next;
        g_OpenGLValues->m_tex[g_OpenGLValues->m_free].m_prev = -1;
        g_OpenGLValues->m_tex[t].m_next = g_OpenGLValues->m_tex[t].m_prev = -1;
    }
}

GLenum APIENTRY glGetError (void)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glGetError" );
#endif
    return GL_NO_ERROR;
}

void APIENTRY glGetFloatv (GLenum pname, GLfloat *params)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glGetFloatv: 0x%X 0x%X", pname, params );
#endif
    switch (pname) {
    case GL_MODELVIEW_MATRIX:
        *((D3DMATRIX*)params) = g_OpenGLValues->m_xfrm[D3DTS_WORLD];
        break;
    case GL_PROJECTION_MATRIX:
        *((D3DMATRIX*)params) = g_OpenGLValues->m_xfrm[D3DTS_PROJECTION];
        break;
#if DODPFS
    default:
        char junk[256];
        sprintf( junk, "Wrapper: Unimplemented GetFloatv query (0x%X)\n", pname );
        OutputDebugStringA( junk );
#endif
    }
}

void APIENTRY glGetIntegerv (GLenum pname, GLint *params)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glGetIntegerv: 0x%X 0x%X", pname, params );
#endif
    switch(pname)
    {
    case GL_MAX_TEXTURE_SIZE:
        *params = max(g_OpenGLValues->m_dd.MaxTextureWidth, g_OpenGLValues->m_dd.MaxTextureHeight);
        break;
    case GL_MAX_ACTIVE_TEXTURES_ARB:
        *params = g_OpenGLValues->m_usemtex ? 2 : 1;
        break;
    case GL_PACK_LSB_FIRST:
    case GL_PACK_SWAP_BYTES:
    case GL_UNPACK_SWAP_BYTES:
    case GL_UNPACK_LSB_FIRST:
        *params = GL_FALSE;
        break;
    case GL_PACK_ROW_LENGTH:
    case GL_UNPACK_ROW_LENGTH:
    case GL_PACK_SKIP_ROWS:
    case GL_PACK_SKIP_PIXELS:
    case GL_UNPACK_SKIP_ROWS:
    case GL_UNPACK_SKIP_PIXELS:
        *params = 0;
        break;
    case GL_PACK_ALIGNMENT:
    case GL_UNPACK_ALIGNMENT:
        *params = 4;
        break;
    case GL_TEXTURE_1D:
        *params = FALSE;
        break;
    case GL_TEXTURE_2D:
        *params = TRUE;
        break;
#if DODPFS
    default:
        char junk[256];
        sprintf( junk, "Wrapper: Unimplemented GetIntegerv query (0x%X)\n", pname );
        OutputDebugStringA( junk );
#endif
    }
}

const GLubyte* APIENTRY glGetString (GLenum name)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glGetString: 0x%X", name );
#endif
    if (!g_OpenGLValues->m_d3ddev)
        return NULL; // No current RC!

    switch(name) {
    case GL_VENDOR:
        return (const GLubyte*)"Microsoft Corp.";
    case GL_RENDERER:
        return (const GLubyte*)"Direct3D";
    case GL_VERSION:
        return (const GLubyte*)"1.1";
    case GL_EXTENSIONS:
        if(g_OpenGLValues->m_usemtex != FALSE)
            return (const GLubyte*)"GL_ARB_multitexture GL_EXT_compiled_vertex_array GL_SGIS_multitexture";
        else
            return (const GLubyte*)"GL_EXT_compiled_vertex_array";
#if DODPFS
    default:
        char junk[256];
        sprintf( junk, "Wrapper: Unimplemented GetString query (0x%X)\n", name );
        OutputDebugStringA( junk );
#endif
    }
    return (const GLubyte*)"";
}

GLboolean APIENTRY glIsTexture (GLuint texture)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glIsTexture: 0x%X", texture );
#endif
    if(texture != 0 && texture < MAXGLTEXHANDLES && g_OpenGLValues->m_tex[texture].m_block != 0)
    {
        return TRUE;
    }
    return FALSE;
}

void APIENTRY glLightf (GLenum light, GLenum pname, GLfloat param)
{  
#if GETPARMSFORDEBUG
    char log[256];
    char p[40];
    ftoa( (double)param, p );
    sprintf( log, "glLightf: 0x%X 0x%X %s", light, pname, p );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    unsigned i = (DWORD)light - GL_LIGHT0;
    switch(pname)
    {
    case GL_SPOT_EXPONENT:
        g_OpenGLValues->m_light[i].Falloff = param;
        break;
    case GL_SPOT_CUTOFF:
        g_OpenGLValues->m_light[i].Phi = param;
        break;
    case GL_CONSTANT_ATTENUATION:
        g_OpenGLValues->m_light[i].Attenuation0 = param;
        break;
    case GL_LINEAR_ATTENUATION:
        g_OpenGLValues->m_light[i].Attenuation1 = param;
        break;
    case GL_QUADRATIC_ATTENUATION:
        g_OpenGLValues->m_light[i].Attenuation2 = param;
        break;
    }
    g_OpenGLValues->m_lightdirty |= (1 << i);
}

void APIENTRY glLightfv (GLenum light, GLenum pname, const GLfloat *params)
{ 
#if GETPARMSFORDEBUG
    char log[256];
    char p[40];
    ftoa( (double)*params, p );
    sprintf( log, "glLightfv: 0x%X 0x%X %s", light, pname, p );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    unsigned i = (DWORD)light - GL_LIGHT0;
    switch(pname)
    {
    case GL_AMBIENT:
        MEMCPY(&g_OpenGLValues->m_light[i].Ambient, params, sizeof(D3DCOLORVALUE));
        break;
    case GL_DIFFUSE:
        MEMCPY(&g_OpenGLValues->m_light[i].Diffuse, params, sizeof(D3DCOLORVALUE));
        break;
    case GL_SPECULAR:
        MEMCPY(&g_OpenGLValues->m_light[i].Specular, params, sizeof(D3DCOLORVALUE));
        break;
    case GL_POSITION:
        MEMCPY(&g_OpenGLValues->m_light[i].Position, params, sizeof(D3DVECTOR));
        g_OpenGLValues->m_lightPositionW[i] = params[3];
        break;
    case GL_SPOT_DIRECTION:
        MEMCPY(&g_OpenGLValues->m_light[i].Direction, params, sizeof(D3DVECTOR));
        break;
    case GL_SPOT_EXPONENT:
        g_OpenGLValues->m_light[i].Falloff = *params;
        break;
    case GL_SPOT_CUTOFF:
        g_OpenGLValues->m_light[i].Phi = *params;
        break;
    case GL_CONSTANT_ATTENUATION:
        g_OpenGLValues->m_light[i].Attenuation0 = *params;
        break;
    case GL_LINEAR_ATTENUATION:
        g_OpenGLValues->m_light[i].Attenuation1 = *params;
        break;
    case GL_QUADRATIC_ATTENUATION:
        g_OpenGLValues->m_light[i].Attenuation2 = *params;
        break;
    }
    g_OpenGLValues->m_lightdirty |= (1 << i);
}

void APIENTRY glLightModelfv (GLenum pname, const GLfloat *params)
{ 
#if GETPARMSFORDEBUG
    char log[256];
    char p[40];
    ftoa( (double)*params, p );
    sprintf( log, "glLightModelfv: 0x%X %s", pname, p );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    static float two55 = 255.f;
    unsigned int R, G, B, A;

    switch(pname)
    {
    case GL_LIGHT_MODEL_AMBIENT:
        R = (unsigned int)(params[0] * two55);
        G = (unsigned int)(params[1] * two55);
        B = (unsigned int)(params[2] * two55);
        A = (unsigned int)(params[3] * two55);
        if(R > 255)
            R = 255;
        if(G > 255)
            G = 255;
        if(B > 255)
            B = 255;
        if(A > 255)
            A = 255;
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_AMBIENT, RGBA_MAKE(R, G, B, A));
        break;
    case GL_LIGHT_MODEL_TWO_SIDE:
#if DODPFS
        if(*params != 0.f)
        {
            OutputDebugStringA("Wrapper: Two sided lighting not supported\n");
        }
#endif
        break;
    case GL_LIGHT_MODEL_LOCAL_VIEWER:
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_LOCALVIEWER, (DWORD)(*params));
        break;
#if DODPFS
    default:
        OutputDebugStringA("Wrapper: LIGHT_MODEL_COLOR_CONTROL not supported\n" );
#endif
    }
}

void APIENTRY glLightModeli (GLenum pname, GLint param)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glLightModeli: 0x%X 0x%X", pname, param );
#endif
    switch(pname)
    {
    case GL_LIGHT_MODEL_TWO_SIDE:
#if DODPFS
        if(param != 0)
        {
            OutputDebugStringA("Wrapper: Two sided lighting not supported\n" );
        }
#endif
        break;
    case GL_LIGHT_MODEL_LOCAL_VIEWER:
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_LOCALVIEWER, param);
        break;
#if DODPFS
    default:
        OutputDebugStringA("Wrapper: LIGHT_MODEL_COLOR_CONTROL not supported\n");
#endif
    }
}

void APIENTRY glLoadMatrixf (const GLfloat *m)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glLoadMatrixf: 0x%X", m );
#endif
    if(g_OpenGLValues->m_matrixMode == D3DTS_TEXTURE0)
    {
        g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt] = *((const D3DMATRIX*)m);
        QuakeSetTransform((D3DTRANSFORMSTATETYPE)(g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt), (const D3DMATRIX*)m);
    }
    else
    {
        g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode] = *((const D3DMATRIX*)m);
        QuakeSetTransform(g_OpenGLValues->m_matrixMode, (const D3DMATRIX*)m);
    }
}

void APIENTRY glLockArraysEXT(GLint first, GLsizei count)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glLockArraysEXT: 0x%X 0x%X", first, count );
#endif
    g_OpenGLValues->m_lckfirst = first;
    g_OpenGLValues->m_lckcount = count;
}

void APIENTRY glMaterialf (GLenum face, GLenum pname, GLfloat param)
{  
#if GETPARMSFORDEBUG
    char log[256];
    char p[40];
    ftoa( (double)param, p );
    sprintf( log, "glMaterialf: 0x%X 0x%X %s", face, pname, p );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    if(face == GL_FRONT || face == GL_FRONT_AND_BACK)
    {
        switch(pname)
        {
        case GL_SHININESS:
            g_OpenGLValues->m_material.Power = param;
            break;
#if DODPFS
        default:
            char junk[256];
            sprintf( junk, "Wrapper: Unimplemented Material (0x%X)\n", pname );
            OutputDebugStringA( junk );
#endif
        }
        g_OpenGLValues->m_d3ddev->SetMaterial(&g_OpenGLValues->m_material);
    }
#if DODPFS
    else
    {
        OutputDebugStringA("Wrapper: Back face material properties ignored\n");
    }
#endif
}

void APIENTRY glMaterialfv (GLenum face, GLenum pname, const GLfloat *params)
{ 
#if GETPARMSFORDEBUG
    char log[256];
    char p[40];
    ftoa( (double)*params, p );
    sprintf( log, "glMaterialfv: 0x%X 0x%X %s", face, pname, p );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    if(face == GL_FRONT || face == GL_FRONT_AND_BACK)
    {
        switch(pname)
        {
        case GL_AMBIENT:
            MEMCPY(&g_OpenGLValues->m_material.Ambient, params, sizeof(D3DCOLORVALUE));
            break;
        case GL_DIFFUSE:
            MEMCPY(&g_OpenGLValues->m_material.Diffuse, params, sizeof(D3DCOLORVALUE));
            break;
        case GL_SPECULAR:
            MEMCPY(&g_OpenGLValues->m_material.Specular, params, sizeof(D3DCOLORVALUE));
            break;
        case GL_EMISSION:
            MEMCPY(&g_OpenGLValues->m_material.Emissive, params, sizeof(D3DCOLORVALUE));
            break;
        case GL_SHININESS:
            g_OpenGLValues->m_material.Power = *params;
            break;
        case GL_AMBIENT_AND_DIFFUSE:
            MEMCPY(&g_OpenGLValues->m_material.Ambient, params, sizeof(D3DCOLORVALUE));
            MEMCPY(&g_OpenGLValues->m_material.Diffuse, params, sizeof(D3DCOLORVALUE));
            break;
#if DODPFS
        default:
            char junk[256];
            sprintf( junk, "Wrapper: Unimplemented Material (0x%X)\n", pname );
            OutputDebugStringA( junk );
#endif
        }
        g_OpenGLValues->m_d3ddev->SetMaterial(&g_OpenGLValues->m_material);
    }
#if DODPFS
    else
    {
        OutputDebugStringA("Wrapper: Back face material properties ignored\n");
    }
#endif
}

void APIENTRY glMTexCoord2fSGIS(GLenum target, GLfloat s, GLfloat t)
{
#if GETPARMSFORDEBUG
    char log[256];
    char ps[40];
    char pt[40];
    ftoa( (double)s, ps );
    ftoa( (double)t, pt );
    sprintf( log, "glMTexCoord2fSGIS: 0x%X %s %s", target, ps, pt );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    if(target == GL_TEXTURE0_SGIS) {
        g_OpenGLValues->m_tu = s;
        g_OpenGLValues->m_tv = t;
    }
    else {
        g_OpenGLValues->m_tu2 = s;
        g_OpenGLValues->m_tv2 = t;
    }
}

void APIENTRY glMultiTexCoord2fARB (GLenum texture, GLfloat s, GLfloat t)
{
#if GETPARMSFORDEBUG
    char log[256];
    char ps[40];
    char pt[40];
    ftoa( (double)s, ps );
    ftoa( (double)t, pt );
    sprintf( log, "glMultiTexCoord2fARB: 0x%X %s %s", texture, ps, pt );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    if(texture == GL_TEXTURE0_ARB) 
    {
        g_OpenGLValues->m_tu = s;
        g_OpenGLValues->m_tv = t;
    }
    else 
    {
        g_OpenGLValues->m_tu2 = s;
        g_OpenGLValues->m_tv2 = t;
    }
}

void APIENTRY glMultiTexCoord2fvARB (GLenum texture, const GLfloat *t)
{
#if GETPARMSFORDEBUG
    char log[256];
    char ps[40];
    char pt[40];
    ftoa( (double)t[0], ps );
    ftoa( (double)t[1], pt );
    sprintf( log, "glMultiTexCoord2fvARB: 0x%X %s %s", texture, ps, pt );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    if(texture == GL_TEXTURE0_ARB) 
    {
        g_OpenGLValues->m_tu = t[0];
        g_OpenGLValues->m_tv = t[1];
    }
    else 
    {
        g_OpenGLValues->m_tu2 = t[0];
        g_OpenGLValues->m_tv2 = t[1];
    }
}

void APIENTRY glMultMatrixd (const GLdouble *m)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glMultMatrixd: 0x%X", m );
#endif
    D3DMATRIX f;
    for(unsigned i = 0; i < 16; ++i)
    {
        ((FLOAT*)&f)[i] = (FLOAT)m[i];
    }
    if(g_OpenGLValues->m_matrixMode == D3DTS_TEXTURE0)
    {
        MultiplyMatrix((D3DTRANSFORMSTATETYPE)(g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt), f);
        QuakeSetTransform((D3DTRANSFORMSTATETYPE)(g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt), &g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt]);
    }
    else
    {
        MultiplyMatrix(g_OpenGLValues->m_matrixMode, f);
        QuakeSetTransform(g_OpenGLValues->m_matrixMode, &g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode]);
    }
}

void APIENTRY glMultMatrixf (const GLfloat *m)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glMultMatrixf: 0x%X", m );
#endif
    if(g_OpenGLValues->m_matrixMode == D3DTS_TEXTURE0)
    {
        MultiplyMatrix((D3DTRANSFORMSTATETYPE)(g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt), *((const D3DMATRIX*)m));
        QuakeSetTransform((D3DTRANSFORMSTATETYPE)(g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt), &g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt]);
    }
    else
    {
        MultiplyMatrix(g_OpenGLValues->m_matrixMode, *((const D3DMATRIX*)m));
        QuakeSetTransform(g_OpenGLValues->m_matrixMode, &g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode]);
    }
}

void APIENTRY glNormal3bv (const GLbyte *v)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glNormal3bv: 0x%X 0x%X 0x%X", v[0], v[1], v[2] );
#endif
    g_OpenGLValues->m_nx = v[0];
    g_OpenGLValues->m_ny = v[1];
    g_OpenGLValues->m_nz = v[2];
}

void APIENTRY glNormal3fv (const GLfloat *v)
{ 
#if GETPARMSFORDEBUG
    char log[256];
    char v0[40];
    char v1[40];
    char v2[40];
    ftoa( (double)v[0], v0 );
    ftoa( (double)v[1], v1 );
    ftoa( (double)v[2], v2 );
    sprintf( log, "glNormal3fv: %s %s %s", v0, v1, v2 );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    g_OpenGLValues->m_nx = v[0];
    g_OpenGLValues->m_ny = v[1];
    g_OpenGLValues->m_nz = v[2];
}

void APIENTRY glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
#if GETPARMSFORDEBUG
    char log[256];
    char l[40], r[40], b[40], t[40], zn[40], zf[40];
    ftoa( (double)left, l );
    ftoa( (double)right, r );
    ftoa( (double)bottom, b );
    ftoa( (double)top, t );
    ftoa( (double)zNear, zn );
    ftoa( (double)zFar, zf );
    sprintf( log, "glOrtho: %s %s %s %s %s %s", l, r, b, t, zn, zf );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    D3DMATRIX f;
    f._11 = (FLOAT)(2.0 / (right - left));
    f._21 = 0.f;
    f._31 = 0.f;
    f._41 = (FLOAT)(-(right + left) / (right - left));
    f._12 = 0.f;
    f._22 = (FLOAT)(2.0 / (top - bottom));
    f._32 = 0.f;
    f._42 = (FLOAT)(-(top + bottom) / (top - bottom));
    f._13 = 0.f;
    f._23 = 0.f;
    f._33 = (FLOAT)(-2.0 / (zFar - zNear));
    f._43 = (FLOAT)(-(zFar + zNear) / (zFar - zNear));
    f._14 = 0.f;
    f._24 = 0.f;
    f._34 = 0.f;
    f._44 = 1.f;
    if(g_OpenGLValues->m_matrixMode == D3DTS_TEXTURE0)
    {
        MultiplyMatrix((D3DTRANSFORMSTATETYPE)(g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt), f);
        QuakeSetTransform((D3DTRANSFORMSTATETYPE)(g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt), &g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt]);
    }
    else
    {
        MultiplyMatrix(g_OpenGLValues->m_matrixMode, f);
        QuakeSetTransform(g_OpenGLValues->m_matrixMode, &g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode]);
    }
}

void APIENTRY glPolygonMode (GLenum face, GLenum mode)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glPolygonMode: 0x%X 0x%X", face, mode );
#endif
    int statevalue=-1;
    switch(mode) {
    case GL_POINT:
        statevalue=D3DFILL_POINT;
        break;
    case GL_LINE:
        statevalue=D3DFILL_WIREFRAME; 
        break;
    case GL_FILL:
        statevalue=D3DFILL_SOLID;
        break;
    }
    if(statevalue >= 0) {
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_FILLMODE, (DWORD)statevalue);
    }
}

void APIENTRY glPolygonOffset (GLfloat factor, GLfloat units)
{ 
#if GETPARMSFORDEBUG
    char log[256];
    char f[40];
    char u[40];
    ftoa( (double)factor, f );
    ftoa( (double)units, u );
    sprintf( log, "glPolygonOffset: %s %s", f, u );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
}

void APIENTRY glPopAttrib (void)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glPopAttrib" );
#endif
    g_OpenGLValues->m_d3ddev->ApplyStateBlock(g_OpenGLValues->m_cbufbit);
}

void APIENTRY glPopMatrix (void)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glPopMatrix" );
#endif
    if(g_OpenGLValues->m_matrixMode == D3DTS_WORLD) {
        if(g_OpenGLValues->m_matrixStack[0].length() == 0)
            return;
        LListManip<D3DMATRIX> m(&g_OpenGLValues->m_matrixStack[0]);
        g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode] = m();
        QuakeSetTransform(g_OpenGLValues->m_matrixMode, &(m()));
        m.remove();
    }
    else if(g_OpenGLValues->m_matrixMode == D3DTS_PROJECTION) {
        if(g_OpenGLValues->m_matrixStack[1].length() == 0)
            return;
        LListManip<D3DMATRIX> m(&g_OpenGLValues->m_matrixStack[1]);
        g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode] = m();
        QuakeSetTransform(g_OpenGLValues->m_matrixMode, &(m()));
        m.remove();
    }
    else {
        if(g_OpenGLValues->m_matrixStack[2 + g_OpenGLValues->m_curtgt].length() == 0)
            return;
        LListManip<D3DMATRIX> m(&g_OpenGLValues->m_matrixStack[2 + g_OpenGLValues->m_curtgt]);
        g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt] = m();
        QuakeSetTransform((D3DTRANSFORMSTATETYPE)(g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt), &(m()));
        m.remove();
    }
}

void APIENTRY glPushAttrib (GLbitfield mask)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glPushAttrib: 0x%X", mask );
#endif
    if(mask & GL_COLOR_BUFFER_BIT)
    {
        g_OpenGLValues->m_d3ddev->CaptureStateBlock(g_OpenGLValues->m_cbufbit);
    }
#if DODPFS
    else
    {
        char junk[256];
        sprintf( junk, "Wrapper: Attrib push not implemented (0x%X)\n", mask );
        OutputDebugStringA( junk );
    }
#endif
}

void APIENTRY glPushMatrix (void)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glPushMatrix" );
#endif
    if(g_OpenGLValues->m_matrixMode == D3DTS_WORLD)
    {
        g_OpenGLValues->m_matrixStack[0].prepend(g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode]);
    }
    else if(g_OpenGLValues->m_matrixMode == D3DTS_PROJECTION)
    {
        g_OpenGLValues->m_matrixStack[1].prepend(g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode]);
    }
    else
    {
        g_OpenGLValues->m_matrixStack[2 + g_OpenGLValues->m_curtgt].prepend(g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt]);
    }
}

void APIENTRY glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
#if GETPARMSFORDEBUG
    char log[256];
    char va[40];
    char vx[40];
    char vy[40];
    char vz[40];
    ftoa( (double)angle, va );
    ftoa( (double)x, vx );
    ftoa( (double)y, vy );
    ftoa( (double)z, vz );
    sprintf( log, "glRotatef: %s %s %s %s", va, vx, vy, vz );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    if(angle == 0.f)
    {
        // Early out for Quake II engine since angle = 0 does not prevent the matrix from getting bad when x, y & z are 0.
        return;
    }
    float u[3];
    double norm = sqrt(x * x + y * y + z * z);
    u[0] = (float)(x / norm);
    u[1] = (float)(y / norm);
    u[2] = (float)(z / norm);
    double ra = angle * PI / 180.f;
    float ca = (float)cos(ra);
    float sa = (float)sin(ra);
    D3DMATRIX s;
    s._11 = 0.f; s._21 = -u[2]; s._31 = u[1];
    s._12 = u[2]; s._22 = 0.f; s._32 = -u[0];
    s._13 = -u[1]; s._23 = u[0]; s._33 = 0.f;
    D3DMATRIX uu;
    uu._11 = u[0] * u[0]; uu._21 = u[0] * u[1]; uu._31 = u[0] * u[2];
    uu._12 = u[1] * u[0]; uu._22 = u[1] * u[1]; uu._32 = u[1] * u[2];
    uu._13 = u[2] * u[0]; uu._23 = u[2] * u[1]; uu._33 = u[2] * u[2];
    D3DMATRIX r;
    r._11 = uu._11 + ca * (1.f - uu._11) + sa * s._11;
    r._21 = uu._21 + ca * (0.f - uu._21) + sa * s._21;
    r._31 = uu._31 + ca * (0.f - uu._31) + sa * s._31;
    r._41 = 0.f;
    r._12 = uu._12 + ca * (0.f - uu._12) + sa * s._12;
    r._22 = uu._22 + ca * (1.f - uu._22) + sa * s._22;
    r._32 = uu._32 + ca * (0.f - uu._32) + sa * s._32;
    r._42 = 0.f;
    r._13 = uu._13 + ca * (0.f - uu._13) + sa * s._13;
    r._23 = uu._23 + ca * (0.f - uu._23) + sa * s._23;
    r._33 = uu._33 + ca * (1.f - uu._33) + sa * s._33;
    r._43 = 0.f;
    r._14 = 0.f;
    r._24 = 0.f;
    r._34 = 0.f;
    r._44 = 1.f;
    if(g_OpenGLValues->m_matrixMode == D3DTS_TEXTURE0)
    {
        MultiplyMatrix((D3DTRANSFORMSTATETYPE)(g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt), r);
        QuakeSetTransform((D3DTRANSFORMSTATETYPE)(g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt), &g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt]);
    }
    else
    {
        MultiplyMatrix(g_OpenGLValues->m_matrixMode, r);
        QuakeSetTransform(g_OpenGLValues->m_matrixMode, &g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode]);
    }
}

void APIENTRY glScalef (GLfloat x, GLfloat y, GLfloat z)
{
#if GETPARMSFORDEBUG
    char log[256];
    char vx[40];
    char vy[40];
    char vz[40];
    ftoa( (double)x, vx );
    ftoa( (double)y, vy );
    ftoa( (double)z, vz );
    sprintf( log, "glScalef: %s %s %s", vx, vy, vz );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    D3DMATRIX f;
    f._11 =   x; f._21 = 0.f; f._31 = 0.f; f._41 = 0.f;
    f._12 = 0.f; f._22 =   y; f._32 = 0.f; f._42 = 0.f; 
    f._13 = 0.f; f._23 = 0.f; f._33 =   z; f._43 = 0.f;
    f._14 = 0.f; f._24 = 0.f; f._34 = 0.f; f._44 = 1.f;
    if(g_OpenGLValues->m_matrixMode == D3DTS_TEXTURE0)
    {
        MultiplyMatrix((D3DTRANSFORMSTATETYPE)(g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt), f);
        QuakeSetTransform((D3DTRANSFORMSTATETYPE)(g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt), &g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt]);
    }
    else
    {
        MultiplyMatrix(g_OpenGLValues->m_matrixMode, f);
        QuakeSetTransform(g_OpenGLValues->m_matrixMode, &g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode]);
    }
}

void APIENTRY glScissor (GLint x, GLint y, GLsizei width, GLsizei height)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glScissor: 0x%X 0x%X 0x%X 0x%X", x, y, width, height );
#endif

    RECT wrect, screct, xrect;

    wrect.left = 0;
    wrect.top = 0;
    wrect.right = g_OpenGLValues->m_winWidth;
    wrect.bottom = g_OpenGLValues->m_winHeight;
    
    screct.left = x;
    screct.top = y;
    screct.right = x + width;
    screct.bottom = y + height;
    
    IntersectRect(&xrect, &wrect, &screct);

//    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glScissor: %d %d %d %d WRECT: %d %d %d %d SCRECT: %d %d %d %d XRECT %d %d %d %d", x, y, width, height, wrect.left, wrect.top, wrect.right, wrect.bottom, screct.left, screct.top, screct.right, screct.bottom, xrect.left, xrect.top, xrect.right, xrect.bottom );

    g_OpenGLValues->m_scix = xrect.left;
    g_OpenGLValues->m_sciy = xrect.top;
    g_OpenGLValues->m_sciw = xrect.right - xrect.left;
    g_OpenGLValues->m_scih = xrect.bottom - xrect.top;
    g_OpenGLValues->m_updvwp = TRUE;
}

void APIENTRY glSelectTextureSGIS(GLenum target)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glSelectTextureSGIS: 0x%X", target );
#endif
    g_OpenGLValues->m_curtgt = target == GL_TEXTURE0_SGIS ? 0 : 1;
}

void APIENTRY glShadeModel (GLenum mode)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glShadeModel: 0x%X", mode );
#endif
    if(mode == GL_SMOOTH)
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
    else
        g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_FLAT);
}

void APIENTRY glTexCoord2f (GLfloat s, GLfloat t)
{
#if GETPARMSFORDEBUG
    char log[256];
    char ps[40];
    char pt[40];
    ftoa( (double)s, ps );
    ftoa( (double)t, pt );
    sprintf( log, "glTexCoord2f: %s %s", ps, pt );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    g_OpenGLValues->m_tu = s;
    g_OpenGLValues->m_tv = t;
}

void APIENTRY glTexCoord2fv (const GLfloat *t)
{ 
#if GETPARMSFORDEBUG
    char log[256];
    char ps[40];
    char pt[40];
    ftoa( (double)t[0], ps );
    ftoa( (double)t[1], pt );
    sprintf( log, "glTexCoord2fv: %s %s", ps, pt );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    g_OpenGLValues->m_tu = t[0];
    g_OpenGLValues->m_tv = t[1];
}

void APIENTRY glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glTexCoordPointer: 0x%X 0x%X 0x%X 0x%X", size, type, stride, pointer );
#endif
    if(size == 2 && type == GL_FLOAT)
        g_OpenGLValues->m_texcoordary[g_OpenGLValues->m_client_active_texture_arb] = (GLfloat*)pointer;
#if DODPFS
    else
    {
        char junk[256];
        sprintf( junk, "TexCoord array not supported (size:0x%X type:0x%X)\n", size, type );
        OutputDebugStringA( junk );
    }
#endif
    if(stride == 0)
    {
        stride = 8;
    }
    g_OpenGLValues->m_texcoordarystride[g_OpenGLValues->m_client_active_texture_arb] = stride;
}

void APIENTRY glTexEnvf (GLenum target, GLenum pname, GLfloat param)
{
#if GETPARMSFORDEBUG
    char log[256];
    sprintf( log, "glTexEnvf: 0x%X 0x%X 0x%X", target, pname, (int)param );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    if(pname == GL_TEXTURE_ENV_MODE) {
        g_OpenGLValues->m_blendmode[g_OpenGLValues->m_curtgt] = (int)param;
        g_OpenGLValues->m_texHandleValid = FALSE;
    }
#if DODPFS
    else
    {
        char junk[256];
        sprintf( junk, "Wrapper: GL_TEXTURE_ENV_COLOR not implemented (0x%X)\n", pname );
        OutputDebugStringA( junk );
    }
#endif
}

void APIENTRY glTexEnvi (GLenum target, GLenum pname, GLint param)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glTexEnvi: 0x%X 0x%X 0x%X", target, pname, param );
#endif
    if(pname == GL_TEXTURE_ENV_MODE) {
        g_OpenGLValues->m_blendmode[g_OpenGLValues->m_curtgt] = param;
        g_OpenGLValues->m_texHandleValid = FALSE;
    }
#if DODPFS
    else
    {
        char junk[256];
        sprintf( junk, "Wrapper: GL_TEXTURE_ENV_COLOR not implemented (0x%X)\n", pname );
        OutputDebugStringA( junk );
    }
#endif
}

void APIENTRY glTexGeni (GLenum coord, GLenum pname, GLint param)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glTexGeni: 0x%X 0x%X 0x%X", coord, pname, param );
#endif
    if(coord == GL_S)
    {
        if(pname == GL_TEXTURE_GEN_MODE)
        {
            if(param == GL_SPHERE_MAP)
            {
                g_OpenGLValues->m_d3ddev->SetTextureStageState(g_OpenGLValues->m_curtgt, D3DTSS_TEXCOORDINDEX, g_OpenGLValues->m_curtgt | D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR);
            }
#if DODPFS
            else
            {
                char junk[256];
                sprintf( junk, "Wrapper: TexGen param not implemented (0x%X)\n", param );
                OutputDebugStringA( junk );
            }
#endif
        }
#if DODPFS
        else
        {
            char junk[256];
            sprintf( junk, "Wrapper: TexGen pname not implemented (0x%X)\n", pname );
            OutputDebugStringA( junk );
        }
#endif
    }
}

void APIENTRY glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei glwidth, GLsizei glheight, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glTexImage2D: 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X", target, level, internalformat, glwidth, glheight, border, format, type, pixels );
#endif
    DWORD width, height;
    TexInfo &ti = g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]];
    if(ti.m_next >= 0)
    {
        if(ti.m_prev < 0)
        {
            g_OpenGLValues->m_free = ti.m_next;
            g_OpenGLValues->m_tex[ti.m_next].m_prev = ti.m_prev;
            ti.m_next = ti.m_prev = -1;
        }
        else
        {
            g_OpenGLValues->m_tex[ti.m_prev].m_next = ti.m_next;
            g_OpenGLValues->m_tex[ti.m_next].m_prev = ti.m_prev;
            ti.m_next = ti.m_prev = -1;
        }
    }
    
    /* See if texture needs to be subsampled */
    if(g_OpenGLValues->m_subsample) {
        if(glwidth > 256 || glheight > 256) {
            if(glwidth > glheight) {
                width = 256;
                height = (glheight * 256) / glwidth;
            }
            else {
                height = 256;
                width = (glwidth * 256) / glheight;
            }
        }
        else {
            width = glwidth;
            height = glheight;
        }
    }
    else {
        width = glwidth;
        height = glheight;
    }
    
    /* See if texture needs to be square */
    if(g_OpenGLValues->m_makeSquare) {
        if(height > width) {
            width = height;
        }
        else {
            height = width;
        }
    }
    
    if(level == 0) {
        IDirect3DTexture8 *ddsurf;
        D3DFORMAT fmt;
        switch(internalformat) {
        case 1:
        case GL_LUMINANCE:
        case GL_LUMINANCE8:
            fmt = g_OpenGLValues->m_ddLuminanceSurfFormat;
            break;
        case 3:
        case GL_RGB:
        case GL_RGB5:
            fmt = g_OpenGLValues->m_ddFiveBitSurfFormat;
            break;
        case 4:
        case GL_RGBA:
        case GL_RGBA4:
            fmt = g_OpenGLValues->m_ddFourBitAlphaSurfFormat;
            break;
        case GL_RGB8:
            fmt = g_OpenGLValues->m_ddEightBitSurfFormat;
            break;
        case GL_RGBA8:
            fmt = g_OpenGLValues->m_ddEightBitAlphaSurfFormat;
            break;
        case GL_ALPHA:
        case GL_ALPHA8:
            fmt = g_OpenGLValues->m_ddEightBitAlphaOnlySurfFormat;
            break;
        default:
#if DODPFS
            char junk[256];
            sprintf( junk, "Wrapper: Unimplemented internalformat (0x%X)\n", internalformat );
            OutputDebugStringA( junk );
#endif
            return;
        }

        HRESULT ddrval = g_OpenGLValues->m_d3ddev->CreateTexture(width, 
                                                  height, 
                                                  1,                // levels
                                                  0,                
                                                  fmt, 
                                                  D3DPOOL_MANAGED, 
                                                  &ddsurf);
        if (FAILED(ddrval)) 
        {
#if DODPFS
            char junk[256];
            sprintf( junk, "Wrapper: CreateTexture failed (0x%X)\n", ddrval );
            OutputDebugStringA( junk );
#endif
            return;
        }
        LPDIRECT3DSURFACE8 pLevel;
        ddrval = ddsurf->GetSurfaceLevel(0, &pLevel);
        if (FAILED(ddrval)) 
        {
#if DODPFS
            char junk[256];
            sprintf( junk, "Wrapper: Failed to retrieve surface (0x%X)\n", ddrval );
            OutputDebugStringA( junk );
#endif
            return;
        }
        
        LoadSurface(pLevel, format, internalformat, glwidth, glheight, width, height, (const DWORD*)pixels);
        pLevel->Release();
        if(ti.m_ddsurf != 0) {
            ti.m_ddsurf->Release();
        }
        ti.m_dwStage = g_OpenGLValues->m_curtgt;
        ti.m_fmt = fmt;
        ti.m_internalformat = internalformat;
        ti.m_width = width;
        ti.m_height = height;
        ti.m_ddsurf = ddsurf;
        ti.m_oldwidth = glwidth;
        ti.m_oldheight = glheight;
        if(ti.m_block == 0)
        {
            g_OpenGLValues->m_d3ddev->BeginStateBlock();
            g_OpenGLValues->m_d3ddev->SetTextureStageState (g_OpenGLValues->m_curtgt, D3DTSS_ADDRESSU,ti.m_addu);
            g_OpenGLValues->m_d3ddev->SetTextureStageState (g_OpenGLValues->m_curtgt, D3DTSS_ADDRESSV,ti.m_addv);
            g_OpenGLValues->m_d3ddev->SetTextureStageState (g_OpenGLValues->m_curtgt, D3DTSS_MAGFILTER,ti.m_magmode);
            g_OpenGLValues->m_d3ddev->SetTextureStageState (g_OpenGLValues->m_curtgt, D3DTSS_MINFILTER,ti.m_minmode);
            g_OpenGLValues->m_d3ddev->SetTextureStageState (g_OpenGLValues->m_curtgt, D3DTSS_MIPFILTER,ti.m_mipmode);
            g_OpenGLValues->m_d3ddev->SetTexture(g_OpenGLValues->m_curtgt, ti.m_ddsurf);
            g_OpenGLValues->m_d3ddev->EndStateBlock(&ti.m_block);
            ti.m_capture = FALSE;
        }
        else
        {
            ti.m_capture = TRUE;
        }
    }
    else if(level == 1 && g_OpenGLValues->m_usemipmap) { // oops, a mipmap
        IDirect3DTexture8 *ddsurf;
        LPDIRECT3DSURFACE8 pLevel, pSrcLevel;

        HRESULT ddrval = g_OpenGLValues->m_d3ddev->CreateTexture(ti.m_width, 
                                                  ti.m_height, 
                                                  miplevels(ti.m_width, ti.m_height), 
                                                  0, 
                                                  ti.m_fmt, 
                                                  D3DPOOL_MANAGED, 
                                                  &ddsurf);
        if (FAILED(ddrval)) {
#if DODPFS
            char junk[256];
            sprintf( junk, "Wrapper: CreateTexture failed (0x%X)\n", ddrval );
            OutputDebugStringA( junk );
#endif
            return;
        }
        ddsurf->GetSurfaceLevel(0, &pLevel);
        ti.m_ddsurf->GetSurfaceLevel(0, &pSrcLevel);
        ddrval = g_OpenGLValues->m_d3ddev->CopyRects(pSrcLevel, NULL, 0, pLevel, NULL);
        if(FAILED(ddrval))
        {
#if DODPFS
            char junk[256];
            sprintf( junk, "Wrapper: CopyRects failed (0x%X)\n", ddrval );
            OutputDebugStringA( junk );
#endif
            return;
        }
        pLevel->Release();
        pSrcLevel->Release();
        ti.m_ddsurf->Release();
        ti.m_ddsurf = ddsurf;
        ti.m_ddsurf->GetSurfaceLevel(1, &pLevel);
        LoadSurface(pLevel, format, internalformat, glwidth, glheight, width, height, (const DWORD*)pixels);
        pLevel->Release();
        ti.m_capture = TRUE;
    }
    else if(g_OpenGLValues->m_usemipmap) {
        if (ti.m_ddsurf!=NULL)
        {
            LPDIRECT3DSURFACE8 pLevel;
            ti.m_ddsurf->GetSurfaceLevel(level, &pLevel);
            LoadSurface(pLevel, format, internalformat, glwidth, glheight, width, height, (const DWORD*)pixels);
            pLevel->Release();
        }
#if DODPFS
        else
        {
            char junk[256];
            sprintf( junk, "NULL surface pointer %d %d %d %d %d %d %d\n", level, ti.m_width, ti.m_height, glwidth, glheight, width, height );
            OutputDebugStringA( junk );
        }
#endif
    }
    g_OpenGLValues->m_texHandleValid = FALSE;
}

void APIENTRY glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glTexSubImage2D: 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X", target, level, xoffset, yoffset, width, height, format, type, pixels );
#endif
    if(level > 1 && !g_OpenGLValues->m_usemipmap)
        return;
    
	TexInfo &ti = g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]];
    
	RECT subimage;
        LPDIRECT3DSURFACE8 pLevel;
    
	HRESULT ddrval = ti.m_ddsurf->GetSurfaceLevel(level, &pLevel);
    
	if (FAILED(ddrval)) 
        {
#if DODPFS
            char junk[256];
            sprintf( junk, "Wrapper: Failed to retrieve surface (0x%X)\n", ddrval );
            OutputDebugStringA( junk );
#endif
            return;
        }
    
	xoffset = (xoffset * ti.m_width) / ti.m_oldwidth;
        yoffset = (yoffset * ti.m_height) / ti.m_oldheight;
    
	SetRect(&subimage, xoffset, yoffset, 
            (width * ti.m_width) / ti.m_oldwidth + xoffset, 
            (height * ti.m_height) / ti.m_oldheight + yoffset);
    
	ddrval = LoadSubSurface( pLevel, format, ti.m_internalformat, width, height, (const DWORD*)pixels, &subimage );
	if (FAILED(ddrval)) {
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: LoadSubSurface Failure (0x%X)\n", ddrval );
        OutputDebugStringA( junk );
#endif
//        return;
    }
    
	pLevel->Release();
}		

void APIENTRY glTexParameterf (GLenum target, GLenum pname, GLfloat param)
{
#if GETPARMSFORDEBUG
    char log[256];
    sprintf( log, "glTexParameterf: 0x%X 0x%X 0x%X", target, pname, (int)param );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    switch(pname) {
    case GL_TEXTURE_MIN_FILTER:
        switch((int)param) {
        case GL_NEAREST:
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_minmode = D3DTEXF_POINT;
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_mipmode = D3DTEXF_NONE;
            break;
        case GL_LINEAR:
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_minmode = D3DTEXF_LINEAR;
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_mipmode = D3DTEXF_NONE;
            break;
        case GL_NEAREST_MIPMAP_NEAREST:
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_minmode = D3DTEXF_POINT;
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_mipmode = D3DTEXF_POINT;
            break;
        case GL_NEAREST_MIPMAP_LINEAR:
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_minmode = D3DTEXF_POINT;
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_mipmode = D3DTEXF_LINEAR;
            break;
        case GL_LINEAR_MIPMAP_NEAREST:
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_minmode = D3DTEXF_LINEAR;
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_mipmode = D3DTEXF_POINT;
            break;
        case GL_LINEAR_MIPMAP_LINEAR:
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_minmode = D3DTEXF_LINEAR;
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_mipmode = D3DTEXF_LINEAR;
            break;
        }
        break;
    case GL_TEXTURE_MAG_FILTER:
        if((int)param == GL_NEAREST)
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_magmode = D3DTEXF_POINT;
        else
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_magmode = D3DTEXF_LINEAR;
        break;
    case GL_TEXTURE_WRAP_S:
        if((int)param == GL_CLAMP)
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_addu = D3DTADDRESS_CLAMP;
        else
            //GL_REPEAT falls here
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_addu = D3DTADDRESS_WRAP;
        break;
    case GL_TEXTURE_WRAP_T:
        if((int)param == GL_CLAMP)
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_addv = D3DTADDRESS_CLAMP;
        else
            //GL_REPEAT falls here
            g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_addv = D3DTADDRESS_WRAP;
        break;
    }
    g_OpenGLValues->m_tex[g_OpenGLValues->m_curstagebinding[g_OpenGLValues->m_curtgt]].m_capture = TRUE;
    g_OpenGLValues->m_texHandleValid = FALSE;
}

void APIENTRY glTexParameteri (GLenum target, GLenum pname, GLint param)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glTexParameteri: 0x%X 0x%X 0x%X", target, pname, param );
#endif
    glTexParameterf(target, pname, (GLfloat)param);
}

void APIENTRY glTranslatef (GLfloat x, GLfloat y, GLfloat z)
{
#if GETPARMSFORDEBUG
    char log[256];
    char vx[40];
    char vy[40];
    char vz[40];
    ftoa( (double)x, vx );
    ftoa( (double)y, vy );
    ftoa( (double)z, vz );
    sprintf( log, "glTranslatef: %s %s %s", vx, vy, vz );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    D3DMATRIX f;
    f._11 = 1.f; f._21 = 0.f; f._31 = 0.f; f._41 = x;
    f._12 = 0.f; f._22 = 1.f; f._32 = 0.f; f._42 = y;
    f._13 = 0.f; f._23 = 0.f; f._33 = 1.f; f._43 = z;
    f._14 = 0.f; f._24 = 0.f; f._34 = 0.f; f._44 = 1.f;
    if(g_OpenGLValues->m_matrixMode == D3DTS_TEXTURE0)
    {
        MultiplyMatrix((D3DTRANSFORMSTATETYPE)(g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt), f);
        QuakeSetTransform((D3DTRANSFORMSTATETYPE)(g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt), &g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode + g_OpenGLValues->m_curtgt]);
    }
    else
    {
        MultiplyMatrix(g_OpenGLValues->m_matrixMode, f);
        QuakeSetTransform(g_OpenGLValues->m_matrixMode, &g_OpenGLValues->m_xfrm[g_OpenGLValues->m_matrixMode]);
    }
}

void APIENTRY glUnlockArraysEXT()
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glUnlockArraysEXT" );
#endif
    g_OpenGLValues->m_lckfirst = 0;
    g_OpenGLValues->m_lckcount = 0;
}

void APIENTRY glVertex2d (GLdouble x, GLdouble y)
{ 
#if GETPARMSFORDEBUG
    char log[256];
    char vx[40];
    char vy[40];
    ftoa( (double)x, vx );
    ftoa( (double)y, vy );
    sprintf( log, "glVertex2d: %s %s", vx, vy );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat)x;
    *(d3dv++) = (GLfloat)y;
    *(d3dv++) = 0.f;
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex2dv (const GLdouble *v)
{ 
#if GETPARMSFORDEBUG
    char log[256];
    char vx[40];
    char vy[40];
    ftoa( (double)v[0], vx );
    ftoa( (double)v[1], vy );
    sprintf( log, "glVertex2dv: %s %s", vx, vy );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat)*(v++);
    *(d3dv++) = (GLfloat)*(v++);
    *(d3dv++) = 0.f;
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex2f (GLfloat x, GLfloat y)
{
#if GETPARMSFORDEBUG
    char log[256];
    char vx[40];
    char vy[40];
    ftoa( (double)x, vx );
    ftoa( (double)y, vy );
    sprintf( log, "glVertex2f: %s %s", vx, vy );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = x;
    *(d3dv++) = y;
    *(d3dv++) = 0.f;
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex2fv (const GLfloat *v)
{ 
#if GETPARMSFORDEBUG
    char log[256];
    char vx[40];
    char vy[40];
    ftoa( (double)v[0], vx );
    ftoa( (double)v[1], vy );
    sprintf( log, "glVertex2fv: %s %s", vx, vy );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = *(v++);
    *(d3dv++) = *(v++);
    *(d3dv++) = 0.f;
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex2i (GLint x, GLint y)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glVertex2i: %d %d", x, y );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat)x;
    *(d3dv++) = (GLfloat)y;
    *(d3dv++) = 0.f;
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex2iv (const GLint *v)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glVertex2iv: %d %d", v[0], v[1] );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat) *(v++);
    *(d3dv++) = (GLfloat) *(v++);
    *(d3dv++) = 0.f;
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex2s (GLshort x, GLshort y)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glVertex2s: %d %d", x, y );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat)x;
    *(d3dv++) = (GLfloat)y;
    *(d3dv++) = 0.f;
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex2sv (const GLshort *v)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glVertex2sv: %s %s", v[0], v[1] );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat) *(v++);
    *(d3dv++) = (GLfloat) *(v++);
    *(d3dv++) = 0.f;
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex3d (GLdouble x, GLdouble y, GLdouble z)
{ 
#if GETPARMSFORDEBUG
    char log[256];
    char vx[40];
    char vy[40];
    char vz[40];
    ftoa( (double)x, vx );
    ftoa( (double)y, vy );
    ftoa( (double)z, vz );
    sprintf( log, "glVertex3d: %s %s %s", vx, vy, vz );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat) x;
    *(d3dv++) = (GLfloat) y;
    *(d3dv++) = (GLfloat) z;
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex3dv (const GLdouble *v)
{ 
#if GETPARMSFORDEBUG
    char log[256];
    char vx[40];
    char vy[40];
    char vz[40];
    ftoa( (double)v[0], vx );
    ftoa( (double)v[1], vy );
    ftoa( (double)v[2], vz );
    sprintf( log, "glVertex3dv: %s %s %s", vx, vy, vz );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat) *(v++);
    *(d3dv++) = (GLfloat) *(v++);
    *(d3dv++) = (GLfloat) *(v++);
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex3f (GLfloat x, GLfloat y, GLfloat z)
{
#if GETPARMSFORDEBUG
    char log[256];
    char vx[40];
    char vy[40];
    char vz[40];
    ftoa( (double)x, vx );
    ftoa( (double)y, vy );
    ftoa( (double)z, vz );
    sprintf( log, "glVertex3f: %s %s %s", vx, vy, vz );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = x;
    *(d3dv++) = y;
    *(d3dv++) = z;
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex3fv (const GLfloat *v)
{
#if GETPARMSFORDEBUG
    char log[256];
    char vx[40];
    char vy[40];
    char vz[40];
    ftoa( (double)v[0], vx );
    ftoa( (double)v[1], vy );
    ftoa( (double)v[2], vz );
    sprintf( log, "glVertex3fv: %s %s %s", vx, vy, vz );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = *(v++);
    *(d3dv++) = *(v++);
    *(d3dv++) = *(v++);
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex3i (GLint x, GLint y, GLint z)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glVertex3i: %d %d %d", x, y, z );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat)x;
    *(d3dv++) = (GLfloat)y;
    *(d3dv++) = (GLfloat)z;
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex3iv (const GLint *v)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glVertex3iv: %d %d %d", v[0], v[1], v[2] );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat) *(v++);
    *(d3dv++) = (GLfloat) *(v++);
    *(d3dv++) = (GLfloat) *(v++);
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex3s (GLshort x, GLshort y, GLshort z)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glVertex3s: %d %d %d", x, y, z );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat)x;
    *(d3dv++) = (GLfloat)y;
    *(d3dv++) = (GLfloat)z;
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex3sv (const GLshort *v)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glVertex3sv: %d %d %d", v[0], v[1], v[2] );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat) *(v++);
    *(d3dv++) = (GLfloat) *(v++);
    *(d3dv++) = (GLfloat) *(v++);
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{ 
#if GETPARMSFORDEBUG
    char log[256];
    char vx[40];
    char vy[40];
    char vz[40];
    char vw[40];
    ftoa( (double)x, vx );
    ftoa( (double)y, vy );
    ftoa( (double)z, vz );
    ftoa( (double)w, vw );
    sprintf( log, "glVertex4d: %s %s %s %s", vx, vy, vz, vw );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat)x;
    *(d3dv++) = (GLfloat)y;
    *(d3dv++) = (GLfloat)z;
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex4dv (const GLdouble *v)
{ 
#if GETPARMSFORDEBUG
    char log[256];
    char vx[40];
    char vy[40];
    char vz[40];
    char vw[40];
    ftoa( (double)v[0], vx );
    ftoa( (double)v[1], vy );
    ftoa( (double)v[2], vz );
    ftoa( (double)v[3], vw );
    sprintf( log, "glVertex4dv: %s %s %s %s", vx, vy, vz, vw );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat) *(v++);
    *(d3dv++) = (GLfloat) *(v++);
    *(d3dv++) = (GLfloat) *(v++);
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
#if GETPARMSFORDEBUG
    char log[256];
    char vx[40];
    char vy[40];
    char vz[40];
    char vw[40];
    ftoa( (double)x, vx );
    ftoa( (double)x, vy );
    ftoa( (double)y, vz );
    ftoa( (double)w, vw );
    sprintf( log, "glVertex4f: %s %s %s %s", vx, vy, vz, vw );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = x;
    *(d3dv++) = y;
    *(d3dv++) = z;
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex4fv (const GLfloat *v)
{
#if GETPARMSFORDEBUG
    char log[256];
    char vx[40];
    char vy[40];
    char vz[40];
    char vw[40];
    ftoa( (double)v[0], vx );
    ftoa( (double)v[1], vy );
    ftoa( (double)v[2], vz );
    ftoa( (double)v[3], vw );
    sprintf( log, "glVertex4fv: %s %s %s %s", vx, vy, vz, vw );
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, log );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = *(v++);
    *(d3dv++) = *(v++);
    *(d3dv++) = *(v++);
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex4i (GLint x, GLint y, GLint z, GLint w)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glVertex4i: %d %d %d %d", x, y, z, w );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat)x;
    *(d3dv++) = (GLfloat)y;
    *(d3dv++) = (GLfloat)z;
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex4iv (const GLint *v)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glVertex4iv: %d %d %d %d", v[0], v[1], v[2], v[3] );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat) *(v++);
    *(d3dv++) = (GLfloat) *(v++);
    *(d3dv++) = (GLfloat) *(v++);
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glVertex4s: %d %d %d %d", x, y, z, w );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat)x;
    *(d3dv++) = (GLfloat)y;
    *(d3dv++) = (GLfloat)z;
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertex4sv (const GLshort *v)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glVertex4sv: %d %d %d %d", v[0], v[1], v[2], v[3] );
#endif
    VertexBufferFilled();

    FLOAT *d3dv = (FLOAT*)&g_OpenGLValues->m_verts[g_OpenGLValues->m_vcnt++];
    *(d3dv++) = (GLfloat) *(v++);
    *(d3dv++) = (GLfloat) *(v++);
    *(d3dv++) = (GLfloat) *(v++);
    MEMCPY(d3dv, &g_OpenGLValues->m_nx, sizeof(FLOAT) * 7 + sizeof(D3DCOLOR));
}

void APIENTRY glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{ 
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "glVertexPointer: 0x%X 0x%X 0x%X 0x%X", size, type, stride, pointer );
#endif
    if(size == 3 && type == GL_FLOAT)
        g_OpenGLValues->m_vertexary = (GLfloat*)pointer;
#if DODPFS
    else
    {
        char junk[256];
        sprintf( junk, "Vertex array not supported (size:0x%X type:0x%X)\n", size, type );
        OutputDebugStringA( junk );
    }
#endif
    if(stride == 0)
    {
        stride = 12;
    }
    g_OpenGLValues->m_vertexarystride = stride;
}

int WINAPI wglChoosePixelFormat(HDC hdc, CONST PIXELFORMATDESCRIPTOR *ppfd)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "wglChoosePixelFormat: 0x%X 0x%X", hdc, ppfd );
#endif
    return 1;
}

#if HOOK_WINDOW_PROC // Custom message loop to test SetLOD
LRESULT CALLBACK MyMsgHandler(
  HWND hwnd,      // handle to window
  UINT uMsg,      // message identifier
  WPARAM wParam,  // first message parameter
  LPARAM lParam   // second message parameter
)
{
    if(uMsg == WM_CHAR)
    {
        if(wParam == 0x2F)
        {
            ++g_OpenGLValues->m_lod;
            if(g_OpenGLValues->m_lod == 8)
                g_OpenGLValues->m_lod = 0;
            int changedLOD = 0;
            static char str[256];
            for(int i = 0; i < MAXGLTEXHANDLES; ++i)
            {
                if(g_OpenGLValues->m_tex[i].m_ddsurf != 0) 
                {
                    DWORD mipcount = g_OpenGLValues->m_tex[i].m_ddsurf->GetLevelCount();
                    if(mipcount > 1)
                    {
                        if(g_OpenGLValues->m_lod >= mipcount)
                            g_OpenGLValues->m_tex[i].m_ddsurf->SetLOD(mipcount - 1);
                        else
                        {
                            g_OpenGLValues->m_tex[i].m_ddsurf->SetLOD(g_OpenGLValues->m_lod);
                            ++changedLOD;
                        }
                    }
                }
            }

            _itoa(changedLOD, str, 10);
#if DODPFS
            char junk[256];
            sprintf( junk, "MyMsgHandler:%s", str );
            OutputDebugStringA( junk );
#endif

            return 0;
        }
    }
    return CallWindowProc(g_OpenGLValues->m_wndproc, hwnd, uMsg, wParam, lParam);
}
#endif

HGLRC WINAPI wglCreateContext(HDC hdc)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "wglCreateContext: 0x%X", hdc );
#endif
    /*
       This IF/ELSE block is necessary in order to allow apps to delete a
       context and then create a new one (as in changing screen resolution
       or changing from a software renderer to using OpenGL32.DLL).  We need
       to make sure that the pre-existing DirectX8Device is freed and that
       the g_OpenGLValues data structure is cleared as it would be when
       created.  If we do not the results can range from rendering the screen
       inaccurately or not at all to crashing the app.  (a-brienw 03/07/2001)
    */
    if (g_OpenGLValues != NULL)
    {
        if (g_OpenGLValues->m_d3ddev != NULL)
        {
            g_OpenGLValues->m_d3ddev->Release();
            g_OpenGLValues->m_d3ddev = 0;
        }
    }
    else
    {
        g_OpenGLValues = new Globals;
    }

    if (g_OpenGLValues == NULL)
        return 0;

    memset( g_OpenGLValues, 0, sizeof(Globals) );
    
    g_OpenGLValues->m_hdc = hdc;
    g_OpenGLValues->m_hwnd = WindowFromDC(g_OpenGLValues->m_hdc);
    RECT rect;
    GetClientRect(g_OpenGLValues->m_hwnd, &rect);
    g_OpenGLValues->m_winWidth = (USHORT)rect.right;
    g_OpenGLValues->m_winHeight = (USHORT)rect.bottom;
    g_OpenGLValues->m_vwx = rect.left;
    g_OpenGLValues->m_vwy = rect.top;
    g_OpenGLValues->m_vww = rect.right - rect.left;
    g_OpenGLValues->m_vwh = rect.bottom - rect.top;
    g_OpenGLValues->m_vport.X = g_OpenGLValues->m_vwx;
    g_OpenGLValues->m_vport.Y = g_OpenGLValues->m_winHeight - (g_OpenGLValues->m_vwy + g_OpenGLValues->m_vwh);
    g_OpenGLValues->m_vport.Width = g_OpenGLValues->m_vww;
    g_OpenGLValues->m_vport.Height = g_OpenGLValues->m_vwh;
    g_OpenGLValues->m_vport.MinZ = 0.f;
    g_OpenGLValues->m_vport.MaxZ = 1.f;

    D3DDEVTYPE DeviceType = D3DDEVTYPE_HAL;
    // Check registry key to see if we need to do software emulation	
    HKEY hKey;
    if(ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_QUAKE, &hKey)) {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = 4;
        if (ERROR_SUCCESS == RegQueryValueEx( hKey, L"Emulation", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
            dwType == REG_DWORD &&
            dwValue != 0) {
            DeviceType = D3DDEVTYPE_REF;
        }
        RegCloseKey( hKey );
    }

    //
    // get the current display settings so they can be restored
    // after the call to Direct3DCreate8.
    //
    DEVMODEW dm;
    dm.dmSize = sizeof(DEVMODEW);
    dm.dmDriverExtra = 0;
    if (!EnumDisplaySettings(0, ENUM_CURRENT_SETTINGS, &dm))
    {
        return 0;
    }

    IDirect3D8 *pEnum = Direct3DCreate8(D3D_SDK_VERSION);
    if (pEnum == NULL)
    {
#if DODPFS
        OutputDebugStringA("Wrapper: Direct3DCreate8 failed\n");
#endif
        return 0;
    }

    D3DPRESENT_PARAMETERS d3dpp;
    memset(&d3dpp, 0, sizeof(D3DPRESENT_PARAMETERS));

    // See if the window is full screen
    if( rect.right == GetDeviceCaps(hdc, HORZRES) && rect.bottom == GetDeviceCaps(hdc, VERTRES) )
    {
        // We are full screen
        d3dpp.Windowed = FALSE;
    }
    else
    {
        d3dpp.Windowed = TRUE;
    }

    int bpp = GetDeviceCaps(hdc, BITSPIXEL);

    /*
        If this device is a 3dfx Voodoo then make sure we don't allow the
        display to be set to more than 16bpp because of the bug in the drivers
        that the 3dfx team is (hopefully) going to get to at a later date.
    */
    if (wcsstr(dm.dmDeviceName,L"3dfx"))
    {
        if (bpp > 16)
        {
            bpp = 16;
            dm.dmBitsPerPel = 16;
        }
    }
    
    d3dpp.hDeviceWindow = g_OpenGLValues->m_hwnd;
    d3dpp.BackBufferWidth = rect.right;
    d3dpp.BackBufferHeight = rect.bottom;
    d3dpp.BackBufferFormat = bpp == 16 ? D3DFMT_R5G6B5 : D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount = 1;
    d3dpp.EnableAutoDepthStencil = TRUE;
    d3dpp.AutoDepthStencilFormat = D3DFMT_D16;
    d3dpp.SwapEffect = D3DSWAPEFFECT_COPY;

    // check to see if the current format is supported
    // if not and we are in 32 bpp change to 16 bpp
    HRESULT hr = pEnum->CheckDeviceType( D3DADAPTER_DEFAULT, DeviceType, d3dpp.BackBufferFormat, d3dpp.BackBufferFormat, d3dpp.Windowed );
    if(FAILED(hr))
    {
        if( bpp == 32 )
        {
            d3dpp.BackBufferFormat = D3DFMT_R5G6B5;
            dm.dmBitsPerPel = 16;
        }
    }

    // restore to the saved display settings.
    ChangeDisplaySettingsExW(0, &dm, 0, CDS_FULLSCREEN, 0);

    hr = pEnum->GetDeviceCaps( D3DADAPTER_DEFAULT, DeviceType, &g_OpenGLValues->m_dd );
    if(FAILED(hr))
    {
        pEnum->Release();
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: GetDeviceCaps failed (0x%X)\n", hr );
        OutputDebugStringA( junk );
#endif
        return 0;
    }

    DWORD Behaviour;

#if 1
    if(g_OpenGLValues->m_dd.MaxStreams >= 4 && 
       (g_OpenGLValues->m_dd.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) != 0 && 
       g_OpenGLValues->m_dd.MaxActiveLights >= 8 && 
       (g_OpenGLValues->m_dd.TextureCaps & D3DPTEXTURECAPS_PROJECTED) != 0)
    {
        Behaviour = D3DCREATE_HARDWARE_VERTEXPROCESSING | ((g_OpenGLValues->m_dd.DevCaps & D3DDEVCAPS_PUREDEVICE) != 0 ? D3DCREATE_PUREDEVICE : 0);
#if DODPFS
        OutputDebugStringA("Wrapper: Using T&L hardware\n");
#endif
    }
    else
#endif
    {
        Behaviour = D3DCREATE_SOFTWARE_VERTEXPROCESSING;
#if DODPFS
        OutputDebugStringA("Wrapper: Using software pipeline\n");
#endif
    }

    hr = pEnum->CreateDevice(D3DADAPTER_DEFAULT, DeviceType, g_OpenGLValues->m_hwnd, Behaviour, &d3dpp, &g_OpenGLValues->m_d3ddev);

    if(FAILED(hr))
    {
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: CreateDevice failed (hr:0x%X windowed:%d)\n", hr, d3dpp.Windowed );
        OutputDebugStringA( junk );
#endif
        pEnum->Release();
        return 0;
    }

    // Check registry key to see if we need to turn off mipmapping
    if(ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_QUAKE, &hKey)) {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = 4;
        if (ERROR_SUCCESS == RegQueryValueEx( hKey, L"DisableMipMap", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
            dwType == REG_DWORD &&
            dwValue != 0) {
            g_OpenGLValues->m_usemipmap = FALSE;
#if DODPFS
            OutputDebugStringA("Wrapper: Mipmapping disabled\n");
#endif
        }
        else {
            g_OpenGLValues->m_usemipmap = TRUE;
        }
        RegCloseKey( hKey );
    }
    else {
        g_OpenGLValues->m_usemipmap = TRUE;
    }
    
    // Enumerate texture formats and find the right ones to use
    // Look for a four bit alpha surface
    hr = pEnum->CheckDeviceFormat(D3DADAPTER_DEFAULT, DeviceType, d3dpp.BackBufferFormat, 0, D3DRTYPE_TEXTURE, D3DFMT_A4R4G4B4);
    if ( FAILED(hr) )
    {
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: Unable to find 4444 texture (0x%X)\n", hr );
        OutputDebugStringA( junk );
#endif
        g_OpenGLValues->m_d3ddev->Release();
        pEnum->Release();
        return 0;
    }
    g_OpenGLValues->m_ddFourBitAlphaSurfFormat = D3DFMT_A4R4G4B4;

    // Look for an eight bit alpha surface
    hr = pEnum->CheckDeviceFormat(D3DADAPTER_DEFAULT, DeviceType, d3dpp.BackBufferFormat, 0, D3DRTYPE_TEXTURE, D3DFMT_A8R8G8B8);
    if ( FAILED(hr) )
    {
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: Not using 8888 texture (0x%X)\n", hr );
        OutputDebugStringA( junk );
#endif
        g_OpenGLValues->m_ddEightBitAlphaSurfFormat = g_OpenGLValues->m_ddFourBitAlphaSurfFormat;
    }
    else
    {
        g_OpenGLValues->m_ddEightBitAlphaSurfFormat = D3DFMT_A8R8G8B8;
    }

    // Look for a surface
    hr = pEnum->CheckDeviceFormat(D3DADAPTER_DEFAULT, DeviceType, d3dpp.BackBufferFormat, 0, D3DRTYPE_TEXTURE, D3DFMT_R5G6B5);
    if ( FAILED(hr) )
    {
        hr = pEnum->CheckDeviceFormat(D3DADAPTER_DEFAULT, DeviceType, d3dpp.BackBufferFormat, 0, D3DRTYPE_TEXTURE, D3DFMT_X1R5G5B5);
        if ( FAILED(hr) )
        {
#if DODPFS
            char junk[256];
            sprintf( junk, "Wrapper: Unable to find 555 or 565 texture (0x%X)\n", hr );
            OutputDebugStringA( junk );
#endif
            g_OpenGLValues->m_d3ddev->Release();
            pEnum->Release();
            return 0;
        }
        g_OpenGLValues->m_ddFiveBitSurfFormat = D3DFMT_X1R5G5B5;
    }
    else
    {
        g_OpenGLValues->m_ddFiveBitSurfFormat = D3DFMT_R5G6B5;
    }

    // Look for an 8-bit surface
    hr = pEnum->CheckDeviceFormat(D3DADAPTER_DEFAULT, DeviceType, d3dpp.BackBufferFormat, 0, D3DRTYPE_TEXTURE, D3DFMT_X8R8G8B8);
    if ( FAILED(hr) )
    {
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: Not using 888 texture (0x%X)\n", hr );
        OutputDebugStringA( junk );
#endif
        g_OpenGLValues->m_ddEightBitSurfFormat = g_OpenGLValues->m_ddFiveBitSurfFormat;
    }
    else
    {
        g_OpenGLValues->m_ddEightBitSurfFormat = D3DFMT_X8R8G8B8;
    }

    // Look for a luminance surface
    hr = pEnum->CheckDeviceFormat(D3DADAPTER_DEFAULT, DeviceType, d3dpp.BackBufferFormat, 0, D3DRTYPE_TEXTURE, D3DFMT_L8);
    if ( FAILED(hr) )
    {
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: Not using luminance texture (0x%X)\n", hr );
        OutputDebugStringA( junk );
#endif
        g_OpenGLValues->m_ddLuminanceSurfFormat = g_OpenGLValues->m_ddEightBitSurfFormat;
    }
    else
    {
        g_OpenGLValues->m_ddLuminanceSurfFormat = D3DFMT_L8;
    }

    // Look for a alpha surface
    hr = pEnum->CheckDeviceFormat(D3DADAPTER_DEFAULT, DeviceType, d3dpp.BackBufferFormat, 0, D3DRTYPE_TEXTURE, D3DFMT_A8);
    if ( FAILED(hr) )
    {
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: Not using alpha-only texture (0x%X)\n", hr );
        OutputDebugStringA( junk );
#endif
        g_OpenGLValues->m_ddEightBitAlphaOnlySurfFormat = g_OpenGLValues->m_ddEightBitAlphaSurfFormat;
    }
    else
    {
        g_OpenGLValues->m_ddEightBitAlphaOnlySurfFormat = D3DFMT_A8;
    }

    // Done with enumerator
    pEnum->Release();
    
    // Do misc init stuff
    if(g_OpenGLValues->m_dd.MaxTextureWidth < 512 || g_OpenGLValues->m_dd.MaxTextureHeight < 512) {
        g_OpenGLValues->m_subsample = TRUE;
#if DODPFS
        OutputDebugStringA("Wrapper: Subsampling textures to 256 x 256\n");
#endif
    }
    else
        g_OpenGLValues->m_subsample = FALSE;
    if(g_OpenGLValues->m_dd.TextureCaps & D3DPTEXTURECAPS_SQUAREONLY) {
        g_OpenGLValues->m_makeSquare = TRUE;
#if DODPFS
        OutputDebugStringA("Wrapper: Forcing all textures to be square\n");
#endif
    }
    else
        g_OpenGLValues->m_makeSquare = FALSE;
    if(g_OpenGLValues->m_dd.MaxSimultaneousTextures > 1) {
        g_OpenGLValues->m_usemtex = TRUE;
#if DODPFS
        OutputDebugStringA("Wrapper: Multitexturing enabled\n");
#endif
    }
    else {
        g_OpenGLValues->m_usemtex = FALSE;
#if DODPFS
        OutputDebugStringA("Wrapper: Multitexturing not available with this driver\n");
#endif
    }
    if(!(g_OpenGLValues->m_dd.TextureFilterCaps & D3DPTFILTERCAPS_MIPFPOINT) &&
        !(g_OpenGLValues->m_dd.TextureFilterCaps & D3DPTFILTERCAPS_MIPFLINEAR)) {
        g_OpenGLValues->m_usemipmap = FALSE;
#if DODPFS
        OutputDebugStringA("Wrapper: Mipmapping disabled\n");
#endif
    }
    if(ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_QUAKE, &hKey)) {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = 4;
        if (ERROR_SUCCESS == RegQueryValueEx( hKey, L"DoFlip", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
            dwType == REG_DWORD &&
            dwValue != 0) {
            g_OpenGLValues->m_doFlip = TRUE;
        }
        else {
            g_OpenGLValues->m_doFlip = FALSE;
        }
        RegCloseKey( hKey );
    }
    else {
        g_OpenGLValues->m_doFlip = FALSE;
    }

    // Create shaders
    DWORD decl0[] = 
    {
        D3DVSD_STREAM(0),
        D3DVSD_REG( D3DVSDE_POSITION,  D3DVSDT_FLOAT3),
        D3DVSD_END()
    };
    hr = g_OpenGLValues->m_d3ddev->CreateVertexShader( decl0, NULL, &g_OpenGLValues->m_vshader[0], 0 );
    if( FAILED(hr) )
    {
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: CreateVertexShader(1) failed (0x%X)\n", hr );
        OutputDebugStringA( junk );
#endif
        g_OpenGLValues->m_d3ddev->Release();
        return 0;
    }
    DWORD decl1[] = 
    {
        D3DVSD_STREAM(0),
        D3DVSD_REG( D3DVSDE_POSITION,  D3DVSDT_FLOAT3),
        D3DVSD_STREAM(1),
        D3DVSD_REG( D3DVSDE_DIFFUSE,   D3DVSDT_D3DCOLOR),
        D3DVSD_END()
    };
    hr = g_OpenGLValues->m_d3ddev->CreateVertexShader( decl1, NULL, &g_OpenGLValues->m_vshader[1], 0 );
    if( FAILED(hr) )
    {
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: CreateVertexShader(2) failed (0x%X)\n", hr );
        OutputDebugStringA( junk );
#endif
        g_OpenGLValues->m_d3ddev->Release();
        return 0;
    }
    DWORD decl2[] = 
    {
        D3DVSD_STREAM(0),
        D3DVSD_REG( D3DVSDE_POSITION,  D3DVSDT_FLOAT3),
        D3DVSD_STREAM(1),
        D3DVSD_REG( D3DVSDE_TEXCOORD0, D3DVSDT_FLOAT2),
        D3DVSD_END()
    };
    hr = g_OpenGLValues->m_d3ddev->CreateVertexShader( decl2, NULL, &g_OpenGLValues->m_vshader[2], 0 );
    if( FAILED(hr) )
    {
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: CreateVertexShader(3) failed (0x%X)\n", hr );
        OutputDebugStringA( junk );
#endif
        g_OpenGLValues->m_d3ddev->Release();
        return 0;
    }
    DWORD decl3[] = 
    {
        D3DVSD_STREAM(0),
        D3DVSD_REG( D3DVSDE_POSITION,  D3DVSDT_FLOAT3),
        D3DVSD_STREAM(1),
        D3DVSD_REG( D3DVSDE_TEXCOORD0, D3DVSDT_FLOAT2),
        D3DVSD_STREAM(2),
        D3DVSD_REG( D3DVSDE_TEXCOORD1, D3DVSDT_FLOAT2),
        D3DVSD_END()
    };
    hr = g_OpenGLValues->m_d3ddev->CreateVertexShader( decl3, NULL, &g_OpenGLValues->m_vshader[3], 0 );
    if( FAILED(hr) )
    {
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: CreateVertexShader(4) failed (0x%X)\n", hr );
        OutputDebugStringA( junk );
#endif
        g_OpenGLValues->m_d3ddev->Release();
        return 0;
    }
    DWORD decl4[] = 
    {
        D3DVSD_STREAM(0),
        D3DVSD_REG( D3DVSDE_POSITION,  D3DVSDT_FLOAT3),
        D3DVSD_STREAM(1),
        D3DVSD_REG( D3DVSDE_DIFFUSE,   D3DVSDT_D3DCOLOR),
        D3DVSD_STREAM(2),
        D3DVSD_REG( D3DVSDE_TEXCOORD0, D3DVSDT_FLOAT2),
        D3DVSD_END()
    };
    hr = g_OpenGLValues->m_d3ddev->CreateVertexShader( decl4, NULL, &g_OpenGLValues->m_vshader[4], 0 );
    if( FAILED(hr) )
    {
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: CreateVertexShader(5) failed (0x%X)\n", hr );
        OutputDebugStringA( junk );
#endif
        g_OpenGLValues->m_d3ddev->Release();
        return 0;
    }
    DWORD decl5[] = 
    {
        D3DVSD_STREAM(0),
        D3DVSD_REG( D3DVSDE_POSITION,  D3DVSDT_FLOAT3),
        D3DVSD_STREAM(1),
        D3DVSD_REG( D3DVSDE_DIFFUSE,   D3DVSDT_D3DCOLOR),
        D3DVSD_STREAM(2),
        D3DVSD_REG( D3DVSDE_TEXCOORD0, D3DVSDT_FLOAT2),
        D3DVSD_STREAM(3),
        D3DVSD_REG( D3DVSDE_TEXCOORD1, D3DVSDT_FLOAT2),
        D3DVSD_END()
    };
    hr = g_OpenGLValues->m_d3ddev->CreateVertexShader( decl5, NULL, &g_OpenGLValues->m_vshader[5], 0 );
    if( FAILED(hr) )
    {
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: CreateVertexShader(6) failed (0x%X)\n", hr );
        OutputDebugStringA( junk );
#endif
        g_OpenGLValues->m_d3ddev->Release();
        return 0;
    }

    // Create vertex buffers
    hr = g_OpenGLValues->m_d3ddev->CreateVertexBuffer(sizeof(QuakeVertex) * VBUFSIZE, D3DUSAGE_WRITEONLY | D3DUSAGE_DYNAMIC, QUAKEVFMT, D3DPOOL_DEFAULT, &g_OpenGLValues->m_vbuf);
    if( FAILED(hr) )
    {
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: CreateVertexBuffer failed (0x%X)\n", hr );
        OutputDebugStringA( junk );
#endif
        g_OpenGLValues->m_d3ddev->Release();
        return 0;
    }

    g_OpenGLValues->m_vertexarystride = 12;
    g_OpenGLValues->m_colorarystride = 4;
    g_OpenGLValues->m_texcoordarystride[0] = 8;
    g_OpenGLValues->m_texcoordarystride[1] = 8;
    g_OpenGLValues->m_xyzbuf = 0;
    g_OpenGLValues->m_colbuf = 0;
    g_OpenGLValues->m_texbuf = 0;
    g_OpenGLValues->m_tex2buf = 0;
    g_OpenGLValues->m_vbufsz = 0;
    hr = GrowVB(VBUFSIZE);
    if( FAILED(hr) )
    {
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: GrowVB failed (0x%X)\n", hr );
        OutputDebugStringA( junk );
#endif
        g_OpenGLValues->m_vbuf->Release();
        g_OpenGLValues->m_d3ddev->Release();
        return 0;
    }
    g_OpenGLValues->m_ibuf = 0;
    g_OpenGLValues->m_ibufsz = 0;
    hr = GrowIB(VBUFSIZE);
    if( FAILED(hr) )
    {
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: GrowIB failed (0x%X)\n", hr );
        OutputDebugStringA( junk );
#endif
        g_OpenGLValues->m_vbuf->Release();
        g_OpenGLValues->m_d3ddev->Release();
        return 0;
    }

    // Some more init stuff
    g_OpenGLValues->m_cullMode = GL_BACK;
    g_OpenGLValues->m_FrontFace = GL_CCW;
    g_OpenGLValues->m_cullEnabled = FALSE;
    g_OpenGLValues->m_texHandleValid = FALSE;
    g_OpenGLValues->m_texturing = FALSE;
    g_OpenGLValues->m_updvwp = TRUE;
    g_OpenGLValues->m_blendmode[0] = GL_MODULATE;
    g_OpenGLValues->m_blendmode[1] = GL_MODULATE;
    g_OpenGLValues->m_nfv = 0;
    g_OpenGLValues->m_curtgt = 0;
    g_OpenGLValues->m_client_active_texture_arb = 0;
    g_OpenGLValues->m_tu = g_OpenGLValues->m_tv = g_OpenGLValues->m_tu2 = g_OpenGLValues->m_tv2 = 0.f;
    g_OpenGLValues->m_color = 0xFFFFFFFF;
    g_OpenGLValues->m_material.Ambient.r = 0.2f;
    g_OpenGLValues->m_material.Ambient.g = 0.2f;
    g_OpenGLValues->m_material.Ambient.b = 0.2f;
    g_OpenGLValues->m_material.Ambient.a = 1.0f;
    g_OpenGLValues->m_material.Diffuse.r = 0.8f;
    g_OpenGLValues->m_material.Diffuse.g = 0.8f;
    g_OpenGLValues->m_material.Diffuse.b = 0.8f;
    g_OpenGLValues->m_material.Diffuse.a = 1.0f;
    g_OpenGLValues->m_material.Specular.r = 0.0f;
    g_OpenGLValues->m_material.Specular.g = 0.0f;
    g_OpenGLValues->m_material.Specular.b = 0.0f;
    g_OpenGLValues->m_material.Specular.a = 1.0f;
    g_OpenGLValues->m_material.Emissive.r = 0.0f;
    g_OpenGLValues->m_material.Emissive.g = 0.0f;
    g_OpenGLValues->m_material.Emissive.b = 0.0f;
    g_OpenGLValues->m_material.Emissive.a = 1.0f;
    g_OpenGLValues->m_material.Power = 0.f;
    g_OpenGLValues->m_clearColor = 0;
    g_OpenGLValues->m_clearDepth = 1.f;
    g_OpenGLValues->m_usecolorary = FALSE;
    g_OpenGLValues->m_usetexcoordary[0] = FALSE;
    g_OpenGLValues->m_usetexcoordary[1] = FALSE;
    g_OpenGLValues->m_usevertexary = FALSE;
    g_OpenGLValues->m_polyoffset = FALSE;
    g_OpenGLValues->m_withinprim = FALSE;
    g_OpenGLValues->m_scix = 0;
    g_OpenGLValues->m_sciy = 0;
    g_OpenGLValues->m_sciw = g_OpenGLValues->m_winWidth;
    g_OpenGLValues->m_scih = g_OpenGLValues->m_winHeight;
    g_OpenGLValues->m_lckfirst = 0;
    g_OpenGLValues->m_lckcount = 0;
    g_OpenGLValues->m_clippstate = 0;
    g_OpenGLValues->m_ibufoff = 0;
    g_OpenGLValues->m_vbufoff = 0;
    g_OpenGLValues->m_lightdirty = 0;
    g_OpenGLValues->m_pStreams[0] = 0;
    g_OpenGLValues->m_pStreams[1] = 0;
    g_OpenGLValues->m_pStreams[2] = 0;
    g_OpenGLValues->m_pStreams[3] = 0;
    g_OpenGLValues->m_pStrides[0] = 0;
    g_OpenGLValues->m_pStrides[1] = 0;
    g_OpenGLValues->m_pStrides[2] = 0;
    g_OpenGLValues->m_pStrides[3] = 0;
    for(unsigned i = 0; i < MAXGLTEXHANDLES; ++i) {
        g_OpenGLValues->m_tex[i].m_ddsurf = 0;
        g_OpenGLValues->m_tex[i].m_block = 0;
        g_OpenGLValues->m_tex[i].m_capture = FALSE;
        g_OpenGLValues->m_tex[i].m_dwStage = 0;
        g_OpenGLValues->m_tex[i].m_minmode = D3DTEXF_POINT;
        g_OpenGLValues->m_tex[i].m_magmode = D3DTEXF_LINEAR;
        g_OpenGLValues->m_tex[i].m_mipmode = D3DTEXF_LINEAR;
        g_OpenGLValues->m_tex[i].m_addu = D3DTADDRESS_WRAP;
        g_OpenGLValues->m_tex[i].m_addv = D3DTADDRESS_WRAP;
        g_OpenGLValues->m_tex[i].m_prev = (int)i - 1;
        g_OpenGLValues->m_tex[i].m_next = (int)i + 1;
    }
    for(i = 0; i < 8; ++i)
    {
        g_OpenGLValues->m_light[i].Ambient.r = 0.0f;
        g_OpenGLValues->m_light[i].Ambient.g = 0.0f;
        g_OpenGLValues->m_light[i].Ambient.b = 0.0f;
        g_OpenGLValues->m_light[i].Ambient.a = 1.0f;
        if(i == 0)
        {
            g_OpenGLValues->m_light[i].Diffuse.r = 1.0f;
            g_OpenGLValues->m_light[i].Diffuse.g = 1.0f;
            g_OpenGLValues->m_light[i].Diffuse.b = 1.0f;
            g_OpenGLValues->m_light[i].Diffuse.a = 1.0f;
            g_OpenGLValues->m_light[i].Specular.r = 1.0f;
            g_OpenGLValues->m_light[i].Specular.g = 1.0f;
            g_OpenGLValues->m_light[i].Specular.b = 1.0f;
            g_OpenGLValues->m_light[i].Specular.a = 1.0f;
        }
        else
        {
            g_OpenGLValues->m_light[i].Diffuse.r = 0.0f;
            g_OpenGLValues->m_light[i].Diffuse.g = 0.0f;
            g_OpenGLValues->m_light[i].Diffuse.b = 0.0f;
            g_OpenGLValues->m_light[i].Diffuse.a = 1.0f;
            g_OpenGLValues->m_light[i].Specular.r = 0.0f;
            g_OpenGLValues->m_light[i].Specular.g = 0.0f;
            g_OpenGLValues->m_light[i].Specular.b = 0.0f;
            g_OpenGLValues->m_light[i].Specular.a = 1.0f;
        }
        g_OpenGLValues->m_light[i].Position.x = 0.f;
        g_OpenGLValues->m_light[i].Position.y = 0.f;
        g_OpenGLValues->m_light[i].Position.z = 1.f;
        g_OpenGLValues->m_lightPositionW[i] = 0.f;
        g_OpenGLValues->m_light[i].Direction.x = 0.f;
        g_OpenGLValues->m_light[i].Direction.y = 0.f;
        g_OpenGLValues->m_light[i].Direction.z = -1.f;
        g_OpenGLValues->m_light[i].Range = (float)sqrt(FLT_MAX);
        g_OpenGLValues->m_light[i].Falloff = 0.f;
        g_OpenGLValues->m_light[i].Attenuation0 = 1.f;
        g_OpenGLValues->m_light[i].Attenuation1 = 0.f;
        g_OpenGLValues->m_light[i].Attenuation2 = 0.f;
        g_OpenGLValues->m_light[i].Theta = 0.f;
        g_OpenGLValues->m_light[i].Phi = 180.f;
        g_OpenGLValues->m_lightdirty |= (1 << i);
    }
    g_OpenGLValues->m_free = 0;
    D3DMATRIX unity;
    unity._11 = 1.0f; unity._12 = 0.0f; unity._13 = 0.0f; unity._14 = 0.0f;
    unity._21 = 0.0f; unity._22 = 1.0f; unity._23 = 0.0f; unity._24 = 0.0f;
    unity._31 = 0.0f; unity._32 = 0.0f; unity._33 = 1.0f; unity._34 = 0.0f;
    unity._41 = 0.0f; unity._42 = 0.0f; unity._43 = 0.0f; unity._44 = 1.0f;
    g_OpenGLValues->m_xfrm[D3DTS_WORLD] = unity;
    QuakeSetTransform(D3DTS_WORLD, &unity); 
    g_OpenGLValues->m_xfrm[D3DTS_PROJECTION] = unity;
    QuakeSetTransform(D3DTS_PROJECTION, &unity); 
    g_OpenGLValues->m_xfrm[D3DTS_TEXTURE0] = unity;
    QuakeSetTransform(D3DTS_TEXTURE0, &unity); 
    if(g_OpenGLValues->m_usemtex == TRUE)
    {
        g_OpenGLValues->m_xfrm[D3DTS_TEXTURE1] = unity;
        QuakeSetTransform(D3DTS_TEXTURE1, &unity); 
    }
    g_OpenGLValues->m_matrixMode = D3DTS_WORLD;
    g_OpenGLValues->m_d3ddev->SetViewport(&g_OpenGLValues->m_vport);
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_SPECULARENABLE, TRUE);
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_DITHERENABLE, TRUE);
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_CLIPPING, TRUE);
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_LIGHTING, FALSE);
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_TEXCOORDINDEX,0);
    if(g_OpenGLValues->m_usemtex == TRUE)
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_TEXCOORDINDEX,1);
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_AMBIENT, RGBA_MAKE(51, 51, 51, 255));
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_COLOR1);
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_MATERIAL); 
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_COLOR1); 
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_NORMALIZENORMALS, FALSE);
    g_OpenGLValues->m_d3ddev->SetMaterial(&g_OpenGLValues->m_material);

    // State block for capturing color buffer bit
    g_OpenGLValues->m_d3ddev->BeginStateBlock();
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_ALPHAREF, 0);
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_ALWAYS);
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
    g_OpenGLValues->m_d3ddev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);
    g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_cbufbit);
    
    // Create shaders
    g_OpenGLValues->m_d3ddev->BeginStateBlock();
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    // following stage state to speedup software rasterizer
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    // following stage state to speedup software rasterizer
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG2);
    g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[0][0]);                

    g_OpenGLValues->m_d3ddev->BeginStateBlock();
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    // following stage state to speedup software rasterizer
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    // following stage state to speedup software rasterizer
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[0][1]);

    g_OpenGLValues->m_d3ddev->BeginStateBlock();
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLOROP, D3DTOP_MODULATE);
    // following stage state to speedup software rasterizer
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG2);
    g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[0][2]);

    g_OpenGLValues->m_d3ddev->BeginStateBlock();
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLOROP, D3DTOP_MODULATE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
    g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[0][3]);

    g_OpenGLValues->m_d3ddev->BeginStateBlock();
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    // following stage state to speedup software rasterizer
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    // following stage state to speedup software rasterizer
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG2);
    g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[0][4]);

    g_OpenGLValues->m_d3ddev->BeginStateBlock();
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLOROP, D3DTOP_BLENDTEXTUREALPHA);
    // following stage state to speedup software rasterizer
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG2);
    g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[0][5]);

    g_OpenGLValues->m_d3ddev->BeginStateBlock();
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG1, D3DTA_TEXTURE | D3DTA_COMPLEMENT);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLOROP, D3DTOP_MODULATE);
    // following stage state to speedup software rasterizer
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG2);
    g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[0][6]);

    g_OpenGLValues->m_d3ddev->BeginStateBlock();
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG1, D3DTA_TEXTURE | D3DTA_COMPLEMENT);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLOROP, D3DTOP_MODULATE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
    g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[0][7]);

    g_OpenGLValues->m_d3ddev->BeginStateBlock();
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    // following stage state to speedup software rasterizer
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLOROP, D3DTOP_SELECTARG2);
    // following stage state to speedup software rasterizer
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[0][8]);                

    g_OpenGLValues->m_d3ddev->BeginStateBlock();
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_COLOROP, D3DTOP_SELECTARG2);
    // following stage state to speedup software rasterizer
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
    g_OpenGLValues->m_d3ddev->SetTextureStageState (0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
    g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[0][9]);

    if(g_OpenGLValues->m_usemtex)
    {
        g_OpenGLValues->m_d3ddev->BeginStateBlock();
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        // following stage state to speedup software rasterizer
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
        // following stage state to speedup software rasterizer
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAOP, D3DTOP_SELECTARG2);
        g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[1][0]);

        g_OpenGLValues->m_d3ddev->BeginStateBlock();
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        // following stage state to speedup software rasterizer
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        // following stage state to speedup software rasterizer
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
        g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[1][1]);

        g_OpenGLValues->m_d3ddev->BeginStateBlock();
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLOROP, D3DTOP_MODULATE);
        // following stage state to speedup software rasterizer
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAOP, D3DTOP_SELECTARG2);
        g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[1][2]);

        g_OpenGLValues->m_d3ddev->BeginStateBlock();
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLOROP, D3DTOP_MODULATE);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
        g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[1][3]);

        g_OpenGLValues->m_d3ddev->BeginStateBlock();
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        // following stage state to speedup software rasterizer
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
        // following stage state to speedup software rasterizer
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAOP, D3DTOP_SELECTARG2);
        g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[1][4]);

        g_OpenGLValues->m_d3ddev->BeginStateBlock();
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLOROP, D3DTOP_BLENDTEXTUREALPHA);
        // following stage state to speedup software rasterizer
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAOP, D3DTOP_SELECTARG2);
        g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[1][5]);

        g_OpenGLValues->m_d3ddev->BeginStateBlock();
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG1, D3DTA_TEXTURE | D3DTA_COMPLEMENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLOROP, D3DTOP_MODULATE);
        // following stage state to speedup software rasterizer
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAOP, D3DTOP_SELECTARG2);
        g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[1][6]);

        g_OpenGLValues->m_d3ddev->BeginStateBlock();
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG1, D3DTA_TEXTURE | D3DTA_COMPLEMENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLOROP, D3DTOP_MODULATE);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
        g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[1][7]);

        g_OpenGLValues->m_d3ddev->BeginStateBlock();
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        // following stage state to speedup software rasterizer
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLOROP, D3DTOP_SELECTARG2);
        // following stage state to speedup software rasterizer
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
        g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[1][8]);                
        
        g_OpenGLValues->m_d3ddev->BeginStateBlock();
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLORARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_COLOROP, D3DTOP_SELECTARG2);
        // following stage state to speedup software rasterizer
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
        g_OpenGLValues->m_d3ddev->SetTextureStageState (1, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
        g_OpenGLValues->m_d3ddev->EndStateBlock(&g_OpenGLValues->m_shaders[1][9]);
    }

#if HOOK_WINDOW_PROC
    // Hook into message loop
    g_OpenGLValues->m_wndproc = (WNDPROC)SetWindowLong(g_OpenGLValues->m_hwnd, GWL_WNDPROC, (LONG)MyMsgHandler);
    g_OpenGLValues->m_lod = 0;
#endif

    // Start a scene
    g_OpenGLValues->m_d3ddev->BeginScene();
    
    return (HGLRC)1;
}

BOOL WINAPI wglDeleteContext(HGLRC hglrc)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "wglDeleteContext: 0x%X", hglrc );
#endif

    if (g_OpenGLValues != NULL)
    {
        g_OpenGLValues->m_d3ddev->EndScene();
#if HOOK_WINDOW_PROC
        SetWindowLong(g_OpenGLValues->m_hwnd, GWL_WNDPROC, (LONG)g_OpenGLValues->m_wndproc);
#endif
        for(int i = 0; i < MAXGLTEXHANDLES; ++i){
            if(g_OpenGLValues->m_tex[i].m_ddsurf != 0) {
                g_OpenGLValues->m_tex[i].m_ddsurf->Release();
                g_OpenGLValues->m_tex[i].m_ddsurf = 0;
                if(g_OpenGLValues->m_tex[i].m_block != 0)
                {
                    g_OpenGLValues->m_d3ddev->DeleteStateBlock(g_OpenGLValues->m_tex[i].m_block);
                    g_OpenGLValues->m_tex[i].m_block = 0;
                }
                g_OpenGLValues->m_tex[i].m_capture = FALSE;
            }
        }
        for(i = 0; i < 8; ++i)
            g_OpenGLValues->m_d3ddev->DeleteStateBlock(g_OpenGLValues->m_shaders[0][i]);
        if(g_OpenGLValues->m_usemtex)
        {
            for(i = 0; i < 8; ++i)
                g_OpenGLValues->m_d3ddev->DeleteStateBlock(g_OpenGLValues->m_shaders[1][i]);
        }
        g_OpenGLValues->m_ibuf->Release();
        g_OpenGLValues->m_ibuf = 0;
        g_OpenGLValues->m_tex2buf->Release();
        g_OpenGLValues->m_tex2buf = 0;
        g_OpenGLValues->m_texbuf->Release();
        g_OpenGLValues->m_texbuf = 0;
        g_OpenGLValues->m_colbuf->Release();
        g_OpenGLValues->m_colbuf = 0;
        g_OpenGLValues->m_xyzbuf->Release();
        g_OpenGLValues->m_xyzbuf = 0;
        g_OpenGLValues->m_vbuf->Release();
        g_OpenGLValues->m_vbuf = 0;

        /*
           Although this is the correct location to release the m_d3ddev object
           we aren't going to do it here and instead we will do it in the
           NOTIFY_FUNCTION when the DLL is detached from the process.  I am
           doing this to prevent apps (such as MDK2) from crashing on exit due
           to the fact that they continue to call GL functions after deleting
           the context which causes an access violation.  (a-brienw 03/02/2001)
        
           g_OpenGLValues->m_d3ddev->Release();
           g_OpenGLValues->m_d3ddev = 0;
        */
    }

    return TRUE;
}

int WINAPI wglDescribePixelFormat(HDC hdc, INT iPixelFormat, UINT nBytes, PIXELFORMATDESCRIPTOR *ppfd)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "wglDescribePixelFormat: 0x%X 0x%X 0x%X 0x%X", hdc, iPixelFormat, nBytes, ppfd );
#endif
    if (ppfd != NULL)
    {
        ppfd->nSize = sizeof(PIXELFORMATDESCRIPTOR);
        ppfd->nVersion = 1;
        ppfd->dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_GENERIC_ACCELERATED | PFD_DOUBLEBUFFER;
        ppfd->iPixelType = PFD_TYPE_RGBA;
        ppfd->cColorBits = (unsigned char)GetDeviceCaps(hdc, BITSPIXEL);    
        ppfd->cAccumBits = 0;
        ppfd->cAccumRedBits = 0;
        ppfd->cAccumGreenBits = 0;
        ppfd->cAccumBlueBits = 0;
        ppfd->cAccumAlphaBits = 0;
        ppfd->cStencilBits = 0;
        ppfd->cAuxBuffers = 0;
        ppfd->iLayerType = 0;
        ppfd->bReserved = 0;
        ppfd->dwLayerMask = 0;
        ppfd->dwVisibleMask = 0;
        ppfd->dwDamageMask = 0;
        if(GetDeviceCaps(hdc, BITSPIXEL) == 16)
        {
            ppfd->cRedBits = 5;
            ppfd->cRedShift = 11;
            ppfd->cGreenBits = 6;
            ppfd->cGreenShift = 5;
            ppfd->cBlueBits = 5;
            ppfd->cBlueShift = 0;
            ppfd->cAlphaBits = 0;
            ppfd->cAlphaShift = 0;
            ppfd->cDepthBits = 16;
        }
        else if(GetDeviceCaps(hdc, BITSPIXEL) == 24 || GetDeviceCaps(hdc, BITSPIXEL) == 32)
        {
            ppfd->cRedBits = 8;
            ppfd->cRedShift = 16;
            ppfd->cGreenBits = 8;
            ppfd->cGreenShift = 8;
            ppfd->cBlueBits = 8;
            ppfd->cBlueShift = 0;
            ppfd->cAlphaBits = 0;
            ppfd->cAlphaShift = 0;
            ppfd->cDepthBits = 16;
        }
        else
        {
            return 0;
        }
    }

    return 1;
} 

HGLRC WINAPI wglGetCurrentContext(VOID)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "wglGetCurrentContext" );
#endif
    return (HGLRC)1;
}

HDC WINAPI wglGetCurrentDC(VOID)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "wglGetCurrentDC" );
#endif
    return g_OpenGLValues->m_hdc;
}

int WINAPI wglGetPixelFormat(HDC hdc)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "wglGetPixelFormat: 0x%X", hdc );
#endif
    return 1;
}

PROC WINAPI wglGetProcAddress(LPCSTR str)
{
    if(strcmp(str, "glMTexCoord2fSGIS") == 0)
        return (PROC)glMTexCoord2fSGIS;
    else if(strcmp(str, "glSelectTextureSGIS") == 0)
        return (PROC)glSelectTextureSGIS;
    else if(strcmp(str, "glActiveTextureARB") == 0)
        return (PROC)glActiveTextureARB;
    else if(strcmp(str, "glClientActiveTextureARB") == 0)
        return (PROC)glClientActiveTextureARB;
    else if(strcmp(str, "glMultiTexCoord2fARB") == 0)
        return (PROC)glMultiTexCoord2fARB;
    else if(strcmp(str, "glMultiTexCoord2fvARB") == 0)
        return (PROC)glMultiTexCoord2fvARB;
    else if(strcmp(str, "glLockArraysEXT") == 0)
        return (PROC)glLockArraysEXT;
    else if(strcmp(str, "glUnlockArraysEXT") == 0)
        return (PROC)glUnlockArraysEXT;
    else if(strcmp(str, "wglSwapIntervalEXT") == 0)
        return (PROC)wglSwapIntervalEXT;
#if DODPFS
    else
    {
        char junk[256];
        sprintf( junk, "Wrapper: Unimplemented function (%s)\n", str );
        OutputDebugStringA( junk );
    }
#endif
    return NULL;
}

BOOL wglMakeCurrent(HDC hdc, HGLRC hglrc)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "wglMakeCurrent: 0x%X 0x%X", hdc, hglrc );
#endif
    return g_OpenGLValues->m_d3ddev != NULL; // Fail if no device
}

BOOL WINAPI wglSetPixelFormat(HDC hdc, int iPixelFormat, CONST PIXELFORMATDESCRIPTOR *ppfd)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "wglSetPixelFormat: 0x%X 0x%X 0x%X", hdc, iPixelFormat, ppfd );
#endif
    return TRUE;
}

BOOL WINAPI wglSwapBuffers(HDC hdc)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "wglSwapBuffers: 0x%X", hdc );
#endif

    if( g_OpenGLValues->m_withinprim == TRUE )
    {
#if DODPFS
        char junk[256];
        sprintf( junk, "Wrapper: wglSwapBuffers primitive=%d cnt=%d\n", g_OpenGLValues->m_prim, g_OpenGLValues->m_vcnt );
        OutputDebugStringA( junk );
#endif
        glEnd();
    }
    
    g_OpenGLValues->m_d3ddev->EndScene();
    g_OpenGLValues->m_d3ddev->Present(NULL, NULL, NULL, NULL);
    g_OpenGLValues->m_d3ddev->BeginScene();

    return TRUE;
}

BOOL WINAPI wglSwapIntervalEXT(GLint interval)
{
#if GETPARMSFORDEBUG
    LOG("EmulateOpenGL - PARMS", eDbgLevelInfo, "wglSwapIntervalEXT: 0x%X", interval );
#endif
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\avrflib\avrfutil.cpp ===
/*++

    Copyright (c) 2001  Microsoft Corporation

    Module Name:

        avrfutil.cpp

    Abstract:

        This module implements the code for manipulating the AppVerifier log file.

    Author:

        dmunsil     created     04/26/2001

    Revision History:

    08/14/2001  robkenny    Moved code inside the ShimLib namespace.
    09/21/2001  rparsons    Logging code now uses NT calls.
    09/25/2001  rparsons    Added critical section.
--*/

#include "avrfutil.h"

namespace ShimLib
{


#define AV_KEY  APPCOMPAT_KEY_PATH_MACHINE L"\\AppVerifier"

HANDLE
AVCreateKeyPath(
    LPCWSTR pwszPath
    )
/*++
    Return: The handle to the registry key created.

    Desc:   Given a path to the key, open/create it.
            The key returns the handle to the key or NULL on failure.
--*/
{
    UNICODE_STRING                  ustrKey;
    HANDLE            KeyHandle = NULL;
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG             CreateDisposition;

    RtlInitUnicodeString(&ustrKey, pwszPath);

    InitializeObjectAttributes(&ObjectAttributes,
                               &ustrKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtCreateKey(&KeyHandle,
                         STANDARD_RIGHTS_WRITE |
                            KEY_QUERY_VALUE |
                            KEY_ENUMERATE_SUB_KEYS |
                            KEY_SET_VALUE |
                            KEY_CREATE_SUB_KEY,
                         &ObjectAttributes,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         &CreateDisposition);

    if (!NT_SUCCESS(Status)) {
        KeyHandle = NULL;
        goto out;
    }

out:
    return KeyHandle;
}


BOOL SaveShimSettingDWORD(
    LPCWSTR     szShim,
    LPCWSTR     szExe,
    LPCWSTR     szSetting,
    DWORD       dwSetting
    )
{
    WCHAR                           szKey[300];
    UNICODE_STRING                  ustrKey;
    UNICODE_STRING                  ustrSetting;
    NTSTATUS                        Status;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    HANDLE                          KeyHandle;
    BOOL                            bRet = FALSE;
    ULONG                           CreateDisposition;

    if (!szShim || !szSetting || !szExe) {
        goto out;
    }
    
    //
    // we have to ensure all the sub-keys are created
    //
    wcscpy(szKey, APPCOMPAT_KEY_PATH_MACHINE);
    KeyHandle = AVCreateKeyPath(szKey);
    if (!KeyHandle) {
        goto out;
    }
    NtClose(KeyHandle);

    wcscpy(szKey, AV_KEY);
    KeyHandle = AVCreateKeyPath(szKey);
    if (!KeyHandle) {
        goto out;
    }
    NtClose(KeyHandle);

    wcscat(szKey, L"\\");
    wcscat(szKey, szExe);
    KeyHandle = AVCreateKeyPath(szKey);
    if (!KeyHandle) {
        goto out;
    }
    NtClose(KeyHandle);

    wcscat(szKey, L"\\");
    wcscat(szKey, szShim);
    KeyHandle = AVCreateKeyPath(szKey);
    if (!KeyHandle) {
        goto out;
    }


    RtlInitUnicodeString(&ustrSetting, szSetting);
    Status = NtSetValueKey(KeyHandle,
                           &ustrSetting,
                           0,
                           REG_DWORD,
                           (PVOID)&dwSetting,
                           sizeof(dwSetting));
    
    NtClose(KeyHandle);

    if (!NT_SUCCESS(Status)) {
        goto out;
    }

    bRet = TRUE;

out:
    return bRet;
}

DWORD GetShimSettingDWORD(
    LPCWSTR     szShim,
    LPCWSTR     szExe,
    LPCWSTR     szSetting,
    DWORD       dwDefault
    )
{
    WCHAR                           szKey[300];
    UNICODE_STRING                  ustrKey;
    UNICODE_STRING                  ustrSetting;
    NTSTATUS                        Status;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    HANDLE                          KeyHandle;
    PKEY_VALUE_PARTIAL_INFORMATION  KeyValueInformation;
    ULONG                           KeyValueBuffer[256];
    ULONG                           KeyValueLength;

    if (!szShim || !szSetting || !szExe) {
        goto out;
    }
    
    wcscpy(szKey, AV_KEY);
    wcscat(szKey, L"\\");
    wcscat(szKey, szExe);
    wcscat(szKey, L"\\");
    wcscat(szKey, szShim);

    RtlInitUnicodeString(&ustrKey, szKey);
    RtlInitUnicodeString(&ustrSetting, szSetting);

    InitializeObjectAttributes(&ObjectAttributes,
                               &ustrKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&KeyHandle,
                       GENERIC_READ,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        //
        // OK, didn't find a specific one for this exe, try the default setting
        //

        wcscpy(szKey, AV_KEY);
        wcscat(szKey, L"\\");
        wcscat(szKey, AVRF_DEFAULT_SETTINGS_NAME_W);
        wcscat(szKey, L"\\");
        wcscat(szKey, szShim);

        RtlInitUnicodeString(&ustrKey, szKey);
        RtlInitUnicodeString(&ustrSetting, szSetting);

        InitializeObjectAttributes(&ObjectAttributes,
                                   &ustrKey,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        Status = NtOpenKey(&KeyHandle,
                           GENERIC_READ,
                           &ObjectAttributes);

        if (!NT_SUCCESS(Status)) {
            goto out;
        }
    }

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)&KeyValueBuffer;

    Status = NtQueryValueKey(KeyHandle,
                             &ustrSetting,
                             KeyValuePartialInformation,
                             KeyValueInformation,
                             sizeof(KeyValueBuffer),
                             &KeyValueLength);

    NtClose(KeyHandle);

    if (!NT_SUCCESS(Status)) {
        goto out;
    }

    //
    // Check for the value type.
    //
    if (KeyValueInformation->Type != REG_DWORD) {
        goto out;
    }

    dwDefault = *(DWORD*)(&KeyValueInformation->Data);

out:
    return dwDefault;
}

BOOL SaveShimSettingString(
    LPCWSTR     szShim,
    LPCWSTR     szExe,
    LPCWSTR     szSetting,
    LPCWSTR     szValue
    )
{
    WCHAR                           szKey[300];
    UNICODE_STRING                  ustrKey;
    UNICODE_STRING                  ustrSetting;
    NTSTATUS                        Status;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    HANDLE                          KeyHandle;
    BOOL                            bRet = FALSE;
    ULONG                           CreateDisposition;

    if (!szShim || !szSetting || !szValue || !szExe) {
        goto out;
    }
    
    //
    // we have to ensure all the sub-keys are created
    //
    wcscpy(szKey, APPCOMPAT_KEY_PATH_MACHINE);
    KeyHandle = AVCreateKeyPath(szKey);
    if (!KeyHandle) {
        goto out;
    }
    NtClose(KeyHandle);

    wcscpy(szKey, AV_KEY);
    KeyHandle = AVCreateKeyPath(szKey);
    if (!KeyHandle) {
        goto out;
    }
    NtClose(KeyHandle);

    wcscat(szKey, L"\\");
    wcscat(szKey, szExe);
    KeyHandle = AVCreateKeyPath(szKey);
    if (!KeyHandle) {
        goto out;
    }
    NtClose(KeyHandle);

    wcscat(szKey, L"\\");
    wcscat(szKey, szShim);
    KeyHandle = AVCreateKeyPath(szKey);
    if (!KeyHandle) {
        goto out;
    }

    RtlInitUnicodeString(&ustrSetting, szSetting);
    Status = NtSetValueKey(KeyHandle,
                           &ustrSetting,
                           0,
                           REG_SZ,
                           (PVOID)szValue,
                           (wcslen(szValue) + 1) * sizeof(WCHAR));
    
    NtClose(KeyHandle);

    if (!NT_SUCCESS(Status)) {
        goto out;
    }

    bRet = TRUE;

out:
    return bRet;
}

BOOL GetShimSettingString(
    LPCWSTR     szShim,
    LPCWSTR     szExe,
    LPCWSTR     szSetting,
    LPWSTR      szResult,
    DWORD       dwBufferLen     // in WCHARs
    )
{
    WCHAR                           szKey[300];
    UNICODE_STRING                  ustrKey;
    UNICODE_STRING                  ustrSetting;
    NTSTATUS                        Status;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    HANDLE                          KeyHandle;
    PKEY_VALUE_PARTIAL_INFORMATION  KeyValueInformation;
    ULONG                           KeyValueBuffer[256];
    ULONG                           KeyValueLength;
    BOOL                            bRet = FALSE;

    if (!szShim || !szSetting || !szResult || !szExe) {
        goto out;
    }
    
    wcscpy(szKey, AV_KEY);
    wcscat(szKey, L"\\");
    wcscat(szKey, szExe);
    wcscat(szKey, L"\\");
    wcscat(szKey, szShim);

    RtlInitUnicodeString(&ustrKey, szKey);
    RtlInitUnicodeString(&ustrSetting, szSetting);

    InitializeObjectAttributes(&ObjectAttributes,
                               &ustrKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&KeyHandle,
                       GENERIC_READ,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        //
        // OK, didn't find a specific one for this exe, try the default setting
        //

        wcscpy(szKey, AV_KEY);
        wcscat(szKey, L"\\");
        wcscat(szKey, AVRF_DEFAULT_SETTINGS_NAME_W);
        wcscat(szKey, L"\\");
        wcscat(szKey, szShim);

        RtlInitUnicodeString(&ustrKey, szKey);
        RtlInitUnicodeString(&ustrSetting, szSetting);

        InitializeObjectAttributes(&ObjectAttributes,
                                   &ustrKey,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        Status = NtOpenKey(&KeyHandle,
                           GENERIC_READ,
                           &ObjectAttributes);

        if (!NT_SUCCESS(Status)) {
            goto out;
        }
    }

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)&KeyValueBuffer;

    Status = NtQueryValueKey(KeyHandle,
                             &ustrSetting,
                             KeyValuePartialInformation,
                             KeyValueInformation,
                             sizeof(KeyValueBuffer),
                             &KeyValueLength);

    NtClose(KeyHandle);

    if (!NT_SUCCESS(Status)) {
        goto out;
    }

    //
    // Check for the value type.
    //
    if (KeyValueInformation->Type != REG_SZ) {
        goto out;
    }

    //
    // check to see if the datalength is bigger than our local nbuffer
    //
    if (KeyValueInformation->DataLength > (sizeof(KeyValueBuffer) - sizeof(KEY_VALUE_PARTIAL_INFORMATION))) {
        KeyValueInformation->DataLength = sizeof(KeyValueBuffer) - sizeof(KEY_VALUE_PARTIAL_INFORMATION);
    }

    //
    // change the buffer length to correspond to the data length, if necessary
    //
    if (KeyValueInformation->DataLength < (dwBufferLen * sizeof(WCHAR))) {
        dwBufferLen = (KeyValueInformation->DataLength / sizeof(WCHAR));
    }

    RtlCopyMemory(szResult, KeyValueInformation->Data, dwBufferLen * sizeof(WCHAR));
    szResult[dwBufferLen - 1] = 0;

    bRet = TRUE;

out:
    return bRet;
}

} // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\external\precomp.h ===
#ifndef _EXTERNAL_PRECOMP_H_
#define _EXTERNAL_PRECOMP_H_

#include "ShimHook.h"

using namespace ShimLib;

#endif // _EXTERNAL_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\external\emulateopengl_llist.hpp ===
// ----------------------------------------------------------------------------
//
// llist.hpp
//
// Author:               Sameer Nene
// Date:                 05/24/96
// Version:              0.1
// Modification History:
// Bugs:
//   
// ----------------------------------------------------------------------------

#ifndef LLIST_INCLUDED
#define LLIST_INCLUDED

//#include <iostream.h>

// forward class declarations

template<class Type> class LListIter;
template<class Type> class LListManip;

template<class Type> class LLink {

  // Private members

  Type d_data;
  LLink<Type> *d_next_p;

  // Links cannot be copied or assigned

  LLink(const LLink<Type>&);
  LLink<Type>& operator=(const LLink<Type>&);

  // Public members
  
public:

  // Construct & Destroy
  
  inline LLink(LLink<Type> **addLinkPtr, const Type &data);
  ~LLink() {}			
  
  // Modifiers
  
  inline void setData(const Type &data);
  inline void setNext(LLink<Type> *link);
  inline LLink<Type>*& getNextRef(); // generally a bad practice
  
  // Accessors
  
  inline Type& getData();
  inline LLink<Type>* getNext() const;

};

template<class Type> class LList {

  // Private members
  
  int d_length;
  LLink<Type> *d_head_p;

  // Friends
  
  friend LListIter<Type>;
  friend LListManip<Type>;

  // Public members
  
public:

  // Construct & Destroy

  LList();
  LList(const LList<Type>&);
  ~LList();

  // Modifiers
  
  LList<Type>& operator=(const LList<Type> &list);
  LList<Type>& operator+=(const Type &i);  
  LList<Type>& operator+=(const LList<Type> &list); 
  LList<Type>& prepend(const Type &i);
  LList<Type>& prepend(const LList<Type> &list); 

  // Accessors
  
  int length() const;

};

//template<class Type> ostream& operator<<(ostream& o, const LList<Type>& list);

template<class Type> class LListIter {

  // Private Data

  LLink<Type> *d_current_p;

  // Public Members
  
public:

  // Construct and Destroy

  inline LListIter(const LList<Type> &list);
  inline LListIter(const LListIter<Type> &iter);
  ~LListIter() {}

  // Modifiers
  inline LListIter<Type>& operator=(const LListIter<Type> &iter);
  inline void operator++();

  // Accessors
  inline operator const void* () const;
  inline Type& operator()() const;

};

template<class Type> class LListManip {

  // Private Data

  LList<Type> *d_list_p;
  LLink<Type> **d_current_p;
  
  // Links cannot be copied or assigned

  LListManip(const LListManip<Type> &manip);	  
  LListManip<Type>& operator=(const LListManip<Type> &manip);

  // Public Members

public:
  // Construct and Destroy
  inline LListManip(LList<Type> *list);
  ~LListManip() {}

  // Modifiers
  inline void operator++();
  inline void insert (const Type &data);
  inline void remove ();

  // Accessors
  inline operator const void *() const;
  inline Type& operator()() const;

};

template<class Type> LLink<Type>::LLink(LLink<Type> **addLinkPtr, const Type &data) : d_next_p(*addLinkPtr), d_data(data)
{
  *addLinkPtr = this;
}

template<class Type> void LLink<Type>::setData(const Type &data)
{
  d_data = data;
}

template<class Type> void LLink<Type>::setNext(LLink<Type> *link)
{
  d_next_p = link;
}

template<class Type> LLink<Type>*& LLink<Type>::getNextRef()
{
  return d_next_p;
}

template<class Type> Type& LLink<Type>::getData()
{
  return d_data;
}

template<class Type> LLink<Type>* LLink<Type>::getNext() const
{
  return d_next_p;
}

template<class Type> LList<Type>::LList() : d_head_p(0), d_length(0)
{
}

template<class Type> LList<Type>::LList(const LList<Type>& list) : d_head_p(0)
{
  LListManip<Type> m(this);
  LListIter<Type> l(list);

  while(l) {
    m.insert(l());
    ++l;
    ++m;
  }
}

template<class Type> LList<Type>::~LList()
{
  LListManip<Type> m(this);

  while(m != 0)
    m.remove();
}

template<class Type> LList<Type>& LList<Type>::operator=(const LList<Type>& list)
{
  LListManip<Type> m(this);
  LListIter<Type> l(list);

  if(this != &list) {
    while(m)
      m.remove();
    while(l) {
      m.insert(l());
      ++l;
      ++m;
    }
  }
  return *this;
}

template<class Type> LList<Type>& LList<Type>::operator+=(const Type &i)
{
  LListManip<Type> m(this);

  while(m)
    ++m;
  m.insert(i);
  return *this;
}

template<class Type> LList<Type>& LList<Type>::operator+=(const LList<Type>& list)
{
  unsigned i, s;
  LListIter<Type> l(list);
  LListManip<Type> m(this);
  
  while(m)
    ++m;
  s = list.d_length;
  for(i = 0; i < s; ++i) {
    m.insert(l());
    ++m;
    ++l;
  }
  return *this;
}

template<class Type> LList<Type>& LList<Type>::prepend(const Type &i)
{
  LListManip<Type> m(this);

  m.insert(i);
  return *this;
}

template<class Type> LList<Type>& LList<Type>::prepend(const LList<Type> &list)
{
  LListIter<Type> l(list);
  LListManip<Type> m(this);

  while(l) {
    m.insert(l());
    ++m;
    ++l;
  }
  return *this;
}

template<class Type> int LList<Type>::length() const
{
  return d_length;
}

//template<class Type> ostream& operator<<(ostream &o, const LList<Type>& list)
//{
//  LListIter<Type> l(list);
//
//  o << "[ ";
//  while(l != 0) {
//    o << l();
//    o << " ";
//    ++l;
//  }
//  return o << "]";
//}

template<class Type> LListIter<Type>::LListIter(const LList<Type> &list) : d_current_p(list.d_head_p)
{
}

template<class Type> LListIter<Type>::LListIter(const LListIter<Type> &iter) : d_current_p(iter.d_current_p)
{
}

template<class Type> LListIter<Type>& LListIter<Type>::operator=(const LListIter<Type> &iter)
{
  d_current_p = iter.d_current_p;
  return *this;
}

template<class Type> void LListIter<Type>::operator++()
{
  d_current_p = d_current_p -> getNext();
}

template<class Type> Type& LListIter<Type>::operator()() const
{
  return d_current_p -> getData();
}

template<class Type> LListIter<Type>::operator const void* () const
{
  return d_current_p;
}

template<class Type> LListManip<Type>::LListManip(LList<Type> *list) : d_current_p(&(list -> d_head_p)), d_list_p(list)
{
}

template<class Type> void LListManip<Type>::operator++()
{
  d_current_p = &((*d_current_p) -> getNextRef());
}

template<class Type> void LListManip<Type>::insert(const Type &data)
{
  new LLink<Type>(d_current_p, data);
  ++(d_list_p -> d_length);
}

template<class Type> void LListManip<Type>::remove()
{
  LLink<Type> *t = *d_current_p;

  *d_current_p = (*d_current_p) -> getNext();
  delete t;
  --(d_list_p -> d_length);
}

template<class Type> LListManip<Type>::operator const void* () const
{
  return *d_current_p;
}

template<class Type> Type& LListManip<Type>::operator()() const
{
  return (*d_current_p) -> getData();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\external\emulateopengl_opengl32.hpp ===
#ifndef EMUGL_INCLUDED
#define EMUGL_INCLUDED

#define D3D_OVERLOADS
#include "d3d8.h"
#include "EmulateOpenGL_llist.hpp"

typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;

//#define DODPFS

/* Version */
#define GL_VERSION_1_1                    1

/* AccumOp */
#define GL_ACCUM                          0x0100
#define GL_LOAD                           0x0101
#define GL_RETURN                         0x0102
#define GL_MULT                           0x0103
#define GL_ADD                            0x0104

/* AlphaFunction */
#define GL_NEVER                          0x0200
#define GL_LESS                           0x0201
#define GL_EQUAL                          0x0202
#define GL_LEQUAL                         0x0203
#define GL_GREATER                        0x0204
#define GL_NOTEQUAL                       0x0205
#define GL_GEQUAL                         0x0206
#define GL_ALWAYS                         0x0207

/* AttribMask */
#define GL_CURRENT_BIT                    0x00000001
#define GL_POINT_BIT                      0x00000002
#define GL_LINE_BIT                       0x00000004
#define GL_POLYGON_BIT                    0x00000008
#define GL_POLYGON_STIPPLE_BIT            0x00000010
#define GL_PIXEL_MODE_BIT                 0x00000020
#define GL_LIGHTING_BIT                   0x00000040
#define GL_FOG_BIT                        0x00000080
#define GL_DEPTH_BUFFER_BIT               0x00000100
#define GL_ACCUM_BUFFER_BIT               0x00000200
#define GL_STENCIL_BUFFER_BIT             0x00000400
#define GL_VIEWPORT_BIT                   0x00000800
#define GL_TRANSFORM_BIT                  0x00001000
#define GL_ENABLE_BIT                     0x00002000
#define GL_COLOR_BUFFER_BIT               0x00004000
#define GL_HINT_BIT                       0x00008000
#define GL_EVAL_BIT                       0x00010000
#define GL_LIST_BIT                       0x00020000
#define GL_TEXTURE_BIT                    0x00040000
#define GL_SCISSOR_BIT                    0x00080000
#define GL_ALL_ATTRIB_BITS                0x000fffff

/* BeginMode */
#define GL_POINTS                         0x0000
#define GL_LINES                          0x0001
#define GL_LINE_LOOP                      0x0002
#define GL_LINE_STRIP                     0x0003
#define GL_TRIANGLES                      0x0004
#define GL_TRIANGLE_STRIP                 0x0005
#define GL_TRIANGLE_FAN                   0x0006
#define GL_QUADS                          0x0007
#define GL_QUAD_STRIP                     0x0008
#define GL_POLYGON                        0x0009

/* BlendingFactorDest */
#define GL_ZERO                           0
#define GL_ONE                            1
#define GL_SRC_COLOR                      0x0300
#define GL_ONE_MINUS_SRC_COLOR            0x0301
#define GL_SRC_ALPHA                      0x0302
#define GL_ONE_MINUS_SRC_ALPHA            0x0303
#define GL_DST_ALPHA                      0x0304
#define GL_ONE_MINUS_DST_ALPHA            0x0305

/* BlendingFactorSrc */
/*      GL_ZERO */
/*      GL_ONE */
#define GL_DST_COLOR                      0x0306
#define GL_ONE_MINUS_DST_COLOR            0x0307
#define GL_SRC_ALPHA_SATURATE             0x0308
/*      GL_SRC_ALPHA */
/*      GL_ONE_MINUS_SRC_ALPHA */
/*      GL_DST_ALPHA */
/*      GL_ONE_MINUS_DST_ALPHA */

/* Boolean */
#define GL_TRUE                           1
#define GL_FALSE                          0

/* ClearBufferMask */
/*      GL_COLOR_BUFFER_BIT */
/*      GL_ACCUM_BUFFER_BIT */
/*      GL_STENCIL_BUFFER_BIT */
/*      GL_DEPTH_BUFFER_BIT */

/* ClientArrayType */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */

/* ClipPlaneName */
#define GL_CLIP_PLANE0                    0x3000
#define GL_CLIP_PLANE1                    0x3001
#define GL_CLIP_PLANE2                    0x3002
#define GL_CLIP_PLANE3                    0x3003
#define GL_CLIP_PLANE4                    0x3004
#define GL_CLIP_PLANE5                    0x3005

/* ColorMaterialFace */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* ColorMaterialParameter */
/*      GL_AMBIENT */
/*      GL_DIFFUSE */
/*      GL_SPECULAR */
/*      GL_EMISSION */
/*      GL_AMBIENT_AND_DIFFUSE */

/* ColorPointerType */
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* CullFaceMode */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* DataType */
#define GL_BYTE                           0x1400
#define GL_UNSIGNED_BYTE                  0x1401
#define GL_SHORT                          0x1402
#define GL_UNSIGNED_SHORT                 0x1403
#define GL_INT                            0x1404
#define GL_UNSIGNED_INT                   0x1405
#define GL_FLOAT                          0x1406
#define GL_2_BYTES                        0x1407
#define GL_3_BYTES                        0x1408
#define GL_4_BYTES                        0x1409
#define GL_DOUBLE                         0x140A

/* DepthFunction */
/*      GL_NEVER */
/*      GL_LESS */
/*      GL_EQUAL */
/*      GL_LEQUAL */
/*      GL_GREATER */
/*      GL_NOTEQUAL */
/*      GL_GEQUAL */
/*      GL_ALWAYS */

/* DrawBufferMode */
#define GL_NONE                           0
#define GL_FRONT_LEFT                     0x0400
#define GL_FRONT_RIGHT                    0x0401
#define GL_BACK_LEFT                      0x0402
#define GL_BACK_RIGHT                     0x0403
#define GL_FRONT                          0x0404
#define GL_BACK                           0x0405
#define GL_LEFT                           0x0406
#define GL_RIGHT                          0x0407
#define GL_FRONT_AND_BACK                 0x0408
#define GL_AUX0                           0x0409
#define GL_AUX1                           0x040A
#define GL_AUX2                           0x040B
#define GL_AUX3                           0x040C

/* Enable */
/*      GL_FOG */
/*      GL_LIGHTING */
/*      GL_TEXTURE_1D */
/*      GL_TEXTURE_2D */
/*      GL_LINE_STIPPLE */
/*      GL_POLYGON_STIPPLE */
/*      GL_CULL_FACE */
/*      GL_ALPHA_TEST */
/*      GL_BLEND */
/*      GL_INDEX_LOGIC_OP */
/*      GL_COLOR_LOGIC_OP */
/*      GL_DITHER */
/*      GL_STENCIL_TEST */
/*      GL_DEPTH_TEST */
/*      GL_CLIP_PLANE0 */
/*      GL_CLIP_PLANE1 */
/*      GL_CLIP_PLANE2 */
/*      GL_CLIP_PLANE3 */
/*      GL_CLIP_PLANE4 */
/*      GL_CLIP_PLANE5 */
/*      GL_LIGHT0 */
/*      GL_LIGHT1 */
/*      GL_LIGHT2 */
/*      GL_LIGHT3 */
/*      GL_LIGHT4 */
/*      GL_LIGHT5 */
/*      GL_LIGHT6 */
/*      GL_LIGHT7 */
/*      GL_TEXTURE_GEN_S */
/*      GL_TEXTURE_GEN_T */
/*      GL_TEXTURE_GEN_R */
/*      GL_TEXTURE_GEN_Q */
/*      GL_MAP1_VERTEX_3 */
/*      GL_MAP1_VERTEX_4 */
/*      GL_MAP1_COLOR_4 */
/*      GL_MAP1_INDEX */
/*      GL_MAP1_NORMAL */
/*      GL_MAP1_TEXTURE_COORD_1 */
/*      GL_MAP1_TEXTURE_COORD_2 */
/*      GL_MAP1_TEXTURE_COORD_3 */
/*      GL_MAP1_TEXTURE_COORD_4 */
/*      GL_MAP2_VERTEX_3 */
/*      GL_MAP2_VERTEX_4 */
/*      GL_MAP2_COLOR_4 */
/*      GL_MAP2_INDEX */
/*      GL_MAP2_NORMAL */
/*      GL_MAP2_TEXTURE_COORD_1 */
/*      GL_MAP2_TEXTURE_COORD_2 */
/*      GL_MAP2_TEXTURE_COORD_3 */
/*      GL_MAP2_TEXTURE_COORD_4 */
/*      GL_POINT_SMOOTH */
/*      GL_LINE_SMOOTH */
/*      GL_POLYGON_SMOOTH */
/*      GL_SCISSOR_TEST */
/*      GL_COLOR_MATERIAL */
/*      GL_NORMALIZE */
/*      GL_AUTO_NORMAL */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */
/*      GL_POLYGON_OFFSET_POINT */
/*      GL_POLYGON_OFFSET_LINE */
/*      GL_POLYGON_OFFSET_FILL */

/* ErrorCode */
#define GL_NO_ERROR                       0
#define GL_INVALID_ENUM                   0x0500
#define GL_INVALID_VALUE                  0x0501
#define GL_INVALID_OPERATION              0x0502
#define GL_STACK_OVERFLOW                 0x0503
#define GL_STACK_UNDERFLOW                0x0504
#define GL_OUT_OF_MEMORY                  0x0505

/* FeedBackMode */
#define GL_2D                             0x0600
#define GL_3D                             0x0601
#define GL_3D_COLOR                       0x0602
#define GL_3D_COLOR_TEXTURE               0x0603
#define GL_4D_COLOR_TEXTURE               0x0604

/* FeedBackToken */
#define GL_PASS_THROUGH_TOKEN             0x0700
#define GL_POINT_TOKEN                    0x0701
#define GL_LINE_TOKEN                     0x0702
#define GL_POLYGON_TOKEN                  0x0703
#define GL_BITMAP_TOKEN                   0x0704
#define GL_DRAW_PIXEL_TOKEN               0x0705
#define GL_COPY_PIXEL_TOKEN               0x0706
#define GL_LINE_RESET_TOKEN               0x0707

/* FogMode */
/*      GL_LINEAR */
#define GL_EXP                            0x0800
#define GL_EXP2                           0x0801

/* FogParameter */
/*      GL_FOG_COLOR */
/*      GL_FOG_DENSITY */
/*      GL_FOG_END */
/*      GL_FOG_INDEX */
/*      GL_FOG_MODE */
/*      GL_FOG_START */

/* FrontFaceDirection */
#define GL_CW                             0x0900
#define GL_CCW                            0x0901

/* GetMapTarget */
#define GL_COEFF                          0x0A00
#define GL_ORDER                          0x0A01
#define GL_DOMAIN                         0x0A02

/* GetPixelMap */
/*      GL_PIXEL_MAP_I_TO_I */
/*      GL_PIXEL_MAP_S_TO_S */
/*      GL_PIXEL_MAP_I_TO_R */
/*      GL_PIXEL_MAP_I_TO_G */
/*      GL_PIXEL_MAP_I_TO_B */
/*      GL_PIXEL_MAP_I_TO_A */
/*      GL_PIXEL_MAP_R_TO_R */
/*      GL_PIXEL_MAP_G_TO_G */
/*      GL_PIXEL_MAP_B_TO_B */
/*      GL_PIXEL_MAP_A_TO_A */

/* GetPointerTarget */
/*      GL_VERTEX_ARRAY_POINTER */
/*      GL_NORMAL_ARRAY_POINTER */
/*      GL_COLOR_ARRAY_POINTER */
/*      GL_INDEX_ARRAY_POINTER */
/*      GL_TEXTURE_COORD_ARRAY_POINTER */
/*      GL_EDGE_FLAG_ARRAY_POINTER */

/* GetTarget */
#define GL_CURRENT_COLOR                  0x0B00
#define GL_CURRENT_INDEX                  0x0B01
#define GL_CURRENT_NORMAL                 0x0B02
#define GL_CURRENT_TEXTURE_COORDS         0x0B03
#define GL_CURRENT_RASTER_COLOR           0x0B04
#define GL_CURRENT_RASTER_INDEX           0x0B05
#define GL_CURRENT_RASTER_TEXTURE_COORDS  0x0B06
#define GL_CURRENT_RASTER_POSITION        0x0B07
#define GL_CURRENT_RASTER_POSITION_VALID  0x0B08
#define GL_CURRENT_RASTER_DISTANCE        0x0B09
#define GL_POINT_SMOOTH                   0x0B10
#define GL_POINT_SIZE                     0x0B11
#define GL_POINT_SIZE_RANGE               0x0B12
#define GL_POINT_SIZE_GRANULARITY         0x0B13
#define GL_LINE_SMOOTH                    0x0B20
#define GL_LINE_WIDTH                     0x0B21
#define GL_LINE_WIDTH_RANGE               0x0B22
#define GL_LINE_WIDTH_GRANULARITY         0x0B23
#define GL_LINE_STIPPLE                   0x0B24
#define GL_LINE_STIPPLE_PATTERN           0x0B25
#define GL_LINE_STIPPLE_REPEAT            0x0B26
#define GL_LIST_MODE                      0x0B30
#define GL_MAX_LIST_NESTING               0x0B31
#define GL_LIST_BASE                      0x0B32
#define GL_LIST_INDEX                     0x0B33
#define GL_POLYGON_MODE                   0x0B40
#define GL_POLYGON_SMOOTH                 0x0B41
#define GL_POLYGON_STIPPLE                0x0B42
#define GL_EDGE_FLAG                      0x0B43
#define GL_CULL_FACE                      0x0B44
#define GL_CULL_FACE_MODE                 0x0B45
#define GL_FRONT_FACE                     0x0B46
#define GL_LIGHTING                       0x0B50
#define GL_LIGHT_MODEL_LOCAL_VIEWER       0x0B51
#define GL_LIGHT_MODEL_TWO_SIDE           0x0B52
#define GL_LIGHT_MODEL_AMBIENT            0x0B53
#define GL_SHADE_MODEL                    0x0B54
#define GL_COLOR_MATERIAL_FACE            0x0B55
#define GL_COLOR_MATERIAL_PARAMETER       0x0B56
#define GL_COLOR_MATERIAL                 0x0B57
#define GL_FOG                            0x0B60
#define GL_FOG_INDEX                      0x0B61
#define GL_FOG_DENSITY                    0x0B62
#define GL_FOG_START                      0x0B63
#define GL_FOG_END                        0x0B64
#define GL_FOG_MODE                       0x0B65
#define GL_FOG_COLOR                      0x0B66
#define GL_DEPTH_RANGE                    0x0B70
#define GL_DEPTH_TEST                     0x0B71
#define GL_DEPTH_WRITEMASK                0x0B72
#define GL_DEPTH_CLEAR_VALUE              0x0B73
#define GL_DEPTH_FUNC                     0x0B74
#define GL_ACCUM_CLEAR_VALUE              0x0B80
#define GL_STENCIL_TEST                   0x0B90
#define GL_STENCIL_CLEAR_VALUE            0x0B91
#define GL_STENCIL_FUNC                   0x0B92
#define GL_STENCIL_VALUE_MASK             0x0B93
#define GL_STENCIL_FAIL                   0x0B94
#define GL_STENCIL_PASS_DEPTH_FAIL        0x0B95
#define GL_STENCIL_PASS_DEPTH_PASS        0x0B96
#define GL_STENCIL_REF                    0x0B97
#define GL_STENCIL_WRITEMASK              0x0B98
#define GL_MATRIX_MODE                    0x0BA0
#define GL_NORMALIZE                      0x0BA1
#define GL_VIEWPORT                       0x0BA2
#define GL_MODELVIEW_STACK_DEPTH          0x0BA3
#define GL_PROJECTION_STACK_DEPTH         0x0BA4
#define GL_TEXTURE_STACK_DEPTH            0x0BA5
#define GL_MODELVIEW_MATRIX               0x0BA6
#define GL_PROJECTION_MATRIX              0x0BA7
#define GL_TEXTURE_MATRIX                 0x0BA8
#define GL_ATTRIB_STACK_DEPTH             0x0BB0
#define GL_CLIENT_ATTRIB_STACK_DEPTH      0x0BB1
#define GL_ALPHA_TEST                     0x0BC0
#define GL_ALPHA_TEST_FUNC                0x0BC1
#define GL_ALPHA_TEST_REF                 0x0BC2
#define GL_DITHER                         0x0BD0
#define GL_BLEND_DST                      0x0BE0
#define GL_BLEND_SRC                      0x0BE1
#define GL_BLEND                          0x0BE2
#define GL_LOGIC_OP_MODE                  0x0BF0
#define GL_INDEX_LOGIC_OP                 0x0BF1
#define GL_COLOR_LOGIC_OP                 0x0BF2
#define GL_AUX_BUFFERS                    0x0C00
#define GL_DRAW_BUFFER                    0x0C01
#define GL_READ_BUFFER                    0x0C02
#define GL_SCISSOR_BOX                    0x0C10
#define GL_SCISSOR_TEST                   0x0C11
#define GL_INDEX_CLEAR_VALUE              0x0C20
#define GL_INDEX_WRITEMASK                0x0C21
#define GL_COLOR_CLEAR_VALUE              0x0C22
#define GL_COLOR_WRITEMASK                0x0C23
#define GL_INDEX_MODE                     0x0C30
#define GL_RGBA_MODE                      0x0C31
#define GL_DOUBLEBUFFER                   0x0C32
#define GL_STEREO                         0x0C33
#define GL_RENDER_MODE                    0x0C40
#define GL_PERSPECTIVE_CORRECTION_HINT    0x0C50
#define GL_POINT_SMOOTH_HINT              0x0C51
#define GL_LINE_SMOOTH_HINT               0x0C52
#define GL_POLYGON_SMOOTH_HINT            0x0C53
#define GL_FOG_HINT                       0x0C54
#define GL_TEXTURE_GEN_S                  0x0C60
#define GL_TEXTURE_GEN_T                  0x0C61
#define GL_TEXTURE_GEN_R                  0x0C62
#define GL_TEXTURE_GEN_Q                  0x0C63
#define GL_PIXEL_MAP_I_TO_I               0x0C70
#define GL_PIXEL_MAP_S_TO_S               0x0C71
#define GL_PIXEL_MAP_I_TO_R               0x0C72
#define GL_PIXEL_MAP_I_TO_G               0x0C73
#define GL_PIXEL_MAP_I_TO_B               0x0C74
#define GL_PIXEL_MAP_I_TO_A               0x0C75
#define GL_PIXEL_MAP_R_TO_R               0x0C76
#define GL_PIXEL_MAP_G_TO_G               0x0C77
#define GL_PIXEL_MAP_B_TO_B               0x0C78
#define GL_PIXEL_MAP_A_TO_A               0x0C79
#define GL_PIXEL_MAP_I_TO_I_SIZE          0x0CB0
#define GL_PIXEL_MAP_S_TO_S_SIZE          0x0CB1
#define GL_PIXEL_MAP_I_TO_R_SIZE          0x0CB2
#define GL_PIXEL_MAP_I_TO_G_SIZE          0x0CB3
#define GL_PIXEL_MAP_I_TO_B_SIZE          0x0CB4
#define GL_PIXEL_MAP_I_TO_A_SIZE          0x0CB5
#define GL_PIXEL_MAP_R_TO_R_SIZE          0x0CB6
#define GL_PIXEL_MAP_G_TO_G_SIZE          0x0CB7
#define GL_PIXEL_MAP_B_TO_B_SIZE          0x0CB8
#define GL_PIXEL_MAP_A_TO_A_SIZE          0x0CB9
#define GL_UNPACK_SWAP_BYTES              0x0CF0
#define GL_UNPACK_LSB_FIRST               0x0CF1
#define GL_UNPACK_ROW_LENGTH              0x0CF2
#define GL_UNPACK_SKIP_ROWS               0x0CF3
#define GL_UNPACK_SKIP_PIXELS             0x0CF4
#define GL_UNPACK_ALIGNMENT               0x0CF5
#define GL_PACK_SWAP_BYTES                0x0D00
#define GL_PACK_LSB_FIRST                 0x0D01
#define GL_PACK_ROW_LENGTH                0x0D02
#define GL_PACK_SKIP_ROWS                 0x0D03
#define GL_PACK_SKIP_PIXELS               0x0D04
#define GL_PACK_ALIGNMENT                 0x0D05
#define GL_MAP_COLOR                      0x0D10
#define GL_MAP_STENCIL                    0x0D11
#define GL_INDEX_SHIFT                    0x0D12
#define GL_INDEX_OFFSET                   0x0D13
#define GL_RED_SCALE                      0x0D14
#define GL_RED_BIAS                       0x0D15
#define GL_ZOOM_X                         0x0D16
#define GL_ZOOM_Y                         0x0D17
#define GL_GREEN_SCALE                    0x0D18
#define GL_GREEN_BIAS                     0x0D19
#define GL_BLUE_SCALE                     0x0D1A
#define GL_BLUE_BIAS                      0x0D1B
#define GL_ALPHA_SCALE                    0x0D1C
#define GL_ALPHA_BIAS                     0x0D1D
#define GL_DEPTH_SCALE                    0x0D1E
#define GL_DEPTH_BIAS                     0x0D1F
#define GL_MAX_EVAL_ORDER                 0x0D30
#define GL_MAX_LIGHTS                     0x0D31
#define GL_MAX_CLIP_PLANES                0x0D32
#define GL_MAX_TEXTURE_SIZE               0x0D33
#define GL_MAX_PIXEL_MAP_TABLE            0x0D34
#define GL_MAX_ATTRIB_STACK_DEPTH         0x0D35
#define GL_MAX_MODELVIEW_STACK_DEPTH      0x0D36
#define GL_MAX_NAME_STACK_DEPTH           0x0D37
#define GL_MAX_PROJECTION_STACK_DEPTH     0x0D38
#define GL_MAX_TEXTURE_STACK_DEPTH        0x0D39
#define GL_MAX_VIEWPORT_DIMS              0x0D3A
#define GL_MAX_CLIENT_ATTRIB_STACK_DEPTH  0x0D3B
#define GL_SUBPIXEL_BITS                  0x0D50
#define GL_INDEX_BITS                     0x0D51
#define GL_RED_BITS                       0x0D52
#define GL_GREEN_BITS                     0x0D53
#define GL_BLUE_BITS                      0x0D54
#define GL_ALPHA_BITS                     0x0D55
#define GL_DEPTH_BITS                     0x0D56
#define GL_STENCIL_BITS                   0x0D57
#define GL_ACCUM_RED_BITS                 0x0D58
#define GL_ACCUM_GREEN_BITS               0x0D59
#define GL_ACCUM_BLUE_BITS                0x0D5A
#define GL_ACCUM_ALPHA_BITS               0x0D5B
#define GL_NAME_STACK_DEPTH               0x0D70
#define GL_AUTO_NORMAL                    0x0D80
#define GL_MAP1_COLOR_4                   0x0D90
#define GL_MAP1_INDEX                     0x0D91
#define GL_MAP1_NORMAL                    0x0D92
#define GL_MAP1_TEXTURE_COORD_1           0x0D93
#define GL_MAP1_TEXTURE_COORD_2           0x0D94
#define GL_MAP1_TEXTURE_COORD_3           0x0D95
#define GL_MAP1_TEXTURE_COORD_4           0x0D96
#define GL_MAP1_VERTEX_3                  0x0D97
#define GL_MAP1_VERTEX_4                  0x0D98
#define GL_MAP2_COLOR_4                   0x0DB0
#define GL_MAP2_INDEX                     0x0DB1
#define GL_MAP2_NORMAL                    0x0DB2
#define GL_MAP2_TEXTURE_COORD_1           0x0DB3
#define GL_MAP2_TEXTURE_COORD_2           0x0DB4
#define GL_MAP2_TEXTURE_COORD_3           0x0DB5
#define GL_MAP2_TEXTURE_COORD_4           0x0DB6
#define GL_MAP2_VERTEX_3                  0x0DB7
#define GL_MAP2_VERTEX_4                  0x0DB8
#define GL_MAP1_GRID_DOMAIN               0x0DD0
#define GL_MAP1_GRID_SEGMENTS             0x0DD1
#define GL_MAP2_GRID_DOMAIN               0x0DD2
#define GL_MAP2_GRID_SEGMENTS             0x0DD3
#define GL_TEXTURE_1D                     0x0DE0
#define GL_TEXTURE_2D                     0x0DE1
#define GL_FEEDBACK_BUFFER_POINTER        0x0DF0
#define GL_FEEDBACK_BUFFER_SIZE           0x0DF1
#define GL_FEEDBACK_BUFFER_TYPE           0x0DF2
#define GL_SELECTION_BUFFER_POINTER       0x0DF3
#define GL_SELECTION_BUFFER_SIZE          0x0DF4
/*      GL_TEXTURE_BINDING_1D */
/*      GL_TEXTURE_BINDING_2D */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */
/*      GL_VERTEX_ARRAY_SIZE */
/*      GL_VERTEX_ARRAY_TYPE */
/*      GL_VERTEX_ARRAY_STRIDE */
/*      GL_NORMAL_ARRAY_TYPE */
/*      GL_NORMAL_ARRAY_STRIDE */
/*      GL_COLOR_ARRAY_SIZE */
/*      GL_COLOR_ARRAY_TYPE */
/*      GL_COLOR_ARRAY_STRIDE */
/*      GL_INDEX_ARRAY_TYPE */
/*      GL_INDEX_ARRAY_STRIDE */
/*      GL_TEXTURE_COORD_ARRAY_SIZE */
/*      GL_TEXTURE_COORD_ARRAY_TYPE */
/*      GL_TEXTURE_COORD_ARRAY_STRIDE */
/*      GL_EDGE_FLAG_ARRAY_STRIDE */
/*      GL_POLYGON_OFFSET_FACTOR */
/*      GL_POLYGON_OFFSET_UNITS */

/* GetTextureParameter */
/*      GL_TEXTURE_MAG_FILTER */
/*      GL_TEXTURE_MIN_FILTER */
/*      GL_TEXTURE_WRAP_S */
/*      GL_TEXTURE_WRAP_T */
#define GL_TEXTURE_WIDTH                  0x1000
#define GL_TEXTURE_HEIGHT                 0x1001
#define GL_TEXTURE_INTERNAL_FORMAT        0x1003
#define GL_TEXTURE_BORDER_COLOR           0x1004
#define GL_TEXTURE_BORDER                 0x1005
/*      GL_TEXTURE_RED_SIZE */
/*      GL_TEXTURE_GREEN_SIZE */
/*      GL_TEXTURE_BLUE_SIZE */
/*      GL_TEXTURE_ALPHA_SIZE */
/*      GL_TEXTURE_LUMINANCE_SIZE */
/*      GL_TEXTURE_INTENSITY_SIZE */
/*      GL_TEXTURE_PRIORITY */
/*      GL_TEXTURE_RESIDENT */

/* HintMode */
#define GL_DONT_CARE                      0x1100
#define GL_FASTEST                        0x1101
#define GL_NICEST                         0x1102

/* HintTarget */
/*      GL_PERSPECTIVE_CORRECTION_HINT */
/*      GL_POINT_SMOOTH_HINT */
/*      GL_LINE_SMOOTH_HINT */
/*      GL_POLYGON_SMOOTH_HINT */
/*      GL_FOG_HINT */

/* IndexPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* LightModelParameter */
/*      GL_LIGHT_MODEL_AMBIENT */
/*      GL_LIGHT_MODEL_LOCAL_VIEWER */
/*      GL_LIGHT_MODEL_TWO_SIDE */

/* LightName */
#define GL_LIGHT0                         0x4000
#define GL_LIGHT1                         0x4001
#define GL_LIGHT2                         0x4002
#define GL_LIGHT3                         0x4003
#define GL_LIGHT4                         0x4004
#define GL_LIGHT5                         0x4005
#define GL_LIGHT6                         0x4006
#define GL_LIGHT7                         0x4007

/* LightParameter */
#define GL_AMBIENT                        0x1200
#define GL_DIFFUSE                        0x1201
#define GL_SPECULAR                       0x1202
#define GL_POSITION                       0x1203
#define GL_SPOT_DIRECTION                 0x1204
#define GL_SPOT_EXPONENT                  0x1205
#define GL_SPOT_CUTOFF                    0x1206
#define GL_CONSTANT_ATTENUATION           0x1207
#define GL_LINEAR_ATTENUATION             0x1208
#define GL_QUADRATIC_ATTENUATION          0x1209

/* InterleavedArrays */
/*      GL_V2F */
/*      GL_V3F */
/*      GL_C4UB_V2F */
/*      GL_C4UB_V3F */
/*      GL_C3F_V3F */
/*      GL_N3F_V3F */
/*      GL_C4F_N3F_V3F */
/*      GL_T2F_V3F */
/*      GL_T4F_V4F */
/*      GL_T2F_C4UB_V3F */
/*      GL_T2F_C3F_V3F */
/*      GL_T2F_N3F_V3F */
/*      GL_T2F_C4F_N3F_V3F */
/*      GL_T4F_C4F_N3F_V4F */

/* ListMode */
#define GL_COMPILE                        0x1300
#define GL_COMPILE_AND_EXECUTE            0x1301

/* ListNameType */
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */
/*      GL_2_BYTES */
/*      GL_3_BYTES */
/*      GL_4_BYTES */

/* LogicOp */
#define GL_CLEAR                          0x1500
#define GL_AND                            0x1501
#define GL_AND_REVERSE                    0x1502
#define GL_COPY                           0x1503
#define GL_AND_INVERTED                   0x1504
#define GL_NOOP                           0x1505
#define GL_XOR                            0x1506
#define GL_OR                             0x1507
#define GL_NOR                            0x1508
#define GL_EQUIV                          0x1509
#define GL_INVERT                         0x150A
#define GL_OR_REVERSE                     0x150B
#define GL_COPY_INVERTED                  0x150C
#define GL_OR_INVERTED                    0x150D
#define GL_NAND                           0x150E
#define GL_SET                            0x150F

/* MapTarget */
/*      GL_MAP1_COLOR_4 */
/*      GL_MAP1_INDEX */
/*      GL_MAP1_NORMAL */
/*      GL_MAP1_TEXTURE_COORD_1 */
/*      GL_MAP1_TEXTURE_COORD_2 */
/*      GL_MAP1_TEXTURE_COORD_3 */
/*      GL_MAP1_TEXTURE_COORD_4 */
/*      GL_MAP1_VERTEX_3 */
/*      GL_MAP1_VERTEX_4 */
/*      GL_MAP2_COLOR_4 */
/*      GL_MAP2_INDEX */
/*      GL_MAP2_NORMAL */
/*      GL_MAP2_TEXTURE_COORD_1 */
/*      GL_MAP2_TEXTURE_COORD_2 */
/*      GL_MAP2_TEXTURE_COORD_3 */
/*      GL_MAP2_TEXTURE_COORD_4 */
/*      GL_MAP2_VERTEX_3 */
/*      GL_MAP2_VERTEX_4 */

/* MaterialFace */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* MaterialParameter */
#define GL_EMISSION                       0x1600
#define GL_SHININESS                      0x1601
#define GL_AMBIENT_AND_DIFFUSE            0x1602
#define GL_COLOR_INDEXES                  0x1603
/*      GL_AMBIENT */
/*      GL_DIFFUSE */
/*      GL_SPECULAR */

/* MatrixMode */
#define GL_MODELVIEW                      0x1700
#define GL_PROJECTION                     0x1701
#define GL_TEXTURE                        0x1702

/* MeshMode1 */
/*      GL_POINT */
/*      GL_LINE */

/* MeshMode2 */
/*      GL_POINT */
/*      GL_LINE */
/*      GL_FILL */

/* NormalPointerType */
/*      GL_BYTE */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* PixelCopyType */
#define GL_COLOR                          0x1800
#define GL_DEPTH                          0x1801
#define GL_STENCIL                        0x1802

/* PixelFormat */
#define GL_COLOR_INDEX                    0x1900
#define GL_STENCIL_INDEX                  0x1901
#define GL_DEPTH_COMPONENT                0x1902
#define GL_RED                            0x1903
#define GL_GREEN                          0x1904
#define GL_BLUE                           0x1905
#define GL_ALPHA                          0x1906
#define GL_RGB                            0x1907
#define GL_RGBA                           0x1908
#define GL_LUMINANCE                      0x1909
#define GL_LUMINANCE_ALPHA                0x190A

/* PixelMap */
/*      GL_PIXEL_MAP_I_TO_I */
/*      GL_PIXEL_MAP_S_TO_S */
/*      GL_PIXEL_MAP_I_TO_R */
/*      GL_PIXEL_MAP_I_TO_G */
/*      GL_PIXEL_MAP_I_TO_B */
/*      GL_PIXEL_MAP_I_TO_A */
/*      GL_PIXEL_MAP_R_TO_R */
/*      GL_PIXEL_MAP_G_TO_G */
/*      GL_PIXEL_MAP_B_TO_B */
/*      GL_PIXEL_MAP_A_TO_A */

/* PixelStore */
/*      GL_UNPACK_SWAP_BYTES */
/*      GL_UNPACK_LSB_FIRST */
/*      GL_UNPACK_ROW_LENGTH */
/*      GL_UNPACK_SKIP_ROWS */
/*      GL_UNPACK_SKIP_PIXELS */
/*      GL_UNPACK_ALIGNMENT */
/*      GL_PACK_SWAP_BYTES */
/*      GL_PACK_LSB_FIRST */
/*      GL_PACK_ROW_LENGTH */
/*      GL_PACK_SKIP_ROWS */
/*      GL_PACK_SKIP_PIXELS */
/*      GL_PACK_ALIGNMENT */

/* PixelTransfer */
/*      GL_MAP_COLOR */
/*      GL_MAP_STENCIL */
/*      GL_INDEX_SHIFT */
/*      GL_INDEX_OFFSET */
/*      GL_RED_SCALE */
/*      GL_RED_BIAS */
/*      GL_GREEN_SCALE */
/*      GL_GREEN_BIAS */
/*      GL_BLUE_SCALE */
/*      GL_BLUE_BIAS */
/*      GL_ALPHA_SCALE */
/*      GL_ALPHA_BIAS */
/*      GL_DEPTH_SCALE */
/*      GL_DEPTH_BIAS */

/* PixelType */
#define GL_BITMAP                         0x1A00
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */

/* PolygonMode */
#define GL_POINT                          0x1B00
#define GL_LINE                           0x1B01
#define GL_FILL                           0x1B02

/* ReadBufferMode */
/*      GL_FRONT_LEFT */
/*      GL_FRONT_RIGHT */
/*      GL_BACK_LEFT */
/*      GL_BACK_RIGHT */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_LEFT */
/*      GL_RIGHT */
/*      GL_AUX0 */
/*      GL_AUX1 */
/*      GL_AUX2 */
/*      GL_AUX3 */

/* RenderingMode */
#define GL_RENDER                         0x1C00
#define GL_FEEDBACK                       0x1C01
#define GL_SELECT                         0x1C02

/* ShadingModel */
#define GL_FLAT                           0x1D00
#define GL_SMOOTH                         0x1D01

/* StencilFunction */
/*      GL_NEVER */
/*      GL_LESS */
/*      GL_EQUAL */
/*      GL_LEQUAL */
/*      GL_GREATER */
/*      GL_NOTEQUAL */
/*      GL_GEQUAL */
/*      GL_ALWAYS */

/* StencilOp */
/*      GL_ZERO */
#define GL_KEEP                           0x1E00
#define GL_REPLACE                        0x1E01
#define GL_INCR                           0x1E02
#define GL_DECR                           0x1E03
/*      GL_INVERT */

/* StringName */
#define GL_VENDOR                         0x1F00
#define GL_RENDERER                       0x1F01
#define GL_VERSION                        0x1F02
#define GL_EXTENSIONS                     0x1F03

/* TextureCoordName */
#define GL_S                              0x2000
#define GL_T                              0x2001
#define GL_R                              0x2002
#define GL_Q                              0x2003

/* TexCoordPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* TextureEnvMode */
#define GL_MODULATE                       0x2100
#define GL_DECAL                          0x2101
/*      GL_BLEND */
/*      GL_REPLACE */

/* TextureEnvParameter */
#define GL_TEXTURE_ENV_MODE               0x2200
#define GL_TEXTURE_ENV_COLOR              0x2201

/* TextureEnvTarget */
#define GL_TEXTURE_ENV                    0x2300

/* TextureGenMode */
#define GL_EYE_LINEAR                     0x2400
#define GL_OBJECT_LINEAR                  0x2401
#define GL_SPHERE_MAP                     0x2402

/* TextureGenParameter */
#define GL_TEXTURE_GEN_MODE               0x2500
#define GL_OBJECT_PLANE                   0x2501
#define GL_EYE_PLANE                      0x2502

/* TextureMagFilter */
#define GL_NEAREST                        0x2600
#define GL_LINEAR                         0x2601

/* TextureMinFilter */
/*      GL_NEAREST */
/*      GL_LINEAR */
#define GL_NEAREST_MIPMAP_NEAREST         0x2700
#define GL_LINEAR_MIPMAP_NEAREST          0x2701
#define GL_NEAREST_MIPMAP_LINEAR          0x2702
#define GL_LINEAR_MIPMAP_LINEAR           0x2703

/* TextureParameterName */
#define GL_TEXTURE_MAG_FILTER             0x2800
#define GL_TEXTURE_MIN_FILTER             0x2801
#define GL_TEXTURE_WRAP_S                 0x2802
#define GL_TEXTURE_WRAP_T                 0x2803
/*      GL_TEXTURE_BORDER_COLOR */
/*      GL_TEXTURE_PRIORITY */

/* TextureTarget */
/*      GL_TEXTURE_1D */
/*      GL_TEXTURE_2D */
/*      GL_PROXY_TEXTURE_1D */
/*      GL_PROXY_TEXTURE_2D */

/* TextureWrapMode */
#define GL_CLAMP                          0x2900
#define GL_REPEAT                         0x2901

/* VertexPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* ClientAttribMask */
#define GL_CLIENT_PIXEL_STORE_BIT         0x00000001
#define GL_CLIENT_VERTEX_ARRAY_BIT        0x00000002
#define GL_CLIENT_ALL_ATTRIB_BITS         0xffffffff

/* polygon_offset */
#define GL_POLYGON_OFFSET_FACTOR          0x8038
#define GL_POLYGON_OFFSET_UNITS           0x2A00
#define GL_POLYGON_OFFSET_POINT           0x2A01
#define GL_POLYGON_OFFSET_LINE            0x2A02
#define GL_POLYGON_OFFSET_FILL            0x8037

/* texture */
#define GL_ALPHA4                         0x803B
#define GL_ALPHA8                         0x803C
#define GL_ALPHA12                        0x803D
#define GL_ALPHA16                        0x803E
#define GL_LUMINANCE4                     0x803F
#define GL_LUMINANCE8                     0x8040
#define GL_LUMINANCE12                    0x8041
#define GL_LUMINANCE16                    0x8042
#define GL_LUMINANCE4_ALPHA4              0x8043
#define GL_LUMINANCE6_ALPHA2              0x8044
#define GL_LUMINANCE8_ALPHA8              0x8045
#define GL_LUMINANCE12_ALPHA4             0x8046
#define GL_LUMINANCE12_ALPHA12            0x8047
#define GL_LUMINANCE16_ALPHA16            0x8048
#define GL_INTENSITY                      0x8049
#define GL_INTENSITY4                     0x804A
#define GL_INTENSITY8                     0x804B
#define GL_INTENSITY12                    0x804C
#define GL_INTENSITY16                    0x804D
#define GL_R3_G3_B2                       0x2A10
#define GL_RGB4                           0x804F
#define GL_RGB5                           0x8050
#define GL_RGB8                           0x8051
#define GL_RGB10                          0x8052
#define GL_RGB12                          0x8053
#define GL_RGB16                          0x8054
#define GL_RGBA2                          0x8055
#define GL_RGBA4                          0x8056
#define GL_RGB5_A1                        0x8057
#define GL_RGBA8                          0x8058
#define GL_RGB10_A2                       0x8059
#define GL_RGBA12                         0x805A
#define GL_RGBA16                         0x805B
#define GL_TEXTURE_RED_SIZE               0x805C
#define GL_TEXTURE_GREEN_SIZE             0x805D
#define GL_TEXTURE_BLUE_SIZE              0x805E
#define GL_TEXTURE_ALPHA_SIZE             0x805F
#define GL_TEXTURE_LUMINANCE_SIZE         0x8060
#define GL_TEXTURE_INTENSITY_SIZE         0x8061
#define GL_PROXY_TEXTURE_1D               0x8063
#define GL_PROXY_TEXTURE_2D               0x8064

/* texture_object */
#define GL_TEXTURE_PRIORITY               0x8066
#define GL_TEXTURE_RESIDENT               0x8067
#define GL_TEXTURE_BINDING_1D             0x8068
#define GL_TEXTURE_BINDING_2D             0x8069

/* vertex_array */
#define GL_VERTEX_ARRAY                   0x8074
#define GL_NORMAL_ARRAY                   0x8075
#define GL_COLOR_ARRAY                    0x8076
#define GL_INDEX_ARRAY                    0x8077
#define GL_TEXTURE_COORD_ARRAY            0x8078
#define GL_EDGE_FLAG_ARRAY                0x8079
#define GL_VERTEX_ARRAY_SIZE              0x807A
#define GL_VERTEX_ARRAY_TYPE              0x807B
#define GL_VERTEX_ARRAY_STRIDE            0x807C
#define GL_NORMAL_ARRAY_TYPE              0x807E
#define GL_NORMAL_ARRAY_STRIDE            0x807F
#define GL_COLOR_ARRAY_SIZE               0x8081
#define GL_COLOR_ARRAY_TYPE               0x8082
#define GL_COLOR_ARRAY_STRIDE             0x8083
#define GL_INDEX_ARRAY_TYPE               0x8085
#define GL_INDEX_ARRAY_STRIDE             0x8086
#define GL_TEXTURE_COORD_ARRAY_SIZE       0x8088
#define GL_TEXTURE_COORD_ARRAY_TYPE       0x8089
#define GL_TEXTURE_COORD_ARRAY_STRIDE     0x808A
#define GL_EDGE_FLAG_ARRAY_STRIDE         0x808C
#define GL_VERTEX_ARRAY_POINTER           0x808E
#define GL_NORMAL_ARRAY_POINTER           0x808F
#define GL_COLOR_ARRAY_POINTER            0x8090
#define GL_INDEX_ARRAY_POINTER            0x8091
#define GL_TEXTURE_COORD_ARRAY_POINTER    0x8092
#define GL_EDGE_FLAG_ARRAY_POINTER        0x8093
#define GL_V2F                            0x2A20
#define GL_V3F                            0x2A21
#define GL_C4UB_V2F                       0x2A22
#define GL_C4UB_V3F                       0x2A23
#define GL_C3F_V3F                        0x2A24
#define GL_N3F_V3F                        0x2A25
#define GL_C4F_N3F_V3F                    0x2A26
#define GL_T2F_V3F                        0x2A27
#define GL_T4F_V4F                        0x2A28
#define GL_T2F_C4UB_V3F                   0x2A29
#define GL_T2F_C3F_V3F                    0x2A2A
#define GL_T2F_N3F_V3F                    0x2A2B
#define GL_T2F_C4F_N3F_V3F                0x2A2C
#define GL_T4F_C4F_N3F_V4F                0x2A2D

/* Extensions */
#define GL_EXT_vertex_array               1
#define GL_WIN_swap_hint                  1
#define GL_EXT_bgra                       1
#define GL_EXT_paletted_texture           1

/* EXT_vertex_array */
#define GL_VERTEX_ARRAY_EXT               0x8074
#define GL_NORMAL_ARRAY_EXT               0x8075
#define GL_COLOR_ARRAY_EXT                0x8076
#define GL_INDEX_ARRAY_EXT                0x8077
#define GL_TEXTURE_COORD_ARRAY_EXT        0x8078
#define GL_EDGE_FLAG_ARRAY_EXT            0x8079
#define GL_VERTEX_ARRAY_SIZE_EXT          0x807A
#define GL_VERTEX_ARRAY_TYPE_EXT          0x807B
#define GL_VERTEX_ARRAY_STRIDE_EXT        0x807C
#define GL_VERTEX_ARRAY_COUNT_EXT         0x807D
#define GL_NORMAL_ARRAY_TYPE_EXT          0x807E
#define GL_NORMAL_ARRAY_STRIDE_EXT        0x807F
#define GL_NORMAL_ARRAY_COUNT_EXT         0x8080
#define GL_COLOR_ARRAY_SIZE_EXT           0x8081
#define GL_COLOR_ARRAY_TYPE_EXT           0x8082
#define GL_COLOR_ARRAY_STRIDE_EXT         0x8083
#define GL_COLOR_ARRAY_COUNT_EXT          0x8084
#define GL_INDEX_ARRAY_TYPE_EXT           0x8085
#define GL_INDEX_ARRAY_STRIDE_EXT         0x8086
#define GL_INDEX_ARRAY_COUNT_EXT          0x8087
#define GL_TEXTURE_COORD_ARRAY_SIZE_EXT   0x8088
#define GL_TEXTURE_COORD_ARRAY_TYPE_EXT   0x8089
#define GL_TEXTURE_COORD_ARRAY_STRIDE_EXT 0x808A
#define GL_TEXTURE_COORD_ARRAY_COUNT_EXT  0x808B
#define GL_EDGE_FLAG_ARRAY_STRIDE_EXT     0x808C
#define GL_EDGE_FLAG_ARRAY_COUNT_EXT      0x808D
#define GL_VERTEX_ARRAY_POINTER_EXT       0x808E
#define GL_NORMAL_ARRAY_POINTER_EXT       0x808F
#define GL_COLOR_ARRAY_POINTER_EXT        0x8090
#define GL_INDEX_ARRAY_POINTER_EXT        0x8091
#define GL_TEXTURE_COORD_ARRAY_POINTER_EXT 0x8092
#define GL_EDGE_FLAG_ARRAY_POINTER_EXT    0x8093
#define GL_DOUBLE_EXT                     GL_DOUBLE

/* EXT_bgra */
#define GL_BGR_EXT                        0x80E0
#define GL_BGRA_EXT                       0x80E1

/* EXT_paletted_texture */

/* These must match the GL_COLOR_TABLE_*_SGI enumerants */
#define GL_COLOR_TABLE_FORMAT_EXT         0x80D8
#define GL_COLOR_TABLE_WIDTH_EXT          0x80D9
#define GL_COLOR_TABLE_RED_SIZE_EXT       0x80DA
#define GL_COLOR_TABLE_GREEN_SIZE_EXT     0x80DB
#define GL_COLOR_TABLE_BLUE_SIZE_EXT      0x80DC
#define GL_COLOR_TABLE_ALPHA_SIZE_EXT     0x80DD
#define GL_COLOR_TABLE_LUMINANCE_SIZE_EXT 0x80DE
#define GL_COLOR_TABLE_INTENSITY_SIZE_EXT 0x80DF

#define GL_COLOR_INDEX1_EXT               0x80E2
#define GL_COLOR_INDEX2_EXT               0x80E3
#define GL_COLOR_INDEX4_EXT               0x80E4
#define GL_COLOR_INDEX8_EXT               0x80E5
#define GL_COLOR_INDEX12_EXT              0x80E6
#define GL_COLOR_INDEX16_EXT              0x80E7

/* For compatibility with OpenGL v1.0 */
#define GL_LOGIC_OP GL_INDEX_LOGIC_OP
#define GL_TEXTURE_COMPONENTS GL_TEXTURE_INTERNAL_FORMAT

/* Multitexture extensions */
#define GL_TEXTURE0_SGIS                  0x835E
#define GL_TEXTURE1_SGIS                  0x835F
#define GL_TEXTURE2_SGIS                  0x8360
#define GL_TEXTURE3_SGIS                  0x8361

#define GL_TEXTURE0_ARB                   0x84C0
#define GL_TEXTURE1_ARB                   0x84C1

#define GL_MAX_ACTIVE_TEXTURES_ARB        0x84E2

#define MAXGLTEXHANDLES 65536

struct QuakeVertex 
{
    FLOAT x, y, z;
    FLOAT nx, ny, nz;
    D3DCOLOR color;
    FLOAT tu, tv, tu2, tv2;
};

#define QUAKEVFMT (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE | D3DFVF_TEX2)

#define VBUFSIZE 8192
#define MAXVERTSPERPRIM 512

#define RGBA_MAKE(r, g, b, a)   ((D3DCOLOR) (((a) << 24) | ((r) << 16) | ((g) << 8) | (b)))

#define RESPATH_QUAKE L"Software\\Microsoft\\Quake"

struct TexInfo {
  DWORD m_block;
  DWORD m_dwStage;
  BOOL m_capture;
  GLint m_internalformat;
  D3DFORMAT m_fmt;
  GLsizei m_width;
  GLsizei m_height;
  GLsizei m_oldwidth;
  GLsizei m_oldheight;
  IDirect3DTexture8 *m_ddsurf;
  D3DTEXTUREFILTERTYPE m_minmode;
  D3DTEXTUREFILTERTYPE m_magmode;
  D3DTEXTUREFILTERTYPE m_mipmode;
  DWORD m_addu, m_addv;
  INT m_prev, m_next;
};

struct Globals {

  // Cache Line 1
  LPDIRECT3DDEVICE8 m_d3ddev;
  DWORD m_curshader;
  GLenum m_prim;
  unsigned m_nfv;
  unsigned m_vcnt;
  QuakeVertex *m_verts;
  BOOL m_texturing;
  BOOL m_mtex;

  // Cache Line 2
  // Following always needs to be together
  /********************************/
  FLOAT m_nx, m_ny, m_nz;
  D3DCOLOR m_color;
  FLOAT m_tu, m_tv, m_tu2, m_tv2;
  /********************************/

  // Cache Line 3
  LPDIRECT3DVERTEXBUFFER8 m_vbuf, m_xyzbuf, m_colbuf, m_texbuf, m_tex2buf;
  LPDIRECT3DINDEXBUFFER8 m_ibuf;

  DWORD m_shaders[2][10];
  int m_winWidth;
  int m_winHeight;
  GLint m_scix, m_sciy;
  GLsizei m_sciw, m_scih;
  GLint m_vwx, m_vwy;
  GLsizei m_vww, m_vwh;
  GLint m_lckfirst;
  GLsizei m_lckcount;
  HWND m_hwnd;
  HDC m_hdc;
  D3DMATERIAL8 m_material;
  D3DFORMAT m_ddFourBitAlphaSurfFormat;
  D3DFORMAT m_ddEightBitAlphaSurfFormat;
  D3DFORMAT m_ddEightBitAlphaOnlySurfFormat;
  D3DFORMAT m_ddFiveBitSurfFormat;
  D3DFORMAT m_ddEightBitSurfFormat;
  D3DFORMAT m_ddLuminanceSurfFormat;
  D3DCAPS8 m_dd;
  GLenum m_cullMode;
  GLenum m_FrontFace;
  D3DTRANSFORMSTATETYPE m_matrixMode;
  BOOL m_cullEnabled;
  BOOL m_texHandleValid;
  BOOL m_subsample;
  BOOL m_usemtex;
  BOOL m_usemipmap;
  BOOL m_doFlip;
  BOOL m_makeSquare;
  BOOL m_scissoring;
  BOOL m_updvwp;
  BOOL m_polyoffset;
  BOOL m_usecolorary, m_usetexcoordary[2], m_usevertexary;
  BOOL m_withinprim;
  BOOL m_texgen;
  DWORD m_vshader[6];
  GLuint m_curstagebinding[2];
  GLenum m_curtgt, m_client_active_texture_arb;
  int m_blendmode[2];
  D3DCOLOR m_clearColor;
  GLclampd m_clearDepth;
  DWORD m_clearStencil;
  const void *m_vertexary;
  const void *m_colorary;
  DWORD m_vertexarystride;
  DWORD m_colorarystride;
  DWORD m_clippstate;
  DWORD m_free;
  DWORD m_cbufbit;
  DWORD m_lightdirty;
  const void *m_texcoordary[2];
  DWORD m_texcoordarystride[2];
  LList<D3DMATRIX> m_matrixStack[4];
  D3DVIEWPORT8 m_vport;
  WNDPROC m_wndproc;
#if 0
  DWORD m_lod;
#endif
  DWORD m_vbufoff, m_vbufsz, m_ibufoff, m_ibufsz;
  IDirect3DVertexBuffer8 *m_pStreams[4];
  DWORD m_pStrides[4];
  D3DLIGHT8 m_light[8];
  FLOAT m_lightPositionW[8];
  D3DMATRIX m_xfrm[512];
  TexInfo m_tex[MAXGLTEXHANDLES]; // support upto MAXGLTEXHANDLES for the time being;
};

inline DWORD miplevels(DWORD w, DWORD h)
{
    DWORD m = w > h ? w : h;
    for(DWORD t = 0; m != 0; ++t)
    {
        m >>= 1;
    }
    return t;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\external\main.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Main.cpp

 Abstract:

    Container for all shim definitions.

 History:

    12/11/2000 linstev Created

--*/

#include "precomp.h"
#include "ShimHookMacro.h"

DECLARE_SHIM(EmulateOpenGL)
DECLARE_SHIM(PrinterGetPrtL2)
DECLARE_SHIM(PrinterJTDevmode)
DECLARE_SHIM(TermServLayer)
DECLARE_SHIM(TSPerUserFiles)

VOID MULTISHIM_NOTIFY_FUNCTION()(DWORD fdwReason)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DPF("ExternalShims", eDbgLevelSpew, "External Shims initialized.");
            break;

        case DLL_PROCESS_DETACH:
            DPF("ExternalShims", eDbgLevelSpew, "External Shims uninitialized.");
            break;

        default:
            break;
    }
}

MULTISHIM_BEGIN()
    MULTISHIM_ENTRY(EmulateOpenGL)
    MULTISHIM_ENTRY(PrinterGetPrtL2)
    MULTISHIM_ENTRY(PrinterJTDevmode)
    MULTISHIM_ENTRY(TermServLayer)
    MULTISHIM_ENTRY(TSPerUserFiles)

    CALL_MULTISHIM_NOTIFY_FUNCTION()
MULTISHIM_END()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\external\printergetprtl2.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

   PrinterGetPrtL2.cpp

 Abstract:

   This is a shim that can be applied to those applications who
   assumed false upper-limit on the size of PRINTER_INFO_2 buffer
   GetPrinter returns. What the shim does is that when it detects
   the spooler returned PRINTER_INFO_2 buffer is over a certain
   limit that could break those apps, it truncates the private
   devmode part in PRINTER_INFO_2's pDevMode to retain only the
   public devmode, and returns the truncated PRINTER_INFO_2 buffer.

 History:

   10/29/2001   fengy   Created

--*/

#include "precomp.h"
#include <stddef.h>

IMPLEMENT_SHIM_BEGIN(PrinterGetPrtL2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetPrinterA)
APIHOOK_ENUM_END

#define ALIGN_PTR_UP(addr) ((ULONG_PTR)((ULONG_PTR)(addr) + (sizeof(ULONG_PTR) - 1)) & ~(sizeof(ULONG_PTR) - 1))

//
// The PRINTER_INFO_2 buffer size limit over which this shim
// will perform the devmode truncation. The default value is
// set to 8K here. App-specific limit values can be specified
// as decimal numbers in the XML database as following:
//
// <SHIM NAME="PrinterGetPrtL2" COMMAND_LINE="1024"/>
//
LONG g_lTruncateLimit = 0x2000;

//
// Table of offsets to each string field in PRINTER_INFO_2A
//
DWORD g_dwStringOffsets[] = {offsetof(PRINTER_INFO_2A, pServerName),
                             offsetof(PRINTER_INFO_2A, pPrinterName),
                             offsetof(PRINTER_INFO_2A, pShareName),
                             offsetof(PRINTER_INFO_2A, pPortName),
                             offsetof(PRINTER_INFO_2A, pDriverName),
                             offsetof(PRINTER_INFO_2A, pComment),
                             offsetof(PRINTER_INFO_2A, pLocation),
                             offsetof(PRINTER_INFO_2A, pSepFile),
                             offsetof(PRINTER_INFO_2A, pPrintProcessor),
                             offsetof(PRINTER_INFO_2A, pDatatype),
                             offsetof(PRINTER_INFO_2A, pParameters),
                             0xFFFFFFFF};

/*++

 This stub function intercepts all level 2 calls to GetPrinterA and detects
 if the spooler returned PRINTER_INFO_2 buffer is over the app limit. If so,
 it will truncate the private devmode of PRINTER_INFO_2's pDevMode.

--*/
BOOL
APIHOOK(GetPrinterA)(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    BOOL  bNoTruncation = TRUE;
    BOOL  bRet;

    if (Level == 2 && pPrinter != NULL && cbBuf != 0)
    {
        PRINTER_INFO_2A *pInfo2Full = NULL;
        DWORD           cbFullNeeded = 0;

        //
        // Call spooler to get the full PRINTER_INFO_2 buffer size
        //
        bRet = ORIGINAL_API(GetPrinterA)(
            hPrinter,
            2,
            NULL,
            0,
            &cbFullNeeded);

       if (!bRet &&
           GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
           cbFullNeeded > (DWORD)g_lTruncateLimit &&
           cbBuf >= cbFullNeeded &&
           (pInfo2Full = (PRINTER_INFO_2A *)malloc(cbFullNeeded)))
       {
           //
           // The full PRINTER_INFO_2 buffer size is over the app limit,
           // so we will first retrieve the full buffer into our internal
           // buffer.
           //
           // The condition "cbBuf >= cbFullNeeded" is here because if
           // that's not true, the original GetPrinterA's behavior is to
           // fail the call. We don't want to change that behavior.
           //
           bRet = ORIGINAL_API(GetPrinterA)(
               hPrinter,
               2,
               (PBYTE)pInfo2Full,
               cbFullNeeded,
               &cbFullNeeded);

           if (bRet)
           {
               PRINTER_INFO_2A *pInfo2In;
               PBYTE pDest;
               INT   i;

               //
               // Having the full PRINTER_INFO_2 structure in our internal
               // buffer, now we will copy it into app-allocated output buffer
               // by duplicating every thing except for the pDevMode. For
               // pDevMode we will only copy over the public devmode part,
               // because the bigger size of PRINTER_INFO_2 structure usually
               // are caused by big private devmode.
               //
               pInfo2In = (PRINTER_INFO_2A *)pPrinter;
               pDest = (PBYTE)pInfo2In + sizeof(PRINTER_INFO_2A);

               //
               // First copy over all the strings
               //
               i = 0;
               while (g_dwStringOffsets[i] != (-1))
               {
                   PSTR pSrc;

                   pSrc = *(PSTR *)((PBYTE)pInfo2Full + g_dwStringOffsets[i]);

                   if (pSrc)
                   {
                       DWORD  cbStrSize;

                       cbStrSize = strlen(pSrc) + sizeof(CHAR);
                       memcpy(pDest, pSrc, cbStrSize);

                       *(PSTR *)((PBYTE)pInfo2In + g_dwStringOffsets[i]) = (PSTR)pDest;
                       pDest += cbStrSize;
                   }
                   else
                   {
                      *(PSTR *)((PBYTE)pInfo2In + g_dwStringOffsets[i]) = NULL;
                   }

                   i++;
               }

               //
               // Then truncate the private devmode part by only copying over
               // public devmode
               //
               if (pInfo2Full->pDevMode)
               {
                   pDest = (PBYTE)ALIGN_PTR_UP(pDest);
                   memcpy(pDest, pInfo2Full->pDevMode, pInfo2Full->pDevMode->dmSize);
                   pInfo2In->pDevMode = (DEVMODEA *)pDest;

                   //
                   // Set private devmode size to zero since it was just truncated
                   //
                   pInfo2In->pDevMode->dmDriverExtra = 0;

                   pDest += pInfo2In->pDevMode->dmSize;
               }
               else
               {
                   pInfo2In->pDevMode = NULL;
               }

               //
               // Then copy over the security descriptor
               //
               if (pInfo2Full->pSecurityDescriptor &&
                   IsValidSecurityDescriptor(pInfo2Full->pSecurityDescriptor))
               {
                   DWORD  cbSDSize;

                   cbSDSize = GetSecurityDescriptorLength(pInfo2Full->pSecurityDescriptor);

                   pDest = (PBYTE)ALIGN_PTR_UP(pDest);
                   memcpy(pDest, pInfo2Full->pSecurityDescriptor, cbSDSize);
                   pInfo2In->pSecurityDescriptor = (PSECURITY_DESCRIPTOR)pDest;

                   pDest += cbSDSize;
               }
               else
               {
                   pInfo2In->pSecurityDescriptor = NULL;
               }

               //
               // Lastly copy over all the DWORD fields
               //
               pInfo2In->Attributes      = pInfo2Full->Attributes;
               pInfo2In->Priority        = pInfo2Full->Priority;
               pInfo2In->DefaultPriority = pInfo2Full->DefaultPriority;
               pInfo2In->StartTime       = pInfo2Full->StartTime;
               pInfo2In->UntilTime       = pInfo2Full->UntilTime;
               pInfo2In->Status          = pInfo2Full->Status;
               pInfo2In->cJobs           = pInfo2Full->cJobs;
               pInfo2In->AveragePPM      = pInfo2Full->AveragePPM;

               //
               // We also need to set the correct return buffer size
               //
               if (pcbNeeded)
               {
                   *pcbNeeded = pDest - pPrinter;
               }

               bNoTruncation = FALSE;

               DPFN(eDbgLevelInfo, "GetPrinterA truncated from %X to %X bytes",
                                    cbBuf, pDest - pPrinter);
           }
       }

       if (pInfo2Full)
       {
           free(pInfo2Full);
           pInfo2Full = NULL;
       }
    }

    if (bNoTruncation)
    {
        //
        // The shim doesn't need to do any truncation, or it has hit
        // an error when it was doing the truncation, so we will
        // just let the original API handle the call.
        //
        bRet = ORIGINAL_API(GetPrinterA)(
            hPrinter,
            Level,
            pPrinter,
            cbBuf,
            pcbNeeded);
    }

    return bRet;
}

/*++

 Handle DLL_PROCESS_ATTACH to retrieve command line parameter.

--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        LONG lLimit = atol(COMMAND_LINE);

        if (lLimit > 0)
        {
            g_lTruncateLimit = lLimit;
        }
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/
HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(WINSPOOL.DRV, GetPrinterA);

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\external\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

!ENDIF

TARGETNAME=AcXtrnal

TARGETTYPE=DYNLINK

SOURCES=..\ver.rc                                  \
        ..\Main.cpp                                \
        ..\EmulateOpenGL.cpp                       \
        ..\EmulateOpenGL_OpenGL32.cpp              \
        ..\EmulateOpenGL_GLStubs.cpp               \
        ..\PrinterGetPrtL2.cpp                     \
        ..\PrinterJTDevmode.cpp                    \
        ..\TermServLayer.cpp                       \
        ..\TSPerUserFiles.cpp                      \
        ..\TSPerUserFiles_Utils.cpp

C_DEFINES=$(C_DEFINES) -DSHIM_HOOKDLL_VERSION2

TARGETPATH=$(_OBJ_DIR)

INCLUDES=$(INCLUDES);                           \
         ..;                                    \
         $(TERMSRV_INC_PATH)


TARGETLIBS=$(TARGETLIBS)                        \
           $(SDK_LIB_PATH)\ntdll.lib            \
           $(SDK_LIB_PATH)\d3d8.lib             \
           $(SDK_LIB_PATH)\user32.lib           \
           $(SDK_LIB_PATH)\gdi32.lib            \
           $(SDK_LIB_PATH)\advapi32.lib         \
           $(SDK_LIB_PATH)\kernel32.lib         \
           $(SDK_LIB_PATH)\uuid.lib             \
           $(SDK_LIB_PATH)\shell32.lib          \
           ..\..\lib\dxguid.lib

DLLDEF = ..\EmulateOpenGL.def

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\external\printerjtdevmode.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

   PrinterJTDevmode.cpp

 Abstract:

   This is a shim that can be applied to those applications who
   assumed false upper-limit on the devmode size. With the support
   of job ticket, Longhorn+ inbox printer drivers' devmode could
   be over those upper-limits and therefore may cause those apps
   to crash. What this shim does is to set a private flag for the
   DocumentPropertiesA API. Our Longhorn inbox printer drivers
   recognize this flag and know not to add the job ticket expansion
   block in returned devmode.

 History:

   10/29/2001   fengy   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(PrinterJTDevmode)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(DocumentPropertiesA)
APIHOOK_ENUM_END

#define DM_NOJTEXP_SHIM      0x80000000

/*++

 This stub function intercepts all calls to DocumentPropertiesA
 and sets the private fMode flag DM_NOJTEXP_SHIM properly to
 retrieve non-JT-expanded devmode.

--*/
LONG
APIHOOK(DocumentPropertiesA)(
    HWND        hWnd,
    HANDLE      hPrinter,
    LPSTR       pDeviceName,
    PDEVMODEA   pDevModeOutput,
    PDEVMODEA   pDevModeInput,
    DWORD       fMode
    )
{
    DWORD fModeShim;
    LONG  lRet;

    //
    // SDK says if fMode is zero, DocumentProperties returns
    // the number of bytes required by the printer driver's
    // DEVMODE data structure. So we shouldn't set the private
    // flag when fMode is zero (because drivers may check
    // for fMode == 0). When fMode is not zero, it contains
    // DM_xxx flags, then it's safe to set the private flag.
    //
    if (fMode == 0 || pDevModeOutput == NULL)
    {
        fModeShim = fMode;
    }
    else
    {
        fModeShim = fMode | DM_NOJTEXP_SHIM;
        DPFN(eDbgLevelInfo, "DocumentPropertiesA fModeShim=%X", fModeShim);
    }

    lRet = ORIGINAL_API(DocumentPropertiesA)(
        hWnd,
        hPrinter,
        pDeviceName,
        pDevModeOutput,
        pDevModeInput,
        fModeShim
        );

    return lRet;
}

/*++

 Register hooked functions

--*/
HOOK_BEGIN

    APIHOOK_ENTRY(WINSPOOL.DRV, DocumentPropertiesA);

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\external\termservlayer.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    TermServLayer.cpp

 Abstract:

    

 Notes:

    This is a general purpose shim for Quake engine based games.

 History:

    12/12/2000 clupu  Created

--*/

#include "precomp.h"


IMPLEMENT_SHIM_BEGIN(TermServLayer)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersion)
APIHOOK_ENUM_END



/*++

 This stub function returns Windows 95 credentials.

--*/

DWORD
APIHOOK(GetVersion)(
    void
    )
{
    return ORIGINAL_API(GetVersion)();
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    return TRUE;
}

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion)

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\external\tsperuserfiles.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   
 Abstract:

   
 Notes:

   
 History:

   

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(TSPerUserFiles)
#include "ShimHookMacro.h"

#include "TSPerUserFiles_utils.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
APIHOOK_ENUM_END


CPerUserPaths* g_pPerUserPaths = NULL;


HANDLE
APIHOOK(CreateFileA)(
    LPCSTR                lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
    )
{
    LPCSTR strCorrect = lpFileName;

    if (g_pPerUserPaths) {
        strCorrect = g_pPerUserPaths->GetPerUserPathA(lpFileName);
    }
    
    return ORIGINAL_API(CreateFileA)(strCorrect,
                                     dwDesiredAccess,
                                     dwShareMode,
                                     lpSecurityAttributes,
                                     dwCreationDisposition,
                                     dwFlagsAndAttributes,
                                     hTemplateFile);
}

HANDLE
APIHOOK(CreateFileW)(
    LPCWSTR               lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
    )
{
    LPCWSTR strCorrect = lpFileName;
    
    if (g_pPerUserPaths) {
        strCorrect = g_pPerUserPaths->GetPerUserPathW(lpFileName);
    }
    
    return ORIGINAL_API(CreateFileW)(strCorrect,
                                     dwDesiredAccess,
                                     dwShareMode,
                                     lpSecurityAttributes,
                                     dwCreationDisposition,
                                     dwFlagsAndAttributes,
                                     hTemplateFile);
}


/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        
        DPF("TSPerUserFiles",
            eDbgLevelInfo,
            "[NOTIFY_FUNCTION] DLL_PROCESS_ATTACH\n");
        
        g_pPerUserPaths = new CPerUserPaths;
    
        if (g_pPerUserPaths) {
            
            if (!g_pPerUserPaths->Init()) {
                delete g_pPerUserPaths;
                g_pPerUserPaths = NULL;
            }
        }
    } else if (fdwReason == DLL_PROCESS_DETACH) {
        
        DPF("TSPerUserFiles",
            eDbgLevelInfo,
            "[NOTIFY_FUNCTION] DLL_PROCESS_DETACH\n");
    }
    
    return TRUE;
}


HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW)

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\external\tsperuserfiles_utils.cpp ===
#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(TSPerUserFiles)
#include "ShimHookMacro.h"

#include <regapi.h>
#include <stdio.h>
#include "TSPerUserFiles_utils.h"

HKEY HKLM = NULL;

//Functions - helpers.
DWORD RegKeyOpen(IN HKEY hKeyParent, IN LPCWSTR szKeyName, IN REGSAM samDesired, OUT HKEY *phKey );
DWORD RegLoadDWORD(IN HKEY hKey, IN LPCWSTR szValueName, OUT DWORD *pdwValue);
DWORD RegGetKeyInfo(IN HKEY hKey, OUT LPDWORD pcValues, OUT LPDWORD pcbMaxValueNameLen);
DWORD RegKeyEnumValues(IN HKEY hKey, IN DWORD iValue, OUT LPWSTR *pwszValueName, OUT LPBYTE *ppbData);


///////////////////////////////////////////////////////////////////////////////
//struct PER_USER_PATH
///////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Routine Description:
    Loads wszFile and wszPerUserDir values from the registry;
    Translates them to ANSI and saves results in szFile and szPerUserDir
    If no wildcards used - constructs wszPerUserFile from 
    wszPerUserDir, and wszFile and szPerUserFile from 
    szPerUserDir and szFile
Arguments:
    IN HKEY hKey - key to load values from. 
    IN DWORD dwIndex - index of value
Return Value:
    error code.
Note:
    Name of a registry value is loaded into wszFile;
    Data is loaded into wszPerUserPath
******************************************************************************/
DWORD
PER_USER_PATH::Init(
    IN HKEY hKey, 
    IN DWORD dwIndex)
{
    DWORD err = RegKeyEnumValues(hKey, dwIndex, &wszFile, 
                    (LPBYTE *)&wszPerUserDir );
    if(err != ERROR_SUCCESS)
    {
        return err;
    }
    
    cFileLen = wcslen(wszFile);
    cPerUserDirLen = wcslen(wszPerUserDir);
    //Check if there is a '*' instead of file name.
    //'*' it stands for any file name not encluding extension
    long i;
    for(i=cFileLen-1; i>=0 && wszFile[i] !=L'\\'; i--)
    {
        if(wszFile[i] == L'*')
        {
            bWildCardUsed = TRUE;
            break;
        }
    }
    
    //there must be at least one '\\' in wszFile
    //and it cannot be a first character
    if(i<=0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    InitANSI();
    
    if(!bWildCardUsed)
    {
        //now wszFile+i points to '\\' in wszFile

        //Let's construct wszPerUserFile from 
        //wszPerUserDir and wszFile
        DWORD cPerUserFile = (wcslen(wszPerUserDir)+cFileLen-i)+1;
        
        wszPerUserFile=(LPWSTR) LocalAlloc(LPTR,cPerUserFile*sizeof(WCHAR));
        if(!wszPerUserFile)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        wcscpy(wszPerUserFile,wszPerUserDir);
        wcscat(wszPerUserFile,wszFile+i);

        if(!bInitANSIFailed)
        {
            szPerUserFile=(LPSTR) LocalAlloc(LPTR,cPerUserFile);
            if(!szPerUserFile)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            strcpy(szPerUserFile,szPerUserDir);
            strcat(szPerUserFile,szFile+i);
        }

        
    }
    
    return ERROR_SUCCESS;
}

/******************************************************************************
Routine Description:
    creates szFile and szPerUserPathTemplate from 
    wszFile and wszPerUserPathTemplate strings
Arguments:
    NONE
Return Value:
    TRUE if success
******************************************************************************/
BOOL 
PER_USER_PATH::InitANSI()
{
    
    //we already tried and failed
    //don't try again
    if(bInitANSIFailed)
    {
        return FALSE;
    }
    
    if(!szFile)
    {

        //allocate memory for ANSI strings
        DWORD cFile = cFileLen+1;
        szFile = (LPSTR) LocalAlloc(LPTR,cFile);
        if(!szFile)
        {
            bInitANSIFailed = TRUE;
            return FALSE;
        }
        
        DWORD cPerUserDir = cPerUserDirLen+1;
        szPerUserDir = (LPSTR) LocalAlloc(LPTR,cPerUserDir);
        if(!szPerUserDir)
        {
            bInitANSIFailed = TRUE;
            return FALSE;
        }

        //convert UNICODE wszFile and wszPerUserPath to ANSI
        if(!WideCharToMultiByte(
                  CP_ACP,            // code page
                  0,            // performance and mapping flags
                  wszFile,    // wide-character string
                  -1,          // number of chars in string
                  szFile,     // buffer for new string
                  cFile,          // size of buffer
                  NULL,     // default for unmappable chars
                  NULL  // set when default char used
                ))
        {
            bInitANSIFailed = TRUE;
            return FALSE;
        }

        if(!WideCharToMultiByte(
                  CP_ACP,            // code page
                  0,            // performance and mapping flags
                  wszPerUserDir,    // wide-character string
                  -1,          // number of chars in string
                  szPerUserDir,     // buffer for new string
                  cPerUserDir,          // size of buffer
                  NULL,     // default for unmappable chars
                  NULL  // set when default char used
                ))
        {
            bInitANSIFailed = TRUE;
            return FALSE;
        }
    }
    
    return TRUE;
}

/******************************************************************************
Routine Description:
    returns szPerUserPath if szInFile is equal to szFile.
Arguments:
    IN LPCSTR szInFile - original path
    IN DWORD cInLen - length of szInFile in characters
Return Value:
    szPerUserPath or NULL if failes
******************************************************************************/
LPCSTR 
PER_USER_PATH::PathForFileA(
        IN LPCSTR szInFile,
        IN DWORD cInLen)
{
    if(bInitANSIFailed)
    {
        return NULL;
    }
    
    long j, i, k;

    if(bWildCardUsed)
    {
        //
        if(cInLen < cFileLen)
        {
            return NULL;
        }

        //if * is used, we need a special algorithm

        //the end of the path will more likely be different.
        //so start comparing from the end.
        for(j=cInLen-1, i=cFileLen-1; i>=0 && j>=0; i--, j--)
        {   
            if(szFile[i] == '*')
            {
                i--;
                if(i<0 || szFile[i]!='\\')
                {
                    //the string in the registry was garbage 
                    //the symbol previous to '*' must be '\\'
                    return NULL;
                }
                
                //skip all symbols in szInFile till next '\\'
                while(j>=0 && szInFile[j]!='\\') j--;
                
                //At this point both strings must me of exactly the same size.
                //If not - they are not equal
                if(j!=i)
                {
                    return NULL;
                }
                //no need to compare, 
                //we already know that current symbols are equal
                break;
            }

            if(tolower(szFile[i])!=tolower(szInFile[j]))
            {
                return NULL;
            }
        }
        
        //i and j are equal now.
        //no more * allowed
        //j we will remember as a position of '\\'
        for(k=j-1; k>=0; k--)
        {
            if(tolower(szFile[k])!=tolower(szInFile[k]))
            {
                return NULL;
            }
        }

        //Okay, the strings are equal
        //Now construct the output string
        if(szPerUserFile)
        {
            LocalFree(szPerUserFile);
            szPerUserFile=NULL;
        }
        
        DWORD cPerUserFile = cPerUserDirLen + cInLen - j + 1;
        szPerUserFile = (LPSTR) LocalAlloc(LPTR,cPerUserFile);
        if(!szPerUserFile)
        {
            return NULL;
        }
        sprintf(szPerUserFile,"%s%s",szPerUserDir,szInFile+j);
    }
    else
    {
        //first find if the input string has right size
        if(cInLen != cFileLen)
        {
            return NULL;
        }

        //the end of the path will more likely be different.
        //so start comparing from the end.
        for(i=cFileLen-1; i>=0; i--)
        {
            if(tolower(szFile[i])!=tolower(szInFile[i]))
            {
                return NULL;
            }
        }
    }

    return szPerUserFile;
}

/******************************************************************************
Routine Description:
    returns wszPerUserPath if wszInFile is equal to szFile.
Arguments:
    IN LPCSTR wszInFile - original path
    IN DWORD cInLen - length of wszInFile in characters
Return Value:
    wszPerUserPath or NULL if failes
******************************************************************************/
LPCWSTR 
PER_USER_PATH::PathForFileW(
        IN LPCWSTR wszInFile,
        IN DWORD cInLen)
{
    long j, i, k;

    if(bWildCardUsed)
    {
        //
        if(cInLen < cFileLen)
        {
            return NULL;
        }

        //if * is used, we need a special algorithm

        //the end of the path will more likely be different.
        //so start comparing from the end.
        for(j=cInLen-1, i=cFileLen-1; i>=0 && j>=0; i--, j--)
        {   
            if(wszFile[i] == '*')
            {
                i--;
                if(i<0 || wszFile[i]!='\\')
                {
                    //the string in the registry was garbage 
                    //the symbol previous to '*' must be '\\'
                    return NULL;
                }
                
                //skip all symbols in szInFile till next '\\'
                while(j>=0 && wszInFile[j]!='\\') j--;
                
                //At this point both strings must me of exactly the same size.
                //If not - they are not equal
                if(j!=i)
                {
                    return NULL;
                }
                //no need to compare, 
                //we already know that current symbols are equal
                break;
            }

            if(towlower(wszFile[i])!=towlower(wszInFile[j]))
            {
                return NULL;
            }
        }
        
        //i and j are equal now.
        //no more * allowed
        //j we will remember as a position of '\\'
        for(k=j; k>=0; k--)
        {
            if(towlower(wszFile[k])!=towlower(wszInFile[k]))
            {
                return NULL;
            }
        }

        //Okay, the strings are equal
        //Now construct the output string
        if(wszPerUserFile)
        {
            LocalFree(wszPerUserFile);
            wszPerUserFile=NULL;
        }
        
        DWORD cPerUserFile = cPerUserDirLen + cInLen - j + 1;
        wszPerUserFile = (LPWSTR) LocalAlloc(LPTR,cPerUserFile*sizeof(WCHAR));
        if(!wszPerUserFile)
        {
            return NULL;
        }
        swprintf(wszPerUserFile,L"%s%s",wszPerUserDir,wszInFile+j);
    }
    else
    {
        //first find if the input string has right size
        if(cInLen != cFileLen)
        {
            return NULL;
        }

        //the end of the path will more likely be different.
        //so start comparing from the end.
        for(i=cFileLen-1; i>=0; i--)
        {
            if(towlower(wszFile[i])!=towlower(wszInFile[i]))
            {
                return NULL;
            }
        }
    }

    return wszPerUserFile;
}

///////////////////////////////////////////////////////////////////////////////
//class CPerUserPaths
///////////////////////////////////////////////////////////////////////////////

CPerUserPaths::CPerUserPaths():
    m_pPaths(NULL), m_cPaths(0)
{
}

CPerUserPaths::~CPerUserPaths()
{
    if(m_pPaths)
    {
        delete[] m_pPaths;
    }

    if(HKLM)
    {
        NtClose(HKLM);
        HKLM = NULL;
    }
}

/******************************************************************************
Routine Description:
    Loads from the registry (HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\
        Terminal Server\\Compatibility\\PerUserFiles\\<Executable name>) information of files 
        that need to be redirected to per-user directory.
Arguments:
    NONE
Return Value:
    TRUE if success
******************************************************************************/
BOOL 
CPerUserPaths::Init()
{
    //Get the name of the current executable.    
    LPCSTR szModule = COMMAND_LINE; //command line is CHAR[] so szModule needs to be CHAR too.

    DPF("TSPerUserFiles",eDbgLevelInfo," - App Name: %s\n",szModule);
    
    //Open HKLM for later use
    if(!HKLM)
    {
        if(RegKeyOpen(NULL, L"\\Registry\\Machine", KEY_READ, &HKLM )!=ERROR_SUCCESS)
        {
            DPF("TSPerUserFiles",eDbgLevelError," - FAILED: Cannot open HKLM!\n");
            return FALSE;
        }
    }
    
    //Check if TS App Compat is on.
    if(!IsAppCompatOn())
    {
        DPF("TSPerUserFiles",eDbgLevelError," - FAILED: TS App Compat is off!\n");
        return FALSE;
    }
    
    //Get files we need to redirect.
    DWORD err;
    HKEY hKey;
    
    WCHAR szKeyNameTemplate[] = L"Software\\Microsoft\\Windows NT\\CurrentVersion"
        L"\\Terminal Server\\Compatibility\\PerUserFiles\\%S";
    LPWSTR szKeyName = (LPWSTR) LocalAlloc(LPTR,
        sizeof(szKeyNameTemplate)+strlen(szModule)*sizeof(WCHAR));

    if(!szKeyName)
    {
        DPF("TSPerUserFiles",eDbgLevelError," - FAILED: cannot allocate key name\n");
        return FALSE;
    }
    
    swprintf(szKeyName,szKeyNameTemplate,szModule);

    err = RegKeyOpen(HKLM, szKeyName, KEY_QUERY_VALUE, &hKey );
    
    LocalFree(szKeyName);

    if(err == ERROR_SUCCESS)
    {

        err = RegGetKeyInfo(hKey, &m_cPaths, NULL);

        if(err == ERROR_SUCCESS)
        {
            DPF("TSPerUserFiles",eDbgLevelInfo," - %d file(s) need to be redirected\n",m_cPaths);
            //Allocate array of PER_USER_PATH structs
            m_pPaths = new PER_USER_PATH[m_cPaths];
        
            if(!m_pPaths)
            {
                NtClose(hKey);
                return FALSE;
            }
            
            for(DWORD i=0;i<m_cPaths;i++)
            {
                err = m_pPaths[i].Init(hKey,i);
                
                if(err != ERROR_SUCCESS)
                {
                    DPF("TSPerUserFiles",eDbgLevelError," - FAILED: cannot load filenames from registry\n");
                    break;
                }

            }
        }

        NtClose(hKey);
    }

    if(err != ERROR_SUCCESS)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }

}

/******************************************************************************
Routine Description:
    redirects file path to per-user directory if necessary
Arguments:
    IN LPCSTR lpFileName
Return Value:
    full path to the per user file if redirected;
    the same as lpFileName if not.
******************************************************************************/
LPCSTR 
CPerUserPaths::GetPerUserPathA(
        IN LPCSTR lpFileName)
{
    LPCSTR szPerUserPath = NULL;
    DWORD cFileLen = strlen(lpFileName);

    for(DWORD i=0; i<m_cPaths; i++)
    {
        szPerUserPath = m_pPaths[i].PathForFileA(lpFileName, cFileLen);

        if(szPerUserPath)
        {
            DPF("TSPerUserFiles",eDbgLevelInfo," - redirecting %s\n to %s\n",
                lpFileName,szPerUserPath);
            return szPerUserPath;
        }
    }
    
    return lpFileName;
}

/******************************************************************************
Routine Description:
    redirects file path to per-user directory if necessary 
Arguments:
    IN LPCWSTR lpFileName
Return Value:
    full path to the per user file if redirected;
    the same as lpFileName if not.
******************************************************************************/
LPCWSTR 
CPerUserPaths::GetPerUserPathW(
        IN LPCWSTR lpFileName)
{
    LPCWSTR szPerUserPath = NULL;
    DWORD cFileLen = wcslen(lpFileName);

    for(DWORD i=0; i<m_cPaths; i++)
    {
        szPerUserPath = m_pPaths[i].PathForFileW(lpFileName, cFileLen);

        if(szPerUserPath)
        {
            DPF("TSPerUserFiles",eDbgLevelInfo," - redirecting %S\n to %S\n",
                lpFileName,szPerUserPath);
            return szPerUserPath;
        }
    }

    return lpFileName;
}

/******************************************************************************
Routine Description:
    Checks if TS application compatibility on
Arguments:
    NONE
Return Value:
    In case of any error - returns FALSE
******************************************************************************/
BOOL 
CPerUserPaths::IsAppCompatOn()
{
    HKEY hKey;
    DWORD dwData;
    BOOL fResult = FALSE;
    
    if( RegKeyOpen(HKLM,
                  REG_CONTROL_TSERVER, 
                  KEY_QUERY_VALUE,
                  &hKey) == ERROR_SUCCESS )
    {
    
        if(RegLoadDWORD(hKey, L"TSAppCompat", &dwData) == ERROR_SUCCESS )
        {
            DPF("TSPerUserFiles",eDbgLevelInfo," - IsAppCompatOn() - OK; Result=%d\n",dwData);
            fResult = (dwData!=0);
        }
    
        NtClose(hKey);
    }

    return fResult;
}

///////////////////////////////////////////////////////////////////////////////
//Functions - helpers.
///////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Opens Registry key
******************************************************************************/
DWORD
RegKeyOpen(
        IN HKEY hKeyParent,
        IN LPCWSTR szKeyName,
        IN REGSAM samDesired,
        OUT HKEY *phKey )
{
    NTSTATUS            Status;
    UNICODE_STRING      UnicodeString;
    OBJECT_ATTRIBUTES   OA;

    RtlInitUnicodeString(&UnicodeString, szKeyName);
    InitializeObjectAttributes(&OA, &UnicodeString, OBJ_CASE_INSENSITIVE, hKeyParent, NULL);

    Status = NtOpenKey((PHANDLE)phKey, samDesired, &OA);
    
    return RtlNtStatusToDosError( Status );
}

/******************************************************************************
Loads a REG_DWORD value from the registry
******************************************************************************/
DWORD 
RegLoadDWORD(
        IN HKEY hKey, 
        IN LPCWSTR szValueName, 
        OUT LPDWORD pdwValue)
{
    NTSTATUS                        Status;
    BYTE                            Buf[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
    PKEY_VALUE_PARTIAL_INFORMATION  pValInfo = (PKEY_VALUE_PARTIAL_INFORMATION)&Buf[0];
    DWORD                           cbData = sizeof(Buf);
    UNICODE_STRING                  ValueString;

    RtlInitUnicodeString(&ValueString, szValueName);

    Status = NtQueryValueKey(hKey,
            &ValueString,
            KeyValuePartialInformation,
            pValInfo,
            cbData,
            &cbData);

    if (NT_SUCCESS(Status)) 
    {
        *pdwValue = *((PDWORD)pValInfo->Data);
    }

    return RtlNtStatusToDosError( Status );
}

/******************************************************************************
Get key's number of values and max svalue name length
******************************************************************************/
DWORD
RegGetKeyInfo(
        IN HKEY hKey,
        OUT LPDWORD pcValues,
        OUT LPDWORD pcbMaxValueNameLen)
{
    NTSTATUS                Status;
    KEY_CACHED_INFORMATION  KeyInfo;
    DWORD                   dwRead;

    Status = NtQueryKey(
            hKey,
            KeyCachedInformation,
            &KeyInfo,
            sizeof(KeyInfo),
            &dwRead);
    
    if (NT_SUCCESS(Status))
    {
        if(pcValues)
        {
            *pcValues = KeyInfo.Values;
        }
        if(pcbMaxValueNameLen)
        {
            *pcbMaxValueNameLen = KeyInfo.MaxValueNameLen;
        }
    }

    return RtlNtStatusToDosError( Status );
}

/******************************************************************************
Enumerates values of the registry key
Returns name and data for one  value at a time
******************************************************************************/
DWORD
RegKeyEnumValues(
   IN HKEY hKey,
   IN DWORD iValue,
   OUT LPWSTR *pwszValueName,
   OUT LPBYTE *ppbData)
{
    KEY_VALUE_FULL_INFORMATION   viValue, *pviValue;
    ULONG                        dwActualLength;
    NTSTATUS                     Status = STATUS_SUCCESS;
    DWORD                        err = ERROR_SUCCESS;
    
    *pwszValueName = NULL;
    *ppbData = NULL;

    pviValue = &viValue;
    Status = NtEnumerateValueKey(
               hKey,
               iValue,
               KeyValueFullInformation,
               pviValue,
               sizeof(KEY_VALUE_FULL_INFORMATION),
               &dwActualLength);

    if (Status == STATUS_BUFFER_OVERFLOW) 
    {

        //
        // Our default buffer of KEY_VALUE_FULL_INFORMATION size didn't quite cut it
        // Forced to allocate from heap and make call again.
        //

        pviValue = (KEY_VALUE_FULL_INFORMATION *) LocalAlloc(LPTR, dwActualLength);
        if (!pviValue) {
           return GetLastError();
        }
        Status = NtEnumerateValueKey(
                    hKey,
                    iValue,
                    KeyValueFullInformation,
                    pviValue,
                    dwActualLength,
                    &dwActualLength);
    }


    if (NT_SUCCESS(Status)) 
    {
        *pwszValueName = (LPWSTR)LocalAlloc(LPTR,pviValue->NameLength+sizeof(WCHAR));
        if(*pwszValueName)
        {
            *ppbData = (LPBYTE)LocalAlloc(LPTR,pviValue->DataLength);
            if(*ppbData)
            {
                CopyMemory(*pwszValueName, pviValue->Name, pviValue->NameLength);
                (*pwszValueName)[pviValue->NameLength/sizeof(WCHAR)] = 0;
                CopyMemory(*ppbData, LPBYTE(pviValue)+pviValue->DataOffset, pviValue->DataLength);
            }
            else
            {
                err = GetLastError();
                LocalFree(*pwszValueName);
                *pwszValueName = NULL;
            }
        }
        else
        {
            err = GetLastError();
        }
    }
    
    if(pviValue != &viValue)
    {
        LocalFree(pviValue);
    }
    
    if(err != ERROR_SUCCESS)
    {
        return err;
    }
    else
    {
        return RtlNtStatusToDosError( Status );
    }
}

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\aliasdxdc.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    AliasDXDC.cpp

 Abstract:

    Win2k used to cache DCs for surfaces. Apparently this no longer happens on 
    Whistler as the handles come back different on different calls to GetDC for 
    the same surface.
    
    Our solution is to alias the handle returned from the IDirectDrawSurface::GetDC
    and fix it up in the GDI functions that depend on it.

 Notes:

    This is a general purpose shim.

 History:

    12/02/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(AliasDXDC)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()

    APIHOOK_ENUM_ENTRY(BitBlt) 
    APIHOOK_ENUM_ENTRY(CreateDIBSection) 
    APIHOOK_ENUM_ENTRY(Ellipse) 
    APIHOOK_ENUM_ENTRY(GetCurrentObject)
    APIHOOK_ENUM_ENTRY(GetDeviceCaps)
    APIHOOK_ENUM_ENTRY(GetPixel)
    APIHOOK_ENUM_ENTRY(SetPixel)
    APIHOOK_ENUM_ENTRY(GetSystemPaletteEntries)
    APIHOOK_ENUM_ENTRY(GetTextExtentPoint32A)
    APIHOOK_ENUM_ENTRY(GetTextFaceA)
    APIHOOK_ENUM_ENTRY(GetTextMetricsA)
    APIHOOK_ENUM_ENTRY(LineTo)
    APIHOOK_ENUM_ENTRY(MoveToEx)
    APIHOOK_ENUM_ENTRY(RealizePalette)
    APIHOOK_ENUM_ENTRY(Rectangle)
    APIHOOK_ENUM_ENTRY(SelectObject)
    APIHOOK_ENUM_ENTRY(SelectPalette)
    APIHOOK_ENUM_ENTRY(SetDIBColorTable)
    APIHOOK_ENUM_ENTRY(SetStretchBltMode)
    APIHOOK_ENUM_ENTRY(SetSystemPaletteUse)
    APIHOOK_ENUM_ENTRY(StretchBlt)
    APIHOOK_ENUM_ENTRY(StretchDIBits)
    APIHOOK_ENUM_ENTRY(TextOutA)

APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

#define ALIASDC (HDC) 0x42

HDC g_hDcLast = 0;

/*++

 UnAlias the DC if required.

--*/

HDC FixDC(HDC hdc)
{
    if (hdc == ALIASDC) {
        return g_hDcLast;
    } else {
        return hdc;
    }
}

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw2, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw2_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw2, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface2, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw4, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC2 lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw4_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw4, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface4, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw7, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC2 lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw7_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw7, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface7, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Get the DC
 
--*/

HRESULT
COMHOOK(IDirectDrawSurface, GetDC)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    HDC FAR *lphDC
    )
{
    HRESULT hReturn;

    _pfn_IDirectDrawSurface_GetDC pfnOld = 
        ORIGINAL_COM(IDirectDrawSurface, GetDC, (LPVOID) lpDDSurface);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            lpDDSurface, 
            lphDC)))
    {
        g_hDcLast = *lphDC;
        *lphDC = ALIASDC;
        DPFN( eDbgLevelWarning, "[Surface_GetDC] Acquired DC %08lx", g_hDcLast);
    }

    return hReturn;
}

/*++

 Get the DC
 
--*/

HRESULT
COMHOOK(IDirectDrawSurface2, GetDC)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    HDC FAR *lphDC
    )
{
    HRESULT hReturn;

    _pfn_IDirectDrawSurface2_GetDC pfnOld = 
        ORIGINAL_COM(IDirectDrawSurface2, GetDC, (LPVOID) lpDDSurface);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            lpDDSurface, 
            lphDC)))
    {
        g_hDcLast = *lphDC;
        *lphDC = ALIASDC;
        DPFN( eDbgLevelWarning, "[Surface_GetDC2] Acquired DC %08lx", g_hDcLast);
    }

    return hReturn;
}

/*++

 Get the DC
 
--*/

HRESULT
COMHOOK(IDirectDrawSurface4, GetDC)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    HDC FAR *lphDC
    )
{
    HRESULT hReturn;

    _pfn_IDirectDrawSurface4_GetDC pfnOld = 
        ORIGINAL_COM(IDirectDrawSurface4, GetDC, (LPVOID) lpDDSurface);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            lpDDSurface, 
            lphDC)))
    {
        g_hDcLast = *lphDC;
        *lphDC = ALIASDC;
        DPFN( eDbgLevelWarning, "[Surface_GetDC4] Acquired DC %08lx", g_hDcLast);
    }

    return hReturn;
}

/*++

 Get the DC
 
--*/

HRESULT
COMHOOK(IDirectDrawSurface7, GetDC)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    HDC FAR *lphDC
    )
{
    HRESULT hReturn;

    _pfn_IDirectDrawSurface7_GetDC pfnOld = 
        ORIGINAL_COM(IDirectDrawSurface7, GetDC, (LPVOID) lpDDSurface);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            lpDDSurface, 
            lphDC)))
    {
        g_hDcLast = *lphDC;
        *lphDC = ALIASDC;
        DPFN( eDbgLevelWarning, "[Surface_GetDC7] Acquired DC %08lx", g_hDcLast);
    }

    return hReturn;
}

/*++

 ReleaseDC the DC

--*/

HRESULT
COMHOOK(IDirectDrawSurface, ReleaseDC)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    HDC hDC
    )
{
    HRESULT hReturn = DDERR_GENERIC;
    
    _pfn_IDirectDrawSurface_ReleaseDC pfnOld = 
            ORIGINAL_COM(IDirectDrawSurface, ReleaseDC, (LPVOID) lpDDSurface);

    if (hDC == ALIASDC)
    {
        hDC = g_hDcLast;
        if (SUCCEEDED(hReturn = (*pfnOld)(lpDDSurface, hDC)))
        {
            DPFN( eDbgLevelWarning, "[Surface_ReleaseDC] Released DC %08lx", g_hDcLast);
            g_hDcLast = 0;
        }
    }
    else
    {
        hReturn = (*pfnOld)(lpDDSurface, hDC);
    }

    return hReturn;
}

/*++

 ReleaseDC the DC

--*/

HRESULT
COMHOOK(IDirectDrawSurface2, ReleaseDC)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    HDC hDC
    )
{
    HRESULT hReturn = DDERR_GENERIC;
    
    _pfn_IDirectDrawSurface2_ReleaseDC pfnOld = 
            ORIGINAL_COM(IDirectDrawSurface2, ReleaseDC, (LPVOID) lpDDSurface);

    if (hDC == ALIASDC)
    {
        hDC = g_hDcLast;
        if (SUCCEEDED(hReturn = (*pfnOld)(lpDDSurface, hDC)))
        {
            DPFN( eDbgLevelWarning, "[Surface_ReleaseDC2] Released DC %08lx", g_hDcLast);
            g_hDcLast = 0;
        }
    }
    else
    {
        hReturn = (*pfnOld)(lpDDSurface, hDC);
    }

    return hReturn;
}

/*++

 ReleaseDC the DC

--*/

HRESULT
COMHOOK(IDirectDrawSurface4, ReleaseDC)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    HDC hDC
    )
{
    HRESULT hReturn = DDERR_GENERIC;
    
    _pfn_IDirectDrawSurface4_ReleaseDC pfnOld = 
            ORIGINAL_COM(IDirectDrawSurface4, ReleaseDC, (LPVOID) lpDDSurface);

    if (hDC == ALIASDC)
    {
        hDC = g_hDcLast;
        if (SUCCEEDED(hReturn = (*pfnOld)(lpDDSurface, hDC)))
        {
            DPFN( eDbgLevelWarning, "[Surface_ReleaseDC4] Released DC %08lx", g_hDcLast);
            g_hDcLast = 0;
        }
    }
    else
    {
        hReturn = (*pfnOld)(lpDDSurface, hDC);
    }

    return hReturn;
}

/*++

 ReleaseDC the DC

--*/

HRESULT
COMHOOK(IDirectDrawSurface7, ReleaseDC)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    HDC hDC
    )
{
    HRESULT hReturn = DDERR_GENERIC;
    
    _pfn_IDirectDrawSurface7_ReleaseDC pfnOld = 
            ORIGINAL_COM(IDirectDrawSurface7, ReleaseDC, (LPVOID) lpDDSurface);

    if (hDC == ALIASDC)
    {
        hDC = g_hDcLast;
        if (SUCCEEDED(hReturn = (*pfnOld)(lpDDSurface, hDC)))
        {
            DPFN( eDbgLevelWarning, "[Surface_ReleaseDC7] Released DC %08lx", g_hDcLast);
            g_hDcLast = 0;
        }
    }
    else
    {
        hReturn = (*pfnOld)(lpDDSurface, hDC);
    }

    return hReturn;
}

/*++

 Unalias the DC.

--*/

BOOL
APIHOOK(BitBlt)(
    HDC hdcDest, 
    int nXDest,  
    int nYDest,  
    int nWidth,  
    int nHeight, 
    HDC hdcSrc,  
    int nXSrc,   
    int nYSrc,   
    DWORD dwRop  
    )
{
    return ORIGINAL_API(BitBlt)(FixDC(hdcDest), nXDest, nYDest, nWidth, 
        nHeight, FixDC(hdcSrc), nXSrc, nYSrc, dwRop);
}

HBITMAP 
APIHOOK(CreateDIBSection)(
    HDC hdc,          
    CONST BITMAPINFO *pbmi,
    UINT iUsage,      
    VOID *ppvBits,    
    HANDLE hSection,  
    DWORD dwOffset    
    )
{
    return ORIGINAL_API(CreateDIBSection)(FixDC(hdc), pbmi, iUsage, ppvBits, hSection,
        dwOffset);
}

BOOL
APIHOOK(Ellipse)(
    HDC hdc,        
    int nLeftRect,  
    int nTopRect,   
    int nRightRect, 
    int nBottomRect 
    )
{
    return ORIGINAL_API(Ellipse)(FixDC(hdc), nLeftRect, nTopRect, nRightRect, 
        nBottomRect);
}

HGDIOBJ 
APIHOOK(GetCurrentObject)(
    HDC hdc,
    UINT uObjectType   
    )
{
    return ORIGINAL_API(GetCurrentObject)(FixDC(hdc), uObjectType);
}

int 
APIHOOK(GetDeviceCaps)(
    HDC hdc,     
    int nIndex   
    )
{
    return ORIGINAL_API(GetDeviceCaps)(FixDC(hdc), nIndex);
}

COLORREF  
APIHOOK(GetPixel)(
    HDC hdc, 
    int XPos, 
    int nYPos
    )
{
    return ORIGINAL_API(GetPixel)(FixDC(hdc), XPos, nYPos);
}

COLORREF  
APIHOOK(SetPixel)(
    HDC hdc, 
    int XPos, 
    int nYPos,
    COLORREF crColor
    )
{
    return ORIGINAL_API(SetPixel)(FixDC(hdc), XPos, nYPos, crColor);
}

UINT 
APIHOOK(GetSystemPaletteEntries)(
    HDC hdc,              
    UINT iStartIndex,     
    UINT nEntries,        
    LPPALETTEENTRY lppe   
    )
{
    return ORIGINAL_API(GetSystemPaletteEntries)(FixDC(hdc), iStartIndex, 
        nEntries, lppe);
}

BOOL 
APIHOOK(GetTextExtentPoint32A)(
    HDC hdc,           
    LPCSTR lpString,  
    int cbString,      
    LPSIZE lpSize      
    )
{
    return ORIGINAL_API(GetTextExtentPoint32A)(FixDC(hdc), lpString, cbString, lpSize);
}

int 
APIHOOK(GetTextFaceA)(
    HDC hdc,            
    int nCount,         
    LPSTR lpFaceName   
    )
{
    return ORIGINAL_API(GetTextFaceA)(FixDC(hdc), nCount, lpFaceName);
}

BOOL      
APIHOOK(GetTextMetricsA)(
    HDC hdc, 
    LPTEXTMETRICA lptm
    )
{
    return ORIGINAL_API(GetTextMetricsA)(FixDC(hdc), lptm);
}

BOOL 
APIHOOK(LineTo)(
    HDC hdc,    
    int nXEnd,  
    int nYEnd   
    )
{
    return ORIGINAL_API(LineTo)(FixDC(hdc), nXEnd, nYEnd);
}

BOOL 
APIHOOK(MoveToEx)(
    HDC hdc,          
    int X,            
    int Y,            
    LPPOINT lpPoint   
    )
{
    return ORIGINAL_API(MoveToEx)(FixDC(hdc), X, Y, lpPoint);
}

UINT 
APIHOOK(RealizePalette)(HDC hdc)
{
    return ORIGINAL_API(RealizePalette)(FixDC(hdc));
}

BOOL 
APIHOOK(Rectangle)(
    HDC hdc,         
    int nLeftRect,   
    int nTopRect,    
    int nRightRect,  
    int nBottomRect  
    )
{
    return ORIGINAL_API(Rectangle)(FixDC(hdc), nLeftRect, nTopRect, nRightRect, 
        nBottomRect);
}
 
HGDIOBJ 
APIHOOK(SelectObject)(
    HDC hdc,          
    HGDIOBJ hgdiobj   
    )
{
    return ORIGINAL_API(SelectObject)(FixDC(hdc), hgdiobj);
}

HPALETTE 
APIHOOK(SelectPalette)(
    HDC hdc,                
    HPALETTE hpal,          
    BOOL bForceBackground   
    )
{
    return ORIGINAL_API(SelectPalette)(FixDC(hdc), hpal, bForceBackground);
}

UINT 
APIHOOK(SetDIBColorTable)(
  HDC hdc,               
  UINT uStartIndex,      
  UINT cEntries,         
  CONST RGBQUAD *pColors 
)
{
    return ORIGINAL_API(SetDIBColorTable)(FixDC(hdc), uStartIndex, cEntries, 
        pColors);
}

int 
APIHOOK(SetStretchBltMode)(
    HDC hdc,           
    int iStretchMode   
    )
{
    return ORIGINAL_API(SetStretchBltMode)(FixDC(hdc), iStretchMode);
}
 
UINT 
APIHOOK(SetSystemPaletteUse)(
    HDC hdc,      
    UINT uUsage   
    )
{
    return ORIGINAL_API(SetSystemPaletteUse)(FixDC(hdc), uUsage);
}

BOOL 
APIHOOK(StretchBlt)(
    HDC hdcDest,      
    int nXOriginDest, 
    int nYOriginDest, 
    int nWidthDest,   
    int nHeightDest,  
    HDC hdcSrc,       
    int nXOriginSrc,  
    int nYOriginSrc,  
    int nWidthSrc,    
    int nHeightSrc,   
    DWORD dwRop       
    )
{
    return ORIGINAL_API(StretchBlt)(FixDC(hdcDest), nXOriginDest, nYOriginDest, 
        nWidthDest, nHeightDest, FixDC(hdcSrc), nXOriginSrc, nYOriginSrc,
        nWidthSrc, nHeightSrc, dwRop);
}

int 
APIHOOK(StretchDIBits)(
    HDC hdc,
    int XDest,
    int YDest,
    int nDestWidth,         
    int nDestHeight,        
    int XSrc,               
    int YSrc,               
    int nSrcWidth,          
    int nSrcHeight,         
    CONST VOID *lpBits,            
    CONST BITMAPINFO *lpBitsInfo,  
    UINT iUsage,                   
    DWORD dwRop                    
    )
{
    return ORIGINAL_API(StretchDIBits)(FixDC(hdc), XDest, YDest, nDestWidth, 
        nDestHeight, XSrc, YSrc, nSrcWidth, nSrcHeight, lpBits, lpBitsInfo, 
        iUsage, dwRop);
}

BOOL 
APIHOOK(TextOutA)(
    HDC hdc,           
    int nXStart,       
    int nYStart,       
    LPCSTR lpString,  
    int cbString       
    )
{
    return ORIGINAL_API(TextOutA)(FixDC(hdc), nXStart, nYStart, lpString, cbString);
}
 
   
/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_DIRECTX_COMSERVER()
    COMHOOK_ENTRY(DirectDraw, IDirectDraw, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw2, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw4, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw7, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, GetDC, 17)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface2, GetDC, 17)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface4, GetDC, 17)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface7, GetDC, 17)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, ReleaseDC, 26)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface2, ReleaseDC, 26)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface4, ReleaseDC, 26)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface7, ReleaseDC, 26)

    APIHOOK_ENTRY(GDI32.DLL, BitBlt)
    APIHOOK_ENTRY(GDI32.DLL, CreateDIBSection)
    APIHOOK_ENTRY(GDI32.DLL, Ellipse)
    APIHOOK_ENTRY(GDI32.DLL, GetCurrentObject)
    APIHOOK_ENTRY(GDI32.DLL, GetDeviceCaps)
    APIHOOK_ENTRY(GDI32.DLL, GetPixel)
    APIHOOK_ENTRY(GDI32.DLL, SetPixel)
    APIHOOK_ENTRY(GDI32.DLL, GetSystemPaletteEntries)
    APIHOOK_ENTRY(GDI32.DLL, GetTextExtentPoint32A)
    APIHOOK_ENTRY(GDI32.DLL, GetTextFaceA)
    APIHOOK_ENTRY(GDI32.DLL, GetTextMetricsA)
    APIHOOK_ENTRY(GDI32.DLL, LineTo)
    APIHOOK_ENTRY(GDI32.DLL, MoveToEx)
    APIHOOK_ENTRY(GDI32.DLL, RealizePalette)
    APIHOOK_ENTRY(GDI32.DLL, Rectangle)
    APIHOOK_ENTRY(GDI32.DLL, SelectObject)
    APIHOOK_ENTRY(GDI32.DLL, SelectPalette)
    APIHOOK_ENTRY(GDI32.DLL, SetDIBColorTable)
    APIHOOK_ENTRY(GDI32.DLL, SetStretchBltMode)
    APIHOOK_ENTRY(GDI32.DLL, SetSystemPaletteUse)
    APIHOOK_ENTRY(GDI32.DLL, StretchBlt)
    APIHOOK_ENTRY(GDI32.DLL, StretchDIBits)
    APIHOOK_ENTRY(GDI32.DLL, TextOutA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\external\tsperuserfiles_utils.h ===
struct PER_USER_PATH
{
    LPWSTR  wszFile;
    LPWSTR  wszPerUserFile;
    LPSTR   szFile;
    LPSTR   szPerUserFile;
    DWORD   cFileLen;               // Length of the file name in symbols
    BOOL    bInitANSIFailed;        // Indicates that path name is not
                                    // translatable to ANSI
    BOOL    bWildCardUsed;          // TRUE if file name has * in it.
    LPSTR   szPerUserDir;           // Per-user directory for a file
    LPWSTR  wszPerUserDir;          // Per-user directory for a file
    DWORD   cPerUserDirLen;            

    PER_USER_PATH():
        wszFile(NULL), wszPerUserDir(NULL),
        szFile(NULL), szPerUserDir(NULL), cFileLen(0),
        bInitANSIFailed(FALSE), bWildCardUsed(FALSE),
        wszPerUserFile(NULL), szPerUserFile(NULL),
        cPerUserDirLen(0)
    {
    }
    
    ~PER_USER_PATH()
    {
        if (wszFile) {
            LocalFree(wszFile);
        }
        
        if (wszPerUserDir) {
            LocalFree(wszPerUserDir);
        }
        
        if (szFile) {
            LocalFree(szFile);
        }
        
        if (szPerUserDir) {
            LocalFree(szPerUserDir);
        }
        
        if (szPerUserFile) {
            LocalFree(szPerUserFile);
        }

        if (wszPerUserFile) {
            LocalFree(wszPerUserFile);
        }

    }

    DWORD   Init(IN HKEY hKey, IN DWORD dwIndex);
    LPCSTR  PathForFileA(IN LPCSTR szInFile, IN DWORD dwInLen);
    LPCWSTR PathForFileW(IN LPCWSTR wszInFile, IN DWORD dwInLen);
private:
    BOOL InitANSI();
};

class CPerUserPaths
{
private:
    PER_USER_PATH*  m_pPaths;
    DWORD           m_cPaths;
public:
    CPerUserPaths();
    ~CPerUserPaths();
    
    BOOL    Init();
    LPCSTR  GetPerUserPathA(IN LPCSTR lpFileName);
    LPCWSTR GetPerUserPathW(IN LPCWSTR lpFileName);
private:
    BOOL IsAppCompatOn();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\correctacmargs.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    CorrectACMArgs.cpp

 Abstract:
    
    This shim is to fix apps that pass incorrect cbSrcLength(too big) in the 
    ACMSTREAMHEADER parameter to acmStreamConvert or acmStreamPrepareHeader. 

 Notes:

    This is a general purpose shim.

 History:

    10/03/2000 maonis  Created

--*/

#include "precomp.h"
#include "msacmdrv.h"

typedef MMRESULT (*_pfn_acmStreamConvert)(HACMSTREAM has, LPACMSTREAMHEADER pash, DWORD fdwConvert);
typedef MMRESULT (*_pfn_acmStreamPrepareHeader)(HACMSTREAM has, LPACMSTREAMHEADER pash, DWORD fdwPrepare);

IMPLEMENT_SHIM_BEGIN(CorrectACMArgs)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(acmStreamConvert)
    APIHOOK_ENUM_ENTRY(acmStreamPrepareHeader)
APIHOOK_ENUM_END
 
/*++
    
 On win9x it checks to ensure that the app doesn't pass in a too big cbSrcLength 
 but this check is removed on NT. We fix this by mimicing what 9x is doing - 
 calling acmStreamSize to check if the source length is too big.

--*/

MMRESULT 
APIHOOK(acmStreamConvert)(
    HACMSTREAM has,          
    LPACMSTREAMHEADER pash,  
    DWORD fdwConvert         
    )
{
    DWORD dwOutputBytes = 0;
    MMRESULT mmr = acmStreamSize(
        has, pash->cbDstLength, &dwOutputBytes, ACM_STREAMSIZEF_DESTINATION);

    if (mmr == MMSYSERR_NOERROR) 
    {
        if(pash->cbSrcLength > dwOutputBytes)
        {
            DPFN( eDbgLevelWarning, "acmStreamConvert: cbSrcLength is too big (cbSrcLength=%u, cbDstLength=%u)\n",pash->cbSrcLength,pash->cbDstLength);
            return ACMERR_NOTPOSSIBLE;
        }
    
        ORIGINAL_API(acmStreamConvert)(
            has, pash, fdwConvert);
    } 

    return mmr;
}

/*++

 Fix bad parameters.

--*/

MMRESULT 
APIHOOK(acmStreamPrepareHeader)(
    HACMSTREAM has,          
    LPACMSTREAMHEADER pash,  
    DWORD fdwPrepare         
    )
{
    UINT l = pash->cbSrcLength;

    while (IsBadReadPtr(pash->pbSrc, l))
    {
        if (l < 256)
        {
            DPFN( eDbgLevelError, "The source buffer is invalid");
            return MMSYSERR_INVALPARAM;
        }

        l-=256;
    }

    if (pash->cbSrcLength != l)
    {
        DPFN( eDbgLevelWarning, "Adjusted header from %d to %d\n", pash->cbSrcLength, l);
    }

    pash->cbSrcLength = l;

    return ORIGINAL_API(acmStreamPrepareHeader)(
        has, pash, fdwPrepare);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(MSACM32.DLL, acmStreamConvert)
    APIHOOK_ENTRY(MSACM32.DLL, acmStreamPrepareHeader)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\correctacmstreamopen.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    CorrectACMStreamOpen.cpp

 Abstract:
    
    This shim corrects the samples per block for acmStreamOpen so that
	it will pass IMA ADPCM's parameter validation.

 Notes:

    This is a general shim.

 History:

    08/09/2002 mnikkel  Created

--*/

#include "precomp.h"
#include "msacmdrv.h"

typedef MMRESULT (*_pfn_acmStreamOpen)(LPHACMSTREAM phas, HACMDRIVER had, LPWAVEFORMATEX  pwfxSrc,    
									   LPWAVEFORMATEX pwfxDst, LPWAVEFILTER pwfltr, DWORD_PTR dwCallback, 
									   DWORD_PTR dwInstance, DWORD fdwOpen );

IMPLEMENT_SHIM_BEGIN(CorrectACMStreamOpen)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(acmStreamOpen)
APIHOOK_ENUM_END
 
/*++
    If the wSamplesPerBlock is 1017 samples change it to 505 samples
	so it will pass IMA ADPCM's parameter validation.
--*/

MMRESULT 
APIHOOK(acmStreamOpen)(
		LPHACMSTREAM    phas,       
		HACMDRIVER      had,        
		LPWAVEFORMATEX  pwfxSrc,    
		LPWAVEFORMATEX  pwfxDst,    
		LPWAVEFILTER    pwfltr,     
		DWORD_PTR       dwCallback, 
		DWORD_PTR       dwInstance, 
		DWORD           fdwOpen     
    )
{
	if ( pwfxSrc && 
		 (WAVE_FORMAT_IMA_ADPCM == pwfxSrc->wFormatTag) &&
		 (256 == pwfxSrc->nBlockAlign) &&
		 (1017 == ((LPIMAADPCMWAVEFORMAT)(pwfxSrc))->wSamplesPerBlock))
	{
		((LPIMAADPCMWAVEFORMAT)(pwfxSrc))->wSamplesPerBlock = 505;
	    DPFN( eDbgLevelError, "[acmStreamOpen] changing samples per block to 505");
	}

    return acmStreamOpen( phas, had, pwfxSrc, pwfxDst, pwfltr, dwCallback,
								  dwInstance, fdwOpen);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(MSACM32.DLL, acmStreamOpen)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\correctcreateicon.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   CorrectCreateIcon.cpp  

 Abstract:

    Clears Alpha channel of ICON's XOR-bits to make them look pretty.

 Notes:

    This is a general purpose shim. 
    
 History:

    1/23/2001 a-larrsh  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CorrectCreateIcon)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateIcon)
APIHOOK_ENUM_END

HICON APIHOOK(CreateIcon)(
  HINSTANCE hInstance,    // handle to application instance
  int nWidth,             // icon width
  int nHeight,            // icon height
  BYTE cPlanes,           // number of planes in XOR bitmask
  BYTE cBitsPixel,        // number of BPP in XOR bitmask
  CONST BYTE *lpbANDbits, // AND bitmask
  CONST BYTE *lpbXORbits  // XOR bitmask
)
{ 
   if (lpbXORbits)
   {
      if(cBitsPixel == 32)
      {
         DPFN( eDbgLevelInfo, "Zero Alpha - CreateIcon(hInstance%x, nWidth:%d, nHeight:%d, cPlanes:%d, cBitsPixel:%d, lpbANDbits:%x, lpbXORbits:%x)", hInstance, nWidth, nHeight, (int)cPlanes, (int)cBitsPixel, lpbANDbits, lpbXORbits);

         int n = (nWidth*nHeight);
         DWORD *pXORbits = (DWORD*)lpbXORbits;

         while(n--)
         {
            // Clears the alpha channel of XOR-bits only.
            *(pXORbits++) &= 0x00FFFFFF;
         }
      }
      
   }

   return ORIGINAL_API(CreateIcon)(hInstance, nWidth, nHeight, cPlanes, cBitsPixel, lpbANDbits, lpbXORbits);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, CreateIcon)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\correctactivemoviepath.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   CorrectActiveMoviePath.cpp  

 Abstract:

    A hack for Railroad Tycoon 2 video playing. Apparently they have 
    hardcoded paths for a WinExec call. Also see MSDN Article ID: Q176221

 Notes:

    This is a general purpose shim. 
    
 History:

    12/06/1999 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CorrectActiveMoviePath)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(WinExec)
APIHOOK_ENUM_END

/*++

 This stub function breaks into WinExec and checks to see if lpCmdLine 
 parameter includes AMOVIE.OCX or RUNDLL as well as /PLAY.

--*/

UINT 
APIHOOK(WinExec)(
    LPCSTR lpCmdLine, 
    UINT uCmdShow 
    )
{
    CSTRING_TRY
    {
        CString csCl(lpCmdLine);
        csCl.MakeUpper();
        
        int nAmovieIndex = csCl.Find(L"AMOVIE.OCX,RUNDLL");
        if (nAmovieIndex >= 0)
        {
            int nPlayIndex = csCl.Find(L"/PLAY");
            if (nPlayIndex >= 0)
            {
                CString csNewCl;
                DWORD dwType;
                LONG success = RegQueryValueExW(csNewCl,
                                        HKEY_LOCAL_MACHINE,
                                        L"Software\\Microsoft\\Multimedia\\DirectXMedia",
                                        L"OCX.ocx",
                                        &dwType);

                if (success == ERROR_SUCCESS && dwType == REG_SZ)
                {
                    csNewCl += L" ";
                    csNewCl += csCl.Mid(nPlayIndex);

                    return ORIGINAL_API(WinExec)(csNewCl.GetAnsi(), uCmdShow);
                }
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    return ORIGINAL_API(WinExec)(lpCmdLine, uCmdShow);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, WinExec)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\correctfareastfont.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

   CorrectFarEastFont.cpp

 Abstract:

   Some localized Far East applications create font to display localized-
   characters by supplying only font face name, and let the system pick up 
   the correct charset. This works fine on Win9x platforms. But on Whistler,
   we need to specify correct charset in order to display localized characters 
   correctly.

   We fix this in CreateFontIndirectA by correcting the charset value based on
   font face name.
     - If font face name contains DBCS characters, use the charset based on
       System Locale (DEFAULT_CHARSET)
     - If font face name is English or no face name is supplied, 
       use ANSI_CHARSET
   
 History:

    05/04/2001  rerkboos     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CorrectFarEastFont)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFontIndirectA)
APIHOOK_ENUM_END


HFONT
APIHOOK(CreateFontIndirectA)(
    CONST LOGFONTA* lplf   // characteristics
    )
{
    int j;
    BOOL bIsFEFont = FALSE;
    BYTE fNewCharSet = DEFAULT_CHARSET;
    LOGFONTA lfNew;

    if (lplf == NULL) {
        return ORIGINAL_API(CreateFontIndirectA)(lplf);
    }
    else
    {
        for (j=0; j<LF_FACESIZE; j++)
        {
            lfNew.lfFaceName[j] = lplf->lfFaceName[j];  // Copy the face name

            if ( IsDBCSLeadByte(lfNew.lfFaceName[j]) )  // Check for DBCS face name
            {
                bIsFEFont = TRUE;
            }

            if (lfNew.lfFaceName[j] == 0)
            {
                break;
            }
        }

        if (!bIsFEFont)
        {
            fNewCharSet = ANSI_CHARSET;
        }

        lfNew.lfHeight         = lplf->lfHeight;
        lfNew.lfWidth          = lplf->lfWidth;
        lfNew.lfEscapement     = lplf->lfEscapement;
        lfNew.lfOrientation    = lplf->lfOrientation;
        lfNew.lfWeight         = lplf->lfWeight;
        lfNew.lfItalic         = lplf->lfItalic;
        lfNew.lfUnderline      = lplf->lfUnderline;
        lfNew.lfStrikeOut      = lplf->lfStrikeOut;
        lfNew.lfCharSet        = fNewCharSet;
        lfNew.lfOutPrecision   = lplf->lfOutPrecision;
        lfNew.lfClipPrecision  = lplf->lfClipPrecision;
        lfNew.lfQuality        = lplf->lfQuality;
        lfNew.lfPitchAndFamily = lplf->lfPitchAndFamily;

        return ORIGINAL_API(CreateFontIndirectA)(&lfNew);
    }
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(GDI32.DLL, CreateFontIndirectA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\correctfilepathsuninstall.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   CorrectFilePathsUninstall.cpp

 Abstract:

   InstallSheild is a bad, bad app.  It places files in the SHFolder directories,
   but does not remember if it used CSIDL_COMMON_DESKTOPDIRECTORY  or CSIDL_DESKTOPDIRECTORY.
   On Win9x, this did not matter, since most machines are single user.  In NT, the machine
   is multi-user, so the links are often installed in one directory, and the uninstall attempts
   to remove them from another directory.  Also, if CorrectFilePaths.dll was applied to the
   install, the uninstallation program has no idea that the files were moved.

   This shim attempts to uninstall by looking for the file/directory in the possible locations.


 Created:

   03/23/1999 robkenny

 Modified:


--*/
#include "precomp.h"

#include "ClassCFP.h"

IMPLEMENT_SHIM_BEGIN(CorrectFilePathsUninstall)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(FindFirstFileA)
    APIHOOK_ENUM_ENTRY(GetFileAttributesA)
    APIHOOK_ENUM_ENTRY(DeleteFileA)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryA)

APIHOOK_ENUM_END
//---------------------------------------------------------------------------
/*++

    This will force all paths to the User directory

--*/
class CorrectPathChangesForceUser : public CorrectPathChangesUser
{
protected:

    virtual void    InitializePathFixes();
};

void CorrectPathChangesForceUser::InitializePathFixes()
{
    CorrectPathChangesUser::InitializePathFixes();

    AddPathChangeW( L"%AllStartMenu%",                               L"%UserStartMenu%" );
    AddPathChangeW( L"%AllDesktop%",                                 L"%UserDesktop%" );
}

/*++
    We have three different version of Correct File Paths.  Our intent,
    is to search for the file/directory that is being deleted:
        1. Original location
        2. Where CorrectFilePaths.dll would have placed the file
        3. <username>/Start Menu or <username>/Desktop
        4. All Users/Start Menu  or All Users/Desktop
--*/

CorrectPathChangesAllUser *     CorrectFilePaths            = NULL;
CorrectPathChangesUser *        CorrectToUsername           = NULL;
CorrectPathChangesForceUser *   CorrectToAll                = NULL;

//---------------------------------------------------------------------------

// Sometimes you get a FILE_NOT_FOUND error, sometimes you get PATH_NOT_FOUND
#define FileOrPathNotFound(err) (err == ERROR_PATH_NOT_FOUND || err == ERROR_FILE_NOT_FOUND)

//---------------------------------------------------------------------------
/*++

    This class will contain a list of file locations.  No duplicates are allowed

--*/
class FileLocations : public CharVector
{
public:
    ~FileLocations();

    void            Append(const char * str);
    void            Set(const char * lpFileName);
};

/*++

    Free up our private copies of the strings

--*/
FileLocations::~FileLocations()
{
    for (int i = 0; i < Size(); ++i)
    {
        char * freeMe = Get(i);
        free(freeMe);
    }
}

/*++

    Override the Append function to ensure strings are unique.

--*/
void FileLocations::Append(const char * str)
{
    for (int i = 0; i < Size(); ++i)
    {
        if (_tcsicmp(Get(i), str) == 0)
            return; // It is a duplicate
    }
    
    CharVector::Append(StringDuplicateA(str));
}


/*++

    Add all our alternative path locations to the FileLocations list

--*/
void FileLocations::Set(const char * lpFileName)
{
    Erase();

    // Add the original filename first, so we will work even if the allocation fails
    Append(lpFileName);

    // Create all the allocators if they don't exist
    if (CorrectToUsername == NULL)
    {
        CorrectToUsername = new CorrectPathChangesUser;
        CorrectFilePaths = new CorrectPathChangesAllUser;
        CorrectToAll = new CorrectPathChangesForceUser;
        if (!CorrectToUsername || !CorrectFilePaths || !CorrectToAll)
        {
            delete CorrectToUsername;
            delete CorrectFilePaths;
            delete CorrectToAll;
            return;
        }
        CorrectToAll->AddCommandLineA( COMMAND_LINE );
        CorrectFilePaths->AddCommandLineA( COMMAND_LINE );
        CorrectToUsername->AddCommandLineA( COMMAND_LINE );
    }

    char * lpCorrectPath    = CorrectFilePaths->CorrectPathAllocA(lpFileName);
    char * lpUserPath       = CorrectToUsername->CorrectPathAllocA(lpFileName);
    char * lpAllPath        = CorrectToAll->CorrectPathAllocA(lpFileName);

    Append(lpCorrectPath);
    Append(lpUserPath);
    Append(lpAllPath);

    free(lpCorrectPath);
    free(lpUserPath);
    free(lpAllPath);
}
//---------------------------------------------------------------------------


/*++
    Call FindFirstFileA
    return FALSE only if it fails because NOT_FOUND
--*/
BOOL bFindFirstFileA(
  LPCSTR lpFileName,
  LPWIN32_FIND_DATAA lpFindFileData,
  HANDLE & returnValue
)
{
    returnValue = ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);

    // If it failed because the file is not found, try again with <username> corrected name
    if (returnValue == INVALID_HANDLE_VALUE)
    {
        DWORD dwLastError = GetLastError();
        if (FileOrPathNotFound(dwLastError))
        {
            return FALSE;
        }
    }
    return TRUE;
}

/*++
    Call FindFirstFileA, if it fails because the file doesn't exist,
    correct the file path and try again.
--*/
HANDLE APIHOOK(FindFirstFileA)(
  LPCSTR lpFileName,               // file name
  LPWIN32_FIND_DATAA lpFindFileData  // data buffer
)
{
    HANDLE returnValue = INVALID_HANDLE_VALUE;

    // Create our list of alternative locations
    FileLocations fileLocations;
    fileLocations.Set(lpFileName);

    for (int i = 0; i < fileLocations.Size(); ++i)
    {
        BOOL fileFound = bFindFirstFileA(fileLocations[i], lpFindFileData, returnValue);
        if (fileFound)
        {
            // Announce the fact that we changed the path
            if (i != 0)
            {
                DPFN( eDbgLevelInfo, "FindFirstFileA corrected path\n    %s\n    %s", lpFileName, fileLocations[i]);
            }
            else
            {
                DPFN( eDbgLevelSpew, "FindFirstFileA(%s)",  fileLocations[i]);
            }
            break;
        }
    }

    // If we totally failed to find the file, call the API with
    // the original values to make sure we have the correct return values
    if (returnValue == INVALID_HANDLE_VALUE)
    {
        returnValue = ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);
    }


    return returnValue;
}

/*++
    Call GetFileAttributesA
    return FALSE only if it fails because NOT_FOUND
--*/
BOOL bGetFileAttributesA(
  LPCSTR lpFileName,
  DWORD & returnValue
)
{
    returnValue = ORIGINAL_API(GetFileAttributesA)(lpFileName);

    // If it failed because the file is not found, try again with <username> corrected name
    if (returnValue == -1)
    {
        DWORD dwLastError = GetLastError();
        if (FileOrPathNotFound(dwLastError))
        {
            return FALSE;
        }
    }
    return TRUE;
}

/*++
    Call GetFileAttributesA, if it fails because the file doesn't exist,
    correct the file path and try again.
--*/
DWORD APIHOOK(GetFileAttributesA)(
  LPCSTR lpFileName   // name of file or directory
)
{
    DWORD returnValue = 0;

    // Create our list of alternative locations
    FileLocations fileLocations;
    fileLocations.Set(lpFileName);

    for (int i = 0; i < fileLocations.Size(); ++i)
    {
        BOOL fileFound = bGetFileAttributesA(fileLocations[i], returnValue);
        if (fileFound)
        {
            // Announce the fact that we changed the path
            if (i != 0)
            {
                DPFN( eDbgLevelInfo, "GetFileAttributesA corrected path\n    %s\n    %s", lpFileName, fileLocations[i]);
            }
            else
            {
                DPFN( eDbgLevelSpew, "GetFileAttributesA(%s)",  fileLocations[i]);
            }
            break;
        }
    }

    return returnValue;
}

/*++
    Call DeleteFileA
    return FALSE only if it fails because NOT_FOUND
--*/
BOOL bDeleteFileA(
  LPCSTR lpFileName,
  BOOL & returnValue
)
{
    returnValue = ORIGINAL_API(DeleteFileA)(lpFileName);

    // If it failed because the file is not found, try again with <username> corrected name
    if (!returnValue)
    {
        DWORD dwLastError = GetLastError();
        if (FileOrPathNotFound(dwLastError))
        {
            return FALSE;
        }
    }
    return TRUE;
}

/*++
    Call DeleteFileA, if it fails because the file doesn't exist,
    correct the file path and try again.
--*/
BOOL APIHOOK(DeleteFileA)(
  LPCSTR lpFileName   // file name
)
{
    BOOL returnValue = 0;

    // Create our list of alternative locations
    FileLocations fileLocations;
    fileLocations.Set(lpFileName);

    for (int i = 0; i < fileLocations.Size(); ++i)
    {
        BOOL fileFound = bDeleteFileA(fileLocations[i], returnValue);
        if (fileFound)
        {
            // Announce the fact that we changed the path
            if (i != 0)
            {
                DPFN( eDbgLevelInfo, "DeleteFileA corrected path\n    %s\n    %s", lpFileName, fileLocations[i]);
            }
            else
            {
                DPFN( eDbgLevelSpew, "DeleteFileA(%s)",  fileLocations[i]);
            }
            break;
        }
    }

    return returnValue;
}

/*++
    Call RemoveDirectoryA
    return FALSE only if it fails because NOT_FOUND
--*/
BOOL bRemoveDirectoryA(LPCSTR lpFileName, BOOL & returnValue)
{
    returnValue = ORIGINAL_API(RemoveDirectoryA)(lpFileName);

    DWORD dwLastError = GetLastError();

    if (!returnValue)
    {
        if (FileOrPathNotFound(dwLastError))
        {
            return FALSE;
        }
    }
    // There is a bug(?) in NTFS.  A directory that has been sucessfully removed
    // will still appear in FindFirstFile/FindNextFile.  It seems that the directory
    // list update is delayed for some unknown time.
    else
    {
        // Call FindFirstFile on the directory we just deleted, until it dissappears.
        // Limit to 500 attempts, worst case delay of 1/2 sec.
        int nAttempts = 500;
        while (nAttempts > 0)
        {
            // Call the non-hooked version of FindFirstFileA, we do not want to Correct the filename.
            WIN32_FIND_DATAA ffd;
            HANDLE fff = ORIGINAL_API(FindFirstFileA)(lpFileName, & ffd);
            if (fff == INVALID_HANDLE_VALUE)
            {
                // FindFile nolonger reports the deleted directory, our job is done
                break;
            }
            else
            {
                // Spew debug info letting user know that we are waiting for directory to clear FindFirstFile info.
                if (nAttempts == 500)
                {
                    DPFN( eDbgLevelInfo, "RemoveDirectoryA waiting for FindFirstFile(%s) to clear", lpFileName);
                }
                else
                {
                    DPFN( eDbgLevelSpew, "  Dir (%s) attr(0x%08x) Attempt(%3d)", ffd.cFileName, ffd.dwFileAttributes, nAttempts);
                }
                FindClose(fff);
            }
            Sleep(1);

            nAttempts -= 1;
        }
    }

    return TRUE;
}

/*++
    Call RemoveDirectoryA, if it fails because the file doesn't exist,
    correct the file path and try again.
--*/

BOOL 
APIHOOK(RemoveDirectoryA)(
    LPCSTR lpFileName   // directory name
    )
{
    BOOL returnValue = 0;

    // Create our list of alternative locations
    FileLocations fileLocations;
    fileLocations.Set(lpFileName);

    for (int i = 0; i < fileLocations.Size(); ++i)
    {
        BOOL fileFound = bRemoveDirectoryA(fileLocations[i], returnValue);
        if (fileFound)
        {
            // Announce the fact that we changed the path
            if (i != 0)
            {
                DPFN( eDbgLevelInfo, "RemoveDirectoryA corrected path\n    %s\n    %s", lpFileName, fileLocations[i]);
            }
            else
            {
                DPFN( eDbgLevelSpew, "RemoveDirectoryA(%s)",  fileLocations[i]);
            }
            break;
        }
    }

    return returnValue;
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    return TRUE;
}

/*++

  Register hooked functions

--*/
HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesA)
    APIHOOK_ENTRY(KERNEL32.DLL, DeleteFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, RemoveDirectoryA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\correctcreatesurface.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:
    
   CorrectCreateSurface.cpp

 Abstract:

    Clean up bad ddraw CreateSurface caps.

    Command Line FIX;CHK:Flag1|Flag2|Flag3;DEL:Flag4|Flag5;ADD=Flag6|Flag7
    e.g., - FIX;CHK:DDSCAPS_TEXTURE;DEL:DDSCAPS_3DDEVICE

    FIX - Sets the flags which indicate whether to 
          fix the flags and call the interface or to 
          make a call and retry after fixing caps if the call fails.
          The default is to call the interface with 
          passed in parameters and if the call fails
          then the flags are fixed and a retry is made.

    CHK - Check for flags (condition)
    ADD - Add flags
    DEL - Delete flags

 Notes:

    This is a general purpose shim.

 History:

    02/16/2001 a-leelat  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CorrectCreateSurface)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()


DWORD g_dwFlagsChk = 0;
DWORD g_dwFlagsAdd = 0;
DWORD g_dwFlagsDel = 0;
BOOL  g_bTryAndFix = TRUE;


struct DDFLAGS
{
    WCHAR * lpszFlagName;
    DWORD   dwFlag;
};

//Hold the falg entries
//add any undefined flags to this array
static DDFLAGS g_DDFlags[] = 
{
    {L"DDSCAPS_3DDEVICE",        DDSCAPS_3DDEVICE},
    {L"DDSCAPS_ALLOCONLOAD",     DDSCAPS_ALLOCONLOAD},
    {L"DDSCAPS_ALPHA",           DDSCAPS_ALPHA},
    {L"DDSCAPS_BACKBUFFER",      DDSCAPS_BACKBUFFER},
    {L"DDSCAPS_COMPLEX",         DDSCAPS_COMPLEX},
    {L"DDSCAPS_FLIP",            DDSCAPS_FLIP},
    {L"DDSCAPS_FRONTBUFFER",     DDSCAPS_FRONTBUFFER},
    {L"DDSCAPS_HWCODEC",         DDSCAPS_HWCODEC},
    {L"DDSCAPS_LIVEVIDEO",       DDSCAPS_LIVEVIDEO},
    {L"DDSCAPS_LOCALVIDMEM",     DDSCAPS_LOCALVIDMEM},
    {L"DDSCAPS_MIPMAP",          DDSCAPS_MIPMAP},
    {L"DDSCAPS_MODEX",           DDSCAPS_MODEX},
    {L"DDSCAPS_NONLOCALVIDMEM",  DDSCAPS_NONLOCALVIDMEM},
    {L"DDSCAPS_OFFSCREENPLAIN",  DDSCAPS_OFFSCREENPLAIN},
    {L"DDSCAPS_OPTIMIZED",       DDSCAPS_OPTIMIZED},
    {L"DDSCAPS_OVERLAY",         DDSCAPS_OVERLAY},
    {L"DDSCAPS_OWNDC",           DDSCAPS_OWNDC},
    {L"DDSCAPS_PALETTE",         DDSCAPS_PALETTE},
    {L"DDSCAPS_PRIMARYSURFACE",  DDSCAPS_PRIMARYSURFACE},
    {L"DDSCAPS_STANDARDVGAMODE", DDSCAPS_STANDARDVGAMODE},
    {L"DDSCAPS_SYSTEMMEMORY",    DDSCAPS_SYSTEMMEMORY},
    {L"DDSCAPS_TEXTURE",         DDSCAPS_TEXTURE},
    {L"DDSCAPS_VIDEOMEMORY",     DDSCAPS_VIDEOMEMORY},
    {L"DDSCAPS_VIDEOPORT",       DDSCAPS_VIDEOPORT},
    {L"DDSCAPS_VISIBLE",         DDSCAPS_VISIBLE},
    {L"DDSCAPS_WRITEONLY",       DDSCAPS_WRITEONLY},
    {L"DDSCAPS_ZBUFFER",         DDSCAPS_ZBUFFER},
};

#define DDFLAGSSIZE sizeof(g_DDFlags) / sizeof(g_DDFlags[0])


DWORD GetDWord(const CString & lpFlag)
{
    for ( int i = 0; i < DDFLAGSSIZE; i++ )
    {
        if (lpFlag.CompareNoCase(g_DDFlags[i].lpszFlagName) == 0)
        {
            return g_DDFlags[i].dwFlag;
        }
    }

    return 0;
}

const WCHAR * GetName(DWORD dwDDSCAPS)
{
    for ( int i = 0; i < DDFLAGSSIZE; i++ )
    {
        if (g_DDFlags[i].dwFlag == dwDDSCAPS)
        {
            return g_DDFlags[i].lpszFlagName;
        }
    }

    return NULL;
}


VOID FixCaps(LPDDSURFACEDESC lpDDSurfaceDesc)
{
    if ( lpDDSurfaceDesc->dwFlags & DDSD_CAPS )
    {
        //To Check
        if( lpDDSurfaceDesc->ddsCaps.dwCaps & g_dwFlagsChk )
        {
            //To remove
            lpDDSurfaceDesc->ddsCaps.dwCaps &= ~g_dwFlagsDel;
            //To add
            lpDDSurfaceDesc->ddsCaps.dwCaps |= g_dwFlagsAdd;
        }
    }
}


VOID FixCaps2(LPDDSURFACEDESC2 lpDDSurfaceDesc)
{
    if ( lpDDSurfaceDesc->dwFlags & DDSD_CAPS )
    {
        //To Check
        if ( lpDDSurfaceDesc->ddsCaps.dwCaps & g_dwFlagsChk )
        {
            //To remove
            lpDDSurfaceDesc->ddsCaps.dwCaps &= ~g_dwFlagsDel;
            //To add
            lpDDSurfaceDesc->ddsCaps.dwCaps |= g_dwFlagsAdd;
        }
    }
}




HRESULT 
COMHOOK(IDirectDraw, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    
    _pfn_IDirectDraw_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw, CreateSurface, pThis);


    //Fix it anyway 
    if ( !g_bTryAndFix )
        FixCaps(lpDDSurfaceDesc);

    HRESULT hRet = (*pfnOld)(
        pThis, 
        lpDDSurfaceDesc, 
        lplpDDSurface, 
        pUnkOuter);

    if ( (hRet == DDERR_INVALIDCAPS) || (hRet == DDERR_INVALIDPIXELFORMAT)||
         (hRet == DDERR_UNSUPPORTED) || (hRet == DDERR_OUTOFVIDEOMEMORY ) || 
         (hRet == DDERR_INVALIDPARAMS) )
    {

        FixCaps(lpDDSurfaceDesc);

        hRet = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter);

    }


    return hRet;
}

/*++

 Hook create surface and fix parameters

--*/

HRESULT 
COMHOOK(IDirectDraw2, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    

    _pfn_IDirectDraw2_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw2, CreateSurface, pThis);

    //Fix it anyway
    if ( !g_bTryAndFix )
        FixCaps(lpDDSurfaceDesc);
 
    HRESULT hRet = (*pfnOld)(
        pThis, 
        lpDDSurfaceDesc, 
        lplpDDSurface, 
        pUnkOuter);


    if ( (hRet == DDERR_INVALIDCAPS) || (hRet == DDERR_INVALIDPIXELFORMAT) || 
         (hRet == DDERR_UNSUPPORTED) || (hRet == DDERR_OUTOFVIDEOMEMORY )  || 
         (hRet == DDERR_INVALIDPARAMS) )
    {

        FixCaps(lpDDSurfaceDesc);

        hRet = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter);

    }

    return hRet;
}

/*++

 Hook create surface and fix parameters

--*/

HRESULT 
COMHOOK(IDirectDraw4, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC2 lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    

    _pfn_IDirectDraw4_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw4, CreateSurface, pThis);

    //Fix it anyway
    if ( !g_bTryAndFix )
        FixCaps2(lpDDSurfaceDesc);
  

    HRESULT hRet = (*pfnOld)(
        pThis, 
        lpDDSurfaceDesc, 
        lplpDDSurface, 
        pUnkOuter);

    
    if ( (hRet == DDERR_INVALIDCAPS) || (hRet == DDERR_INVALIDPIXELFORMAT) || 
         (hRet == DDERR_UNSUPPORTED) || (hRet == DDERR_OUTOFVIDEOMEMORY )  || 
         (hRet == DDERR_INVALIDPARAMS) )
    {

        FixCaps2(lpDDSurfaceDesc);
       
        hRet = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter);

    }
    
    return hRet;
}


/*++

 Hook create surface and fix parameters

--*/

HRESULT 
COMHOOK(IDirectDraw7, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC2 lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    _pfn_IDirectDraw7_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw7, CreateSurface, pThis);

    
    if ( !g_bTryAndFix )
        FixCaps2(lpDDSurfaceDesc);
    
      
    HRESULT hRet = (*pfnOld)(
        pThis, 
        lpDDSurfaceDesc, 
        lplpDDSurface, 
        pUnkOuter);

     if ( (hRet == DDERR_INVALIDCAPS) || (hRet == DDERR_INVALIDPIXELFORMAT) || 
          (hRet == DDERR_UNSUPPORTED) || (hRet == DDERR_OUTOFVIDEOMEMORY)  || 
          (hRet == DDERR_INVALIDPARAMS ) )
    {
        FixCaps2(lpDDSurfaceDesc);
      
        hRet = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter);
    }
        
    return hRet;
}

BOOL
ParseCommandLine(const char * lpszCommandLine)
{
    CSTRING_TRY
    {
        DPFN( eDbgLevelInfo, "[ParseCommandLine] CommandLine(%s)\n", lpszCommandLine);
        
        CStringToken csCommandLine(lpszCommandLine, ";|:=");
        CString csOperator;

        while (csCommandLine.GetToken(csOperator))
        {
            if (csOperator.CompareNoCase(L"Fix") == 0)
            {
                //Go ahead and fix the caps 
                //before we make the call.
                g_bTryAndFix = FALSE;

                DPFN( eDbgLevelInfo, "[ParseCommandLine] Do not fix\n", lpszCommandLine);
            }
            else
            {
                // The next token is the caps to add
                CString csDDSCAPS;
                csCommandLine.GetToken(csDDSCAPS);
                DWORD dwDDSCAPS = GetDWord(csDDSCAPS);      // returns 0 for unknown DDSCAPS

                if (dwDDSCAPS)
                {
                    if (csOperator.CompareNoCase(L"Add") == 0)
                    {
                        DPFN( eDbgLevelInfo, "[ParseCommandLine] Add(%S)\n", GetName(dwDDSCAPS));

                        g_dwFlagsAdd |= dwDDSCAPS;
                    }
                    else if (csOperator.CompareNoCase(L"Del") == 0)
                    {
                        DPFN( eDbgLevelInfo, "[ParseCommandLine] Del(%S)\n", GetName(dwDDSCAPS));

                        g_dwFlagsDel |= dwDDSCAPS;
                    }
                    else if (csOperator.CompareNoCase(L"Chk") == 0)
                    {
                        DPFN( eDbgLevelInfo, "[ParseCommandLine] Chk(%S)\n", GetName(dwDDSCAPS));

                        g_dwFlagsChk |= dwDDSCAPS;
                    }
                }
            }
        }
    }
    CSTRING_CATCH
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    BOOL bSuccess = TRUE;

    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        // Run the command line to check for adjustments to defaults
        bSuccess = ParseCommandLine(COMMAND_LINE);
    }
      
    return bSuccess;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY_DIRECTX_COMSERVER()

    COMHOOK_ENTRY(DirectDraw, IDirectDraw,  CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw2, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw4, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw7, CreateSurface, 6)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\correctfilepathinsetdlgitemtext.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   CorrectFilePathInSetDlgItemText.cpp

 Abstract:

   This is an general purpose shim that watches the calls to SetDlgItemText
   and looks for paths.  If found it corrects the path.
   
 History:

   12/21/2000 a-brienw  Created

--*/

#include "precomp.h"
#include "ShimHook.h"

IMPLEMENT_SHIM_BEGIN(CorrectFilePathInSetDlgItemText)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetDlgItemTextA)
APIHOOK_ENUM_END

/*

  Look for incorrect system directory path being put into a dialog box
  item and replace it with the correct system directory path.

 */

BOOL
APIHOOK(SetDlgItemTextA)(
    HWND hWnd,          // handle to window
    int nIDDlgItem,     // control identifier
    LPCSTR lpString     // text to set
    )
{
    if( lpString != NULL)
    {
        CSTRING_TRY
        {
            CString csText(lpString);
            if (csText.CompareNoCase(L"c:\\windows\\system\\") == 0 )
            {
                CString csWinDir;
                csWinDir.GetSystemDirectory();
                
                csText.Replace(L"c:\\windows\\system\\", csWinDir);

                LOGN( eDbgLevelWarning,
                    "SetDlgItemTextA converted lpString from \"%s\" to \"%S\".",
                    lpString, csText.Get());

                return SetDlgItemTextA(hWnd, nIDDlgItem, csText.GetAnsi());
            }
        }
         CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return ORIGINAL_API(SetDlgItemTextA)(hWnd, nIDDlgItem, lpString);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, SetDlgItemTextA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\correctopenfileexclusive.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   CorrectOpenFileExclusive.cpp

 Abstract:

   On Win9x, opening a file for exclusive access will fail if the file is 
   already opened. WinNT will allow the exclusive open to succeed.

   This shim will force CreateFile to fail exclusive open if the file is 
   already opened.

 History:

   11/10/2000 robkenny created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CorrectOpenFileExclusive)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OpenFile ) 
APIHOOK_ENUM_END

HFILE 
APIHOOK(OpenFile)(
    LPCSTR lpFileName,        // file name
    LPOFSTRUCT lpReOpenBuff,  // file information
    UINT uStyle               // action and attributes
    )
{
    if (uStyle & OF_SHARE_EXCLUSIVE)
    {
        // We need to check to see if the file is already open.
        // We can do a fairly good job by attempting to open it
        // with read, write and execute access, which will only succeed
        // if all other handles to the object are have shared the file for RWE.
     
        DWORD CreateDisposition = OPEN_EXISTING;
        if (uStyle & OF_CREATE )
        {
            CreateDisposition = CREATE_ALWAYS;
        }

        HANDLE hFile = CreateFileA(
            lpFileName,
            GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
            0, // No sharing allowed
            NULL,
            CreateDisposition,
            0,
            NULL
            );

        if (hFile == INVALID_HANDLE_VALUE)
        {
            LOGN( eDbgLevelError, "Force CreateFile exclusive open to fail since file %s is already opened.", lpFileName);

            lpReOpenBuff->nErrCode = (WORD) GetLastError();
            return (HFILE)HandleToUlong(INVALID_HANDLE_VALUE);
        }
        else
        {
            CloseHandle(hFile);
        }
    }

    HFILE returnValue = ORIGINAL_API(OpenFile)(
        lpFileName, lpReOpenBuff, uStyle);

    return (HFILE)HandleToUlong(returnValue);
}

/*++

  Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, OpenFile)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\correctverinstallfile.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    CorrectVerInstallFile.cpp

 Abstract:

    In Windows XP, due to a modification in the caching between MoveFile and
    DeleteFile API's, when the VerInstallFileW API was called, the SHORT 
    filename gets SET instead of the long filename.

    This SHIM corrects this problem which effects the installation of a few 
    apps when the older version is still present.
   
 Notes:

    This can be a layer shim. This is a general purpose shim.

 History:

   04/05/2001 prashkud  Created
   02/28/2002 mnikkel   Added check for nulls passed in for temporary file name
                        buffer and size.  This was not checked on win9x but is
                        immediately used on XP.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CorrectVerInstallFile)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(VerInstallFileW)
    APIHOOK_ENUM_ENTRY(VerInstallFileA)
APIHOOK_ENUM_END

/*++

 GetTitle takes the app path and returns just the EXE name.

--*/

VOID
SplitTitleAndPath(CString& csAppName, CString& csAppTitle)
{    
    //
    // Go to the first '\' from the end.
    // The return value is the number of characters
    // from the beginning of the string starting at 
    // index 0.
    //
    int len = csAppName.ReverseFind(L'\\');
    if (len)
    {
        csAppTitle.Delete(0, len+1);
    }  
    int DirLen = csAppName.GetLength() - len;
    csAppName.Delete(len, DirLen);

}

DWORD
APIHOOK(VerInstallFileA)(
    DWORD uFlags,
    LPSTR szSrcFileName,
    LPSTR szDestFileName,
    LPSTR szSrcDir,
    LPSTR szDestDir,
    LPSTR szCurDir,
    LPSTR szTmpFile,
    PUINT lpuTmpFileLen
    )
{
    CHAR DummyBuffer[MAX_PATH];
    UINT DummySize = MAX_PATH;
    DWORD dwRet = 0;

   
    // check for a null szTmpFile or a null lpuTmpFileLen.
    if (szTmpFile == NULL)
    {
        szTmpFile = DummyBuffer;
        DPFN(eDbgLevelInfo, "VerInstallFileA using dummy TmpFile.");
    }

    if (lpuTmpFileLen == NULL)
    {
        lpuTmpFileLen = &DummySize;
        DPFN(eDbgLevelInfo, "VerInstallFileA using dummy TmpFileLen.");
    }

    CSTRING_TRY
    {
        CString csDestFilePath(szDestDir);  
        CString csDestFileName(szDestFileName);
        csDestFilePath.AppendPath(csDestFileName);

        //
        // Now csDestFileName possibly contains the SHORT path name
        // Convert it into long pathname
        //
        DWORD dwAttr = GetFileAttributesW(csDestFilePath.Get());
        if ((dwAttr != 0xFFFFFFFF) &&
            (dwAttr != FILE_ATTRIBUTE_DIRECTORY))
        {           
            //
            // This file exists in the current destination directory.
            // This API had problems replacing it if the filename
            // is a SHORT name. Convert it into LONG name.
            //

            if (csDestFilePath.GetLongPathNameW())
            {
                DPFN( eDbgLevelWarning, "Short Path \
                     converted to Long Path = %S",
                     csDestFilePath.Get());

                csDestFileName = csDestFilePath;                
                SplitTitleAndPath(csDestFilePath,csDestFileName);

                dwRet= ORIGINAL_API(VerInstallFileA)(uFlags,szSrcFileName,
                        (char*)csDestFileName.GetAnsi(), szSrcDir,
                        (char*)csDestFilePath.GetAnsi(), szCurDir,
                        szTmpFile,lpuTmpFileLen);

                // If using the dummy buffer then they had a null temp buffer
                // Set the buffer too small flag.
                if (szTmpFile == DummyBuffer)
                {
                    dwRet &= VIF_BUFFTOOSMALL;
                }

                return dwRet;
            }
        }

    }
    CSTRING_CATCH
    {
        DPFN(eDbgLevelError,
            "Exception raised ! Calling Original API");
    }

    dwRet = ORIGINAL_API(VerInstallFileA)(uFlags,szSrcFileName,szDestFileName,
            szSrcDir,szDestDir,szCurDir,szTmpFile,lpuTmpFileLen);

    // If using the dummy buffer then they had a null temp buffer
    // Set the buffer too small flag.
    if (szTmpFile == DummyBuffer)
    {
        dwRet &= VIF_BUFFTOOSMALL;
    }

    return dwRet;
}

/*++

 Modify the Short filename to its corresponding long filename.

--*/

DWORD
APIHOOK(VerInstallFileW)(
    DWORD uFlags,
    LPWSTR szSrcFileName,
    LPWSTR szDestFileName,
    LPWSTR szSrcDir,
    LPWSTR szDestDir,
    LPWSTR szCurDir,
    LPWSTR szTmpFile,
    PUINT lpuTmpFileLen
    )
{
    WCHAR DummyBuffer[MAX_PATH];
    UINT DummySize = MAX_PATH;
    DWORD dwRet = 0;


    // check for a null szTmpFile or a null lpuTmpFileLen.
    if (szTmpFile == NULL)
    {
        szTmpFile = DummyBuffer;
        DPFN(eDbgLevelInfo, "VerInstallFileA using dummy TmpFile.");
    }

    if (lpuTmpFileLen == NULL)
    {
        lpuTmpFileLen = &DummySize;
        DPFN(eDbgLevelInfo, "VerInstallFileA using dummy TmpFileLen.");
    }

    CSTRING_TRY
    {
        CString csDestFilePath(szDestDir);      
        csDestFilePath.AppendPath(szDestFileName);

        //
        // Now csDestFileName possibly contains the SHORT path name
        // Convert it into long pathname
        //
        DWORD dwAttr = GetFileAttributesW(csDestFilePath.Get());
        if ((dwAttr != 0xFFFFFFFF) &&
            (dwAttr != FILE_ATTRIBUTE_DIRECTORY))
        {           
            //
            // This file exists in the current destination directory.
            // This API had problems replacing it if the filename
            // is a SHORT name. Convert it into LONG name.
            //

            if (csDestFilePath.GetLongPathNameW())
            {
                DPFN( eDbgLevelWarning, "Short Path \
                     converted to Long Path = %S",
                     csDestFilePath.Get());

                CString csDestFileName(csDestFilePath);             
                SplitTitleAndPath(csDestFilePath,csDestFileName);

                dwRet = ORIGINAL_API(VerInstallFileW)(uFlags,szSrcFileName,
                        (WCHAR*)csDestFileName.Get(), szSrcDir,
                        (WCHAR*)csDestFilePath.Get(), szCurDir,
                        szTmpFile,lpuTmpFileLen);

                // If using the dummy buffer then they had a null temp buffer
                // Set the buffer too small flag.
                if (szTmpFile == DummyBuffer)
                {
                    dwRet &= VIF_BUFFTOOSMALL;
                }

                return dwRet;
            }
        }

    }
    CSTRING_CATCH
    {
        DPFN( eDbgLevelError,
            "Exception raised ! Calling Original API");
    }

    dwRet = ORIGINAL_API(VerInstallFileW)(uFlags,szSrcFileName,szDestFileName,
            szSrcDir,szDestDir,szCurDir,szTmpFile,lpuTmpFileLen);

    // If using the dummy buffer then they had a null temp buffer
    // Set the buffer too small flag.
    if (szTmpFile == DummyBuffer)
    {
        dwRet &= VIF_BUFFTOOSMALL;
    }

    return dwRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(VERSION.DLL, VerInstallFileW)
    APIHOOK_ENTRY(VERSION.DLL, VerInstallFileA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\cuasappfix.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:
    
    CUASAppHack.cpp

 Abstract:

    This shim communicates with CUAS to pass AppHack information down to 
    msctf.dll.

 Notes:

    This is a general purpose shim, but must be customized via the command 
    line.

 History:

    05/10/2002 yutakas      Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CUASAppFix)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

typedef HRESULT (*PFNCUASAPPFIX)(LPCSTR lpCommandLine);

VOID CUASAppFix(LPCSTR lpCommandLine)
{
    if (!lpCommandLine) {
        LOGN(eDbgLevelError, "CUASAppFix requires a command line");
        return;
    }

    PFNCUASAPPFIX pfn;
    HMODULE hMod = LoadLibrary(TEXT("msctf.dll"));

    if (hMod) {
        pfn = (PFNCUASAPPFIX) GetProcAddress(hMod, "TF_CUASAppFix");
        if (pfn) {
            LOGN(eDbgLevelInfo, "Running CUASAppFix with %S", lpCommandLine);
            pfn(lpCommandLine);
        }
    }
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        CUASAppFix(COMMAND_LINE);
    }
    
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\cuasdisablecicero.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    CUASDisableCicero.cpp

 Abstract:

    This shim is for apps that don't support CUAS.

 Notes:

    This is a general purpose shim.

 History:

    12/11/2001 yutakas      Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CUASDisableCicero)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

typedef BOOL (*PFNIMMDISABLETEXTFRAMESERVICE)(DWORD);

void TurnOffCicero()
{
    PFNIMMDISABLETEXTFRAMESERVICE pfn;
    HMODULE hMod = LoadLibrary(TEXT("imm32.dll"));

    if (hMod)
    {
        pfn = (PFNIMMDISABLETEXTFRAMESERVICE)GetProcAddress(hMod,
                           "ImmDisableTextFrameService");

        if (pfn)
            pfn(-1);
    }
    
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        TurnOffCicero();
    }
    
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\delaydllinit.cpp ===
/*

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    DelayDllInit.cpp

 Abstract:

    This Shim delays the DllInit of given DLLs on the command line until at
    SHIM_STATIC_DLLS_INITIALIZED

    One problem was: Autodesk 3D Studio Mask does the bad thing of creating windows
    during their Splash!DllInit. This is not allowed but works on previous OSes. It
    also works fine on regular US install. But if you enable Far East language
    support, then the IME creates a window on top of the main window and we get in a
    situation where ADVAPI32 is called before it initialized. Solution is simple: 
    delay SPLASH.

    There is a better way to do this, but we would need a callback in NTDLL right after
    it loads KERNEL32.


 History:

    06/11/2001  pierreys    Created
*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DelayDllInit)

#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

APIHOOK_ENUM_END

#pragma pack(push)
#pragma pack(1)

typedef struct _ENTRYPATCH {
    BYTE    bJmp;
    DWORD   dwRelativeAddress;
} ENTRYPATCH, *PENTRYPATCH;

#pragma pack(pop)

typedef struct _DLLPATCH {
    struct _DLLPATCH    *Next;
    HMODULE             hModule;
    DWORD               dwOldProtection;
    ENTRYPATCH          epSave;
    PENTRYPATCH         pepFix;
} DLLPATCH, *PDLLPATCH;

PDLLPATCH   pDllPatchHead=NULL;

BOOL WINAPI
PatchedDllMain(
    HINSTANCE hinstDll,
    DWORD fdwReason,
    LPVOID lpvReserved
    )
{
    if (fdwReason != DLL_PROCESS_ATTACH)
        LOGN(eDbgLevelError, "PatchDllMain invalidely called");

    return(TRUE);
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{

    PIMAGE_NT_HEADERS   pImageNTHeaders;
    DWORD               dwUnused;
    PDLLPATCH           pDllPatch;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:

            CSTRING_TRY
            {
                int             i, iDllCount;
                CString         *csArguments;

                CString         csCl(COMMAND_LINE);
                CStringParser   csParser(csCl, L";");

                iDllCount      = csParser.GetCount();
                csArguments    = csParser.ReleaseArgv();

                for (i=0; i<iDllCount; i++)
                {
                    pDllPatch=(PDLLPATCH)LocalAlloc(LMEM_FIXED, sizeof(*pDllPatch));
                    if (pDllPatch)
                    {
                        pDllPatch->hModule=GetModuleHandle(csArguments[i].Get());
                        if (pDllPatch->hModule)
                        {
                            pImageNTHeaders=RtlImageNtHeader(pDllPatch->hModule);
                            if (pImageNTHeaders)
                            {
                                pDllPatch->pepFix=(PENTRYPATCH)((DWORD)(pImageNTHeaders->OptionalHeader.AddressOfEntryPoint)+(DWORD)(pDllPatch->hModule));
                                if (pDllPatch->pepFix)
                                {
                                    if (VirtualProtect(pDllPatch->pepFix, sizeof(*(pDllPatch->pepFix)), PAGE_READWRITE, &(pDllPatch->dwOldProtection)))
                                    {
                                        memcpy(&(pDllPatch->epSave), pDllPatch->pepFix, sizeof(pDllPatch->epSave));

                                        //
                                        // Warning: this is X86 only.
                                        //
                                        pDllPatch->pepFix->bJmp=0xE9;              // 32-bit near relative jump
                                        pDllPatch->pepFix->dwRelativeAddress=(DWORD)PatchedDllMain-(DWORD)(pDllPatch->pepFix)-sizeof(*(pDllPatch->pepFix));

                                        pDllPatch->Next=pDllPatchHead;
                                        pDllPatchHead=pDllPatch;
                                    }
                                    else 
                                    {
                                        LOGN(eDbgLevelError, "Failed to make the DllMain of %S writable", csArguments[i].Get());

                                        return FALSE;
                                    }
                                }
                                else 
                                {
                                    LOGN(eDbgLevelError, "Failed to get the DllMain of %S", csArguments[i].Get());

                                    return FALSE;
                                }
                            }
                            else
                            {
                                LOGN(eDbgLevelError, "Failed to get the header of %S", csArguments[i].Get());

                                return FALSE;
                            }
                        } 
                        else 
                        {
                            LOGN(eDbgLevelError, "Failed to get the %S Dll", csArguments[i].Get());

                            return FALSE;
                        }
                    }
                    else
                    {
                        LOGN(eDbgLevelError, "Failed to allocate memory for %S", csArguments[i].Get());

                        return FALSE;
                    }
                }
            }
            CSTRING_CATCH
            {
                return FALSE;
            }
            break;

        case SHIM_STATIC_DLLS_INITIALIZED:

            if (pDllPatchHead)
            {
                PDLLPATCH   pNextDllPatch;

                for (pDllPatch=pDllPatchHead; pDllPatch; pDllPatch=pNextDllPatch)
                {
                    memcpy(pDllPatch->pepFix, &(pDllPatch->epSave), sizeof(*(pDllPatch->pepFix)));

                    if (!VirtualProtect(pDllPatch->pepFix, sizeof(*(pDllPatch->pepFix)), pDllPatch->dwOldProtection, &dwUnused))
                    {
                        LOGN(eDbgLevelWarning, "Failed to reprotect Dll at %08X", pDllPatch->hModule);
                    }

                    if (!((PDLL_INIT_ROUTINE)(pDllPatch->pepFix))(pDllPatch->hModule, DLL_PROCESS_ATTACH, (PCONTEXT)1))
                    {
                        LOGN(eDbgLevelError, "Failed to initialize Dll at %08X", pDllPatch->hModule);

                        return(FALSE);
                    }

                    pNextDllPatch=pDllPatch->Next;

                    if (!LocalFree(pDllPatch))
                    {
                        LOGN(eDbgLevelWarning, "Failed to free memory Dll at %08X", pDllPatch->hModule);
                    }
                }
            }
            else
            {
                LOGN(eDbgLevelError, "Failed to get Dll list");

                return FALSE;
            }
            break;

    }

    return TRUE;
}



HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\deletespecifiedfiles.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    DeleteSpecifiedFiles.cpp

 Abstract:

    This SHIM renames the MFC42loc.dll that is installed by the APP in the 
    %windir%\system32 directory and sets up the temporary file for destruction.
    
 Notes:

    This app. places the MFC42loc.dll into the %windir%\system32 directory even on a English language
    locale thereby forcing some APPS to use it and thereby some 'Dialogs' and 'Message boxes' are messed up.
    
 History:

    08/21/2000 prashkud Created

--*/

#include "precomp.h"
#include "CharVector.h"
#include <new>  // for inplace new

IMPLEMENT_SHIM_BEGIN(DeleteSpecifiedFiles)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

class FILENAME_PATH
{
public:
    CString FileName;
    CString FileVersion;
    BOOL bPresent;

    FILENAME_PATH()
    {
        bPresent = FALSE;
    }
};

class FileNamePathList : public VectorT<FILENAME_PATH>
{
};

VectorT<FILENAME_PATH>  *g_StFileNamePath = NULL;


/*++

  This function checks the 'FileVersion' of the first variable 'szFileName' 
  matches that of the 2nd parameter 'szFileVersion' and if it matches returns 
  TRUE else returns FALSE.

--*/

BOOL 
FileCheckVersion(
   const CString & csFileName,
   const CString & csFileVersion
   )
{
    DWORD dwDummy;
    PVOID pVersionInfo;
    UINT cbTranslate, i;
    WCHAR SubBlock[100];
    LPWSTR lpBuffer;
    DWORD dwBytes;
    WORD wLangID;
    struct LANGANDCODEPAGE  
    { 
        WORD wLanguage;                                              
        WORD wCodePage;                                              
    } *lpTranslate;
    DWORD dwVersionInfoSize;

    //
    // There is no File Version specified. So, no point in going ahead. Return TRUE.
    //
    if (csFileVersion.IsEmpty())
    {
        return TRUE;  
    }

    dwVersionInfoSize = GetFileVersionInfoSizeW((LPWSTR)csFileName.Get(), &dwDummy);
          
    if (dwVersionInfoSize > 0)
    {
        pVersionInfo = malloc(dwVersionInfoSize);
        if (pVersionInfo) 
        {
            if (0 != GetFileVersionInfoW(
                    (LPWSTR)csFileName.Get(),
                    0,
                    dwVersionInfoSize,
                    pVersionInfo
                    )) 
            {
               // Now, pVersionInfo contains the required version block. 
               // Use it with VerQueryValue to get the
               // the language info that is needed             
               // Get System locale before and note down the language for the system                                                  
               // Read the list of languages and code pages.
              
                if (VerQueryValueW(
                        pVersionInfo, 
                        L"\\VarFileInfo\\Translation",
                        (LPVOID*)&lpTranslate,
                        &cbTranslate
                        ))
                {
                    //
                    // Read the language string each language and code page.
                    //

                    for (i=0; i < (cbTranslate/sizeof(struct LANGANDCODEPAGE)); i++)
                    {                                               
                        wsprintf( 
                            SubBlock, 
                            L"\\StringFileInfo\\%04x%04x\\FileVersion",
                            lpTranslate[i].wLanguage,
                            lpTranslate[i].wCodePage 
                            ); 

                        //
                        // Retrieve FileVersion for language and code page "i" from the pVersionInfo.
                        //
                        if (VerQueryValueW(
                                pVersionInfo, 
                                SubBlock, 
                                (LPVOID*)&lpBuffer, 
                                (UINT*)&dwBytes))
                        {
                            if (!(csFileVersion.Compare(lpBuffer)))
                            {
                                DPFN(
                                    eDbgLevelInfo,
                                    "Version string for current file is %S,%S",
                                    lpBuffer, csFileVersion.Get());

                                free(pVersionInfo);
                                return TRUE;
                            }  
                        }
                    } // for loop 
                } 

            }
            free(pVersionInfo); 
        }
    }

    return FALSE;
}

/*++

 This function as the name suggests deletes the file or if it is in use moves 
 it to the 'Temp' folder.

--*/

VOID 
DeleteFiles()
{
    for (int i = 0; i < g_StFileNamePath->Size(); ++i)
    {
        const FILENAME_PATH & fnp = g_StFileNamePath->Get(i);
        
        DPFN( eDbgLevelSpew, "DeleteFiles file(%S) version(%S)", fnp.FileName.Get(), fnp.FileVersion.Get());

        if (!fnp.bPresent)
        {
            //
            // CheckFileVersion
            //
            if (FileCheckVersion(fnp.FileName, fnp.FileVersion))
            { 
                LOGN(eDbgLevelError,"Deleting file %S.", fnp.FileName.Get());

                // Delete the file..
                if (!DeleteFileW(fnp.FileName))
                {
                    CString csTempDir;
                    CString csTempPath;
                    
                    LOGN(eDbgLevelError,"Moving file %S.", fnp.FileName.Get());
                    //
                    // Could not delete.Retry by renaming it and then deleting it.              
                    // New file is %windir%\Temp
                    //
                    csTempDir.GetTempPathW();
                    csTempPath.GetTempFileNameW(csTempDir, L"XXXX", 0);

                    if (MoveFileExW( fnp.FileName, csTempPath, MOVEFILE_REPLACE_EXISTING ))
                    {
                        SetFileAttributesW(
                            csTempPath, 
                            FILE_ATTRIBUTE_ARCHIVE |
                            FILE_ATTRIBUTE_TEMPORARY);

                        DeleteFileW(csTempPath);
                    }
                }
            }
        }
    }
}

/*++

 This function checks for the existence of the file specified on the commandline .
 This is called during the DLL_PROCESS_ATTACH notification
    
--*/

BOOL 
CheckFileExistence()
{
    // If any among the list is not present, mark it as 'Not Present' and only those marked as 
    // 'Not present' will be deleted.

    BOOL bFileDoesNotExist = FALSE;
    WIN32_FIND_DATAW StWin32FileData;

    for (int i = 0; i < g_StFileNamePath->Size(); ++i)
    {
        FILENAME_PATH & fnp = g_StFileNamePath->Get(i);

        DPFN( eDbgLevelSpew, "CheckFileExistence file(%S) version(%S)", fnp.FileName.Get(), fnp.FileVersion.Get());

        HANDLE hTempFile = FindFirstFileW(fnp.FileName, &StWin32FileData);
        if (INVALID_HANDLE_VALUE != hTempFile)
        {
            FindClose(hTempFile);            

            //
            // File is present. Check its version if given.
            //            
            if (FileCheckVersion(fnp.FileName, fnp.FileVersion))
            {
                fnp.bPresent = TRUE;
            }
            else
            {
                bFileDoesNotExist = TRUE;
                fnp.bPresent = FALSE;
            }
        } 
        else
        {
           bFileDoesNotExist = TRUE;
           fnp.bPresent = FALSE;
        } 
    } 

   return bFileDoesNotExist;  
}
   
/*++

    The command line can contain FileName:Path:VersionString,FileName1:Path1:VersionString1 etc....
    Eg. Ole2.dll:system:604.5768.94567,MFC42.dll:0:,Foo.dll:d:\program Files\DisneyInteractive etc..
    'system' implies the %windir%. '0' implies that the filename itself is a fully qualified path
    OR one has the option of giving the path seperately OR it can be left blank.

--*/

BOOL
ParseCommandLine(LPCSTR lpszCommandLine)
{
    CSTRING_TRY
    {
        g_StFileNamePath = new VectorT<FILENAME_PATH>;
        if (!g_StFileNamePath)
        {
            return FALSE;
        }
        
        CStringToken csCommandLine(COMMAND_LINE, ":,;");
        CString csTok;
        DWORD dwState = 0;


        while (csCommandLine.GetToken(csTok))
        {
            FILENAME_PATH fnp;
            
            switch(dwState)
            {
                case 0:
                    dwState++;
                    fnp.FileName = csTok;
                    break;

                case 1:
                    if (csTok.CompareNoCase(L"system") == 0)
                    {
                        fnp.FileName.GetSystemDirectoryW();
                        fnp.FileName.AppendPath(fnp.FileName);
                    }
                    else
                    {
                        fnp.FileName = csTok;
                    }
                    dwState++;
                    break;

                case 2:
                    dwState = 0;
                    fnp.FileVersion = csTok;

                    DPFN( eDbgLevelInfo, "ParseCommandLine file(%S) version(%S)", fnp.FileName.Get(), fnp.FileVersion.Get());

                    // Found all three states, add it to the list
                    if (!g_StFileNamePath->AppendConstruct(fnp))
                    {
                        // Append failed, stop parsing
                        return FALSE;
                    }
                   
                   break;
             }  
        }
    }
    CSTRING_CATCH
    {
        return FALSE;
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    static BOOL fDidNotExist = FALSE;

    switch (fdwReason)
    {
        case SHIM_STATIC_DLLS_INITIALIZED:
        {
            if (ParseCommandLine(COMMAND_LINE))
            {
                //
                // Ok...CommandLine is in place...Now Check for those Files...
                // If any one file exists, then we are not responsible. We bail out..
                //
                fDidNotExist = CheckFileExistence();
            }
            break;
        }

        case DLL_PROCESS_DETACH:
        {
            //
            // Check for the specified file at the specified location. If it existed prior to
            // to this in PROCESS_DLL_ATTACH, it is not installed us...Just bail out !
            // If the file did not exist before, it is our problem and we should remove them.
            //
            if (fDidNotExist)
            {
                DeleteFiles();
            }  
            break;
       }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\delaywinmmcallback.cpp ===
/*+

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   DelayWinMMCallback.cpp

 Abstract:

   This Shim does not allow the application to be called from inside the WINMM callback routine.
   Very few API's are supported inside the callback.  The callback routine's data is stored away,
   and passed to the application inside the WM_TIMER callback.

 History:

   05/11/2000 robkenny

--*/


#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(DelayWinMMCallback)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_ENTRY(waveOutOpen) 
APIHOOK_ENUM_ENTRY(waveOutClose) 
APIHOOK_ENUM_ENTRY(SetTimer) 
APIHOOK_ENUM_END


//---------------------------------------------------------------------------------------
// Which device is currently inside the callback routine
// NULL means nobody is inside the routine.
static HWAVEOUT            g_InsideCallback = NULL;

typedef void CALLBACK WAVE_OUT_CALLBACK(
  HWAVEOUT hwo,
  UINT uMsg,
  DWORD dwInstance,
  DWORD dwParam1,
  DWORD dwParam2
);

//---------------------------------------------------------------------------------------

/*+
  Just a convenient way of storing the WINMM callback data

--*/

class WinMMCallbackData
{
public:
    UINT            m_uMsg;
    DWORD           m_dwInstance;
    DWORD           m_dwParam1;
    DWORD           m_dwParam2;

    WinMMCallbackData(
            UINT        uMsg,
            DWORD       dwInstance,
            DWORD       dwParam1,
            DWORD       dwParam2
            )
    {
        m_uMsg          = uMsg;
        m_dwInstance    = dwInstance;
        m_dwParam1      = dwParam1;
        m_dwParam2      = dwParam2;
    }

};

/*

  Information particular to a single Wave Out device.

--*/
class WaveOutInfo
{
public:
    HWAVEOUT                    m_DeviceId;
    WAVE_OUT_CALLBACK *         m_OrigCallback;
    VectorT<WinMMCallbackData>  m_CallbackData;

    inline WaveOutInfo();
    inline bool operator == (const HWAVEOUT & deviceId) const;
    inline bool operator == (const WaveOutInfo & woi) const;

    void                    AddCallbackData(const WinMMCallbackData & callbackData);
    void                    CallCallbackRoutines();
    void                    ClearCallbackData();
};

inline WaveOutInfo::WaveOutInfo()
{
    m_DeviceId      = NULL;
    m_OrigCallback  = NULL;
}

/*+

  Does this WaveOutInfo class have the same device id?

--*/
inline bool WaveOutInfo::operator == (const HWAVEOUT & deviceId) const
{
    return deviceId == m_DeviceId;
}

/*+

  Are these two WaveOutInfo classes the same?

--*/
inline bool WaveOutInfo::operator == (const WaveOutInfo & woi) const
{
    return woi.m_DeviceId == m_DeviceId;
}

/*+

  Add this callback data

--*/
void WaveOutInfo::AddCallbackData(const WinMMCallbackData & callbackData)
{
    DPFN( eDbgLevelInfo, "AddCallbackData(0x%08x) uMsg(0x%08x).", m_DeviceId, callbackData.m_uMsg);
    m_CallbackData.Append(callbackData);
}

/*+

  Call the app with all the postponed WINMM callback data.

--*/
void WaveOutInfo::CallCallbackRoutines()
{
    int nEntries = m_CallbackData.Size();

    for (int i = 0; i < nEntries; ++i)
    {
        WinMMCallbackData & callbackData = m_CallbackData.Get(i);

        if (m_OrigCallback)
        {
            DPFN(
                eDbgLevelInfo,
                "CallCallbackRoutines m_uMsg(0x08x) m_dwInstance(0x08x) m_dwParam1(0x08x) m_dwParam2(0x08x).",
                callbackData.m_uMsg,
                callbackData.m_dwInstance,
                callbackData.m_dwParam1,
                callbackData.m_dwParam2);

            (*m_OrigCallback)(
                m_DeviceId, 
                callbackData.m_uMsg, 
                callbackData.m_dwInstance, 
                callbackData.m_dwParam1, 
                callbackData.m_dwParam2);
        }
    }

    ClearCallbackData();
}

void WaveOutInfo::ClearCallbackData()
{
    m_CallbackData.Reset();
}

//---------------------------------------------------------------------------------------
/*+

  A vector of WaveOutInfo objects.
  Access to this list must be inside a critical section.

--*/
class WaveOutList : public VectorT<WaveOutInfo>
{
private:
    // Prevent copy
    WaveOutList(const WaveOutList & );
    WaveOutList & operator = (const WaveOutList & );

private:
    static WaveOutList *    TheWaveOutList;
    CRITICAL_SECTION        TheWaveOutListLock;

    inline                  WaveOutList();
    inline                  ~WaveOutList();

    static WaveOutList *    GetLocked();
    inline void             Lock();
    inline void             Unlock();

    void                    Dump();
    int                     FindWave(const HWAVEOUT & hwo) const;
    void                    ClearCallbackData();

public:

    // All access to this class is through these static interfaces.
    // The app has no direct access to the list, therefore cannot accidentally
    // leave the list locked or unlocked.
    // All operations are Atomic.
    static void                 Add(const WaveOutInfo & woi);
    static void                 RemoveWaveOut(const HWAVEOUT & hwo);

    static void                 AddCallbackData(const HWAVEOUT & hwo, const WinMMCallbackData & callbackData);
    static void                 CallCallbackRoutines();

};

/*+

  A static pointer to the one-and-only wave out list.

--*/
WaveOutList * WaveOutList::TheWaveOutList = NULL;

/*+

  Init the class

--*/
inline WaveOutList::WaveOutList()
{
    InitializeCriticalSection(&TheWaveOutListLock);
}

/*+

  Clean up, releasing all resources.

--*/
inline WaveOutList::~WaveOutList()
{
    DeleteCriticalSection(&TheWaveOutListLock);
}

/*+

  Enter the critical section

--*/
inline void WaveOutList::Lock()
{
    EnterCriticalSection(&TheWaveOutListLock);
}

/*+

  Unlock the list

--*/
inline void WaveOutList::Unlock()
{
    LeaveCriticalSection(&TheWaveOutListLock);
}

/*+

  Return a locked pointer to the list

--*/
WaveOutList * WaveOutList::GetLocked()
{
    if (!TheWaveOutList)
    {
        TheWaveOutList = new WaveOutList;
    }
    if (TheWaveOutList)
        TheWaveOutList->Lock();
    
    return TheWaveOutList;
}

/*+

  Search for the member in the list, return index or -1

--*/
int WaveOutList::FindWave(const HWAVEOUT & findMe) const
{
    for (int i = 0; i < Size(); ++i)
    {
        const WaveOutInfo & hwo = Get(i);
        if (Get(i) == findMe)
            return i;
    }
    return -1;
}

/*+

  Dump the list, caller is responsible for locking

--*/
void WaveOutList::Dump()
{
#if DBG
    for (int i = 0; i < Size(); ++i)
    {
        DPFN( 
            eDbgLevelInfo, 
            "TheWaveOutListLock[i] = HWO(%04d) CALLBACK(0x%08x).", 
            i, 
            Get(i).m_DeviceId, 
            Get(i).m_OrigCallback);
    }
#endif
}

/*+

  Add this wave out device to the global list.

--*/
void WaveOutList::Add(const WaveOutInfo & woi)
{
    WaveOutList * waveOutList = WaveOutList::GetLocked();
    if (!waveOutList)
        return;

    int index = waveOutList->Find(woi);
    if (index == -1)
        waveOutList->Append(woi);

    #if DBG
        waveOutList->Dump();
    #endif

    // unlock the list
    waveOutList->Unlock();
}

/*+

  Remove the wavout entry with the specified wave out handle from the global list

--*/
void WaveOutList::RemoveWaveOut(const HWAVEOUT & hwo)
{
    // Get a pointer to the locked list
    WaveOutList * waveOutList = WaveOutList::GetLocked();
    if (!waveOutList)
        return;

    // Look for our device and mark it for a reset.
    int woiIndex = waveOutList->FindWave(hwo);
    if (woiIndex >= 0)
    {
        waveOutList->Remove(woiIndex);

        #if DBG
            waveOutList->Dump();
        #endif
    }

    // unlock the list
    waveOutList->Unlock();
}

/*+

  Save this callback data for later.

--*/
void WaveOutList::AddCallbackData(const HWAVEOUT & hwo, const WinMMCallbackData & callbackData)
{
    // Get a pointer to the locked list
    WaveOutList * waveOutList = WaveOutList::GetLocked();
    if (!waveOutList)
        return;

    // Look for our device and if it has a callback
    int woiIndex = waveOutList->FindWave(hwo);
    if (woiIndex >= 0)
    {
        WaveOutInfo & woi = waveOutList->Get(woiIndex);
        woi.AddCallbackData(callbackData);
    }

    // unlock the list
    waveOutList->Unlock();
}

/*+

  Clear the callback data for all our waveout devices.

--*/
void WaveOutList::ClearCallbackData()
{
    int nEntries = Size();
    for (int i = 0; i < nEntries; ++i)
    {
        WaveOutInfo & woi = Get(i);
        woi.ClearCallbackData();
    }
}

/*+

  Get the callback value for this wave out device.

--*/
void WaveOutList::CallCallbackRoutines()
{
    // Get a pointer to the locked list
    WaveOutList * waveOutList = WaveOutList::GetLocked();
    if (!waveOutList)
        return;

    // Quick exit if the list is empty.
    if (waveOutList->Size() == 0)
    {
        waveOutList->Unlock();
        return;
    }

    // We make a duplicate of the list because we cannot call back to the application while
    // the list is locked.  If it is locked, the first WINMM callback will block attempting
    // to add data to the locked list.
    VectorT<WaveOutInfo> waveOutCallbackCopy = *waveOutList;

    // Remove the callback data from the original list
    waveOutList->ClearCallbackData();

    // unlock the list
    waveOutList->Unlock();

    DPFN(
        eDbgLevelInfo, 
        "CallCallbackRoutines Start %d entries.", 
        waveOutCallbackCopy.Size());

    int nEntries = waveOutCallbackCopy.Size();
    for (int i = 0; i < nEntries; ++i)
    {
        WaveOutInfo & woi = waveOutCallbackCopy.Get(i);
        woi.CallCallbackRoutines();
    }
}

//---------------------------------------------------------------------------------------

/*+

  Our version of the WaveCallback routine, all this routine does is to store away
  the callback data, for later use..

--*/
void CALLBACK WaveOutCallback(
  HWAVEOUT hwo,
  UINT uMsg,
  DWORD dwInstance,
  DWORD dwParam1,
  DWORD dwParam2
)
{
    WaveOutList::AddCallbackData(hwo, WinMMCallbackData(uMsg, dwInstance, dwParam1, dwParam2));
}

/*+

  Call waveOutOpen, saving dwCallback if it is a function.

--*/
MMRESULT 
APIHOOK(waveOutOpen)(
    LPHWAVEOUT phwo,
    UINT uDeviceID,
    LPWAVEFORMATEX pwfx,
    DWORD dwCallback,
    DWORD dwCallbackInstance,
    DWORD fdwOpen
    )
{
    WAVE_OUT_CALLBACK * myCallback = &WaveOutCallback;

    MMRESULT returnValue = ORIGINAL_API(waveOutOpen)(
        phwo, 
        uDeviceID, 
        pwfx, 
        (DWORD)myCallback, 
        dwCallbackInstance, 
        fdwOpen);

    if (returnValue == MMSYSERR_NOERROR && (fdwOpen & CALLBACK_FUNCTION))
    {
        WaveOutInfo woi;
        woi.m_DeviceId = *phwo;
        woi.m_OrigCallback = (WAVE_OUT_CALLBACK *)dwCallback;

        WaveOutList::Add(woi);

        LOGN( eDbgLevelError, "waveOutOpen(%d,...) has callback. Added to list.", *phwo);
    }

    return returnValue;
}

/*+

  Call waveOutClose and forget the callback for the device.

--*/
MMRESULT 
APIHOOK(waveOutClose)(
    HWAVEOUT hwo
    )
{
    LOGN( eDbgLevelError, "waveOutClose(%d) called. Remove callback from list.", hwo);

    WaveOutList::RemoveWaveOut(hwo);

    MMRESULT returnValue = ORIGINAL_API(waveOutClose)(hwo);
    return returnValue;
}

//--------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------
/*+

  Up to this point, this module is generic; that is going to change.
  The app necessating this fix uses the WM_TIMER message to pump the
  sound system, unfortunately the timer can occur while the game is
  inside the WINMM callback routine, causing a deadlock occurs when this timer
  callback calls a WINMM routine.

--*/
static TIMERPROC g_OrigTimerCallback = NULL;

VOID CALLBACK TimerCallback(
  HWND hwnd,         // handle to window
  UINT uMsg,         // WM_TIMER message
  UINT_PTR idEvent,  // timer identifier
  DWORD dwTime       // current system time
)
{
    if (g_OrigTimerCallback)
    {
        // Pass all the delayed WINMM timer callback data
        WaveOutList::CallCallbackRoutines();

        // Now call the original callback routine.
        (*g_OrigTimerCallback)(hwnd, uMsg, idEvent, dwTime);
    }
}

/*+

  Substitute our timer routine for theirs.

--*/
UINT_PTR 
APIHOOK(SetTimer)(
    HWND hWnd,              // handle to window
    UINT_PTR nIDEvent,      // timer identifier
    UINT uElapse,           // time-out value
    TIMERPROC lpTimerFunc   // timer procedure
    )
{
    g_OrigTimerCallback = lpTimerFunc;

    LOGN( eDbgLevelError, "SetTimer called. Substitute our timer routine for theirs.");

    UINT_PTR returnValue = ORIGINAL_API(SetTimer)(hWnd, nIDEvent, uElapse, TimerCallback);
    return returnValue;
}

/*+

  Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(WINMM.DLL, waveOutOpen)
    APIHOOK_ENTRY(WINMM.DLL, waveOutClose)
    APIHOOK_ENTRY(USER32.DLL, SetTimer)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\delayshowgroup.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   DelayShowGroup.cpp

 Abstract:

   When the ShowGroup command is sent to Program Manager (DDE),
   wait for the window to actually appear before returning.

 History:

    10/05/2000  robkenny Created

--*/

#include "precomp.h"
#include <ParseDDE.h>

IMPLEMENT_SHIM_BEGIN(DelayShowGroup)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_ENTRY(DdeClientTransaction) 
APIHOOK_ENUM_END

static DWORD dwMaxWaitTime = 5000; // 5 seconds

// A list of DDE commands that we are interested in.
const char * c_sDDECommands[] =
{
    "ShowGroup",
    NULL,
} ;


// Return FALSE if this window contains the pathname in lParam
BOOL 
CALLBACK WindowEnumCB(
    HWND hwnd,      // handle to parent window
    LPARAM lParam   // application-defined value
    )
{
    const char * szGroupName = (const char *)lParam;

    char lpWindowTitle[MAX_PATH];

    if (GetWindowTextA(hwnd, lpWindowTitle, MAX_PATH) > 0)
    {
        //DPF(eDbgLevelSpew, "Window(%s)\n", lpWindowTitle);

        if (_tcsicmp(lpWindowTitle, szGroupName) == 0)
            return FALSE;
    }

    return TRUE; // keep enumming
}

// Determine if a window with the szGroupName exists on the sytem
BOOL 
CheckForWindow(const char * szGroupName)
{
    DWORD success = EnumDesktopWindows(NULL, WindowEnumCB, (LPARAM)szGroupName);

    BOOL retval = success == 0 && GetLastError() == 0;

    return retval;
}

// Check to see if this is a ShowGroup command,
// if it is do not return until the window actually exists
void 
DelayIfShowGroup(LPBYTE pData)
{
    if (pData)
    {
        // Now we need to parse the string, looking for a DeleteGroup command
        // Format "ShowGroup(GroupName,ShowCommand[,CommonGroupFlag])"
        // CommonGroupFlag is optional

        char * pszBuf = StringDuplicateA((const char *)pData);
        if (!pszBuf)
            return;

        UINT * lpwCmd = GetDDECommands(pszBuf, c_sDDECommands, FALSE);
        if (lpwCmd)
        {
            // Store off lpwCmd so we can free the correct addr later
            UINT *lpwCmdTemp = lpwCmd;

            // Execute a command.
            while (*lpwCmd != (UINT)-1)
            {
                UINT wCmd = *lpwCmd++;
                // Subtract 1 to account for the terminating NULL
                if (wCmd < ARRAYSIZE(c_sDDECommands)-1)
                {

                    // We found a command--it must be DeleteGroup--since there is only 1

                    BOOL iCommonGroup = -1;

                    // From DDE_ShowGroup
                    if (*lpwCmd < 2 || *lpwCmd > 3)
                    {
                        goto Leave;
                    }

                    if (*lpwCmd == 3) {

                        //
                        // Need to check for common group flag
                        //

                        if (pszBuf[*(lpwCmd + 3)] == '1') {
                            iCommonGroup = 1;
                        } else {
                            iCommonGroup = 0;
                        }
                    }
                    const char * groupName = pszBuf + lpwCmd[1];

                    // Build a path to the directory
                    CHAR  szGroupName[MAX_PATH];
                    GetGroupPath(groupName, szGroupName, 0, iCommonGroup);


                    // We need to wait until we have a window whose title matches this group
                    DWORD dwStartTime   = GetTickCount();
                    DWORD dwNowTime     = dwStartTime;
                    BOOL bWindowExists  = FALSE;

                    while (dwNowTime - dwStartTime < dwMaxWaitTime)
                    {
                        bWindowExists = CheckForWindow(szGroupName);
                        if (bWindowExists)
                            break;

                        Sleep(100); // wait a bit more
                        dwNowTime = GetTickCount();
                    }

                    LOGN( 
                        eDbgLevelError, 
                        "DelayIfShowGroup: %8s(%s).", 
                        bWindowExists ? "Show" : "Timeout", 
                        szGroupName);
                }

                // Next command.
                lpwCmd += *lpwCmd + 1;
            }

    Leave:
            // Tidyup...
            GlobalFree(lpwCmdTemp);
        }

        free(pszBuf);
    }
}


HDDEDATA 
APIHOOK(DdeClientTransaction)(
    LPBYTE pData,       // pointer to data to pass to server
    DWORD cbData,       // length of data
    HCONV hConv,        // handle to conversation
    HSZ hszItem,        // handle to item name string
    UINT wFmt,          // clipboard data format
    UINT wType,         // transaction type
    DWORD dwTimeout,    // time-out duration
    LPDWORD pdwResult   // pointer to transaction result
    )
{
#if 0
    dwTimeout = 0x0fffffff; // a long time, enables me to debug explorer
#endif

    if (pData)
    {
        DPFN(eDbgLevelInfo, "DdeClientTransaction(%s) called.", pData);
    }

    // Pass data through untouched.
    HDDEDATA retval = ORIGINAL_API(DdeClientTransaction)(
        pData,       // pointer to data to pass to server
        cbData,       // length of data
        hConv,        // handle to conversation
        hszItem,        // handle to item name string
        wFmt,          // clipboard data format
        wType,         // transaction type
        dwTimeout,    // time-out duration
        pdwResult   // pointer to transaction result
        );


    if (pData)
        DelayIfShowGroup(pData);

    return retval;

}

/*++

  Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, DdeClientTransaction)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\disableboostthread.cpp ===
/*

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    DisableBoostThread.cpp

 Abstract:

    DisableBoostThread disables the autoboost that threads get when they
    unblocked. The NT scheduler will normally temporarily boost a thread
    when the synchronization object gets release. 9X does not: it only check
    if there is a higher priority thread.

    This was first written for Hijaak: besied its many memory bugs, as a race 
    condition between its worker thread and its main thread. See b#379504 for details.

 History:

    06/28/2001  pierreys    Created
*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DisableBoostThread)

#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateThread)
APIHOOK_ENUM_END

HANDLE
APIHOOK(CreateThread)(
    LPSECURITY_ATTRIBUTES lpsa,
    DWORD cbStack,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpvThreadParm,
    DWORD fdwCreate,
    LPDWORD lpIDThread    
    )
{
    HANDLE  hThread;

    //
    // Call the original API
    //
    hThread=ORIGINAL_API(CreateThread)(
        lpsa,
        cbStack,
        lpStartAddress,
        lpvThreadParm,
        fdwCreate,
        lpIDThread
    );

    if (hThread!=NULL)
    {
        //
        // We are disabling (rather weird, but TRUE means disabling)
        // the autoboost a thread gets for unblocking.
        //
        SetThreadPriorityBoost(hThread, TRUE);
    }

    return(hThread);
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason==DLL_PROCESS_ATTACH)
    {
        CSTRING_TRY
        {
            BOOL fBoostMainThread=FALSE;

            CString csCl(COMMAND_LINE);
            CStringParser csParser(csCl, L" ");
    
            int argc = csParser.GetCount();

            for (int i = 0; i < argc; ++i)
            {
                if (csParser[i] == L"+LowerMainThread")
                {
                    DPFN( eDbgLevelSpew, "LowerMainThread Selected");

                    //
                    // Unboost the main thread to make sure it runs first.
                    //
                    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_LOWEST);
                }
                else if (csParser[i] == L"+HigherMainThread")
                {
                    DPFN( eDbgLevelSpew, "HigherMainThread Selected");

                    //
                    // Boost the main thread to make sure it runs first.
                    //
                    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
                }
                else if (csParser[i] == L"+BoostMainThread")
                {
                    DPFN( eDbgLevelSpew, "HigherMainThread Selected");

                    fBoostMainThread = TRUE;
                }
                else
                {
                    DPFN( eDbgLevelError, "Ignoring unknown command:%S", csParser[i].Get());
                }
    
            }

            if (!fBoostMainThread)
            {
                //
                // We are disabling (rather weird, but TRUE means disabling)
                // the autoboost a thread gets for unblocking.
                //
                SetThreadPriorityBoost(GetCurrentThread(), TRUE);
            }
        }
        CSTRING_CATCH
        {
            DPFN( eDbgLevelError, "String error, ignoring command line");
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, CreateThread)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\delaywin95versionlie.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   DelayWin95VersionLie.cpp

 Abstract:

   This DLL hooks GetVersion and GetVersionEx so that they return Windows 95
   version credentials. Applications often check to ensure that they are 
   running on a Win9x system, even though they will run OK on an NT based 
   system.

 Notes:

   This is a general purpose shim.

 History:

   11/10/1999 v-johnwh  Created

--*/

#include "precomp.h"
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(DelayWin95VersionLie)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersion)
    APIHOOK_ENUM_ENTRY(GetVersionExA)
    APIHOOK_ENUM_ENTRY(GetVersionExW)
APIHOOK_ENUM_END

//
// Used to delay version lying
//
DWORD g_dwCount = 0;
DWORD g_dwDelay = 0;

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 95 credentials.

--*/

BOOL
APIHOOK(GetVersionExA)(
    OUT LPOSVERSIONINFOA lpVersionInformation
    )
{
    g_dwCount++;
    if (g_dwCount < g_dwDelay) {
        return ORIGINAL_API(GetVersionExA)(lpVersionInformation);
    } else {
        BOOL bReturn = FALSE;

        if (ORIGINAL_API(GetVersionExA)(lpVersionInformation)) {
            
            LOGN(eDbgLevelInfo, "[GetVersionExA] Return Win95");
            
            //
            // Fixup the structure with the Win95 data.
            //
            lpVersionInformation->dwMajorVersion = 4;
            lpVersionInformation->dwMinorVersion = 0;
            lpVersionInformation->dwBuildNumber = 950;
            lpVersionInformation->dwPlatformId = 1;
            *lpVersionInformation->szCSDVersion = '\0';

            bReturn = TRUE;
        }
        
        return bReturn;
    }
}

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 95 credentials.

--*/

BOOL
APIHOOK(GetVersionExW)(
    OUT LPOSVERSIONINFOW lpVersionInformation
    )
{
    g_dwCount++;
    if (g_dwCount < g_dwDelay) {
        return ORIGINAL_API(GetVersionExW)(lpVersionInformation);
    } else {
        BOOL bReturn = FALSE;

        if (ORIGINAL_API(GetVersionExW)(lpVersionInformation)) {
            
            LOGN(eDbgLevelInfo, "[GetVersionExW] Return Win95");
            
            //
            // Fixup the structure with the Win95 data.
            //
            lpVersionInformation->dwMajorVersion = 4;
            lpVersionInformation->dwMinorVersion = 0;
            lpVersionInformation->dwBuildNumber = 950;
            lpVersionInformation->dwPlatformId = 1;
            *lpVersionInformation->szCSDVersion = L'\0';

            bReturn = TRUE;
        }
        
        return bReturn;
    }
}

/*++

 This stub function returns Windows 95 credentials.

--*/

DWORD
APIHOOK(GetVersion)()
{
    g_dwCount++;
    if (g_dwCount < g_dwDelay) {
        return ORIGINAL_API(GetVersion)();
    } else {
        LOGN(eDbgLevelInfo, "[GetVersion] Return Win95");
        return (DWORD)0xC3B60004;
    }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        CSTRING_TRY
        {
            CString csCl(COMMAND_LINE);
        
            if (!csCl.IsEmpty())
            {
                WCHAR * unused;
                g_dwDelay = wcstol(csCl, &unused, 10);
            }

            DPFN(eDbgLevelInfo, "Delaying version lie by %d", g_dwDelay);
        }
        CSTRING_CATCH
        {
            return FALSE;
        }
    }
    
    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\disablefilterkeys.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   DisableFilterKeys.cpp

 Abstract:

   This shim disables the Filter Keys Accessibility Option at DLL_PROCESS_ATTACH,
   and re-enables it on termination of the application.

 History:

   06/27/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DisableFilterKeys)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

LPFILTERKEYS g_lpOldFilterKeyValue;
BOOL g_bInitialize = FALSE;

/*++

 DisableFilterKeys saves the current value for LPFILTERKEYS and then disables the option.

--*/

VOID 
DisableFilterKeys()
{
    if (!g_bInitialize) {
        //
        // Disable filter key support
        //
        g_bInitialize = TRUE;

        g_lpOldFilterKeyValue = (LPFILTERKEYS) malloc(sizeof(FILTERKEYS));
        g_lpOldFilterKeyValue->cbSize = sizeof(FILTERKEYS);

        LPFILTERKEYS pvParam = (LPFILTERKEYS) malloc(sizeof(FILTERKEYS));

        pvParam->cbSize = sizeof(FILTERKEYS);
        pvParam->dwFlags = 0;

        SystemParametersInfo(SPI_GETFILTERKEYS, sizeof(FILTERKEYS), 
            g_lpOldFilterKeyValue, 0);

        SystemParametersInfo(SPI_SETFILTERKEYS, sizeof(FILTERKEYS), pvParam, 
            SPIF_UPDATEINIFILE & SPIF_SENDCHANGE);

        LOGN( eDbgLevelInfo, "[DisableFilterKeys] Filter keys disabled");
    }
}

/*++

 EnableFilterKeys uses the save value for FILTERKEYS and resets the option to the original setting.

--*/

VOID 
EnableFilterKeys()
{
    if (g_bInitialize) {
        //
        // Restore filter key state
        //
        SystemParametersInfo(SPI_SETFILTERKEYS, sizeof(FILTERKEYS), 
            g_lpOldFilterKeyValue, SPIF_UPDATEINIFILE & SPIF_SENDCHANGE);

        LOGN( eDbgLevelInfo, "[EnableFilterKeys] Filter key state restored");
    }
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        // 
        // Turn OFF filter keys
        //
        DisableFilterKeys();
    } else if (fdwReason == DLL_PROCESS_DETACH) {
        //
        // Restore filter keys
        //
        EnableFilterKeys();
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\disablescreensaver.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    DisableScreenSaver.cpp

 Abstract:

    This shim is for apps that do bad things when screen savers are active.

 Notes:

    This is a general purpose shim.

 History:

    02/07/2001 linstev      Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DisableScreenSaver)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

// Store the state of the active flag
BOOL g_bActive = TRUE;

BOOL g_bSuccess = FALSE;

/*++

 Turn screen saver off and on again on detach.

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        // 
        // Turn OFF screen saver: detect success/failure so we know if we can 
        // safely clean up
        //
        BOOL bOff = FALSE;
        g_bSuccess = SystemParametersInfoA(SPI_GETSCREENSAVEACTIVE, 0, &g_bActive, 0) &&
                     SystemParametersInfoA(SPI_SETSCREENSAVEACTIVE, 0, &bOff, 0);        

        if (!g_bSuccess) {
            LOGN( eDbgLevelError, "[INIT] Failed to disable screen saver");
        }

    } else if (fdwReason == DLL_PROCESS_DETACH) {
        // 
        // Restore original screen saver state
        //
        if (g_bSuccess) {
            SystemParametersInfoA(SPI_SETSCREENSAVEACTIVE, g_bActive, NULL, 0);
        }
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\derandomizeexename.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    DerandomizeExeName.cpp

 Abstract:

    See markder

 History:

    10/13/1999  markder     created.   
    05/16/2000  robkenny    Check for memory alloc failure.
    03/12/2001  robkenny    Converted to CString

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DeRandomizeExeName)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA)
APIHOOK_ENUM_END

CString * g_csFilePattern = NULL;
CString * g_csNewFileName = NULL;

BOOL 
APIHOOK(CreateProcessA)(
    LPCSTR                lpApplicationName,    // name of executable module
    LPSTR                 lpCommandLine,        // command line string
    LPSECURITY_ATTRIBUTES lpProcessAttributes, 
    LPSECURITY_ATTRIBUTES lpThreadAttributes, 
    BOOL                  bInheritHandles,      // handle inheritance flag
    DWORD                 dwCreationFlags,      // creation flags
    LPVOID                lpEnvironment,        // new environment block
    LPCSTR                lpCurrentDirectory,   // current directory name
    LPSTARTUPINFOA        lpStartupInfo, 
    LPPROCESS_INFORMATION lpProcessInformation 
    )
{

    CSTRING_TRY
    {
        AppAndCommandLine appAndCommandLine(lpApplicationName, lpCommandLine);
    
        const CString & csOrigAppName = appAndCommandLine.GetApplicationName();
        CString fileName;
    
        //
        // Grab the filename portion of the string only.
        //
        csOrigAppName.GetLastPathComponent(fileName);
    
        BOOL bMatchesPattern = fileName.PatternMatch(*g_csFilePattern);
        if (bMatchesPattern)
        {
            //
            // Replace the randomized app name with the specified name
            //
            CString csNewAppName(csOrigAppName);
            csNewAppName.Replace(fileName, *g_csNewFileName);
    
            //
            // Copy the exe to the specified name.
            //
            if (CopyFileW(csOrigAppName.Get(), csNewAppName.Get(), FALSE))
            {
    
                LOGN(
                    eDbgLevelInfo,
                    "[CreateProcessA] Derandomized pathname from (%S) to (%S)",
                    csOrigAppName.Get(), csNewAppName.Get());
    
                //
                // Mark the file for deletion after we reboot,
                // otherwise the file will never get removed.
                //
                MoveFileExW(csNewAppName.Get(), NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
    
                //
                // We have successfully copied the exe to a new file with the specified name
                // it is now safe to replace the lpApplicationName to our new file.
                //
    
                return ORIGINAL_API(CreateProcessA) (
                                    csNewAppName.GetAnsi(),
                                    lpCommandLine, 
                                    lpProcessAttributes,
                                    lpThreadAttributes,
                                    bInheritHandles,
                                    dwCreationFlags,
                                    lpEnvironment,
                                    lpCurrentDirectory,
                                    lpStartupInfo,
                                    lpProcessInformation);
            }
        }
    }
    CSTRING_CATCH
    {
        // Fall through
    }

    return ORIGINAL_API(CreateProcessA) (
                        lpApplicationName,
                        lpCommandLine, 
                        lpProcessAttributes,
                        lpThreadAttributes,
                        bInheritHandles,
                        dwCreationFlags,
                        lpEnvironment,
                        lpCurrentDirectory,
                        lpStartupInfo,
                        lpProcessInformation);
}

#if TEST_MATCH
void
TestMatch(
    const char* a,
    const char* b
    )
{
    BOOL bMatch = PatternMatchA(a, b);
    
    if (bMatch)
    {
        DPFN(
            eDbgLevelSpew,
            "[TestMatch] (%s) == (%s)\n", a, b);
    }
    else
    {
        DPFN(
            eDbgLevelSpew,
            "[TestMatch] (%s) != (%s)\n", a, b);
    }
}

void TestLots()
{
    TestMatch("", "");
    TestMatch("", "ABC");
    TestMatch("*", "");
    TestMatch("?", "");
    TestMatch("abc", "ABC");
    TestMatch("?", "ABC");
    TestMatch("?bc", "ABC");
    TestMatch("a?c", "ABC");
    TestMatch("ab?", "ABC");
    TestMatch("a??", "ABC");
    TestMatch("?b?", "ABC");
    TestMatch("??c", "ABC");
    TestMatch("???", "ABC");
    TestMatch("*", "ABC");
    TestMatch("*.", "ABC");
    TestMatch("*.", "ABC.");
    TestMatch("*.?", "ABC.");
    TestMatch("??*", "ABC");
    TestMatch("*??", "ABC");
    TestMatch("ABC", "ABC");
    TestMatch(".*", "ABC");
    TestMatch("?*", "ABC");
    TestMatch("???*", "ABC");
    TestMatch("*.txt", "ABC.txt");
    TestMatch("*.txt", ".txt");
    TestMatch("*.txt", ".abc");
    TestMatch("*.txt", "txt.abc");
    TestMatch("***", "");
    TestMatch("***", "a");
    TestMatch("***", "ab");
    TestMatch("***", "abc");
}
#endif


BOOL
ParseCommandLine(void)
{
    CSTRING_TRY
    {
        CStringToken csTok(COMMAND_LINE, ";");

        g_csFilePattern = new CString;
        g_csNewFileName = new CString;

        if (g_csFilePattern &&
            g_csNewFileName && 
            csTok.GetToken(*g_csFilePattern) &&
            csTok.GetToken(*g_csNewFileName))
        {
            return TRUE;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
    
    LOGN(
        eDbgLevelError,
        "[ParseCommandLine] Illegal command line");

    return FALSE;
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        #if TEST_MATCH
        TestLots();
        #endif

        return ParseCommandLine();
    }

    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
   
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\disablethemes.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    DisableThemes.cpp

 Abstract:

    This shim is for apps that don't support themes.

 Notes:

    This is a general purpose shim.

 History:

    01/15/2001 clupu      Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DisableThemes)
#include "ShimHookMacro.h"

#include "uxtheme.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

void
TurnOffThemes(
    void
    )
{
    LOGN( eDbgLevelError, "[TurnOffThemes] Turning off themes");
    
    SetThemeAppProperties(0);
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        TurnOffThemes();
    }
    
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\disablestickykeys.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   DisableStickyKeys.cpp

 Abstract:

   This shim disables the Sticky Keys Accessibility Option at DLL_PROCESS_ATTACH,
   and re-enables it on termination of the application.

   Some applications, ie. A Bug's Life, have control keys mapped to the shift key.  When the
   key is pressed five consecutive times the option is enabled and they are dumped out to the
   desktop to verify that they want to enable the option.  In the case of A Bug's Life, the
   application errors and terminates when going to the desktop.

 History:

   05/11/2000 jdoherty  Created
   11/06/2000 linstev   Removed User32 dependency on InitializeHooks
   04/01/2001 linstev   Use SHIM_STATIC_DLLS_INITIALIZED callout

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DisableStickyKeys)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

LPSTICKYKEYS g_lpOldStickyKeyValue;
BOOL g_bInitialize = FALSE;

/*++

 DisableStickyKeys saves the current value for LPSTICKYKEYS and then disables the option.

--*/

VOID 
DisableStickyKeys()
{
    if (!g_bInitialize) {
        //
        // Disable sticky key support
        //
        g_bInitialize = TRUE;

        g_lpOldStickyKeyValue = (LPSTICKYKEYS) malloc(sizeof(STICKYKEYS));
        g_lpOldStickyKeyValue->cbSize = sizeof(STICKYKEYS);

        LPSTICKYKEYS pvParam = (LPSTICKYKEYS) malloc(sizeof(STICKYKEYS));

        pvParam->cbSize = sizeof(STICKYKEYS);
        pvParam->dwFlags = 0;

        SystemParametersInfo(SPI_GETSTICKYKEYS, sizeof(STICKYKEYS), 
            g_lpOldStickyKeyValue, 0);

        SystemParametersInfo(SPI_SETSTICKYKEYS, sizeof(STICKYKEYS), pvParam, 
            SPIF_UPDATEINIFILE & SPIF_SENDCHANGE);

        LOGN( eDbgLevelInfo, "[DisableStickyKeys] Sticky keys disabled");
    }
}

/*++

 EnableStickyKeys uses the save value for STICKYKEYS and resets the option to the original setting.

--*/

VOID 
EnableStickyKeys()
{
    if (g_bInitialize) {
        //
        // Restore sticky key state
        //
        SystemParametersInfo(SPI_SETSTICKYKEYS, sizeof(STICKYKEYS), 
            g_lpOldStickyKeyValue, SPIF_UPDATEINIFILE & SPIF_SENDCHANGE);

        LOGN( eDbgLevelInfo, "[EnableStickyKeys] Sticky key state restored");
    }
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        // 
        // Turn OFF sticky keys
        //
        DisableStickyKeys();
    } else if (fdwReason == DLL_PROCESS_DETACH) {
        //
        // Restore sticky keys
        //
        EnableStickyKeys();
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\disablew2kownerdrawbuttonstates.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    DisableW2KOwnerDrawButtonStates.cpp

 Abstract:

    Hooks all application-defined window procedures and filters out new
    owner-draw buttons states (introduced in Win2000).

 Notes:

    This shim can be reused for other shims that require WindowProc hooking.
    Copy all APIHook_* functions and simply replace the code in WindowProcHook
    and DialogProcHook.

 History:

    11/01/1999 markder  Created
    02/15/1999 markder  Reworked WndProc hooking mechanism so that it generically
                        hooks all WndProcs for the process.
    11/29/2000 andyseti Converted into GeneralPurpose shim.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DisableW2KOwnerDrawButtonStates)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA)
    APIHOOK_ENUM_ENTRY(RegisterClassW)
    APIHOOK_ENUM_ENTRY(RegisterClassExA)
    APIHOOK_ENUM_ENTRY(RegisterClassExW)
    APIHOOK_ENUM_ENTRY(CreateDialogParamA)
    APIHOOK_ENUM_ENTRY(CreateDialogParamW)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamA)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamW)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamAorW)
    APIHOOK_ENUM_ENTRY(SetWindowLongA)
    APIHOOK_ENUM_ENTRY(SetWindowLongW)
APIHOOK_ENUM_END


/*++

 Change WM_DRAWITEM behaviour

--*/

LRESULT CALLBACK 
WindowProcHook(
    WNDPROC pfnOld, // address of old WindowProc
    HWND hwnd,      // handle to window
    UINT uMsg,      // message identifier
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{
    // Check for message we're interested in
    if (uMsg == WM_DRAWITEM)
    {
        if (((LPDRAWITEMSTRUCT) lParam)->itemState &
                ~(ODS_SELECTED |
                ODS_GRAYED |
                ODS_DISABLED |
                ODS_CHECKED |
                ODS_FOCUS | 
                ODS_DEFAULT |
                ODS_COMBOBOXEDIT |
                ODS_HOTLIGHT |
                ODS_INACTIVE)) 
        {
            LOGN(eDbgLevelError, "Removed Win2K-specific Owner-draw button flags.");

            // Remove all Win9x-incompatible owner draw button states.
            ((LPDRAWITEMSTRUCT) lParam)->itemState &=
               (ODS_SELECTED |
                ODS_GRAYED |
                ODS_DISABLED |
                ODS_CHECKED |
                ODS_FOCUS | 
                ODS_DEFAULT |
                ODS_COMBOBOXEDIT |
                ODS_HOTLIGHT |
                ODS_INACTIVE);
        }
    }

    return (*pfnOld)(hwnd, uMsg, wParam, lParam);    
}

INT_PTR CALLBACK 
DialogProcHook(
    DLGPROC   pfnOld,   // address of old DialogProc
    HWND      hwndDlg,  // handle to dialog box
    UINT      uMsg,     // message
    WPARAM    wParam,   // first message parameter
    LPARAM    lParam    // second message parameter
    )
{
    // Check for message we're interested in
    if (uMsg == WM_DRAWITEM)
    {
        if (((LPDRAWITEMSTRUCT) lParam)->itemState &
                ~(ODS_SELECTED |
                ODS_GRAYED |
                ODS_DISABLED |
                ODS_CHECKED |
                ODS_FOCUS | 
                ODS_DEFAULT |
                ODS_COMBOBOXEDIT |
                ODS_HOTLIGHT |
                ODS_INACTIVE)) 
        {
            LOGN(eDbgLevelError, "Removed Win2K-specific Owner-draw button flags.");
 
            // Remove all Win9x-incompatible owner draw button states.
            ((LPDRAWITEMSTRUCT) lParam)->itemState &=
               (ODS_SELECTED |
                ODS_GRAYED |
                ODS_DISABLED |
                ODS_CHECKED |
                ODS_FOCUS | 
                ODS_DEFAULT |
                ODS_COMBOBOXEDIT |
                ODS_HOTLIGHT |
                ODS_INACTIVE);
        }
    }

    return (*pfnOld)(hwndDlg, uMsg, wParam, lParam);    
}

/*++

 Hook all possible calls that can initialize or change a window's
 WindowProc (or DialogProc)

--*/

ATOM
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpWndClass  // class data
    )
{
    WNDCLASSA   wcNewWndClass   = *lpWndClass;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, WindowProcHook);

    DPFN(eDbgLevelInfo, "Hooked window proc via RegisterClassA.");

    return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassW)(
    CONST WNDCLASSW *lpWndClass  // class data
    )
{
    WNDCLASSW   wcNewWndClass   = *lpWndClass;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, WindowProcHook);

    DPFN( eDbgLevelInfo, "Hooked window proc via RegisterClassW.");

    return ORIGINAL_API(RegisterClassW)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassExA)(
    CONST WNDCLASSEXA *lpwcx  // class data
    )
{
    WNDCLASSEXA   wcNewWndClass   = *lpwcx;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpwcx->lpfnWndProc, WindowProcHook);

    DPFN( eDbgLevelInfo, "Hooked window proc via RegisterClassExA.");

    return ORIGINAL_API(RegisterClassExA)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassExW)(
    CONST WNDCLASSEXW *lpwcx  // class data
    )
{
    WNDCLASSEXW   wcNewWndClass   = *lpwcx;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpwcx->lpfnWndProc, WindowProcHook);

    DPFN( eDbgLevelInfo, "Hooked window proc via RegisterClassExW.");

    return ORIGINAL_API(RegisterClassExW)(&wcNewWndClass);
}

HWND
APIHOOK(CreateDialogParamA)(
    HINSTANCE hInstance,     // handle to module
    LPCSTR lpTemplateName,   // dialog box template
    HWND hWndParent,         // handle to owner window
    DLGPROC lpDialogFunc,    // dialog box procedure
    LPARAM dwInitParam       // initialization value
    )
{
    lpDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, DialogProcHook);

    DPFN( eDbgLevelInfo, "Hooked window proc via CreateDialogParamA.");

    return ORIGINAL_API(CreateDialogParamA)(  
        hInstance,
        lpTemplateName,
        hWndParent,
        lpDialogFunc,
        dwInitParam     );
}

HWND
APIHOOK(CreateDialogParamW)(
    HINSTANCE hInstance,     // handle to module
    LPCWSTR lpTemplateName,  // dialog box template
    HWND hWndParent,         // handle to owner window
    DLGPROC lpDialogFunc,    // dialog box procedure
    LPARAM dwInitParam       // initialization value
    )
{
    lpDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, DialogProcHook);

    DPFN( eDbgLevelInfo, "Hooked window proc via CreateDialogParamW.");

    return ORIGINAL_API(CreateDialogParamW)(  
        hInstance,
        lpTemplateName,
        hWndParent,
        lpDialogFunc,
        dwInitParam     );
}

HWND
APIHOOK(CreateDialogIndirectParamA)(
    HINSTANCE hInstance,        // handle to module
    LPCDLGTEMPLATE lpTemplate,  // dialog box template
    HWND hWndParent,            // handle to owner window
    DLGPROC lpDialogFunc,       // dialog box procedure
    LPARAM lParamInit           // initialization value
    )
{
    lpDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, DialogProcHook);

    DPFN( eDbgLevelInfo, "Hooked window proc via CreateDialogIndirectParamA.");

    return ORIGINAL_API(CreateDialogIndirectParamA)(  
        hInstance,
        lpTemplate,
        hWndParent,
        lpDialogFunc,
        lParamInit     );
}

HWND
APIHOOK(CreateDialogIndirectParamW)(
    HINSTANCE hInstance,        // handle to module
    LPCDLGTEMPLATE lpTemplate,  // dialog box template
    HWND hWndParent,            // handle to owner window
    DLGPROC lpDialogFunc,       // dialog box procedure
    LPARAM lParamInit           // initialization value
    )
{
    lpDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, DialogProcHook);

    DPFN( eDbgLevelInfo, "Hooked window proc via CreateDialogIndirectParamW.");

    return ORIGINAL_API(CreateDialogIndirectParamW)(  
        hInstance,
        lpTemplate,
        hWndParent,
        lpDialogFunc,
        lParamInit     );
}

HWND
APIHOOK(CreateDialogIndirectParamAorW)(
    HINSTANCE hInstance,        // handle to module
    LPCDLGTEMPLATE lpTemplate,  // dialog box template
    HWND hWndParent,            // handle to owner window
    DLGPROC lpDialogFunc,       // dialog box procedure
    LPARAM lParamInit           // initialization value
    )
{
    lpDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, DialogProcHook);

    DPFN( eDbgLevelInfo, "Hooked window proc via CreateDialogIndirectParamAorW.");

    return ORIGINAL_API(CreateDialogIndirectParamAorW)(  
        hInstance,
        lpTemplate,
        hWndParent,
        lpDialogFunc,
        lParamInit     );
}

LONG 
APIHOOK(SetWindowLongA)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if (nIndex == GWL_WNDPROC) 
    {

        LOGN( eDbgLevelError, "Hooked window proc via SetWindowLongA. Pre-hook: 0x%X. ", dwNewLong);

        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, WindowProcHook);

        DPFN( eDbgLevelInfo, "Post-hook: 0x%X.", dwNewLong);

    } 
    else if (nIndex == DWL_DLGPROC) 
    {

        LOGN( eDbgLevelError, "Hooked dialog proc via SetWindowLongA. Pre-hook: 0x%X. ", dwNewLong);

        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, DialogProcHook);

        DPFN( eDbgLevelInfo, "Post-hook: 0x%X.", dwNewLong);
    }

    return ORIGINAL_API(SetWindowLongA)(  
        hWnd,
        nIndex,
        dwNewLong );
}

LONG 
APIHOOK(SetWindowLongW)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if (nIndex == GWL_WNDPROC) 
    {
        LOGN( eDbgLevelError, "Hooked window proc via SetWindowLongW. Pre-hook: 0x%X. ", dwNewLong);

        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, WindowProcHook);

        DPFN( eDbgLevelInfo, "Post-hook: 0x%X.", dwNewLong);
    } 
    else if (nIndex == DWL_DLGPROC) 
    {
        LOGN( eDbgLevelError, "Hooked dialog proc via SetWindowLongW. Pre-hook: 0x%X. ", dwNewLong);

        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, DialogProcHook);

        DPFN( eDbgLevelInfo, "Post-hook: 0x%X.", dwNewLong);
    }

    return ORIGINAL_API(SetWindowLongW)(  
        hWnd,
        nIndex,
        dwNewLong );
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassW);
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExA);
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExW);
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamA);
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamW);
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamA);
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamW);
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamAorW);
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA);
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongW);

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\emptyclipboardtoset.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmptyClipboardtoSet.cpp

 Abstract:
 
    Calendar of Ramadan V. 1 calls SetClipboardData with CF_TEXT without 
    emptying the clipboard first.
    
    This shim is app specific

 History:

 05/20/2001 mhamid  created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmptyClipboardtoSet)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetClipboardData) 
APIHOOK_ENUM_END

HANDLE 
APIHOOK(SetClipboardData)(
  UINT uFormat,
  HANDLE hMem
			             )
{
	if (uFormat == CF_TEXT)
		EmptyClipboard();
	return ORIGINAL_API(SetClipboardData)(uFormat, hMem);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SetClipboardData)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\emulategetstdhandle.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateGetStdHandle.cpp

 Abstract:
 
    Normally, when a process is created, members hStdInput, hStdOutput, and 
    hStdError of STARTUPINFO struct are set to NULL. Some apps like 
    Baby-Sitters Club Activity Center and Baby-Sitters Club 3-rd Grade Disk 2
    may check these handles and send Error messages.
    
    This shim can be used in this case to send appropriate handles and prevent 
    program terminate.

 History:

 06/14/2000 a-vales  created
 11/29/2000 andyseti Converted into AppSpecific shim.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateGetStdHandle)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetStdHandle) 
APIHOOK_ENUM_END

HANDLE 
APIHOOK(GetStdHandle)(
    DWORD nStdHandle)
{
    HANDLE hStd = ORIGINAL_API(GetStdHandle)(nStdHandle);

    if (hStd == 0)
    {
        switch (nStdHandle)
        {
            case STD_INPUT_HANDLE:
                LOGN( eDbgLevelError, "Correcting GetStdHandle(STD_INPUT_HANDLE). Returning handle = 1.");
                hStd = (HANDLE) 1;
                break;
            case STD_OUTPUT_HANDLE:
                LOGN( eDbgLevelError, "Correcting GetStdHandle(STD_OUTPUT_HANDLE). Returning handle = 2.");
                hStd = (HANDLE) 2;
                break;

            case STD_ERROR_HANDLE:
                LOGN( eDbgLevelError, "Correcting GetStdHandle(STD_ERROR_HANDLE). Returning handle = 3.");
                hStd = (HANDLE) 3;
                break;
        }
    }

    return hStd;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetStdHandle)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\emulatelzhandles.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateLZHandles.cpp

 Abstract:

    This shim hooks all of the LZ api calls and increments/decrements the 
    handles so that a valid handle from the app's perspective is always > 0 
    instead of >= 0.

    Fixes apps that treated a handle value of zero as an error; Win9x never 
    returned handles of zero.

 History:

    07/25/2000 t-adams  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateLZHandles)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LZClose) 
    APIHOOK_ENUM_ENTRY(LZCopy) 
    APIHOOK_ENUM_ENTRY(LZInit) 
    APIHOOK_ENUM_ENTRY(LZOpenFile) 
    APIHOOK_ENUM_ENTRY(LZRead) 
    APIHOOK_ENUM_ENTRY(LZSeek) 
APIHOOK_ENUM_END

#define KEY_SIZE_STEP MAX_PATH

/*++

  Abstract:
    This function decrements the handles on the way in and increments
    handles that are passed back to the app

  History:

  07/25/2000    t-adams     Created

--*/

VOID
APIHOOK(LZClose)(INT hFile) 
{
    ORIGINAL_API(LZClose)(--hFile);
}

/*++

  Abstract:
    This function decrements the handles on the way in and increments
    handles that are passed back to the app

  History:

  07/25/2000    t-adams     Created

--*/

LONG
APIHOOK(LZCopy)(
           INT hSource, 
           INT hDest
           ) 
{
    return ORIGINAL_API(LZCopy)(--hSource, --hDest);
}

/*++

  Abstract:
    This function does not decrement the handle passed in to it
    because the handle passed in is supposed to be a regular HANDLE
    created by CreateFile.  It does decrement handles that are 
    passed back to the app because they represent LZ file handles.
    The differences between the handles are poorly documented in MSDN.

  History:

  07/25/2000    t-adams     Created

--*/

INT
APIHOOK(LZInit)(INT hfSource) 
{
    INT iRet = 0;

    // Don't decrement handle.  See above.
    iRet = ORIGINAL_API(LZInit)(hfSource);

    // If there was an error, don't increment the error.
    if(iRet < 0) {
        return iRet;
    }
    
    return ++iRet;
}

/*++

  Abstract:
    This function decrements the handles on the way in and increments
    handles that are passed back to the app

  History:

  07/25/2000    t-adams     Created

--*/

INT
APIHOOK(LZOpenFile)(
    LPSTR lpFileName, 
    LPOFSTRUCT lpReOpenBuf, 
    WORD wStyle
    )
{
    INT iRet = 0;
    iRet = ORIGINAL_API(LZOpenFile)(lpFileName, lpReOpenBuf, wStyle);

    // If there was an error, don't increment the error.
    if( iRet < 0 ) {
        return iRet;
    }

    return ++iRet;
}

/*++

  Abstract:
    This function decrements the handles on the way in and increments
    handles that are passed back to the app

  History:

  07/25/2000    t-adams     Created

--*/

INT
APIHOOK(LZRead)(
    INT hFile, 
    LPSTR lpBuffer, 
    INT cbRead
    ) 
{
    return ORIGINAL_API(LZRead)(--hFile, lpBuffer, cbRead);
}

/*++

  Abstract:
    This function decrements the handles on the way in and increments
    handles that are passed back to the app

  History:

  07/25/2000    t-adams     Created

--*/

LONG
APIHOOK(LZSeek)(
    INT hFile, 
    LONG lOffset, 
    INT iOrigin
    ) 
{
    return ORIGINAL_API(LZSeek)(--hFile, lOffset, iOrigin);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(LZ32.DLL, LZClose)
    APIHOOK_ENTRY(LZ32.DLL, LZCopy)
    APIHOOK_ENTRY(LZ32.DLL, LZInit)
    APIHOOK_ENTRY(LZ32.DLL, LZOpenFile)
    APIHOOK_ENTRY(LZ32.DLL, LZRead)
    APIHOOK_ENTRY(LZ32.DLL, LZSeek)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\enlargegetobject.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EnlargeGetObject.cpp

 Abstract:
 
    Holy Quran (El Hozayfy and Mohamed Ayoub) V 1 calls GetObjectA()
    with the second parameter hard coded to 10 while it suppose to 
    be the sizeof(BITMAP) i.e. 24
    
    This shim is app specific

 History:

 04/17/2001 mhamid  created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EnlargeGetObjectBufferSize)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetObjectA) 
APIHOOK_ENUM_END

int 
APIHOOK(GetObjectA)(
  HGDIOBJ hgdiobj,  // handle to graphics object
  int cbBuffer,     // size of buffer for object information
  LPVOID lpvObject  // buffer for object information
					)
{
	if ((cbBuffer == 10) && (lpvObject != NULL))
		cbBuffer = sizeof(BITMAP);
	return ORIGINAL_API(GetObjectA)(hgdiobj, cbBuffer, lpvObject);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(GDI32.DLL, GetObjectA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\emulategetstringtype.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    EmulateGetStringType.cpp

 Abstract:
    
    This shim emulate Win 2K GetStringType[W,ExW,A,ExA] API behavior.
    There's more than 10k change in Win XP ctype from Win 2K for Unicode 3.0 
    change.

 Notes:

    This is a general shim.

 History:

    06/03/2002 hioh     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateGetStringType)

#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetStringTypeW)
    APIHOOK_ENUM_ENTRY(GetStringTypeExW)
    APIHOOK_ENUM_ENTRY(GetStringTypeA)
    APIHOOK_ENUM_ENTRY(GetStringTypeExA)
APIHOOK_ENUM_END

/*++

 Table data imported, sorted and compressed from Win2K 
    \windows\winnls\data\other\ctype.txt.
 Format : WCHAR, CTYPE1, CTYPE2, CTYPE3, # of duplication series

--*/

#define MAXINDEX 1420    // 0 base max
WORD g_ctype[][5] = {
    0x0000, 0x0020, 0x0000, 0x0000, 0x0008,
    0x0009, 0x0068, 0x0009, 0x0008, 0x0000,
    0x000A, 0x0028, 0x0000, 0x0008, 0x0003,
    0x000E, 0x0020, 0x0000, 0x0000, 0x0011,
    0x0020, 0x0048, 0x000A, 0x0048, 0x0000,
    0x0021, 0x0010, 0x000B, 0x0048, 0x0000,
    0x0022, 0x0010, 0x000B, 0x0448, 0x0000,
    0x0023, 0x0010, 0x0005, 0x0048, 0x0000,
    0x0024, 0x0010, 0x0005, 0x0448, 0x0000,
    0x0025, 0x0010, 0x0005, 0x0048, 0x0000,
    0x0026, 0x0010, 0x0001, 0x0048, 0x0000,
    0x0027, 0x0010, 0x000B, 0x0440, 0x0000,
    0x0028, 0x0010, 0x000B, 0x0048, 0x0002,
    0x002B, 0x0010, 0x0005, 0x0048, 0x0000,
    0x002C, 0x0010, 0x0007, 0x0048, 0x0000,
    0x002D, 0x0010, 0x0005, 0x0440, 0x0000,
    0x002E, 0x0010, 0x0004, 0x0048, 0x0000,
    0x002F, 0x0010, 0x0004, 0x0448, 0x0000,
    0x0030, 0x0084, 0x0003, 0x0040, 0x0009,
    0x003A, 0x0010, 0x0007, 0x0048, 0x0000,
    0x003B, 0x0010, 0x000B, 0x0048, 0x0001,
    0x003D, 0x0010, 0x000B, 0x0448, 0x0000,
    0x003E, 0x0010, 0x000B, 0x0048, 0x0001,
    0x0040, 0x0010, 0x0001, 0x0448, 0x0000,
    0x0041, 0x0181, 0x0001, 0x8040, 0x0005,
    0x0047, 0x0101, 0x0001, 0x8040, 0x0013,
    0x005B, 0x0010, 0x000B, 0x0048, 0x0000,
    0x005C, 0x0010, 0x000B, 0x0448, 0x0000,
    0x005D, 0x0010, 0x000B, 0x0048, 0x0000,
    0x005E, 0x0010, 0x000B, 0x0448, 0x0002,
    0x0061, 0x0182, 0x0001, 0x8040, 0x0005,
    0x0067, 0x0102, 0x0001, 0x8040, 0x0013,
    0x007B, 0x0010, 0x000B, 0x0048, 0x0002,
    0x007E, 0x0010, 0x000B, 0x0448, 0x0000,
    0x007F, 0x0020, 0x0000, 0x0000, 0x0020,
    0x00A0, 0x0048, 0x000A, 0x0008, 0x0000,
    0x00A1, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00A2, 0x0010, 0x0005, 0x0048, 0x0001,
    0x00A4, 0x0010, 0x0005, 0x0008, 0x0000,
    0x00A5, 0x0010, 0x0005, 0x0048, 0x0000,
    0x00A6, 0x0010, 0x000B, 0x0048, 0x0000,
    0x00A7, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00A8, 0x0010, 0x000B, 0x0408, 0x0000,
    0x00A9, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00AA, 0x0010, 0x000B, 0x0400, 0x0000,
    0x00AB, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00AC, 0x0010, 0x000B, 0x0048, 0x0000,
    0x00AD, 0x0010, 0x000B, 0x0408, 0x0000,
    0x00AE, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00AF, 0x0010, 0x000B, 0x0448, 0x0000,
    0x00B0, 0x0010, 0x0005, 0x0008, 0x0001,
    0x00B2, 0x0014, 0x0003, 0x0000, 0x0001,
    0x00B4, 0x0010, 0x000B, 0x0408, 0x0000,
    0x00B5, 0x0010, 0x000B, 0x0008, 0x0002,
    0x00B8, 0x0010, 0x000B, 0x0408, 0x0000,
    0x00B9, 0x0014, 0x0003, 0x0000, 0x0000,
    0x00BA, 0x0010, 0x000B, 0x0400, 0x0000,
    0x00BB, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00BC, 0x0010, 0x000B, 0x0000, 0x0002,
    0x00BF, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00C0, 0x0101, 0x0001, 0x8003, 0x0005,
    0x00C6, 0x0101, 0x0001, 0x8000, 0x0000,
    0x00C7, 0x0101, 0x0001, 0x8003, 0x0008,
    0x00D0, 0x0101, 0x0001, 0x8000, 0x0000,
    0x00D1, 0x0101, 0x0001, 0x8003, 0x0005,
    0x00D7, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00D8, 0x0101, 0x0001, 0x8003, 0x0005,
    0x00DE, 0x0101, 0x0001, 0x8000, 0x0000,
    0x00DF, 0x0102, 0x0001, 0x8000, 0x0000,
    0x00E0, 0x0102, 0x0001, 0x8003, 0x0005,
    0x00E6, 0x0102, 0x0001, 0x8000, 0x0000,
    0x00E7, 0x0102, 0x0001, 0x8003, 0x0008,
    0x00F0, 0x0102, 0x0001, 0x8000, 0x0000,
    0x00F1, 0x0102, 0x0001, 0x8003, 0x0005,
    0x00F7, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00F8, 0x0102, 0x0001, 0x8003, 0x0005,
    0x00FE, 0x0102, 0x0001, 0x8000, 0x0000,
    0x00FF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0100, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0101, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0102, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0103, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0104, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0105, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0106, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0107, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0108, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0109, 0x0102, 0x0001, 0x8003, 0x0000,
    0x010A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x010B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x010C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x010D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x010E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x010F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0110, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0111, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0112, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0113, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0114, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0115, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0116, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0117, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0118, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0119, 0x0102, 0x0001, 0x8003, 0x0000,
    0x011A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x011B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x011C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x011D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x011E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x011F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0120, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0121, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0122, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0123, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0124, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0125, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0126, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0127, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0128, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0129, 0x0102, 0x0001, 0x8003, 0x0000,
    0x012A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x012B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x012C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x012D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x012E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x012F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0130, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0131, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0132, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0133, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0134, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0135, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0136, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0137, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0138, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0139, 0x0101, 0x0001, 0x8003, 0x0000,
    0x013A, 0x0102, 0x0001, 0x8003, 0x0000,
    0x013B, 0x0101, 0x0001, 0x8003, 0x0000,
    0x013C, 0x0102, 0x0001, 0x8003, 0x0000,
    0x013D, 0x0101, 0x0001, 0x8003, 0x0000,
    0x013E, 0x0102, 0x0001, 0x8003, 0x0000,
    0x013F, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0140, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0141, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0142, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0143, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0144, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0145, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0146, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0147, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0148, 0x0102, 0x0001, 0x8003, 0x0001,
    0x014A, 0x0101, 0x0001, 0x8000, 0x0000,
    0x014B, 0x0102, 0x0001, 0x8000, 0x0000,
    0x014C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x014D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x014E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x014F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0150, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0151, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0152, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0153, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0154, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0155, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0156, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0157, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0158, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0159, 0x0102, 0x0001, 0x8003, 0x0000,
    0x015A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x015B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x015C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x015D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x015E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x015F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0160, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0161, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0162, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0163, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0164, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0165, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0166, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0167, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0168, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0169, 0x0102, 0x0001, 0x8003, 0x0000,
    0x016A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x016B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x016C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x016D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x016E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x016F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0170, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0171, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0172, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0173, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0174, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0175, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0176, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0177, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0178, 0x0101, 0x0001, 0x8003, 0x0001,
    0x017A, 0x0102, 0x0001, 0x8003, 0x0000,
    0x017B, 0x0101, 0x0001, 0x8003, 0x0000,
    0x017C, 0x0102, 0x0001, 0x8003, 0x0000,
    0x017D, 0x0101, 0x0001, 0x8003, 0x0000,
    0x017E, 0x0102, 0x0001, 0x8003, 0x0000,
    0x017F, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0180, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0181, 0x0101, 0x0001, 0x8000, 0x0001,
    0x0183, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0184, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0185, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0186, 0x0101, 0x0001, 0x8000, 0x0001,
    0x0188, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0189, 0x0101, 0x0001, 0x8000, 0x0002,
    0x018C, 0x0102, 0x0001, 0x8000, 0x0001,
    0x018E, 0x0101, 0x0001, 0x8000, 0x0003,
    0x0192, 0x0112, 0x0001, 0x8000, 0x0000,
    0x0193, 0x0101, 0x0001, 0x8000, 0x0001,
    0x0195, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0196, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0197, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0198, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0199, 0x0102, 0x0001, 0x8000, 0x0000,
    0x019A, 0x0102, 0x0001, 0x8003, 0x0001,
    0x019C, 0x0101, 0x0001, 0x8000, 0x0001,
    0x019E, 0x0102, 0x0001, 0x8000, 0x0000,
    0x019F, 0x0101, 0x0001, 0x8003, 0x0001,
    0x01A1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01A2, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01A3, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01A4, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01A5, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01A6, 0x0100, 0x0001, 0x8000, 0x0000,
    0x01A7, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01A8, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01A9, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01AA, 0x0100, 0x0001, 0x8000, 0x0000,
    0x01AB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01AC, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01AD, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01AE, 0x0101, 0x0001, 0x8003, 0x0001,
    0x01B0, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01B1, 0x0101, 0x0001, 0x8000, 0x0002,
    0x01B4, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01B5, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01B6, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01B7, 0x0101, 0x0001, 0x8000, 0x0001,
    0x01B9, 0x0102, 0x0001, 0x8000, 0x0001,
    0x01BB, 0x0100, 0x0001, 0x8000, 0x0000,
    0x01BC, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01BD, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01BE, 0x0100, 0x0001, 0x8000, 0x0001,
    0x01C0, 0x0100, 0x0001, 0x8008, 0x0003,
    0x01C4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01C5, 0x0103, 0x0001, 0x8003, 0x0000,
    0x01C6, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01C7, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01C8, 0x0103, 0x0001, 0x8000, 0x0000,
    0x01C9, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01CA, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01CB, 0x0103, 0x0001, 0x8000, 0x0000,
    0x01CC, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01CD, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01CE, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01CF, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01D0, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01D1, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01D2, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01D3, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01D4, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01D5, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01D6, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01D7, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01D8, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01D9, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01DA, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01DB, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01DC, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01DD, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01DE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01DF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01E0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01E1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01E2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01E3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01E4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01E5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01E6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01E7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01E8, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01E9, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01EA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01EB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01EC, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01ED, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01EE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01EF, 0x0102, 0x0001, 0x8003, 0x0001,
    0x01F1, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01F2, 0x0103, 0x0001, 0x8000, 0x0000,
    0x01F3, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01F4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01F5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01FA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01FB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01FC, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01FD, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01FE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01FF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0200, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0201, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0202, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0203, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0204, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0205, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0206, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0207, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0208, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0209, 0x0102, 0x0001, 0x8003, 0x0000,
    0x020A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x020B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x020C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x020D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x020E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x020F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0210, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0211, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0212, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0213, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0214, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0215, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0216, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0217, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0250, 0x0102, 0x0001, 0x8000, 0x0011,
    0x0262, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0263, 0x0102, 0x0001, 0x8000, 0x0004,
    0x0268, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0269, 0x0102, 0x0001, 0x8000, 0x0000,
    0x026A, 0x0100, 0x0001, 0x8000, 0x0000,
    0x026B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x026C, 0x0102, 0x0001, 0x8000, 0x0007,
    0x0274, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0275, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0276, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0277, 0x0102, 0x0001, 0x8000, 0x0008,
    0x0280, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0282, 0x0102, 0x0001, 0x8000, 0x000C,
    0x028F, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0290, 0x0102, 0x0001, 0x8000, 0x0003,
    0x0294, 0x0100, 0x0001, 0x8000, 0x0005,
    0x029A, 0x0102, 0x0001, 0x8000, 0x0000,
    0x029B, 0x0100, 0x0001, 0x8000, 0x0001,
    0x029D, 0x0102, 0x0001, 0x8000, 0x0001,
    0x029F, 0x0100, 0x0001, 0x8000, 0x0000,
    0x02A0, 0x0102, 0x0001, 0x8000, 0x0000,
    0x02A1, 0x0100, 0x0001, 0x8000, 0x0001,
    0x02A3, 0x0102, 0x0001, 0x8000, 0x0005,
    0x02B0, 0x0010, 0x0001, 0x0400, 0x0008,
    0x02B9, 0x0010, 0x0001, 0x0001, 0x0002,
    0x02BC, 0x0010, 0x0001, 0x0401, 0x0000,
    0x02BD, 0x0010, 0x0001, 0x0001, 0x0009,
    0x02C7, 0x0010, 0x0001, 0x0401, 0x0000,
    0x02C8, 0x0010, 0x0001, 0x0001, 0x0001,
    0x02CA, 0x0010, 0x0001, 0x0401, 0x0001,
    0x02CC, 0x0010, 0x0001, 0x0001, 0x0002,
    0x02CF, 0x0010, 0x0001, 0x0401, 0x0000,
    0x02D0, 0x0010, 0x0001, 0x0001, 0x0007,
    0x02D8, 0x0010, 0x0001, 0x0408, 0x0005,
    0x02DE, 0x0010, 0x0001, 0x0001, 0x0000,
    0x02E0, 0x0010, 0x0001, 0x0400, 0x0003,
    0x02E4, 0x0010, 0x0001, 0x0001, 0x0005,
    0x0300, 0x0010, 0x0001, 0x0003, 0x0045,
    0x0360, 0x0010, 0x0001, 0x0003, 0x0001,
    0x0374, 0x0010, 0x0001, 0x0000, 0x0001,
    0x037A, 0x0010, 0x0001, 0x0408, 0x0000,
    0x037E, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0384, 0x0010, 0x0001, 0x0408, 0x0001,
    0x0386, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0387, 0x0010, 0x0001, 0x0408, 0x0000,
    0x0388, 0x0101, 0x0001, 0x8003, 0x0002,
    0x038C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x038E, 0x0101, 0x0001, 0x8003, 0x0001,
    0x0390, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0391, 0x0101, 0x0001, 0x8000, 0x0010,
    0x03A3, 0x0101, 0x0001, 0x8000, 0x0006,
    0x03AA, 0x0101, 0x0001, 0x8003, 0x0001,
    0x03AC, 0x0102, 0x0001, 0x8003, 0x0004,
    0x03B1, 0x0102, 0x0001, 0x8000, 0x0018,
    0x03CA, 0x0102, 0x0001, 0x8003, 0x0004,
    0x03D0, 0x0102, 0x0001, 0x8000, 0x0001,
    0x03D2, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03D3, 0x0101, 0x0001, 0x8003, 0x0001,
    0x03D5, 0x0102, 0x0001, 0x8000, 0x0001,
    0x03DA, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03DC, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03DE, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03E0, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03E2, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03E3, 0x0102, 0x0001, 0x8000, 0x0000,
    0x03E4, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03E5, 0x0102, 0x0001, 0x8000, 0x0000,
    0x03E6, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03E7, 0x0102, 0x0001, 0x8000, 0x0000,
    0x03E8, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03E9, 0x0102, 0x0001, 0x8000, 0x0000,
    0x03EA, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03EB, 0x0102, 0x0001, 0x8000, 0x0000,
    0x03EC, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03ED, 0x0102, 0x0001, 0x8000, 0x0000,
    0x03EE, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03EF, 0x0102, 0x0001, 0x8000, 0x0004,
    0x0401, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0402, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0403, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0404, 0x0101, 0x0001, 0x8000, 0x0002,
    0x0407, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0408, 0x0101, 0x0001, 0x8000, 0x0003,
    0x040C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x040E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x040F, 0x0101, 0x0001, 0x8000, 0x0009,
    0x0419, 0x0101, 0x0001, 0x8003, 0x0000,
    0x041A, 0x0101, 0x0001, 0x8000, 0x0015,
    0x0430, 0x0102, 0x0001, 0x8000, 0x0008,
    0x0439, 0x0102, 0x0001, 0x8003, 0x0000,
    0x043A, 0x0102, 0x0001, 0x8000, 0x0015,
    0x0451, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0452, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0453, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0454, 0x0102, 0x0001, 0x8000, 0x0002,
    0x0457, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0458, 0x0102, 0x0001, 0x8000, 0x0003,
    0x045C, 0x0102, 0x0001, 0x8003, 0x0000,
    0x045E, 0x0102, 0x0001, 0x8003, 0x0000,
    0x045F, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0460, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0461, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0462, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0463, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0464, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0465, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0466, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0467, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0468, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0469, 0x0102, 0x0001, 0x8000, 0x0000,
    0x046A, 0x0101, 0x0001, 0x8000, 0x0000,
    0x046B, 0x0102, 0x0001, 0x8000, 0x0000,
    0x046C, 0x0101, 0x0001, 0x8000, 0x0000,
    0x046D, 0x0102, 0x0001, 0x8000, 0x0000,
    0x046E, 0x0101, 0x0001, 0x8000, 0x0000,
    0x046F, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0470, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0471, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0472, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0473, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0474, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0475, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0476, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0477, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0478, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0479, 0x0102, 0x0001, 0x8000, 0x0000,
    0x047A, 0x0101, 0x0001, 0x8000, 0x0000,
    0x047B, 0x0102, 0x0001, 0x8000, 0x0000,
    0x047C, 0x0101, 0x0001, 0x8000, 0x0000,
    0x047D, 0x0102, 0x0001, 0x8000, 0x0000,
    0x047E, 0x0101, 0x0001, 0x8000, 0x0000,
    0x047F, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0480, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0481, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0482, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0483, 0x0010, 0x0001, 0x0003, 0x0003,
    0x0490, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0491, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0492, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0493, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0494, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0495, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0496, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0497, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0498, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0499, 0x0102, 0x0001, 0x8003, 0x0000,
    0x049A, 0x0101, 0x0001, 0x8000, 0x0000,
    0x049B, 0x0102, 0x0001, 0x8000, 0x0000,
    0x049C, 0x0101, 0x0001, 0x8000, 0x0000,
    0x049D, 0x0102, 0x0001, 0x8000, 0x0000,
    0x049E, 0x0101, 0x0001, 0x8000, 0x0000,
    0x049F, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04A0, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04A1, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04A2, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04A3, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04A4, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04A5, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04A6, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04A7, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04A8, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04A9, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04AA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04AB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04AC, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04AD, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04AE, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04AF, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04B0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04B1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04B2, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04B3, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04B4, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04B5, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04B6, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04B7, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04B8, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04B9, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04BA, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04BB, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04BC, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04BD, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04BE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04BF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04C0, 0x0100, 0x0001, 0x8000, 0x0000,
    0x04C1, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04C2, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04C3, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04C4, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04C7, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04C8, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04CB, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04CC, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04D0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04D1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04D2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04D3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04D4, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04D5, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04D6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04D7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04D8, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04D9, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04DA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04DB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04DC, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04DD, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04DE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04DF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04E0, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04E1, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04E2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04E3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04E4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04E5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04E6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04E7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04E8, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04E9, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04EA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04EB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04EE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04EF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04F0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04F1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04F2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04F3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04F4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04F5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04F8, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04F9, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0531, 0x0101, 0x0001, 0x8000, 0x0025,
    0x0559, 0x0010, 0x0001, 0x0401, 0x0001,
    0x055B, 0x0010, 0x0001, 0x0008, 0x0004,
    0x0561, 0x0102, 0x0001, 0x8000, 0x0026,
    0x0589, 0x0010, 0x0001, 0x0008, 0x0000,
    0x0591, 0x0010, 0x0002, 0x0003, 0x0010,
    0x05A3, 0x0010, 0x0002, 0x0003, 0x001A,
    0x05BE, 0x0010, 0x0002, 0x0008, 0x0000,
    0x05BF, 0x0010, 0x0002, 0x0003, 0x0000,
    0x05C0, 0x0010, 0x0002, 0x0008, 0x0000,
    0x05C1, 0x0010, 0x0002, 0x0003, 0x0001,
    0x05C3, 0x0010, 0x0002, 0x0008, 0x0000,
    0x05C4, 0x0010, 0x0002, 0x0003, 0x0000,
    0x05D0, 0x0100, 0x0002, 0x8000, 0x001A,
    0x05F0, 0x0100, 0x0002, 0x8000, 0x0002,
    0x05F3, 0x0010, 0x0002, 0x0008, 0x0001,
    0x060C, 0x0010, 0x0002, 0x0008, 0x0000,
    0x061B, 0x0010, 0x0002, 0x0008, 0x0000,
    0x061F, 0x0010, 0x0002, 0x0008, 0x0000,
    0x0621, 0x0100, 0x0002, 0x8000, 0x0019,
    0x0640, 0x0010, 0x0002, 0x0601, 0x0000,
    0x0641, 0x0100, 0x0002, 0x8000, 0x0009,
    0x064B, 0x0010, 0x0002, 0x0003, 0x0007,
    0x0660, 0x0004, 0x0006, 0x0000, 0x0009,
    0x066A, 0x0010, 0x0005, 0x0008, 0x0000,
    0x066B, 0x0010, 0x0007, 0x0008, 0x0001,
    0x066D, 0x0010, 0x0002, 0x0008, 0x0000,
    0x0670, 0x0010, 0x0002, 0x0003, 0x0000,
    0x0671, 0x0100, 0x0002, 0x8000, 0x0046,
    0x06BA, 0x0100, 0x0002, 0x8000, 0x0004,
    0x06C0, 0x0100, 0x0002, 0x8000, 0x000E,
    0x06D0, 0x0100, 0x0002, 0x8000, 0x0003,
    0x06D4, 0x0010, 0x0002, 0x0008, 0x0000,
    0x06D5, 0x0100, 0x0002, 0x8000, 0x0000,
    0x06D6, 0x0010, 0x0002, 0x0001, 0x0012,
    0x06E9, 0x0010, 0x0002, 0x0008, 0x0000,
    0x06EA, 0x0010, 0x0002, 0x0001, 0x0003,
    0x06F0, 0x0004, 0x0003, 0x0000, 0x0009,
    0x0901, 0x0010, 0x0001, 0x0001, 0x0002,
    0x0905, 0x0100, 0x0001, 0x8000, 0x0034,
    0x093C, 0x0010, 0x0001, 0x0001, 0x0000,
    0x093D, 0x0010, 0x0001, 0x0000, 0x0000,
    0x093E, 0x0010, 0x0001, 0x0005, 0x000E,
    0x094D, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0950, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0951, 0x0010, 0x0001, 0x0001, 0x0003,
    0x0958, 0x0100, 0x0001, 0x8000, 0x0009,
    0x0962, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0964, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0966, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0970, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0981, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0982, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0985, 0x0100, 0x0001, 0x8000, 0x0007,
    0x098F, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0993, 0x0100, 0x0001, 0x8000, 0x0015,
    0x09AA, 0x0100, 0x0001, 0x8000, 0x0006,
    0x09B2, 0x0100, 0x0001, 0x8000, 0x0000,
    0x09B6, 0x0100, 0x0001, 0x8000, 0x0003,
    0x09BC, 0x0010, 0x0001, 0x0001, 0x0000,
    0x09BE, 0x0010, 0x0001, 0x0004, 0x0002,
    0x09C1, 0x0010, 0x0001, 0x0005, 0x0003,
    0x09C7, 0x0010, 0x0001, 0x0004, 0x0001,
    0x09CB, 0x0010, 0x0001, 0x0004, 0x0001,
    0x09CD, 0x0010, 0x0001, 0x0001, 0x0000,
    0x09D7, 0x0010, 0x0001, 0x0000, 0x0000,
    0x09DC, 0x0100, 0x0001, 0x8000, 0x0001,
    0x09DF, 0x0100, 0x0001, 0x8000, 0x0002,
    0x09E2, 0x0010, 0x0001, 0x0005, 0x0001,
    0x09E6, 0x0004, 0x0001, 0x0000, 0x0009,
    0x09F0, 0x0100, 0x0001, 0x8000, 0x0001,
    0x09F2, 0x0010, 0x0001, 0x0000, 0x0008,
    0x0A02, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0A05, 0x0100, 0x0001, 0x8000, 0x0005,
    0x0A0F, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0A13, 0x0100, 0x0001, 0x8000, 0x0015,
    0x0A2A, 0x0100, 0x0001, 0x8000, 0x0006,
    0x0A32, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0A35, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0A38, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0A3C, 0x0010, 0x0001, 0x0005, 0x0000,
    0x0A3E, 0x0010, 0x0001, 0x0004, 0x0001,
    0x0A40, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0A41, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0A47, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0A4B, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0A4D, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0A59, 0x0100, 0x0001, 0x8000, 0x0003,
    0x0A5E, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0A66, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0A70, 0x0010, 0x0001, 0x0001, 0x0001,
    0x0A72, 0x0010, 0x0001, 0x0000, 0x0002,
    0x0A81, 0x0010, 0x0001, 0x0001, 0x0001,
    0x0A83, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0A85, 0x0100, 0x0001, 0x8000, 0x0006,
    0x0A8D, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0A8F, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0A93, 0x0100, 0x0001, 0x8000, 0x0015,
    0x0AAA, 0x0100, 0x0001, 0x8000, 0x0006,
    0x0AB2, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0AB5, 0x0100, 0x0001, 0x8000, 0x0004,
    0x0ABC, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0ABD, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0ABE, 0x0010, 0x0001, 0x0004, 0x0002,
    0x0AC1, 0x0010, 0x0001, 0x0005, 0x0004,
    0x0AC7, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0AC9, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0ACB, 0x0010, 0x0001, 0x0004, 0x0001,
    0x0ACD, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0AD0, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0AE0, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0AE6, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0B01, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0B02, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0B05, 0x0100, 0x0001, 0x8000, 0x0007,
    0x0B0F, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0B13, 0x0100, 0x0001, 0x8000, 0x0015,
    0x0B2A, 0x0100, 0x0001, 0x8000, 0x0006,
    0x0B32, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0B36, 0x0100, 0x0001, 0x8000, 0x0003,
    0x0B3C, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0B3D, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0B3F, 0x0010, 0x0001, 0x0005, 0x0000,
    0x0B40, 0x0010, 0x0001, 0x0004, 0x0000,
    0x0B41, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0B47, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0B4B, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0B4D, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0B56, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0B5C, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0B5F, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0B66, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0B70, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0B82, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0B85, 0x0100, 0x0001, 0x8000, 0x0005,
    0x0B8E, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0B92, 0x0100, 0x0001, 0x8000, 0x0003,
    0x0B99, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0B9C, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0B9E, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0BA3, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0BA8, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0BAE, 0x0100, 0x0001, 0x8000, 0x0007,
    0x0BB7, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0BBE, 0x0010, 0x0001, 0x0004, 0x0001,
    0x0BC0, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0BC6, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0BCA, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0BCD, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0BD7, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0BE7, 0x0004, 0x0001, 0x0000, 0x000B,
    0x0C01, 0x0010, 0x0001, 0x0000, 0x0002,
    0x0C05, 0x0100, 0x0001, 0x8000, 0x0007,
    0x0C0E, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0C12, 0x0100, 0x0001, 0x8000, 0x0016,
    0x0C2A, 0x0100, 0x0001, 0x8000, 0x0009,
    0x0C35, 0x0100, 0x0001, 0x8000, 0x0004,
    0x0C3E, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0C41, 0x0010, 0x0001, 0x0004, 0x0003,
    0x0C46, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0C4A, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0C4D, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0C55, 0x0010, 0x0001, 0x0001, 0x0001,
    0x0C60, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0C66, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0C82, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0C85, 0x0100, 0x0001, 0x8000, 0x0007,
    0x0C8E, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0C92, 0x0100, 0x0001, 0x8000, 0x0016,
    0x0CAA, 0x0100, 0x0001, 0x8000, 0x0009,
    0x0CB5, 0x0100, 0x0001, 0x8000, 0x0004,
    0x0CBE, 0x0010, 0x0001, 0x0004, 0x0000,
    0x0CBF, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0CC1, 0x0010, 0x0001, 0x0004, 0x0003,
    0x0CC6, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0CCA, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0CCD, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0CD5, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0CDE, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0CE0, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0CE6, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0D02, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0D05, 0x0100, 0x0001, 0x8000, 0x0007,
    0x0D0E, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0D12, 0x0100, 0x0001, 0x8000, 0x0016,
    0x0D2A, 0x0100, 0x0001, 0x8000, 0x000F,
    0x0D3E, 0x0010, 0x0001, 0x0004, 0x0002,
    0x0D41, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0D46, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0D4A, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0D4D, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0D57, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0D60, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0D66, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0E01, 0x0100, 0x0001, 0x8000, 0x0022,
    0x0E24, 0x0100, 0x0001, 0x8004, 0x0000,
    0x0E25, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0E26, 0x0100, 0x0001, 0x8004, 0x0000,
    0x0E27, 0x0100, 0x0001, 0x8000, 0x0007,
    0x0E2F, 0x0100, 0x0001, 0x0008, 0x0000,
    0x0E30, 0x0100, 0x0001, 0x8004, 0x0000,
    0x0E31, 0x0100, 0x0001, 0x0005, 0x0000,
    0x0E32, 0x0100, 0x0001, 0x8004, 0x0001,
    0x0E34, 0x0100, 0x0001, 0x0005, 0x0005,
    0x0E3A, 0x0100, 0x0001, 0x0003, 0x0000,
    0x0E3F, 0x0010, 0x0001, 0x0008, 0x0000,
    0x0E40, 0x0100, 0x0001, 0x8004, 0x0005,
    0x0E46, 0x0100, 0x0001, 0x0008, 0x0000,
    0x0E47, 0x0100, 0x0001, 0x0003, 0x0000,
    0x0E48, 0x0100, 0x0001, 0x0001, 0x0003,
    0x0E4C, 0x0100, 0x0001, 0x0003, 0x0002,
    0x0E4F, 0x0010, 0x0001, 0x0008, 0x0000,
    0x0E50, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0E5A, 0x0010, 0x0001, 0x0008, 0x0001,
    0x0E81, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0E84, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0E87, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0E8A, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0E8D, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0E94, 0x0100, 0x0001, 0x8000, 0x0003,
    0x0E99, 0x0100, 0x0001, 0x8000, 0x0006,
    0x0EA1, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0EA5, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0EA7, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0EAA, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0EAD, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0EAF, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0EB0, 0x0010, 0x0001, 0x0004, 0x0000,
    0x0EB1, 0x0010, 0x0001, 0x0005, 0x0000,
    0x0EB2, 0x0010, 0x0001, 0x0004, 0x0001,
    0x0EB4, 0x0010, 0x0001, 0x0005, 0x0005,
    0x0EBB, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0EC0, 0x0010, 0x0001, 0x0005, 0x0004,
    0x0EC6, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0EC8, 0x0010, 0x0001, 0x0001, 0x0005,
    0x0ED0, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0EDC, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0F00, 0x0010, 0x0001, 0x0000, 0x0017,
    0x0F18, 0x0010, 0x0001, 0x0001, 0x0001,
    0x0F1A, 0x0010, 0x0001, 0x0000, 0x0005,
    0x0F20, 0x0004, 0x0001, 0x0000, 0x0013,
    0x0F34, 0x0010, 0x0001, 0x0000, 0x000B,
    0x0F40, 0x0100, 0x0001, 0x8000, 0x0007,
    0x0F49, 0x0100, 0x0001, 0x8000, 0x0020,
    0x0F71, 0x0010, 0x0001, 0x0005, 0x000C,
    0x0F7E, 0x0010, 0x0001, 0x0001, 0x0001,
    0x0F80, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0F82, 0x0010, 0x0001, 0x0001, 0x0009,
    0x0F90, 0x0100, 0x0001, 0x0001, 0x0005,
    0x0F97, 0x0100, 0x0001, 0x0001, 0x0000,
    0x0F99, 0x0100, 0x0001, 0x0001, 0x0014,
    0x0FB1, 0x0100, 0x0001, 0x0001, 0x0006,
    0x0FB9, 0x0100, 0x0001, 0x0001, 0x0000,
    0x10A0, 0x0101, 0x0001, 0x8000, 0x0025,
    0x10D0, 0x0102, 0x0001, 0x8000, 0x0026,
    0x10FB, 0x0010, 0x0001, 0x0000, 0x0000,
    0x1100, 0x0100, 0x0001, 0x8000, 0x0059,
    0x115F, 0x0100, 0x0001, 0x8000, 0x0043,
    0x11A8, 0x0100, 0x0001, 0x8000, 0x0051,
    0x1E00, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E01, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E02, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E03, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E04, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E05, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E06, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E07, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E08, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E09, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E0A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E0B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E0C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E0D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E0E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E0F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E10, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E11, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E12, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E13, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E14, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E15, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E16, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E17, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E18, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E19, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E1A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E1B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E1C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E1D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E1E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E1F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E20, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E21, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E22, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E23, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E24, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E25, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E26, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E27, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E28, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E29, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E2A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E2B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E2C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E2D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E2E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E2F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E30, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E31, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E32, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E33, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E34, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E35, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E36, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E37, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E38, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E39, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E3A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E3B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E3C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E3D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E3E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E3F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E40, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E41, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E42, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E43, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E44, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E45, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E46, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E47, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E48, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E49, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E4A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E4B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E4C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E4D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E4E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E4F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E50, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E51, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E52, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E53, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E54, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E55, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E56, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E57, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E58, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E59, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E5A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E5B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E5C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E5D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E5E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E5F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E60, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E61, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E62, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E63, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E64, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E65, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E66, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E67, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E68, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E69, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E6A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E6B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E6C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E6D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E6E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E6F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E70, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E71, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E72, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E73, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E74, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E75, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E76, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E77, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E78, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E79, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E7A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E7B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E7C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E7D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E7E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E7F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E80, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E81, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E82, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E83, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E84, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E85, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E86, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E87, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E88, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E89, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E8A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E8B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E8C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E8D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E8E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E8F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E90, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E91, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E92, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E93, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E94, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E95, 0x0102, 0x0001, 0x8003, 0x0006,
    0x1EA0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EA1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EA2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EA3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EA4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EA5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EA6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EA7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EA8, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EA9, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EAA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EAB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EAC, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EAD, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EAE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EAF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EB0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EB1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EB2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EB3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EB4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EB5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EB6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EB7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EB8, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EB9, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EBA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EBB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EBC, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EBD, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EBE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EBF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EC0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EC1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EC2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EC3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EC4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EC5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EC6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EC7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EC8, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EC9, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1ECA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1ECB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1ECC, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1ECD, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1ECE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1ECF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1ED0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1ED1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1ED2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1ED3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1ED4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1ED5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1ED6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1ED7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1ED8, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1ED9, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EDA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EDB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EDC, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EDD, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EDE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EDF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EE0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EE1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EE2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EE3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EE4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EE5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EE6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EE7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EE8, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EE9, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EEA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EEB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EEC, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EED, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EEE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EEF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EF0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EF1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EF2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EF3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EF4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EF5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EF6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EF7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EF8, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EF9, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1F00, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1F08, 0x0101, 0x0001, 0x8003, 0x0007,
    0x1F10, 0x0102, 0x0001, 0x8003, 0x0005,
    0x1F18, 0x0101, 0x0001, 0x8003, 0x0005,
    0x1F20, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1F28, 0x0101, 0x0001, 0x8003, 0x0007,
    0x1F30, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1F38, 0x0101, 0x0001, 0x8003, 0x0007,
    0x1F40, 0x0102, 0x0001, 0x8003, 0x0005,
    0x1F48, 0x0101, 0x0001, 0x8003, 0x0005,
    0x1F50, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1F59, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1F5B, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1F5D, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1F5F, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1F60, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1F68, 0x0101, 0x0001, 0x8003, 0x0007,
    0x1F70, 0x0102, 0x0001, 0x8003, 0x000D,
    0x1F80, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1F88, 0x0101, 0x0001, 0x8003, 0x0007,
    0x1F90, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1F98, 0x0101, 0x0001, 0x8003, 0x0007,
    0x1FA0, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1FA8, 0x0101, 0x0001, 0x8003, 0x0007,
    0x1FB0, 0x0102, 0x0001, 0x8003, 0x0004,
    0x1FB6, 0x0102, 0x0001, 0x8003, 0x0001,
    0x1FB8, 0x0101, 0x0001, 0x8003, 0x0004,
    0x1FBD, 0x0010, 0x0001, 0x0408, 0x0004,
    0x1FC2, 0x0102, 0x0001, 0x8003, 0x0002,
    0x1FC6, 0x0102, 0x0001, 0x8003, 0x0001,
    0x1FC8, 0x0101, 0x0001, 0x8003, 0x0004,
    0x1FCD, 0x0010, 0x0001, 0x0408, 0x0002,
    0x1FD0, 0x0102, 0x0001, 0x8003, 0x0003,
    0x1FD6, 0x0102, 0x0001, 0x8003, 0x0001,
    0x1FD8, 0x0101, 0x0001, 0x8003, 0x0003,
    0x1FDD, 0x0010, 0x0001, 0x0408, 0x0002,
    0x1FE0, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1FE8, 0x0101, 0x0001, 0x8003, 0x0004,
    0x1FED, 0x0010, 0x0001, 0x0408, 0x0002,
    0x1FF2, 0x0102, 0x0001, 0x8003, 0x0002,
    0x1FF6, 0x0102, 0x0001, 0x8003, 0x0001,
    0x1FF8, 0x0101, 0x0001, 0x8003, 0x0004,
    0x1FFD, 0x0010, 0x0001, 0x0408, 0x0001,
    0x2000, 0x0018, 0x000A, 0x0008, 0x0006,
    0x2007, 0x0018, 0x0004, 0x0008, 0x0000,
    0x2008, 0x0018, 0x000A, 0x0008, 0x0003,
    0x200C, 0x0030, 0x000B, 0x0008, 0x0000,
    0x200D, 0x0030, 0x000B, 0x0000, 0x0000,
    0x200E, 0x0030, 0x0001, 0x0000, 0x0000,
    0x200F, 0x0030, 0x0002, 0x0000, 0x0000,
    0x2010, 0x0010, 0x000B, 0x0408, 0x0000,
    0x2011, 0x0010, 0x000B, 0x0400, 0x0004,
    0x2016, 0x0010, 0x000B, 0x0008, 0x0001,
    0x2018, 0x0010, 0x000B, 0x0088, 0x0001,
    0x201A, 0x0010, 0x000B, 0x0008, 0x0001,
    0x201C, 0x0010, 0x000B, 0x0088, 0x0001,
    0x201E, 0x0010, 0x000B, 0x0008, 0x0008,
    0x2027, 0x0010, 0x000B, 0x0000, 0x0000,
    0x2028, 0x0030, 0x0008, 0x0008, 0x0001,
    0x202A, 0x0030, 0x000B, 0x0000, 0x0004,
    0x2030, 0x0010, 0x0005, 0x0008, 0x0001,
    0x2032, 0x0010, 0x0005, 0x0408, 0x0001,
    0x2034, 0x0010, 0x000B, 0x0408, 0x0000,
    0x2035, 0x0010, 0x000B, 0x0008, 0x0002,
    0x2038, 0x0010, 0x000B, 0x0408, 0x0000,
    0x2039, 0x0010, 0x000B, 0x0008, 0x0009,
    0x2043, 0x0010, 0x000B, 0x0400, 0x0000,
    0x2044, 0x0010, 0x000B, 0x0408, 0x0000,
    0x2045, 0x0010, 0x000B, 0x0008, 0x0001,
    0x206A, 0x0030, 0x000B, 0x0000, 0x0005,
    0x2070, 0x0004, 0x0003, 0x0000, 0x0000,
    0x2074, 0x0004, 0x0003, 0x0000, 0x0005,
    0x207A, 0x0010, 0x0005, 0x0008, 0x0000,
    0x207B, 0x0010, 0x0005, 0x0400, 0x0000,
    0x207C, 0x0010, 0x000B, 0x0408, 0x0000,
    0x207D, 0x0010, 0x000B, 0x0008, 0x0001,
    0x207F, 0x0010, 0x000B, 0x0400, 0x0000,
    0x2080, 0x0004, 0x0003, 0x0000, 0x0009,
    0x208A, 0x0010, 0x0005, 0x0008, 0x0000,
    0x208B, 0x0010, 0x0005, 0x0400, 0x0000,
    0x208C, 0x0010, 0x000B, 0x0408, 0x0000,
    0x208D, 0x0010, 0x000B, 0x0008, 0x0001,
    0x20A0, 0x0010, 0x0005, 0x0008, 0x0008,
    0x20A9, 0x0010, 0x0005, 0x0048, 0x0000,
    0x20AA, 0x0010, 0x0005, 0x0008, 0x0002,
    0x20D0, 0x0010, 0x0001, 0x0009, 0x0011,
    0x2100, 0x0010, 0x000B, 0x0000, 0x0016,
    0x2117, 0x0010, 0x000B, 0x0008, 0x0000,
    0x2118, 0x0010, 0x000B, 0x0000, 0x0020,
    0x2153, 0x0010, 0x000B, 0x0000, 0x000C,
    0x2160, 0x0010, 0x0001, 0x0000, 0x0022,
    0x2190, 0x0010, 0x000B, 0x0008, 0x005A,
    0x2200, 0x0010, 0x000B, 0x0008, 0x0011,
    0x2212, 0x0010, 0x0005, 0x0408, 0x0000,
    0x2213, 0x0010, 0x0005, 0x0008, 0x0000,
    0x2214, 0x0010, 0x000B, 0x0008, 0x0000,
    0x2215, 0x0010, 0x000B, 0x0408, 0x0001,
    0x2217, 0x0010, 0x000B, 0x0008, 0x0006,
    0x221E, 0x0010, 0x000B, 0x0000, 0x0000,
    0x221F, 0x0010, 0x000B, 0x0008, 0x00D2,
    0x2300, 0x0010, 0x000B, 0x0008, 0x0000,
    0x2302, 0x0010, 0x000B, 0x0008, 0x0078,
    0x2400, 0x0010, 0x000B, 0x0008, 0x0024,
    0x2440, 0x0010, 0x000B, 0x0008, 0x000A,
    0x2460, 0x0010, 0x000B, 0x0000, 0x003B,
    0x249C, 0x0112, 0x000B, 0x8000, 0x0019,
    0x24B6, 0x0111, 0x000B, 0x8000, 0x0019,
    0x24D0, 0x0112, 0x000B, 0x8000, 0x0019,
    0x24EA, 0x0010, 0x000B, 0x0000, 0x0000,
    0x2500, 0x0010, 0x000B, 0x0408, 0x0000,
    0x2501, 0x0010, 0x000B, 0x0008, 0x0002,
    0x2504, 0x0010, 0x000B, 0x0408, 0x0001,
    0x2506, 0x0010, 0x000B, 0x0008, 0x0001,
    0x2508, 0x0010, 0x000B, 0x0408, 0x0001,
    0x250A, 0x0010, 0x000B, 0x0008, 0x0041,
    0x254C, 0x0010, 0x000B, 0x0408, 0x0001,
    0x254E, 0x0010, 0x000B, 0x0008, 0x0047,
    0x25A0, 0x0010, 0x000B, 0x0008, 0x004E,
    0x25EF, 0x0010, 0x000B, 0x0000, 0x0000,
    0x2600, 0x0010, 0x000B, 0x0008, 0x0013,
    0x261A, 0x0010, 0x000B, 0x0008, 0x0055,
    0x2701, 0x0010, 0x000B, 0x0008, 0x0003,
    0x2706, 0x0010, 0x000B, 0x0008, 0x0003,
    0x270C, 0x0010, 0x000B, 0x0008, 0x001B,
    0x2729, 0x0010, 0x000B, 0x0008, 0x0022,
    0x274D, 0x0010, 0x000B, 0x0008, 0x0000,
    0x274F, 0x0010, 0x000B, 0x0008, 0x0003,
    0x2756, 0x0010, 0x000B, 0x0008, 0x0000,
    0x2758, 0x0010, 0x000B, 0x0008, 0x0006,
    0x2761, 0x0010, 0x000B, 0x0008, 0x0006,
    0x2776, 0x0010, 0x000B, 0x0000, 0x001D,
    0x2794, 0x0010, 0x000B, 0x0008, 0x0000,
    0x2798, 0x0010, 0x000B, 0x0008, 0x0017,
    0x27B1, 0x0010, 0x000B, 0x0008, 0x000D,
    0x3000, 0x0048, 0x000A, 0x0088, 0x0000,
    0x3001, 0x0010, 0x000B, 0x0088, 0x0001,
    0x3003, 0x0010, 0x000B, 0x0400, 0x0000,
    0x3004, 0x0010, 0x0001, 0x0000, 0x0000,
    0x3005, 0x0110, 0x000B, 0x8101, 0x0000,
    0x3006, 0x0010, 0x000B, 0x0008, 0x0000,
    0x3007, 0x0110, 0x000B, 0x0008, 0x0000,
    0x3008, 0x0010, 0x000B, 0x0008, 0x0003,
    0x300C, 0x0010, 0x000B, 0x0088, 0x0001,
    0x300E, 0x0010, 0x000B, 0x0008, 0x000D,
    0x301C, 0x0010, 0x000B, 0x0400, 0x0000,
    0x301D, 0x0010, 0x000B, 0x0008, 0x0003,
    0x3021, 0x0010, 0x000B, 0x0000, 0x0008,
    0x302A, 0x0010, 0x000B, 0x0001, 0x0005,
    0x3030, 0x0010, 0x000B, 0x0400, 0x0000,
    0x3031, 0x0010, 0x000B, 0x0430, 0x0000,
    0x3032, 0x0010, 0x000B, 0x0433, 0x0000,
    0x3033, 0x0010, 0x000B, 0x0430, 0x0000,
    0x3034, 0x0010, 0x000B, 0x0433, 0x0000,
    0x3035, 0x0010, 0x000B, 0x0430, 0x0000,
    0x3036, 0x0010, 0x000B, 0x0008, 0x0001,
    0x303F, 0x0010, 0x0001, 0x0008, 0x0000,
    0x3041, 0x0100, 0x0001, 0x8020, 0x000A,
    0x304C, 0x0100, 0x0001, 0x8023, 0x0000,
    0x304D, 0x0100, 0x0001, 0x8020, 0x0000,
    0x304E, 0x0100, 0x0001, 0x8023, 0x0000,
    0x304F, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3050, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3051, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3052, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3053, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3054, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3055, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3056, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3057, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3058, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3059, 0x0100, 0x0001, 0x8020, 0x0000,
    0x305A, 0x0100, 0x0001, 0x8023, 0x0000,
    0x305B, 0x0100, 0x0001, 0x8020, 0x0000,
    0x305C, 0x0100, 0x0001, 0x8023, 0x0000,
    0x305D, 0x0100, 0x0001, 0x8020, 0x0000,
    0x305E, 0x0100, 0x0001, 0x8023, 0x0000,
    0x305F, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3060, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3061, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3062, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3063, 0x0100, 0x0001, 0x8020, 0x0001,
    0x3065, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3066, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3067, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3068, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3069, 0x0100, 0x0001, 0x8023, 0x0000,
    0x306A, 0x0100, 0x0001, 0x8020, 0x0005,
    0x3070, 0x0100, 0x0001, 0x8023, 0x0001,
    0x3072, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3073, 0x0100, 0x0001, 0x8023, 0x0001,
    0x3075, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3076, 0x0100, 0x0001, 0x8023, 0x0001,
    0x3078, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3079, 0x0100, 0x0001, 0x8023, 0x0001,
    0x307B, 0x0100, 0x0001, 0x8020, 0x0000,
    0x307C, 0x0100, 0x0001, 0x8023, 0x0001,
    0x307E, 0x0100, 0x0001, 0x8020, 0x0016,
    0x3099, 0x0010, 0x0001, 0x0033, 0x0001,
    0x309B, 0x0110, 0x0001, 0x84B3, 0x0001,
    0x309D, 0x0110, 0x0001, 0x8421, 0x0000,
    0x309E, 0x0110, 0x0001, 0x8423, 0x0000,
    0x30A1, 0x0100, 0x0001, 0x8090, 0x000A,
    0x30AC, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30AD, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30AE, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30AF, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30B0, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30B1, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30B2, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30B3, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30B4, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30B5, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30B6, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30B7, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30B8, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30B9, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30BA, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30BB, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30BC, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30BD, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30BE, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30BF, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30C0, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30C1, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30C2, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30C3, 0x0100, 0x0001, 0x8090, 0x0001,
    0x30C5, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30C6, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30C7, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30C8, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30C9, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30CA, 0x0100, 0x0001, 0x8090, 0x0005,
    0x30D0, 0x0100, 0x0001, 0x8013, 0x0001,
    0x30D2, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30D3, 0x0100, 0x0001, 0x8013, 0x0001,
    0x30D5, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30D6, 0x0100, 0x0001, 0x8013, 0x0001,
    0x30D8, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30D9, 0x0100, 0x0001, 0x8013, 0x0001,
    0x30DB, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30DC, 0x0100, 0x0001, 0x8013, 0x0001,
    0x30DE, 0x0100, 0x0001, 0x8090, 0x000F,
    0x30EE, 0x0100, 0x0001, 0x8010, 0x0000,
    0x30EF, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30F0, 0x0100, 0x0001, 0x8010, 0x0001,
    0x30F2, 0x0100, 0x0001, 0x8090, 0x0001,
    0x30F4, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30F5, 0x0100, 0x0001, 0x8010, 0x0001,
    0x30F7, 0x0100, 0x0001, 0x8013, 0x0003,
    0x30FB, 0x0010, 0x0001, 0x0098, 0x0000,
    0x30FC, 0x0110, 0x0001, 0x8031, 0x0000,
    0x30FD, 0x0110, 0x0001, 0x8411, 0x0000,
    0x30FE, 0x0110, 0x0001, 0x8413, 0x0000,
    0x3105, 0x0100, 0x0001, 0x8000, 0x0027,
    0x3131, 0x0100, 0x0001, 0x8080, 0x0033,
    0x3165, 0x0100, 0x0001, 0x8000, 0x0029,
    0x3190, 0x0010, 0x0001, 0x0000, 0x000F,
    0x3200, 0x0010, 0x0001, 0x0000, 0x001C,
    0x3220, 0x0010, 0x0001, 0x0000, 0x0023,
    0x3260, 0x0010, 0x0001, 0x0000, 0x001B,
    0x327F, 0x0010, 0x0001, 0x0008, 0x0000,
    0x3280, 0x0010, 0x0001, 0x0000, 0x0030,
    0x32C0, 0x0010, 0x0001, 0x0008, 0x000B,
    0x32D0, 0x0010, 0x0001, 0x0000, 0x002E,
    0x3300, 0x0010, 0x0001, 0x0000, 0x0057,
    0x3358, 0x0010, 0x0001, 0x0008, 0x0018,
    0x3371, 0x0010, 0x0001, 0x0000, 0x0005,
    0x337B, 0x0010, 0x0001, 0x0000, 0x0062,
    0x33E0, 0x0010, 0x0001, 0x0008, 0x001E,
    0x4E00, 0x0100, 0x0001, 0x8100, 0x51A5,
    0xAC00, 0x0100, 0x0001, 0x8000, 0x2BA3,
    0xF900, 0x0100, 0x0001, 0x8100, 0x012D,
    0xFB00, 0x0102, 0x0001, 0x8000, 0x0006,
    0xFB13, 0x0102, 0x0001, 0x8000, 0x0004,
    0xFB1E, 0x0010, 0x0002, 0x0001, 0x0000,
    0xFB1F, 0x0100, 0x0002, 0x8000, 0x0017,
    0xFB38, 0x0100, 0x0002, 0x8000, 0x0004,
    0xFB3E, 0x0100, 0x0002, 0x8000, 0x0000,
    0xFB40, 0x0100, 0x0002, 0x8000, 0x0001,
    0xFB43, 0x0100, 0x0002, 0x8000, 0x0001,
    0xFB46, 0x0100, 0x0002, 0x8000, 0x006B,
    0xFBD3, 0x0100, 0x0002, 0x8000, 0x016A,
    0xFD3E, 0x0010, 0x000B, 0x0008, 0x0001,
    0xFD50, 0x0100, 0x0002, 0x8000, 0x003F,
    0xFD92, 0x0100, 0x0002, 0x8000, 0x0035,
    0xFDF0, 0x0100, 0x0002, 0x8000, 0x000B,
    0xFE20, 0x0010, 0x0001, 0x0003, 0x0003,
    0xFE30, 0x0010, 0x000B, 0x0008, 0x0000,
    0xFE31, 0x0010, 0x000B, 0x0400, 0x0001,
    0xFE33, 0x0010, 0x000B, 0x0008, 0x0001,
    0xFE35, 0x0010, 0x0000, 0x0008, 0x0001,
    0xFE37, 0x0010, 0x000B, 0x0008, 0x000D,
    0xFE49, 0x0010, 0x000B, 0x0008, 0x0006,
    0xFE50, 0x0010, 0x0007, 0x0008, 0x0000,
    0xFE51, 0x0010, 0x000B, 0x0008, 0x0000,
    0xFE52, 0x0010, 0x0004, 0x0008, 0x0000,
    0xFE54, 0x0010, 0x000B, 0x0008, 0x0000,
    0xFE55, 0x0010, 0x0007, 0x0008, 0x0000,
    0xFE56, 0x0010, 0x000B, 0x0008, 0x0001,
    0xFE58, 0x0010, 0x000B, 0x0400, 0x0000,
    0xFE59, 0x0010, 0x000B, 0x0008, 0x0008,
    0xFE62, 0x0010, 0x0005, 0x0008, 0x0000,
    0xFE63, 0x0010, 0x0005, 0x0400, 0x0000,
    0xFE64, 0x0010, 0x000B, 0x0008, 0x0001,
    0xFE66, 0x0010, 0x000B, 0x0408, 0x0000,
    0xFE68, 0x0010, 0x000B, 0x0408, 0x0000,
    0xFE69, 0x0010, 0x0005, 0x0408, 0x0000,
    0xFE6A, 0x0010, 0x0005, 0x0008, 0x0000,
    0xFE6B, 0x0010, 0x000B, 0x0408, 0x0000,
    0xFE70, 0x0010, 0x0002, 0x0000, 0x0002,
    0xFE74, 0x0010, 0x0002, 0x0000, 0x0000,
    0xFE76, 0x0010, 0x0002, 0x0000, 0x0009,
    0xFE80, 0x0110, 0x0002, 0x8000, 0x007C,
    0xFEFF, 0x0048, 0x0000, 0x0000, 0x0000,
    0xFF01, 0x0010, 0x000B, 0x0088, 0x0002,
    0xFF04, 0x0010, 0x0005, 0x0488, 0x0000,
    0xFF05, 0x0010, 0x0005, 0x0088, 0x0000,
    0xFF06, 0x0010, 0x000B, 0x0088, 0x0000,
    0xFF07, 0x0010, 0x000B, 0x0480, 0x0000,
    0xFF08, 0x0010, 0x000B, 0x0088, 0x0002,
    0xFF0B, 0x0010, 0x0005, 0x0088, 0x0000,
    0xFF0C, 0x0010, 0x0007, 0x0088, 0x0000,
    0xFF0D, 0x0010, 0x0005, 0x0480, 0x0000,
    0xFF0E, 0x0010, 0x0004, 0x0088, 0x0000,
    0xFF0F, 0x0010, 0x0004, 0x0488, 0x0000,
    0xFF10, 0x0084, 0x0003, 0x0080, 0x0009,
    0xFF1A, 0x0010, 0x0007, 0x0088, 0x0000,
    0xFF1B, 0x0010, 0x000B, 0x0088, 0x0001,
    0xFF1D, 0x0010, 0x000B, 0x0488, 0x0000,
    0xFF1E, 0x0010, 0x000B, 0x0088, 0x0001,
    0xFF20, 0x0010, 0x000B, 0x0488, 0x0000,
    0xFF21, 0x0181, 0x0001, 0x8080, 0x0005,
    0xFF27, 0x0101, 0x0001, 0x8080, 0x0013,
    0xFF3B, 0x0010, 0x000B, 0x0088, 0x0000,
    0xFF3C, 0x0010, 0x000B, 0x0488, 0x0000,
    0xFF3D, 0x0010, 0x000B, 0x0088, 0x0000,
    0xFF3E, 0x0010, 0x000B, 0x0488, 0x0000,
    0xFF3F, 0x0010, 0x000B, 0x0088, 0x0000,
    0xFF40, 0x0010, 0x000B, 0x0488, 0x0000,
    0xFF41, 0x0182, 0x0001, 0x8080, 0x0005,
    0xFF47, 0x0102, 0x0001, 0x8080, 0x0013,
    0xFF5B, 0x0010, 0x000B, 0x0088, 0x0002,
    0xFF5E, 0x0010, 0x000B, 0x0488, 0x0000,
    0xFF61, 0x0010, 0x000B, 0x0048, 0x0003,
    0xFF65, 0x0010, 0x0001, 0x0048, 0x0000,
    0xFF66, 0x0100, 0x0001, 0x8050, 0x0009,
    0xFF70, 0x0110, 0x0001, 0x8073, 0x0000,
    0xFF71, 0x0100, 0x0001, 0x8050, 0x002C,
    0xFF9E, 0x0110, 0x0001, 0x8053, 0x0001,
    0xFFA0, 0x0010, 0x0001, 0x0040, 0x0000,
    0xFFA1, 0x0100, 0x0001, 0x8040, 0x001D,
    0xFFC2, 0x0100, 0x0001, 0x8040, 0x0005,
    0xFFCA, 0x0100, 0x0001, 0x8040, 0x0005,
    0xFFD2, 0x0100, 0x0001, 0x8040, 0x0005,
    0xFFDA, 0x0100, 0x0001, 0x8040, 0x0002,
    0xFFE0, 0x0010, 0x0005, 0x0088, 0x0001,
    0xFFE2, 0x0010, 0x000B, 0x0088, 0x0002,
    0xFFE5, 0x0010, 0x0005, 0x0088, 0x0001,
    0xFFE8, 0x0010, 0x000B, 0x0040, 0x0006,
    0xFFFD, 0x0100, 0x000B, 0x8000, 0x0000
};

/*++

 Function Description:
    
    Get CTYPE for the character.

 Arguments:

    IN wcSrcChar    - Source character
    IN wType        - CTYPE to get (must be 1,2,3)

 Return Value:

    CTYPE value

 History:

    06/03/2002 hioh     Created

--*/

WORD GetCtype(WCHAR wcSrcChar, WORD wType)
{
    WORD bgn = 0;
    WORD end = MAXINDEX;
    WORD med;
    WORD idx = 0xFFFF;

    // Look for index in the table
    while (wcSrcChar > g_ctype[bgn][0] && g_ctype[end][0] > wcSrcChar) {
        med = (bgn + end) / 2;
        if (bgn == med) {
            idx = bgn;
            break;
        }

        if (wcSrcChar < g_ctype[med][0]) {
            end = med;
        }
        else {
            bgn = med;
        }
    }

    // Check the border index
    if (idx == 0xFFFF) {
        if (wcSrcChar == g_ctype[bgn][0]) {
            idx = bgn;
        }
        else if (wcSrcChar == g_ctype[end][0]) {
            idx = end;
        }
    }

    // Return CTYPE if the character is really in the table
    if (idx != 0xFFFF && g_ctype[idx][0] <= wcSrcChar && wcSrcChar <= g_ctype[idx][0]+g_ctype[idx][4]) {
        return (g_ctype[idx][wType]);
    }

    // Not found in the table
    return (0);
}

/*++

 GetStringTypeW : Internal

--*/

BOOL
myGetStringTypeW(
    DWORD dwInfoType,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType
    )
{
    int Ctr;                      // loop counter

    //
    //  Invalid Parameter Check:
    //    - lpSrcStr NULL
    //    - cchSrc is 0
    //    - lpCharType NULL
    //    - same buffer - src and destination
    //    - (flags will be checked in switch statement below)
    //
    if ((lpSrcStr == NULL) || (cchSrc == 0) || (lpCharType == NULL) || 
        (lpSrcStr == lpCharType)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  If cchSrc is -1, then the source string is null terminated and we
    //  need to get the length of the source string.  Add one to the
    //  length to include the null termination.
    //  (This will always be at least 1.)
    //
    if (cchSrc <= -1) {
        cchSrc = lstrlenW(lpSrcStr) + 1;
    }

    //
    //  Return the appropriate information in the lpCharType parameter
    //  based on the dwInfoType parameter.
    //
    switch (dwInfoType) {
        case CT_CTYPE1:
            //  Return the ctype 1 information for the string.
            for (Ctr = 0; Ctr < cchSrc; Ctr++) {
                lpCharType[Ctr] = GetCtype(lpSrcStr[Ctr], 1);
            }
            break;

        case CT_CTYPE2:
            //  Return the ctype 2 information.
            for (Ctr = 0; Ctr < cchSrc; Ctr++) {
                lpCharType[Ctr] = GetCtype(lpSrcStr[Ctr], 2);
            }
            break;

        case CT_CTYPE3:
            //  Return the ctype 3 information.
            for (Ctr = 0; Ctr < cchSrc; Ctr++) {
                lpCharType[Ctr] = GetCtype(lpSrcStr[Ctr], 3);
            }
            break;

        default :
            //  Invalid flag parameter, so return failure.
            SetLastError(ERROR_INVALID_FLAGS);
            return FALSE;
    }

    //  Return success.
    return TRUE;
}

/*++

 GetStringTypeW

--*/

BOOL
APIHOOK(GetStringTypeW)(
    DWORD   dwInfoType,
    LPCWSTR lpSrcStr,
    int     cchSrc,
    LPWORD  lpCharType)
{
    return myGetStringTypeW(dwInfoType, lpSrcStr, cchSrc, lpCharType);
}

/*++

 GetStringTypeExW

--*/

BOOL
APIHOOK(GetStringTypeExW)(
    LCID Locale,
    DWORD dwInfoType,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType
    )
{
    //  Invalid Parameter Check: Validate LCID
    if (Locale != LOCALE_SYSTEM_DEFAULT && Locale != LOCALE_USER_DEFAULT &&
        Locale != LOCALE_NEUTRAL && Locale != LOCALE_INVARIANT) {

        if (SUBLANGID(LANGIDFROMLCID(Locale)) == SUBLANG_NEUTRAL) {
            //
            //  Re-form the locale id using the primary language and the
            //  default sublanguage.
            //
            Locale = MAKELCID(MAKELANGID(PRIMARYLANGID(LANGIDFROMLCID(Locale)),
                SUBLANG_DEFAULT), SORTIDFROMLCID(Locale));
        }

        if (!IsValidLocale(Locale, LCID_SUPPORTED)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }

    //  Return the result of GetStringTypeW.
    return myGetStringTypeW(dwInfoType, lpSrcStr, cchSrc, lpCharType);
}

/*++

 GetStringTypeA : Internal

--*/

BOOL
myGetStringTypeA(
    LCID Locale,
    DWORD dwInfoType,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType
    )
{
    WCHAR wcCpStr[7];       // 6 is max for LOCALE_IDEFAULTANSICODEPAGE
    long cp = 0;            // Ansi code page
    int UnicodeLength;      // length of Unicode string
    BOOL Result;            // result
    int Ctr;                // loop counter

    // Get code page for the locale
    if (GetLocaleInfoW(Locale, LOCALE_IDEFAULTANSICODEPAGE, wcCpStr, 
        sizeof(wcCpStr) / sizeof(wcCpStr[0]))) {
        cp = wcstol(wcCpStr, NULL, 10);
    }

    //
    //  Invalid Parameter Check:
    //    - Validate LCID
    //    - valid code page
    //    - same buffer - src and destination
    //
    if ((cp == 0) || (lpSrcStr == (LPSTR)lpCharType)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //  Get the source length if not specified
    if (cchSrc == -1) {
        cchSrc = lstrlenA(lpSrcStr);
        cchSrc++;
    }

    //  Allocate Unicode string
    WCHAR *pUnicode = new WCHAR[cchSrc];

    //
    //  Convert Ansi string to Unicode.
    //  Invalid character is handled as 0xFFFF in original API
    //
    UnicodeLength = 0;
    for (Ctr = 0; Ctr < cchSrc; Ctr++) {
        int lenWchar;

        // Check if DBCS lead byte
        if (IsDBCSLeadByteEx(cp, lpSrcStr[Ctr])) {
            // Check if 2 byte exist
            if ((Ctr+1) < cchSrc) {
                lenWchar = MultiByteToWideChar(cp, MB_ERR_INVALID_CHARS, 
                    &lpSrcStr[Ctr], 2, &pUnicode[UnicodeLength], 
                    cchSrc - UnicodeLength);

                // Check if invalid
                if (0 == lenWchar) {
                    pUnicode[UnicodeLength] = 0xFFFF;
                }
                // DBCS counter increment
                Ctr++;
            } else {
                // 1 byte DBCS lead is invalid
                pUnicode[UnicodeLength] = 0xFFFF;
            }
        } else {
            // Single byte handling
            lenWchar = MultiByteToWideChar(cp, MB_ERR_INVALID_CHARS, 
                &lpSrcStr[Ctr], 1, &pUnicode[UnicodeLength], 
                cchSrc - UnicodeLength);

            // Check if invalid
            if (0 == lenWchar) {
                pUnicode[UnicodeLength] = 0xFFFF;
            }
        }
        UnicodeLength++;
    }

    //  Call the W version of the API.
    Result = myGetStringTypeW(dwInfoType, pUnicode, UnicodeLength, lpCharType);

    //  Free the allocated source buffer (if one was allocated).
    delete [] pUnicode;

    //  Return the result of the call to GetStringTypeW.
    return (Result);
}

/*++

 GetStringTypeA

--*/

BOOL
APIHOOK(GetStringTypeA)(
    LCID Locale,
    DWORD dwInfoType,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType
    )
{
    return myGetStringTypeA(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
}

/*++

 GetStringTypeExA

--*/

BOOL
APIHOOK(GetStringTypeExA)(
    LCID Locale,
    DWORD dwInfoType,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType
    )
{
    return myGetStringTypeA(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GetStringTypeW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetStringTypeExW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetStringTypeA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetStringTypeExA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\failcloseprofileusermapping.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    FailCloseProfileUserMapping.cpp

 Abstract:

    Fifa 2000 makes a bad assumption that CloseProfileUserMapping always 
    returns 0

    Fix is of course trivial.
   
 Notes:

    This is an app specific shim.

 History:

    04/07/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(FailCloseProfileUserMapping)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CloseProfileUserMapping) 
APIHOOK_ENUM_END

/*++

 Stub always returns 0.

--*/

BOOL
APIHOOK(CloseProfileUserMapping)(VOID)
{
    ORIGINAL_API(CloseProfileUserMapping)();
    return FALSE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CloseProfileUserMapping)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\failgetstdhandle.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    FailGetStdHandle.cpp

 Abstract:

    This shim returns INVALID_HANDLE_VALUE when GetStdHandle is called.

 Notes:

    This is an app specific shim.

 History:

    12/12/1999 cornel   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(FailGetStdHandle)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetStdHandle) 
APIHOOK_ENUM_END

/*++

 Return INVALID_HANDLE_VALUE when GetStdHandle is called.

--*/

HANDLE 
APIHOOK(GetStdHandle)(DWORD nStdHandle)
{
    return INVALID_HANDLE_VALUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetStdHandle)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\failobsoleteshellapis.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    FailObsoleteShellAPIs.cpp

 Abstract:

    Some applications call private shell32 APIs that have been removed since win2k.
    To make matters worse, these old ordinals are now used by other shell APIs. To
    prevent resulting crashes, we now hand out stubbed out functions that fail when
    you call GetProcAddress with these obsolete ordinals.

 Notes:

    This is a general purpose shim.

 History:

    05/31/2001 stevepro    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(FailObsoleteShellAPIs)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetProcAddress)
APIHOOK_ENUM_END


HMODULE g_hShell32 = NULL;



/*++

    Stubbed out versions of the obsolete APIs.  They all return failure codes.

--*/


STDAPI_(BOOL)
FileMenu_HandleNotify(HMENU hmenu, LPCITEMIDLIST * ppidl, LONG lEvent)
{
    return FALSE;
}

STDAPI_(UINT)
FileMenu_DeleteAllItems(HMENU hmenu)
{
    return 0;
}

STDAPI_(LRESULT)
FileMenu_DrawItem(HWND hwnd, DRAWITEMSTRUCT *pdi)
{
    return FALSE;
}

STDAPI_(HMENU)
FileMenu_FindSubMenuByPidl(HMENU hmenu, LPITEMIDLIST pidlFS)
{
    return NULL;
}

STDAPI_(BOOL)
FileMenu_GetLastSelectedItemPidls(
    IN  HMENU          hmenu,
    OUT LPITEMIDLIST * ppidlFolder,         OPTIONAL
    OUT LPITEMIDLIST * ppidlItem)           OPTIONAL
{
    return FALSE;
}

STDAPI_(LRESULT)
FileMenu_HandleMenuChar(HMENU hmenu, TCHAR ch)
{
    return E_FAIL;
}

STDAPI_(BOOL)
FileMenu_InitMenuPopup(
    IN HMENU hmenu)
{
    return FALSE;
}

STDAPI
FileMenu_ComposeA(
    IN HMENU        hmenu,
    IN UINT         nMethod,
    IN struct FMCOMPOSEA * pfmc)
{
    return E_FAIL;
}

STDAPI_(void)
FileMenu_Invalidate(HMENU hmenu)
{
}

STDAPI_(LRESULT)
FileMenu_MeasureItem(HWND hwnd, MEASUREITEMSTRUCT *lpmi)
{
    return FALSE;
}

STDAPI
FileMenu_ComposeW(
    IN HMENU        hmenu,
    IN UINT         nMethod,
    IN struct FMCOMPOSEW * pfmc)
{
    return E_FAIL;
}

STDAPI_(HMENU)
FileMenu_Create(COLORREF clr, int cxBmpGap, HBITMAP hbmp, int cySel, DWORD fmf)
{
    return NULL;
}

STDAPI_(BOOL)
FileMenu_AppendItem(
    HMENU hmenu,
    LPTSTR psz,
    UINT id,
    int iImage,
    HMENU hmenuSub,
    UINT cyItem)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_TrackPopupMenuEx(HMENU hmenu, UINT Flags, int x, int y,
    HWND hwndOwner, LPTPMPARAMS lpTpm)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_DeleteItemByCmd(HMENU hmenu, UINT id)
{
    return FALSE;
}

STDAPI_(void)
FileMenu_Destroy(HMENU hmenu)
{
}

STDAPI_(void)
FileMenu_AbortInitMenu(void)
{
}

STDAPI_(UINT)
FileMenu_AppendFilesForPidl(
    HMENU hmenu,
    LPITEMIDLIST pidl,
    BOOL bInsertSeparator)
{
    return 0;
}

STDAPI_(BOOL)
FileMenu_DeleteItemByIndex(HMENU hmenu, UINT iItem)
{
    return FALSE;
}


STDAPI_(BOOL)
FileMenu_DeleteMenuItemByFirstID(HMENU hmenu, UINT id)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_DeleteSeparator(HMENU hmenu)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_EnableItemByCmd(HMENU hmenu, UINT id, BOOL fEnable)
{
    return FALSE;
}

STDAPI_(DWORD)
FileMenu_GetItemExtent(HMENU hmenu, UINT iItem)
{
    return 0;
}

STDAPI_(BOOL)
FileMenu_ProcessCommand(
    IN HWND   hwnd,
    IN HMENU  hmenuBar,
    IN UINT   idMenu,
    IN HMENU  hmenu,
    IN UINT   idCmd)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_IsFileMenu(HMENU hmenu)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_InsertItem(
    IN HMENU  hmenu,
    IN LPTSTR psz,
    IN UINT   id,
    IN int    iImage,
    IN HMENU  hmenuSub,
    IN UINT   cyItem,
    IN UINT   iPos)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_InsertSeparator(HMENU hmenu, UINT iPos)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_GetPidl(HMENU hmenu, UINT iPos, LPITEMIDLIST *ppidl)
{
    return FALSE;
}

STDAPI_(void)
FileMenu_EditMode(BOOL bEdit)
{
}

STDAPI_(BOOL)
FileMenu_HandleMenuSelect(
    IN HMENU  hmenu,
    IN WPARAM wparam,
    IN LPARAM lparam)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_IsUnexpanded(HMENU hmenu)
{
    return FALSE;
}

STDAPI_(void)
FileMenu_DelayedInvalidate(HMENU hmenu)
{
}

STDAPI_(BOOL)
FileMenu_IsDelayedInvalid(HMENU hmenu)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_CreateFromMenu(
    IN HMENU    hmenu,
    IN COLORREF clr,
    IN int      cxBmpGap,
    IN HBITMAP  hbmp,
    IN int      cySel,
    IN DWORD    fmf)
{
    return FALSE;
}



/*++

    Table associating the obsolete APIs and thier ordinals

--*/

struct ShellStubs
{
    PVOID   pfnStub;
    UINT    uiOrd;
};

const ShellStubs g_rgShellStubs[] =
{
    { FileMenu_HandleNotify,              101 },
    { FileMenu_DeleteAllItems,            104 },
    { FileMenu_DrawItem,                  105 },
    { FileMenu_FindSubMenuByPidl,         106 },
    { FileMenu_GetLastSelectedItemPidls,  107 },
    { FileMenu_HandleMenuChar,            108 },
    { FileMenu_InitMenuPopup,             109 },
    { FileMenu_ComposeA,                  110 },
    { FileMenu_Invalidate,                111 },
    { FileMenu_MeasureItem,               112 },
    { FileMenu_ComposeW,                  113 },
    { FileMenu_Create,                    114 },
    { FileMenu_AppendItem,                115 },
    { FileMenu_TrackPopupMenuEx,          116 },
    { FileMenu_DeleteItemByCmd,           117 },
    { FileMenu_Destroy,                   118 },
    { FileMenu_AbortInitMenu,             120 },
    { FileMenu_AppendFilesForPidl,        124 },
    { FileMenu_DeleteItemByIndex,         140 },
    { FileMenu_DeleteMenuItemByFirstID,   141 },
    { FileMenu_DeleteSeparator,           142 },
    { FileMenu_EnableItemByCmd,           143 },
    { FileMenu_GetItemExtent,             144 },
    { FileMenu_ProcessCommand,            217 },
    { FileMenu_IsFileMenu,                216 },
    { FileMenu_InsertItem,                218 },
    { FileMenu_InsertSeparator,           219 },
    { FileMenu_GetPidl,                   220 },
    { FileMenu_EditMode,                  221 },
    { FileMenu_HandleMenuSelect,          222 },
    { FileMenu_IsUnexpanded,              223 },
    { FileMenu_DelayedInvalidate,         224 },
    { FileMenu_IsDelayedInvalid,          225 },
    { FileMenu_CreateFromMenu,            227 },

/*
    May need to add these too.  Not needed yet.

    { ExtAppListOpenW                     228 },
    { ExtAppListOpenA                     229 },
    { ExtAppListClose                     230 },
    { ExtAppListAddItemsW                 231 },
    { ExtAppListAddItemsA                 232 },
    { ExtAppListRemoveItemsW              233 },
    { ExtAppListRemoveItemsA              234 },
    { ExtAppListItemsFreeStringsW         235 },
    { ExtAppListItemsFreeStringsA         236 },
    { ExtAppListEnumItemsW                237 },
    { ExtAppListEnumItemsA                238 },

    { Link_AddExtraDataSection            206 },
    { Link_ReadExtraDataSection           207 },
    { Link_RemoveExtraDataSection         208 },

    { ReceiveAddToRecentDocs              647 },
*/

};



/*++

    We only want to intercept calls to GetProcAddress and not mess with the
    DLL inport tables.  This is because the ordinals have been reused
    by valid shell APIs and we want LdrGetProcAddress to work normally for these
    ordinals.  So instead of hooking each of the old APIs using the shim library,
    we need to do the work ourselves.

--*/

FARPROC
APIHOOK(GetProcAddress)(
    HMODULE hModule,
    LPCSTR pszProcName
    )
{
    // Only intercept shell32 API's referenced by ordinal
    if (IS_INTRESOURCE(pszProcName))
    {
        if (g_hShell32 == NULL)
        {
            g_hShell32 = GetModuleHandle(L"shell32.dll");
        }

        if (g_hShell32 && hModule == g_hShell32)
        {
            UINT uiOrd = (UINT)pszProcName;

            // Look for ordinal of obsolete APIs
            for (int i=0; i < ARRAYSIZE(g_rgShellStubs); ++i)
            {
                if (g_rgShellStubs[i].uiOrd == uiOrd)
                {
                    // Found one!
                    return (FARPROC)g_rgShellStubs[i].pfnStub;
                }
            }
        }
    }

    // Default to the original API
    return ORIGINAL_API(GetProcAddress)(
        hModule,
        pszProcName);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(kernel32.DLL, GetProcAddress)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\failopenfile.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   FailOpenFile.cpp

 Abstract:

   Force OpenFile to fail for the specified files.

 History:

    01/31/2001  robkenny    created
    03/13/2001  robkenny    Converted to CString

--*/

#include "precomp.h"
#include "charvector.h"

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(FailOpenFile)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OpenFile ) 
APIHOOK_ENUM_END

CharVector  * g_FailList = NULL;

HFILE 
APIHOOK(OpenFile)(
    LPCSTR lpFileName,        // file name
    LPOFSTRUCT lpReOpenBuff,  // file information
    UINT uStyle               // action and attributes
    )
{
    int i;
    for (i = 0; i < g_FailList->Size(); ++i)
    {
        // Compare each fail name against the end of lpFileName
        const char * failName = g_FailList->Get(i);
        size_t failNameLen = strlen(failName);
        size_t fileNameLen = strlen(lpFileName);

        if (fileNameLen >= failNameLen)
        {
            if (_strnicmp(failName, lpFileName+fileNameLen-failNameLen, failNameLen) == 0)
            {
                // Force OpenFile to fail for this filename
                DPFN( eDbgLevelError, "Forcing OpenFile(%s) to fail", lpFileName); 
                return FALSE;
            }
        }
    }

    HFILE returnValue = ORIGINAL_API(OpenFile)(lpFileName, lpReOpenBuff, uStyle);
    return returnValue;
}

/*++

 Parse the command line, push each filename onto the end of the g_FailList.

--*/

BOOL ParseCommandLine(const char * cl)
{
    g_FailList = new CharVector;
    if (!g_FailList)
    {
        return FALSE;
    }

    if (cl != NULL && *cl)
    {
        int     argc = 0;
        LPSTR * argv = _CommandLineToArgvA(cl, & argc);
        if (argv)
        {
            for (int i = 0; i < argc; ++i)
            {
                if (!g_FailList->Append(argv[i]))
                {
                    // Memory failure
                    delete g_FailList;
                    g_FailList = NULL;
                    break;
                }
                DPFN( eDbgLevelSpew, "Adding %s to fail list", argv[i]); 
            }
            LocalFree(argv);
        }
    }
    return g_FailList != NULL;
}

/*++

 Handle attach and detach

--*/

BOOL
NOTIFY_FUNCTION(DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        return ParseCommandLine(COMMAND_LINE);
    }
    return TRUE;
}


/*++

  Register hooked functions

--*/

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, OpenFile)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\extractassociatedicon.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    ExtractAssociatedIcon.cpp

 Abstract:
 
    32bpp icons do not render into old style metafiles. When an application uses OleGetIconOfFile,
    The icons are not rendered.  We shim shell32's ExtractAssociatedIcon to return 24bpp icons,
    so we don't try to use functions that aren't available in old metafiles.
   
 Notes:

    This shim is a general purpose shim.

 History:

    07/19/2001 lamadio  created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ExtractAssociatedIcon)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ExtractAssociatedIconW)
    APIHOOK_ENUM_ENTRY(ExtractAssociatedIconA)
    APIHOOK_ENUM_ENTRY(DrawIcon)
    APIHOOK_ENUM_ENTRY(DrawIconEx)
APIHOOK_ENUM_END


HBITMAP CreateDIB(HDC h, WORD depth, int cx, int cy, RGBQUAD** pprgb)
{
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = cx;
    bi.bmiHeader.biHeight = cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = depth;
    bi.bmiHeader.biCompression = BI_RGB;

    return CreateDIBSection(h, &bi, DIB_RGB_COLORS, (void**)pprgb, NULL, 0);
}


// Strip a 32bbp icon of it's alpha channel
HICON StripIcon(HICON hicon, BOOL fDestroyOriginal)
{
    // Get the original bitmaps. Don't forget to delete them
    ICONINFO ii;
    if (GetIconInfo(hicon, &ii))
    {
        // Make sure we have a good height and width.
        BITMAP bm;
        GetObject(ii.hbmColor, sizeof(bm), &bm);

        HDC hdcNew = CreateCompatibleDC(NULL);
        HDC hdcSrc = CreateCompatibleDC(NULL);
        if (hdcNew && hdcSrc)
        {
            // Create a 24bpp icon. This strips the alpha channel
            RGBQUAD* prgb;
            HBITMAP hbmpNew = CreateDIB(hdcNew, 24, bm.bmWidth, bm.bmHeight, &prgb);

            if (hbmpNew)
            {
                HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcNew, hbmpNew);
                HBITMAP hbmpOld2 = (HBITMAP)SelectObject(hdcSrc, ii.hbmColor);

                // Copy from 32bpp to 24bpp.
                BitBlt(hdcNew, 0, 0, bm.bmWidth, bm.bmHeight, hdcSrc, 0, 0, SRCCOPY);

                SelectObject(hdcSrc, hbmpOld2);
                SelectObject(hdcNew, hbmpOld);

                // Delete the original bitmap
                DeleteObject(ii.hbmColor);

                // and return the new one
                ii.hbmColor = hbmpNew;
            }
        }

        if (hdcNew)
            DeleteDC(hdcNew);

        if (hdcSrc)
            DeleteDC(hdcSrc);

        // Now, create the new icon from the 16bpp image and the mask.
        HICON hiconStripped = CreateIconIndirect(&ii);

        if (hiconStripped)
        {
            if (fDestroyOriginal)
                DestroyIcon(hicon);

            hicon = hiconStripped;
        }

        // Don't forget to clean up.
        DeleteObject(ii.hbmColor);
        DeleteObject(ii.hbmMask);
    }

    return hicon;
}

HICON APIHOOK(ExtractAssociatedIconA)(HINSTANCE hInst, LPSTR lpIconPath, LPWORD lpiIcon)
{
    HICON hicon = ORIGINAL_API(ExtractAssociatedIconA)(hInst, lpIconPath, lpiIcon);
    return StripIcon(hicon, TRUE);
}

HICON APIHOOK(ExtractAssociatedIconW)(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIcon)
{
    HICON hicon = ORIGINAL_API(ExtractAssociatedIconW)(hInst, lpIconPath, lpiIcon);
    return StripIcon(hicon, TRUE);
}


BOOL APIHOOK(DrawIcon)(HDC hDC, int X, int Y, HICON hIcon)
{
    HICON hIconNew = StripIcon(hIcon, FALSE);
        
    BOOL b = ORIGINAL_API(DrawIcon)(hDC, X, Y, hIconNew);

    DestroyIcon(hIconNew);

    return b;
}

BOOL APIHOOK(DrawIconEx)(HDC hDC, int X, int Y, HICON hIcon, int cxWidth, int cyHeight, UINT istepIfAniCur,
              HBRUSH hbrFlickerFreeDraw, UINT diFlags)
{
    HICON hIconNew = StripIcon(hIcon, FALSE);
        
    BOOL b = ORIGINAL_API(DrawIconEx)(hDC, X, Y, hIconNew, cxWidth, cyHeight, istepIfAniCur,
              hbrFlickerFreeDraw, diFlags);

    DestroyIcon(hIconNew);
    return b;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(SHELL32.DLL, ExtractAssociatedIconA)
    APIHOOK_ENTRY(SHELL32.DLL, ExtractAssociatedIconW)
    APIHOOK_ENTRY(USER32.DLL, DrawIcon)
    APIHOOK_ENTRY(USER32.DLL, DrawIconEx)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\fakethememetrics.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   FakeThemeMetrics.cpp

 Abstract:

  This Shim will allow the Skemers group to shim applications that do not behave 
  well with "Themed" system metrics

 History:

  11/30/2000 a-brienw Converted to shim frame work version 2.

--*/

#include "precomp.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    sizeof(x)/sizeof((x)[0])
#endif

IMPLEMENT_SHIM_BEGIN(FakeThemeMetrics)
#include "ShimHookMacro.h"

// Add APIs that you wish to hook to this enumeration. The first one
// must have "= USERAPIHOOKSTART", and the last one must be
// APIHOOK_Count.
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetSysColor) 
APIHOOK_ENUM_END

#define F_TYPE_RGB      0
#define F_TYPE_MAP      1
#define F_TYPE_PERCENT  2
#define F_TYPE_MAX      3
#define F_TYPE_NOTEQUAL 4
typedef struct
{
    int nIndex;
    DWORD fType;
    COLORREF rgb;
    int nMap;  // If mapping we need to use the post processed color. Call HookedGetSysColor. See note
    int iPercent;
} GETSYSCOLOR_MAP;

const static GETSYSCOLOR_MAP s_ColorMap[] = 
{
    {COLOR_MENU, F_TYPE_MAP, RGB(212, 208, 200), COLOR_BTNFACE, 10},
    {COLOR_BTNFACE, F_TYPE_MAX, RGB(227, 227, 227), 0, 0},
    {COLOR_3DDKSHADOW, F_TYPE_NOTEQUAL, RGB(0,0,0), COLOR_BTNFACE, 20}
};

COLORREF AdjustPercent(COLORREF crOld, int iPercent)
{
    return RGB(GetRValue(crOld) - (GetRValue(crOld) * iPercent) / 100,
               GetGValue(crOld) - (GetGValue(crOld) * iPercent) / 100,
               GetBValue(crOld) - (GetBValue(crOld) * iPercent) / 100);
}

// NOTE: If you are mapping a color (i.e. a direct map), then you need to call HookedGetSysColor. For example
// MSDEV calls GetSysColor(COLOR_BTNFACE). It then calls GetSysColor(COLOR_MENU) and compares the two. 
// If they are different then it pukes. However we hook both COLOR_MENU and COLOR_BTNFACE. So we need to get the mapped color.


DWORD HookedGetSysColor(int nIndex)
{
    for (int i = 0; i < ARRAYSIZE(s_ColorMap); i++)
    {
        if (nIndex == s_ColorMap[i].nIndex)
        {
            switch (s_ColorMap[i].fType)
            {
            case F_TYPE_RGB:
                return (DWORD)s_ColorMap[i].rgb;
                break;

            case F_TYPE_MAP:
                return HookedGetSysColor(s_ColorMap[i].nMap);
                break;

            case F_TYPE_PERCENT:
            {
                COLORREF crOld = (COLORREF)ORIGINAL_API(GetSysColor)(nIndex);

                return (DWORD)AdjustPercent(crOld, s_ColorMap[i].iPercent);
            }

            case F_TYPE_MAX:
            {
                COLORREF crOld = (COLORREF)ORIGINAL_API(GetSysColor)(nIndex);
                BYTE r = GetRValue(crOld);
                BYTE g = GetGValue(crOld);
                BYTE b = GetBValue(crOld);

                if (r > GetRValue(s_ColorMap[i].rgb))
                    r = GetRValue(s_ColorMap[i].rgb);
                if (g > GetGValue(s_ColorMap[i].rgb))
                    g = GetGValue(s_ColorMap[i].rgb);
                if (b > GetBValue(s_ColorMap[i].rgb))
                    b = GetBValue(s_ColorMap[i].rgb);

                return RGB(r,g,b);
            }
            case F_TYPE_NOTEQUAL:
            {
                COLORREF crOld = (COLORREF)ORIGINAL_API(GetSysColor)(nIndex);
                COLORREF crNotEqual = (COLORREF)HookedGetSysColor(s_ColorMap[i].nMap);
                if (crOld == crNotEqual)
                {
                    crOld = AdjustPercent(crOld, s_ColorMap[i].iPercent);
                }

                return crOld;
            }
            }

            break;
        }
    }

    return ORIGINAL_API(GetSysColor)( nIndex );
}

DWORD
APIHOOK(GetSysColor)(int nIndex)
{
    return HookedGetSysColor(nIndex);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, GetSysColor)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\filternetworkresources.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    FilterNetworkResources.cpp

 Abstract:

    This shim intercepts WNetEnumResourceW from MPR.DLL and removes:

             "Microsoft Terminal Services"   and/or 
             "Web Client Network"

    network providers from the list of default network providers. It obtains the actual 
    names for these two providers from the registry. 

 Notes:

   This is a general purpose shim.

 History:
 
   08/21/2001 bduke & linstev   Created

--*/

#include "precomp.h"
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(FilterNetworkResources)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(WNetEnumResourceA) 
    APIHOOK_ENUM_ENTRY(WNetEnumResourceW) 
APIHOOK_ENUM_END

// ANSI and Unicode versions of the resource provider names
CHAR g_szTerminalServerName[MAX_PATH] = "";
CHAR g_szWebClientName[MAX_PATH] = "";
WCHAR g_wzTerminalServerName[MAX_PATH] = L"";
WCHAR g_wzWebClientName[MAX_PATH] = L"";

void 
InitPaths()
{
    static BOOL bInit = FALSE;

    if (bInit) return;

    //
    // Registry path for the names of all providers, so we can find the name for 
    // each provider in different language SKUs
    //
    #define TS_NETWORK_PROVIDER  L"SYSTEM\\CurrentControlSet\\Services\\RDPNP\\NetworkProvider"
    #define WC_NETWORK_PROVIDER  L"SYSTEM\\CurrentControlSet\\Services\\WebClient\\NetworkProvider"
    #define PROVIDER_VALUEA      "Name"
    #define PROVIDER_VALUEW      L"Name"

    //
    // Get names from the registry
    //
    HKEY hKey;
    if (ERROR_SUCCESS == RegOpenKeyW(HKEY_LOCAL_MACHINE, TS_NETWORK_PROVIDER, &hKey)) {
        //
        // Get the TS provider name
        //
        DWORD dwSize;

        dwSize = sizeof(g_szTerminalServerName);
        RegQueryValueExA(hKey, PROVIDER_VALUEA, 0, 0, (PBYTE)g_szTerminalServerName, &dwSize);

        dwSize = sizeof(g_wzTerminalServerName);
        RegQueryValueExW(hKey, PROVIDER_VALUEW, 0, 0, (PBYTE)g_wzTerminalServerName, &dwSize);

        RegCloseKey(hKey);
    } else {
        DPFN(eDbgLevelWarning, "Failed to open TS_NETWORK_PROVIDER");
    }

    if (ERROR_SUCCESS == RegOpenKeyW(HKEY_LOCAL_MACHINE, WC_NETWORK_PROVIDER, &hKey)) {
        //
        // Get the web client name
        //
        DWORD dwSize;
        
        dwSize = sizeof(g_szWebClientName);
        RegQueryValueExA(hKey, PROVIDER_VALUEA, 0, 0, (PBYTE)g_szWebClientName, &dwSize);

        dwSize = sizeof(g_wzWebClientName);
        RegQueryValueExW(hKey, PROVIDER_VALUEW, 0, 0, (PBYTE)g_wzWebClientName, &dwSize);

        RegCloseKey(hKey);
    } else {
        DPFN(eDbgLevelWarning, "Failed to open WC_NETWORK_PROVIDER");
    }

    bInit = TRUE;
}

/*++
  
 Hook WNetEnumResourceA function

--*/

DWORD 
APIHOOK(WNetEnumResourceA)(
    HANDLE  hEnum,         // handle to enumeration
    LPDWORD lpcCount,      // entries to list
    LPVOID  lpBuffer,      // buffer
    LPDWORD lpBufferSize   // buffer size
    )
{   
retry:

    DWORD dwRet = ORIGINAL_API(WNetEnumResourceA)(hEnum, lpcCount, lpBuffer, lpBufferSize);

    if (dwRet == NO_ERROR) {
        //
        // Remove entries we want to hide
        //
        InitPaths();

        DWORD dwCount = *lpcCount;
        LPNETRESOURCEA lpResourceFirst = (LPNETRESOURCEA) lpBuffer;
        LPNETRESOURCEA lpResourceLast = (LPNETRESOURCEA) lpBuffer  + dwCount - 1;

        while ((dwCount > 0) && (lpResourceFirst <= lpResourceLast)) {
            
            if ((lpResourceFirst->dwUsage & RESOURCEUSAGE_CONTAINER) && 
                ((strcmp(lpResourceFirst->lpProvider, g_szTerminalServerName) == 0) ||
                (strcmp(lpResourceFirst->lpProvider, g_szWebClientName) == 0))) {

                MoveMemory(lpResourceFirst, lpResourceLast, sizeof(NETRESOURCEA));
                ZeroMemory(lpResourceLast, sizeof(NETRESOURCEA));

                lpResourceLast--;
                dwCount--; 
            } else {
                lpResourceFirst++;
            }
        }

        if (dwCount != *lpcCount) {
            if (dwCount == 0) {
                //
                // We filtered everything out, so try again with a larger count
                //
                *lpcCount = *lpcCount + 1;
                goto retry;
            }
            LOGN(eDbgLevelWarning, "Network providers removed from list");
        }

        //
        // Fixup out variables
        //

        *lpcCount = dwCount;

        if (dwCount == 0) {
            dwRet = ERROR_NO_MORE_ITEMS;
        }
    }

    return dwRet;
}

/*++
  
 Hook WNetEnumResourceW function

--*/

DWORD 
APIHOOK(WNetEnumResourceW)(
    HANDLE  hEnum,         // handle to enumeration
    LPDWORD lpcCount,      // entries to list
    LPVOID  lpBuffer,      // buffer
    LPDWORD lpBufferSize   // buffer size
    )
{   
retry:

    DWORD dwRet = ORIGINAL_API(WNetEnumResourceW)(hEnum, lpcCount, lpBuffer, lpBufferSize);

    if (dwRet == NO_ERROR) {
        //
        // Remove entries we want to hide
        //
        InitPaths();

        DWORD dwCount = *lpcCount;
        LPNETRESOURCEW lpResourceFirst = (LPNETRESOURCEW) lpBuffer;
        LPNETRESOURCEW lpResourceLast = (LPNETRESOURCEW) lpBuffer  + dwCount - 1;

        while ((dwCount > 0) && (lpResourceFirst <= lpResourceLast)) {
            
            if ((lpResourceFirst->dwUsage & RESOURCEUSAGE_CONTAINER) && 
                ((wcscmp(lpResourceFirst->lpProvider, g_wzTerminalServerName) == 0) ||
                (wcscmp(lpResourceFirst->lpProvider, g_wzWebClientName) == 0))) {

                MoveMemory(lpResourceFirst, lpResourceLast, sizeof(NETRESOURCEW));
                ZeroMemory(lpResourceLast, sizeof(NETRESOURCEW));

                lpResourceLast--;
                dwCount--; 
            } else {
                lpResourceFirst++;
            }
        }

        if (dwCount != *lpcCount) {
            if (dwCount == 0) {
                //
                // We filtered everything out, so try again with a larger count
                //
                *lpcCount = *lpcCount + 1;
                goto retry;
            }
            LOGN(eDbgLevelWarning, "Network providers removed from list");
        }

        //
        // Fixup out variables
        //

        *lpcCount = dwCount;

        if (dwCount == 0) {
            dwRet = ERROR_NO_MORE_ITEMS;
        }
    }

    return dwRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(MPR.DLL, WNetEnumResourceA)
    APIHOOK_ENTRY(MPR.DLL, WNetEnumResourceW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\forceadminaccess.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceAdminAccess.cpp

 Abstract:

    Pretend the token is a member. Typically used to see if we have 
    administrator access... 

 Notes:

    This is a general purpose shim.

 History:

    12/07/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceAdminAccess)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CheckTokenMembership) 
APIHOOK_ENUM_END

/*++

 Pretend the token is a member.

--*/

BOOL 
APIHOOK(CheckTokenMembership)(
    HANDLE TokenHandle,  // handle to an access token
    PSID SidToCheck,     // SID to check for 
    PBOOL IsMember       // receives results of the check 
    )
{
    BOOL bRet = ORIGINAL_API(CheckTokenMembership)(
        TokenHandle, SidToCheck, IsMember);

    if (bRet && IsMember)
    {
        *IsMember = TRUE;
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, CheckTokenMembership)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\force640x480x8.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    Force640x480x8.cpp

 Abstract:

    This shim is for games that assume the start resolution is 640x480x8.

 Notes:

    This is a general purpose shim.

 History:

    01/20/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Force640x480x8)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

#define CDS_WIDTH   640
#define CDS_HEIGHT  480
#define CDS_BITS    8

VOID
ChangeMode()
{
    DEVMODEA dm;

    __try { 
        EnumDisplaySettingsA(NULL, ENUM_CURRENT_SETTINGS, &dm);
        if ((dm.dmPelsWidth != CDS_WIDTH) ||
            (dm.dmPelsHeight != CDS_HEIGHT) ||
            (dm.dmBitsPerPel != CDS_BITS)) {
            //
            // The mode is different, so change
            //
            dm.dmPelsWidth = CDS_WIDTH;
            dm.dmPelsHeight = CDS_HEIGHT;
            dm.dmBitsPerPel = CDS_BITS;
            ChangeDisplaySettingsA(&dm, CDS_FULLSCREEN);
        }
    }
    __except(1) {
        DPFN( eDbgLevelWarning, "Exception trying to change mode");
    };
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        ChangeMode();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\force640x480x16.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    Force640x480x8.cpp

 Abstract:

    This shim is for games that assume the start resolution is 640x480x16.

 Notes:

    This is a general purpose shim.

 History:

    01/20/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Force640x480x16)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

#define CDS_WIDTH   640
#define CDS_HEIGHT  480
#define CDS_BITS    16

VOID
ChangeMode()
{
    DEVMODEA dm;

    __try { 
        EnumDisplaySettingsA(NULL, ENUM_CURRENT_SETTINGS, &dm);

        if ((dm.dmPelsWidth != CDS_WIDTH) ||
            (dm.dmPelsHeight != CDS_HEIGHT) ||
            (dm.dmBitsPerPel != CDS_BITS)) {
            //
            // The mode is different, so change
            //
            dm.dmPelsWidth = CDS_WIDTH;
            dm.dmPelsHeight = CDS_HEIGHT;
            dm.dmBitsPerPel = CDS_BITS;
            ChangeDisplaySettingsA(&dm, CDS_FULLSCREEN);
        }
    }
    __except(1) {
        DPFN( eDbgLevelWarning, "Exception trying to change mode");
    };
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        ChangeMode();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\fixservicestartupcirculardependency.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    FixServiceStartupCircularDependency.cpp

 Abstract:

    Hooks the call to CreateServiceA and changes the start parameter for
    only the service passed in COMMAND_LINE from SERVICE_AUTO_START to
    SERVICE_SYSTEM_START.  This eliminates a circular dependency during
    boot up which results in XP taking 15 to 20 minutes to boot.

 Notes:

    This is a general purpose shim.  Pass the service name in the command
    line.  It tests if the startup type for that service is SERVICE_AUTO_START
    and if so changes it to SERVICE_SYSTEM_START.

 History:

    02/19/2001 a-brienw Created
    02/20/2001 a-brienw Changed it to a general purpose shim using the command
                        line to pass in the service name.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(FixServiceStartupCircularDependency)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateServiceA)
APIHOOK_ENUM_END

/*++

 Hook CreateServiceA to change the start parameter for the required service.

--*/

SC_HANDLE
APIHook_CreateServiceA(
  SC_HANDLE hSCManager,       // handle to SCM database 
  LPCSTR lpServiceName,       // name of service to start
  LPCSTR lpDisplayName,       // display name
  DWORD dwDesiredAccess,      // type of access to service
  DWORD dwServiceType,        // type of service
  DWORD dwStartType,          // when to start service
  DWORD dwErrorControl,       // severity of service failure
  LPCSTR lpBinaryPathName,    // name of binary file
  LPCSTR lpLoadOrderGroup,    // name of load ordering group
  LPDWORD lpdwTagId,          // tag identifier
  LPCSTR lpDependencies,      // array of dependency names
  LPCSTR lpServiceStartName,  // account name 
  LPCSTR lpPassword           // account password
)
{
    /*
       Only change it if it is currently SERVICE_AUTO_START.  Do not change
       the IF statement to read != as there are other startup types which do
       not result in a circular dependency.
    */
    if (dwStartType == SERVICE_AUTO_START &&
        !_tcsicmp(lpServiceName,COMMAND_LINE))
    {
        LOGN( eDbgLevelInfo,
            "[CreateServiceA] Fixed startup type: %s.", lpServiceName);
        dwStartType = SERVICE_SYSTEM_START;
    }
    
    return ORIGINAL_API(CreateServiceA)(hSCManager, lpServiceName,
        lpDisplayName, dwDesiredAccess, dwServiceType, dwStartType,
        dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId,
        lpDependencies, lpServiceStartName, lpPassword);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(ADVAPI32.DLL, CreateServiceA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\forceansiwindowproc.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceAnsiWindowProc.cpp

 Abstract:

    Apps call GetWindowLongA() to get a window procedure and subsequently 
    does not call CallWindowProc() with the value returned from 
    GetWindowLongA(). This SHIM calls GetWindowLongW( ), which returns the 
    window procedure.
        If the app wants a Dialog procedure, we pass back our function
    and subsequently call CallWindowProc() in our function. SetWindowLongA()
    is hooked to prevent the app from setting our function as a Dialog Proc. 
   
 Notes:

    This is a general purpose SHIM 
 History:

    03/16/2000 prashkud Created
    01/30/2001 prashkud Converted to a general SHIM

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceAnsiWindowProc)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowLongA) 
    APIHOOK_ENUM_ENTRY(GetWindowLongA) 
APIHOOK_ENUM_END

#define HANDLE_MASK 0xffff0000
LONG g_lGetWindowLongRet = 0;

LRESULT
MyProcAddress(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return CallWindowProcA(
            (WNDPROC) g_lGetWindowLongRet,
            hWnd,
            uMsg,
            wParam,
            lParam
            );
}

LONG
APIHOOK(SetWindowLongA)(
    HWND hwnd,
    int  nIndex,
    LONG dwNewLong
     )
{
    LONG lRet = 0;

    // If the address that is being set is my address, don't!
    if (dwNewLong == (LONG)MyProcAddress)
    {
        lRet = 0;
    }
    else
    {
        lRet = ORIGINAL_API(SetWindowLongA)(hwnd,nIndex,dwNewLong);
    }

    return lRet;
}

/*++

 This function intercepts GetWindowLong( ), checks the nIndex for GWL_WNDPROC 
 and if it is,calls GetWindowLongW( ). Otherwise, it calls GetWindowLongA( )

--*/

LONG
APIHOOK(GetWindowLongA)(
    HWND hwnd,
    int  nIndex )
{
    LONG lRet = 0;

    // Apply the modification only if the App wants a WindowProc.
    if ((nIndex == GWL_WNDPROC) ||
        (nIndex == DWL_DLGPROC))
    {
        if ((nIndex == GWL_WNDPROC)) 
        {
            lRet = GetWindowLongW(hwnd, nIndex);
        }
        else
        {
            g_lGetWindowLongRet = ORIGINAL_API(GetWindowLongA)(
                                                hwnd,
                                                nIndex
                                                );
            if ((g_lGetWindowLongRet & HANDLE_MASK) == HANDLE_MASK)
            {
                lRet = (LONG) MyProcAddress;
            }
            else
            {
                lRet = g_lGetWindowLongRet;
            }
            
        }
    }
    else
    {
        lRet = ORIGINAL_API(GetWindowLongA)(hwnd, nIndex);
    }

    return lRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, GetWindowLongA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\forceapplicationfocus.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceApplicationFocus.cpp

 Abstract:

    This shim calls SetForegroundWindow after CreateWindowEx and ShowWindow 
    calls to fix focus problems that applications tend to have when they 
    create/destroy windows on startup and manage to lose the foreground focus.

 Notes:

    This is a general purpose shim.

 History:

    12/02/1999 markder     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceApplicationFocus)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ShowWindow)
    APIHOOK_ENUM_ENTRY(CreateWindowExA)
    APIHOOK_ENUM_ENTRY(CreateWindowExW)
APIHOOK_ENUM_END

/*++

 Calls SetForegroundWindow directly after a ShowWindow call with SW_SHOW as
 the operation. The mouse_event call allows the SetForegroundWindow call to 
 succeed. This is a hack borrowed from the DirectX sources.

--*/

BOOL 
APIHOOK(ShowWindow)(
    HWND hWnd, 
    INT nCmdShow
    )
{
    BOOL bReturn;

    bReturn = ORIGINAL_API(ShowWindow)(hWnd, nCmdShow);

    if (nCmdShow == SW_SHOW)
    {
        if (hWnd != GetForegroundWindow()) {
            LOGN( eDbgLevelWarning, 
               "ShowWindow called for non-foreground window. Forcing to foreground.");
        }
        mouse_event(MOUSEEVENTF_WHEEL, 0, 0, 0, 0);
        SetForegroundWindow(hWnd);
    }

    return bReturn;
}

/*++

 Calls SetForegroundWindow directly after a CreateWindowEx call with 
 WS_VISIBLE as a style. The mouse_event call allows the
 SetForegroundWindow call to succeed. This is a hack borrowed from
 the DirectX sources.

--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,      
    LPCSTR lpClassName,  
    LPCSTR lpWindowName, 
    DWORD dwStyle,       
    int x,               
    int y,               
    int nWidth,          
    int nHeight,         
    HWND hWndParent,     
    HMENU hMenu,         
    HINSTANCE hInstance, 
    LPVOID lpParam       
    )
{
    HWND hReturn;

    hReturn = ORIGINAL_API(CreateWindowExA)(
        dwExStyle,
        lpClassName,      
        lpWindowName,     
        dwStyle,          
        x,                
        y,                
        nWidth,           
        nHeight,          
        hWndParent,       
        hMenu,            
        hInstance,        
        lpParam);

    if (hReturn && (dwStyle & WS_VISIBLE))
    {
        if (hReturn != GetForegroundWindow()) {
            LOGN( eDbgLevelWarning, 
               "CreateWindowExA: New window not foreground. Forcing to foreground.");
        }
        mouse_event(MOUSEEVENTF_WHEEL, 0, 0, 0, 0);
        SetForegroundWindow(hReturn);
    }

    return hReturn;
}

/*++

 Calls SetForegroundWindow directly after a CreateWindowEx call with
 WS_VISIBLE as a style. The mouse_event call allows the
 SetForegroundWindow call to succeed. This is a hack borrowed from
 the DirectX sources.

--*/

HWND 
APIHOOK(CreateWindowExW)(
    DWORD dwExStyle,      
    LPCWSTR lpClassName,  
    LPCWSTR lpWindowName, 
    DWORD dwStyle,        
    int x,                
    int y,                
    int nWidth,           
    int nHeight,          
    HWND hWndParent,      
    HMENU hMenu,          
    HINSTANCE hInstance,  
    LPVOID lpParam        
    )
{
    HWND hReturn;

    hReturn = ORIGINAL_API(CreateWindowExW)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,     
        x,           
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,     
        hInstance, 
        lpParam);

    if (hReturn && (dwStyle & WS_VISIBLE))
    {
        if (hReturn != GetForegroundWindow()) {
            LOGN( eDbgLevelWarning, "CreateWindowExW: New window not foreground. Forcing to foreground.");
        }
        mouse_event(MOUSEEVENTF_WHEEL, 0, 0, 0, 0);
        SetForegroundWindow(hReturn);
    }

    return hReturn;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, ShowWindow)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExW)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\forceappendmenusuccess.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceAppendMenuSuccess.cpp

 Abstract:

    Apps call AppendMenu passing the handle of the system menu.
    This is prohibited in Windows 2000 and the API will fail. The present
    shim will return success to all AppenMenu calls since there is no
    easy way to tell if an HMENU is the handle of the real system menu.

 Notes:

    This is a general shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceAppendMenuSuccess)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(AppendMenuA)
APIHOOK_ENUM_END

/*++

    Return TRUE to AppendMenuA no matter what.

--*/

BOOL
APIHOOK(AppendMenuA)(
    HMENU    hMenu,
    UINT     uFlags,
    UINT_PTR uIDNewItem,
    LPSTR    lpNewItem
    )
{
    BOOL bReturn = ORIGINAL_API(AppendMenuA)(
                                    hMenu,
                                    uFlags,
                                    uIDNewItem,
                                    lpNewItem);
    
    if (!bReturn) {
        LOGN(
            eDbgLevelInfo,
            "ForceAppendMenuSuccess.dll, AppendMenuA returns TRUE instead of FALSE.");
    }
    
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, AppendMenuA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\forceaviwindow.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceAVIWindow.cpp

 Abstract:

    Some apps that use MCI to play their AVIs send messages in an order that
    causes mciavi32 to continually re-open the window it's supposed to be 
    playing to.

    The code in mciavi is different on win9x, so the exact reason for this shim 
    is hidden in layers of user/avi code. Here we just filter the message that 
    causes the avi stuff to not use the existing window it's been given.

 Notes:

    This is an app specific shim.

 History:

    02/22/2000 linstev     Created
    09/27/2000 mnikkel     Modified to destroy the MCI window on a command line input

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceAVIWindow)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(PostMessageW)
APIHOOK_ENUM_END

BOOL g_bDestroyWindow= FALSE;

/*++

 Filter AVIM_SHOWSTAGE
 
--*/

BOOL 
APIHOOK(PostMessageW)(
    HWND hWnd,      
    UINT Msg,       
    WPARAM wParam,  
    LPARAM lParam   
    )
{
    #define AVIM_SHOWSTAGE  (WM_USER+104)

    BOOL bRet;

    // Eat the AVIM_SHOWSTAGE message
    if (Msg != AVIM_SHOWSTAGE)
    {        
        bRet = ORIGINAL_API(PostMessageW)(
            hWnd,
            Msg,
            wParam,
            lParam);
    }
    else    
    {
        LOGN( eDbgLevelError, 
           "[APIHook_PostMessageW] AVIM_SHOWSTAGE message discarded");

        // if command line specified to destroy the MCI window do so now.
        if (g_bDestroyWindow)
        {
            MCIWndDestroy(hWnd);
        }

        bRet = TRUE;
    }

    return bRet;
}
 
/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        CSTRING_TRY
        {
            CString csCl(COMMAND_LINE);
            g_bDestroyWindow = csCl.CompareNoCase(L"DestroyMCIWindow") == 0;
        }
        CSTRING_CATCH
        {
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, PostMessageW)
    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\forcedirectdrawwait.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    ForceDirectDrawWait.cpp

 Abstract:

    Some applications don't specify the DD_WAIT flag to 
    IDirectDrawSurface::Lock, which means that if it fails because the device
    is busy, the app can fail. This could also happen on Win9x of course, but 
    was more difficult to repro.

    Note that we don't need to do this on the IDirectDraw7 interface since the
    default is DDLOCK_WAIT, unless DDLOCK_DONOTWAIT is specified.

 Notes:

    This is a general purpose shim.

 History:

    03/04/2000 linstev     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceDirectDrawWait)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw2, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw2_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw2, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface2, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw4, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC2 lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw4_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw4, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface4, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Make sure we add DDBLT_WAIT.

--*/

HRESULT 
COMHOOK(IDirectDrawSurface, Blt)(
    LPDIRECTDRAWSURFACE lpDDDestSurface,
    LPRECT lpDestRect,
    LPDIRECTDRAWSURFACE lpDDSrcSurface,
    LPRECT lpSrcRect,
    DWORD dwFlags,
    LPDDBLTFX lpDDBltFX 
    )
{
    dwFlags &= ~DDBLT_DONOTWAIT;
    dwFlags |= DDBLT_WAIT;

    // Original Blt
    _pfn_IDirectDrawSurface_Blt pfnOld = ORIGINAL_COM(
        IDirectDrawSurface, 
        Blt, 
        lpDDDestSurface);

    return (*pfnOld)(
            lpDDDestSurface,
            lpDestRect,
            lpDDSrcSurface,
            lpSrcRect,
            dwFlags,
            lpDDBltFX);
}

HRESULT 
COMHOOK(IDirectDrawSurface2, Blt)(
    LPDIRECTDRAWSURFACE lpDDDestSurface,
    LPRECT lpDestRect,
    LPDIRECTDRAWSURFACE lpDDSrcSurface,
    LPRECT lpSrcRect,
    DWORD dwFlags,
    LPDDBLTFX lpDDBltFX 
    )
{
    dwFlags &= ~DDBLT_DONOTWAIT;
    dwFlags |= DDBLT_WAIT;

    // Original Blt
    _pfn_IDirectDrawSurface_Blt pfnOld = ORIGINAL_COM(
        IDirectDrawSurface2, 
        Blt, 
        lpDDDestSurface);

    return (*pfnOld)(
            lpDDDestSurface,
            lpDestRect,
            lpDDSrcSurface,
            lpSrcRect,
            dwFlags,
            lpDDBltFX);
}

HRESULT 
COMHOOK(IDirectDrawSurface4, Blt)(
    LPDIRECTDRAWSURFACE lpDDDestSurface,
    LPRECT lpDestRect,
    LPDIRECTDRAWSURFACE lpDDSrcSurface,
    LPRECT lpSrcRect,
    DWORD dwFlags,
    LPDDBLTFX lpDDBltFX 
    )
{
    dwFlags &= ~DDBLT_DONOTWAIT;
    dwFlags |= DDBLT_WAIT;

    // Original Blt
    _pfn_IDirectDrawSurface_Blt pfnOld = ORIGINAL_COM(
        IDirectDrawSurface4, 
        Blt, 
        lpDDDestSurface);

    return (*pfnOld)(
            lpDDDestSurface,
            lpDestRect,
            lpDDSrcSurface,
            lpSrcRect,
            dwFlags,
            lpDDBltFX);
}

/*++

 Make sure we add DDLOCK_WAIT.

--*/

HRESULT 
COMHOOK(IDirectDrawSurface, Lock)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPRECT lpDestRect,
    LPDDSURFACEDESC lpDDSurfaceDesc,
    DWORD dwFlags,
    HANDLE hEvent
    )
{
    dwFlags &= ~DDLOCK_DONOTWAIT;
    dwFlags |= DDLOCK_WAIT;

    // Retrieve the old function
    _pfn_IDirectDrawSurface_Lock pfnOld = ORIGINAL_COM(
        IDirectDrawSurface, 
        Lock, 
        lpDDSurface);

    // Call the old API
    return (*pfnOld)(
            lpDDSurface, 
            lpDestRect, 
            lpDDSurfaceDesc, 
            dwFlags, 
            hEvent);
}

HRESULT 
COMHOOK(IDirectDrawSurface2, Lock)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPRECT lpDestRect,
    LPDDSURFACEDESC lpDDSurfaceDesc,
    DWORD dwFlags,
    HANDLE hEvent
    )
{
    dwFlags &= ~DDLOCK_DONOTWAIT;
    dwFlags |= DDLOCK_WAIT;

    // Retrieve the old function
    _pfn_IDirectDrawSurface_Lock pfnOld = ORIGINAL_COM(
        IDirectDrawSurface2, 
        Lock, 
        lpDDSurface);

    // Call the old API
    return (*pfnOld)(
            lpDDSurface, 
            lpDestRect, 
            lpDDSurfaceDesc, 
            dwFlags, 
            hEvent);
}

HRESULT 
COMHOOK(IDirectDrawSurface4, Lock)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPRECT lpDestRect,
    LPDDSURFACEDESC lpDDSurfaceDesc,
    DWORD dwFlags,
    HANDLE hEvent
    )
{
    dwFlags &= ~DDLOCK_DONOTWAIT;
    dwFlags |= DDLOCK_WAIT;

    // Retrieve the old function
    _pfn_IDirectDrawSurface_Lock pfnOld = ORIGINAL_COM(
        IDirectDrawSurface4, 
        Lock, 
        lpDDSurface);

    // Call the old API
    return (*pfnOld)(
            lpDDSurface, 
            lpDestRect, 
            lpDDSurfaceDesc, 
            dwFlags, 
            hEvent);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_DIRECTX_COMSERVER()

    COMHOOK_ENTRY(DirectDraw, IDirectDraw, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw2, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw4, CreateSurface, 6)

    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, Blt, 5)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface2, Blt, 5)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface4, Blt, 5)

    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, Lock, 25)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface2, Lock, 25)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface4, Lock, 25)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\forcedirectdrawemulation.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    ForceDirectDrawEmulation.cpp

 Abstract:

    Some applications don't handle aspects of hardware acceleration correctly.
    For example, Dragon Lore 2 creates a surface and assumes that the pitch is 
    double the width for 16bpp. However, this is not always the case. 
    DirectDraw exposes this through the lPitch parameter when a surface is 
    locked. 

    The fix is to force DirectDraw into emulation, in which case all surfaces 
    will be in system memory and so the pitch really will be related to the 
    width.

 Notes:

    This is a general purpose shim.

 History:

    03/11/2000 linstev     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceDirectDrawEmulation)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
APIHOOK_ENUM_END

/*++

 Force DirectDraw into emulation.

--*/

LONG 
APIHOOK(RegQueryValueExA)(
    HKEY hKey,           
    LPSTR lpValueName,  
    LPDWORD lpReserved,  
    LPDWORD lpType,      
    LPBYTE lpData,       
    LPDWORD lpcbData     
    )
{
    if (_tcsicmp("EmulationOnly", lpValueName) == 0)
    {
        if (lpType)
        {
            *lpType = REG_DWORD;
        }

        if (lpData)
        {
            *((DWORD *)lpData) = 1;
        }

        if (lpcbData)
        {
            *lpcbData = 4;
        }

        return ERROR_SUCCESS;
    }

    return ORIGINAL_API(RegQueryValueExA)(
        hKey,
        lpValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA) 

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\forceseparatevdm.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    ForceSeparateVDM.cpp   

 Abstract:

    Force child processes to use a separate VDM. 
    
    This can be useful if the parent process wants to wait on a handle returned
    by CreateProcess. This only works because of a hack in the VDM that returns 
    and actual thread handle that will go away along with the process if a VDM 
    doesn't already exist.

 Notes:

    This is a general purpose shim.

 History:

   06/14/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceSeparateVDM)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
    APIHOOK_ENUM_ENTRY(CreateProcessW) 
APIHOOK_ENUM_END

BOOL 
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    if (!(dwCreationFlags & CREATE_SEPARATE_WOW_VDM)) {
        LOGN(eDbgLevelWarning, "Added CREATE_SEPARATE_WOW_VDM to CreateProcessA"); 
    }
    return ORIGINAL_API(CreateProcessA)(lpApplicationName, lpCommandLine, 
        lpProcessAttributes, lpThreadAttributes, bInheritHandles,
        dwCreationFlags | CREATE_SEPARATE_WOW_VDM,
        lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
}

BOOL 
APIHOOK(CreateProcessW)(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    if (!(dwCreationFlags & CREATE_SEPARATE_WOW_VDM)) {
        LOGN(eDbgLevelWarning, "Added CREATE_SEPARATE_WOW_VDM to CreateProcessW"); 
    }
    return ORIGINAL_API(CreateProcessW)(lpApplicationName, lpCommandLine, 
        lpProcessAttributes, lpThreadAttributes, bInheritHandles,
        dwCreationFlags | CREATE_SEPARATE_WOW_VDM,
        lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
}
 
/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessW)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\forcedefaultsystempaletteentries.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceDefaultSystemPaletteEntries.cpp

 Abstract:

    This shim hard-codes DefaultPalette with correct palette information.

 Notes:

    This is a general purpose shim.

 History:

    11/22/1999 linstev     Created
    11/29/2000 a-larrsh    Ported to Multi-Shim Format
--*/

#include "precomp.h"
IMPLEMENT_SHIM_BEGIN(ForceDefaultSystemPaletteEntries)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetSystemPaletteEntries)
APIHOOK_ENUM_END

// Initialize global palette
DWORD DefaultPalette[256] = 
{
    0x00000000, 0x00000080, 0x00008000, 0x00008080,
    0x00800000, 0x00800080, 0x00808000, 0x00C0C0C0,
    0x00C0DCC0, 0x00F0CAA6, 0x04081824, 0x04142830,
    0x0418303C, 0x04304D61, 0x0451514D, 0x044D7161,
    0x04826D61, 0x040C1414, 0x04597582, 0x04759E08,
    0x04303438, 0x04AA6938, 0x04203428, 0x04496161,
    0x0449869E, 0x047D9A6D, 0x040869CB, 0x048E8682,
    0x0475615D, 0x040061EB, 0x04000871, 0x042C3830,
    0x040471EF, 0x048E92AA, 0x04306DF7, 0x0404C3C3,
    0x0492AAB2, 0x04101814, 0x04040C08, 0x040C7110,
    0x04CFA282, 0x040008AA, 0x0428412C, 0x04498EB2,
    0x04204D61, 0x04555955, 0x0404D3D3, 0x041C3C4D,
    0x0420A6F7, 0x0410A210, 0x0418241C, 0x045DAEF3,
    0x04719EAA, 0x04B2E720, 0x04102871, 0x0486C3D3,
    0x04288A2C, 0x040C51BA, 0x0459716D, 0x04494D4D,
    0x04AAB6C3, 0x04005100, 0x0420CBF7, 0x044D8A51,
    0x04BEC7B2, 0x04043CBA, 0x04101C18, 0x040851DF,
    0x04A6E7A6, 0x049ECF24, 0x04797592, 0x04AE7559,
    0x049E8269, 0x04CFE3DF, 0x040C2030, 0x0428692C,
    0x049EA2A2, 0x04F7C782, 0x0434617D, 0x04B6BEBE,
    0x04969E86, 0x04DBFBD3, 0x04655149, 0x0465EF65,
    0x04AED3D3, 0x04E7924D, 0x04B2BEB2, 0x04D7DBDB,
    0x04797571, 0x04344D59, 0x0486B2CF, 0x04512C14,
    0x04A6FBFB, 0x04385965, 0x04828E92, 0x041C4161,
    0x04595961, 0x04002000, 0x043C6D7D, 0x045DB2D7,
    0x0438EF3C, 0x0451CB55, 0x041C2424, 0x0461C3F3,
    0x0408A2A2, 0x0438413C, 0x04204951, 0x04108A14,
    0x04103010, 0x047DE7F7, 0x04143449, 0x04B2652C,
    0x04F7EBAA, 0x043C7192, 0x0404FBFB, 0x04696151,
    0x04EFC796, 0x040441D7, 0x04000404, 0x04388AF7,
    0x048AD3F3, 0x04006500, 0x040004E3, 0x04DBFFFF,
    0x04F7AE69, 0x04CF864D, 0x0455A2D3, 0x04EBEFE3,
    0x04EB8A41, 0x04CF9261, 0x04C3F710, 0x048E8E82,
    0x04FBFFFF, 0x04104110, 0x04040851, 0x0482FBFB,
    0x043CC734, 0x04088A8A, 0x04384545, 0x04514134,
    0x043C7996, 0x041C6161, 0x04EBB282, 0x04004100,
    0x04715951, 0x04A2AAA6, 0x04B2B6B2, 0x04C3FBFB,
    0x04000834, 0x0428413C, 0x04C7C7CF, 0x04CFD3D3,
    0x04824520, 0x0408CB0C, 0x041C1C1C, 0x04A6B29A,
    0x0471A6BE, 0x04CF9E6D, 0x046D7161, 0x04008A04,
    0x045171BE, 0x04C7D3C3, 0x04969E96, 0x04798696,
    0x042C1C10, 0x04385149, 0x04BE7538, 0x0408141C,
    0x04C3C7C7, 0x04202C28, 0x04D3E3CF, 0x0471826D,
    0x04653C1C, 0x0404EF08, 0x04345575, 0x046D92A6,
    0x04797979, 0x0486F38A, 0x04925528, 0x04E3E7E7,
    0x04456151, 0x041C499A, 0x04656961, 0x048E9EA2,
    0x047986D3, 0x04204151, 0x048AC7E3, 0x04007100,
    0x04519EBE, 0x0410510C, 0x04A6AAAA, 0x042C3030,
    0x04D37934, 0x04183030, 0x0449828E, 0x04CBFBC3,
    0x046D7171, 0x040428A6, 0x044D4545, 0x04040C14,
    0x04087575, 0x0471CB79, 0x044D6D0C, 0x04FBFBD3,
    0x04AAB2AE, 0x04929292, 0x04F39E55, 0x04005D00,
    0x04E3D7B2, 0x04F7FBC3, 0x043C5951, 0x0404B2B2,
    0x0434658E, 0x040486EF, 0x04F7FBE3, 0x04616161,
    0x04DFE3DF, 0x041C100C, 0x0408100C, 0x0408180C,
    0x04598600, 0x0424FBFB, 0x04346171, 0x04042CC7,
    0x04AEC79A, 0x0445AE4D, 0x0428A62C, 0x04EFA265,
    0x047D8282, 0x04F7D79A, 0x0465D3F7, 0x04E3E7BA,
    0x04003000, 0x04245571, 0x04DF823C, 0x048AAEC3,
    0x04A2C3D3, 0x04A6FBA2, 0x04F3FFF3, 0x04AAD7E7,
    0x04EFEFC3, 0x0455F7FB, 0x04EFF3F3, 0x04BED3B2,
    0x0404EBEB, 0x04A6E3F7, 0x00F0FBFF, 0x00A4A0A0,
    0x00808080, 0x000000FF, 0x0000FF00, 0x0000FFFF,
    0x00FF0000, 0x00FF00FF, 0x00FFFF00, 0x00FFFFFF
};

/*++

 Copy the values stored in DefaultPalette into lppe.

--*/

UINT 
APIHOOK(GetSystemPaletteEntries)(
    HDC hdc,             
    UINT iStartIndex,     
    UINT nEntries,        
    LPPALETTEENTRY lppe
    )
{
    if (lppe)
    {
        memcpy(
            lppe, 
            &DefaultPalette[iStartIndex], 
            nEntries * sizeof(PALETTEENTRY));
    }
    else
    {
        nEntries = 256;
    }
        
    return nEntries;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(GDI32.DLL, GetSystemPaletteEntries)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\forcetemporarymodechange.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceTemporaryModeChange.cpp

 Abstract:

    A hack for several apps that permanently change the display mode and fail
    to restore it correctly. Some of these apps do restore the resolution, but 
    not the refresh rate. 1024x768 @ 60Hz looks really bad.

 Notes:

    This is a general purpose shim.

 History:

    01/20/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceTemporaryModeChange)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsA)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsW)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsExA)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsExW)
APIHOOK_ENUM_END

/*++

 Force temporary change.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsA)(
    LPDEVMODEA lpDevMode,
    DWORD      dwFlags
    )
{
    if (dwFlags != CDS_FULLSCREEN) {
        LOGN(
            eDbgLevelError,
            "[ChangeDisplaySettingsA] Changing flags to CDS_FULLSCREEN.");
    }

    return ORIGINAL_API(ChangeDisplaySettingsA)(
        lpDevMode,
        CDS_FULLSCREEN);
}

/*++

 Force temporary change.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsW)(
    LPDEVMODEW lpDevMode,
    DWORD      dwFlags
    )
{
    if (dwFlags != CDS_FULLSCREEN) {
        LOGN(
            eDbgLevelError,
            "[ChangeDisplaySettingsW] Changing flags to CDS_FULLSCREEN.");
    }

    return ORIGINAL_API(ChangeDisplaySettingsW)(
        lpDevMode,
        CDS_FULLSCREEN);
}

/*++

 Force temporary change.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsExA)(
    LPCSTR     lpszDeviceName,
    LPDEVMODEA lpDevMode,
    HWND       hwnd,
    DWORD      dwflags,
    LPVOID     lParam
    )
{
    if (dwflags != CDS_FULLSCREEN) {
        LOGN(
            eDbgLevelError,
            "[ChangeDisplaySettingsExA] Changing flags to CDS_FULLSCREEN.");
    }

    return ORIGINAL_API(ChangeDisplaySettingsExA)(
        lpszDeviceName, 
        lpDevMode, 
        hwnd, 
        CDS_FULLSCREEN, 
        lParam);
}

/*++

 Force temporary change.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsExW)(
    LPCWSTR    lpszDeviceName,
    LPDEVMODEW lpDevMode,
    HWND       hwnd,
    DWORD      dwflags,
    LPVOID     lParam
    )
{
    if (dwflags != CDS_FULLSCREEN) {
        LOGN(
            eDbgLevelError,
            "[ChangeDisplaySettingsExW] Changing flags to CDS_FULLSCREEN.");
    }

    return ORIGINAL_API(ChangeDisplaySettingsExW)(
        lpszDeviceName, 
        lpDevMode, 
        hwnd, 
        CDS_FULLSCREEN, 
        lParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsA)
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsW)
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsExA)
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\forcesimplewindow.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceSimpleWindow.cpp

 Abstract:

    Make the simplest possible full-screen window.

 Notes:

    This is a general purpose shim, but should not be used in a layer.

 History:

    06/01/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceSimpleWindow)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateWindowExA)
    APIHOOK_ENUM_ENTRY(CreateWindowExW)
    APIHOOK_ENUM_ENTRY(SetWindowLongA)
    APIHOOK_ENUM_ENTRY(SetWindowLongW)
APIHOOK_ENUM_END

BOOL g_bFullScreen = TRUE;

/*++

 Simplify window if it's not a child.
 
--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,
    LPCSTR lpClassName,
    LPCSTR lpWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam 
    )
{
    if (!(dwStyle & WS_CHILD))
    {
        DPFN( eDbgLevelWarning, "Window \"%s\" style simplified: WS_STYLE=%08lx, WS_EXSTYLE=%08lx", lpWindowName, dwStyle, dwExStyle);

        dwStyle &= WS_VISIBLE;
        dwStyle |= WS_OVERLAPPED|WS_POPUP;

        dwExStyle = 0;

        if (g_bFullScreen)
        {
            DPFN( eDbgLevelWarning, "Window \"%s\" maximized", lpWindowName);
            x = y = 0;
            nWidth = GetSystemMetrics(SM_CXSCREEN);
            nHeight = GetSystemMetrics(SM_CYSCREEN);
            dwExStyle = WS_EX_TOPMOST;
        }
    }

    return ORIGINAL_API(CreateWindowExA)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,
        x,
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,
        hInstance,
        lpParam);
}

/*++

 Simplify window if it's not a child.

--*/

HWND 
APIHOOK(CreateWindowExW)(
    DWORD dwExStyle,
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam 
    )
{
    if (!(dwStyle & WS_CHILD))
    {
        DPFN( eDbgLevelWarning, "Window \"%S\" style simplified: WS_STYLE=%08lx, WS_EXSTYLE=%08lx", lpWindowName, dwStyle, dwExStyle);

        dwStyle &= WS_VISIBLE;
        dwStyle |= WS_OVERLAPPED|WS_POPUP;

        dwExStyle = 0;

        if (g_bFullScreen)
        {
            DPFN( eDbgLevelWarning, "Window \"%S\" maximized", lpWindowName);
            x = y = 0;
            nWidth = GetSystemMetrics(SM_CXSCREEN);
            nHeight = GetSystemMetrics(SM_CYSCREEN);
            dwExStyle = WS_EX_TOPMOST;
        }
    }

    return ORIGINAL_API(CreateWindowExW)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,
        x,
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,
        hInstance,
        lpParam);
}

LONG 
APIHOOK(SetWindowLongA)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if ((nIndex == GWL_STYLE) || (nIndex == GWL_EXSTYLE))
    {
        CHAR szName[MAX_PATH];
        GetWindowTextA(hWnd, szName, MAX_PATH);
        DPFN( eDbgLevelWarning, "Window \"%s\": ignoring style change", szName);
        return GetWindowLongA(hWnd, nIndex);
    }
    else
    {
        return ORIGINAL_API(SetWindowLongA)(  
            hWnd,
            nIndex,
            dwNewLong);
    }
}

LONG 
APIHOOK(SetWindowLongW)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if ((nIndex == GWL_STYLE) || (nIndex == GWL_EXSTYLE))
    {
        CHAR szName[MAX_PATH];
        GetWindowTextA(hWnd, szName, MAX_PATH);
        DPFN( eDbgLevelWarning, "Window \"%s\": ignoring style change", szName);
        return GetWindowLongW(hWnd, nIndex);
    }
    else
    {
        return ORIGINAL_API(SetWindowLongW)(  
            hWnd,
            nIndex,
            dwNewLong);
    }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        CString csCl(COMMAND_LINE);
        g_bFullScreen = csCl.CompareNoCase(L"FULLSCREEN") == 0;
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExW)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\forcedisplaymode.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    ForceDisplayMode.cpp

 Abstract:

    This shim is for games that require a specific resolution to run at.

    It takes a command line to specify the resolution: width in pixels, height 
    in pixels,bits per pixel if you don't specify one or more of those, we'll 
    use the current setting.    
    
        eg: 1024,768 will change resolution to 1024x768.
        eg: ,,16 will change the color depth to 16 bit.

 Notes:

    This is a general purpose shim.

 History:

    11/08/2000  maonis      Created (adopted from Force640x480x8 and Force640x480x16 shims)
    03/13/2001  robkenny    Converted to CString

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceDisplayMode)
#include "ShimHookMacro.h"

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

DWORD g_dmPelsWidth = 0;
DWORD g_dmPelsHeight = 0;
DWORD g_dmBitsPerPel = 0;

VOID 
ParseCommandLine(
    LPCSTR lpCommandLine
    )
{
    LPSTR szCommandLine = (LPSTR) malloc(strlen(lpCommandLine) + 1);
    if (!szCommandLine) {
        DPFN( eDbgLevelError, 
           "[ParseCommandLine] not enough memory\n");
        return;
    }

    strcpy(szCommandLine, lpCommandLine);

    char *token, *szCurr = szCommandLine;
    
    if (token = strchr(szCurr, ',')) {
        *token = '\0';
        g_dmPelsWidth = atol(szCurr);
        szCurr = token + 1;

        if (token = strchr(szCurr, ',')) {
            *token = '\0';
            g_dmBitsPerPel = atol(token + 1);
        }

        g_dmPelsHeight = atol(szCurr);
    } else {
        g_dmPelsWidth = atol(szCurr);
    }

    DPFN( eDbgLevelError, 
       "[ParseCommandLine] width = %d pixels; height = %d pixels; color depth = %d\n", g_dmPelsWidth, g_dmPelsHeight, g_dmBitsPerPel);

    free(szCommandLine);
}

VOID
ChangeMode()
{
    DEVMODEA dm;
    BOOL fNeedChange = FALSE;
    
    __try { 
        EnumDisplaySettingsA(NULL, ENUM_CURRENT_SETTINGS, &dm);

        if (g_dmPelsWidth && g_dmPelsWidth != dm.dmPelsWidth) {
            dm.dmPelsWidth = g_dmPelsWidth;
            fNeedChange = TRUE;
        }

        if (g_dmPelsHeight && g_dmPelsHeight != dm.dmPelsHeight) {
            dm.dmPelsHeight = g_dmPelsHeight;
            fNeedChange = TRUE;
        }

        if (g_dmBitsPerPel && g_dmBitsPerPel != dm.dmBitsPerPel) {
            dm.dmBitsPerPel = g_dmBitsPerPel;
            fNeedChange = TRUE;
        }

        if (fNeedChange) {
            ChangeDisplaySettingsA(&dm, CDS_FULLSCREEN);
        }
    }
    __except(1) {
        DPFN( eDbgLevelWarning, "Exception trying to change mode");
    };
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        ParseCommandLine(COMMAND_LINE);
        ChangeMode();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\fusapi.h ===
//  --------------------------------------------------------------------------
//  Module Name: FUSAPI.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to manage communication with the BAM server for shims.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _FUSAPI_
#define     _FUSAPI_

//  --------------------------------------------------------------------------
//  CFUSAPI
//
//  Purpose:    Class that knows how to communicate with the BAM server.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

class   CFUSAPI
{
    private:
                CFUSAPI (void);
    public:
                CFUSAPI (const WCHAR *pszImageName);
                ~CFUSAPI (void);

        bool    IsRunning (void);
        bool    TerminatedFirstInstance (void);
        void    RegisterBadApplication (BAM_TYPE bamType);
    private:
        void    DWORDToString (DWORD dwNumber, WCHAR *pszString);
    private:
        HANDLE  _hPort;
        WCHAR*  _pszImageName;
};

#endif  /*  _FUSAPI_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\forceworkingdirectorytoexepath.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   ForceWorkingDirectoryToEXEPath.cpp

 Abstract:

   This shim forces the working directory to match the executables path in a 
   short cut link. This shim is used in the case of the working directory
   in the link being incorrect and causing the application to work 
   incorrectly.  When this shim is applied the call to SetWorkingDirectory will
   be ignored and will be executed when SetPath is called.

 Notes:

   This is a general purpose shim.

 History:

   09/27/2000 a-brienw Created
   11/15/2000 a-brienw added some error checking as precautionary measure.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceWorkingDirectoryToEXEPath)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_COMSERVER(SHELL32)
APIHOOK_ENUM_END

IMPLEMENT_COMSERVER_HOOK(SHELL32)


HRESULT SetWorkingDirectoryW( PVOID pThis, LPCWSTR pszDir, LPCWSTR pszFile );
HRESULT SetWorkingDirectoryA( PVOID pThis, const CString & csDir, const CString & csFile );


/*++

  Hook IShellLinkA::SetWorkingDirectory and call local
  SetWorkingDirectoryA to handle the input.

--*/

HRESULT STDMETHODCALLTYPE
COMHOOK(IShellLinkA, SetWorkingDirectory)(
    PVOID pThis,
    LPCSTR pszDir
    )
{
    CSTRING_TRY
    {
        CString csDummyPath;
        return SetWorkingDirectoryA( pThis, pszDir, csDummyPath);
    }
    CSTRING_CATCH
    {
        DPFN( eDbgLevelError,"Exception encountered");
    }

    _pfn_IShellLinkA_SetWorkingDirectory pfnSetWorkingDir =
        ORIGINAL_COM(IShellLinkA, SetWorkingDirectory, pThis);
     return((*pfnSetWorkingDir)(pThis, pszDir));
}

/*++

  Hook IShellLinkW::SetWorkingDirectory and call local
  SetWorkingDirectoryW to handle the input.

--*/

HRESULT STDMETHODCALLTYPE
COMHOOK(IShellLinkW, SetWorkingDirectory)(
    PVOID pThis,
    LPCWSTR pszDir
    )
{
    return SetWorkingDirectoryW( pThis, pszDir, NULL );
}

/*++

  Hook IShellLinkA::SetPath and call local
  SetWorkingDirectoryA to handle the input.

--*/

HRESULT STDMETHODCALLTYPE
COMHOOK(IShellLinkA, SetPath)(
    PVOID pThis,
    LPCSTR pszFile
    )
{
    CSTRING_TRY
    {
        CString csDummyPath;
        return SetWorkingDirectoryA( pThis, csDummyPath, pszFile);
    }
    CSTRING_CATCH
    {
         DPFN( eDbgLevelError,"Exception encountered");    
    }

    _pfn_IShellLinkA_SetPath pfnSetPath = ORIGINAL_COM(IShellLinkA, SetPath, pThis);
    return (*pfnSetPath)(pThis, pszFile);
}

/*++

  Hook IShellLinkW::SetPath and call local
  SetWorkingDirectoryW to handle the input.

--*/

HRESULT STDMETHODCALLTYPE
COMHOOK(IShellLinkW, SetPath)(
    PVOID pThis,
    LPCWSTR pszFile
    )
{
    return SetWorkingDirectoryW( pThis, NULL, pszFile );
}

/*++

  This routine handles the input of SetPath and
  SetWorkingDirectory and determines what path
  to really place in the short cut link's working
  directory.

--*/

HRESULT
SetWorkingDirectoryA(
    PVOID pThis,
    const CString & csDir,
    const CString & csFile
    )
{
    char szDir[_MAX_PATH];
    CString csStoredDir;
    bool doit;
    HRESULT hReturn;

    doit = false;
    
    if( csFile.IsEmpty())
    {
        // handle passed in working directory
        IShellLinkA *MyShellLink = (IShellLinkA *)pThis;

        // now call IShellLink::GetWorkingDirectory
        hReturn = MyShellLink->GetWorkingDirectory(
            szDir,
            _MAX_PATH);
        
        // if the stored working directory has not
        // been stored use the one passed in.
        csStoredDir = szDir;
        if (csStoredDir.GetLength() < 1 )
        {
            csStoredDir = csDir;
        }             

        doit = true;
        hReturn = NOERROR;
    }
    else
    {
        _pfn_IShellLinkA_SetPath    pfnSetPath;

        // Look up IShellLink::SetPath
        pfnSetPath = (_pfn_IShellLinkA_SetPath)
            ORIGINAL_COM( IShellLinkA, SetPath, pThis);

        // build working directory from exe path & name
        int len;
        csStoredDir = csFile;

        // now search backwards from the end of the string
        // for the first \ and terminate the string there
        // making that the new path.
        len = csStoredDir.ReverseFind(L'\\');
        if (len > 0)
        {            
            doit = true;
            csStoredDir.Truncate(len);
            if(csStoredDir[0] == L'"')
            {
                csStoredDir += L'"';
            }
        }

        // now call the IShellLink::SetPath
        hReturn = (*pfnSetPath)( pThis, csFile.GetAnsi());
    }

    // if there was no error
    if (hReturn == NOERROR)
    {
        // and we have a working directory to set
        if( doit == true )
        {
            _pfn_IShellLinkA_SetWorkingDirectory    pfnSetWorkingDirectory;

            // Look up IShellLink::SetWorkingDirectory
            pfnSetWorkingDirectory = (_pfn_IShellLinkA_SetWorkingDirectory)
                ORIGINAL_COM( IShellLinkA, SetWorkingDirectory, pThis);

            // now call the IShellLink::SetWorkingDirectory
            if( pfnSetWorkingDirectory != NULL )
            {
                hReturn = (*pfnSetWorkingDirectory)(
                    pThis,
                    csStoredDir.GetAnsi());
            }
            else
            {
                hReturn = E_OUTOFMEMORY;
            }
        }
    }

    // return the error status
    return( hReturn );
}

/*++

  This routine handles the input of SetPath and
  SetWorkingDirectory and determines what path
  to really place in the short cut link's working
  directory.

--*/

HRESULT
SetWorkingDirectoryW(
    PVOID pThis,
    LPCWSTR pszDir,
    LPCWSTR pszFile
    )
{
    wchar_t szDir[_MAX_PATH];
    bool doit;
    HRESULT hReturn;

    doit = false;
    
    if( pszFile == NULL )
    {
        // handle passed in working directory
        IShellLinkW *MyShellLink = (IShellLinkW *)pThis;

        // now call IShellLink::GetWorkingDirectory
        hReturn = MyShellLink->GetWorkingDirectory(
            szDir,
            _MAX_PATH);
        
        // if the stored working directory has not
        // been stored use the one passed in.
        if( wcslen(szDir) < 1 )
            wcscpy( szDir, pszDir );

        doit = true;
        hReturn = NOERROR;
    }
    else
    {
        _pfn_IShellLinkW_SetPath    pfnSetPath;

        // Look up IShellLink::SetPath
        pfnSetPath = (_pfn_IShellLinkW_SetPath)
            ORIGINAL_COM( IShellLinkW, SetPath, pThis);

        // build working directory from exe path & name
        int len, i;

        len = wcslen( pszFile );
        wcscpy( szDir, pszFile );

        // now search backwards from the end of the string
        // for the first \ and terminate the string there
        // making that the new path.
        for( i = len; i > 0; i-- )
        {
            if( szDir[i] == L'\\' )
            {
                szDir[i] = L'\0';
                doit = true;

                // if it starts with a QUOTE it must
                // also end with a QUOTE.
                if( szDir[0] == L'"' )
                    wcscat( szDir, L"\"" );

                break;
            }
        }

        // now call the IShellLink::SetPath
        hReturn = (*pfnSetPath)( pThis, pszFile );
    }

    // if there was no error
    if (hReturn == NOERROR)
    {
        // and we have a working directory to set
        if( doit == true )
        {
            _pfn_IShellLinkW_SetWorkingDirectory    pfnSetWorkingDirectory;

            // Look up IShellLink::SetWorkingDirectory
            pfnSetWorkingDirectory = (_pfn_IShellLinkW_SetWorkingDirectory)
                ORIGINAL_COM( IShellLinkW, SetWorkingDirectory, pThis);

            // now call the IShellLink::SetWorkingDirectory
            if( pfnSetWorkingDirectory != NULL )
            {
                hReturn = (*pfnSetWorkingDirectory)(
                    pThis,
                    szDir);
            }
            else
            {
                hReturn = E_OUTOFMEMORY;
            }
        }
    }

    // return the error status
    return( hReturn );
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_COMSERVER(SHELL32)

    COMHOOK_ENTRY(ShellLink, IShellLinkA, SetWorkingDirectory, 9)
    COMHOOK_ENTRY(ShellLink, IShellLinkW, SetWorkingDirectory, 9)
    COMHOOK_ENTRY(ShellLink, IShellLinkA, SetPath, 20)
    COMHOOK_ENTRY(ShellLink, IShellLinkW, SetPath, 20)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\fusbadapplicationtype2.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: FUSBadApplicationType2.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Shim code to register a process as a BAM type 2.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------

#include "precomp.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lpcfus.h>

#include "FUSAPI.h"

IMPLEMENT_SHIM_BEGIN(FUSBadApplicationType2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

//  --------------------------------------------------------------------------
//  InitializeHooks
//
//  Arguments:  fdwReason   =   DLL attach reason.
//
//  Returns:    <none>
//
//  Purpose:    Hooks whatever it necessary during process startup of a known
//              bad application.
//
//              For type 1 applications register the process as bad.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
   switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            CFUSAPI     fusAPI(NULL);

            fusAPI.RegisterBadApplication(BAM_TYPE_SWITCH_USER);
            break;
        }
        default:
            break;
    }

   return TRUE;
}


HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\fusbadapplicationtype1.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: FUSBadApplicationType1.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Shim code to register a process as a BAM type 1.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------

#include "precomp.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lpcfus.h>

#include "FUSAPI.h"

IMPLEMENT_SHIM_BEGIN(FUSBadApplicationType1)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

//  --------------------------------------------------------------------------
//  InitializeHooks
//
//  Arguments:  fdwReason   =   DLL attach reason.
//
//  Returns:    <none>
//
//  Purpose:    Hooks whatever it necessary during process startup of a known
//              bad application.
//
//              For type 1 applications if the image is already running then
//              try to terminate the first instance if possible. Prompt the
//              user to give some input. If the termination succeeds treat
//              this like it's not running. In that case register this process
//              as the instance that's bad.
//
//              Otherwise exit this process. Don't give it a chance to run.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
   switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            CFUSAPI     fusAPI(NULL);

            if (!fusAPI.IsRunning() || fusAPI.TerminatedFirstInstance())
            {
                fusAPI.RegisterBadApplication(BAM_TYPE_SECOND_INSTANCE_START);
            }
            else
            {
                ExitProcess(0);
            }
            break;
        }
        default:
            break;
    }

   return TRUE;
}


HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\fusbadapplicationtype4.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: FUSBadApplicationType4.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Shim code to register a process as a BAM type 4.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------

#include "precomp.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lpcfus.h>

#include "FUSAPI.h"


IMPLEMENT_SHIM_BEGIN(FUSBadApplicationType4)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

//  --------------------------------------------------------------------------
//  InitializeHooks
//
//  Arguments:  fdwReason   =   DLL attach reason.
//
//  Returns:    <none>
//
//  Purpose:    Hooks whatever it necessary during process startup of a known
//              bad application.
//
//              For type 4 applications register the process as bad.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            CFUSAPI     fusAPI(NULL);

            fusAPI.RegisterBadApplication(BAM_TYPE_SWITCH_TO_NEW_USER);
            break;
        }
        default:
            break;
    }

   return TRUE;
}


HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\fusbadapplicationtype3.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: FUSBadApplicationType3.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Shim code to register a process as a BAM type 3.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------

#include "precomp.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lpcfus.h>

#include "FUSAPI.h"


IMPLEMENT_SHIM_BEGIN(FUSBadApplicationType3)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

//  --------------------------------------------------------------------------
//  InitializeHooks
//
//  Arguments:  fdwReason   =   DLL attach reason.
//
//  Returns:    <none>
//
//  Purpose:    Hooks whatever it necessary during process startup of a known
//              bad application.
//
//              For type 1 applications register the process as bad.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            CFUSAPI     fusAPI(NULL);

            fusAPI.RegisterBadApplication(BAM_TYPE_SWITCH_TO_NEW_USER_WITH_RESTORE);
            break;
        }
        default:
            break;
    }

   return TRUE;
}


HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\globalmemorystatuslie.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    GlobalMemoryStatusLie.cpp

 Abstract:

    Lies about the amount of swap space returned from the
    GlobalMemoryStatus API so app will think it has a huge
    swap space like it did on win98.

 Notes:

    This is a general purpose shim.

 History:

    05/08/2001 mnikkel  Created

--*/

#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(GlobalMemoryStatusLie)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GlobalMemoryStatus)
APIHOOK_ENUM_END



/*++

   Increase the Available page file size to 400 mb.

--*/

VOID
APIHOOK(GlobalMemoryStatus)( 
        LPMEMORYSTATUS lpBuffer
)
{
    ORIGINAL_API(GlobalMemoryStatus)(lpBuffer);

    // change page file size to 400 mb.
    lpBuffer->dwAvailPageFile = 0x17D78400;

    return;
}



/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GlobalMemoryStatus)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\fusapi.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: FUSAPI.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to manage communication with the BAM server for shims.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------

#include "precomp.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lpcfus.h>

#include "FUSAPI.h"

#ifndef ARRAYSIZE
   #define ARRAYSIZE(x)    (sizeof(x) / sizeof((x)[0]))
#endif
#define TBOOL(x)        (BOOL)(x)
#define TSTATUS(x)      (NTSTATUS)(x)

//  --------------------------------------------------------------------------
//  CFUSAPI::CFUSAPI
//
//  Arguments:  pszImageName    =   Image name of the desired process.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CFUSAPI. Establishes a connection with the
//              BAM server. Saves off the image name given or the image name
//              of the current process if not specified.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

CFUSAPI::CFUSAPI (const WCHAR *pszImageName) :
    _hPort(NULL),
    _pszImageName(NULL)

{
    ULONG                           ulConnectionInfoLength;
    UNICODE_STRING                  portName, *pImageName;
    SECURITY_QUALITY_OF_SERVICE     sqos;
    WCHAR                           szConnectionInfo[32];

    RtlInitUnicodeString(&portName, FUS_PORT_NAME);
    sqos.Length = sizeof(sqos);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = TRUE;
    lstrcpyW(szConnectionInfo, FUS_CONNECTION_REQUEST);
    ulConnectionInfoLength = sizeof(szConnectionInfo);
    TSTATUS(NtConnectPort(&_hPort,
                          &portName,
                          &sqos,
                          NULL,
                          NULL,
                          NULL,
                          szConnectionInfo,
                          &ulConnectionInfoLength));
    if (pszImageName != NULL)
    {
        _pszImageName = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, (lstrlen(pszImageName) + sizeof('\0')) * sizeof(WCHAR)));
        if (_pszImageName != NULL)
        {
            (TCHAR*)lstrcpy(_pszImageName, pszImageName);
        }
    }
    else
    {
        pImageName = &NtCurrentPeb()->ProcessParameters->ImagePathName;
        _pszImageName = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, pImageName->Length + sizeof(WCHAR)));
        if (_pszImageName != NULL)
        {
            CopyMemory(_pszImageName, pImageName->Buffer, pImageName->Length);
            _pszImageName[pImageName->Length / sizeof(WCHAR)] = L'\0';
        }
    }
}

//  --------------------------------------------------------------------------
//  CFUSAPI::~CFUSAPI
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CFUSAPI. Releases resources used by the class.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

CFUSAPI::~CFUSAPI (void)

{
    if (_pszImageName != NULL)
    {
        (HLOCAL)LocalFree(_pszImageName);
        _pszImageName = NULL;
    }
    if (_hPort != NULL)
    {
        TBOOL(CloseHandle(_hPort));
        _hPort = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CFUSAPI::IsRunning
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Asks the BAM server is the image name running?
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

bool    CFUSAPI::IsRunning (void)

{
    bool    fResult;

    fResult = false;
    if ((_hPort != NULL) && (_pszImageName != NULL))
    {
        FUSAPI_PORT_MESSAGE     portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiBAM.apiGeneric.ulAPINumber = API_BAM_QUERYRUNNING;
        portMessageIn.apiBAM.apiSpecific.apiQueryRunning.in.pszImageName = _pszImageName;
        portMessageIn.apiBAM.apiSpecific.apiQueryRunning.in.cchImageName = lstrlenW(_pszImageName) + sizeof('\0');
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_BAM);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(FUSAPI_PORT_MESSAGE));
        if (NT_SUCCESS(NtRequestWaitReplyPort(_hPort, &portMessageIn.portMessage, &portMessageOut.portMessage)) &&
            NT_SUCCESS(portMessageOut.apiBAM.apiGeneric.status))
        {
            fResult = portMessageOut.apiBAM.apiSpecific.apiQueryRunning.out.fResult;
        }
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CFUSAPI::TerminatedFirstInstance
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Starts a child process to bring up UI for the current process.
//              The current process is shim'd typically as a BAM type 1
//              process. The child process makes the decision and presents
//              appropriate UI and returns the result to this process in the
//              exit code. This process then makes a decision on what to do.
//              The process is halted waiting for the child process (with the
//              loader lock held).
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

bool    CFUSAPI::TerminatedFirstInstance (void)

{
    bool                    fResult;
    HANDLE                  hProcess;
    STARTUPINFO             startupInfo;
    PROCESS_INFORMATION     processInformation;
    WCHAR                   szCommandLine[MAX_PATH];

    fResult = false;
    (DWORD)ExpandEnvironmentStringsW(L"%systemroot%\\system32\\rundll32.exe %systemroot%\\system32\\shsvcs.dll,FUSCompatibilityEntry prompt", szCommandLine, ARRAYSIZE(szCommandLine));
    if (DuplicateHandle(GetCurrentProcess(),
                        GetCurrentProcess(),
                        GetCurrentProcess(),
                        &hProcess,
                        PROCESS_VM_READ | PROCESS_QUERY_INFORMATION,
                        TRUE,
                        0) != FALSE)
    {
        WCHAR   szProcessHandle[16];

        DWORDToString(HandleToULong(hProcess), szProcessHandle);
        (WCHAR*)lstrcatW(szCommandLine, L" ");
        (WCHAR*)lstrcatW(szCommandLine, szProcessHandle);
    }
    else
    {
        hProcess = NULL;
    }
    ZeroMemory(&startupInfo, sizeof(startupInfo));
    ZeroMemory(&processInformation, sizeof(processInformation));
    startupInfo.cb = sizeof(startupInfo);
    if (CreateProcessW(NULL,
                       szCommandLine,
                       NULL,
                       NULL,
                       TRUE,
                       0,
                       NULL,
                       NULL,
                       &startupInfo,
                       &processInformation) != FALSE)
    {
        DWORD   dwExitCode;

        TBOOL(CloseHandle(processInformation.hThread));
        (DWORD)WaitForSingleObject(processInformation.hProcess, INFINITE);
        dwExitCode = 0;
        TBOOL(GetExitCodeProcess(processInformation.hProcess, &dwExitCode));
        fResult = (dwExitCode != 0);
        TBOOL(CloseHandle(processInformation.hProcess));
    }
    if (hProcess != NULL)
    {
        TBOOL(CloseHandle(hProcess));
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CFUSAPI::RegisterBadApplication
//
//  Arguments:  bamType     =   BAM type of the current process.
//
//  Returns:    <none>
//
//  Purpose:    Registers with the BAM server this process (image name) as a
//              bad application of type whatever is passed in. The different
//              BAM shims pass in different parameters.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

void    CFUSAPI::RegisterBadApplication (BAM_TYPE bamType)

{
    if ((_hPort != NULL) && (_pszImageName != NULL))
    {
        FUSAPI_PORT_MESSAGE     portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiBAM.apiGeneric.ulAPINumber = API_BAM_REGISTERRUNNING;
        portMessageIn.apiBAM.apiSpecific.apiRegisterRunning.in.pszImageName = _pszImageName;
        portMessageIn.apiBAM.apiSpecific.apiRegisterRunning.in.cchImageName = lstrlen(_pszImageName) + sizeof('\0');
        portMessageIn.apiBAM.apiSpecific.apiRegisterRunning.in.dwProcessID = GetCurrentProcessId();
        portMessageIn.apiBAM.apiSpecific.apiRegisterRunning.in.bamType = bamType;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_BAM);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(FUSAPI_PORT_MESSAGE));
        TSTATUS(NtRequestWaitReplyPort(_hPort, &portMessageIn.portMessage, &portMessageOut.portMessage));
    }
}

//  --------------------------------------------------------------------------
//  CFUSAPI::DWORDToString
//
//  Arguments:  dwNumber    =   DWORD to convert to a string.
//              pszString   =   Buffer that gets the result.
//
//  Returns:    <none>
//
//  Purpose:    Implements wsprintf(pszString, TEXT("%ld"), dwNumber) because
//              this code CANNOT use user32 imports.
//
//  History:    2000-11-08  vtan        created
//  --------------------------------------------------------------------------

void    CFUSAPI::DWORDToString (DWORD dwNumber, WCHAR *pszString)

{
    int     i;
    WCHAR   szTemp[16];

    i = 0;
    do
    {
        szTemp[i++] = L'0' + static_cast<WCHAR>(dwNumber % 10);
        dwNumber /= 10;
    } while (dwNumber != 0);
    do
    {
        --i;
        *pszString++ = szTemp[i];
    } while (i != 0);
    *pszString = L'\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\heapforcegrowable.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HeapForceGrowable.cpp

 Abstract:
     
    Remove upper limit on heap calls by setting the maximum size to zero, which
    means that the heap will grow to accomodate new allocations.
     
 Notes:

    This is a general purpose shim.

 History:
                            
    04/25/2000 linstev  Created
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HeapForceGrowable)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(HeapCreate) 
APIHOOK_ENUM_END

/*++

 Fix the heap so it can grow.

--*/

HANDLE
APIHOOK(HeapCreate)(
    DWORD flOptions,      
    DWORD dwInitialSize,  
    DWORD dwMaximumSize   
    )
{
    if (dwMaximumSize)
    {
        LOGN( eDbgLevelError,
            "[APIHook_HeapCreate] Setting heap maximum to 0.");
        dwMaximumSize = 0;
    }

    return ORIGINAL_API(HeapCreate)(flOptions, dwInitialSize, dwMaximumSize);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, HeapCreate)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\heapignoremoveable.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HeapIgnoreMoveable.cpp

 Abstract:

    After 64k calls to GlobalAlloc, we are no longer able to use the 
    GMEM_MOVEABLE flag. This shim just filters it in the case of 
    GlobalAlloc failing.

    This is a known issue with the heap manager on NT and is a won't fix. 
    
    According to adrmarin:

        The table with handles cannot grow dynamic. The initial size is 
        hardcoded to 64k handles. Increasing this number will affect the 
        reserved address for each process. 

    See Whistler bug #147032.

 Notes:

    This is a general purpose shim - superceded by EmulateHeap.

 History:

    02/19/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HeapIgnoreMoveable)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GlobalAlloc)
APIHOOK_ENUM_END

/*++

 Remove the GMEM_MOVEABLE flag in the case of failure.

--*/

HGLOBAL 
APIHOOK(GlobalAlloc)(
    UINT uFlags,    
    DWORD dwBytes   
    )
{
    HGLOBAL hRet = ORIGINAL_API(GlobalAlloc)(uFlags, dwBytes);

    if (hRet == NULL)
    {
        hRet = ORIGINAL_API(GlobalAlloc)(
            uFlags & ~GMEM_MOVEABLE, dwBytes);
    }

    return hRet;
}
 
/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalAlloc)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\handledbcsusername2.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

   HandleDBCSUserName2.cpp

 Abstract:

   Disable DBCS handling for CharNextA if the string is DBCS user profile
   for non-DBCS enabled application support.

 More info:

   Return next byte address instead of next character address.

 History:

    05/01/2001  geoffguo        Created

--*/

#include "precomp.h"


IMPLEMENT_SHIM_BEGIN(HandleDBCSUserName2)
#include "ShimHookMacro.h"

#define MAX_USERNAME 256

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CharNextA) 
APIHOOK_ENUM_END

//
// Checking if the string is user profile path
//
BOOL IsUserProfilePath(
    LPCSTR lpCurrentChar)
{
    LPSTR  lpChar = (LPSTR)lpCurrentChar;
    BOOL   bRet = FALSE;
    char   szBuf[10];

    while (lpChar != NULL && *lpChar != (char)NULL 
        && (lpCurrentChar - lpChar) < MAX_USERNAME+25) {
        //to find ":\Documents and Settings" (short name is :\DOCUME~1) in path
        if (*lpChar == (char) ':') {
            lstrcpynA (szBuf, lpChar, 9);
            szBuf[8] = (char) NULL;
            if (lstrcmpiA (szBuf, ":\\DOCUME") == 0) {
                bRet = TRUE;
                break;
            }
        }
        lpChar--;
    }

    return bRet;
}

//
// Disable DBCS handling for CharNextA
//
LPSTR
APIHOOK(CharNextA)(
    LPCSTR lpCurrentChar)
{
    if (lpCurrentChar != NULL && *lpCurrentChar != (char)NULL) {
        // Disable DBCS support for DBCS username in user profile path
        if (IsDBCSLeadByte(*lpCurrentChar) && !IsUserProfilePath(lpCurrentChar))
            lpCurrentChar++;

        lpCurrentChar++;
    }

    return (LPSTR)lpCurrentChar;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, CharNextA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\heapdelaylocalfree.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   HeapDelayLocalFree.cpp

 Abstract:

   Delay calls to LocalFree.

 History:

   09/19/2000 robkenny

--*/

#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(HeapDelayLocalFree)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LocalFree)
APIHOOK_ENUM_END

CRITICAL_SECTION            g_CritSec;
static VectorT<HLOCAL>     *g_DelayLocal            = NULL;
static DWORD                g_DelayBufferSize       = 20;

HLOCAL 
APIHOOK(LocalFree)(
    HLOCAL hMem   // handle to local memory object
)
{
    if (hMem == NULL)
        return NULL;

    if (g_DelayLocal)
    {
        EnterCriticalSection(&g_CritSec);

        // If the list is full
        if (g_DelayLocal->Size() > 0 &&
            g_DelayLocal->Size() >= g_DelayLocal->MaxSize())
        {
            HLOCAL & hDelayed = g_DelayLocal->Get(0);
#if DBG
            DPFN(eDbgLevelInfo, "LocalFree(0x%08x).", hDelayed);
#endif
            ORIGINAL_API(LocalFree)(hDelayed);

            g_DelayLocal->Remove(0);
        }

        g_DelayLocal->Append(hMem);
#if DBG
        DPFN(eDbgLevelInfo, "Delaying LocalFree(0x%08x).", hMem);
#endif
       
        LeaveCriticalSection(&g_CritSec);
        
        return NULL;
    }

    HLOCAL returnValue = ORIGINAL_API(LocalFree)(hMem);
    return returnValue;
}

BOOL ParseCommandLine(const char * commandLine)
{
    InitializeCriticalSection(&g_CritSec);

    g_DelayLocal = new VectorT<HLOCAL>;

    if (g_DelayLocal)
    {
        // If we cannot resize the array, stop now
        if (!g_DelayLocal->Resize(g_DelayBufferSize))
        {
            delete g_DelayLocal;
            g_DelayLocal = NULL;

            // Turn off all hooks:
            return FALSE;
        }
    }

    return TRUE;
}

/*++

  Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        return ParseCommandLine(COMMAND_LINE);
    }
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        if (g_DelayLocal)
        {
            delete g_DelayLocal;
            g_DelayLocal = NULL;
        }

        DeleteCriticalSection(&g_CritSec);
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, LocalFree)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\grabmatchinginformation.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    GrabMatchingInformation.cpp

 Abstract:

    Upon ProcessAttach the shim gathers matching information from the current 
    directory.

 Notes:

    This is a general purpose shim.

 History:

    20-Oct-2000   jdoherty    Created

--*/
#include "precomp.h"
#include <stdio.h>

// This module is *not* DBCS safe, but should only be used by our testers
// We should, eventually, correct this file.
// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(GrabMatchingInformation)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineA) 
    APIHOOK_ENUM_ENTRY(GetCommandLineW) 
APIHOOK_ENUM_END

BOOL gbCalledHook;
LPSTR glpOriginalRootDir;
VOID GrabMatchingInformationMain();
BOOL GrabMatchingInfo(LPSTR lpRootDirectory, HANDLE hStorageFile, int nLevel);
BOOL GetRelativePath(LPSTR lpPathFromRoot, LPCSTR lpSubDir, LPCSTR lpFileName);
VOID AddMatchingFile( LPSTR lpData, LPCSTR pszFullPath, LPCSTR pszRelativePath );

LPSTR 
APIHOOK(GetCommandLineA)()
{
    if (!gbCalledHook)
    {
        int     nLength = 0;
        LPSTR   lpCursorEnd;
        
        glpOriginalRootDir = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));
        
        GetModuleFileNameA( NULL, glpOriginalRootDir, MAX_PATH );
        nLength = strlen( glpOriginalRootDir );
        lpCursorEnd = &glpOriginalRootDir[nLength-1];
        
        while( --nLength )
        {
            if ( *(lpCursorEnd) == '\\' )
            {
                *(lpCursorEnd) = '\0';
                break;
            }
            lpCursorEnd--;
            if (nLength==0)
            {
                GetCurrentDirectoryA( MAX_PATH, glpOriginalRootDir );
            }
        }
        GrabMatchingInformationMain();
        ShimFree(glpOriginalRootDir);
        gbCalledHook = TRUE;
    }
    
    return ORIGINAL_API(GetCommandLineA)();
}

LPWSTR 
APIHOOK(GetCommandLineW)()
{
    if (!gbCalledHook)
    {
        int     nLength = 0;
        LPSTR   lpCursorEnd;
        
        glpOriginalRootDir = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));
        
        GetModuleFileNameA( NULL, glpOriginalRootDir, MAX_PATH );
        nLength = strlen( glpOriginalRootDir );
        lpCursorEnd = &glpOriginalRootDir[nLength-1];
        
        while( --nLength )
        {
            if ( *(lpCursorEnd) == '\\' )
            {
                *(lpCursorEnd) = '\0';
                break;
            }
            lpCursorEnd--;
            if (nLength==0)
            {
                GetCurrentDirectoryA( MAX_PATH, glpOriginalRootDir );
            }
        }
        GrabMatchingInformationMain();
        ShimFree(glpOriginalRootDir);
        gbCalledHook = TRUE;
    }

    return ORIGINAL_API(GetCommandLineW)();
}


VOID GrabMatchingInformationMain()
{
    HANDLE hMutexHandle;
    LPSTR lpStorageFilePath;
    LPSTR lpDirInfo;
    LPSTR lpRootDir;
    HANDLE hStorageFile;
    DWORD  dwBytesWritten = 0;

    lpStorageFilePath = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));
    lpDirInfo = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));
    lpRootDir = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));


    // Setup a mutex so only one process at a time can write to the matchinginfo.txt file.
    hMutexHandle = CreateMutexA( NULL, FALSE, "MyGrabMIFileMutex" );
    WaitForSingleObject( hMutexHandle, INFINITE );

    // Build path to where the matching information will be stored.
    SHGetSpecialFolderPathA(NULL, lpStorageFilePath, CSIDL_DESKTOPDIRECTORY, TRUE );
    strcat( lpStorageFilePath, "\\matchinginfo.txt" );

/*
    if ( (strcmp(glpOriginalRootDir ,".") == 0) || (strcmp(glpOriginalRootDir ,"") == 0) )
    {
        GetCurrentDirectoryA( MAX_PATH, glpOriginalRootDir );
    }
*/
    // Open matchinginfo.txt on the desktop for write if it exists and set the file pointer to the end
    // of the file, create a new file otherwise.
    hStorageFile = CreateFileA( lpStorageFilePath, 
                                GENERIC_WRITE, 
                                0, 
                                NULL, 
                                OPEN_ALWAYS, 
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

    SetFilePointer( hStorageFile, NULL, NULL, FILE_END );

    if (hStorageFile == INVALID_HANDLE_VALUE)
    {
        return;
    }
    sprintf(lpDirInfo, "<!-- Generating matching information for files in: [ %s ]For Process: [ %s ]-->\r\n", 
            glpOriginalRootDir,
            GetCommandLineA()
            );
    WriteFile( hStorageFile, lpDirInfo, strlen(lpDirInfo), &dwBytesWritten, NULL );
    strcpy(lpRootDir, glpOriginalRootDir);

    if (!GrabMatchingInfo(lpRootDir, hStorageFile, 0))
    {
        CloseHandle(hStorageFile);
        return;
    }

    CloseHandle(hStorageFile);

    ShimFree(lpStorageFilePath);
    ShimFree(lpDirInfo);
    ShimFree(lpRootDir);

    ReleaseMutex( hMutexHandle );

    return;
}

/*++

 This function traverses lpRootDirectory and it's subdirectories while storing the 
 size and checksum for the files in those directories. 

--*/
BOOL GrabMatchingInfo(LPSTR lpRootDirectory, HANDLE hStorageFile, int nLevel)
{

    WIN32_FIND_DATAA FindFileData;
    HANDLE hSearch;                         // Search handle returned by FindFirstFile
    LPSTR lpSubDir;
    LPSTR lpFilePath;
    LPSTR lpData;
    LPSTR lpPathFromRoot;
    DWORD  dwBytesWritten = 0;

    int cbFileCounter = 0;
    lpSubDir = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));
    lpFilePath = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));
    lpData = (LPSTR) ShimMalloc((MAX_PATH*2)*sizeof(LPSTR));
    lpPathFromRoot = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));

    // Just repeat displaying a dot so the user knows something is happening.
    // USED IN GRABMI
    // printf(".");

    strcpy (lpSubDir, lpRootDirectory);

    strcat(lpRootDirectory, "\\*");

    if ( (hSearch=FindFirstFileA( lpRootDirectory, &FindFileData )) == INVALID_HANDLE_VALUE )
    {
        return FALSE;
    }

    BOOL bRepeat = FALSE;

    while ( (strcmp( FindFileData.cFileName, "." ) == 0) || (strcmp( FindFileData.cFileName, ".." ) == 0) && !bRepeat )
    {
        FindNextFileA(hSearch, &FindFileData);
        if ( strcmp( FindFileData.cFileName, ".." ) == 0 )
            bRepeat = TRUE;
    }

    if (!FindNextFileA(hSearch, &FindFileData))
    {
        return TRUE;
    }

    do 
    {
        if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            // Build path for matching file
            strcpy(lpFilePath, lpSubDir);
            strcat(lpFilePath, "\\");
            strcat(lpFilePath, FindFileData.cFileName);

            ZeroMemory( lpData, (MAX_PATH*2)*sizeof(LPSTR) );

            //  Determine the relative path for the file from the original root directory.
            if (!GetRelativePath(lpPathFromRoot, lpSubDir, FindFileData.cFileName))
                strcpy(lpPathFromRoot, FindFileData.cFileName);

            // Check to see if there is version information for the specified file and whether it is 
            // an .exe, .icd, ._MP, or .dll.  If so add the information to the file.
            if ( stristr(lpFilePath, ".exe") || 
                 stristr(lpFilePath, ".icd") ||
                 stristr(lpFilePath, "._MP") ||
                 stristr(lpFilePath, ".dll") )
            {
                AddMatchingFile( lpData, lpFilePath, lpPathFromRoot );
            } else
            {
                // Limit the amount of info gathered to 10 files per directory excluding the above file types.
                if (cbFileCounter < 10)
                {
                    cbFileCounter++;
                    AddMatchingFile( lpData, lpFilePath, lpPathFromRoot );
                }
            }

            // Write the information stored in lpData to the file
            WriteFile( hStorageFile, lpData, strlen(lpData), &dwBytesWritten, NULL );
        }
    } while ( FindNextFileA( hSearch, &FindFileData ) );

    /////////////////////////////////////////////////////////////////////////////////
    //
    // Now go through the directory again and go into the subdirectories
    //
    /////////////////////////////////////////////////////////////////////////////////
    if (strlen(lpRootDirectory) < 4)
    {
        if ( (hSearch=FindFirstFileA(lpRootDirectory, &FindFileData)) == INVALID_HANDLE_VALUE)
        {
            return FALSE;
        }
    } else
    {
        if ( (hSearch=FindFirstFileA(lpRootDirectory, &FindFileData)) == INVALID_HANDLE_VALUE)
        {
            return FALSE;
        }
        FindNextFileA(hSearch, &FindFileData);
        if (!FindNextFileA(hSearch, &FindFileData))
        {
            FindClose( hSearch );
            return TRUE;
        }
    }

    do
    {
        if ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && nLevel < 3)
        {
            strcat(lpSubDir, "\\");
            strcat(lpSubDir, FindFileData.cFileName);

            GrabMatchingInfo (lpSubDir, hStorageFile, nLevel+1);
            lpSubDir[strlen(lpSubDir)-2]='\0';

            strcpy(lpSubDir, lpRootDirectory);
            lpSubDir[strlen(lpSubDir)-2]='\0';
        }
    }while ( FindNextFileA( hSearch, &FindFileData ) ); 

    FindClose(hSearch);

    ShimFree(lpSubDir);
    ShimFree(lpFilePath);
    ShimFree(lpData);
    ShimFree(lpPathFromRoot);

    return TRUE;
}

BOOL GetRelativePath(LPSTR lpPathFromRoot, LPCSTR lpSubDir, LPCSTR lpFileName)
{

    int difference=(strlen(lpSubDir)-strlen(glpOriginalRootDir));
    if (difference)
    {
        for (int i=0; i < difference; i++)
        {
            lpPathFromRoot[i] = lpSubDir[strlen(glpOriginalRootDir)+i+1];
        }
        strcat(lpPathFromRoot, "\\");
        strcat(lpPathFromRoot, lpFileName);
        difference=0;
        return TRUE;
    }
    return FALSE;
}

/*++
    AddMatchingFile

    Description:    Adds a matching file and it's attributes to the tree.

--*/
VOID AddMatchingFile(
                    OUT LPSTR lpData, 
                    IN LPCSTR pszFullPath, 
                    IN LPCSTR pszRelativePath )
{
    PATTRINFO   pAttrInfo;
    DWORD       dwAttrCount;

    LPWSTR      pwszFullPath;
    pwszFullPath = (LPWSTR) ShimMalloc(MAX_PATH*sizeof(LPWSTR));
    mbstowcs( pwszFullPath, pszFullPath, MAX_PATH );

    //
    // Call the attribute manager to get all the attributes for this file.
    //
    if (SdbGetFileAttributes(pwszFullPath, &pAttrInfo, &dwAttrCount))
    {
        LPSTR       lpBuffer;
        LPWSTR      lpwBuffer;

        lpBuffer = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));
        lpwBuffer = (LPWSTR) ShimMalloc(MAX_PATH*sizeof(LPWSTR));

        //
        // Loop through all the attributes and show the ones that are available.
        //
//        ZeroMemory( lpData, (MAX_PATH*2)*sizeof(LPSTR) );

        sprintf(lpData, "<MATCHING_FILE NAME=\"%s\" ", pszRelativePath);
        for (DWORD i = 0; i < dwAttrCount; ++i)
        {
            if ( SdbFormatAttribute(&pAttrInfo[i], lpwBuffer, MAX_PATH) )//CHARCOUNT(lpwBuffer))) 
            {
                ZeroMemory( lpBuffer, MAX_PATH*sizeof(LPSTR) );
                wcstombs( lpBuffer, lpwBuffer, wcslen (lpwBuffer) );
                //
                // wszBuffer has XML for this attribute
                //
                strcat( lpData, lpBuffer );
                strcat( lpData, " " );
            }
        }
        strcat( lpData, "/>\r\n" );
        ShimFree( lpBuffer );
        ShimFree( lpwBuffer );
        SdbFreeFileAttributes(pAttrInfo);
    }
    ShimFree( pwszFullPath );
}

/*++

 Handle DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH in your notify function
 to do initialization and uninitialization.

 IMPORTANT: Make sure you ONLY call NTDLL, KERNEL32 and MSVCRT APIs during
 DLL_PROCESS_ATTACH notification. No other DLLs are initialized at that
 point.
 
 If your shim cannot initialize properly, return FALSE and none of the
 APIs specified will be hooked.
 
--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        gbCalledHook = FALSE;

        DPFN( eDbgLevelInfo, "Beginng to Grab Information.");
    } 

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineW)

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\heapclearallocation.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HeapClearAllocation.cpp

 ModAbstract:
     
    This shim fills all heap allocations with 0, or a DWORD specified on the command line
     
 Notes:

    This is a general purpose shim.

 History:
           
    05/16/2000 dmunsil      Created (based on HeapPadAllocation, by linstev)
    10/10/2000 rparsons     Added additional hooks for GlobalAlloc & LocalAlloc
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HeapClearAllocation)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RtlAllocateHeap) 
    APIHOOK_ENUM_ENTRY(LocalAlloc) 
    APIHOOK_ENUM_ENTRY(GlobalAlloc) 
APIHOOK_ENUM_END

#define DEFAULT_CLEAR_DWORD 0

DWORD g_dwClearValue = DEFAULT_CLEAR_DWORD;

/*++

 Clear the allocation with the requested DWORD.

--*/

PVOID 
APIHOOK(RtlAllocateHeap)(
    PVOID HeapHandle,
    ULONG Flags,
    SIZE_T Size
    )
{
    PVOID pRet;

    pRet = ORIGINAL_API(RtlAllocateHeap)(HeapHandle, Flags, Size);

    if (pRet) {
        DWORD *pdwBegin = (DWORD*)pRet;
        DWORD *pdwEnd = pdwBegin + (Size / sizeof(DWORD));

        while (pdwBegin != pdwEnd) {
            *pdwBegin++ = g_dwClearValue;
        }
    }

    return pRet;
}

/*++

 Clear the allocation with the requested DWORD.

--*/

HLOCAL
APIHOOK(LocalAlloc)(
    UINT uFlags,
    SIZE_T uBytes
    )
{
    HLOCAL hLocal;

    hLocal = ORIGINAL_API(LocalAlloc)(uFlags, uBytes);

    if (hLocal) {
        DWORD *pdwBegin = (DWORD*)hLocal;
        DWORD *pdwEnd = pdwBegin + (uBytes / sizeof(DWORD));

        while (pdwBegin != pdwEnd) {
            *pdwBegin++ = g_dwClearValue;
        }
    }

    return hLocal;
}

/*++

 Clear the allocation with the requested DWORD.

--*/

HGLOBAL
APIHOOK(GlobalAlloc)(
    UINT uFlags,
    DWORD dwBytes
    )
{
    HGLOBAL hGlobal;

    hGlobal = ORIGINAL_API(GlobalAlloc)(uFlags, dwBytes);

    if (hGlobal) {
        DWORD *pdwBegin = (DWORD*)hGlobal;
        DWORD *pdwEnd = pdwBegin + (dwBytes / sizeof(DWORD));

        while (pdwBegin != pdwEnd) {
            *pdwBegin++ = g_dwClearValue;
        }
    }

    return hGlobal;
}

/*++

  Get the fill value from the command line.
  
--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        CSTRING_TRY
        {
            CString csCl(COMMAND_LINE);
        
            if (! csCl.IsEmpty())
            {
                WCHAR * unused;
                g_dwClearValue = wcstol(csCl, &unused, 10);
            }

            DPFN( eDbgLevelInfo, "Filling all heap allocations with 0x%8.8X\n", g_dwClearValue);
        }
        CSTRING_CATCH
        {
            return FALSE;
        }
    } 
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(NTDLL.DLL, RtlAllocateHeap)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalAlloc)

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\handledbcsusername.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

   HandleDBCSUserName.cpp

 Abstract:

   ShFolder.Exe is failing installation when its app path has Hi Ascii characters (typically DBCS).
   When app path is double quoted, the bug code is not processed and install will succeed.
   This shim wrap the command line app path name with double quote at GetCommandLineA.

   Example:
   C:\DOCUME~1\DBCS\LOCALS~1\Temp\_ISTMP1.DIR\_ISTMP0.DIR\shfolder.exe /Q:a
   "C:\DOCUME~1\DBCS\LOCALS~1\Temp\_ISTMP1.DIR\_ISTMP0.DIR\shfolder.exe" /Q:a

 More info:

   Self extractor ShFolder.Exe checks its app path name with space char 0x20 on signed char basis.
   Hi Ascii character included in path treated below 0x20 and path is chopped at there.
   When path has double quote at the top, the problem check is not proceeded.

 History:

    04/09/2001  hioh        Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HandleDBCSUserName)
#include "ShimHookMacro.h"

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineA) 
APIHOOK_ENUM_END

char * g_lpszCommandLine = NULL;

CRITICAL_SECTION g_csCmdLine;

class CAutoLock
{
public:
   CAutoLock()
   {
      EnterCriticalSection(&g_csCmdLine);
   }
   ~CAutoLock()
   {
      LeaveCriticalSection(&g_csCmdLine);
   }
};

/*++

 Wrap the application path name with double quote.
 
--*/

LPSTR
APIHOOK(GetCommandLineA)(
    void
    )
{
    CAutoLock lock;
    if (g_lpszCommandLine)
    {
        // Been here, done that
        return g_lpszCommandLine;
    }

    g_lpszCommandLine = ORIGINAL_API(GetCommandLineA)();
    CSTRING_TRY
    {
        AppAndCommandLine  appCmdLine(NULL, g_lpszCommandLine);

        // The command line is often only the arguments: no application name
        // If the "application name" doesn't exist, don't bother to put quotes
        // around it.
        DWORD dwAttr = GetFileAttributesW(appCmdLine.GetApplicationName());
        if (dwAttr != INVALID_FILE_ATTRIBUTES)
        {
            CString csDQ = L'"';
            CString csCL = csDQ;
            CString csNA = appCmdLine.GetCommandlineNoAppName();

            csCL += appCmdLine.GetApplicationName();
            csCL += csDQ;

            if (!csNA.IsEmpty())
            {   // Add the rest
                csCL += L" ";
                csCL += csNA;
            }

            g_lpszCommandLine = csCL.ReleaseAnsi();
        }
    }
    CSTRING_CATCH
    {
        // Do nothing, g_lpszCommandLine is initialized with good value
    }

    return g_lpszCommandLine;
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
       return InitializeCriticalSectionAndSpinCount(&g_csCmdLine, 0x80000000);
    }
    
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\hidecursor.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    HideCursor.cpp

 Abstract:

    ShowCursor will display the cursor if the count is >= 0, this shim will 
    force ShowCursor to act as a toggle rather than a count.
   
    In other words it forces the count to be 0 or -1.

 History:

    05/25/2001  robkenny   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HideCursor)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ShowCursor)
APIHOOK_ENUM_END

int
APIHOOK(ShowCursor)(
    BOOL bShow   // cursor visibility
    )
{
    int nShowCount = ShowCursor(bShow);

    while (nShowCount > 0)
    {
        // Hide the cursor until the count reaches 0
        nShowCount = ShowCursor(FALSE);
    }

    while (nShowCount < -1)
    {
        // Show the cursor until the count reaches -1
        nShowCount = ShowCursor(TRUE);
    }

    return nShowCount;
}

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, ShowCursor)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\heaplookasidefree.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HeapLookasideFree.cpp

 Abstract:
     
    Check for the following heap management problems:

        1. Delay heap free calls by command line
        2. Validate free calls to make sure they are in the correct heap.
        3. Allocate new blocks out of the delay free pool if the size is 
           identical
    
    The delay of calls is implemented by means of circular array. As soon 
    as it's full, the oldest free call is validated and executed. 
     
 Notes:

    This is a general purpose shim.

 History:
           
    04/03/2000 linstev  Created
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HeapLookasideFree)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RtlAllocateHeap) 
    APIHOOK_ENUM_ENTRY(RtlFreeHeap) 
    APIHOOK_ENUM_ENTRY(HeapDestroy) 
APIHOOK_ENUM_END

#define DEFAULT_BUFFER_SIZE 16

DWORD g_dwBufferSize;
DWORD g_bHead, g_bTail;
CRITICAL_SECTION g_csHeap;

struct ENTRY
{
    HANDLE hHeap;
    PVOID lpMem;
    ULONG Flags;
    ULONG Size;
};
ENTRY *g_pEntry;

/*++

 Try and find an entry in the list.

--*/

PVOID 
APIHOOK(RtlAllocateHeap)(
    HANDLE hHeap,
    ULONG Flags,
    SIZE_T Size
    )
{
    PVOID pRet = NULL;
    
    // Make sure we are the only ones touching our heap list
    EnterCriticalSection(&g_csHeap);

    // Check if we are active - we may have shut down already.
    if (g_pEntry && Size)
    {
        DWORD bTail = (g_bTail + g_dwBufferSize - 1) % g_dwBufferSize;
        DWORD bHead = (g_bHead + g_dwBufferSize - 1) % g_dwBufferSize;
        while (bTail != bHead)
        {
            ENTRY *pEntry = g_pEntry + bTail;
            if ((pEntry->Size == Size) &&
                (pEntry->hHeap == hHeap) &&
                (pEntry->Flags == Flags))
            {
                pRet = pEntry->lpMem;
                pEntry->hHeap = 0;
                break;
            }
            bTail = (bTail + 1) % g_dwBufferSize;
        }
    }

    if (!pRet)
    {
        pRet = ORIGINAL_API(RtlAllocateHeap)(hHeap, Flags, Size);
    }

    // Done using the list
    LeaveCriticalSection(&g_csHeap);

    if (!pRet)
    {
        DPFN( eDbgLevelWarning,
            "Allocation of size %d failed", Size);
    }
        
    return pRet;
}

/*++

 Buffer the call and free the oldest entry if it's valid.

--*/

BOOL
APIHOOK(RtlFreeHeap)(
    PVOID hHeap,
    ULONG Flags,
    PVOID lpMem
    )
{
    BOOL bRet = TRUE;

    // Check if we are active - we may have shut down already.
    if (g_pEntry && lpMem)
    {
        // Make sure we are the only ones touching our heap list
        EnterCriticalSection(&g_csHeap);

        // Go ahead and free the oldest allocation
        ENTRY *pEntry = g_pEntry + g_bHead;
        if (pEntry->hHeap)
        {
            if (HeapValidate(
                    pEntry->hHeap, 
                    pEntry->Flags, 
                    pEntry->lpMem))
            {
                ORIGINAL_API(RtlFreeHeap)(
                    pEntry->hHeap, 
                    pEntry->Flags, 
                    pEntry->lpMem);
                
                pEntry->hHeap = 0;
            }
        }
        
        // Add a new entry to the table
        __try
        {
            pEntry = g_pEntry + g_bTail;
            pEntry->Size = HeapSize(hHeap, Flags, lpMem);
            pEntry->hHeap = hHeap;
            pEntry->Flags = Flags;
            pEntry->lpMem = lpMem;
            g_bHead = (g_bHead + 1) % g_dwBufferSize;
            g_bTail = (g_bTail + 1) % g_dwBufferSize;
        }
        __except(1)
        {
        }
        // Done using the list
        LeaveCriticalSection(&g_csHeap);
    }
    else
    {
        // We're no longer active, so just work normally
        bRet = ORIGINAL_API(RtlFreeHeap)(
                hHeap, 
                Flags, 
                lpMem);
    }

    return bRet;
}

/*++

 Clear all entries of this heap from our table.

--*/

BOOL
APIHOOK(HeapDestroy)(
    HANDLE hHeap
    )
{
    // Make sure we are the only ones touching our heap list
    EnterCriticalSection(&g_csHeap);

    if (g_pEntry)
    {
        // Remove entries in this heap from our list
        for (ULONG i=0; i<g_dwBufferSize; i++)
        {
            ENTRY *pEntry = g_pEntry + i;
            if (pEntry->hHeap == hHeap)
            {
                pEntry->hHeap = 0;
            }
        }
    }
    
    // We're done with the list
    LeaveCriticalSection(&g_csHeap);

    return ORIGINAL_API(HeapDestroy)(hHeap);
}

/*++

 Handle DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH in your notify function
 to do initialization and uninitialization.

 IMPORTANT: Make sure you ONLY call NTDLL and KERNEL32 APIs during
 DLL_PROCESS_ATTACH notification. No other DLLs are initialized at that
 point.
 
 If your shim cannot initialize properly, return FALSE and none of the
 APIs specified will be hooked.
 
--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        CSTRING_TRY
        {
            CString csCl(COMMAND_LINE);
        
            if (! csCl.IsEmpty())
            {
                WCHAR * unused;
                g_dwBufferSize= wcstol(csCl, &unused, 10);
            }
            if (g_dwBufferSize == 0)
            {
                g_dwBufferSize = DEFAULT_BUFFER_SIZE;
            }

            InitializeCriticalSection(&g_csHeap);
            g_bHead = 0;
            g_bTail = g_dwBufferSize - 1;
            g_pEntry = (ENTRY *)VirtualAlloc(0, 
                                             sizeof(ENTRY) * g_dwBufferSize, 
                                             MEM_COMMIT, 
                                             PAGE_READWRITE);
        }
        CSTRING_CATCH
        {
            return FALSE;
        }

        return TRUE;
    }
    if (fdwReason == DLL_PROCESS_DETACH) 
    {
        EnterCriticalSection(&g_csHeap);
        VirtualFree(g_pEntry, 0, MEM_RELEASE);
        g_pEntry = (ENTRY *)NULL;
        LeaveCriticalSection(&g_csHeap);
        
        // Don't delete this critical section in case we get called after detach
        // DeleteCriticalSection(&g_csHeap);
        return TRUE;
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(NTDLL.DLL, RtlAllocateHeap)
    APIHOOK_ENTRY(NTDLL.DLL, RtlFreeHeap)
    APIHOOK_ENTRY(KERNEL32.DLL, HeapDestroy)

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\heapvalidatefrees.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HeapValidateFrees.cpp

 ModAbstract:
     
    Verifies the pointer passed to RtlFreeHeap and RtlReAllocateHeap to make 
    sure they belong to the heap specified
     
 Notes:

    This is a general purpose shim.

 History:
           
    04/25/2000 linstev  Created
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HeapValidateFrees)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RtlFreeHeap) 
    APIHOOK_ENUM_ENTRY(RtlReAllocateHeap) 
    APIHOOK_ENUM_ENTRY(RtlSizeHeap) 
APIHOOK_ENUM_END

/*++

 Verify that the pointer being freed belongs to the heap.

--*/

BOOL
APIHOOK(RtlFreeHeap)(
    PVOID HeapHandle,
    ULONG Flags,
    PVOID BaseAddress
    )
{
    BOOL bRet = TRUE; 

    if (HeapValidate(HeapHandle, 0, BaseAddress)) 
    {
        bRet = ORIGINAL_API(RtlFreeHeap)(HeapHandle, Flags, BaseAddress);
    }
    else 
    {
        LOGN( eDbgLevelError,
            "[APIHook_RtlFreeHeap] Invalid Pointer 0x%x for Heap 0x%x.",
            BaseAddress, HeapHandle);
    }
    
    return bRet;
}

/*++

 Verify that the pointer being freed belongs to the heap.

--*/

LPVOID
APIHOOK(RtlReAllocateHeap)(
    HANDLE hHeap,  
    DWORD dwFlags, 
    LPVOID lpMem,  
    DWORD dwBytes  
    )
{
    LPVOID pRet = NULL;

    if (HeapValidate(hHeap, 0, lpMem)) 
    {
        pRet = ORIGINAL_API(RtlReAllocateHeap)(hHeap, dwFlags, lpMem, dwBytes);
    }
    else
    {
        LOGN( eDbgLevelError,
            "[APIHook_RtlReAllocateHeap] Invalid Pointer 0x%x for Heap 0x%x.",
            lpMem, hHeap);
    }

    return pRet;
}

/*++

 Verify that the pointer being sized belongs to the heap

--*/

DWORD
APIHOOK(RtlSizeHeap)(
    HANDLE hHeap,  
    DWORD dwFlags, 
    LPCVOID lpMem  
    )
{
    DWORD dwRet = (DWORD)-1;

    if (HeapValidate(hHeap, 0, lpMem)) 
    {
        dwRet = ORIGINAL_API(RtlSizeHeap)(hHeap, dwFlags, lpMem);
    }
    else
    {
        LOGN( eDbgLevelError,
            "[APIHook_RtlSizeHeap] Invalid Pointer 0x%x for Heap 0x%x.",
            lpMem, hHeap);
    }

    return dwRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(NTDLL.DLL, RtlFreeHeap)
    APIHOOK_ENTRY(NTDLL.DLL, RtlReAllocateHeap)
    APIHOOK_ENTRY(NTDLL.DLL, RtlSizeHeap)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\heappadallocation.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HeapPadAllocation.cpp

 ModAbstract:
     
    This shim pads heap allocations by n bytes - where n is 256 by default but 
    can be specified by command line.
     
 Notes:

    This is a general purpose shim.

 History:
           
    09/28/1999 linstev  Created
    04/25/2000 linstev  Added command line 
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HeapPadAllocation)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RtlAllocateHeap) 
APIHOOK_ENUM_END

#define DEFAULT_PAD_SIZE 256

DWORD g_dwPadSize = DEFAULT_PAD_SIZE;

/*++

 Increase the heap allocation size.

--*/

PVOID 
APIHOOK(RtlAllocateHeap)(
    PVOID HeapHandle,
    ULONG Flags,
    SIZE_T Size
    )
{
    return ORIGINAL_API(RtlAllocateHeap)(HeapHandle, Flags, Size + g_dwPadSize);
}

/*++

 Handle DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH in your notify function
 to do initialization and uninitialization.

 IMPORTANT: Make sure you ONLY call NTDLL and KERNEL32 APIs during
 DLL_PROCESS_ATTACH notification. No other DLLs are initialized at that
 point.
 
 If your shim cannot initialize properly, return FALSE and none of the
 APIs specified will be hooked.
 
--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        CSTRING_TRY
        {
            CString csCl(COMMAND_LINE);
        
            if (! csCl.IsEmpty())
            {
                WCHAR * unused;
                g_dwPadSize = wcstol(csCl, &unused, 10);
            }
            if (g_dwPadSize == 0)
            {
                g_dwPadSize = DEFAULT_PAD_SIZE;
            }

            DPFN( eDbgLevelInfo, "Padding all heap allocations by %d bytes\n", g_dwPadSize);
        }
        CSTRING_CATCH
        {
            return FALSE;
        }
    } 

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(NTDLL.DLL, RtlAllocateHeap)
    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\hidetaskbar.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HideTaskBar.cpp

 Abstract:

    The WS_EX_CLIENTEDGE flag means that the taskbar gets shown on NT. This 
    isn't always what's desirable.

 Notes:

    This is a general purpose shim.

 History:

    04/07/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HideTaskBar)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateWindowExA) 
    APIHOOK_ENUM_ENTRY(CreateWindowExW) 
APIHOOK_ENUM_END

/*++

 Remove invalid Windows 2000 style bits from dwExStyle mask before calling
 CreateWindowEx.

--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,
    LPCSTR lpClassName,
    LPCSTR lpWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam 
    )
{
    // Remove the client edge style.
    dwExStyle &= ~WS_EX_CLIENTEDGE;

    return ORIGINAL_API(CreateWindowExA)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,
        x,
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,
        hInstance,
        lpParam);
}

/*++

 Remove invalid Windows 2000 style bits from dwExStyle mask before calling
 CreateWindowEx.

--*/

HWND 
APIHOOK(CreateWindowExW)(
    DWORD dwExStyle,
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam 
    )
{
    dwExStyle &= ~WS_EX_CLIENTEDGE;
    
    // Call the original API
    return ORIGINAL_API(CreateWindowExW)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,
        x,
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,
        hInstance,
        lpParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\ignorecocreateinstance.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    IgnoreCoCreateInstance.cpp

 Abstract:

    Ignore specified CoCreateInstance calls.

 Notes:

    This is a general purpose shim.

 History:

    01/07/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreCoCreateInstance)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CoCreateInstance)
APIHOOK_ENUM_END

int g_nCount = 0;
CString *g_rGUIDs = NULL;

/*++

 Ignore specified CoCreateInstance calls
 
--*/

STDAPI 
APIHOOK(CoCreateInstance)(
    REFCLSID  rclsid,     
    LPUNKNOWN pUnkOuter, 
    DWORD     dwClsContext,  
    REFIID    riid,         
    LPVOID*   ppv
    )
{
    CSTRING_TRY
    {
        //
        // Convert the CLSID to a string so we can compare it to our guids
        //

        LPOLESTR wszCLSID;
        if (StringFromCLSID(rclsid, &wszCLSID) == S_OK) {
            // Run the list and jump out if we match
            CString csClass(wszCLSID);
            for (int i = 0; i < g_nCount; i++) {
                if (csClass.CompareNoCase(g_rGUIDs[i]) == 0) {
                    LOGN(eDbgLevelWarning, "[CoCreateInstance] Failed %S", wszCLSID);

                    // Free the memory
                    CoTaskMemFree(wszCLSID);
                    return REGDB_E_CLASSNOTREG;
                }
            }
            
            // Free the memory
            CoTaskMemFree(wszCLSID);
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    return ORIGINAL_API(CoCreateInstance)(rclsid, pUnkOuter, dwClsContext, riid, 
        ppv);
}
 
/*++

 Register hooked functions

--*/

BOOL ParseCommandLine()
{
    CSTRING_TRY
    {
        CString csCl(COMMAND_LINE);
        CStringParser csParser(csCl, L";");

        g_nCount = csParser.GetCount();
        g_rGUIDs = csParser.ReleaseArgv();
    }
    CSTRING_CATCH
    {
        return FALSE;
    }

    for (int i = 0; i < g_nCount; ++i) {
        DPFN(eDbgLevelInfo, "ClassID = %S", g_rGUIDs[i].Get());
    }

    return TRUE;
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        return ParseCommandLine();
    }

    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(OLE32.DLL, CoCreateInstance)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\ignorecrtexit.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    IgnoreCRTExit.cpp

 Abstract:

    Prevent CRT shutdown routines from running. At some point MSVCRT didn't 
    actually call these, so some apps fault when they really do get called.
    
 Notes:
    
    This is a general purpose shim.
   
 History:

    05/09/2002  linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreCRTExit)
#include "ShimHookMacro.h"

typedef LPVOID (__cdecl *_pfn_atexit)(LPVOID);
typedef LPVOID (__cdecl *_pfn__onexit)(LPVOID);

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(atexit) 
    APIHOOK_ENUM_ENTRY(_onexit) 
APIHOOK_ENUM_END

VOID
__cdecl
APIHOOK(atexit)(LPVOID lpFunc)
{
    return;
}

LPVOID
__cdecl
APIHOOK(_onexit)(LPVOID lpFunc)
{
    return lpFunc;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(MSVCRT.DLL, atexit)
    APIHOOK_ENTRY(MSVCRT.DLL, _onexit)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\ignorealttab.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    IgnoreAltTab.cpp

 Abstract:

   This DLL installs a low level keyboard hook to eat Alt-Tab, Left Win,
   Right Win and Apps combinations.
   
   This is accomplished by creating a seperate thread, installing a WH_KEYBOARD_LL hook
   and starting a message loop in that thread.
   

   This shim needs to force DInput to use windows hooks instead of WM_INPUT,
   since WM_INPUT messages force all WH_KEYBOARD_LL to be ignored.

 Notes:

   We intentionally try to stay at the *end* of the hook chain
   by hooking as early as we can.  If we are at the end of the
   hook chain, we allow all previous hookers (DInput especially)
   their chance at the key event before we toss it out.

 History:

    05/25/2001  robkenny   Created
    11/27/2001  mnikkel    Added sticky and filter keys to shim.

--*/

#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(IgnoreAltTab)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterRawInputDevices)
APIHOOK_ENUM_END


// Forward declarations

LRESULT CALLBACK KeyboardProcLL(int nCode, WPARAM wParam, LPARAM lParam);
class CThreadKeyboardHook;


// Global variables

CThreadKeyboardHook *g_cKeyboardHook = NULL;
LPSTICKYKEYS g_lpOldStickyKeyValue;
LPFILTERKEYS g_lpOldFilterKeyValue;
BOOL g_bInitialize = FALSE;
BOOL g_bInitialize2= FALSE;
BOOL g_bCatchKeys = TRUE;

class CThreadKeyboardHook
{
protected:
    HHOOK               hKeyboardHook;
    HANDLE              hMessageThread;
    DWORD               dwMessageThreadId;

public:
    CThreadKeyboardHook();
    ~CThreadKeyboardHook();

    void    AddHook();
    void    RemoveHook();

    LRESULT HandleKeyLL(int code, WPARAM wParam, LPARAM lParam);

    static DWORD WINAPI MessageLoopThread(LPVOID lpParameter);
};

/*++

  This routine runs in a seperate thread.
 
  MSDN says: "This hook is called in the context of the thread that installed it.
              The call is made by sending a message to the thread that installed
              the hook. Therefore, the thread that installed the hook must have a message loop." 

--*/

DWORD WINAPI CThreadKeyboardHook::MessageLoopThread(LPVOID lpParameter)
{
    CThreadKeyboardHook * pThreadHookList = (CThreadKeyboardHook *)lpParameter;


    pThreadHookList->AddHook();

    DPFN(eDbgLevelSpew, "Starting message loop");

    BOOL bRet;
    MSG msg;

    while ((bRet = GetMessage(&msg, NULL, 0, 0)) != 0)
    { 
        DPFN(eDbgLevelSpew, "MessageLoopThread: Msg(0x%08x) wParam(0x%08x) lParam(0x%08x)",
             msg.message, msg.wParam, msg.lParam);

        if (bRet == -1)
        {
            // handle the error and possibly exit
        }
        else
        {
            TranslateMessage(&msg); 
            DispatchMessage(&msg); 
        }
    }
    
    // We are exiting the thread
    pThreadHookList->hMessageThread = 0;
    pThreadHookList->dwMessageThreadId = 0;

    return 0;
}

CThreadKeyboardHook::CThreadKeyboardHook()
{
    hMessageThread = CreateThread(NULL, 0, MessageLoopThread, this, 0, &dwMessageThreadId);
}

CThreadKeyboardHook::~CThreadKeyboardHook()
{
    if (hMessageThread)
    {
        TerminateThread(hMessageThread, 0);
    }
}

void CThreadKeyboardHook::AddHook()
{
    // Do not add duplicates to the list
    if (!hKeyboardHook)
    {
        hKeyboardHook = SetWindowsHookExA(WH_KEYBOARD_LL, KeyboardProcLL, g_hinstDll, 0);
        if (hKeyboardHook)
        {
            DPFN(eDbgLevelSpew, "Adding WH_KEYBOARD_LL hook(0x%08x)", hKeyboardHook);
        }
    }
}

void CThreadKeyboardHook::RemoveHook()
{
    if (hKeyboardHook)
    {
        UnhookWindowsHookEx(hKeyboardHook);

        DPFN(eDbgLevelSpew, "Removing hook(0x%08x)", hKeyboardHook);

        hKeyboardHook   = NULL;
    }
}

LRESULT CThreadKeyboardHook::HandleKeyLL(int code, WPARAM wParam, LPARAM lParam)
{
    LRESULT retval          = 1;

    DWORD dwKey             = 0;
    BOOL bAltDown           = 0;
    BOOL bCtlDown           = GetKeyState(VK_CONTROL) < 0;

    if (lParam)
    {
        KBDLLHOOKSTRUCT * pllhs = (KBDLLHOOKSTRUCT*)lParam;
        dwKey                   = pllhs->vkCode;
        bAltDown                = (pllhs->flags & LLKHF_ALTDOWN) != 0;
    }

    //if (code >= 0)    // Despite what MSDN says, we need to muck with the values even if nCode == 0
    {
        if (bAltDown && dwKey == VK_TAB)        // Alt-Tab
        {
            // Do not process this event
            LOGN(eDbgLevelInfo, "Eating Key: Alt-Tab");
            return TRUE; 
        }
        else if (bAltDown && dwKey == VK_ESCAPE)     // Alt-Escape
        {
            // Do not process this event
            LOGN(eDbgLevelInfo, "Eating Key: Alt-Escape");
            return TRUE; 
        }
        else if (bCtlDown && dwKey == VK_ESCAPE)     // Ctrl-Escape
        {
            // Do not process this event
            LOGN(eDbgLevelInfo, "Eating Key: Ctrl-Escape");
            return TRUE; 
        }
        else if (dwKey == VK_RWIN || dwKey == VK_LWIN) // Windows key
        {
            // Do not process this event
            LOGN(eDbgLevelInfo, "Eating Key: Windows Key");
            return TRUE; 
        }
        else if (dwKey == VK_APPS)       // Menu key
        {
            // Do not process this event
            LOGN(eDbgLevelInfo, "Eating Key: Apps key");
            return TRUE; 
        }
    }

    DPFN(eDbgLevelSpew, "LL Key event:  code(0x%08x) dwKey(0x%08x) bits(0x%08x) Alt(%d) Ctrl(%d)",
          code, dwKey, lParam, bAltDown, bCtlDown);

    return CallNextHookEx(hKeyboardHook, code, wParam, lParam);
}



/*++

 This function intercepts special codes and eats them so that
 the app is not switched out of.

--*/

LRESULT CALLBACK
KeyboardProcLL(
    int    nCode,
    WPARAM wParam,
    LPARAM lParam
   )
{
    if (g_cKeyboardHook)
    {
        return g_cKeyboardHook->HandleKeyLL(nCode, wParam, lParam);
    }

    return 1; // this is an error...
}

/*++

 Determine if there are any accelerated pixel formats available. This is done
 by enumerating the pixel formats and testing for acceleration.

--*/

BOOL
IsGLAccelerated()
{
    HMODULE hMod = NULL;
    HDC hdc = NULL;
    int i;
    PIXELFORMATDESCRIPTOR pfd;
    _pfn_wglDescribePixelFormat pfnDescribePixelFormat;

    int iFormat = -1;

    //
    // Load original opengl
    //

    hMod = LoadLibraryA("opengl32");
    if (!hMod)
    {
        LOGN(eDbgLevelError, "Failed to load OpenGL32");
        goto Exit;
    }

    //
    // Get wglDescribePixelFormat so we can enumerate pixel formats
    //
    
    pfnDescribePixelFormat = (_pfn_wglDescribePixelFormat) GetProcAddress(
        hMod, "wglDescribePixelFormat");
    if (!pfnDescribePixelFormat)
    {
        LOGN(eDbgLevelError, "API wglDescribePixelFormat not found in OpenGL32");
        goto Exit;
    }

    //
    // Get a Display DC for enumeration
    //
    
    hdc = GetDC(NULL);
    if (!hdc)
    {
        LOGN(eDbgLevelError, "GetDC(NULL) Failed");
        goto Exit;
    }

    //
    // Run the list of pixel formats looking for any that are non-generic,
    //   i.e. accelerated by an ICD
    //
    
    i = 1;
    iFormat = 0;
    while ((*pfnDescribePixelFormat)(hdc, i, sizeof(PIXELFORMATDESCRIPTOR), &pfd))
    {
        if ((pfd.dwFlags & PFD_DRAW_TO_WINDOW) &&
            (pfd.dwFlags & PFD_SUPPORT_OPENGL) &&
            (!(pfd.dwFlags & PFD_GENERIC_FORMAT)))
        {
            iFormat = i;
            break;
        }

        i++;
    }

Exit:
    if (hdc)
    {
        ReleaseDC(NULL, hdc);
    }

    if (hMod)
    {
        FreeLibrary(hMod);
    }

    return (iFormat > 0);
}


/*++

 WM_INPUT messages force WH_KEYBOARD_LL hooks to be ignored, therefore
 we need to fail this call.
 
--*/
BOOL
APIHOOK(RegisterRawInputDevices)(
  PCRAWINPUTDEVICE  pRawInputDevices, 
  UINT        uiNumDevices,
  UINT        cbSize
)
{
    LOGN(eDbgLevelError, "RegisterRawInputDevices: failing API with bogus ERROR_INVALID_PARAMETER");

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}


/*++

 DisableStickyKeys saves the current value for LPSTICKYKEYS and then disables the option.

--*/

VOID 
DisableStickyKeys()
{
    if (!g_bInitialize2) {
        //
        // Disable sticky key support
        //
        g_lpOldStickyKeyValue = (LPSTICKYKEYS) malloc(sizeof(STICKYKEYS));
        LPSTICKYKEYS pvParam = (LPSTICKYKEYS) malloc(sizeof(STICKYKEYS));

        if ( g_lpOldStickyKeyValue == NULL || pvParam == NULL )
        {
            // return if out of memory
            LOGN( eDbgLevelInfo, "[IgnoreAltTab] Out of Memory, unable to disable sticky keys.");
            return;
        }

        g_lpOldStickyKeyValue->cbSize = sizeof(STICKYKEYS);

        pvParam->cbSize = sizeof(STICKYKEYS);
        pvParam->dwFlags = 0;

        SystemParametersInfo(SPI_GETSTICKYKEYS, sizeof(STICKYKEYS), 
            g_lpOldStickyKeyValue, 0);

        SystemParametersInfo(SPI_SETSTICKYKEYS, sizeof(STICKYKEYS), pvParam, 
            SPIF_SENDCHANGE);

        g_bInitialize2 = TRUE;
        LOGN( eDbgLevelInfo, "[IgnoreAltTab] Sticky keys disabled");
    }
}

/*++

 EnableStickyKeys uses the save value for STICKYKEYS and resets the option to the original setting.

--*/

VOID 
EnableStickyKeys()
{
    if (g_bInitialize2) 
    {
        g_bInitialize2 = FALSE;

        //
        // Restore sticky key state
        //
        SystemParametersInfo(SPI_SETSTICKYKEYS, sizeof(STICKYKEYS), 
            g_lpOldStickyKeyValue, SPIF_SENDCHANGE);

        LOGN( eDbgLevelInfo, "[EnableStickyKeys] Sticky key state restored");
    }
}


/*++

 DisableFilterKeys saves the current value for LPFILTERKEYS and then disables the option.

--*/

VOID 
DisableFilterKeys()
{
    if (!g_bInitialize) 
    {
        //
        // Disable filter key support
        //
        g_lpOldFilterKeyValue = (LPFILTERKEYS) malloc(sizeof(FILTERKEYS));
        LPFILTERKEYS pvParam = (LPFILTERKEYS) malloc(sizeof(FILTERKEYS));

        if ( g_lpOldFilterKeyValue == NULL || pvParam == NULL )
        {
            // return if out of memory
            LOGN( eDbgLevelInfo, "[IgnoreAltTab] Out of Memory, unable to disable filter keys.");
            return;
        }

        g_lpOldFilterKeyValue->cbSize = sizeof(FILTERKEYS);

        pvParam->cbSize = sizeof(FILTERKEYS);
        pvParam->dwFlags = 0;

        SystemParametersInfo(SPI_GETFILTERKEYS, sizeof(FILTERKEYS), 
            g_lpOldFilterKeyValue, 0);

        SystemParametersInfo(SPI_SETFILTERKEYS, sizeof(FILTERKEYS), pvParam, 
            SPIF_SENDCHANGE);

        g_bInitialize = TRUE;
        LOGN( eDbgLevelInfo, "[DisableFilterKeys] Filter keys disabled");
    }
}

/*++

 EnableFilterKeys uses the save value for FILTERKEYS and resets the option to the original setting.

--*/

VOID 
EnableFilterKeys()
{
    if (g_bInitialize) 
    {
        g_bInitialize = FALSE;

        //
        // Restore filter key state
        //
        SystemParametersInfo(SPI_SETFILTERKEYS, sizeof(FILTERKEYS), 
            g_lpOldFilterKeyValue, SPIF_SENDCHANGE);

        LOGN( eDbgLevelInfo, "[EnableFilterKeys] Filter key state restored");
    }
}


/*++

 Handle Shim notifications.

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
   )
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        g_cKeyboardHook = new CThreadKeyboardHook;

        if (!g_cKeyboardHook)
        {
            return FALSE;
        }

        CSTRING_TRY
        {
            CString csCl(COMMAND_LINE);
            if (csCl.CompareNoCase(L"NOKEYS") == 0)
            {
                g_bCatchKeys = FALSE;
            }
        }
        CSTRING_CATCH
        {
            // no action
        }
    }
    else if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) 
    {
        if (g_bCatchKeys)
        {
            DisableStickyKeys();
            DisableFilterKeys();
        }

        #if DBG
        static bool bTest = FALSE;
        if (bTest)
        {
            delete g_cKeyboardHook;
            g_cKeyboardHook = NULL;
            return TRUE;
        }
        #endif

        CSTRING_TRY
        {
            CString csCl(COMMAND_LINE);

            if (csCl.CompareNoCase(L"OPENGL") == 0)
            {
                // This must be called *after* the dll's have been initialized
                if (IsGLAccelerated())
                {
                    delete g_cKeyboardHook;
                    g_cKeyboardHook = NULL;
                    return TRUE;
                }
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    } 
    else if (fdwReason == DLL_PROCESS_DETACH) 
    {
        if (g_bCatchKeys)
        {
            EnableFilterKeys();
            EnableStickyKeys();
        }
    }

    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(USER32.DLL,   RegisterRawInputDevices)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\ignoremcistop.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreMCIStop.cpp

 Abstract:

    The shim hooks mciSendCommand and ignores MCI_STOP which takes 2-3 seconds
    on my P2-400. 

    Sent to the audio team for fixing, but I'm not optimistic - bug number 
    246407.

 Notes:

    This cannot be put in the layer, but can apply to more than one app.

 History:

    08/04/2000 a-brienw  Created
    11/30/2000 linstev   Generalized 

--*/

#include "precomp.h"
#include <mmsystem.h>

IMPLEMENT_SHIM_BEGIN(IgnoreMCIStop)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(mciSendCommandA) 
APIHOOK_ENUM_END

/*++

 Hook mciSendCommand and perform the shims duties.

--*/

MCIERROR 
APIHOOK(mciSendCommandA)(
    MCIDEVICEID IDDevice,  
    UINT uMsg,             
    DWORD fdwCommand,      
    DWORD dwParam          
    )
{
    if (uMsg == MCI_STOP)
    {
        DPFN( eDbgLevelWarning, "Ignoring MCI_STOP");
        return 0;
    }

    if (uMsg == MCI_CLOSE)
    {
        DPFN( eDbgLevelWarning, "MCI_CLOSE called: issuing MCI_STOP");
        mciSendCommandA(IDDevice, MCI_STOP, 0, 0);
    }

    MCIERROR mErr = ORIGINAL_API(mciSendCommandA)(
        IDDevice,
        uMsg,
        fdwCommand,
        dwParam);

    return mErr;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(WINMM.DLL, mciSendCommandA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\ignorefreelibrary.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreFreeLibrary.cpp

 Abstract:

    Some applications free DLLs before they're actually ready to. When this occurs,
    if the offending application attempts to make a call to an exported function,
    the call fails. This results in an access violation.
    
    This shim takes a command line of ; delimited DLL names. For each DLL on the command
    line, a call to FreeLibrary for the specified DLL will be ignored.
                                                             
    Example:

    xanim.dll
    
    video_3dfx.dll;glide.dll

 Notes:
    
    This is a general purpose shim.

 History:

    10/31/2000 rparsons  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreFreeLibrary)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(FreeLibrary) 
APIHOOK_ENUM_END

#define MAX_FILES 64

int                 g_nLibraryCountFreeLibrary          = 0;
CString *           g_rgLibrariesToIgnoreFreeLibrary    = NULL;



/*++

 Hook the call to FreeLibrary. Determine if the file name that corresponds to this
 module should be ignored.

--*/

BOOL
APIHOOK(FreeLibrary)( 
    HMODULE hModule
    )
{
    CSTRING_TRY
    {
        CString csModule;
        csModule.GetModuleFileNameW(hModule);

        CString csFileName;
        csModule.GetLastPathComponent(csFileName);

        for (int i = 0; i < g_nLibraryCountFreeLibrary; ++i)
        {
            if (csFileName.CompareNoCase(g_rgLibrariesToIgnoreFreeLibrary[i]) == 0)
            {
                DPFN( eDbgLevelInfo, "Caught attempt freeing %S\n", csModule.Get());
                return TRUE;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }
    
    return ORIGINAL_API(FreeLibrary)(hModule);
}

/*++

 This function parses the COMMAND_LINE for the libraries that should
 have their FreeLibrary call ignored.

--*/

BOOL ParseCommandLine()
{
    CSTRING_TRY
    {
        CString         csCl(COMMAND_LINE);
        CStringParser   csParser(csCl, L";");

        g_nLibraryCountFreeLibrary          = csParser.GetCount();
        g_rgLibrariesToIgnoreFreeLibrary    = csParser.ReleaseArgv();
    }
    CSTRING_CATCH
    {
        return FALSE;
    }

    for (int i = 0; i < g_nLibraryCountFreeLibrary; ++i) {
        DPFN( eDbgLevelInfo, "Library %d: name: --%S--\n", i, g_rgLibrariesToIgnoreFreeLibrary[i].Get());
    }

    return TRUE;
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        return ParseCommandLine();
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, FreeLibrary)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\ignoremessagebox.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   IgnoreMessageBox.cpp

 Abstract:

   This APIHooks MessageBox and based on the passed in command line prevents the
   message box from being displayed. Many applications display a message box with
   some debugging or other extraneous comment. This is normally the result of
   differences between Windows 98 and Whistler. 

   command line syntax:

   text,caption;text1,caption1

   The passed in command line is composed of a pair of one or more strings separated
   by semicolons. These string pairs form the text and caption that must match in order
   to block the display of the message box. If either the caption or text are not needed
   then they can be left blank. For example, "block this text,;" would prevent the message
   box from being displayed if the text passed to the message box was: block this text" the
   caption parameter would not be used. The following are some examples:

    "error message 1000,Error"      - would not display the message box if the
                                      lpCaption parameter contained Error and
                                      the lpText parameter contained error
                                      message 1000

    "error message 1000,"           - would not display the message box if the
                                      lpText parameter contained error message 1000

    ",Error"                        - would not display any message boxes if the
                                      lpCaption parameter contained Error
                                 
    "message1,Error;message2,Error2 - would not display the message box if the
                                      lpText parameter contained message1 and
                                      the lpCaption parameter contained Error or
                                      the lpText parameter contained message2 and
                                      the lpCaption paramter contained Error2.

    The match is performed on the command line string to the current message box
    parameter string. The command line string can contain wildcard specification
    characters. This allows complex out of order matching to take place see below:

        ?   match one character in this position
        *   match zero or more characters in this position

    If the source string contains any ? * , ; \ characters, precede them with a backslash.
    For example, the following command line would match the indicated text and caption:

        Text:           "Compatibility; A *very* important thing."
        Caption:        "D:\WORD\COMPAT.DOC"

        Command line:   "Compatibility\; A \*very\* important thing.,D:\\WORD\\COMPAT.DOC"

 Notes:

 History:

   04/06/2000 philipdu Created
   04/06/2000 markder  Added wide-character conversion, plus Ex versions.
   05/23/2001 mnikkel  Added W routines so we can pick up system messagebox calls

--*/

#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(IgnoreMessageBox)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(MessageBoxA) 
    APIHOOK_ENUM_ENTRY(MessageBoxExA) 
    APIHOOK_ENUM_ENTRY(MessageBoxW) 
    APIHOOK_ENUM_ENTRY(MessageBoxExW) 
APIHOOK_ENUM_END


class MBPair
{
public:
    CString     csText;
    CString     csCaption;
};

VectorT<MBPair>     * g_IgnoreList = NULL;


BOOL IsBlockMessage(LPCSTR szOrigText, LPCSTR szOrigCaption)
{
    CSTRING_TRY
    {
        CString csText(szOrigText);
        CString csCaption(szOrigCaption);
    
        for (int i = 0; i < g_IgnoreList->Size(); ++i)
        {
            const MBPair & mbPair = g_IgnoreList->Get(i);
        
            BOOL bTextMatch  = mbPair.csText.IsEmpty()    || csText.PatternMatch(mbPair.csText);
            BOOL bTitleMatch = mbPair.csCaption.IsEmpty() || csCaption.PatternMatch(mbPair.csCaption);

            if (bTextMatch && bTitleMatch)
            {
                return TRUE;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    return FALSE;
}

BOOL IsBlockMessageW(LPWSTR szOrigText, LPWSTR szOrigCaption)
{
    CSTRING_TRY
    {
        CString csText(szOrigText);
        CString csCaption(szOrigCaption);
    
        for (int i = 0; i < g_IgnoreList->Size(); ++i)
        {
            const MBPair & mbPair = g_IgnoreList->Get(i);
        
            BOOL bTextMatch  = mbPair.csText.IsEmpty()    || csText.PatternMatch(mbPair.csText);
            BOOL bTitleMatch = mbPair.csCaption.IsEmpty() || csCaption.PatternMatch(mbPair.csCaption);

            if (bTextMatch && bTitleMatch)
            {
                return TRUE;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    return FALSE;
}


int
APIHOOK(MessageBoxA)(
    HWND hWnd,          // handle to owner window
    LPCSTR lpText,      // text in message box
    LPCSTR lpCaption,   // message box title
    UINT uType          // message box style
    )
{
    int iReturnValue;

    //if this is the passed in string that we want do not
    //want to display then simply return to caller.

    if (IsBlockMessage(lpText, lpCaption))
    {
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] MessageBoxA swallowed:\n");
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] Caption = \"%s\"\n", lpCaption);
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] Text    = \"%s\"\n", lpText);
        return MB_OK;
    }

    iReturnValue = ORIGINAL_API(MessageBoxA)( 
        hWnd,
        lpText,
        lpCaption,
        uType);

    return iReturnValue;
}


int
APIHOOK(MessageBoxExA)(
    HWND hWnd,          // handle to owner window
    LPCSTR lpText,      // text in message box
    LPCSTR lpCaption,   // message box title
    UINT uType,         // message box style
    WORD wLanguageId    // language identifier
    )
{
    int iReturnValue;

    //if this is the passed in string that we want do not
    //want to display then simply return to caller.

    if (IsBlockMessage(lpText, lpCaption))
    {
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] MessageBoxExA swallowed:\n");
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] Caption = \"%s\"\n", lpCaption);
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] Text    = \"%s\"\n", lpText);
        return MB_OK;
    }

    iReturnValue = ORIGINAL_API(MessageBoxExA)( 
        hWnd,
        lpText,
        lpCaption,
        uType,
        wLanguageId);

    return iReturnValue;
}

int
APIHOOK(MessageBoxW)(
    HWND hWnd,          // handle to owner window
    LPWSTR lpText,      // text in message box
    LPWSTR lpCaption,   // message box title
    UINT uType          // message box style
    )
{
    int iReturnValue;

    //if this is the passed in string that we want do not
    //want to display then simply return to caller.

    if (IsBlockMessageW(lpText, lpCaption))
    {
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] MessageBoxW swallowed:\n");
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] Caption = \"%S\"\n", lpCaption);
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] Text    = \"%S\"\n", lpText);
        return MB_OK;
    }

    iReturnValue = ORIGINAL_API(MessageBoxW)( 
        hWnd,
        lpText,
        lpCaption,
        uType);

    return iReturnValue;
}

int
APIHOOK(MessageBoxExW)(
    HWND hWnd,          // handle to owner window
    LPWSTR lpText,      // text in message box
    LPWSTR lpCaption,   // message box title
    UINT uType,         // message box style
    WORD wLanguageId    // language identifier
    )
{
    int iReturnValue;

    //if this is the passed in string that we want do not
    //want to display then simply return to caller.

    if (IsBlockMessageW(lpText, lpCaption))
    {
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] MessageBoxExW swallowed:\n");
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] Caption = \"%S\"\n", lpCaption);
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] Text    = \"%S\"\n", lpText);
        return MB_OK;
    }

    iReturnValue = ORIGINAL_API(MessageBoxExW)( 
        hWnd,
        lpText,
        lpCaption,
        uType,
        wLanguageId);

    return iReturnValue;
}


BOOL
ParseCommandLine(const char * cl)
{
    CSTRING_TRY
    {
        CStringToken csCommandLine(COMMAND_LINE, ";");
        CString csTok;
    
        g_IgnoreList = new VectorT<MBPair>;
        if (!g_IgnoreList)
        {
            return FALSE;
        }
    
        while (csCommandLine.GetToken(csTok))
        {
            MBPair mbPair;
            
            CStringToken csMB(csTok, ",");
            csMB.GetToken(mbPair.csText);
            csMB.GetToken(mbPair.csCaption);
    
            if (!g_IgnoreList->AppendConstruct(mbPair))
            {
                return FALSE;
            }
        }
    }
    CSTRING_CATCH
    {
        // Fall through
        LOGN(eDbgLevelError, "[ParseCommandLine] Illegal command line");
    }    

    return g_IgnoreList && g_IgnoreList->Size() > 0;
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        return ParseCommandLine(COMMAND_LINE);
    }
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(USER32.DLL, MessageBoxA)
    APIHOOK_ENTRY(USER32.DLL, MessageBoxExA)
    APIHOOK_ENTRY(USER32.DLL, MessageBoxW) 
    APIHOOK_ENTRY(USER32.DLL, MessageBoxExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\ignoredebugoutput.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreDebugOutput.cpp

 Abstract:

    If an app tries to output debug strings, throws them on the floor to improve 
    perf.

 Notes:

    This shim is general purpose and emulates Win9x behavior (at least it 
    emulates the behavior when there's no debugger attached).

 History:

    05/10/2000   dmunsil     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreDebugOutput)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OutputDebugStringA)
    APIHOOK_ENUM_ENTRY(OutputDebugStringW)
APIHOOK_ENUM_END

/*++

 This stub function throws away all debug strings

--*/

VOID 
APIHOOK(OutputDebugStringA)(
    LPCSTR lpOutputString
    )
{
    return;
}

/*++

 This stub function throws away all debug strings

--*/

VOID 
APIHOOK(OutputDebugStringW)(
    LPCWSTR lpOutputString
    )
{
    return;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, OutputDebugStringA)
    APIHOOK_ENTRY(KERNEL32.DLL, OutputDebugStringW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\ignorenomodechange.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreNoModeChange.cpp

 Abstract:

    Ignore mode changes that are not really different from the current mode.

    The problem is that even if there is no real mode change, the uniqueness 
    value for the mode is still updated. DirectDraw checks this value every 
    time it enters any API and if the mode uniqueness value has changed, it
    resets all it's objects.

    Applications will hit this if they call ChangeDisplaySettings* and don't 
    realize that even if the mode is identical, they'll still have to reset 
    all their objects.

 Notes:

    This is a general purpose shim.

 History:

    01/20/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreNoModeChange)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsA)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsW)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsExA)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsExW)
APIHOOK_ENUM_END


BOOL 
IsModeEqual(
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBitsPerPel,
    DWORD dwRefresh
    )
{
    BOOL     bRet = FALSE;
    DEVMODEA dm;
    
    dm.dmSize = sizeof(DEVMODEA);

    //
    // Get the existing settings.
    //
    if (EnumDisplaySettingsA(0, ENUM_CURRENT_SETTINGS, &dm)) {
        
        //
        // Assume that 0 or 1 means default refresh.
        //
        if (dwRefresh <= 1) {
            dwRefresh = dm.dmDisplayFrequency;
        }
        
        bRet = (dwWidth == dm.dmPelsWidth) &&
               (dwHeight == dm.dmPelsHeight) &&
               (dwBitsPerPel == dm.dmBitsPerPel) &&
               (dwRefresh == dm.dmDisplayFrequency);
    }

    if (bRet) {
        LOGN(
            eDbgLevelInfo,
            "[IsModeEqual] Ignoring irrelevant mode change.");
    } else {
        LOGN(
            eDbgLevelInfo,
            "Mode change is required.");
    }

    return bRet;
}

/*++

 Force temporary change.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsA)(
    LPDEVMODEA lpDevMode,
    DWORD      dwFlags
    )
{
    if (lpDevMode &&
        IsModeEqual(
            lpDevMode->dmPelsWidth, 
            lpDevMode->dmPelsHeight, 
            lpDevMode->dmBitsPerPel,
            lpDevMode->dmDisplayFrequency)) {
        
        return DISP_CHANGE_SUCCESSFUL;
    }

    return ORIGINAL_API(ChangeDisplaySettingsA)(
                            lpDevMode,
                            CDS_FULLSCREEN);
}

/*++

 Force temporary change.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsW)(
    LPDEVMODEW lpDevMode,
    DWORD      dwFlags
    )
{
    if (lpDevMode &&
        IsModeEqual(
            lpDevMode->dmPelsWidth, 
            lpDevMode->dmPelsHeight, 
            lpDevMode->dmBitsPerPel,
            lpDevMode->dmDisplayFrequency)) {
        
        return DISP_CHANGE_SUCCESSFUL;
    }

    return ORIGINAL_API(ChangeDisplaySettingsW)(
                            lpDevMode,
                            CDS_FULLSCREEN);
}

/*++

 Force temporary change.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsExA)(
    LPCSTR     lpszDeviceName,
    LPDEVMODEA lpDevMode,
    HWND       hwnd,
    DWORD      dwflags,
    LPVOID     lParam
    )
{
    if (lpDevMode &&
        IsModeEqual(
            lpDevMode->dmPelsWidth, 
            lpDevMode->dmPelsHeight, 
            lpDevMode->dmBitsPerPel,
            lpDevMode->dmDisplayFrequency)) {
        
        return DISP_CHANGE_SUCCESSFUL;
    }

    return ORIGINAL_API(ChangeDisplaySettingsExA)(
                            lpszDeviceName, 
                            lpDevMode, 
                            hwnd, 
                            CDS_FULLSCREEN, 
                            lParam);
}

/*++

 Force temporary change.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsExW)(
    LPCWSTR    lpszDeviceName,
    LPDEVMODEW lpDevMode,
    HWND       hwnd,
    DWORD      dwflags,
    LPVOID     lParam
    )
{
    if (lpDevMode &&
        IsModeEqual(
            lpDevMode->dmPelsWidth, 
            lpDevMode->dmPelsHeight, 
            lpDevMode->dmBitsPerPel,
            lpDevMode->dmDisplayFrequency)) {
        
        return DISP_CHANGE_SUCCESSFUL;
    }

    return ORIGINAL_API(ChangeDisplaySettingsExW)(
                            lpszDeviceName, 
                            lpDevMode, 
                            hwnd, 
                            CDS_FULLSCREEN, 
                            lParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsA)
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsW)
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsExA)
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\ignorehungapppaint.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreHungAppPaint.cpp

 Abstract:

    Setup the hollow brush to prevent user from trashing peoples windows.

 Notes:

    This is a general purpose shim.

 History:
    
    12/04/2000 linstev  Created

--*/

#include "precomp.h"
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(IgnoreHungAppPaint)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA)
    APIHOOK_ENUM_ENTRY(RegisterClassW)
    APIHOOK_ENUM_ENTRY(RegisterClassExA)
    APIHOOK_ENUM_ENTRY(RegisterClassExW)
APIHOOK_ENUM_END

struct HUNGCLASS
{
    char szClass[MAX_PATH];
    HUNGCLASS *next;
};
HUNGCLASS *g_lHungList = NULL;

BOOL g_bAll = FALSE;

/*++

 Check if a class needs a hollow brush.

--*/

BOOL
IsHungClassA(LPCSTR szClass)
{
    BOOL bRet = FALSE;

    if (szClass)
    {
        HUNGCLASS *h = g_lHungList;
        while (h)
        {
            if (_stricmp(szClass, h->szClass) == 0)
            {
                LOGN(eDbgLevelWarning, "Matched hung class: forcing HOLLOW_BRUSH");

                bRet = TRUE;
                break;
            }
            h = h->next;
        }
    }

    return bRet;
}

/*++

 Check if a class needs a hollow brush.

--*/

BOOL
IsHungClassW(LPCWSTR wszClass)
{
    CHAR szClass[MAX_PATH];

    WideCharToMultiByte(
        CP_ACP, 
        0, 
        (LPWSTR) wszClass, 
        MAX_PATH, 
        (LPSTR) szClass, 
        MAX_PATH, 
        0, 
        0);

    return IsHungClassA(szClass);
}

/*++

 Hook all possible calls that can initialize or change a window's
 WindowProc (or DialogProc)

--*/

ATOM
APIHOOK(RegisterClassA)(
    WNDCLASSA *lpWndClass  
    )
{
    if (lpWndClass && (g_bAll || IsHungClassA(lpWndClass->lpszClassName)))
    {
        lpWndClass->hbrBackground = (HBRUSH) GetStockObject(HOLLOW_BRUSH);
    }

    return ORIGINAL_API(RegisterClassA)(lpWndClass);
}

ATOM
APIHOOK(RegisterClassW)(
    WNDCLASSW *lpWndClass  
    )
{
    if (lpWndClass && IsHungClassW(lpWndClass->lpszClassName))
    {
        lpWndClass->hbrBackground = (HBRUSH) GetStockObject(HOLLOW_BRUSH);
    }

    return ORIGINAL_API(RegisterClassW)(lpWndClass);
}

ATOM
APIHOOK(RegisterClassExA)(
    WNDCLASSEXA *lpWndClass  
    )
{
    if (lpWndClass && IsHungClassA(lpWndClass->lpszClassName))
    {
        lpWndClass->hbrBackground = (HBRUSH) GetStockObject(HOLLOW_BRUSH);
    }

    return ORIGINAL_API(RegisterClassExA)(lpWndClass);
}

ATOM
APIHOOK(RegisterClassExW)(
    WNDCLASSEXW *lpWndClass  
    )
{
    if (lpWndClass && IsHungClassW(lpWndClass->lpszClassName))
    {
        lpWndClass->hbrBackground = (HBRUSH) GetStockObject(HOLLOW_BRUSH);
    }

    return ORIGINAL_API(RegisterClassExW)(lpWndClass);
}

/*++

 Parse the command line for fixes:

    CLASS1; CLASS2; CLASS3 ...

--*/

VOID
ParseCommandLineA(
    LPCSTR lpCommandLine
    )
{
    // Add all the defaults if no command line is specified
    if (!lpCommandLine || (lpCommandLine[0] == '\0'))
    {
        g_bAll = TRUE;
        DPFN(eDbgLevelInfo, "All classes will use HOLLOW_BRUSH");
        return;
    }

    char seps[] = " ,\t;";
    char *token = NULL;

    // Since strtok modifies the string, we need to copy it 
    LPSTR szCommandLine = (LPSTR) malloc(strlen(lpCommandLine) + 1);
    if (!szCommandLine) goto Exit;

    strcpy(szCommandLine, lpCommandLine);

    //
    // Run the string, looking for fix names
    //
    
    token = _strtok(szCommandLine, seps);
    while (token)
    {
        HUNGCLASS *h;

        h = (HUNGCLASS *) malloc(sizeof(HUNGCLASS));
        if (h)
        {
            h->next = g_lHungList;
            g_lHungList = h;

            strncpy(h->szClass, token, MAX_PATH);
            DPFN(eDbgLevelInfo, "Adding %s", token);

        }
        else
        {
            DPFN(eDbgLevelError, "Out of memory");
        }
    
        // Get the next token
        token = _strtok(NULL, seps);
    }

Exit:
    if (szCommandLine)
    {
        free(szCommandLine);
    }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        ParseCommandLineA(COMMAND_LINE);
    }

    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassW);
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExA);
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExW);

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\ignoresyscolchanges.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreSysColChanges.cpp

 Abstract:

    Do not change system colors. Of course this changes the behaviour between
    9x and NT, but we're trying to make the experience better.

 Notes:

    This is a general purpose shim.

 History:

    07/17/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreSysColChanges)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetSysColors) 
APIHOOK_ENUM_END

/*++

 Ignore changes to system colors

--*/

BOOL 
APIHOOK(SetSysColors)(
    int cElements,                 
    CONST INT *lpaElements,        
    CONST COLORREF *lpaRgbValues   
    )
{
    LOGN(
            eDbgLevelInfo,
            "Ignoring changes to system colors");

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, SetSysColors)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\ignoretapidisconnect.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    IgnoreTAPIDisconnect.cpp

 Abstract:

    NT4 does not send a disconnect message to the line callback. It's not clear 
    why this is the case. 

    The current behaviour seems to be correct, so this shim simply removes the 
    disconnect message from the queue.

 Notes:

    This is a general purpose shim.

 History:

    05/09/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreTAPIDisconnect)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(lineInitialize) 
APIHOOK_ENUM_END

/*++

 Ignore disconnect state.

--*/

VOID FAR PASCAL LineCallback(
    LINECALLBACK pfnOld,
    DWORD hDevice,             
    DWORD dwMsg,               
    DWORD dwCallbackInstance,  
    DWORD dwParam1,            
    DWORD dwParam2,            
    DWORD dwParam3             
    )
{
    if ((dwMsg == LINEAGENTSTATUS_STATE) && (dwParam1 & LINECALLSTATE_DISCONNECTED)) {
        //
        // Ignore disconnect message
        //
        return;
    }

    return (*pfnOld)(hDevice, dwMsg, dwCallbackInstance, dwParam1, dwParam2, dwParam3);    
}

/*++

 Hook the callback.

--*/

LONG 
APIHOOK(lineInitialize)(
    LPHLINEAPP lphLineApp,  
    HINSTANCE hInstance,    
    LINECALLBACK lpfnCallback,  
    LPCSTR lpszAppName,     
    LPDWORD lpdwNumDevs     
    )
{
    return ORIGINAL_API(lineInitialize)(lphLineApp, hInstance, 
        (LINECALLBACK) HookCallback(lpfnCallback, LineCallback),  lpszAppName,
        lpdwNumDevs);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(TAPI32.DLL, lineInitialize)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\ignoreoemtochar.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreOemToChar.cpp

 Abstract:

    Written originally to fix an Install Shield bug.  
    
    It may be specific to _ins5576._mp versions.

    The executable _ins5576._mp calls OemToChar on the string 
    "%userprofile%\local settings\temp\_istmp11.dir\_ins5576._mp".
    
    The call is unessasary and causes problems with path names that
    contain non-ansi characters.
    

 Notes:
    
    This is a general purpose shim.

 History:

    04/03/2001 a-larrsh  Created

--*/

#include "precomp.h"
#include <shlwapi.h>    // For PathFindFileName


IMPLEMENT_SHIM_BEGIN(IgnoreOemToChar)
#include "ShimHookMacro.h"

typedef BOOL (WINAPI *_pfn_OemToCharA)(LPCSTR lpszSrc, LPTSTR lpszDst);

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OemToCharA) 
APIHOOK_ENUM_END

/*++

 Hook the call to OemToCharA. Determine if the string should be ignored.

--*/

BOOL APIHOOK(OemToCharA)(
   LPCSTR lpszSrc,  // string to translate
   LPTSTR lpszDst   // translated string
)
{
   BOOL bReturn;
   CString sTemp(lpszSrc);

   sTemp.MakeUpper();

   if( sTemp.Find(L"TEMP") )
   {
      DPFN( eDbgLevelInfo, "Ignoring attempt to convert string %s\n", lpszSrc);

      if (lpszDst)
      {
         _tcscpy((char *)lpszDst, lpszSrc);
      }

      bReturn = TRUE;
   }
   else
   {
      bReturn = ORIGINAL_API(OemToCharA)(lpszSrc, lpszDst);
   }

   return bReturn;
}



/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, OemToCharA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\ignorevboverflow.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    IgnoreVBOverflow.cpp

 Abstract:

    Some VB applications don't expect full 32-bit handles from some APIs. VB
    type checking typically throws a "Runtime Error 6" message when 
    applications try and store a 32-bit value in a 16-bit variable.
    
    This fix works with VB5 and VB6 apps.

 Notes:

    This is a general purpose shim.

 History:

    05/21/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreVBOverflow)
#include "ShimHookMacro.h"

typedef DWORD (WINAPI *_pfn_VB5_vbaI2I4)();
typedef DWORD (WINAPI *_pfn_VB6_vbaI2I4)();

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(VB5_vbaI2I4)
    APIHOOK_ENUM_ENTRY(VB6_vbaI2I4)
APIHOOK_ENUM_END

/*++

  Zero the return if ecx > 0xFFFF

--*/

__declspec(naked)
VOID
APIHOOK(VB5_vbaI2I4)()
{
    __asm {
        test  ecx, 0xFFFF0000
        jz    Loc1
        xor   ecx, ecx
    Loc1:
        mov   eax, ecx
        ret
    }
}

/*++

  Zero the return if ecx > 0xFFFF

--*/

__declspec(naked)
VOID
APIHOOK(VB6_vbaI2I4)()
{
    __asm {
        test  ecx, 0xFFFF0000
        jz    Loc1
        xor   ecx, ecx
    Loc1:
        mov   eax, ecx
        ret
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_NAME(MSVBVM50.DLL, VB5_vbaI2I4, __vbaI2I4)
    APIHOOK_ENTRY_NAME(MSVBVM60.DLL, VB6_vbaI2I4, __vbaI2I4)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\keepwindowonmonitor.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    KeepWindowOnMonitor.cpp

 Abstract:

   Do not allow a window to be placed off the Monitor.

 History:

    04/24/2001  robkenny    Created
    09/10/2001  robkenny    Made shim more generic.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(KeepWindowOnMonitor)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowPos) 
    APIHOOK_ENUM_ENTRY(MoveWindow) 
    APIHOOK_ENUM_ENTRY(CreateWindowA) 
    APIHOOK_ENUM_ENTRY(CreateWindowExA) 
APIHOOK_ENUM_END


/*++

   Are these two RECTs equal
   
--*/

BOOL operator == (const RECT & rc1, const RECT & rc2)
{
    return rc1.left   == rc2.left   &&
           rc1.right  == rc2.right  &&
           rc1.top    == rc2.top    &&
           rc1.bottom == rc2.bottom;
}

/*++

   Are these two RECTs different
   
--*/

BOOL operator != (const RECT & rc1, const RECT & rc2)
{
    return ! (rc1 == rc2);
}

/*++

   Is rcWindow entirely visible on rcMonitor
   
--*/

BOOL EntirelyVisible(const RECT & rcWindow, const RECT & rcMonitor)
{
    return rcWindow.left   >= rcMonitor.left   &&
           rcWindow.right  <= rcMonitor.right  &&
           rcWindow.top    >= rcMonitor.top    &&
           rcWindow.bottom <= rcMonitor.bottom;
}


#define MONITOR_CENTER   0x0001        // center rect to monitor
#define MONITOR_CLIP     0x0000        // clip rect to monitor
#define MONITOR_WORKAREA 0x0002        // use monitor work area
#define MONITOR_AREA     0x0000        // use monitor entire area

//
//  ClipOrCenterRectToMonitor
//
//  The most common problem apps have when running on a
//  multimonitor system is that they "clip" or "pin" windows
//  based on the SM_CXSCREEN and SM_CYSCREEN system metrics.
//  Because of app compatibility reasons these system metrics
//  return the size of the primary monitor.
//
//  This shows how you use the new Win32 multimonitor APIs
//  to do the same thing.
//
BOOL ClipOrCenterRectToMonitor(
    LPRECT prcWindowPos,
    UINT flags)
{
    HMONITOR hMonitor;
    MONITORINFO mi;
    RECT        rcMonitorRect;
    int         w = prcWindowPos->right  - prcWindowPos->left;
    int         h = prcWindowPos->bottom - prcWindowPos->top;

    //
    // get the nearest monitor to the passed rect.
    //
    hMonitor = MonitorFromRect(prcWindowPos, MONITOR_DEFAULTTONEAREST);

    //
    // get the work area or entire monitor rect.
    //
    mi.cbSize = sizeof(mi);
    if ( !GetMonitorInfo(hMonitor, &mi) )
    {
        return FALSE;
    }

    if (flags & MONITOR_WORKAREA)
        rcMonitorRect = mi.rcWork;
    else
        rcMonitorRect = mi.rcMonitor;

    // We only want to move the window if it is not entirely visible.
    if (EntirelyVisible(*prcWindowPos, rcMonitorRect))
    {
        return FALSE;
    }
    //
    // center or clip the passed rect to the monitor rect
    //
    if (flags & MONITOR_CENTER)
    {
        prcWindowPos->left   = rcMonitorRect.left + (rcMonitorRect.right  - rcMonitorRect.left - w) / 2;
        prcWindowPos->top    = rcMonitorRect.top  + (rcMonitorRect.bottom - rcMonitorRect.top  - h) / 2;
        prcWindowPos->right  = prcWindowPos->left + w;
        prcWindowPos->bottom = prcWindowPos->top  + h;
    }
    else
    {
        prcWindowPos->left   = max(rcMonitorRect.left, min(rcMonitorRect.right-w,  prcWindowPos->left));
        prcWindowPos->top    = max(rcMonitorRect.top,  min(rcMonitorRect.bottom-h, prcWindowPos->top));
        prcWindowPos->right  = prcWindowPos->left + w;
        prcWindowPos->bottom = prcWindowPos->top  + h;
    }

    return TRUE;
}

/*++

   If hwnd is not entirely visible on a single monitor,
   move/resize the window as necessary.

--*/

void ClipOrCenterWindowToMonitor(
    HWND hwnd,
    HWND hWndParent,
    UINT flags,
    const char * API)
{
    // We only want to forcibly move top-level windows
    if (hWndParent == NULL || hWndParent == GetDesktopWindow())
    {
        // Grab the current position of the window
        RECT rcWindowPos;
        if ( GetWindowRect(hwnd, &rcWindowPos) )
        {
            RECT rcOrigWindowPos = rcWindowPos;

            // Calculate the new position of the window, based on flags
            if ( ClipOrCenterRectToMonitor(&rcWindowPos, flags) )
            {
                if (rcWindowPos != rcOrigWindowPos)
                {
                    DPFN( eDbgLevelInfo, "[%s] HWnd(0x08x) OrigWindowRect (%d, %d) x (%d, %d) moved to (%d, %d) x (%d, %d)\n",
                          API, hwnd,
                          rcOrigWindowPos.left, rcOrigWindowPos.top, rcOrigWindowPos.right, rcOrigWindowPos.bottom,
                          rcWindowPos.left, rcWindowPos.top, rcWindowPos.right, rcWindowPos.bottom);

                    SetWindowPos(hwnd, NULL, rcWindowPos.left, rcWindowPos.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
                }
            }
        }
    }
}


/*++

   Call SetWindowPos,
   but if the window is not entirely visible,
   the window will be centered on the nearest monitor.

--*/

BOOL
APIHOOK(SetWindowPos)(
  HWND hWnd,             // handle to window
  HWND hWndInsertAfter,  // placement-order handle
  int X,                 // horizontal position
  int Y,                 // vertical position
  int cx,                // width
  int cy,                // height
  UINT uFlags            // window-positioning options
)
{
    BOOL bReturn = ORIGINAL_API(SetWindowPos)(hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);

    ClipOrCenterWindowToMonitor(hWnd, GetParent(hWnd), MONITOR_CENTER | MONITOR_WORKAREA, "SetWindowPos");

    return bReturn;
}

/*++

   Call MoveWindow,
   but if the window is not entirely visible,
   the window will be centered on the nearest monitor.

--*/

BOOL
APIHOOK(MoveWindow)(
  HWND hWnd,      // handle to window
  int X,          // horizontal position
  int Y,          // vertical position
  int nWidth,     // width
  int nHeight,    // height
  BOOL bRepaint   // repaint option
)
{
    BOOL bReturn = ORIGINAL_API(MoveWindow)(hWnd, X, Y, nWidth, nHeight, bRepaint);

    ClipOrCenterWindowToMonitor(hWnd, GetParent(hWnd), MONITOR_CENTER | MONITOR_WORKAREA, "MoveWindow");

    return bReturn;
}

/*++

   Call CreateWindowA,
   but if the window is not entirely visible,
   the window will be centered on the nearest monitor.

--*/

HWND
APIHOOK(CreateWindowA)(
  LPCSTR lpClassName,  // registered class name
  LPCSTR lpWindowName, // window name
  DWORD dwStyle,        // window style
  int x,                // horizontal position of window
  int y,                // vertical position of window
  int nWidth,           // window width
  int nHeight,          // window height
  HWND hWndParent,      // handle to parent or owner window
  HMENU hMenu,          // menu handle or child identifier
  HINSTANCE hInstance,  // handle to application instance
  LPVOID lpParam        // window-creation data
)
{
    HWND hWnd = ORIGINAL_API(CreateWindowA)(lpClassName,
                                            lpWindowName,
                                            dwStyle,
                                            x,
                                            y,
                                            nWidth,
                                            nHeight,
                                            hWndParent,
                                            hMenu,
                                            hInstance,
                                            lpParam);

    if (hWnd)
    {
        ClipOrCenterWindowToMonitor(hWnd, hWndParent, MONITOR_CENTER | MONITOR_WORKAREA, "CreateWindowA");
    }

    return hWnd;
}

/*++

   Call CreateWindowExA,
   but if the window is not entirely visible,
   the window will be centered on the nearest monitor.

--*/

HWND
APIHOOK(CreateWindowExA)(
  DWORD dwExStyle,      // extended window style
  LPCSTR lpClassName,  // registered class name
  LPCSTR lpWindowName, // window name
  DWORD dwStyle,        // window style
  int x,                // horizontal position of window
  int y,                // vertical position of window
  int nWidth,           // window width
  int nHeight,          // window height
  HWND hWndParent,      // handle to parent or owner window
  HMENU hMenu,          // menu handle or child identifier
  HINSTANCE hInstance,  // handle to application instance
  LPVOID lpParam        // window-creation data
)
{
    HWND hWnd = ORIGINAL_API(CreateWindowExA)(dwExStyle,
                                              lpClassName,
                                              lpWindowName,
                                              dwStyle,
                                              x,
                                              y,
                                              nWidth,
                                              nHeight,
                                              hWndParent,
                                              hMenu,
                                              hInstance,
                                              lpParam);

    if (hWnd)
    {
        ClipOrCenterWindowToMonitor(hWnd, hWndParent, MONITOR_CENTER | MONITOR_WORKAREA, "CreateWindowExA");
    }

    return hWnd;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SetWindowPos)
    APIHOOK_ENTRY(USER32.DLL, MoveWindow)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\ignorezeromovewindow.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   IgnoreZeroMoveWindow.cpp

 Abstract:

   This shim changes MoveWindow calls with zero-sized width &
   height parameters to a value of one. NBA Live 99 was failing
   due to an internal check. This implies that WIN9x does not allow
   zero size windows.


 Notes:
    
    This is an app specific for NBA Live 99

 History:

    03/02/2000 a-chcoff   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreZeroMoveWindow)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(MoveWindow) 
APIHOOK_ENUM_END

/*++

 This function sanitizes 0 size windows by making them have a min height/width of 1.

--*/

BOOL 
APIHOOK(MoveWindow)(
    HWND hWnd,      // handle to window
    int X,          // horizontal position
    int Y,          // vertical position
    int nWidth,     // width
    int nHeight,    // height
    BOOL bRepaint   // repaint option
    )
{   
    if (0 == nWidth) nWidth=1;
    if (0 == nHeight) nHeight=1;

    return ORIGINAL_API(MoveWindow)(
        hWnd, X, Y, nWidth, nHeight, bRepaint);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, MoveWindow)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\lazyreleasedc.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    LazyReleaseDC.cpp

 Abstract:

    Delay releasing a DC by one call.  A DC is not released until the next call to ReleaseDC

 Notes:

    This is a general purpose shim.

 History:
    
    10/10/1999 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(LazyReleaseDC)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ReleaseDC) 
APIHOOK_ENUM_END

HWND                g_hWndPrev;
HDC                 g_hDcPrev;
CRITICAL_SECTION    g_MakeThreadSafe;

/*++

 Save this hWnd and hdc for releasing later. If there is already a DC to be 
 released, release it now.

--*/

int 
APIHOOK(ReleaseDC)(
    HWND hWnd, 
    HDC hdc
    )
{
    UINT uRet = 1; // All's well

    EnterCriticalSection(&g_MakeThreadSafe);

    // If there is a previous DC, release it now
    if (g_hDcPrev) {
        uRet = ORIGINAL_API(ReleaseDC)(g_hWndPrev, g_hDcPrev);
    }

    g_hWndPrev = hWnd;
    g_hDcPrev = hdc;

    LeaveCriticalSection(&g_MakeThreadSafe);

    return uRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hWndPrev = 0;
        g_hDcPrev = 0;

        InitializeCriticalSection(&g_MakeThreadSafe);
    }

    // Ignore Detach code
    /*
    else if (fdwReason == DLL_PROCESS_DETACH) {
        DeleteCriticalSection(&g_MakeThreadSafe);
    }
    */

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(USER32.DLL, ReleaseDC)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\injectdll.cpp ===
/*

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    InjectDll.cpp

 Abstract:

    This Shim inject given DLLs on the command line at
    SHIM_STATIC_DLLS_INITIALIZED so that if people try to load
    dynamic library in their own DllInit, no dependencies occur
    because the dynamic libraries are in place.

    One problem was: Visio 2000 call LoadLibrary(VBE6.DLL) which
    (shame on us) loads MSI.DLL in its DllInit.


 History:

    06/11/2001  pierreys    Created
*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(InjectDll)

#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

APIHOOK_ENUM_END

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    switch (fdwReason)
    {
        case SHIM_STATIC_DLLS_INITIALIZED:

            CSTRING_TRY
            {
                int             i, iDllCount;
                CString         *csArguments;

                CString         csCl(COMMAND_LINE);
                CStringParser   csParser(csCl, L";");

                iDllCount      = csParser.GetCount();
                csArguments    = csParser.ReleaseArgv();

                for (i=0; i<iDllCount; i++)
                {
                    if (LoadLibrary(csArguments[i].Get())==NULL)
                    {
                        LOGN(eDbgLevelError, "Failed to load %S DLL", csArguments[i].Get());

                        return(FALSE);
                    }
                }
            }
            CSTRING_CATCH
            {
                return FALSE;
            }
            break;
    }

    return TRUE;
}



HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\limitfindfile.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    LimitFindFile.cpp

 Abstract:

    This shim was originally intended for QuickTime's qt32inst.exe which
    did a breadth-first search of the directory tree and would overflow 
    the buffer in which it was keeping a list of subdirs yet to visit.

    With this shim you can limit the number of files that a single FindFile
    search will return, you can limit the number of subdirectories (aka the
    branching factor) returned, you can limit the "depth" to which any
    FindFile search will locate files, and you can specify whether these 
    limits should be applied to all FindFiles or only fully-qualified FindFiles.
    You can also request that FindFile return only short filenames.

    The shim's arguments are:
    DEPTH=#
    BRANCH=#
    FILES=#
    SHORTFILENAMES or LONGFILENAMES
    LIMITRELATIVE or ALLOWRELATIVE

    The default behavior is:
    SHORTFILENAMES
    DEPTH = 4
    ALLOWRELATIVE
    ... but if any command line is specified, the behavior is only that which
        is specified on the command line (no default behavior).

    An example command line:
    COMMAND_LINE="FILES=100 LIMITRELATIVE"
    Which would limit every FindFile search to returning 100 or fewer files (but
    still returning any and all subdirectories).

    Note: Depth is a bit tricky.  The method used is to count backslashes, so
    limiting depth to zero will allow no files to be found ("C:\autorun.bat" has
    1 backslash).

 History:

    08/24/2000 t-adams    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(LimitFindFile)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(FindFirstFileA) 
    APIHOOK_ENUM_ENTRY(FindNextFileA) 
    APIHOOK_ENUM_ENTRY(FindClose) 
APIHOOK_ENUM_END

// Linked list of FindFileHandles
struct FFNode
{
    FFNode  *next;
    HANDLE  hFF;
    DWORD   dwBranches;
    DWORD   dwFiles;
};
FFNode *g_FFList = NULL;

// Default behaviors - overridden by Commandline
BOOL  g_bUseShortNames = TRUE;
BOOL  g_bLimitDepth    = TRUE;
DWORD g_dwDepthLimit   = 4;
BOOL  g_bLimitRelative = FALSE;
BOOL  g_bLimitBranch   = FALSE;
DWORD g_dwBranchLimit  = 0;
BOOL  g_bLimitFiles    = FALSE;
DWORD g_dwFileLimit    = 0;


/*++

  Abstract:
    ApplyLimits applys the recently found file from lpFindFileData to the
    current node, checks that none of the limits have been violated, and
    shortens the filename if requested.

    It returns TRUE if within limits, FALSE if limits have been exceeded.
  History:

  08/24/2000    t-adams     Created

--*/
BOOL ApplyLimits(FFNode *pFFNode, LPWIN32_FIND_DATAA lpFindFileData)
{
    BOOL bRet = TRUE;

    // If it's a directory
    if ( lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
    {
        pFFNode->dwBranches++;
        if ( g_bLimitBranch && pFFNode->dwBranches > g_dwBranchLimit )
        {
            bRet = FALSE;
            goto exit;
        }
    }
    else
    { // else it's a file
        pFFNode->dwFiles++;
        if ( g_bLimitFiles && pFFNode->dwFiles > g_dwFileLimit )
        {
            bRet = FALSE;
            goto exit;
        }
    }

    // Change to short name if requested
    if ( g_bUseShortNames && NULL != lpFindFileData->cAlternateFileName[0])
    {
        _tcscpy(lpFindFileData->cFileName, lpFindFileData->cAlternateFileName);
        lpFindFileData->cAlternateFileName[0] = NULL;
    }

exit:
    return bRet;
}


/*++

  Abstract:
    CheckDepthLimit checks to see if the depth of the requested search
    is greater than is allowed.  If we are limiting relative paths, then
    the current directory is prepended to the requested search string.

    It returns TRUE if within limits, FALSE if limits have been exceeded.
  History:

  08/24/2000    t-adams     Created

--*/
BOOL
CheckDepthLimit(const CString & csFileName)
{
    BOOL   bRet = TRUE;

    CSTRING_TRY
    {
        // Check the depth of the requested file
        if ( g_bLimitDepth )
        {
    
            DWORD  dwDepth = -1;
            int nIndex = 0;
            do
            {
                dwDepth += 1;
                nIndex = csFileName.Find(L'\\', nIndex);
            }
            while( nIndex >= 0 );
    
            if ( dwDepth > g_dwDepthLimit )
            {
                bRet = FALSE;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return bRet;
}


/*++

  Abstract:
    This function checks the depth of the requested search (see comments above).
    If the depth check passes it performs the search, request limit application,
    and finally returns a successful handle only if within all limits.

  History:

  08/24/2000    t-adams     Created

--*/
HANDLE 
APIHOOK(FindFirstFileA)(
            LPCSTR lpFileName,
            LPWIN32_FIND_DATAA lpFindFileData)
{
    HANDLE hRet       = INVALID_HANDLE_VALUE;
    FFNode *pFFNode   = NULL;
    BOOL   bRelPath   = FALSE;

    CString csFileName(lpFileName);
    
    // Determine if the path is relative to the CWD:
    CString csDrive;
    csFileName.GetDrivePortion(csDrive);
    bRelPath = csDrive.IsEmpty();

    // If it is a relative path & we're not limiting such, then just do
    // the FindFile and get out.
    if ( bRelPath)
    {
        if (!g_bLimitRelative)
        {
            return ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);
        }

        // We need to expand the directory portion of lpFileName to its full path
        CString csPath;
        CString csFile;

        csFileName.GetNotLastPathComponent(csPath);
        csFileName.GetLastPathComponent(csFile);

        csPath.GetFullPathNameW();
        csPath.AppendPath(csFile);

        csFileName = csPath;

        // Check the depth limit
        if ( !CheckDepthLimit(csFileName) )
        {
            return INVALID_HANDLE_VALUE;
        }
    }

    hRet = ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);
    if ( INVALID_HANDLE_VALUE == hRet )
    {
        return hRet;
    }

    // Make a new node for this handle
    pFFNode = (FFNode *) malloc(sizeof FFNode);
    if ( !pFFNode )
    {
        // Don't close the find, maybe it could still work for the app.
        goto exit;
    }
    pFFNode->hFF = hRet;
    pFFNode->dwBranches = 0;
    pFFNode->dwFiles = 0;

    // Apply our limits until we get a passable find
    while( !ApplyLimits(pFFNode, lpFindFileData) )
    {
        // If there are no more files to find, clean up & exit
        //   else loop back & ApplyLimits again
        if ( !FindNextFileA(hRet, lpFindFileData) )
        {
            free(pFFNode);
            FindClose(hRet);
            hRet = INVALID_HANDLE_VALUE;
            goto exit;
        }
    }

    // We are clear to add this node to the global list
    pFFNode->next = g_FFList;
    g_FFList = pFFNode;

exit:
    return hRet;
}


/*++

  Abstract:
    This function continues a limited search given the search's handle.

  History:

  08/24/2000    t-adams     Created

--*/
BOOL 
APIHOOK(FindNextFileA)(
            HANDLE hFindFile, 
            LPWIN32_FIND_DATAA lpFindFileData)
{

    FFNode *pFFNode = NULL;
    BOOL bRet = ORIGINAL_API(FindNextFileA)(hFindFile, lpFindFileData);

    if ( !bRet )
    {
        goto exit;
    }

    // Find our node in the global list
    pFFNode = g_FFList;
    while( pFFNode )
    {
        if ( pFFNode->hFF == hFindFile )
        {
            break;
        }
        pFFNode = pFFNode->next;
    }

    // We don't keep track of relative-path searches if we're not
    // limiting such.
    if ( pFFNode == NULL )
    {
        goto exit;
    }

    // Apply our limits until we get a passable find
    while( !ApplyLimits(pFFNode, lpFindFileData) )
    {
        // If there are no more files to find return FALSE
        //   else loop back & ApplyLimits again
        if ( !FindNextFileA(hFindFile, lpFindFileData) )
        {
            bRet = FALSE;
            goto exit;
        }
    }

exit:
    return bRet;
}


/*++

  Abstract:
    This function closes a search, cleaning up the structures used
    in keeping track of the limits.

  History:

  08/24/2000    t-adams     Created

--*/
BOOL 
APIHOOK(FindClose)(
            HANDLE hFindFile)
{

    FFNode *pFFNode, *prev;

    BOOL bRet = ORIGINAL_API(FindClose)(hFindFile);

    // Find the node that matches the handle
    pFFNode = g_FFList;
    prev = NULL;
    while( pFFNode )
    {
        if ( pFFNode->hFF == hFindFile )
        {
            // Remove this node from this list
            if ( prev )
            {
                prev->next = pFFNode->next;
            }
            else
            {
                g_FFList = pFFNode->next;
            }

            free(pFFNode);
            pFFNode = NULL;
            break;
        }
        prev = pFFNode;
        pFFNode = pFFNode->next;
    }

    return bRet;
}


/*++

  Abstract:
    This function parses the command line.
    See the top of the file for valid arguments.

  History:

  08/24/2000    t-adams     Created

--*/
// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

VOID 
ParseCommandLine( LPCSTR lpCommandLine )
{
    char seps[] = " ,\t;:=";
    BOOL  *pbOption = NULL;
    DWORD *pdwValue = NULL;
    char *token = NULL;

    // Since strtok modifies the string, we need to copy it 
    LPSTR szCommandLine = (LPSTR) malloc(strlen(lpCommandLine)+1);
    if (!szCommandLine)
    {
        goto Exit;
    }

    strcpy(szCommandLine, lpCommandLine);

    // If there is a command line, reset the default behavior
    if ( NULL != *szCommandLine )
    {
        g_bLimitDepth = FALSE;
        g_bLimitBranch = FALSE;
        g_bLimitFiles = FALSE;
        g_bUseShortNames = FALSE;
    }

    // Run the command line
    
    token = _strtok(szCommandLine, seps);

    while (token)
    {
        // If we're looking for a value
        if ( pdwValue )
        {
            *pdwValue = atol(token);
            pdwValue = NULL;
        }
        else
        { // We're expecting a keyword
            if ( strcmp("DEPTH", token) == 0 )
            {
                g_bLimitDepth = TRUE;
                pdwValue = &g_dwDepthLimit;
            }
            else if ( strcmp("BRANCH", token) == 0 )
            {
                g_bLimitBranch = TRUE;
                pdwValue = &g_dwBranchLimit;
            }
            else if ( strcmp("FILES", token) == 0 )
            {
                g_bLimitFiles = TRUE;
                pdwValue = &g_dwFileLimit;
            }
            else if ( strcmp("SHORTFILENAMES", token) == 0)
            {
                g_bUseShortNames = TRUE;
                // Don't need a value here
            }
            else if ( strcmp("LONGFILENAMES", token) == 0)
            {
                g_bUseShortNames = FALSE;
                // Don't need a value here
            }
            else if ( strcmp("LIMITRELATIVE", token) == 0)
            {
                g_bLimitRelative = TRUE;
                // Don't need a value here
            }
            else if ( strcmp("ALLOWRELATIVE", token) == 0)
            {
                g_bLimitRelative = FALSE;
                // Don't need a value here
            }
        }

        // Get the next token
        token = _strtok(NULL, seps);
    }

Exit:
    if (szCommandLine)
    {
        free(szCommandLine);
    }
    //
    // Dump results of command line parse
    //

    DPFN( eDbgLevelInfo, "===================================\n");
    DPFN( eDbgLevelInfo, "          Limit FindFile           \n");
    DPFN( eDbgLevelInfo, "===================================\n");
    if ( g_bLimitDepth )
    {
        DPFN( eDbgLevelInfo, " Depth  = %d\n", g_dwDepthLimit);
    }
    if ( g_bLimitBranch )
    {
        DPFN( eDbgLevelInfo, " Branch = %d\n", g_dwBranchLimit);
    }
    if ( g_bLimitFiles )
    {
        DPFN( eDbgLevelInfo, " Files  = %d\n", g_dwFileLimit);
    }
    if ( g_bLimitRelative )
    {
        DPFN( eDbgLevelInfo, " Limiting Relative Paths.\n");
    }
    else
    {
        DPFN( eDbgLevelInfo, " Not Limiting Relative Paths.\n");
    }
    if ( g_bUseShortNames )
    {
        DPFN( eDbgLevelInfo, " Using short file names.\n");
    }

    DPFN( eDbgLevelInfo, "-----------------------------------\n");
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        ParseCommandLine(COMMAND_LINE);
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindClose)
    CALL_NOTIFY_FUNCTION

HOOK_END



IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\loadlibrarycwd.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    LoadLibraryCWD.cpp

 Abstract:

    Some applications rely on the fact that LoadLibrary will search the current
    working directory (CWD) in-order to find dlls that are there.  This is a
    security hole, so we apply shims to only the apps that really need it.
    
 Notes:
    
    This is a general purpose shim.

 History:

    05/01/2002 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(LoadLibraryCWD)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

typedef BOOL (WINAPI *_pfn_SetDllDirectoryW)(LPCWSTR lpPathName);

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        
        HMODULE hMod = GetModuleHandleW(L"KERNEL32.DLL");

        if (hMod) {

            // Get the API
            _pfn_SetDllDirectoryW pfn = (_pfn_SetDllDirectoryW)
                GetProcAddress(hMod, "SetDllDirectoryW");

            if (pfn) {
                // Success, the API exists
                LOGN(eDbgLevelError, "DLL search order now starts with current directory");
                pfn(L".");
                return TRUE;
            }
        }

        LOGN(eDbgLevelError, "ERROR: DLL search order API does not exist");
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\main.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Main.cpp

 Abstract:


 Notes:

 History:

    15/11/2000 clupu Created
    11/30/2000 a-brienw modified for beginning of misc shim

--*/

#include "precomp.h"
#include "ShimHookMacro.h"

DECLARE_SHIM(AliasDXDC)
DECLARE_SHIM(CorrectACMArgs)
DECLARE_SHIM(CorrectACMStreamOpen)
DECLARE_SHIM(CorrectActiveMoviePath)
DECLARE_SHIM(CorrectCreateIcon)
DECLARE_SHIM(CorrectCreateSurface)
DECLARE_SHIM(CorrectFarEastFont)
DECLARE_SHIM(CorrectFilePathInSetDlgItemText)
DECLARE_SHIM(CorrectFilePathsUninstall)
DECLARE_SHIM(CorrectOpenFileExclusive)
DECLARE_SHIM(CorrectVerInstallFile)
DECLARE_SHIM(CUASAppFix)
DECLARE_SHIM(CUASDisableCicero)
DECLARE_SHIM(DelayDllInit)
DECLARE_SHIM(DelayShowGroup)
DECLARE_SHIM(DelayWin95VersionLie)
DECLARE_SHIM(DelayWinMMCallback)
DECLARE_SHIM(DeleteSpecifiedFiles)
DECLARE_SHIM(DeRandomizeExeName)
DECLARE_SHIM(DisableBoostThread)
DECLARE_SHIM(DisableFilterKeys)
DECLARE_SHIM(DisableScreenSaver)
DECLARE_SHIM(DisableStickyKeys)

#ifndef SHIM_WIN2K
DECLARE_SHIM(DisableThemes)
#endif // SHIM_WIN2K

DECLARE_SHIM(DisableW2KOwnerDrawButtonStates)
DECLARE_SHIM(EmptyClipboardtoSet)
DECLARE_SHIM(EmulateGetStdHandle)
DECLARE_SHIM(EmulateGetStringType)
DECLARE_SHIM(EmulateLZHandles)
DECLARE_SHIM(EnlargeGetObjectBufferSize)
DECLARE_SHIM(ExtractAssociatedIcon)
DECLARE_SHIM(FailCloseProfileUserMapping)
DECLARE_SHIM(FailGetStdHandle)
DECLARE_SHIM(FailObsoleteShellAPIs)
DECLARE_SHIM(FailOpenFile)
DECLARE_SHIM(FakeThemeMetrics)
DECLARE_SHIM(FilterNetworkResources)
DECLARE_SHIM(FixServiceStartupCircularDependency)
DECLARE_SHIM(Force640x480x8)
DECLARE_SHIM(Force640x480x16)
DECLARE_SHIM(ForceAdminAccess)
DECLARE_SHIM(ForceAnsiWindowProc)
DECLARE_SHIM(ForceAppendMenuSuccess)
DECLARE_SHIM(ForceApplicationFocus)
DECLARE_SHIM(ForceAVIWindow)
DECLARE_SHIM(ForceDefaultSystemPaletteEntries)
DECLARE_SHIM(ForceDirectDrawEmulation)
DECLARE_SHIM(ForceDirectDrawWait)
DECLARE_SHIM(ForceDisplayMode)
DECLARE_SHIM(ForceSeparateVDM)
DECLARE_SHIM(ForceSimpleWindow)
DECLARE_SHIM(ForceTemporaryModeChange)
DECLARE_SHIM(ForceWorkingDirectoryToEXEPath)
DECLARE_SHIM(FUSBadApplicationType1)
DECLARE_SHIM(FUSBadApplicationType2)
DECLARE_SHIM(FUSBadApplicationType3)
DECLARE_SHIM(FUSBadApplicationType4)
DECLARE_SHIM(GlobalMemoryStatusLie)
DECLARE_SHIM(HandleDBCSUserName)
DECLARE_SHIM(HandleDBCSUserName2)
DECLARE_SHIM(HeapClearAllocation)
DECLARE_SHIM(HeapDelayLocalFree)
DECLARE_SHIM(HeapForceGrowable)
DECLARE_SHIM(HeapIgnoreMoveable)
DECLARE_SHIM(HeapLookasideFree)
DECLARE_SHIM(HeapPadAllocation)
DECLARE_SHIM(HeapValidateFrees)
DECLARE_SHIM(HideCursor)
DECLARE_SHIM(HideTaskBar)
DECLARE_SHIM(IgnoreAltTab)
DECLARE_SHIM(IgnoreCoCreateInstance)
DECLARE_SHIM(IgnoreCRTExit)
DECLARE_SHIM(IgnoreDebugOutput)
DECLARE_SHIM(IgnoreFreeLibrary)
DECLARE_SHIM(IgnoreHungAppPaint)
DECLARE_SHIM(IgnoreMCIStop)
DECLARE_SHIM(IgnoreMessageBox)
DECLARE_SHIM(IgnoreNoModeChange)
DECLARE_SHIM(IgnoreOemToChar)
DECLARE_SHIM(IgnoreSysColChanges)
DECLARE_SHIM(IgnoreTAPIDisconnect)
DECLARE_SHIM(IgnoreVBOverflow)
DECLARE_SHIM(IgnoreZeroMoveWindow)
DECLARE_SHIM(InjectDll)
DECLARE_SHIM(KeepWindowOnMonitor)
DECLARE_SHIM(LazyReleaseDC)
DECLARE_SHIM(LimitFindFile)
DECLARE_SHIM(LoadComctl32Version5)
DECLARE_SHIM(LoadLibraryCWD)
DECLARE_SHIM(LowerThreadPriority)
DECLARE_SHIM(MoveIniToRegistry)
DECLARE_SHIM(MoveWinInitRenameToReg)
DECLARE_SHIM(NullHwndInMessageBox)
DECLARE_SHIM(PaletteRestore)
DECLARE_SHIM(PopulateDefaultHKCUSettings)
DECLARE_SHIM(PropagateProcessHistory)
DECLARE_SHIM(RecopyExeFromCD)
DECLARE_SHIM(RedirectDBCSTempPath)
DECLARE_SHIM(RedirectEXE)
DECLARE_SHIM(RedirectWindowsDirToSystem32)
DECLARE_SHIM(RemoveBroadcastPostMessage)
DECLARE_SHIM(RemoveDDEFlagFromShellExecuteEx)
DECLARE_SHIM(RemoveInvalidW2KWindowStyles)
DECLARE_SHIM(RemoveIpFromMsInfoCommandLine)
DECLARE_SHIM(RemoveNoBufferingFlagFromCreateFile)
DECLARE_SHIM(RemoveOverlappedFlagFromCreateFile)
DECLARE_SHIM(RemoveReadOnlyAttribute)
DECLARE_SHIM(RestoreSystemCursors)
DECLARE_SHIM(SearchPathInAppPaths)
DECLARE_SHIM(SetEnvironmentVariable)
DECLARE_SHIM(StackSwap)
DECLARE_SHIM(TerminateExe)
DECLARE_SHIM(TrimVersionInfo)
DECLARE_SHIM(UnMirrorImageList)
DECLARE_SHIM(WaveOutUsePreferredDevice)
DECLARE_SHIM(WinG32SysToSys32)


VOID MULTISHIM_NOTIFY_FUNCTION()(DWORD fdwReason)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DPF("AcGenral", eDbgLevelSpew, "General Purpose Shims initialized.");
            break;

        case DLL_PROCESS_DETACH:
            DPF("AcGenral", eDbgLevelSpew, "General Purpose Shims uninitialized.");
            break;

        default:
            break;
    }
}

MULTISHIM_BEGIN()

    MULTISHIM_ENTRY(AliasDXDC)
    MULTISHIM_ENTRY(CorrectACMArgs)
    MULTISHIM_ENTRY(CorrectACMStreamOpen)
    MULTISHIM_ENTRY(CorrectActiveMoviePath)
    MULTISHIM_ENTRY(CorrectCreateIcon)
    MULTISHIM_ENTRY(CorrectCreateSurface)
    MULTISHIM_ENTRY(CorrectFarEastFont)
    MULTISHIM_ENTRY(CorrectFilePathInSetDlgItemText)
    MULTISHIM_ENTRY(CorrectFilePathsUninstall)
    MULTISHIM_ENTRY(CorrectOpenFileExclusive)
    MULTISHIM_ENTRY(CorrectVerInstallFile)
    MULTISHIM_ENTRY(CUASAppFix)
    MULTISHIM_ENTRY(CUASDisableCicero)
    MULTISHIM_ENTRY(DelayDllInit)
    MULTISHIM_ENTRY(DelayShowGroup)
    MULTISHIM_ENTRY(DelayWin95VersionLie)
    MULTISHIM_ENTRY(DelayWinMMCallback)
    MULTISHIM_ENTRY(DeleteSpecifiedFiles)
    MULTISHIM_ENTRY(DeRandomizeExeName)
    MULTISHIM_ENTRY(DisableBoostThread)
    MULTISHIM_ENTRY(DisableFilterKeys)
    MULTISHIM_ENTRY(DisableScreenSaver)
    MULTISHIM_ENTRY(DisableStickyKeys)

#ifndef SHIM_WIN2K
    MULTISHIM_ENTRY(DisableThemes)
#endif // SHIM_WIN2K

    MULTISHIM_ENTRY(DisableW2KOwnerDrawButtonStates)
    MULTISHIM_ENTRY(EmptyClipboardtoSet)
    MULTISHIM_ENTRY(EmulateGetStdHandle)
    MULTISHIM_ENTRY(EmulateGetStringType)
    MULTISHIM_ENTRY(EmulateLZHandles)
    MULTISHIM_ENTRY(EnlargeGetObjectBufferSize)
    MULTISHIM_ENTRY(ExtractAssociatedIcon)
    MULTISHIM_ENTRY(FailCloseProfileUserMapping)
    MULTISHIM_ENTRY(FailGetStdHandle)
    MULTISHIM_ENTRY(FailObsoleteShellAPIs)
    MULTISHIM_ENTRY(FailOpenFile)
    MULTISHIM_ENTRY(FakeThemeMetrics)
    MULTISHIM_ENTRY(FilterNetworkResources)
    MULTISHIM_ENTRY(FixServiceStartupCircularDependency)
    MULTISHIM_ENTRY(Force640x480x8)
    MULTISHIM_ENTRY(Force640x480x16)
    MULTISHIM_ENTRY(ForceAdminAccess)
    MULTISHIM_ENTRY(ForceAnsiWindowProc)
    MULTISHIM_ENTRY(ForceAppendMenuSuccess)
    MULTISHIM_ENTRY(ForceApplicationFocus)
    MULTISHIM_ENTRY(ForceAVIWindow)
    MULTISHIM_ENTRY(ForceDefaultSystemPaletteEntries)
    MULTISHIM_ENTRY(ForceDirectDrawEmulation)
    MULTISHIM_ENTRY(ForceDirectDrawWait)
    MULTISHIM_ENTRY(ForceDisplayMode)
    MULTISHIM_ENTRY(ForceSeparateVDM)
    MULTISHIM_ENTRY(ForceSimpleWindow)
    MULTISHIM_ENTRY(ForceTemporaryModeChange)
    MULTISHIM_ENTRY(ForceWorkingDirectoryToEXEPath)
    MULTISHIM_ENTRY(FUSBadApplicationType1)
    MULTISHIM_ENTRY(FUSBadApplicationType2)
    MULTISHIM_ENTRY(FUSBadApplicationType3)
    MULTISHIM_ENTRY(FUSBadApplicationType4)
    MULTISHIM_ENTRY(GlobalMemoryStatusLie)
    MULTISHIM_ENTRY(HandleDBCSUserName)
    MULTISHIM_ENTRY(HandleDBCSUserName2)
    MULTISHIM_ENTRY(HeapClearAllocation)
    MULTISHIM_ENTRY(HeapDelayLocalFree)
    MULTISHIM_ENTRY(HeapForceGrowable)
    MULTISHIM_ENTRY(HeapIgnoreMoveable)
    MULTISHIM_ENTRY(HeapLookasideFree)
    MULTISHIM_ENTRY(HeapPadAllocation)
    MULTISHIM_ENTRY(HeapValidateFrees)
    MULTISHIM_ENTRY(HideCursor)
    MULTISHIM_ENTRY(HideTaskBar)
    MULTISHIM_ENTRY(IgnoreAltTab)
    MULTISHIM_ENTRY(IgnoreCoCreateInstance)
    MULTISHIM_ENTRY(IgnoreCRTExit)
    MULTISHIM_ENTRY(IgnoreDebugOutput)
    MULTISHIM_ENTRY(IgnoreFreeLibrary)
    MULTISHIM_ENTRY(IgnoreHungAppPaint)
    MULTISHIM_ENTRY(IgnoreMCIStop)
    MULTISHIM_ENTRY(IgnoreMessageBox)
    MULTISHIM_ENTRY(IgnoreNoModeChange)
    MULTISHIM_ENTRY(IgnoreOemToChar)
    MULTISHIM_ENTRY(IgnoreSysColChanges)
    MULTISHIM_ENTRY(IgnoreTAPIDisconnect)
    MULTISHIM_ENTRY(IgnoreVBOverflow)
    MULTISHIM_ENTRY(IgnoreZeroMoveWindow)
    MULTISHIM_ENTRY(InjectDll)
    MULTISHIM_ENTRY(KeepWindowOnMonitor)
    MULTISHIM_ENTRY(LazyReleaseDC)
    MULTISHIM_ENTRY(LimitFindFile)
    MULTISHIM_ENTRY(LoadComctl32Version5)
    MULTISHIM_ENTRY(LoadLibraryCWD)
    MULTISHIM_ENTRY(LowerThreadPriority)
    MULTISHIM_ENTRY(MoveIniToRegistry)
    MULTISHIM_ENTRY(MoveWinInitRenameToReg)
    MULTISHIM_ENTRY(NullHwndInMessageBox)
    MULTISHIM_ENTRY(PaletteRestore)
    MULTISHIM_ENTRY(PopulateDefaultHKCUSettings)
    MULTISHIM_ENTRY(PropagateProcessHistory)
    MULTISHIM_ENTRY(RecopyExeFromCD)
    MULTISHIM_ENTRY(RedirectDBCSTempPath)
    MULTISHIM_ENTRY(RedirectEXE)
    MULTISHIM_ENTRY(RedirectWindowsDirToSystem32)
    MULTISHIM_ENTRY(RemoveBroadcastPostMessage)
    MULTISHIM_ENTRY(RemoveDDEFlagFromShellExecuteEx)
    MULTISHIM_ENTRY(RemoveInvalidW2KWindowStyles)
    MULTISHIM_ENTRY(RemoveIpFromMsInfoCommandLine)
    MULTISHIM_ENTRY(RemoveNoBufferingFlagFromCreateFile)
    MULTISHIM_ENTRY(RemoveOverlappedFlagFromCreateFile)
    MULTISHIM_ENTRY(RemoveReadOnlyAttribute)
    MULTISHIM_ENTRY(RestoreSystemCursors)
    MULTISHIM_ENTRY(SearchPathInAppPaths)
    MULTISHIM_ENTRY(SetEnvironmentVariable)
    MULTISHIM_ENTRY(StackSwap)
    MULTISHIM_ENTRY(TerminateExe)
    MULTISHIM_ENTRY(TrimVersionInfo)
    MULTISHIM_ENTRY(UnMirrorImageList)
    MULTISHIM_ENTRY(WaveOutUsePreferredDevice)
    MULTISHIM_ENTRY(WinG32SysToSys32)

    CALL_MULTISHIM_NOTIFY_FUNCTION()

MULTISHIM_END()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\loadcomctl32version5.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    e.cpp

 Abstract:

    This DLL Hooks CreateWindow, DialogBox, and CreateDialog routines in order to
    ensure that Comctl32 version 5 is loaded.

 Notes:
    
    This is a general purpose shim.

 History:

    05/25/2000 lamadio  Added initial shims to ensure that comctl32 version 6 
                        is loaded.

--*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(LoadComctl32Version5)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateWindowExA) 
    APIHOOK_ENUM_ENTRY(CreateWindowExW) 
    APIHOOK_ENUM_ENTRY(DialogBoxParamA) 
    APIHOOK_ENUM_ENTRY(DialogBoxParamW) 
    APIHOOK_ENUM_ENTRY(DialogBoxIndirectParamA) 
    APIHOOK_ENUM_ENTRY(DialogBoxIndirectParamW) 
    APIHOOK_ENUM_ENTRY(CreateDialogParamA) 
    APIHOOK_ENUM_ENTRY(CreateDialogParamW) 
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamA) 
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamW) 
APIHOOK_ENUM_END

BOOL g_fComctl32V5Loaded = FALSE;

typedef BOOL  (__stdcall *PFNInitCommonControlsEx)(LPINITCOMMONCONTROLSEX);
void EnsureComctl32Version5IsLoaded()
{

    if (g_fComctl32V5Loaded == FALSE) {
        HMODULE hMod = GetModuleHandle(TEXT("Comctl32.dll"));
        if (hMod == NULL) {
            hMod = LoadLibrary(TEXT("Comctl32.dll"));
            if (hMod) {
                PFNInitCommonControlsEx pfn = (PFNInitCommonControlsEx)GetProcAddress(hMod, "InitCommonControlsEx");
                if (pfn) {
                    INITCOMMONCONTROLSEX icc;
                    icc.dwSize = sizeof(icc);
                    icc.dwICC = 0x00003FFF;     // Initialize all classes.

                    pfn(&icc);
                }
            }
        }

        g_fComctl32V5Loaded = TRUE;      // Well, we tried. If we failed, we shouldn't try more than once.
    }
}



HWND APIHOOK(CreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle,  int X, int Y, 
                             int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(CreateWindowExA)(dwExStyle, lpClassName, lpWindowName, dwStyle,  X, Y, 
                             nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
}
HWND APIHOOK(CreateWindowExW)(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle,  int X, int Y, 
                             int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(CreateWindowExW)(dwExStyle, lpClassName, lpWindowName, dwStyle,  X, Y, 
                             nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
}

INT_PTR APIHOOK(DialogBoxParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(DialogBoxParamA)(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
}

INT_PTR APIHOOK(DialogBoxParamW)(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(DialogBoxParamW)(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
}

INT_PTR APIHOOK(DialogBoxIndirectParamA)(HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(DialogBoxIndirectParamA)(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
}

INT_PTR APIHOOK(DialogBoxIndirectParamW)(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(DialogBoxIndirectParamW)(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
}

HWND APIHOOK(CreateDialogParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(CreateDialogParamA)(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
}

HWND APIHOOK(CreateDialogParamW)(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(CreateDialogParamW)(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
}

HWND APIHOOK(CreateDialogIndirectParamA)(HINSTANCE hInstance, LPCDLGTEMPLATEA lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(CreateDialogIndirectParamA)(hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam);
}

HWND APIHOOK(CreateDialogIndirectParamW)(HINSTANCE hInstance, LPCDLGTEMPLATEW lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(CreateDialogIndirectParamW)(hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExW)
    APIHOOK_ENTRY(USER32.DLL, DialogBoxParamA)
    APIHOOK_ENTRY(USER32.DLL, DialogBoxParamW)
    APIHOOK_ENTRY(USER32.DLL, DialogBoxIndirectParamA)
    APIHOOK_ENTRY(USER32.DLL, DialogBoxIndirectParamW)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamA)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamW)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamA)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\lowerthreadpriority.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    LowerThreadPriority.cpp

 Abstract:

    Includes the following hooks:
    
    SetThreadPriority: if the thread priority is THREAD_PRIORITY_TIME_CRITICAL, 
                       change it to THREAD_PRIORITY_HIGHEST.
    
    SetPriorityClass: if the process priority is HIGH_PRIORITY_CLASS or 
                      REALTIME_PRIORITY_CLASS, change it to 
                      NORMAL_PRIORITY_CLASS. 
    
 Notes:
    
    This is a general purpose shim.
   
 History:

    05/23/2001  qzheng      Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(LowerThreadPriority)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetThreadPriority) 
    APIHOOK_ENUM_ENTRY(SetPriorityClass) 
APIHOOK_ENUM_END

BOOL
APIHOOK(SetThreadPriority)(
    HANDLE hThread,
    int nPriority
    )
{
    BOOL bReturnValue;
    int  nNewPriority;

    LOGN( eDbgLevelInfo,
        "Original SetThreadPriority(hThread: 0x%08lx, nPriority: %d).", hThread, nPriority );
    
	nNewPriority = (nPriority == THREAD_PRIORITY_TIME_CRITICAL) ? THREAD_PRIORITY_HIGHEST : nPriority;
    bReturnValue = ORIGINAL_API(SetThreadPriority)(hThread, nNewPriority);

	if( bReturnValue && (nNewPriority != nPriority) ) {
        LOGN( eDbgLevelInfo,
            "New SetThreadPriority(hThread: 0x%08lx, nPriority: %d).", hThread, nNewPriority );
    }

    return bReturnValue;
}

BOOL
APIHOOK(SetPriorityClass)(
    HANDLE hProcess,
    DWORD  dwPriorityClass
    )
{
    BOOL  bReturnValue;
    DWORD dwNewPriorityClass;

    LOGN( eDbgLevelInfo,
        "Original SetPriorityClass(hProcess: 0x%08lx, dwPriorityClass: %d).", hProcess, dwPriorityClass );
    
	dwNewPriorityClass = ( (dwPriorityClass == HIGH_PRIORITY_CLASS) || (dwPriorityClass == REALTIME_PRIORITY_CLASS) ) ? 
	                     NORMAL_PRIORITY_CLASS : dwPriorityClass;
    bReturnValue = ORIGINAL_API(SetPriorityClass)(hProcess, dwNewPriorityClass);

	if( bReturnValue && (dwNewPriorityClass != dwPriorityClass) ) {
	    LOGN( eDbgLevelInfo,
             "New SetPriorityClass (hProcess: 0x%08lx, dwPriorityClass: %d).", hProcess, dwNewPriorityClass );
    }

    return bReturnValue;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, SetThreadPriority)
    APIHOOK_ENTRY(KERNEL32.DLL, SetPriorityClass)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\moveinitoregistry.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   MoveIniToRegistry.cpp

 Abstract:

   This shim will move entries written directly into an INI file into the registry.

   Usage:
   IniFile  [IniSection]   IniKeyName  RegBaseKey RegKeyPath RegValue RegValueType

   IniFile          Full path to INI file (env variables like used for CorrectFilePaths may be used)
   [IniSection]     INI section name, must include the brackets
   IniKeyName       INI key name (the thing on the left of the =)
   RegBaseKey       One of: HKEY_CLASSES_ROOT, HKEY_CURRENT_CONFIG, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE or HKEY_USERS
   RegKeyPath       path of the registry key
   RegValue         registry value name (it may be different from IniKeyName
   RegValueType     One of: REG_SZ, REG_EXPAND_SZ, REG_DWORD


   Example:
   win.ini [Boot] SCRNSAVE.EXE HKEY_CURRENT_USER "Default\Control Panel\Desktop" SCRNSAVE.EXE REG_SZ
   Win.ini
   [Desktop]
   SCRNSAVE.EXE=goofy screen saver
   will be placed:
   RegSetValueEX("HKEY_USERS\Default\Control Panel\Desktop", "SCRNSAVE.EXE", 0, REG_SZ, "goofy screen saver", strlen("goofy screen saver"));
   

  Note:
    A section name of * implies that the data is not associated with any specific section,
    this allows this shim to work with (stupid) apps that put the data into random sections.
    If there are multiple entries, the first matching 

 Created:

   08/17/2000 robkenny

 Modified:



--*/

#include "precomp.h"
#include <ClassCFP.h>       // for EnvironmentValues

IMPLEMENT_SHIM_BEGIN(MoveIniToRegistry)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA) 
    APIHOOK_ENUM_ENTRY(OpenFile) 
    APIHOOK_ENUM_ENTRY(WriteFile) 
    APIHOOK_ENUM_ENTRY(CloseHandle) 
APIHOOK_ENUM_END


// Convert a string into a root HKEY
HKEY ToHKEY(const CString & csKey)
{
    if (csKey.CompareNoCase(L"HKEY_CLASSES_ROOT") == 0) 
    {
        return HKEY_CLASSES_ROOT;
    } 
    else  if (csKey.CompareNoCase(L"HKEY_CURRENT_CONFIG") == 0)
    {
        return HKEY_CURRENT_CONFIG;
    } 
    else  if (csKey.CompareNoCase(L"HKEY_CURRENT_USER") == 0)  
    {
        return HKEY_CURRENT_USER;
    } 
    else  if (csKey.CompareNoCase(L"HKEY_LOCAL_MACHINE") == 0) 
    {
        return HKEY_LOCAL_MACHINE;
    } 
    else  if (csKey.CompareNoCase(L"HKEY_USERS") == 0)   
    {
        return HKEY_USERS;
    } 
    else
    {
        return NULL;
    }
}

DWORD ToRegType(const CString & csRegType)
{
    if (csRegType.CompareNoCase(L"REG_SZ") == 0)  
    {
        return REG_SZ;
    }   
    else if (csRegType.CompareNoCase(L"REG_EXPAND_SZ") == 0)  
    {
        return REG_EXPAND_SZ;
    }   
    else if (csRegType.CompareNoCase(L"REG_DWORD") == 0)      
    {
        return REG_DWORD;
    }   
    else if (csRegType.CompareNoCase(L"REG_DWORD_LITTLE_ENDIAN") == 0)  
    {
        // Same as REG_DWORD
        return REG_DWORD;
    }   
    else
    {
        return REG_NONE;
    }
}

class IniEntry
{
protected:

public:
    CString         lpIniFileName;
    HANDLE          hIniFileHandle;
    CString         lpSectionName;
    CString         lpKeyName;
    CString         lpKeyPath;
    DWORD           dwRegDataType;
    HKEY            hkRootKey;

    BOOL            bFileNameConverted;
    BOOL            bDirty;         // Has this file been modified

    BOOL    Set(const char * iniFileName,
                const char * iniSectionName,
                const char * iniKeyName,
                const char * rootKeyName,
                const char * keyPath,
                const char * valueName,
                const char * valueType);
    void    Clear();

    void    Convert();
    VOID    ReadINIEntry(CString & csEntry);
    void    MoveToRegistry();

    inline void SetDirty(BOOL dirty)
    {
        bDirty = dirty;
    }
    inline void OpenFile(HANDLE hFile)
    {
        hIniFileHandle  = hFile;
        bDirty          = FALSE;
    }
    inline void CloseFile()
    {
        hIniFileHandle  = INVALID_HANDLE_VALUE;
        bDirty          = FALSE;
    }
};


void IniEntry::Clear()
{
    if (hIniFileHandle != INVALID_HANDLE_VALUE)
        CloseHandle(hIniFileHandle);
}

BOOL IniEntry::Set(
    const char * iniFileName,
    const char * iniSectionName,
    const char * iniKeyName,
    const char * rootKeyName,
    const char * keyPath,
    const char * valueName,
    const char * valueType)
{
    hIniFileHandle      = INVALID_HANDLE_VALUE;
    dwRegDataType       = REG_NONE;
    hkRootKey           = NULL;
    bFileNameConverted  = FALSE;
    bDirty              = FALSE;

    CString csValue(valueType);
    CString csRootKey(rootKeyName);

    dwRegDataType = ToRegType(csValue);
    if (dwRegDataType == REG_NONE)
        return false;

    // Attempt to open the registry keys, if these fail, we need go no further
    hkRootKey = ToHKEY(csRootKey);
    if (hkRootKey == NULL)
        return false;

    // We cannot open the RegKey here; ADVAPI32.dll hasn't been initialzed, yet.

    lpKeyPath       = keyPath;
    lpIniFileName   = iniFileName;
    lpSectionName   = iniSectionName;
    lpKeyName       = iniKeyName;

    return TRUE;
}


// Read a single line of data from the file,
// return TRUE if hit EOF
BOOL GetLine(HANDLE hFile, char * line, DWORD lineSize, DWORD * charsRead)
{
    BOOL retval = FALSE;

    *charsRead = 0;
    while (*charsRead < lineSize - 1)
    {
        DWORD bytesRead;
        char *nextChar = line + *charsRead;

        BOOL readOK = ReadFile(hFile, nextChar, 1, &bytesRead, NULL);
        if (!readOK || bytesRead != 1)
        {
            // Some sort of error
            retval = TRUE;
            break;
        }
        // Eat CR-LF
        if (!IsDBCSLeadByte(*nextChar) && *nextChar == '\n')
            break;
        if (!IsDBCSLeadByte(*nextChar) && *nextChar != '\r')
            *charsRead += 1;
    }

    line[*charsRead] = 0;

    return retval;
}

VOID FindLine(HANDLE hFile, const CString & findMe, CString & csLine, const WCHAR * stopLooking)
{
    csLine.Empty();

    const size_t findMeLen      = findMe.GetLength();

    // Search for findMe
    while (true)
    {
        char line[300];

        DWORD dataRead;
        BOOL eof = GetLine(hFile, line, sizeof(line), &dataRead);
        if (eof)
            break;

        CString csTemp(line);
        if (dataRead >= findMeLen) 
        {
            csTemp.TrimLeft();
            if (csTemp.ComparePartNoCase(findMe, 0, findMeLen) == 0) 
            {
                // Found the section
                csLine = csTemp;
                break;
            }

            // Check for termination
            if (stopLooking && csTemp.CompareNoCase(stopLooking) == 0) 
            {
                csLine = csTemp;
                break;
            }
        }
    }
}

// Convert all %envVars% in the string to text.
void IniEntry::Convert()
{
    if (!bFileNameConverted)
    {
        EnvironmentValues   env;
        WCHAR * fullIniFileName = env.ExpandEnvironmentValueW(lpIniFileName);
        if (fullIniFileName) 
        {
            lpIniFileName = fullIniFileName;
            delete fullIniFileName;
        }

        bFileNameConverted = TRUE;
    }
}

// Read the data from the INI file
// We *cannot* use GetPrivateProfileStringA since it might be re-routed to the registry
// Return the number of chars read.
VOID IniEntry::ReadINIEntry(CString & csEntry)
{
    csEntry.Empty();

    CString csLine;
    
    HANDLE hFile = CreateFileW(lpIniFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {

        // If the section name is *, we don't need to search
        if (lpSectionName.GetAt(0) != L'*') 
        {
            FindLine(hFile, lpSectionName, csLine, NULL);
        }

        // Our early termination string.
        // If the section name is *, we look forever, otherwise
        // we stop looking if we find a line starting with a [
        const WCHAR * stopLooking = lpSectionName.GetAt(0) == L'*' ? NULL : L"[";

        // Search for lpKeyName
        FindLine(hFile, lpKeyName, csLine, stopLooking);
        if (!csLine.IsEmpty())
        {
            int nEqual = csLine.Find(L'=');
            if (nEqual >= 0)
            {
                csLine.Mid(nEqual + 1, csEntry);
            }
        }

        CloseHandle(hFile);
    }
}

// Move the INI file entry into the registry
void IniEntry::MoveToRegistry()
{
    // Don't bother with the work, if they never wrote any data into the file.
    if (!bDirty)
        return;

    HKEY regKey;
    LONG success = RegOpenKeyExW(
        hkRootKey,
        lpKeyPath,
        0,
        KEY_ALL_ACCESS,
        &regKey);
    if (success != ERROR_SUCCESS)
        return;

    CString csIniEntry;

    ReadINIEntry(csIniEntry);
    if (!csIniEntry.IsEmpty())  
    {
        switch (dwRegDataType)
        {
        case REG_SZ:
        case REG_EXPAND_SZ:
            {
                const WCHAR * lpIniEntry = csIniEntry.Get();
                DWORD dwValueSize = (csIniEntry.GetLength() + 1) * sizeof(WCHAR);
                success = RegSetValueExW(regKey, lpKeyName, 0, dwRegDataType, (CONST BYTE *)lpIniEntry, dwValueSize);
                if (success == ERROR_SUCCESS)
                {
                    LOGN( eDbgLevelError, "IniEntry::MoveToRegistry, KeyPath(%S) Value(%S) set to (%S)\n",
                        lpKeyPath, lpKeyName, lpIniEntry);
                }
            }
            break;

        case REG_DWORD:
            {
                WCHAR * unused;
                long iniValue = wcstol(csIniEntry, &unused, 10);

                RegSetValueExW(regKey, lpKeyName, 0, dwRegDataType, (CONST BYTE *)&iniValue, sizeof(iniValue));
                if (success == ERROR_SUCCESS)
                {
                    LOGN( eDbgLevelError, "IniEntry::MoveToRegistry, KeyPath(%S) Value(%S) set to (%d)\n", lpKeyPath, lpKeyName, iniValue);
                }
            }
            break;
        }
    }

    RegCloseKey(regKey);
}

class IniEntryList : public VectorT<IniEntry>
{
public:
    void    OpenFile(const char *fileName, HANDLE hFile);
    void    CloseFile(HANDLE hFile);
    void    WriteFile(HANDLE hFile);    

    void    Add(const char * iniFileName,
                const char * iniSectionName,
                const char * iniKeyName,
                const char * rootKeyName,
                const char * keyPath,
                const char * valueName,
                const char * valueType);
};

// A file is being opened.
// If it is one that we are interested in, remember the handle
void IniEntryList::OpenFile(const char *fileName, HANDLE handle)
{
    CString csFileName(fileName);
    csFileName.GetFullPathNameW();

    const int nElem = Size();
    for (int i = 0; i < nElem; ++i)
    {
        IniEntry & elem = Get(i);

        elem.Convert();

        // Convert fileName to a full pathname for the compare.
        char fullPathName[MAX_PATH];
        char * filePart;
        
        if (csFileName.CompareNoCase(elem.lpIniFileName) == 0)  
        {
            elem.OpenFile(handle);

            DPFN( eDbgLevelSpew, "IniEntryList::OpenFile(%S) Handle(%d) has been opened for write\n", elem.lpIniFileName.Get(), elem.hIniFileHandle);
        }
    }
}

// A file has been closed,
// Check to see if this is a handle to a file that we are interested in.
// If it is a match, then move the INI entries into the registry.
void IniEntryList::CloseFile(HANDLE handle)
{
    const int nElem = Size();
    for (int i = 0; i < nElem; ++i)
    {
        IniEntry & elem = Get(i);

        if (elem.hIniFileHandle == handle)  
        {
            DPFN( eDbgLevelSpew, "IniEntryList::CloseFile(%S) Handle(%d) has been closed\n", elem.lpIniFileName.Get(), elem.hIniFileHandle);

            // Move the ini entry into the registry
            elem.MoveToRegistry();

            elem.CloseFile();
        }
    }
}

// A file has been closed,
// Check to see if this is a handle to a file that we are interested in.
// If it is a match, then move the INI entries into the registry.
void IniEntryList::WriteFile(HANDLE handle)
{
    const int nElem = Size();
    for (int i = 0; i < nElem; ++i)
    {
        IniEntry & elem = Get(i);

        if (elem.hIniFileHandle == handle && !elem.bDirty)  
        {
            DPFN( eDbgLevelSpew, "IniEntryList::CloseFile(%S) Handle(%d) has been closed\n", elem.lpIniFileName.Get(), elem.hIniFileHandle);
            
            elem.SetDirty(TRUE);
        }
    }
}

// Attempt to add these values to the list.
// Only if all values are valid, will a new entry be created.
void IniEntryList::Add(const char * iniFileName,
                       const char * iniSectionName,
                       const char * iniKeyName,
                       const char * rootKeyName,
                       const char * keyPath,
                       const char * valueName,
                       const char * valueType)
{
    // Make room for this 
    int lastElem = Size();
    if (Resize(lastElem + 1))   
    {
        IniEntry & iniEntry = Get(lastElem);

        // The VectorT does not call the constructors for new elements
        // Inplace new
        new (&iniEntry) IniEntry;

        if (iniEntry.Set(iniFileName, iniSectionName, iniKeyName, rootKeyName, keyPath, valueName, valueType)) 
        {
            // Keep the value
            nVectorList += 1;
        }
    }
}

IniEntryList * g_IniEntryList = NULL;

/*++

    Create the appropriate g_PathCorrector

--*/
BOOL ParseCommandLine(const char * commandLine)
{
    g_IniEntryList = new IniEntryList;
    if (!g_IniEntryList)
        return FALSE;

    int argc;
    char **argv = _CommandLineToArgvA(commandLine, &argc);

    // If there are no command line arguments, stop now
    if (argc == 0 || argv == NULL)
        return TRUE;

#if DBG
    {
        for (int i = 0; i < argc; ++i)
        {
            const char * arg = argv[i];
            DPFN( eDbgLevelSpew, "Argv[%d] = (%s)\n", i, arg);
        }
    }
#endif

    // Search the beginning of the command line for the switches
    for (int i = 0; i+6 < argc; i += 7)
    {
        g_IniEntryList->Add(
            argv[i + 0],
            argv[i + 1],
            argv[i + 2],
            argv[i + 3],
            argv[i + 4],
            argv[i + 5],
            argv[i + 6]);
    }

    return TRUE;
}


HANDLE 
APIHOOK(CreateFileA)(
    LPCSTR lpFileName,                         // file name
    DWORD dwDesiredAccess,                      // access mode
    DWORD dwShareMode,                          // share mode
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
    DWORD dwCreationDisposition,                // how to create
    DWORD dwFlagsAndAttributes,                 // file attributes
    HANDLE hTemplateFile                        // handle to template file
    )
{
    HANDLE returnValue = ORIGINAL_API(CreateFileA)(
                lpFileName,
                dwDesiredAccess,
                dwShareMode,
                lpSecurityAttributes,
                dwCreationDisposition,
                dwFlagsAndAttributes,
                hTemplateFile);

    if ( (dwDesiredAccess & GENERIC_WRITE) && (returnValue != INVALID_HANDLE_VALUE))
        g_IniEntryList->OpenFile(lpFileName, returnValue);

    return returnValue;
}


HFILE 
APIHOOK(OpenFile)(
    LPCSTR lpFileName,        // file name
    LPOFSTRUCT lpReOpenBuff,  // file information
    UINT uStyle               // action and attributes
    )
{
    HFILE returnValue = ORIGINAL_API(OpenFile)(lpFileName, lpReOpenBuff, uStyle);
 
    if ((uStyle & OF_WRITE) && (returnValue != HFILE_ERROR))
        g_IniEntryList->OpenFile(lpReOpenBuff->szPathName, (HANDLE)returnValue);

    return returnValue;
}

BOOL 
APIHOOK(CloseHandle)(
    HANDLE hObject   // handle to object
    )
{
    BOOL returnValue = ORIGINAL_API(CloseHandle)(hObject);

    if (hObject != INVALID_HANDLE_VALUE)
        g_IniEntryList->CloseFile(hObject);

    return returnValue;
}

BOOL
APIHOOK(WriteFile)(
    HANDLE hFile,                    // handle to file
    LPCVOID lpBuffer,                // data buffer
    DWORD nNumberOfBytesToWrite,     // number of bytes to write
    LPDWORD lpNumberOfBytesWritten,  // number of bytes written
    LPOVERLAPPED lpOverlapped        // overlapped buffer
    )
{
    BOOL returnValue = ORIGINAL_API(WriteFile)(
        hFile,
        lpBuffer,
        nNumberOfBytesToWrite,
        lpNumberOfBytesWritten,
        lpOverlapped
        );

    g_IniEntryList->WriteFile(hFile);

    return returnValue;
}

/*++

  Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        return ParseCommandLine(COMMAND_LINE);
    }
    
    return TRUE;
}

HOOK_BEGIN

    APIHOOK_ENTRY(Kernel32.DLL, CreateFileA )
    APIHOOK_ENTRY(Kernel32.DLL, OpenFile )
    APIHOOK_ENTRY(Kernel32.DLL, WriteFile )
    APIHOOK_ENTRY(Kernel32.DLL, CloseHandle )

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\movewininitrenametoreg.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    MoveWinInitRenameToReg.cpp

 Abstract:
    This shim hooks ExitWindowsEx as well as waits for DLL_PROCESS_DETACH 
    and then moves the contents of the [Rename] section of wininit.ini 
    into the registry via MoveFileEx().  

 History:

 07/24/2000 t-adams    Created

--*/
#include "precomp.h"

#define KEY_SIZE_STEP MAX_PATH

IMPLEMENT_SHIM_BEGIN(MoveWinInitRenameToReg)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ExitWindowsEx) 
APIHOOK_ENUM_END



/*++

  Abstract:
    Moves the entries in the Rename section of WinInit.ini into
    the registry via MoveFileEx().

  History:

  07/24/2000    t-adams     Created

--*/
void MoveWinInitRenameToReg(void)
{
    LPWSTR szKeys               = NULL;
    LPWSTR szFrom               = NULL;
    DWORD  dwKeysSize           = 0;
    LPWSTR pszTo                = NULL;

    CString csWinInit;
    CString csWinInitBak;

    // Construct the paths to wininit.ini and wininit.bak
    csWinInit.GetWindowsDirectoryW();
    csWinInitBak.GetWindowsDirectoryW();

    csWinInit.AppendPath(L"\\wininit.ini");
    csWinInitBak.AppendPath(L"\\wininit.bak");

    // Make sure wininit.ini exists.
    if( GetFileAttributesW(csWinInit) != -1 )
    {
        // Copy wininit.ini to wininit.bak because we will be destroying
        // wininit.ini as we read through its keys and can't simply rename
        // it to wininit.bak later.
        CopyFileW(csWinInit, csWinInitBak, FALSE);
    
        // Read the "key" names.
        // Since we can't know how big the list of keys is going to be,
        // continue to try to get the list until GetPrivateProfile string
        // returns something other than dwKeysSize-2 (indicating too small
        // of a buffer).
    
        // Read the "key" names.
        // Since we can't know how big the list of keys is going to be,
        // continue to try to get the list until GetPrivateProfile string
        // returns something other than dwKeysSize-2 (indicating too small
        // of a buffer).
        
        do
        {
            if( NULL != szKeys )
            {
                free(szKeys);
            }
            dwKeysSize += KEY_SIZE_STEP;
            szKeys = (LPWSTR) malloc(dwKeysSize * sizeof(WCHAR));
            if( NULL == szKeys )
            {
                goto Exit;
            }
        }
        while(GetPrivateProfileStringW(L"Rename", NULL, NULL, szKeys, dwKeysSize, csWinInit) 
                == dwKeysSize - 2);
    
        szFrom = (LPWSTR) malloc(MAX_PATH * sizeof(WCHAR));
        if( NULL != szFrom )
        {
        
            // Traverse through the keys.
            // Delete each key after we read it so that if there are multiple "NUL" keys,
            // our calls to GetPrivateProfileStringA won't continue to return only the
            // first NUL key's associated value.
            pszTo = szKeys;
            while(*pszTo != NULL)
            {
                GetPrivateProfileStringW(L"Rename", pszTo, NULL, szFrom, MAX_PATH, csWinInit);
                WritePrivateProfileStringW(L"Rename", pszTo, NULL, csWinInit);
                // If pszTo is "NUL", then the intention is to delete the szFrom file, so pass
                // NULL to MoveFileExA().
                if( wcscmp(pszTo, L"NUL") == 0 )
                {
                    MoveFileExW(szFrom, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                }
                else
                {
                    MoveFileExW(szFrom, pszTo, MOVEFILE_DELAY_UNTIL_REBOOT);
                }
        
                // Move to the next file (key)
                pszTo += wcslen(pszTo) + 1;
            }
        
            // delete WinInit.ini
            DeleteFileW(csWinInit);
        }
    }

Exit:
    if( NULL != szKeys )
    {
        free(szKeys);
    }
    if( NULL != szFrom )
    {
        free(szFrom);
    }
}


/*++

  Abstract:
    Hook ExitWindowsEx in case the program resets the machine, keeping
    us from receiving the DLL_PROCESS_DETACH message.  (Shim originally
    written for an uninstall program that caused a reset.)

  History:

  07/24/2000    t-adams     Created

--*/
BOOL 
APIHOOK(ExitWindowsEx)( 
            UINT uFlags, 
            DWORD dwReserved) 
{
    MoveWinInitRenameToReg();
    return ORIGINAL_API(ExitWindowsEx)(uFlags, dwReserved);    
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_DETACH)
    {
        MoveWinInitRenameToReg();
    }
    
    return TRUE;
}

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, ExitWindowsEx )

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\precomp.h ===
#ifndef _GPSHIMS_PRECOMP_H_
#define _GPSHIMS_PRECOMP_H_

#include "ShimHook.h"
#include "IllegalStr.h" // make strXXX routines illegal
#include "tcs.h"

using namespace ShimLib;


#endif // _GPSHIMS_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\nullhwndinmessagebox.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    NullHwndInMessageBox.cpp

 Abstract:

    This shim replaces "non window" handles in msgbox with NULL to tell it 
    that desktop is owner.

 Notes:

    This is a general purpose shim.

 History:

    12/08/1999 a-jamd   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(NullHwndInMessageBox)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(MessageBoxA)
    APIHOOK_ENUM_ENTRY(MessageBoxW)
APIHOOK_ENUM_END

/*++

 This stub function sets hWnd to NULL if it is not a valid window.

--*/
int 
APIHOOK(MessageBoxA)(
    HWND    hWnd,
    LPCSTR  lpText,
    LPCSTR  lpCaption,
    UINT    uType
    )
{
    if (IsWindow(hWnd) == 0) {
        hWnd = NULL;
    }

    return ORIGINAL_API(MessageBoxA)(hWnd, lpText, lpCaption, uType);
}

/*++

 This stub function sets hWnd to NULL if it is not a valid window.

--*/

int 
APIHOOK(MessageBoxW)(
    HWND    hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT    uType
    )
{
    if (IsWindow(hWnd) == 0) {
        hWnd = NULL;
    }

    return ORIGINAL_API(MessageBoxW)(hWnd, lpText, lpCaption, uType);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, MessageBoxA)
    APIHOOK_ENTRY(USER32.DLL, MessageBoxW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\paletterestore.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    PaletteRestore.cpp

 Abstract:

    On win9x, all palette state was maintained through a mode change. On NT, 
    this can cause numerous problems, most often when task switching between 
    the application and the desktop.

    Unfortunately, GetSystemPaletteEntries does NOT return the peFlags part
    of the PALETTEENTRY struct, which means that we have to intercept the 
    other palette setting functions just to find out what the real palette 
    is.

    The strategy is as follows:
        
        1. Catch all known ways of setting up the palette
        2. After a mode change, restore the palette 

    In order to do this, we also have to keep a list of the DCs so we know 
    which palette was animated/realized and the active window to which it 
    belongs.

    Not yet implemented:

        1. Track whether a palette change came from within DirectDraw, since on 
           win9x, DirectDraw doesn't use GDI to set the palette, so calls to 
           GetSystemPaletteEntries will return different results. 

 Notes:

    This is a general purpose shim.

 History:

    05/20/2000 linstev  Created

--*/

#include "precomp.h"
#include "CharVector.h"

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(PaletteRestore)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsA)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsW)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsExA)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsExW)
    APIHOOK_ENUM_ENTRY(SetSystemPaletteUse)
    APIHOOK_ENUM_ENTRY(CreatePalette)
    APIHOOK_ENUM_ENTRY(SetPaletteEntries)
    APIHOOK_ENUM_ENTRY(AnimatePalette)
    APIHOOK_ENUM_ENTRY(CreateDCA)
    APIHOOK_ENUM_ENTRY(CreateDCW)
    APIHOOK_ENUM_ENTRY(CreateCompatibleDC)
    APIHOOK_ENUM_ENTRY(DeleteDC)
    APIHOOK_ENUM_ENTRY(GetDC)
    APIHOOK_ENUM_ENTRY(GetWindowDC)
    APIHOOK_ENUM_ENTRY(ReleaseDC)
    APIHOOK_ENUM_ENTRY(SelectPalette)
    APIHOOK_ENUM_ENTRY(GetSystemPaletteEntries)
    APIHOOK_ENUM_ENTRY(RealizePalette)
    APIHOOK_ENUM_ENTRY(DeleteObject)
APIHOOK_ENUM_END

//
// Keep track of the last realized palette
//

PALETTEENTRY g_lastPal[256];

//
// Keeps the last value of the call to SetSystemPaletteUse
//

UINT g_uLastUse = SYSPAL_NOSTATIC256;

//
// Default system palette: needed because NT only keeps 20 colors
//
 
DWORD g_palDefault[256] = 
{
    0x00000000, 0x00000080, 0x00008000, 0x00008080,
    0x00800000, 0x00800080, 0x00808000, 0x00C0C0C0,
    0x00C0DCC0, 0x00F0CAA6, 0x04081824, 0x04142830,
    0x0418303C, 0x04304D61, 0x0451514D, 0x044D7161,
    0x04826D61, 0x040C1414, 0x04597582, 0x04759E08,
    0x04303438, 0x04AA6938, 0x04203428, 0x04496161,
    0x0449869E, 0x047D9A6D, 0x040869CB, 0x048E8682,
    0x0475615D, 0x040061EB, 0x04000871, 0x042C3830,
    0x040471EF, 0x048E92AA, 0x04306DF7, 0x0404C3C3,
    0x0492AAB2, 0x04101814, 0x04040C08, 0x040C7110,
    0x04CFA282, 0x040008AA, 0x0428412C, 0x04498EB2,
    0x04204D61, 0x04555955, 0x0404D3D3, 0x041C3C4D,
    0x0420A6F7, 0x0410A210, 0x0418241C, 0x045DAEF3,
    0x04719EAA, 0x04B2E720, 0x04102871, 0x0486C3D3,
    0x04288A2C, 0x040C51BA, 0x0459716D, 0x04494D4D,
    0x04AAB6C3, 0x04005100, 0x0420CBF7, 0x044D8A51,
    0x04BEC7B2, 0x04043CBA, 0x04101C18, 0x040851DF,
    0x04A6E7A6, 0x049ECF24, 0x04797592, 0x04AE7559,
    0x049E8269, 0x04CFE3DF, 0x040C2030, 0x0428692C,
    0x049EA2A2, 0x04F7C782, 0x0434617D, 0x04B6BEBE,
    0x04969E86, 0x04DBFBD3, 0x04655149, 0x0465EF65,
    0x04AED3D3, 0x04E7924D, 0x04B2BEB2, 0x04D7DBDB,
    0x04797571, 0x04344D59, 0x0486B2CF, 0x04512C14,
    0x04A6FBFB, 0x04385965, 0x04828E92, 0x041C4161,
    0x04595961, 0x04002000, 0x043C6D7D, 0x045DB2D7,
    0x0438EF3C, 0x0451CB55, 0x041C2424, 0x0461C3F3,
    0x0408A2A2, 0x0438413C, 0x04204951, 0x04108A14,
    0x04103010, 0x047DE7F7, 0x04143449, 0x04B2652C,
    0x04F7EBAA, 0x043C7192, 0x0404FBFB, 0x04696151,
    0x04EFC796, 0x040441D7, 0x04000404, 0x04388AF7,
    0x048AD3F3, 0x04006500, 0x040004E3, 0x04DBFFFF,
    0x04F7AE69, 0x04CF864D, 0x0455A2D3, 0x04EBEFE3,
    0x04EB8A41, 0x04CF9261, 0x04C3F710, 0x048E8E82,
    0x04FBFFFF, 0x04104110, 0x04040851, 0x0482FBFB,
    0x043CC734, 0x04088A8A, 0x04384545, 0x04514134,
    0x043C7996, 0x041C6161, 0x04EBB282, 0x04004100,
    0x04715951, 0x04A2AAA6, 0x04B2B6B2, 0x04C3FBFB,
    0x04000834, 0x0428413C, 0x04C7C7CF, 0x04CFD3D3,
    0x04824520, 0x0408CB0C, 0x041C1C1C, 0x04A6B29A,
    0x0471A6BE, 0x04CF9E6D, 0x046D7161, 0x04008A04,
    0x045171BE, 0x04C7D3C3, 0x04969E96, 0x04798696,
    0x042C1C10, 0x04385149, 0x04BE7538, 0x0408141C,
    0x04C3C7C7, 0x04202C28, 0x04D3E3CF, 0x0471826D,
    0x04653C1C, 0x0404EF08, 0x04345575, 0x046D92A6,
    0x04797979, 0x0486F38A, 0x04925528, 0x04E3E7E7,
    0x04456151, 0x041C499A, 0x04656961, 0x048E9EA2,
    0x047986D3, 0x04204151, 0x048AC7E3, 0x04007100,
    0x04519EBE, 0x0410510C, 0x04A6AAAA, 0x042C3030,
    0x04D37934, 0x04183030, 0x0449828E, 0x04CBFBC3,
    0x046D7171, 0x040428A6, 0x044D4545, 0x04040C14,
    0x04087575, 0x0471CB79, 0x044D6D0C, 0x04FBFBD3,
    0x04AAB2AE, 0x04929292, 0x04F39E55, 0x04005D00,
    0x04E3D7B2, 0x04F7FBC3, 0x043C5951, 0x0404B2B2,
    0x0434658E, 0x040486EF, 0x04F7FBE3, 0x04616161,
    0x04DFE3DF, 0x041C100C, 0x0408100C, 0x0408180C,
    0x04598600, 0x0424FBFB, 0x04346171, 0x04042CC7,
    0x04AEC79A, 0x0445AE4D, 0x0428A62C, 0x04EFA265,
    0x047D8282, 0x04F7D79A, 0x0465D3F7, 0x04E3E7BA,
    0x04003000, 0x04245571, 0x04DF823C, 0x048AAEC3,
    0x04A2C3D3, 0x04A6FBA2, 0x04F3FFF3, 0x04AAD7E7,
    0x04EFEFC3, 0x0455F7FB, 0x04EFF3F3, 0x04BED3B2,
    0x0404EBEB, 0x04A6E3F7, 0x00F0FBFF, 0x00A4A0A0,
    0x00808080, 0x000000FF, 0x0000FF00, 0x0000FFFF,
    0x00FF0000, 0x00FF00FF, 0x00FFFF00, 0x00FFFFFF
};

// 
// Critical section used when accessing our lists
//

CRITICAL_SECTION g_csLists;

//
// A single item in the list of palettes
//

struct PALITEM
{
    HPALETTE hPal;
    PALETTEENTRY palPalEntry[256];
};

//
// Vector class that stores all the known palettes
//

class CPalVector : public VectorT<PALITEM>
{
public:
    // Find an hPal
    PALITEM *Find(HPALETTE hPal)
    {
        for (int i=0; i<Size(); ++i)
        {
            PALITEM &pitem = Get(i);
            if (pitem.hPal == hPal)
            {
                return &pitem;
            }
        }
        
        DPFN( eDbgLevelWarning, "Find: Could not find HPALETTE %08lx", hPal);

        return NULL;
    }
    
    // Remove an hPal
    BOOL Remove(HPALETTE hPal)
    {
        if (hPal)
        {
            EnterCriticalSection(&g_csLists);

            for (int i=0; i<Size(); ++i)
            {
                PALITEM &pitem = Get(i);
                if (pitem.hPal == hPal)
                {
                    pitem = Get(Size() - 1);
                    nVectorList -= 1;
                    LeaveCriticalSection(&g_csLists);
                    return TRUE;
                }
            }
            
            LeaveCriticalSection(&g_csLists);
        }

        return FALSE;
    }

};
CPalVector *g_palList;

//
// A single item in the list of DCs
//

struct DCITEM
{
    HDC hDc;
    HWND hWnd;
    HPALETTE hPal;
};

//
// Vector class that stores all the known DCs acquired by GetDC
//

class CDcVector : public VectorT<DCITEM>
{
public:
    // Find an hWnd/hDC
    DCITEM *Find(HWND hWnd, HDC hDc)
    {
        for (int i=0; i<Size(); ++i)
        {
            DCITEM &ditem = Get(i);
            if ((ditem.hDc == hDc) &&
                (ditem.hWnd == hWnd))
            {
                return &ditem;
            }
        }

        DPFN( eDbgLevelWarning, "Find: Could not find HDC %08lx", hDc);
        
        return NULL;
    }

    // Add an hWnd/hDC
    void Add(HWND hWnd, HDC hDc)
    {
        EnterCriticalSection(&g_csLists);

        DCITEM ditem;
        ditem.hPal = 0;
        ditem.hWnd = hWnd;
        ditem.hDc = hDc;
        Append(ditem);

        LeaveCriticalSection(&g_csLists);
    }
        
    
    // Remove an hWnd/hDC
    BOOL Remove(HWND hWnd, HDC hDc)
    {
        if (hDc)
        {
            EnterCriticalSection(&g_csLists);

            for (int i=0; i<Size(); ++i)
            {
                DCITEM &ditem = Get(i);
                if ((ditem.hDc == hDc) && (ditem.hWnd == hWnd))
                {
                    ditem = Get(Size() - 1);
                    nVectorList -= 1;
                    LeaveCriticalSection(&g_csLists);
                    return TRUE;
                }
            }

            LeaveCriticalSection(&g_csLists);
        }

        DPFN( eDbgLevelWarning, "Remove: Could not find hWnd=%08lx, hDC=%08lx", hWnd, hDc);

        return FALSE;
    }
};
CDcVector *g_dcList;

/*++

 Restore the last palette that was realized if we're in a palettized mode.
 
--*/

VOID 
FixPalette()
{
    LPLOGPALETTE plogpal;
    HWND hwnd;
    HDC hdc;
    HPALETTE hpal, hpalold;
    int icaps;
    
    hwnd = GetActiveWindow();
    hdc = ORIGINAL_API(GetDC)(hwnd);
    icaps = GetDeviceCaps(hdc, RASTERCAPS);

    // Check for palettized mode
    if (icaps & RC_PALETTE)
    {
        DPFN( eDbgLevelInfo, "Restoring palette");

        // We've set into a palettized mode, so fix the palette use
        ORIGINAL_API(SetSystemPaletteUse)(hdc, g_uLastUse);

        // Create a palette we can realize
        plogpal = (LPLOGPALETTE) malloc(sizeof(LOGPALETTE) + sizeof(g_lastPal));
        plogpal->palVersion = 0x0300;
        plogpal->palNumEntries = 256;
        MoveMemory(&plogpal->palPalEntry[0], &g_lastPal[0], sizeof(g_lastPal));
    
        // Realize the palette
        hpal = ORIGINAL_API(CreatePalette)(plogpal);
        hpalold = ORIGINAL_API(SelectPalette)(hdc, hpal, FALSE);
        ORIGINAL_API(RealizePalette)(hdc);
        ORIGINAL_API(SelectPalette)(hdc, hpalold, FALSE);
        ORIGINAL_API(DeleteObject)(hpal);
    }
    else
    {
        // Release the DC we used
        ORIGINAL_API(ReleaseDC)(hwnd, hdc);
    }
}

/*++

 Restore palette after change
 
--*/

LONG 
APIHOOK(ChangeDisplaySettingsA)(
    LPDEVMODEA lpDevMode,
    DWORD dwFlags
    )
{
    LONG lRet = ORIGINAL_API(ChangeDisplaySettingsA)(
        lpDevMode,
        dwFlags);

    if (lpDevMode)
    {
        DPFN( eDbgLevelInfo, 
            "%08lx=ChangeDisplaySettings(%d x %d x %d)", 
            lRet,
            lpDevMode->dmPelsWidth, 
            lpDevMode->dmPelsHeight, 
            lpDevMode->dmBitsPerPel);
    }
    else
    {
        DPFN( eDbgLevelInfo,
            "%08lx=ChangeDisplaySettings Restore",lRet);
    }

    if (lpDevMode) FixPalette();

    return lRet;
}

/*++

 Restore palette after change

--*/

LONG 
APIHOOK(ChangeDisplaySettingsW)(
    LPDEVMODEW lpDevMode,
    DWORD dwFlags
    )
{
    LONG lRet = ORIGINAL_API(ChangeDisplaySettingsW)(
        lpDevMode,
        dwFlags);

    if (lpDevMode)
    {
        DPFN( eDbgLevelInfo, 
            "%08lx=ChangeDisplaySettings(%d x %d x %d)", 
            lRet,
            lpDevMode->dmPelsWidth, 
            lpDevMode->dmPelsHeight, 
            lpDevMode->dmBitsPerPel);
    }
    else
    {
        DPFN( eDbgLevelInfo,
            "%08lx=ChangeDisplaySettings Restore",lRet);
    }

    if (lpDevMode) FixPalette();

    return lRet;
}

/*++

 Restore palette after change

--*/

LONG 
APIHOOK(ChangeDisplaySettingsExA)(
    LPCSTR lpszDeviceName,
    LPDEVMODEA lpDevMode,
    HWND hwnd,
    DWORD dwFlags,
    LPVOID lParam
    )
{
    LONG lRet = ORIGINAL_API(ChangeDisplaySettingsExA)(
        lpszDeviceName, 
        lpDevMode, 
        hwnd, 
        dwFlags, 
        lParam);

    if (lpDevMode)
    {
        DPFN( eDbgLevelInfo, 
            "%08lx=ChangeDisplaySettings(%d x %d x %d)", 
            lRet,
            lpDevMode->dmPelsWidth, 
            lpDevMode->dmPelsHeight, 
            lpDevMode->dmBitsPerPel);
    }
    else
    {
        DPFN( eDbgLevelInfo,
            "%08lx=ChangeDisplaySettings Restore",lRet);
    }

    if (lpDevMode) FixPalette();

    return lRet;
}

/*++

 Restore palette after change
 
--*/

LONG 
APIHOOK(ChangeDisplaySettingsExW)(
    LPCWSTR lpszDeviceName,
    LPDEVMODEW lpDevMode,
    HWND hwnd,
    DWORD dwFlags,
    LPVOID lParam
    )
{
    LONG lRet = ORIGINAL_API(ChangeDisplaySettingsExW)(
        lpszDeviceName, 
        lpDevMode, 
        hwnd, 
        dwFlags, 
        lParam);

    if (lpDevMode)
    {
        DPFN( eDbgLevelInfo, 
            "%08lx=ChangeDisplaySettings(%d x %d x %d)", 
            lRet,
            lpDevMode->dmPelsWidth, 
            lpDevMode->dmPelsHeight, 
            lpDevMode->dmBitsPerPel);
    }
    else
    {
        DPFN( eDbgLevelInfo,
            "%08lx=ChangeDisplaySettings Restore",lRet);
    }

    if (lpDevMode) FixPalette();

    return lRet;
}

/*++

 Track the system palette use

--*/

UINT 
APIHOOK(SetSystemPaletteUse)(
    HDC hdc,      
    UINT uUsage   
    )
{
    g_uLastUse = uUsage;

    DPFN( eDbgLevelInfo, "SetSystemPaletteUse=%08lx", uUsage);
        
    return ORIGINAL_API(SetSystemPaletteUse)(hdc, uUsage);
}

/*++

 Track created palette

--*/

HPALETTE 
APIHOOK(CreatePalette)(
    CONST LOGPALETTE *lplgpl   
    )
{
    HPALETTE hRet;

    hRet = ORIGINAL_API(CreatePalette)(lplgpl);

    if (hRet)
    {
        PALITEM pitem;
        
        pitem.hPal = hRet;

        MoveMemory(
            &pitem.palPalEntry[0], 
            &lplgpl->palPalEntry[0], 
            lplgpl->palNumEntries * sizeof(PALETTEENTRY));

        EnterCriticalSection(&g_csLists);
        g_palList->Append(pitem);
        LeaveCriticalSection(&g_csLists);
    }

    DPFN( eDbgLevelInfo, "%08lx=CreatePalette", hRet);

    return hRet;
}

/*++

 Update our private palette with the new entries.

--*/

UINT 
APIHOOK(SetPaletteEntries)(
    HPALETTE hpal,             
    UINT iStart,               
    UINT cEntries,             
    CONST PALETTEENTRY *lppe   
    )
{
    UINT uRet;

    uRet = ORIGINAL_API(SetPaletteEntries)(
        hpal,
        iStart,
        cEntries,
        lppe);

    if (uRet)
    {
        EnterCriticalSection(&g_csLists);

        PALITEM *pitem = g_palList->Find(hpal);

        if (pitem)
        {
            MoveMemory(
                &pitem->palPalEntry[iStart], 
                lppe, 
                cEntries * sizeof(PALETTEENTRY));
        }

        LeaveCriticalSection(&g_csLists);
    }

    DPFN( eDbgLevelInfo, 
        "%08lx=SetPaletteEntries(%08lx,%d,%d)", 
        uRet, 
        hpal, 
        iStart, 
        cEntries);

    return uRet;
}

/*++

 Update our private palette with the new entries.

--*/

BOOL 
APIHOOK(AnimatePalette)(
    HPALETTE hpal,            
    UINT iStartIndex,         
    UINT cEntries,            
    CONST PALETTEENTRY *ppe   
    )
{
    BOOL bRet;
    UINT ui;
    int i;

    bRet = ORIGINAL_API(AnimatePalette)(
        hpal,
        iStartIndex,
        cEntries,
        ppe);

    if (bRet)
    {
        EnterCriticalSection(&g_csLists);

        PALITEM *pitem = g_palList->Find(hpal);

        if (pitem)
        {
            //
            // Animate palette only replaces entries with the PC_RESERVED flag 
            //

            PALETTEENTRY *pe = &pitem->palPalEntry[iStartIndex];
            for (ui=0; ui<cEntries; ui++)
            {
                if (pe->peFlags & PC_RESERVED)
                {
                    pe->peRed = ppe->peRed;
                    pe->peGreen = ppe->peGreen;
                    pe->peBlue = ppe->peBlue;
                }

                pe++;
                ppe++;
            }

            //
            // Check if this palette will be realized. 
            // Note: check all DCs since the palette it may have been 
            // selected into more than 1.
            //

            for (i=0; i<g_dcList->Size(); i++)
            {
                DCITEM &ditem = g_dcList->Get(i);

                if ((hpal == ditem.hPal) &&
                    (GetActiveWindow() == ditem.hWnd))
                {
                    MoveMemory(
                        &g_lastPal[0], 
                        &pitem->palPalEntry[0], 
                        sizeof(g_lastPal));
                    
                    break;
                }
            }
        }
        
        LeaveCriticalSection(&g_csLists);
    }

    DPFN( eDbgLevelInfo, 
        "%08lx=AnimatePalette(%08lx,%d,%d)", 
        bRet,
        hpal,
        iStartIndex,
        cEntries);

    return bRet;
}

/*++

 Keep a list of DCs and their associated windows so we can look them up when 
 we need to find out which DC has which palette. 

--*/

HDC 
APIHOOK(CreateCompatibleDC)(
    HDC hdc   
    )
{
    HDC hRet;

    hRet = ORIGINAL_API(CreateCompatibleDC)(hdc);

    if (hRet)
    {
        g_dcList->Add(0, hRet);
    }

    DPFN( eDbgLevelInfo, 
        "%08lx=CreateCompatibleDC(%08lx)", 
        hRet,
        hdc);

    return hRet;
}
 
/*++

 Keep a list of DCs and their associated windows so we can look them up when 
 we need to find out which DC has which palette. We only care about CreateDC 
 if it's passed 'display'

--*/

HDC 
APIHOOK(CreateDCA)(
    LPCSTR lpszDriver,  
    LPCSTR lpszDevice,  
    LPCSTR lpszOutput,  
    CONST DEVMODEA *lpInitData 
    )
{
    HDC hRet;

    hRet = ORIGINAL_API(CreateDCA)(
        lpszDriver, 
        lpszDevice, 
        lpszOutput, 
        lpInitData);

    if (hRet && (!lpszDriver || (_stricmp(lpszDriver, "DISPLAY") == 0)))
    {
        g_dcList->Add(0, hRet);
    }

    DPFN( eDbgLevelInfo, 
        "%08lx=CreateDCA(%s,%s)", 
        hRet,
        lpszDriver,
        lpszDevice);

    return hRet;
}
 
/*++

 Keep a list of DCs and their associated windows so we can look them up when 
 we need to find out which DC has which palette. We only care about CreateDC 
 if it's passed 'display'

--*/

HDC 
APIHOOK(CreateDCW)(
    LPCWSTR lpszDriver,  
    LPCWSTR lpszDevice,  
    LPCWSTR lpszOutput,  
    CONST DEVMODEW *lpInitData 
    )
{
    HDC hRet;

    hRet = ORIGINAL_API(CreateDCW)(
        lpszDriver, 
        lpszDevice, 
        lpszOutput, 
        lpInitData);

    if (hRet && (!lpszDriver || (_wcsicmp(lpszDriver, L"DISPLAY") == 0)))
    {
        g_dcList->Add(0, hRet);
    }

    DPFN( eDbgLevelInfo, 
        "%08lx=CreateDCW(%S,%S)", 
        hRet,
        lpszDriver,
        lpszDevice);

    return hRet;
}

/*++

 Remove a DC created with CreateDC

--*/

BOOL
APIHOOK(DeleteDC)(
    HDC hdc
    )
{
    int bRet;

    bRet = ORIGINAL_API(DeleteDC)(hdc);

    if (bRet)
    {
        g_dcList->Remove(0, hdc);
    }

    DPFN( eDbgLevelInfo, "%08lx=DeleteDC(%08lx)", bRet, hdc);

    return bRet;
}

/*++

 Keep a list of DCs and their associated windows so we can look them up when 
 we need to find out which DC has which palette.

--*/

HDC 
APIHOOK(GetDC)(
    HWND hWnd   
    )
{
    HDC hRet;

    hRet = ORIGINAL_API(GetDC)(hWnd);

    if (hRet)
    {
        g_dcList->Add(hWnd, hRet);
    }

    DPFN( eDbgLevelInfo, "%08lx=GetDC(%08lx)", hRet, hWnd);

    return hRet;
}

/*++

 Keep a list of DCs and their associated windows so we can look them up when 
 we need to find out which DC has which palette.

--*/

HDC 
APIHOOK(GetWindowDC)(
    HWND hWnd   
    )
{
    HDC hRet;

    hRet = ORIGINAL_API(GetWindowDC)(hWnd);

    if (hRet)
    {
        g_dcList->Add(hWnd, hRet);
    }

    DPFN( eDbgLevelInfo, "%08lx=GetWindowDC(%08lx)", hRet, hWnd);

    return hRet;
}

/*++

 Release the DC and remove it from our list

--*/

int 
APIHOOK(ReleaseDC)(
    HWND hWnd,  
    HDC hDC     
    )
{
    int iRet;

    iRet = ORIGINAL_API(ReleaseDC)(hWnd, hDC);

    if (iRet)
    {
        g_dcList->Remove(hWnd, hDC);
    }

    DPFN( eDbgLevelInfo, "%08lx=ReleaseDC(%08lx, %08lx)", iRet, hWnd, hDC);

    return iRet;
}
  
/*++

 Keep track of which DC the palette lives in.

--*/

HPALETTE 
APIHOOK(SelectPalette)(
    HDC hdc,                
    HPALETTE hpal,          
    BOOL bForceBackground   
    )
{
    HPALETTE hRet;

    hRet = ORIGINAL_API(SelectPalette)(
        hdc,
        hpal,
        bForceBackground);

    EnterCriticalSection(&g_csLists);

    //
    // Select this palette into all copies of this DC
    //

    for (int i=0; i<g_dcList->Size(); i++)
    {
        DCITEM & ditem = g_dcList->Get(i);

        if (hdc == ditem.hDc)
        {
            ditem.hPal = hpal;
        }
    }

    LeaveCriticalSection(&g_csLists);

    DPFN( eDbgLevelInfo, "%08lx=SelectPalette(%08lx, %08lx)", hRet, hdc, hpal);

    return hRet;
}

/*++

 Stub this for now because of known problems listed at top.

--*/

UINT 
APIHOOK(GetSystemPaletteEntries)(
    HDC hdc,              
    UINT iStartIndex,     
    UINT nEntries,        
    LPPALETTEENTRY lppe   
    )
{
    UINT uRet;

    uRet = ORIGINAL_API(GetSystemPaletteEntries)(
        hdc,
        iStartIndex,
        nEntries,
        lppe);

    DPFN( eDbgLevelInfo, "%08lx=GetSystemPaletteEntries(%08lx, %08lx, %08lx)", uRet, hdc, iStartIndex, nEntries);

    return uRet;
}

/*++

 Fill in the last known palette if anything was realized

--*/

UINT 
APIHOOK(RealizePalette)(
    HDC hdc   
    )
{
    UINT uRet;

    uRet = ORIGINAL_API(RealizePalette)(hdc);

    if (uRet)
    {
        EnterCriticalSection(&g_csLists);

        //
        // Check for all windows of all DCs
        //

        HWND hwnd = GetActiveWindow();

        for (int i=0; i<g_dcList->Size(); i++)
        {
            DCITEM &ditem = g_dcList->Get(i);

            if (hwnd == ditem.hWnd)
            {
                PALITEM *pitem = g_palList->Find(ditem.hPal);

                if (pitem)
                {
                    MoveMemory(
                        &g_lastPal[0],
                        &pitem->palPalEntry[0],
                        sizeof(g_lastPal));

                    break;
                }
            }
        }

        LeaveCriticalSection(&g_csLists);
    }

    DPFN( eDbgLevelInfo, "%08lx=RealizePalette(%08lx)", uRet, hdc);

    return uRet;
}

/*++

 Delete palette objects from the list.

--*/

UINT 
APIHOOK(DeleteObject)(
    HGDIOBJ hObject
    )
{
    BOOL bRet;

    bRet = ORIGINAL_API(DeleteObject)(hObject);

    if (bRet)
    {
        g_palList->Remove((HPALETTE)hObject);
    }

    return bRet;
}
 
/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        g_palList = new CPalVector;
        g_dcList = new CDcVector;

        InitializeCriticalSection(&g_csLists);

        MoveMemory(&g_lastPal, &g_palDefault, sizeof(g_lastPal));
    }
    else if (fdwReason == DLL_PROCESS_DETACH) 
    {
        // Can't free since we might still be called
        
        // delete g_palList;
        // delete g_dcList;
        // DeleteCriticalSection(&g_csLists);
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsA);
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsW);
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsExA);
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsExW);
    APIHOOK_ENTRY(USER32.DLL, GetDC);
    APIHOOK_ENTRY(USER32.DLL, GetWindowDC);
    APIHOOK_ENTRY(USER32.DLL, ReleaseDC);

    APIHOOK_ENTRY(GDI32.DLL, CreateCompatibleDC);
    APIHOOK_ENTRY(GDI32.DLL, CreateDCA);
    APIHOOK_ENTRY(GDI32.DLL, CreateDCW);
    APIHOOK_ENTRY(GDI32.DLL, DeleteDC);
    APIHOOK_ENTRY(GDI32.DLL, SetSystemPaletteUse);
    APIHOOK_ENTRY(GDI32.DLL, CreatePalette);
    APIHOOK_ENTRY(GDI32.DLL, SetPaletteEntries);
    APIHOOK_ENTRY(GDI32.DLL, AnimatePalette);
    APIHOOK_ENTRY(GDI32.DLL, SelectPalette);
    APIHOOK_ENTRY(GDI32.DLL, GetSystemPaletteEntries);
    APIHOOK_ENTRY(GDI32.DLL, RealizePalette);
    APIHOOK_ENTRY(GDI32.DLL, DeleteObject);

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\populatedefaulthkcusettings.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    PopulateDefaultHKCUSettings.cpp
    
 Abstract:

    Populate HKCU with default values if they do not exist. Some apps installs HKCU values
    for only the user that ran setup on that app. In this case, if another users tries to use the
    application they will be unable to due to missing HKCU regkeys.
    
    To shim around this, we check for the existance of a regkey and if it does not exist, we then read
    a pre-defined .reg file our of our resource section and exec regedit on it to add the necessary
    registry keys. For example:

    COMMAND_LINE("Software\Lotus\SmartCenter\97.0!SmartCenter97")

    would mean that if the regkey 'HKCU\Software\Lotus\SmartCenter\97.0' does NOT exist, then we should
    read the named resource 'SmartCenter97' out of our dll and write it to a temp .reg file and then
    execute 'regedit.exe /s tempfile.reg' to properly populate the registry with the defaul HKCU values.

 Notes:

    This is an general shim. (Actually, its a Admiral shim, since its in the navy, hehe).

 History:

    01/31/2001 reiner Created
    03/30/2001 amarp  Added %__AppSystemDir_% and %__AppLocalOrCDDir<Param1><Param2><Param3>_%
                      (documented below)

--*/

#include "precomp.h"
#include "stdio.h"

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"


IMPLEMENT_SHIM_BEGIN(PopulateDefaultHKCUSettings)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegOpenKeyA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyW)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExW)
APIHOOK_ENUM_END


BOOL ParseCommandLine(const char* pszCmdLine, char* pszRegKeyName, DWORD cchRegKeyName, char* pszResourceName, DWORD cchResourceName)
{
    BOOL bRet = FALSE;
    char* psz;

    psz = strstr(pszCmdLine, "!");
    if (psz)
    {
        DWORD cchKey; 
        DWORD cchResource;
        
        cchKey = (DWORD)(((BYTE*)psz - (BYTE*)pszCmdLine) / sizeof(char));

        // move past the '!' so psz now points to the resource name
        psz++;

        cchResource = lstrlenA(psz);

        if ((cchRegKeyName >= (cchKey + 1)) && 
            (cchResourceName >= (cchResource + 1)))
        {
            // we have enough space in the output buffers to fit the strings
            lstrcpynA(pszRegKeyName, pszCmdLine, cchKey + 1);
            lstrcpynA(pszResourceName, psz, cchResourceName);

            bRet = TRUE;
        }
    }

    return bRet;
}


//
// This actually creates the tempfile (0 bytes) and returns
// the filename.
//
BOOL CreateTempName(char* szFileName)
{
    char szTempPath[MAX_PATH];
    BOOL bRet = FALSE;

    if (GetTempPathA(sizeof(szTempPath)/sizeof(szTempPath[0]), szTempPath))
    {
        if (GetTempFileNameA(szTempPath,
                             "AcGenral",
                             0,
                             szFileName))
        {
            bRet = TRUE;
        }
    }

    return bRet;
}


//
// Exec's "regedit /s" with the given file
//
BOOL SpawnRegedit(char* szFile)
{
    STARTUPINFOA si = {0};
    PROCESS_INFORMATION pi = {0};
    char szApp[MAX_PATH * 2];
    BOOL bRet = FALSE;

    sprintf(szApp, "regedit.exe /s %s", szFile);

    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;
    
    bRet = CreateProcessA(NULL,
                          szApp,
                          NULL,
                          NULL,
                          FALSE,
                          0,
                          NULL,
                          NULL,
                          &si,
                          &pi);

    if (bRet)
    {
        WaitForSingleObject(pi.hProcess, INFINITE);

        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }

    return bRet;
}


//
// this function is used to change a path from:
//
//  "C:\Lotus\Smartsuite"  ->  "C:\\Lotus\\Smartsuite"
//
// (.reg files use escaped backslashes)
//
BOOL DoubleUpBackslashes(WCHAR* pwszPath, DWORD cchPath)
{
    BOOL bRet = FALSE;
    WCHAR wszTemp[MAX_PATH * 2];
    WCHAR* pwsz = pwszPath;
    WCHAR* pwszTemp = wszTemp;
    
    while (*pwszTemp = *pwsz)
    {
        if (*pwsz == L'\\')
        {
            // if we found a '\' then add another one
            pwszTemp++;
            *pwszTemp = L'\\';
        }

        pwsz++;
        pwszTemp++;
    }

    if (cchPath >= (DWORD)(lstrlenW(wszTemp) + 1))
    {
        lstrcpynW(pwszPath, wszTemp, cchPath);
        bRet = TRUE;
    }

    return bRet;
}


//
// This fuction calculates the application dir (pszAppDir) and the application
// parent dir (pszAppParentDir) based on the return from GetModuleFileName
//
BOOL InitAppDir(WCHAR* pwszSystemDir, DWORD cchSystemDir,
                WCHAR* pwszAppDir, DWORD cchAppDir, 
                WCHAR* pwszAppParentDir, DWORD cchAppParentDir
                )
{
    BOOL bRet = FALSE;
    WCHAR wszExePath[MAX_PATH];

    bRet = GetSystemDirectoryW(pwszSystemDir,cchSystemDir);
    if( !bRet )
        return FALSE;

    bRet = DoubleUpBackslashes(pwszSystemDir,cchSystemDir);
    if( !bRet )
        return FALSE;

    if (GetModuleFileNameW(NULL, wszExePath, sizeof(wszExePath)/sizeof(wszExePath[0])))
    {
        // find the last '\' in the path
        WCHAR* pwsz = wcsrchr(wszExePath, L'\\');
        if (pwsz)
        {
            *pwsz = L'\0';

            if (cchAppDir >= (DWORD)(lstrlenW(wszExePath) + 1))
            {
                lstrcpynW(pwszAppDir, wszExePath, cchAppDir);
                bRet = DoubleUpBackslashes(pwszAppDir, cchAppDir);
                
                if (bRet)
                {
                    pwsz = wcsrchr(wszExePath, L'\\');
                    if (pwsz)
                    {
                        *pwsz = L'\0';

                        if (cchAppParentDir >= (DWORD)(lstrlenW(wszExePath) + 1))
                        {
                            lstrcpynW(pwszAppParentDir, wszExePath, cchAppParentDir);
                            bRet = DoubleUpBackslashes(pwszAppParentDir, cchAppParentDir);
                        }
                    }
                    else
                    {
                        // if there is not another '\' then just use the same path as pwszAppDir
                        lstrcpynW(pwszAppParentDir, wszExePath, cchAppParentDir);
                        bRet = TRUE;
                    }
                }
            }
        }
    }

    return bRet;
}


//
// This function is called to actually write stuff out to the file
//
BOOL WriteToFile(HANDLE hFile, void* pv, DWORD cb)
{
    DWORD dwBytesWritten;
    BOOL bWriteSucceeded = FALSE;

    if (WriteFile(hFile, pv, cb, &dwBytesWritten, NULL) &&
        (dwBytesWritten == cb))
    {
        bWriteSucceeded = TRUE;
    }

    return bWriteSucceeded;
}

BOOL PathIsNonEmptyDirectory(WCHAR* pwszPath)
{
    WCHAR wszSearchFilter[MAX_PATH];
    DWORD dwAttr = GetFileAttributesW(pwszPath);
    BOOL bRet = FALSE;
    if( (-1 != dwAttr) && (FILE_ATTRIBUTE_DIRECTORY & dwAttr ) )
    {
        if( _snwprintf(wszSearchFilter,MAX_PATH,L"%s\\*.*",pwszPath) < 0 )
            return bRet;

        WIN32_FIND_DATAW FindData;
        HANDLE hSearch = FindFirstFileW(wszSearchFilter,&FindData);
        if( INVALID_HANDLE_VALUE == hSearch )
            return bRet;
        do
        {
            if(L'.' != FindData.cFileName[0])
            {
                bRet = TRUE;
                break;
            }
        }
        while( FindNextFileW(hSearch,&FindData) );
        FindClose(hSearch);
    }
    return bRet;
}

BOOL FindCDDriveContainingDirectory(WCHAR* pwchCDDriveLetter, WCHAR* pwszCheckPath)
{
    // Find out cd drive (looks for app cd in drive, else just chooses first cd drive found)
    // NOTE: This function only actually does anything the first time its called (to avoid
    //       thrashing CD drive, or bringing up excessive dialogs if no CD in drive).
    //       The assumption is that once a good CD drive is found, any other times you need
    //       a CD drive in this shim, it will be the same one, so this function will just return
    //       that drive.

    static BOOL  s_bFoundDrive = FALSE;
    static BOOL  s_bTriedOnce  = FALSE;
    static WCHAR s_wchCDDriveLetter = L'\0';

    if( s_bTriedOnce )
    {
        *pwchCDDriveLetter = s_wchCDDriveLetter;
        return s_bFoundDrive;
    }
    s_bTriedOnce = TRUE;
    
    DWORD dwLogicalDrives = GetLogicalDrives();
    WCHAR wchCurrDrive = L'a';
    WCHAR wszPath[MAX_PATH];

    while( dwLogicalDrives )
    {
        if( dwLogicalDrives & 1 )
        {
            if( _snwprintf(wszPath,MAX_PATH,L"%c:",wchCurrDrive) < 0 )
                return FALSE;

            if( DRIVE_CDROM == GetDriveTypeW( wszPath ) )
            {
                if( L'\0' == s_wchCDDriveLetter )
                {
                    s_bFoundDrive = TRUE;
                    s_wchCDDriveLetter = wchCurrDrive;
                }

                wcscat( wszPath, pwszCheckPath );
                
                DWORD dwAttr = GetFileAttributesW(wszPath);
                if( (-1 != dwAttr) && (FILE_ATTRIBUTE_DIRECTORY & dwAttr ) )
                {
                    // this drive seems to have the app cd in it based on 
                    // a very primitive heuristic... so lets use this as our cd drive.
                    s_wchCDDriveLetter = wchCurrDrive;
                    *pwchCDDriveLetter = s_wchCDDriveLetter;
                    return TRUE;
                }
            }
        }
        dwLogicalDrives >>= 1;
        wchCurrDrive++;
    }
    *pwchCDDriveLetter = s_wchCDDriveLetter; //may be L'\0' if we didn't find anything.
    return s_bFoundDrive;
}

BOOL GrabNParameters( UINT uiNumParameters,
                      WCHAR* pwszStart, WCHAR** ppwszEnd,
                      WCHAR  pwszParam[][MAX_PATH] )
{
    WCHAR* pwszEnd;
    UINT uiLength;
    *ppwszEnd = NULL;

    for( UINT i = 0; i < uiNumParameters; i++ )
    {
        if( L'<' != *(pwszStart++) )
            return FALSE;

        pwszEnd = pwszStart;

        while( (L'\0' != *pwszEnd) )
        {
            if( L'>' != *pwszEnd )
            {
                pwszEnd++;
                continue;
            }
            uiLength = (pwszEnd - pwszStart);
            if( uiLength >= MAX_PATH )
                return FALSE;

            wcsncpy(pwszParam[i],pwszStart,uiLength);
            pwszParam[i][uiLength] = L'\0';
            break;
        }

        if( L'>' != *pwszEnd )
            return FALSE;

        pwszStart = pwszEnd + 1; 
    }
    *ppwszEnd = pwszStart;
    return TRUE;
}

//
// As we write out the resource to a temp file, we need to scan through looking
// for the env variables:
//
//      %__AppDir_%
//      %__AppParentDir_%
//
// and replace them with the proper path (the dir of the current .exe or its parent,
// respectively). 
//
// Additional vars (added by amarp):
//
//     %__AppSystemDir_% 
//          - Maps to GetSystemDir()  (i.e. c:\windows\system32)
// 
//     %__AppLocalOrCDDir<Param1><Param2><Param3>_%
// 
//          - The three parameters are just paths (should start with a \\).  
//            Any/all may be empty.  They are defined as follows:
//            Param1 = a relative path under the apps install directory (i.e. under AppDir)
//            Param2 = a relative path under the apps CD drive (where CD Drive = "drive:")
//            Param3 = a relative path/filename under Param1 or Param2 (in most cases this will be empty)
// 
//            When this var is encountered, it is replaced as follows:
//             a)   if AppDirParam1Param3 is a *nonempty* directory, output AppDirParam1Param3
//             b)   else, if there is a CDDrive for which directory CDDrive:Param2 exists, output CDDrive:Param2Param3
//             c)   else, output CDDrive:Param2Param3 for the first enumerated CD drive.
//
//            Example: %__AppLocalOrCDDir<\\content\\clipart><\\clipart><\\index.dat>_% maps does the following:
//                (lets assume AppDir is c:\app, and there are cd drives d: and e:, neither of which have the app's CD inserted)
//             a)   Is c:\app\content a directory? Yes! -> Is it nonempty (at least one file or directory that doesn't start with '.')?
//                                                 yes! -> output c:\app\content\index.dat
//             <end>
//
//            Or, this example could pan out to the following scenario:
//             a) Is c:\app\content a directory? Yes! -> Is it nonempty? No!
//             b) Is d:\clipart a directory? No! Is e:\clipart a directory? No!
//             c) The first cd drive we found was d: -> output d:\clipart\index.dat
//             <end>
//
//            Anoter example: %__AppLocalOrCDDir<__UNUSED__><\\clipart><>_% maps does the following:
//                (lets assume AppDir is c:\app and app CD is in drive d:)
//             a)   Is c:\app__UNUSED__ a directory?  PROBABLY NOT! (thus we can essentially ignore this parameter by doing this)
//             b)   Is d:\clipart a directory? Yes! -->  output d:\clipart
//             <end>
//
//
//
// NOTE: cbResourceSize holds the size of the original resource (which is the 2 WCHAR's
//       smaller than pvData). We use this to set eof after we are done writing everything
//       out.
//
BOOL WriteResourceFile(HANDLE hFile, void* pvData, DWORD cbResourceSize)
{
    DWORD cbFileSize = cbResourceSize;
    WCHAR* pwszEndOfLastWrite = (WCHAR*)pvData;
    WCHAR wszAppDir[MAX_PATH];
    WCHAR wszAppParentDir[MAX_PATH];
    WCHAR wszSystemDir[MAX_PATH];
    BOOL bRet = FALSE;
    bRet = InitAppDir(wszSystemDir, sizeof(wszSystemDir)/sizeof(wszSystemDir[0]),
                      wszAppDir, sizeof(wszAppDir)/sizeof(wszAppDir[0]), 
                      wszAppParentDir, sizeof(wszAppParentDir)/sizeof(wszAppParentDir[0]));
    if (!bRet)
        return bRet;

    do
    {
        WCHAR* pwsz = wcsstr(pwszEndOfLastWrite, L"%__App");
        if (pwsz)
        {
            // first, write out anything before the tag we found
            bRet = WriteToFile(hFile, pwszEndOfLastWrite, (DWORD)((BYTE*)pwsz - (BYTE*)pwszEndOfLastWrite));

            if(!bRet)
                break;

            pwszEndOfLastWrite = pwsz;

            // found a tag that we need to replace. See which one it is
            if (wcsncmp(pwsz, L"%__AppDir_%", lstrlenW(L"%__AppDir_%")) == 0)
            {
                bRet = WriteToFile(hFile, wszAppDir, lstrlenW(wszAppDir) * sizeof(WCHAR));
                pwszEndOfLastWrite += lstrlenW(L"%__AppDir_%");
            }
            else if (wcsncmp(pwsz, L"%__AppParentDir_%", lstrlenW(L"%__AppParentDir_%")) == 0)
            {
                bRet = WriteToFile(hFile, wszAppParentDir, lstrlenW(wszAppParentDir) * sizeof(WCHAR));
                pwszEndOfLastWrite += lstrlenW(L"%__AppParentDir_%");
            }
            else if (wcsncmp(pwsz, L"%__AppSystemDir_%", lstrlenW(L"%__AppSystemDir_%")) == 0)
            {
                bRet = WriteToFile(hFile, wszSystemDir, lstrlenW(wszSystemDir) * sizeof(WCHAR));
                pwszEndOfLastWrite += lstrlenW(L"%__AppSystemDir_%");
            }
            else if (wcsncmp(pwsz, L"%__AppLocalOrCDDir", lstrlenW(L"%__AppLocalOrCDDir")) == 0)
            {
                WCHAR   wszParams[3][MAX_PATH];
                WCHAR*  pwszStart = pwsz + lstrlenW(L"%__AppLocalOrCDDir");
                WCHAR*  pwszEnd;
                WCHAR   wszDesiredPath[MAX_PATH];
                WCHAR   wchDrive;

                if (!GrabNParameters(3,pwszStart,&pwszEnd,wszParams))
                {
                    pwszEndOfLastWrite += lstrlenW(L"%__AppLocalOrCDDir");
                    continue;
                }

                if (0 != wcsncmp(pwszEnd, L"_%", lstrlenW(L"_%")))
                {
                    pwszEndOfLastWrite = pwszEnd;
                    continue;
                }

                if ( _snwprintf( wszDesiredPath, MAX_PATH,L"%s%s", wszAppDir, wszParams[0] ) > 0 )
                {
                    if( PathIsNonEmptyDirectory(wszDesiredPath) )
                    {
                        if( _snwprintf( wszDesiredPath, MAX_PATH,L"%s%s%s", wszAppDir, wszParams[0], wszParams[2] ) > 0 )
                            bRet = WriteToFile(hFile, wszDesiredPath, lstrlenW(wszDesiredPath) * sizeof(WCHAR));
                    }
                    else
                    {
                        WCHAR wchDrive;
                        UINT uiOffset;
                        if( L'\\' == wszParams[1][0] && L'\\' == wszParams[1][1] )
                            uiOffset = sizeof(WCHAR);
                        else
                            uiOffset = 0;
                        if( FindCDDriveContainingDirectory(&wchDrive,wszParams[1]+uiOffset) &&
                            (_snwprintf(wszDesiredPath,MAX_PATH,L"%c:%s%s",wchDrive,wszParams[1],wszParams[2]) > 0) )
                                bRet = WriteToFile(hFile, wszDesiredPath, lstrlenW(wszDesiredPath) * sizeof(WCHAR));
                    }
                }
                                                                
                pwszEndOfLastWrite= pwszEnd + lstrlenW(L"_%");
            }
            else
            {
                // Strange... we found a string that started w/ "%__App" that wasen't one we are
                // intersted in. Just skip over it and keep going.
                bRet = WriteToFile(hFile, pwsz, lstrlenW(L"%__App") * sizeof(WCHAR));
                pwszEndOfLastWrite += lstrlenW(L"%__App");
            }
        }
        else
        {
            // didn't find anymore strings to replace

            // using lstrlenW should give us the size of the string w/out the null, which is what we
            // want since we added on the space for the null when we created the buffer
            bRet = WriteToFile(hFile, pwszEndOfLastWrite, lstrlenW(pwszEndOfLastWrite) * sizeof(WCHAR));

            // break out of the loop, as we are finished
            break;
        }

    } while (bRet);
    
    return bRet;
}


//
// The job of this function is to read the specified string resource our
// of our own DLL and write it to a temp file, and then to spawn regedit on
// the file 
//
BOOL ExecuteRegFileFromResource(char* pszResourceName)
{
    // lame, but we aren't passed our hinst in our pseudo dllmain,
    // so we have to hardcode the dllname
    HMODULE hmod = GetModuleHandleA("AcGenral");
    BOOL bRet = FALSE;

    if (hmod)
    {
        HRSRC hrsrc = FindResourceA(hmod, pszResourceName, MAKEINTRESOURCEA(10)/* RT_RCDATA */);

        if (hrsrc)
        {
            DWORD dwSize;
            void* pvData;

            dwSize = SizeofResource(hmod, hrsrc);

            // allocate enough room for the entire resource including puting a null terminator on
            // the end since we will be treating it like huge LPWSTR.
            pvData = LocalAlloc(LPTR, dwSize + sizeof(WCHAR));

            if (pvData)
            {
                HGLOBAL hGlobal = LoadResource(hmod, hrsrc);

                if (hGlobal)
                {
                    void* pv = LockResource(hGlobal);

                    if (pv)
                    {
                        char szTempFile[MAX_PATH];

                        // copy the resource into our buffer
                        memcpy(pvData, pv, dwSize);

                        if (CreateTempName(szTempFile))
                        {
                            // we use OPEN_EXISTING since the tempfile should always exist as it
                            // was created in the call to CreateTempName()
                            HANDLE hFile = CreateFileA(szTempFile,
                                                       GENERIC_WRITE,
                                                       FILE_SHARE_READ,
                                                       NULL,
                                                       OPEN_EXISTING,
                                                       FILE_ATTRIBUTE_TEMPORARY,
                                                       NULL);

                            if (hFile != INVALID_HANDLE_VALUE)
                            {
                                DWORD dwBytesWritten;
                                BOOL bWriteSucceeded = WriteResourceFile(hFile, pvData, dwSize);

                                CloseHandle(hFile);

                                if (bWriteSucceeded)
                                {
                                    bRet = SpawnRegedit(szTempFile);
                                }
                            }

                            DeleteFileA(szTempFile);
                        }
                    }
                }
            }
        }
    }

    return bRet;
}


BOOL PopulateHKCUValues()
{
    static BOOL s_fAlreadyPopulated = FALSE;

    if (!s_fAlreadyPopulated)
    {
        char szRegKeyName[MAX_PATH];
        char szResourceName[64];

        UINT uiOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS); // stop dialogs from coming up when we enumerate CD drives that are empty.

        // set this to true so we only do this check once 
        s_fAlreadyPopulated = TRUE;

        if (ParseCommandLine(COMMAND_LINE,
                             szRegKeyName,
                             sizeof(szRegKeyName)/sizeof(szRegKeyName[0]),
                             szResourceName,
                             sizeof(szResourceName)/sizeof(szResourceName[0])))
        {
            DWORD dwError;
            HKEY hkCU;

            // check to see if the HKCU registry key is already present
            dwError = RegOpenKeyExA(HKEY_CURRENT_USER,
                                    szRegKeyName,
                                    0,
                                    KEY_QUERY_VALUE,
                                    &hkCU);

            if (dwError == ERROR_SUCCESS)
            {
                // yep, its already there. Nothing to do.
                RegCloseKey(hkCU);
            }
            else if (dwError == ERROR_FILE_NOT_FOUND)
            {
                // the regkey is missing, we will assume that this is the first time
                // the user has run the app and populate HKCU with the proper stuff
                ExecuteRegFileFromResource(szResourceName);
            }
        }

        SetErrorMode(uiOldErrorMode);
    }


    return s_fAlreadyPopulated;
}


//
// Its lame that we have to hook RegOpenKey/Ex but since we need to call
// the advapi32 registry apis we can't do this as a straight NOTIFY_FUNCTION
// because we need to wait for advapi to have its DLL_PROCESS_ATTACH called.
//
LONG
APIHOOK(RegOpenKeyA)(HKEY hkey, LPCSTR pszSubKey, HKEY* phkResult)
{
    PopulateHKCUValues();
    return ORIGINAL_API(RegOpenKeyA)(hkey, pszSubKey, phkResult);
}


LONG
APIHOOK(RegOpenKeyW)(HKEY hkey, LPCWSTR pszSubKey, HKEY* phkResult)
{
    PopulateHKCUValues();
    return ORIGINAL_API(RegOpenKeyW)(hkey, pszSubKey, phkResult);
}

LONG
APIHOOK(RegOpenKeyExA)(HKEY hkey, LPCSTR pszSubKey, DWORD ulOptions, REGSAM samDesired, HKEY* phkResult)
{
    PopulateHKCUValues();
    return ORIGINAL_API(RegOpenKeyExA)(hkey, pszSubKey, ulOptions, samDesired, phkResult);
}

LONG
APIHOOK(RegOpenKeyExW)(HKEY hkey, LPCWSTR pszSubKey, DWORD ulOptions, REGSAM samDesired, HKEY* phkResult)
{
    PopulateHKCUValues();
    return ORIGINAL_API(RegOpenKeyExW)(hkey, pszSubKey, ulOptions, samDesired, phkResult);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\recopyexefromcd.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RecopyExeFromCD.cpp

 Abstract:

    This shim waits for CloseHandle to be called on the appropriate .exe file.
    Once this call has been made, CopyFile is called to recopy the executable 
    due to truncation of the file during install.

 History:

    12/08/1999 a-jamd   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RecopyExeFromCD)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA) 
    APIHOOK_ENUM_ENTRY(CloseHandle) 
APIHOOK_ENUM_END

// The following variables are used to keep track of the file handle,
// the source path and the destination path.
HANDLE          g_hInterestingHandle    = NULL; 
CString *       g_wszSourcePath         = NULL;
CString *       g_wszDestinationPath    = NULL;
BOOL            g_bInCopyFile           = FALSE;

// The following array specifies what the valid names of executables to 
// be recopied are. Add to these lists when new apps requiring this shim are 
// found.
WCHAR *g_rgszExes[] = {
    L"eaw.exe",
    L"GK3.EXE",
};

#define N_RECOPY_EXE    (sizeof(g_rgszExes) / sizeof(g_rgszExes[0]))

/*++

 This stub function breaks into CreateFileA and checks to see if the file in 
 use is a known .exe file.  If it is, APIHook_CreateFileA determines if  
 lpFileName is the source path or the destination and saves it.  When the 
 file is the destination, the handle returned by CreateFile is also saved 
 for my check in CloseHandle.

--*/

HANDLE 
APIHOOK(CreateFileA)(    
    LPSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,  
    DWORD dwCreationDisposition,                          
    DWORD dwFlagsAndAttributes, 
    HANDLE hTemplateFile 
    )
{
    HANDLE hRet = ORIGINAL_API(CreateFileA)(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,  
        dwCreationDisposition,                          
        dwFlagsAndAttributes, 
        hTemplateFile);

    if (hRet != INVALID_HANDLE_VALUE)
    {
        CString csFilePartOnly;
        CString csFileName(lpFileName);
        csFileName.GetFullPathNameW();
        csFileName.GetLastPathComponent(csFilePartOnly);
    
        // Should be d:\ or somesuch
        CString csDir;
        csFileName.Mid(0, 3, csDir);
        UINT uiDriveType = GetDriveTypeW(csDir);

        for (int i = 0; i < N_RECOPY_EXE; ++i)
        {
            const WCHAR * lpszRecopy = g_rgszExes[i];
    
            // Find out if one of the known .exe files is the file in use
            
            if (csFilePartOnly.CompareNoCase(lpszRecopy) == 0)
            {
                if (uiDriveType != DRIVE_CDROM)
                {
                    // Known .exe file was found in the filename, and it wasn't on the CDRom.
                    // There is also a valid handle.
                    g_hInterestingHandle = hRet;
                    g_wszDestinationPath = new CString(csFileName);
                    
                    break;
                }
                else
                {
                    // Known .exe was found in the filename, and the drive is a CDRom.
                    // This is the path to the source and must be stored for later.
                    g_wszSourcePath = new CString(csFileName);

                    break;
                }
            }
        }
    }
    
    return hRet;
}


/*++

 This stub function breaks into CloseHandle and checks to see if the handle in 
 use is the handle to a known .exe.  If it is, APIHook_CloseHandle calls 
 CopyFile and copies the known .exe from the CDRom to the destination.

--*/

BOOL 
APIHOOK(CloseHandle)(HANDLE hObject)
{
    BOOL    bRet;

    bRet = ORIGINAL_API(CloseHandle)(hObject);
    
    // Find out if g_hInterestingHandle is being closed
    if ((hObject == g_hInterestingHandle) &&
        g_wszSourcePath &&
        g_wszDestinationPath &&
        (g_bInCopyFile == FALSE) )
    {
        // CopyFileA calls CloseHandle, so we must maintain the recursive state 
        // to fix a recursion problem
        g_bInCopyFile = TRUE;

        // Correct Handle
        // Call CopyFile and recopy the known .exe file from the CDRom to the 
        // destination
        CopyFileW( g_wszSourcePath->Get(), g_wszDestinationPath->Get(), FALSE );

        LOGN( eDbgLevelWarning, "[CloseHandle] Copied %S from CD to %S", g_wszSourcePath->Get(), g_wszDestinationPath->Get());

        // Since copying from the CDRom, and attributes are carried over, the 
        // file attributes must be set
        SetFileAttributesW( g_wszDestinationPath->Get(), FILE_ATTRIBUTE_NORMAL );

        g_bInCopyFile = FALSE;
        g_hInterestingHandle = NULL;

        return bRet;
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CloseHandle)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\redirectdbcstemppath.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

   RedirectDBCSTempPath.cpp

 Abstract:

   This shim redirect DBCS temp path to SBCS temp path.
   With DBCS user name log on, temp path contains DBCS path.
   Some App cannot handle DBCS temp path and fails to launch.

   Originally created for Japanese App BenriKaikeiV2 to avoid setup failure.
   App setup fails when DBCS user logon. GetTempPathA returns DBCS include path.
   SETUP1.EXE convert path to Unicode and call MSVBVM60!rtcLeftCharBstr to set str length.
   This API calculate Unicode len = ANSI len + ANSI len and set wrong result.
   Length is wrong and MSVBVM60!_vbaStrCat could not add necessary file name to path.
   RedirectDBCSTempPath solves those bugs.

   Example:
   change C:\DOCUME~1\DBCS\LOCALS~1\Temp\ (DBCS User Temp)
   to C:\DOCUME~1\ALLUSE~1\APPLIC~1\ (All User App Data)

 History:

    05/04/2001  hioh        Created
    03/14/2002  mnikkel     Increased size of buffer to MAX_PATH*2
                            converted to use strsafe.h
    04/25/2002  hioh        To "\Documents and Settings\All Users\Application Data\" for LUA
    05/31/2002  hioh        Ported from Lab03 to fix 623371 on xpsp1

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RedirectDBCSTempPath)
#include "ShimHookMacro.h"

//
// API to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetTempPathA) 
APIHOOK_ENUM_END

/*++

 Function Description:
    
    Check if DBCS character is included in the specified length of the string.

 Arguments:

    IN pStr  - Pointer to the string
    IN dwlen - Length to check

 Return Value:

    TRUE if DBCS exist or FALSE

 History:

    05/04/2001 hioh     Created

--*/

BOOL
IsDBCSHere(
    CHAR    *pStr,
    DWORD   dwlen
    )
{
    while (0 < dwlen--)
    {
        if (IsDBCSLeadByte(*pStr++))
        {
            return TRUE;
        }
    }
    return FALSE;
}

/*++

 Hack to redirect DBCS temp path to SBCS ALL User App Data path.
 
--*/

DWORD
APIHOOK(GetTempPathA)(
    DWORD nBufferLength,
    LPSTR lpBuffer
    )
{
    // Check if valid pointer
    if (!lpBuffer)
    {   // NULL pointer error
        LOG("RedirectDBCSTempPath", eDbgLevelError, "lpBuffer is NULL.");
        return (ORIGINAL_API(GetTempPathA)(nBufferLength, lpBuffer));
    }

    // Call original API with my stack data
    CHAR    szTempPath[MAX_PATH*2];
    DWORD   dwLen = ORIGINAL_API(GetTempPathA)(sizeof(szTempPath), szTempPath);

    // If API error occurs, return
    if (dwLen <= 0 || dwLen >= MAX_PATH)
    {
        return dwLen;
    }

    // Check DBCS, if so, try to redirect
    if (IsDBCSHere(szTempPath, dwLen))
    {
        CHAR    szAllUserPath[MAX_PATH*2] = "";

        // Get All User App Data path
        if (SHGetSpecialFolderPathA(0, szAllUserPath, CSIDL_COMMON_APPDATA, FALSE))
        {
            // Check if we have non DBCS path
            if (szAllUserPath[0] && !IsDBCSHere(szAllUserPath, strlen(szAllUserPath)))
            {
                CHAR    szNewTempPath[MAX_PATH*2] = "";
                DWORD   dwNewLen;

                dwNewLen = GetShortPathNameA(szAllUserPath, szNewTempPath, sizeof(szNewTempPath));
                // Add last back slash if not exist
                if (dwNewLen+1 < MAX_PATH*2 && szNewTempPath[dwNewLen-1] != 0x5c)
                {
                    szNewTempPath[dwNewLen] = 0x5c;
                    dwNewLen++;
                    szNewTempPath[dwNewLen] = 0;
                }
                if (dwNewLen < nBufferLength)
                {   // Enough space to return new path
                    if (strcpy(lpBuffer, szNewTempPath))
                    {
                        LOG("RedirectDBCSTempPath", eDbgLevelInfo, "GetTempPathA() is redirected to All User App Data.");
                        return (dwNewLen);
                    }
                }
                LOG("RedirectDBCSTempPath", eDbgLevelInfo, "nBufferLength is not sufficient.");
                return (dwNewLen + 1);
            }
        }
    }

    // Return original data
    LOG("RedirectDBCSTempPath", eDbgLevelInfo, "Returns original result.");
    if (dwLen < nBufferLength)
    {
        if (strcpy(lpBuffer, szTempPath))
        {
            return (dwLen);
        }
    }
    return (dwLen + 1);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetTempPathA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\redirectexe.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RedirectEXE.cpp

 Abstract:

    Launch a new EXE and terminate the existing one.

 Notes:

    This is a general purpose shim.

 History:

    04/10/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RedirectEXE)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

/*++

 Launch the new process.

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {

        // 
        // Redirect the EXE
        //
        CSTRING_TRY 
        {
            AppAndCommandLine acl(NULL, GetCommandLineA());
        
            CString csAppName(COMMAND_LINE);

            csAppName.ExpandEnvironmentStrings();

            if (csAppName.GetAt(0) == L'+')
            {

                LPVOID  lpvEnv;
                CString csDrive, csPathAdd, csName, csExt, csCracker;
                DWORD   dwLen;

                csAppName.Delete(0, 1);
                csCracker=acl.GetApplicationName();
                csCracker.SplitPath(&csDrive, &csPathAdd, &csName, &csExt);

                csPathAdd.TrimRight('\\');
                if (csPathAdd.IsEmpty())
                {
                    csPathAdd = L"\\";
                }

                static const DWORD dwBufferSize = 2000;
                WCHAR   szBuffer[dwBufferSize];
                dwLen = GetEnvironmentVariableW(L"PATH", szBuffer, dwBufferSize);
                if (!dwLen)
                {
                    LOGN( eDbgLevelError, "Could not get path!");
                }
                else
                {
                    CString csPathEnv = szBuffer;

                    csPathEnv += L";";
                    csPathEnv += csDrive;
                    csPathEnv += csPathAdd;
                    if (!SetEnvironmentVariable(L"PATH", csPathEnv.Get()))
                    {
                        LOGN( eDbgLevelError, "Could not set path!");
                    }
                    else
                    {
                        LOGN( eDbgLevelInfo, "New Path: %S", csPathEnv);
                    }
                }
                
            }

            csAppName += L" ";
            csAppName += acl.GetCommandlineNoAppName();

            LOGN( eDbgLevelInfo, "Redirecting to %S", csAppName);

            WinExec(csAppName.GetAnsi(), SW_SHOWDEFAULT);
        }
        CSTRING_CATCH
        {
            LOGN( eDbgLevelError, "Exception while trying to redirect EXE");
        }

        ExitProcess(0);
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\propagateprocesshistory.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   PropagateProcessHistory.cpp

 Abstract:

   This DLL adds the current process to the __PROCESS_HISTORY environment
   variable. This is needed for 32-bit applications that launch other
   32-bit executables that have been put in a temporary directory and have
   no appropriate side-step files. It allows the matching mechanism to
   locate files in the parent's directory, which are unique to the application.

 History:

   03/21/2000 markder  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(PropagateProcessHistory)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        DWORD dwProcessHistoryBufSize, dwExeFileNameBufSize;
        LPWSTR wszExeFileName = NULL, wszProcessHistory = NULL;

        dwProcessHistoryBufSize = GetEnvironmentVariableW( L"__PROCESS_HISTORY", NULL, 0 );
        dwExeFileNameBufSize = MAX_PATH; // GetModuleFileNameW doesn't return buffer size needed??;

        wszProcessHistory = (LPWSTR) HeapAlloc(
                                        GetProcessHeap(),
                                        HEAP_GENERATE_EXCEPTIONS,
                                        (dwProcessHistoryBufSize + dwExeFileNameBufSize + 2) * sizeof(WCHAR) );

        wszExeFileName = (LPWSTR) HeapAlloc(
                                        GetProcessHeap(),
                                        HEAP_GENERATE_EXCEPTIONS,
                                        (dwExeFileNameBufSize + 1) * sizeof(WCHAR) );

        if( wszExeFileName && wszProcessHistory )
        {
            wszProcessHistory[0] = L'\0';
            dwProcessHistoryBufSize = GetEnvironmentVariableW( 
                                            L"__PROCESS_HISTORY",
                                            wszProcessHistory,
                                            dwProcessHistoryBufSize );

            dwExeFileNameBufSize = GetModuleFileNameW( NULL, wszExeFileName, dwExeFileNameBufSize );

            if( *wszProcessHistory && wszProcessHistory[wcslen(wszProcessHistory) - 1] != L';' )
                wcscat( wszProcessHistory, L";" );

            wcscat( wszProcessHistory, wszExeFileName );

            if( ! SetEnvironmentVariableW( L"__PROCESS_HISTORY", wszProcessHistory ) )
            {
                DPFN( eDbgLevelError, "SetEnvironmentVariable failed!");
            }
            else
            {
                DPFN( eDbgLevelInfo, "Current EXE added to process history");
                DPFN( eDbgLevelInfo, "__PROCESS_HISTORY=%S", wszProcessHistory);
            }
        }
        else
            DPFN( eDbgLevelError, "Could not allocate memory for strings");

        if( wszProcessHistory )
            HeapFree( GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS, wszProcessHistory );

        if( wszExeFileName )
            HeapFree( GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS, wszExeFileName );
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\removebroadcastpostmessage.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RemoveBroadcastPostMessage.cpp

 Abstract:

    Fix apps that don't handle broadcast messages.

 Notes:

    This is a general purpose shim.

 History:

    04/28/2000 a-batjar  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RemoveBroadcastPostMessage)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(PostMessageA) 
APIHOOK_ENUM_END

/*++

 Filter HWND_BROADCAST messages

--*/

BOOL 
APIHOOK(PostMessageA)(
        HWND hwnd,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam
        )
{
    if (hwnd == HWND_BROADCAST)
    {
        hwnd = NULL;
    }

    return ORIGINAL_API(PostMessageA)(
        hwnd,
        Msg,
        wParam,
        lParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, PostMessageA)

HOOK_END

    

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\redirectwindowsdirtosystem32.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RedirectWindowsDirToSystem32.cpp

 Abstract:

    Redirects GetWindowsDirectory calls to GetSystemDirectory.

 Notes:


 History:

    04/05/2000 a-batjar  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RedirectWindowsDirToSystem32)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetWindowsDirectoryA) 
    APIHOOK_ENUM_ENTRY(GetWindowsDirectoryW) 
APIHOOK_ENUM_END

DWORD 
APIHOOK(GetWindowsDirectoryA)(
    LPSTR lpBuffer,
    DWORD Size 
    )
{
   return GetSystemDirectoryA( lpBuffer, Size );
}

DWORD 
APIHOOK(GetWindowsDirectoryW)(
    LPWSTR lpBuffer,
    DWORD Size 
    )
{
   return GetSystemDirectoryW( lpBuffer, Size );
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetWindowsDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetWindowsDirectoryW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\removeinvalidw2kwindowstyles.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RemoveInvalidW2KWindowStyles.cpp

 Abstract:

    Windows 2000 deems certain previously supported Windows style bits as 
    "invalid". This shim removes the newly invalidated style bits from the mask 
    which will allow the CreateWindowEx call to succeed.

 Notes:

    This is a general purpose shim.

 History:

    09/13/1999 markder  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RemoveInvalidW2KWindowStyles)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateWindowExA) 
    APIHOOK_ENUM_ENTRY(CreateWindowExW) 
APIHOOK_ENUM_END

/*++

 Remove invalid Windows 2000 style bits from dwExStyle mask before calling
 CreateWindowEx.

--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,
    LPCSTR lpClassName,
    LPCSTR lpWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam 
    )
{
    // Defined in windows source as WS_INVALID50
    dwExStyle &= 0x85F77FF;         

    return ORIGINAL_API(CreateWindowExA)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,
        x,
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,
        hInstance,
        lpParam);
}

/*++

 Remove invalid Windows 2000 style bits from dwExStyle mask before calling
 CreateWindowEx.

--*/

HWND 
APIHOOK(CreateWindowExW)(
    DWORD dwExStyle,
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam 
    )
{
    dwExStyle &= 0x85F77FF;
    
    // Call the original API
    return ORIGINAL_API(CreateWindowExW)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,
        x,
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,
        hInstance,
        lpParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\removenobufferingflagfromcreatefile.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RemoveNoBufferingFlagFromCreateFile.cpp

 Abstract:

    This modified version of kernel32!CreateFile* prevents an app from using
    the FILE_FLAG_NO_BUFFERING flag if the app doesn't handle it correctly.

 Notes:

    This is a general shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RemoveNoBufferingFlagFromCreateFile)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
APIHOOK_ENUM_END


/*++

    Take out FILE_FLAG_NO_BUFFERING

--*/

HANDLE
APIHOOK(CreateFileA)(
    LPSTR                 lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
    )
{
    //
    // Take out FILE_FLAG_NO_BUFFERING.
    //
    if (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING) {
        DPFN(
            eDbgLevelInfo,
            "[CreateFileA] called with FILE_FLAG_NO_BUFFERING set.\n");
    }
    
    dwFlagsAndAttributes &= ~FILE_FLAG_NO_BUFFERING;

    return ORIGINAL_API(CreateFileA)(
                                lpFileName,
                                dwDesiredAccess,
                                dwShareMode,
                                lpSecurityAttributes,
                                dwCreationDisposition,
                                dwFlagsAndAttributes,
                                hTemplateFile);
}

/*++

    Take out FILE_FLAG_NO_BUFFERING

--*/

HANDLE
APIHOOK(CreateFileW)(
    LPWSTR                lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
    )
{
    //
    // Take out FILE_FLAG_NO_BUFFERING.
    //
    if (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING) {
        DPFN(
            eDbgLevelInfo,
            "[CreateFileW] called with FILE_FLAG_NO_BUFFERING set.\n");
    }
    
    dwFlagsAndAttributes &= ~FILE_FLAG_NO_BUFFERING;

    return ORIGINAL_API(CreateFileW)(
                                lpFileName,
                                dwDesiredAccess,
                                dwShareMode,
                                lpSecurityAttributes,
                                dwCreationDisposition,
                                dwFlagsAndAttributes,
                                hTemplateFile);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\removeoverlappedflagfromcreatefile.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    RemoveOverlappedFlagFromCreateFile.cpp

 Abstract:

    This modified version of kernel32!CreateFile* prevents an app from using
    the FILE_FLAG_OVERLAPPED flag if the app doesn't handle it correctly.

 Notes:

    This is a general shim.

 History:

    06/22/2001 linstev Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RemoveOverlappedFlagFromCreateFile)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
APIHOOK_ENUM_END

/*++

 Take out FILE_FLAG_OVERLAPPED if we are on a drive

--*/

HANDLE
APIHOOK(CreateFileA)(
    LPSTR                 lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
    )
{
    if ((dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED) &&
        (GetDriveTypeFromFileNameA(lpFileName) != DRIVE_UNKNOWN))
    {
        dwFlagsAndAttributes &= ~FILE_FLAG_OVERLAPPED;
        LOGN(eDbgLevelInfo, "[CreateFileA] \"%s\": removed OVERLAPPED flag", lpFileName);
    }

    return ORIGINAL_API(CreateFileA)(lpFileName, dwDesiredAccess, dwShareMode,
        lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes,
        hTemplateFile);
}

/*++

 Take out FILE_FLAG_OVERLAPPED if we are on a drive

--*/

HANDLE
APIHOOK(CreateFileW)(
    LPWSTR                lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
    )
{
    if ((dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED) &&
        (GetDriveTypeFromFileNameW(lpFileName) != DRIVE_UNKNOWN))
    {
        dwFlagsAndAttributes &= ~FILE_FLAG_OVERLAPPED;
        LOGN(eDbgLevelInfo, "[CreateFileW] \"%S\": removed OVERLAPPED flag", lpFileName);
    }

    return ORIGINAL_API(CreateFileW)(lpFileName, dwDesiredAccess, dwShareMode,
        lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, 
        hTemplateFile);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\removeipfrommsinfocommandline.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RemoveIpFromMsInfoCommandLine.cpp   

 Abstract:

    Microsoft Streets & Trips 2000 specific hack. removing /p option when it 
    calls msinfo: Bug #30531

 Notes:

    This is a general purpose shim.

 History:

   02/23/2000 jarbats  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RemoveIpFromMsInfoCommandLine)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessW) 
APIHOOK_ENUM_END

BOOL 
APIHOOK(CreateProcessW)(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    WCHAR *szTemp = NULL;

    if (lpCommandLine && wcsistr(lpCommandLine, L"msinfo32.exe"))
    {
        szTemp = wcsistr(lpCommandLine, L"/p");

        if (NULL != szTemp)
        {
            *szTemp ++ = L' ';
            *szTemp = L' ';
        }
    }
    
    return ORIGINAL_API(CreateProcessW)(
        lpApplicationName,
        lpCommandLine,
        lpProcessAttributes,
        lpThreadAttributes,
        bInheritHandles,
        dwCreationFlags,
        lpEnvironment,
        lpCurrentDirectory,
        lpStartupInfo,
        lpProcessInformation);
}
 
/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\removeddeflagfromshellexecuteex.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    RemoveDDEFlagFromShellExecuteEx.cpp

 Abstract:

    Some applications call ShellExecute which in turn calls ShellExecuteEx.
    One of the flags in the SHELLEXECUTEINFO structure is 'SEE_MASK_FLAG_DDEWAIT'.
    This flag gets set by ShellExecuteEx as a default whenever ShellExecute is
    called.
    
    Here is the description for the flag:
    
    'Wait for the DDE conversation to terminate before returning
    (if the ShellExecuteEx function causes a DDE conversation to start).
    
    The SEE_MASK_FLAG_DDEWAIT flag must be specified if the thread calling
    ShellExecuteEx does not have a message loop or if the thread or process
    will terminate soon after ShellExecuteEx returns. Under such conditions,
    the calling thread will not be available to complete the DDE conversation,
    so it is important that ShellExecuteEx complete the conversation before
    returning control to the caller. Failure to complete the conversation can
    result in an unsuccessful launch of the document.
    
    If the calling thread has a message loop and will exist for some time
    after the call to ShellExecuteEx returns, the SEE_MASK_FLAG_DDEWAIT
    flag is optional. If the flag is omitted, the calling thread's message
    pump will be used to complete the DDE conversation. The calling application
    regains control sooner, since the DDE conversation can be completed in the background.'
    
    When the flag gets passed, it can sometimes cause synchronzation problems.
    An example is Photo Express Platinum 2000. It attempts to launch Internet Explorer,
    but IE wreaks havoc on the app that made the call.
    
    This shim simply removes this flag from the ShellExecuteEx call.

 Notes:
    
    This is a general purpose shim.

 History:

    04/16/2001  rparsons  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RemoveDDEFlagFromShellExecuteEx)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ShellExecuteExW)
APIHOOK_ENUM_END

/*++

 Hook the call to ShellExecuteExW and remove the flag.

--*/

BOOL
APIHOOK(ShellExecuteExW)(
    LPSHELLEXECUTEINFO lpExecInfo
    )
{
    lpExecInfo->fMask = lpExecInfo->fMask & ~SEE_MASK_FLAG_DDEWAIT;

    LOGN( eDbgLevelInfo, "Removed SEE_MASK_FLAG_DDEWAIT from ShellExecuteExW");
    
    return ORIGINAL_API(ShellExecuteExW)(lpExecInfo);
    
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(SHELL32.DLL, ShellExecuteExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\removereadonlyattribute.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RemoveReadOnlyAttribute.cpp

 Abstract:

    Removes read only attributes from directories: used to fix some apps that 
    aren't used to shell folders being read-only.

 Notes:

    This is a general purpose shim.

 History:

    01/03/2000 a-jamd   Created
    12/02/2000 linstev  Separated functionality into 2 shims: this one and EmulateCDFS

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RemoveReadOnlyAttribute)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetFileAttributesW)
    APIHOOK_ENUM_ENTRY(GetFileAttributesA)        
    APIHOOK_ENUM_ENTRY(FindFirstFileW)         
    APIHOOK_ENUM_ENTRY(FindFirstFileA)             
    APIHOOK_ENUM_ENTRY(FindNextFileW)             
    APIHOOK_ENUM_ENTRY(FindNextFileA)              
    APIHOOK_ENUM_ENTRY(GetFileInformationByHandle)
APIHOOK_ENUM_END

typedef struct _FINDFILE_HANDLE 
{
    HANDLE DirectoryHandle;
    PVOID FindBufferBase;
    PVOID FindBufferNext;
    ULONG FindBufferLength;
    ULONG FindBufferValidLength;
    RTL_CRITICAL_SECTION FindBufferLock;
} FINDFILE_HANDLE, *PFINDFILE_HANDLE;

/*++

 Remove read only attribute if it's a directory

--*/

DWORD 
APIHOOK(GetFileAttributesA)(LPCSTR lpFileName)
{    
    DWORD dwFileAttributes = ORIGINAL_API(GetFileAttributesA)(lpFileName);
    
    // Check for READONLY and DIRECTORY attributes
    if ((dwFileAttributes != INT_PTR(-1)) &&
        (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (dwFileAttributes & FILE_ATTRIBUTE_READONLY))
    {
        // Flip the read-only bit.
        LOGN( eDbgLevelWarning, "[GetFileAttributesA] Removing FILE_ATTRIBUTE_READONLY");
        dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return dwFileAttributes;
}

/*++

 Remove read only attribute if it's a directory

--*/

DWORD 
APIHOOK(GetFileAttributesW)(LPCWSTR wcsFileName)
{
    DWORD dwFileAttributes = ORIGINAL_API(GetFileAttributesW)(wcsFileName);
    
    // Check for READONLY and DIRECTORY attributes
    if ((dwFileAttributes != INT_PTR(-1)) &&
        (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (dwFileAttributes & FILE_ATTRIBUTE_READONLY))
    {
        // Flip the read-only bit.
        LOGN( eDbgLevelWarning, "[GetFileAttributesW] Removing FILE_ATTRIBUTE_READONLY");
        dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return dwFileAttributes;
}

/*++

 Remove read only attribute if it's a directory

--*/

HANDLE 
APIHOOK(FindFirstFileA)(
    LPCSTR lpFileName, 
    LPWIN32_FIND_DATAA lpFindFileData
    )
{    
    HANDLE hFindFile = ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);

    if ((hFindFile != INVALID_HANDLE_VALUE) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY))
    {
        // Flip the read-only bit
        LOGN( eDbgLevelWarning, "[FindFirstFileA] Removing FILE_ATTRIBUTE_READONLY");
        lpFindFileData->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return hFindFile;
}

/*++

 Remove read only attribute if it's a directory.

--*/

HANDLE 
APIHOOK(FindFirstFileW)(
    LPCWSTR wcsFileName, 
    LPWIN32_FIND_DATAW lpFindFileData
    )
{
    HANDLE hFindFile = ORIGINAL_API(FindFirstFileW)(wcsFileName, lpFindFileData);

    if ((hFindFile != INVALID_HANDLE_VALUE) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY))
    {
        // It's a directory: flip the read-only bit
        LOGN( eDbgLevelInfo, "[FindFirstFileW] Removing FILE_ATTRIBUTE_READONLY");
        lpFindFileData->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return hFindFile;
}

/*++

 Remove read only attribute if it's a directory.

--*/

BOOL 
APIHOOK(FindNextFileA(
    HANDLE hFindFile, 
    LPWIN32_FIND_DATAA lpFindFileData 
    )
{    
    BOOL bRet = ORIGINAL_API(FindNextFileA)(hFindFile, lpFindFileData);

    if (bRet &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY))
    {
        // Flip the read-only bit.
        LOGN( eDbgLevelWarning, "[FindNextFileA] Removing FILE_ATTRIBUTE_READONLY"));
        lpFindFileData->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return bRet;
}

/*++

 Remove read only attribute if it's a directory.

--*/

BOOL 
APIHOOK(FindNextFileW)(
    HANDLE hFindFile, 
    LPWIN32_FIND_DATAW lpFindFileData 
    )
{
    BOOL bRet = ORIGINAL_API(FindNextFileW)(hFindFile, lpFindFileData);

    if (bRet &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY))
    {
        // Flip the read-only bit
        LOGN( eDbgLevelWarning, "[FindNextFileW] Removing FILE_ATTRIBUTE_READONLY");
        lpFindFileData->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return bRet;
}

/*++

 Remove read only attribute if it's a directory.

--*/

BOOL 
APIHOOK(GetFileInformationByHandle)( 
    HANDLE hFile, 
    LPBY_HANDLE_FILE_INFORMATION lpFileInformation 
    )
{
    BOOL bRet = ORIGINAL_API(GetFileInformationByHandle)(hFile, lpFileInformation);

    if (bRet &&
        (lpFileInformation->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFileInformation->dwFileAttributes & FILE_ATTRIBUTE_READONLY))
    {
        // It's a CDROM too. Flip the read-only bit.
        LOGN( eDbgLevelWarning, "[GetFileInformationByHandle] Removing FILE_ATTRIBUTE_READONLY");
        lpFileInformation->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesW);
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesA);
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileW);
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA);
    APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileW);
    APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileA);
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileInformationByHandle);

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\searchpathinapppaths.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   SearchPathInAppPaths.cpp

 Abstract:

   An application might use SearchPath to determine if a specific EXE is found
   in the current path.  Some applications have registered their path with the
   shell in "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\App Paths"
   If SearchPath fails, we'll check to see if the applications has registered a path.

 History:

   03/03/2000 robkenny  Created

--*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(SearchPathInAppPaths)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SearchPathA) 
APIHOOK_ENUM_END

/*++

 Grab an entry from the registry, expand if REG_EXPAND_SZ.
 Return a full path in lpBuffer, and a pointer to the file part.

 Return the number of chars copied into lpBuffer, including NULL terminator.

--*/

DWORD 
GetPathFromRegistryA(
    HKEY hKey,            // handle to key
    LPCSTR lpKeyPath,     // value name
    LPCSTR lpValueName,   // value name
    DWORD nBufferLength,  // size of buffer
    LPSTR lpBuffer,       // found file name buffer
    LPSTR *lpFilePart     // file component (optional)
    )
{
    DWORD returnValue = 0;
    HKEY hkPathKey;
    LONG success;

    success = RegOpenKeyExA(hKey, lpKeyPath, 0, KEY_QUERY_VALUE, &hkPathKey);
    if (success == ERROR_SUCCESS)
    {
        
        DWORD appPathsKeyType;
        char appPathsData[MAX_PATH];
        DWORD appPathsDataSize = MAX_PATH;

        appPathsData[0] = 0;
        success = RegQueryValueExA(
            hkPathKey, lpValueName, NULL, &appPathsKeyType, (BYTE *)appPathsData, 
            &appPathsDataSize);

        if (success == ERROR_SUCCESS)
        {
            if (appPathsKeyType == REG_EXPAND_SZ)
            {
                // Gotta expand the env. vars
                char expandedAppPathsData[MAX_PATH];
                DWORD dwChars = ExpandEnvironmentStringsA(appPathsData, expandedAppPathsData, MAX_PATH);
                if (dwChars > 0)
                {
                    returnValue = GetFullPathNameA(expandedAppPathsData, nBufferLength, lpBuffer, lpFilePart);
                }
            }
            else if (appPathsKeyType == REG_SZ)
            {
                returnValue = GetFullPathNameA(appPathsData, nBufferLength, lpBuffer, lpFilePart);
            }
        }

        RegCloseKey(hkPathKey);
    }

    return returnValue;
}

  
DWORD 
APIHOOK(SearchPathA)(
    LPCSTR lpPath,       // search path
    LPCSTR lpFileName,   // file name
    LPCSTR lpExtension,  // file extension
    DWORD nBufferLength, // size of buffer
    LPSTR lpBuffer,      // found file name buffer
    LPSTR *lpFilePart    // file component
    )
{
    DWORD returnValue = ORIGINAL_API(SearchPathA)(
        lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart);

    if (returnValue == 0)
    {
        // Search failed, look in the registry.
        // First look for lpFileName.  If that fails, append lpExtension and look again.

        CSTRING_TRY
        {
            CString csFile(lpFileName);
            CString csReg(L"Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\");
            csReg.AppendPath(csFile);

            DWORD success;
            success = GetPathFromRegistryA(HKEY_LOCAL_MACHINE,
                                           csReg.GetAnsi(),
                                           NULL,           // (Default) entry
                                           nBufferLength,
                                           lpBuffer,
                                           lpFilePart);
            if (success > 0)
            {
                // SearchPath returns the number of chars, not including the NULL terminator
                returnValue = success - 1;
            }
            else
            {
                // Try appending the extension onto the path
                CString csExt(lpExtension);
                csReg += csExt;

                success = GetPathFromRegistryA(HKEY_LOCAL_MACHINE,
                                               csReg.GetAnsi(),
                                               NULL,           // (Default) entry
                                               nBufferLength,
                                               lpBuffer,
                                               lpFilePart);
                if (success > 0)
                {
                    // SearchPath returns the number of chars, not including the NULL terminator
                    returnValue = success - 1;
                }
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return returnValue;
}

/*++

  Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, SearchPathA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\setenvironmentvariable.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    SetEnvironmentVariable.cpp

 Abstract:

    mapi dlls don't ship with w2k, and with outlook2000 it gets installed in a different
    location (%commonprogramfiles%)
    resumemaker and possibly others depend on mapi dlls being in system32 directory.
    Command line syntax is "envvariablename|envvariablevalue|envvariablename|envvariablevalue"

 Notes:

    This is an app specific shim.

 History:

    07/02/2000 jarbats  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SetEnvironmentVariable)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

/*++

 Set environment variables in the command line to get some dll path resolutions correct.

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        char *CmdLine = COMMAND_LINE;
        char *lpstrEnvName,*lpstrEnvVal,*lpstrBuf;
        DWORD num;

        while (1)
        {
            lpstrEnvName = lpstrEnvVal = CmdLine;        

            while (*CmdLine && (*CmdLine != '|')) CmdLine++;

            if (*CmdLine == '|')
            {
                *CmdLine = '\0';
                CmdLine++;
            }
        
            lpstrEnvVal = CmdLine;                       

            if (0 == *lpstrEnvVal) 
            {
                break;
            }
  
            lpstrBuf = NULL;
            num = 0;
            num = ExpandEnvironmentStringsA(lpstrEnvVal, lpstrBuf, 0);
         
            if (0 == num)
            {
               DPFN( eDbgLevelError, "Couldn't get environment strings size in the input\n %s\n", lpstrEnvVal);
               return TRUE;
            }        
         
            lpstrBuf = (char*) HeapAlloc(GetProcessHeap(), 0, num+1);

            if (NULL == lpstrBuf)
            {
                DPFN( eDbgLevelError," Couldn't allocate memory");
                return TRUE;
            }   
        
            num = ExpandEnvironmentStringsA(lpstrEnvVal,lpstrBuf,num);
      
            if (0 == num)
            {
                DPFN( eDbgLevelError, "Couldn't expand environment strings in the input\n %s\n", lpstrEnvVal);
                HeapFree(GetProcessHeap(),0,lpstrBuf);
                return TRUE;
            }
   
            if (SetEnvironmentVariableA(lpstrEnvName,lpstrBuf))
            {           
                DPFN( eDbgLevelInfo, "Set %s to %s\n",lpstrEnvName,lpstrBuf);
            }
            else
            {
                DPFN( eDbgLevelInfo, "No Success setting %s to %s\n",lpstrEnvName,lpstrEnvVal);
            }

            if (NULL != lpstrBuf)
            {
                HeapFree(GetProcessHeap(),0,lpstrBuf);
            }

            while (*CmdLine && (*CmdLine == '|')) CmdLine++;
        }
    }

    return TRUE;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\removespacesafterslashfromfilenames.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RemoveSpacesAfterSlashFromFilenames.cpp

 Abstract:

    This shims all of the listed apis and simply searches a filename var for
    "\ " and replaces it with "\"

 Notes:

    This is a general purpose shim.

 History:

    12/15/1999 markder  Created
    05/16/2000 robkenny Check for memory alloc failure.
                        Moved MassagePath routines to here.

--*/

#include "ShimHook.h"

enum
{

    APIHOOK_CreateFileA = USERAPIHOOKSTART,
    APIHOOK_CreateFileW,
    APIHOOK_GetFileAttributesA,
    APIHOOK_GetFileAttributesW,
    APIHOOK_GetFileAttributesExA,
    APIHOOK_GetFileAttributesExW,
    APIHOOK_DeleteFileA,
    APIHOOK_DeleteFileW,
    APIHOOK_RemoveDirectoryA,
    APIHOOK_RemoveDirectoryW,
    APIHOOK_MoveFileA,
    APIHOOK_MoveFileW,
    APIHOOK_MoveFileExA,
    APIHOOK_MoveFileExW,
    APIHOOK_Count
};
/*++

 Function Description:
    
    Removes all "\ " and replaces with "\".

 Arguments:

    IN  pszOldPath - String to scan
    OUT pszNewPath - Resultant string

 Return Value: 
    
    None

 History:

    01/10/2000 linstev  Updated

--*/

VOID 
MassagePathA(
    LPCSTR pszOldPath, 
    LPSTR pszNewPath
    )
{
    PCHAR pszTempBuffer;
    PCHAR pszPointer;
    LONG nOldPos, nNewPos, nOldStringLen;
    BOOL bAtSeparator = TRUE;

    nOldStringLen = strlen(pszOldPath);
    pszTempBuffer = (PCHAR) LocalAlloc(LPTR, nOldStringLen + 1);
    if (pszTempBuffer == NULL)
    {
        // Alloc failed, do nothing.
        strcpy(pszNewPath, pszOldPath);
        return;
    }
    pszPointer = pszTempBuffer;

    nNewPos = nOldStringLen;
    for (nOldPos = nOldStringLen - 1; nOldPos >= 0; nOldPos--)
    {
        if (pszOldPath[ nOldPos ] == '\\')
        {
            bAtSeparator = TRUE;
        }
        else
        {
            if (pszOldPath[nOldPos] == ' ' && bAtSeparator)
            {
                DPF(eDbgLevelError, "[MassagePathA] Found \"\\ \" in filename. Removing space.\n");
                continue;
            }
            else
            {
                bAtSeparator = FALSE;
            }
        }

        pszPointer[--nNewPos] = pszOldPath[nOldPos];
    }

    pszPointer += nNewPos;
    strcpy(pszNewPath, pszPointer);
    LocalFree(pszTempBuffer);
}

/*++

 Function Description:
    
    Removes all L"\ " and replaces with L"\".

 Arguments:

    IN  pwszOldPath - String to scan
    OUT pwszNewPath - Resultant string

 Return Value: 
    
    None

 History:

    01/10/2000 linstev  Updated

--*/

VOID 
MassagePathW( 
    LPCWSTR pwszOldPath, 
    LPWSTR pwszNewPath 
    )
{
    PWCHAR pwszTempBuffer;
    PWCHAR pwszPointer;
    LONG nOldPos, nNewPos, nOldStringLen;
    BOOL bAtSeparator = TRUE;

    nOldStringLen = wcslen(pwszOldPath);
    pwszTempBuffer = (PWCHAR) LocalAlloc(LPTR, (nOldStringLen + 1) * sizeof(WCHAR));
    if (pwszTempBuffer == NULL)
    {
        // Alloc failed, do nothing.
        wcscpy(pwszNewPath, pwszOldPath);
        return;
    }
    pwszPointer = pwszTempBuffer;

    nNewPos = nOldStringLen;
    for (nOldPos = nOldStringLen - 1; nOldPos >= 0; nOldPos--)
    {
        if (pwszOldPath[ nOldPos ] == L'\\')
        {
            bAtSeparator = TRUE;
        }
        else
        {
            if (pwszOldPath[nOldPos] == L' ' && bAtSeparator)
            {
                DPF(eDbgLevelError, "[MassagePathW] Found \"\\ \" in filename. Removing space.\n");
                continue;
            }
            else
            {
                bAtSeparator = FALSE;
            }
        }

        pwszPointer[--nNewPos] = pwszOldPath[nOldPos];
    }

    pwszPointer += nNewPos;

    wcscpy(pwszNewPath, pwszPointer);

    LocalFree(pwszTempBuffer);
}

/*++

 This stub searches pathnames and changes "\ " to "\" prior to OEM call

--*/

HANDLE
APIHook_CreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    LPSTR lpNewFileName = NULL;
    HANDLE hResult = NULL;

    lpNewFileName = (LPSTR) malloc(strlen(lpFileName) + 1);
    if (lpNewFileName != NULL)
    {
        MassagePathA(lpFileName, lpNewFileName);
        hResult = LOOKUP_APIHOOK(CreateFileA)(
            lpNewFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile);
    }
    free(lpNewFileName);

    return hResult;
}

/*++

 This stub searches pathnames and changes "\ " to "\" prior to OEM call

--*/

HANDLE
APIHook_CreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    LPWSTR lpNewFileName = NULL;
    HANDLE hResult = NULL;

    lpNewFileName = (LPWSTR) malloc( (wcslen(lpFileName) + 1) * sizeof(WCHAR));
    if (lpNewFileName != NULL)
    {
        MassagePathW(lpFileName, lpNewFileName);
        hResult = LOOKUP_APIHOOK(CreateFileW)(
            lpNewFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile);
    }
    free(lpNewFileName);

    return hResult;
}

/*++

 This stub searches pathnames and changes "\ " to "\" prior to OEM call

--*/

DWORD
APIHook_GetFileAttributesA(LPCSTR lpFileName)
{
    LPSTR lpNewFileName = NULL;
    DWORD dwResult = -1;

    lpNewFileName = (LPSTR) malloc(strlen(lpFileName) + 1);
    if (lpNewFileName != NULL)
    {
        MassagePathA(lpFileName, lpNewFileName);
        dwResult = LOOKUP_APIHOOK(GetFileAttributesA)(lpNewFileName);
    }
    free(lpNewFileName);

    return dwResult;
}

/*++

 This stub searches pathnames and changes "\ " to "\" prior to OEM call

--*/

DWORD
APIHook_GetFileAttributesW(LPCWSTR lpFileName)
{
    LPWSTR lpNewFileName = NULL;
    DWORD dwResult = -1;

    lpNewFileName = (LPWSTR) malloc( (wcslen(lpFileName) + 1) * sizeof(WCHAR));
    if (lpNewFileName != NULL)
    {
        MassagePathW(lpFileName, lpNewFileName);
        dwResult = LOOKUP_APIHOOK(GetFileAttributesW)(lpNewFileName);
    }
    free(lpNewFileName);

    return dwResult;
}

/*++

 This stub searches pathnames and changes "\ " to "\" prior to OEM call

--*/

BOOL
APIHook_GetFileAttributesExA(
    LPCSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    )
{
    LPSTR lpNewFileName = NULL;
    BOOL bResult = FALSE;

    lpNewFileName = (LPSTR)malloc(strlen(lpFileName) + 1);
    if (lpNewFileName != NULL)
    {
        MassagePathA(lpFileName, lpNewFileName);
        bResult = LOOKUP_APIHOOK(GetFileAttributesExA)(
            lpNewFileName,
            fInfoLevelId,
            lpFileInformation);
    }
    free( lpNewFileName );

    return bResult;
}

/*++

 This stub searches pathnames and changes "\ " to "\" prior to OEM call

--*/

BOOL
APIHook_GetFileAttributesExW(
    LPCWSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    )
{
    LPWSTR lpNewFileName = NULL;
    BOOL bResult = FALSE;

    lpNewFileName = (LPWSTR) malloc( (wcslen(lpFileName) + 1) * sizeof(WCHAR));
    if (lpNewFileName != NULL)
    {
        MassagePathW(lpFileName, lpNewFileName);
        bResult = LOOKUP_APIHOOK(GetFileAttributesExW)(
            lpNewFileName,
            fInfoLevelId,
            lpFileInformation);
    }
    free(lpNewFileName);

    return bResult;
}

/*++

 This stub searches pathnames and changes "\ " to "\" prior to OEM call

--*/

BOOL
APIHook_DeleteFileA(LPCSTR lpFileName)
{
    LPSTR lpNewFileName = NULL;
    BOOL bResult = FALSE;

    lpNewFileName = (LPSTR) malloc(strlen(lpFileName) + 1);
    if (lpNewFileName != NULL)
    {
        MassagePathA(lpFileName, lpNewFileName);
        bResult = LOOKUP_APIHOOK(DeleteFileA)(lpNewFileName);
    }
    free(lpNewFileName);

    return bResult;
}


/*++

 This stub searches pathnames and changes "\ " to "\" prior to OEM call

--*/

BOOL
APIHook_DeleteFileW(LPCWSTR lpFileName)
{
    LPWSTR lpNewFileName = NULL;
    BOOL bResult = FALSE;

    lpNewFileName = (LPWSTR) malloc((wcslen(lpFileName) + 1) * sizeof(WCHAR));
    if (lpNewFileName != NULL)
    {
        MassagePathW(lpFileName, lpNewFileName);
        bResult = LOOKUP_APIHOOK(DeleteFileW)(lpNewFileName);
    }
    free(lpNewFileName);

    return bResult;
}

/*++

 This stub searches pathnames and changes "\ " to "\" prior to OEM call

--*/

BOOL
APIHook_RemoveDirectoryA(LPCSTR lpFileName)
{
    LPSTR lpNewFileName = NULL;
    BOOL bResult = FALSE;

    lpNewFileName = (LPSTR)malloc( strlen( lpFileName ) + 1);
    if (lpNewFileName != NULL)
    {
        MassagePathA(lpFileName, lpNewFileName);
        bResult = LOOKUP_APIHOOK(RemoveDirectoryA)(lpNewFileName);
    }
    free(lpNewFileName);

    return bResult;
}

/*++

 This stub searches pathnames and changes "\ " to "\" prior to OEM call

--*/

BOOL
APIHook_RemoveDirectoryW(LPCWSTR lpFileName)
{
    LPWSTR lpNewFileName = NULL;
    BOOL bResult = FALSE;

    lpNewFileName = (LPWSTR)malloc( (wcslen(lpFileName) + 1) * sizeof(WCHAR));
    if (lpNewFileName != NULL)
    {
        MassagePathW(lpFileName, lpNewFileName);
        bResult = LOOKUP_APIHOOK(RemoveDirectoryW)(lpNewFileName);
    }
    free(lpNewFileName);

    return bResult;
}

/*++

 This stub searches pathnames and changes "\ " to "\" prior to OEM call

--*/

BOOL
APIHook_MoveFileA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    )
{
    LPSTR lpNewNewFileName = NULL;
    LPSTR lpNewExistingFileName = NULL;
    BOOL bResult = FALSE;

    lpNewNewFileName = (LPSTR) malloc( strlen(lpNewFileName) + 1);
    if (lpNewNewFileName != NULL)
    {
        lpNewExistingFileName = (LPSTR) malloc( strlen(lpExistingFileName) + 1);
        if (lpNewNewFileName != NULL)
        {
            MassagePathA(lpNewFileName, lpNewNewFileName);
            MassagePathA(lpExistingFileName, lpNewExistingFileName);

            bResult = LOOKUP_APIHOOK(MoveFileA)(
                lpNewNewFileName,
                lpNewExistingFileName);
        }
    }
    free(lpNewNewFileName);
    free(lpNewExistingFileName);

    return bResult;
}

/*++

 This stub searches pathnames and changes "\ " to "\" prior to OEM call

--*/

BOOL
APIHook_MoveFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    )
{
    LPWSTR lpNewNewFileName = NULL;
    LPWSTR lpNewExistingFileName = NULL;
    BOOL bResult = FALSE;

    lpNewNewFileName = (LPWSTR) malloc((wcslen(lpNewFileName) + 1) * sizeof(WCHAR));
    if (lpNewNewFileName != NULL)
    {
        lpNewExistingFileName = (LPWSTR) malloc((wcslen(lpExistingFileName) + 1) * sizeof(WCHAR));
        if (lpNewExistingFileName != NULL)
        {
            MassagePathW(lpNewFileName, lpNewNewFileName);
            MassagePathW(lpExistingFileName, lpNewExistingFileName);

            bResult = LOOKUP_APIHOOK(MoveFileW)(
                lpNewNewFileName,
                lpNewExistingFileName);
        }
    }
    free(lpNewNewFileName);
    free(lpNewExistingFileName);

    return bResult;
}

/*++

 This stub searches pathnames and changes "\ " to "\" prior to OEM call

--*/

BOOL
APIHook_MoveFileExA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    DWORD dwFlags
    )
{
    LPSTR lpNewNewFileName = NULL;
    LPSTR lpNewExistingFileName = NULL;
    BOOL bResult = FALSE;

    lpNewNewFileName = (LPSTR)malloc(  strlen(lpNewFileName) + 1);
    if (lpNewNewFileName != NULL)
    {
        lpNewExistingFileName = (LPSTR)malloc( strlen(lpExistingFileName) + 1);
        if (lpNewExistingFileName != NULL)
        {
            MassagePathA(lpNewFileName, lpNewNewFileName);
            MassagePathA(lpExistingFileName, lpNewExistingFileName);

            bResult = LOOKUP_APIHOOK(MoveFileExA)(
                lpNewNewFileName,
                lpNewExistingFileName,
                dwFlags);
        }
    }
    free(lpNewNewFileName);
    free(lpNewExistingFileName);

    return bResult;
}

/*++

 This stub searches pathnames and changes "\ " to "\" prior to OEM call

--*/

BOOL
APIHook_MoveFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags
    )
{
    LPWSTR lpNewNewFileName = NULL;
    LPWSTR lpNewExistingFileName = NULL;
    BOOL bResult = FALSE;

    lpNewNewFileName = (LPWSTR) malloc( (wcslen(lpNewFileName) + 1) * sizeof(WCHAR));
    if (lpNewNewFileName != NULL)
    {
        lpNewExistingFileName = (LPWSTR) malloc((wcslen(lpExistingFileName) + 1) * sizeof(WCHAR));
        if (lpNewExistingFileName != NULL)
        {
            MassagePathW(lpNewFileName, lpNewNewFileName);
            MassagePathW(lpExistingFileName, lpNewExistingFileName);

            bResult = LOOKUP_APIHOOK(MoveFileExW)(
                lpNewNewFileName,
                lpNewExistingFileName,
                dwFlags);
        }
    }
    free(lpNewNewFileName);
    free(lpNewExistingFileName);

    return bResult;
}

/*++

 Register hooked functions

--*/

VOID
InitializeHooks(DWORD fdwReason)
{
    if (fdwReason != DLL_PROCESS_ATTACH) return;

    INIT_HOOKS(APIHOOK_Count);

    DECLARE_APIHOOK(KERNEL32.DLL, CreateFileA);
    DECLARE_APIHOOK(KERNEL32.DLL, CreateFileW);
    DECLARE_APIHOOK(KERNEL32.DLL, GetFileAttributesA);
    DECLARE_APIHOOK(KERNEL32.DLL, GetFileAttributesW);
    DECLARE_APIHOOK(KERNEL32.DLL, GetFileAttributesExA);
    DECLARE_APIHOOK(KERNEL32.DLL, GetFileAttributesExW);
    DECLARE_APIHOOK(KERNEL32.DLL, DeleteFileA);
    DECLARE_APIHOOK(KERNEL32.DLL, DeleteFileW);
    DECLARE_APIHOOK(KERNEL32.DLL, RemoveDirectoryA);
    DECLARE_APIHOOK(KERNEL32.DLL, RemoveDirectoryW);
    DECLARE_APIHOOK(KERNEL32.DLL, MoveFileA);
    DECLARE_APIHOOK(KERNEL32.DLL, MoveFileW);
    DECLARE_APIHOOK(KERNEL32.DLL, MoveFileExA);
    DECLARE_APIHOOK(KERNEL32.DLL, MoveFileExW);
}

IMPLEMENT_SHIM_END
#include "ShimHookMacro.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

!ENDIF

TARGETNAME=AcGenral

TARGETTYPE=DYNLINK

INCLUDES=$(INCLUDES);                              \
         ..;                                       \
         $(SHELL_INC_PATH)

SOURCES=..\general.rc                              \
        ..\Main.cpp                                \
        ..\AliasDXDC.cpp                           \
        ..\CorrectACMArgs.cpp                      \
        ..\CorrectACMStreamOpen.cpp                \
        ..\CorrectActiveMoviePath.cpp              \
        ..\CorrectCreateIcon.cpp                   \
        ..\CorrectCreateSurface.cpp                \
        ..\CorrectFarEastFont.cpp                  \
        ..\CorrectFilePathInSetDlgItemText.cpp     \
        ..\CorrectFilePathsUninstall.cpp           \
        ..\CorrectOpenFileExclusive.cpp            \
        ..\CorrectVerInstallFile.cpp               \
        ..\CUASAppFix.cpp                          \
        ..\CUASDisableCicero.cpp                   \
        ..\DelayDllInit.cpp                        \
        ..\DelayShowGroup.cpp                      \
        ..\DelayWin95VersionLie.cpp                \
        ..\DelayWinMMCallback.cpp                  \
        ..\DeleteSpecifiedFiles.cpp                \
        ..\DeRandomizeExeName.cpp                  \
        ..\DisableBoostThread.cpp                  \
        ..\DisableFilterKeys.cpp                   \
        ..\DisableScreenSaver.cpp                  \
        ..\DisableStickyKeys.cpp                   \
        ..\DisableW2KOwnerDrawButtonStates.cpp     \
        ..\EmptyClipboardtoSet.cpp                 \
        ..\EmulateGetStdHandle.cpp                 \
        ..\EmulateGetStringType.cpp                \
        ..\EmulateLZHandles.cpp                    \
        ..\EnlargeGetObject.cpp                    \
        ..\ExtractAssociatedIcon.cpp               \
        ..\FailCloseProfileUserMapping.cpp         \
        ..\FailGetStdHandle.cpp                    \
        ..\FailObsoleteShellAPIs.cpp               \
        ..\FailOpenFile.cpp                        \
        ..\FakeThemeMetrics.cpp                    \
        ..\FilterNetworkResources.cpp              \
        ..\FixServiceStartupCircularDependency.cpp \
        ..\Force640x480x8.cpp                      \
        ..\Force640x480x16.cpp                     \
        ..\ForceAdminAccess.cpp                    \
        ..\ForceAnsiWindowProc.cpp                 \
        ..\ForceAppendMenuSuccess.cpp              \
        ..\ForceApplicationFocus.cpp               \
        ..\ForceAVIWindow.cpp                      \
        ..\ForceDefaultSystemPaletteEntries.cpp    \
        ..\ForceDirectDrawEmulation.cpp            \
        ..\ForceDirectDrawWait.cpp                 \
        ..\ForceDisplayMode.cpp                    \
        ..\ForceSeparateVDM.cpp                    \
        ..\ForceSimpleWindow.cpp                   \
        ..\ForceTemporaryModeChange.cpp            \
        ..\ForceWorkingDirectoryToEXEPath.cpp      \
        ..\FUSAPI.cpp                              \
        ..\FUSBadApplicationType1.cpp              \
        ..\FUSBadApplicationType2.cpp              \
        ..\FUSBadApplicationType3.cpp              \
        ..\FUSBadApplicationType4.cpp              \
        ..\GlobalMemoryStatusLie.cpp               \
        ..\HandleDBCSUserName.cpp                  \
        ..\HandleDBCSUserName2.cpp                 \
        ..\HeapClearAllocation.cpp                 \
        ..\HeapDelayLocalFree.cpp                  \
        ..\HeapForceGrowable.cpp                   \
        ..\HeapIgnoreMoveable.cpp                  \
        ..\HeapLookasideFree.cpp                   \
        ..\HeapPadAllocation.cpp                   \
        ..\HeapValidateFrees.cpp                   \
        ..\HideCursor.cpp                          \
        ..\HideTaskBar.cpp                         \
        ..\IgnoreAltTab.cpp                        \
        ..\IgnoreCoCreateInstance.cpp              \
        ..\IgnoreCRTExit.cpp                       \
        ..\IgnoreDebugOutput.cpp                   \
        ..\IgnoreFreeLibrary.cpp                   \
        ..\IgnoreHungAppPaint.cpp                  \
        ..\IgnoreMCIStop.cpp                       \
        ..\IgnoreMessageBox.cpp                    \
        ..\IgnoreNoModeChange.cpp                  \
        ..\IgnoreOemToChar.cpp                     \
        ..\IgnoreSysColChanges.cpp                 \
        ..\IgnoreTAPIDisconnect.cpp                \
        ..\IgnoreVBOverflow.cpp                    \
        ..\IgnoreZeroMoveWindow.cpp                \
        ..\InjectDll.cpp                           \
        ..\KeepWindowOnMonitor.cpp                 \
        ..\LazyReleaseDC.cpp                       \
        ..\LimitFindFile.cpp                       \
        ..\LoadComctl32Version5.cpp                \
        ..\LoadLibraryCWD.cpp                      \
        ..\LowerThreadPriority.cpp                 \
        ..\MoveIniToRegistry.cpp                   \
        ..\MoveWinInitRenameToReg.cpp              \
        ..\NullHwndInMessageBox.cpp                \
        ..\PaletteRestore.cpp                      \
        ..\PopulateDefaultHKCUSettings.cpp         \
        ..\PropagateProcessHistory.cpp             \
        ..\RecopyEXEFromCD.cpp                     \
        ..\RedirectDBCSTempPath.cpp                \
        ..\RedirectEXE.cpp                         \
        ..\RedirectWindowsDirToSystem32.cpp        \
        ..\RemoveBroadcastPostMessage.cpp          \
        ..\RemoveDDEFlagFromShellExecuteEx.cpp     \
        ..\RemoveInvalidW2KWindowStyles.cpp        \
        ..\RemoveIpFromMsInfoCommandLine.cpp       \
        ..\RemoveNoBufferingFlagFromCreateFile.cpp \
        ..\RemoveOverlappedFlagFromCreateFile.cpp  \
        ..\RemoveReadOnlyAttribute.cpp             \
        ..\RestoreSystemCursors.cpp                \
        ..\SearchPathInAppPaths.cpp                \
        ..\SetEnvironmentVariable.cpp              \
        ..\StackSwap_Exports.cpp                   \
        ..\StackSwap.cpp                           \
        ..\TerminateExe.cpp                        \
        ..\TrimVersionInfo.cpp                     \
        ..\UnMirrorImageList.cpp                   \
        ..\WaveOutUsePreferredDevice.cpp           \
        ..\WinG32SysToSys32.cpp

C_DEFINES=$(C_DEFINES) -DSHIM_HOOKDLL_VERSION2

TARGETPATH=$(_OBJ_DIR)

TARGETLIBS=$(TARGETLIBS)                        \
           $(SDK_LIB_PATH)\user32.lib           \
           $(SDK_LIB_PATH)\gdi32.lib            \
           $(SDK_LIB_PATH)\advapi32.lib         \
           $(SDK_LIB_PATH)\winmm.lib            \
           $(SDK_LIB_PATH)\uuid.lib             \
           $(SDK_LIB_PATH)\ole32.lib            \
           $(SDK_LIB_PATH)\msacm32.lib          \
           $(SDK_LIB_PATH)\version.lib          \
           $(SDK_LIB_PATH)\shell32.lib          \
           $(SDK_LIB_PATH)\shlwapi.lib          \
           $(SDK_LIB_PATH)\userenv.lib          \
           $(PROJECT_ROOT)\appcompat\sdbAPI\lib\$(O)\sdbapil.lib


DLLBASE=0x22000000

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\stackswap_excludes.h ===
#ifndef _EXCLUDES_H_
#define _EXCLUDES_H_

/*++

 This file lists some of the APIs we need to exclude from the stack swapping
 system. It can be modified to include any API that uses no stack, or a that
 otherwise crashes. 

 Note that since the wildcards catch all exports, not just APIs, variable 
 names need to be included in this list.

--*/

struct FNEXCLUDE
{
   char *pszModule;         // Module name
   char *pszFnName;         // Function name
};
 
FNEXCLUDE Excludes[] = 
{
    {"KERNEL32.DLL", "EnterCriticalSection"}, 
    {"KERNEL32.DLL", "LeaveCriticalSection"},
    {"KERNEL32.DLL", "InitializeCriticalSection"},
    {"KERNEL32.DLL", "DeleteCriticalSection"},
    {"KERNEL32.DLL", "HeapAlloc"},
    {"KERNEL32.DLL", "HeapFree"},
    {"KERNEL32.DLL", "HeapReAlloc"},
    {"KERNEL32.DLL", "HeapSize"},
    {"KERNEL32.DLL", "VirtualAlloc"},
    {"KERNEL32.DLL", "VirtualAllocEx"},
    {"KERNEL32.DLL", "VirtualBufferExceptionHandler"},
    {"KERNEL32.DLL", "VirtualFree"},
    {"KERNEL32.DLL", "VirtualFreeEx"},
    {"KERNEL32.DLL", "VirtualLock"},
    {"KERNEL32.DLL", "VirtualProtect"},
    {"KERNEL32.DLL", "VirtualProtectEx"},
    {"KERNEL32.DLL", "VirtualQuery"},
    {"KERNEL32.DLL", "VirtualQueryEx"},
    {"KERNEL32.DLL", "VirtualUnlock"},
    {"KERNEL32.DLL", "WaitForSingleObject"},
    {"KERNEL32.DLL", "WaitForSingleObjectEx"},
    {"KERNEL32.DLL", "WaitForMultipleObjects"},
    {"KERNEL32.DLL", "WaitForMultipleObjectsEx"},
    {"KERNEL32.DLL", "LoadLibraryA"},
    {"KERNEL32.DLL", "LoadLibraryExA"},
    {"KERNEL32.DLL", "LoadLibraryExW"},
    {"KERNEL32.DLL", "LoadLibraryW"},
    {"KERNEL32.DLL", "GetProcessHeap"},
    {"KERNEL32.DLL", "GetProcAddress"},
    {"KERNEL32.DLL", "CreateThread"},
    {"KERNEL32.DLL", "ExitThread"},
    {"KERNEL32.DLL", "TerminateThread"},

    {"USER32.DLL", "PostThreadMessageA"},
    {"USER32.DLL", "PostThreadMessageW"},

    {"GDI32.DLL", "XFORMOBJ_bApplyXform"},
    {"GDI32.DLL", "XFORMOBJ_iGetXform"},
    {"GDI32.DLL", "XLATEOBJ_cGetPalette"},
    {"GDI32.DLL", "XLATEOBJ_hGetColorTransform"},
    {"GDI32.DLL", "XLATEOBJ_iXlate"},
    {"GDI32.DLL", "XLATEOBJ_piVector"},
    {"GDI32.DLL", "STROBJ_bEnum"},
    {"GDI32.DLL", "STROBJ_bEnumPositionsOnly"},
    {"GDI32.DLL", "STROBJ_bGetAdvanceWidths"},
    {"GDI32.DLL", "STROBJ_dwGetCodePage"},
    {"GDI32.DLL", "STROBJ_vEnumStart"},
    {"GDI32.DLL", "PATHOBJ_bEnum"},
    {"GDI32.DLL", "PATHOBJ_bEnumClipLines"},
    {"GDI32.DLL", "PATHOBJ_vEnumStart"},
    {"GDI32.DLL", "PATHOBJ_vEnumStartClipLines"},
    {"GDI32.DLL", "PATHOBJ_vGetBounds"},
    {"GDI32.DLL", "BRUSHOBJ_hGetColorTransform"},
    {"GDI32.DLL", "BRUSHOBJ_pvAllocRbrush"},
    {"GDI32.DLL", "BRUSHOBJ_pvGetRbrush"},
    {"GDI32.DLL", "BRUSHOBJ_ulGetBrushColor"},
    {"GDI32.DLL", "HT_Get8BPPMaskPalette"},
    {"GDI32.DLL", "HT_Get8BPPFormatPalette"},
    {"GDI32.DLL", "cGetTTFFromFOT"},
    {"GDI32.DLL", "bMakePathNameW"},
    {"GDI32.DLL", "bInitSystemAndFontsDirectoriesW"},
    {"GDI32.DLL", "FONTOBJ_vGetInfo"},
    {"GDI32.DLL", "FONTOBJ_pxoGetXform"},
    {"GDI32.DLL", "FONTOBJ_pvTrueTypeFontFile"},
    {"GDI32.DLL", "FONTOBJ_pifi"},
    {"GDI32.DLL", "FONTOBJ_pfdg"},
    {"GDI32.DLL", "FONTOBJ_pQueryGlyphAttrs"},
    {"GDI32.DLL", "FONTOBJ_cGetGlyphs"},
    {"GDI32.DLL", "FONTOBJ_cGetAllGlyphHandles"},
    {"GDI32.DLL", "SetSystemPaletteUse"}    
};

#endif //_EXCLUDES_H_/*++
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\stackswap.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    StackSwap.cpp

 Abstract:

    Some applications make the assumption that Win32 APIs don't use any stack 
    space. This stems from the architecture of win9x - whereby many APIs 
    thunked and therefore had there own stack.

    Of course on NT this isn't the case and many APIs are normal user mode 
    functions that don't even call down to kernel. To make matters worse, some
    applications depend on *no* stack usage in a number of other ways, for 
    example:

        1. Sierra Cart racing keeps a pointer in old stack
        2. Baldur's Gate *double* dereferences pointers in old stack
        3. NFL Blitz keeps it's linked lists on the stack and so simply calling 
           an API causes corruption 
        4. NFL Blitz 2000 runs out of stack space calling CreateFile
        5. Interplay EReg has uninitialized variables on the stack which are 
           normally zeroed on win9x

    This shim is parameterized and takes a list of APIs and the behavior of 
    each. Behavior is defined as the following:

          - No stack is used by this API
        0 - After API is called, old stack will be filled with zeroes
        1 - After API is called, old stack will be filled with valid pointers
        2 - After API is called, old stack will be filled with valid pointers 
            to pointers

    The default is that no stack space is used by the API.

 Notes:

    This is a general purpose shim.

 History:

    05/03/2000  linstev     Created
    03/12/2001  robkenny    Blessed for DBCS

--*/

#include "precomp.h"

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(StackSwap)
#include "ShimHookMacro.h"
#include "ShimStack.h"
#include "StackSwap_Exports.h"
#include "StackSwap_Excludes.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateThread) 
    APIHOOK_ENUM_ENTRY(TerminateThread) 
    APIHOOK_ENUM_ENTRY(ExitThread) 
APIHOOK_ENUM_END


#define THREAD_VAR       Vdm        // The TEB variable to overwrite

#define STUB_SIZE        64         // size of stub code in bytes
#define STACK_SIZE       65536      // size of temporary stack
#define STACK_COPY_SIZE  16         // number of dwords to copy from old stack
#define STACK_FILL_SIZE  256        // default number of dwords to fill
#define STACK_GUARD_SIZE 4096       // gaurd page at the top of the stack - must be a multiple of 4096

#define STACK_FILL_NONE -1          // no old stack filling
#define STACK_FILL_ZERO  0          // fill old stack with zeroes
#define STACK_FILL_PTR1  1          // fill old stack with pointers
#define STACK_FILL_PTR2  2          // fill old stack with pointers to pointers

PVOID g_dwZero = 0;                 // used for pointer to zero
PVOID g_dwPtr = &g_dwPtr;           // used for pointer to pointer

PVOID g_arrFill[] = 
{
    0, 
    &g_dwZero,
    &g_dwPtr 
};

// Store for each hook returned by the parser

struct HOOK
{
    char szModule[MAX_PATH];        // Module name
    char szFnName[MAX_PATH];        // Function name
    PVOID pfnNew;                   // Pointer to stub
    DWORD dwFill;                   // Stack fill type
    DWORD dwFillSize;               // Number of dwords to fill
    struct HOOK *next;              
};
HOOK *g_pHooks = NULL;

HOOK g_AllHooks[] =
{
    {"KERNEL32.DLL", "*", NULL, STACK_FILL_NONE},
    {"GDI32.DLL",    "*", NULL, STACK_FILL_NONE},
    {"USER32.DLL",   "*", NULL, STACK_FILL_NONE},
    {"WINMM.DLL",    "*", NULL, STACK_FILL_NONE}
};

DWORD dwStubCount = 0;

// Thread local data

typedef struct _THREAD_DATA
{
    PVOID pfnHook;                  // Address of actual call
    PVOID pNewStack;                // The new stack
    PVOID pOldStack;                // The old stack
    DWORD dwFill;                   // Fill method
    DWORD dwFillSize;               // Number of dwords to fill
    ULONG ulCount;                  // Number of times we've entered 
    DWORD dwRet;                    // Return value 
    DWORD dwEcx, dwEsi, dwEdi;      // Tempory storage, since we don't have a stack
} THREAD_DATA;

/*++

 This function is called from the stubs. It's purpose is to give the API a new 
 stack to use. It does this by doing the following:

    1. Copy the original stack to the new stack
    2. Call the original hook
    3. Copy the changed stack back to the original stack
    4. Return control to the original caller

 The only tricky things about this routine are that we don't want to use any 
 stack at all (no push/pop) and we need to calculate how much stack was used
 for the parameters - something we don't know because we don't have the proto-
 type. 
 
 If we really wanted to use push and pop, we could have set up a temporary 
 stack, but since we only need ecx, esi and edi, there didn't seem to be any 
 point.

--*/

__declspec(naked)
void 
SwapStack()
{
    __asm {
        inc  [eax + THREAD_DATA.ulCount]            // increment counter

        mov  [eax + THREAD_DATA.dwEcx], ecx         // backup ecx
        mov  [eax + THREAD_DATA.dwEsi], esi         // backup esi
        mov  [eax + THREAD_DATA.dwEdi], edi         // backup edi

        mov  ecx, [esp]                             // retrieve 'Hook' from Stub()
        mov  [eax + THREAD_DATA.pfnHook], ecx       // which we got from the call
        add  esp, 4                                 // move the stack up to the return address

        mov  dword ptr [esp], offset SwapBack       // fill in our new return address

        lea  edi, [esp + 4]                         // dst = new stack
        mov  esi, [eax + THREAD_DATA.pOldStack]     // src = old stack
        add  esi, 4                                 // note the +4s since the first dword is the return address

        cld                                         // clear direction flag
        mov  ecx, STACK_COPY_SIZE - 1               // copy off STACK_COPY_SIZE - 1 bytes
        rep  movsd                                  // do the copy

        mov  ecx, [eax + THREAD_DATA.dwEcx]         // restore ecx
        mov  esi, [eax + THREAD_DATA.dwEsi]         // restore esi
        mov  edi, [eax + THREAD_DATA.dwEdi]         // restore edi

        jmp  [eax + THREAD_DATA.pfnHook]            // jump back into the stub to do the actual

    SwapBack:

        mov  [esp - 4], eax                         // unfortunately this is the only way to store the return 

        mov  eax, fs:[0x18]                         // get the TEB
        mov  eax, [eax + TEB.THREAD_VAR]            // get our thread local pointer

        mov  [eax + THREAD_DATA.dwEcx], ecx         // backup ecx
        mov  [eax + THREAD_DATA.dwEsi], esi         // backup esi
        mov  [eax + THREAD_DATA.dwEdi], edi         // backup edi

        mov  ecx, [esp - 4]                         // get return value
        mov  [eax + THREAD_DATA.dwRet], ecx         // store return value for later

        mov  ecx, esp                               // this is where we find out how many parameters were passed
        sub  ecx, [eax + THREAD_DATA.pNewStack]     // on the stack - so we get the difference in ecx

        mov  edi, [eax + THREAD_DATA.pOldStack]     // original stack
        mov  esi, [edi]                             // read the real return address
        add  edi, ecx                               // move the stack up, so we don't copy unnecessay stack
        mov  [edi - 4], esi                         // put the return address into edi-4: this is the only time we
                                                    //  use app stack space at all
        mov  esp, edi

        mov  ecx, [eax + THREAD_DATA.dwFill]        // test how we're going to fill 
        cmp  ecx, STACK_FILL_NONE
        jz   FillDone

        mov  esi, [ecx*4 + g_arrFill]               // value to fill with

        lea  edi, [esp - 8]                         // we're going to fill backwards, so esp-8 will skip the return address
        mov  ecx, [eax + THREAD_DATA.dwFillSize]    // number of dwords to fill with

    FillStack:
        mov  [edi], esi                             // store the value
        sub  edi, 4                                 
        dec  ecx
        jnz  FillStack

    FillDone:

        mov  ecx, [eax + THREAD_DATA.dwEcx]         // restore ecx
        mov  esi, [eax + THREAD_DATA.dwEsi]         // restore esi
        mov  edi, [eax + THREAD_DATA.dwEdi]         // restore edi
        
        dec  [eax + THREAD_DATA.ulCount]            // decrement counter

        mov  eax, [eax + THREAD_DATA.dwRet]         // get the return value
        jmp  dword ptr [esp - 4]                    // return to original caller
    }
}

//
// We need the stub to do a far call to SwapStack since the stub will move, but
// I can't seem to force the far call without this method
//

DWORD_PTR g_pfnStackSwap = (DWORD_PTR)SwapStack;

/*++

  This is the stub function that is called by every API. It is copied from here 
  to blocks of executable memory and the calls and fill types are written to 
  hard coded addresses within it.

  The instuctions:

    mov  [eax + THREAD_DATA.dwFill], 0xFFFFFFFF     is replaced by
    mov  [eax + THREAD_DATA.dwFill], FILL_TYPE
    mov  [eax + THREAD_DATA.dwFillSize], 0xFFFFFFFF is replaced by
    mov  [eax + THREAD_DATA.dwFill], FILL_SIZE

  and 
  
    call g_pfnStackSwap                             is replaced by 
    call g_pAPIHooks[api].pfnOld

--*/

__declspec(naked)
void 
Stub()
{
    __asm {
        mov  eax, fs:[0x18]                         // get the TEB
        mov  eax, [eax + TEB.THREAD_VAR]            // get our thread local pointer
  
        or   eax, eax                               // our pointer is gone
        jz   Hook                                   // exit gracefully

        cmp  [eax + THREAD_DATA.ulCount], 0         // have we already swapped the stack
        jnz  Hook

        mov  [eax + THREAD_DATA.dwFill], 0xFFFFFFFF // the 0xFFFFFFFF will be replaced by the fill type
        mov  [eax + THREAD_DATA.dwFillSize], 0xFFFFFFFF // the 0xFFFFFFFF will be replaced by the fill size
        mov  [eax + THREAD_DATA.pOldStack], esp     // backup the old stack
        mov  esp, [eax + THREAD_DATA.pNewStack]     // swap the stack
        call g_pfnStackSwap                         // call into the stack swapping code
        
    Hook:
        jmp  [g_pHooks]                             // jump to the hook
    }
}

/*++

 Create a new stack

--*/

THREAD_DATA *
AllocStack()
{
    LPVOID p = VirtualAlloc(
        0, 
        sizeof(THREAD_DATA) + STACK_SIZE + STACK_GUARD_SIZE, 
        MEM_COMMIT, 
        PAGE_READWRITE);

    if (p)
    {
        DWORD dwOld;
        if (!VirtualProtect(p, STACK_GUARD_SIZE, PAGE_READONLY | PAGE_GUARD, &dwOld))
        {
            DPFN( eDbgLevelError, "Failed to place Gaurd page at the top of the stack");
        }

        THREAD_DATA *pTD = (THREAD_DATA *)((DWORD_PTR)p + STACK_SIZE + STACK_GUARD_SIZE);

        pTD->pNewStack = (LPVOID)((DWORD_PTR)pTD - STACK_COPY_SIZE * 4);

        return pTD;
    }
    else
    {
        DPFN( eDbgLevelError, "Failed to allocate new stack");
        return NULL;
    }
}

/*++

 Free the stack

--*/

BOOL
FreeStack(THREAD_DATA *pTD)
{
    BOOL bRet = FALSE;
    
    if (pTD)
    {
        LPVOID p = (LPVOID)((DWORD_PTR)pTD - STACK_SIZE - STACK_GUARD_SIZE);
        bRet = VirtualFree(p, 0, MEM_RELEASE);
    }

    if (!bRet)
    {
        DPFN( eDbgLevelError, "Failed to free a stack");
    }
    
    return bRet;
}

/*++

 Hook CreateThread so we can add our stuff to the TEB.

--*/

HANDLE 
APIHOOK(CreateThread)(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,  
    DWORD dwStackSize,                         
    LPTHREAD_START_ROUTINE lpStartAddress,     
    LPVOID lpParameter,                        
    DWORD dwCreationFlags,                     
    LPDWORD lpThreadId                         
    )
{
    HANDLE hRet;
    DWORD dwFlags = dwCreationFlags;

    NEW_STACK();

    hRet = ORIGINAL_API(CreateThread)(
        lpThreadAttributes,
        dwStackSize,
        lpStartAddress,
        lpParameter,
        dwCreationFlags | CREATE_SUSPENDED,
        lpThreadId);

    if (hRet)
    {
        THREAD_BASIC_INFORMATION tbi;
        NTSTATUS Status;

        Status = NtQueryInformationThread(
            hRet,
            ThreadBasicInformation,
            &tbi,
            sizeof(tbi),
            NULL);

        if ((NT_SUCCESS(Status)) && (tbi.TebBaseAddress))
        {
            tbi.TebBaseAddress->THREAD_VAR = AllocStack();
        }

        if (!(dwFlags & CREATE_SUSPENDED))
        {
            ResumeThread(hRet);
        }
    }

    OLD_STACK();

    return hRet;
}

/*++

 Hook TerminateThread so we can clean up the thread local data.

--*/

BOOL 
APIHOOK(TerminateThread)(
    HANDLE hThread,    
    DWORD dwExitCode   
    )
{
    THREAD_BASIC_INFORMATION tbi;
    NTSTATUS Status;
    BOOL bRet;
    THREAD_DATA *pTD = NULL;
    
    Status = NtQueryInformationThread(
        hThread,
        ThreadBasicInformation,
        &tbi,
        sizeof(tbi),
        NULL);

    if ((NT_SUCCESS(Status)) && (tbi.TebBaseAddress))
    {
       pTD = (THREAD_DATA *)(tbi.TebBaseAddress->THREAD_VAR);
    }

    bRet = ORIGINAL_API(TerminateThread)(hThread, dwExitCode);
    
    FreeStack(pTD);

    return bRet;
}

/*++

 Hook ExitThread so we can clean up the thread local data.

--*/

VOID 
APIHOOK(ExitThread)(
    DWORD dwExitCode   
    )
{
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION tbi;
    HANDLE hThread = GetCurrentThread();
    
    Status = NtQueryInformationThread(
        hThread,
        ThreadBasicInformation,
        &tbi,
        sizeof(tbi),
        NULL);
    
    if ((NT_SUCCESS(Status)) && (tbi.TebBaseAddress))
    {
        THREAD_DATA *pTD = (THREAD_DATA *)tbi.TebBaseAddress->THREAD_VAR;
        
        // Make sure we don't free it if we're using it
        if (pTD && (pTD->ulCount == 0))
        {
            FreeStack(pTD);
        }
    }

    ORIGINAL_API(ExitThread)(dwExitCode);
}

/*++

  Add the specified hook to the linked list - this accepts wildcards.

--*/

VOID 
AddHooks(HOOK *pHook)
{
    if (strstr(pHook->szFnName, "*") == 0)
    {
        // Now that we have a hook (not a wild card), we need to make sure it's
        // ok to add it to the list. There are some calls that cannot be shimmed

        for (int i=0; i<sizeof(Excludes)/sizeof(FNEXCLUDE); i++)
        {
            if ((_stricmp(pHook->szModule, (LPSTR)Excludes[i].pszModule) == 0) &&
                (strcmp(pHook->szFnName, (LPSTR)Excludes[i].pszFnName) == 0))
            {
                DPFN( eDbgLevelInfo,"Ignoring %s!%s", Excludes[i].pszModule, Excludes[i].pszFnName);
                return;
            }
        }
        
        // The hook passes, so add it to the list.

        HOOK *pH = (HOOK *) malloc(sizeof(HOOK));
        if (pH)
        {
            MoveMemory(pH, pHook, sizeof(HOOK));
            pH->next = g_pHooks;
            g_pHooks = pH;
        }
        return;
    }

    // Here we have to look through the exports
    LOADED_IMAGE image;
    
    if (!LoadModule(pHook->szModule, &image))
    {
        DPFN( eDbgLevelError, "Module %s not found", pHook->szModule);
        return;
    }

    EXPORT_ENUM exports;
    CHAR szFnName[MAX_PATH];

    strcpy(szFnName, pHook->szFnName);

    DWORD dwLen = (DWORD)((DWORD_PTR)strstr(pHook->szFnName, "*") - (DWORD_PTR)&pHook->szFnName);

    // Enumerate the exports for this module

    BOOL bMore = EnumFirstExport(&image, &exports);
    while (bMore)
    {
        if ((dwLen == 0) ||
            (strncmp(exports.ExportFunction, szFnName, dwLen) == 0))
        {
            // We have a match
            strcpy(pHook->szFnName, exports.ExportFunction);
            AddHooks(pHook);
        }
    
        bMore = EnumNextExport(&exports);
    }
        
    // Done with this module
    UnloadModule(&image);
}

/*++

 Parse the command line for APIs to fix stack problems with:

    USER32.DLL!GetDC:0; KERNEL32.DLL!CreateFile*

 The :X is to define behaviour - so:
    
    :0 fill old stack with zeroes
    :1 fill old stack with pointers
    :2 fill old stack with pointers to pointers

--*/

DWORD
ParseCommandLineA(
    LPCSTR lpCommandLine
    )
{
    char seps[] = " :,\t;!";
    char *token = NULL;
    HOOK *pHook = NULL;
    DWORD dwState = 0;
    HOOK hook;

    // Since strtok modifies the string, we need to copy it 
    LPSTR szCommandLine = (LPSTR) malloc(strlen(lpCommandLine) + 1);
    if (!szCommandLine) goto Exit;

    strcpy(szCommandLine, lpCommandLine);

    //
    // See if we need to do all modules
    //
    
    if ((strcmp(szCommandLine, "") == 0) || (strcmp(szCommandLine, "*") == 0))
    {
        for (int i=0; i<sizeof(g_AllHooks)/sizeof(HOOK); i++)
        {
            AddHooks(&g_AllHooks[i]);
        }
        goto Exit;
    }

    //
    // Run the string, looking for exception names
    //

    token = _strtok(szCommandLine, seps);
   
    while (token)
    {
        switch (dwState)
        {
        case 2:     // handle the :X[(fill size)] case
            dwState = 0;

            if (token[0] && ((token[1] == '\0') || (token[1] == '(')))
            {
                switch (token[0])
                {
                case '0': 
                    hook.dwFill = STACK_FILL_ZERO;
                    break;
                case '1':
                    hook.dwFill = STACK_FILL_PTR1;
                    break;
                case '2':
                    hook.dwFill = STACK_FILL_PTR2;
                    break;
                default:
                    hook.dwFill = STACK_FILL_ZERO;
                }

                if (token[1] == '(')
                {
                    token+=2;      // advance to the beginning of the fill size
                    token[strlen(token)-1] = '\0';       // null terminate
                    hook.dwFillSize = atol(token) >> 2;  // get fill size in dwords
                    if (hook.dwFillSize == 0)
                    {
                        hook.dwFillSize = STACK_FILL_SIZE;
                    }
                }

                // We must be done, so add this hook
                AddHooks(&hook);

                break;
            }

            AddHooks(&hook);

        case 0:     // add a new API module name
            ZeroMemory(&hook, sizeof(HOOK));
            strcpy(hook.szModule, token);
            hook.dwFill = STACK_FILL_NONE;
            hook.dwFillSize = STACK_FILL_SIZE;
            dwState++;

            break;
    
        case 1:     // add a new API function name
            dwState++;
            
            if (strlen(hook.szModule) == 0)
            {
                DPFN( eDbgLevelError, "Parse error with token %s", token);
                goto Exit;
            }

            strcpy(hook.szFnName, token);
            break;
        }

        // Get the next token
        token = _strtok(NULL, seps);
    }

    if (dwState == 2)
    {
        AddHooks(&hook);
    }

Exit:
    if (szCommandLine)
    {
        free(szCommandLine);
    }

    if (!g_pHooks)
    {
        DPFN( eDbgLevelError, "No hooks added");
        return 0;
    }

    //
    // Dump results of command line parse
    //

    DPFN( eDbgLevelInfo, "--------------------------------------------");
    DPFN( eDbgLevelInfo, "     Stack Swapping the following APIs:     ");
    DPFN( eDbgLevelInfo, "--------------------------------------------");
    
    DWORD dwCount = 0;
    pHook = g_pHooks;
    while (pHook)
    {
        DPFN( eDbgLevelInfo, "%s!%s: Fill=%d, Size=%d", pHook->szModule, pHook->szFnName, pHook->dwFill, pHook->dwFillSize*4);
        dwCount++;
        pHook = pHook->next;
    }
    DPFN( eDbgLevelInfo, "--------------------------------------------");

    return dwCount;
}

/*++

 Builds the stubs for the hooked APIs 

--*/

DWORD 
BuildStubs()
{
    // Count the stubs
    DWORD dwCount = 0;
    HOOK *pHook = g_pHooks;
    while (pHook)
    {
        dwCount++;
        pHook = pHook->next;
    }

    // Create the stubs
    LPBYTE pStub = (LPBYTE) VirtualAlloc(
        0, 
        STUB_SIZE * dwCount, 
        MEM_COMMIT, 
        PAGE_EXECUTE_READWRITE);

    if (!pStub)
    {
        DPFN( eDbgLevelError, "Could not allocate memory for stubs");
        return 0;
    }

    pHook = g_pHooks;
    PHOOKAPI pAPIHook = &g_pAPIHooks[APIHOOK_Count];
    while (pHook)
    {
        MoveMemory(pStub, Stub, STUB_SIZE);
        
        LPDWORD p;
        
        p = (LPDWORD)((DWORD_PTR)pStub + 0x19); // fill in the fill type
        *p = pHook->dwFill;

        p = (LPDWORD)((DWORD_PTR)pStub + 0x19+7); // fill in the fill size
        *p = pHook->dwFillSize;
        
        p = (LPDWORD)((DWORD_PTR)pStub + 0x2b+7); // fill in the hook
        *p = (DWORD_PTR)&pAPIHook->pfnOld;
        
        ZeroMemory(pAPIHook, sizeof(HOOKAPI));
        pAPIHook->pszModule = pHook->szModule;
        pAPIHook->pszFunctionName = pHook->szFnName;
        pAPIHook->pfnNew = pStub;
        
        DPFN( eDbgLevelSpew, "%08lx %s!%s", pStub, pHook->szModule, pHook->szFnName);

        pStub += STUB_SIZE;
        pAPIHook++;
        pHook = pHook->next;
    }

    return dwCount;
}

/*++

 Free the stub list allocated by ParseCommandLineA

--*/

VOID
FreeStubs()
{
    HOOK *pHook = g_pHooks;
    
    while (pHook)
    {
        pHook = pHook->next;
        free(g_pHooks);
        g_pHooks = pHook;
    }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        // Run the command line to check for hooks - returns number found
        dwStubCount = ParseCommandLineA(COMMAND_LINE);

        if (dwStubCount)
        {
            //
            // Increase the hook structure size.
            //

            g_pAPIHooks = (PHOOKAPI) realloc(g_pAPIHooks, 
                sizeof(HOOKAPI) * (APIHOOK_Count + dwStubCount));

            if (!g_pAPIHooks)
            {
                DPFN( eDbgLevelError, "Failed to re-allocate hooks"); 
                return FALSE;
            }
        }

        INIT_STACK(1024 * 128, 32);
        
        NtCurrentTeb()->THREAD_VAR = AllocStack();

        BuildStubs();
    }
    else if (fdwReason == DLL_PROCESS_DETACH) 
    {
        // Ignore cleanup
        // FreeStubs();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, CreateThread)
    APIHOOK_ENTRY(KERNEL32.DLL, TerminateThread)
    APIHOOK_ENTRY(KERNEL32.DLL, ExitThread)

    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        // Write out the new size
        *pdwHookCount = APIHOOK_Count + dwStubCount;
    }

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\restoresystemcursors.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    RestoreSystemCursors.cpp

 Abstract:

    Due to a bug in NT, cursors are not correctly restored with the following
    code sequence:

        1. hNewCursor = LoadCursor(0, "cursor.cur");
        2. SetSystemCursor(hNewCursor, OCR_NORMAL)
        3. hOldCursor = LoadCursor(0,MAKEINTRESOURCE(OCR_NORMAL));
        4. SetSystemCursor(hOldCursor, OCR_NORMAL)

    The last call (4) does nothing on NT, but works correctly on Win9x. 
    
    To fix this we use the known USER workaround, namely CopyCursor. Note that 
    this will probably be fixed in Whistler by the time it ships.
    
 Notes:

    This is a general purpose shim.

 History:

    02/13/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RestoreSystemCursors)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineA) 
    APIHOOK_ENUM_ENTRY(GetCommandLineW) 
APIHOOK_ENUM_END

#define OCR_NORMAL          32512UL
#define OCR_IBEAM           32513UL
#define OCR_WAIT            32514UL
#define OCR_CROSS           32515UL
#define OCR_UP              32516UL
#define OCR_SIZE            32640UL   
#define OCR_ICON            32641UL   
#define OCR_SIZENWSE        32642UL
#define OCR_SIZENESW        32643UL
#define OCR_SIZEWE          32644UL
#define OCR_SIZENS          32645UL
#define OCR_SIZEALL         32646UL
#define OCR_ICOCUR          32647UL   
#define OCR_NO              32648UL
#define OCR_HAND            32649UL
#define OCR_APPSTARTING     32650UL

struct CURSOR 
{
    DWORD id;
    HCURSOR hCursor;
};

CURSOR g_arrCursors[] = 
{
    {OCR_NORMAL,        0},
    {OCR_IBEAM,         0},
    {OCR_WAIT,          0},
    {OCR_CROSS,         0},
    {OCR_UP,            0},
    {OCR_SIZE,          0},
    {OCR_ICON,          0},
    {OCR_SIZENWSE,      0},
    {OCR_SIZENESW,      0},
    {OCR_SIZEWE,        0},
    {OCR_SIZENS,        0},
    {OCR_SIZEALL,       0},
    {OCR_ICOCUR,        0},
    {OCR_NO,            0},
    {OCR_HAND,          0},
    {OCR_APPSTARTING,   0}
};

BOOL g_bInit = FALSE;

/*++

 Backup cursors.

--*/

VOID 
BackupCursors()
{
    if (!g_bInit) 
    {
        g_bInit = TRUE;

        // Backup all the cursors
        for (int i=0; i<sizeof(g_arrCursors)/sizeof(CURSOR);i++)
        {
            HCURSOR hCursorT = LoadCursor(0,MAKEINTRESOURCE(g_arrCursors[i].id));
            
            if (hCursorT)
            {
                g_arrCursors[i].hCursor = CopyCursor(hCursorT);
                DestroyCursor(hCursorT);
            }
            else
            {
                g_arrCursors[i].hCursor = 0;
            }
        }
    }
}

/*++

 Restore cursors.

--*/

VOID
RestoreCursors()
{
    if (g_bInit) 
    {
        // Restore all the cursors
        for (int i=0; i<sizeof(g_arrCursors)/sizeof(CURSOR);i++)
        {
            if (g_arrCursors[i].hCursor)
            {
                SetSystemCursor(g_arrCursors[i].hCursor, g_arrCursors[i].id);
                DestroyCursor(g_arrCursors[i].hCursor);
            }
        }
    }
}

/*++

 Backup cursors.

--*/

LPSTR 
APIHOOK(GetCommandLineA)()
{
    BackupCursors();
    return ORIGINAL_API(GetCommandLineA)();
}

/*++

 Backup cursors.

--*/

LPWSTR 
APIHOOK(GetCommandLineW)()
{
    BackupCursors();
    return ORIGINAL_API(GetCommandLineW)();
}
 
/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_DETACH) {
        RestoreCursors();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\terminateexe.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:
    
    TerminateExe.cpp

 Abstract:

    This shim terminates an exe on startup. (Die Die DIE!!!)

 Notes:

    This is a general purpose shim.

 History:

    05/01/2001 mnikkel      Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(TerminateExe)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DPFN( eDbgLevelSpew, "Terminating Exe.\n");
            ExitProcess(0);
            break;

        default:
            break;
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\trimversioninfo.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    TrimVersionInfo.cpp

 Abstract:

    This shim trims the blanks off of the end the version info string.

 Notes:

    This is a general shim.

 History:
 
  08/01/2001 mnikkel, astritz   Created
  
 --*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(TrimVersionInfo)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(VerQueryValueA)
APIHOOK_ENUM_END

/*++

 Return the product version with blanks trimmed from end.
  
--*/

BOOL 
APIHOOK(VerQueryValueA)(
    const LPVOID pBlock, 
    LPSTR lpSubBlock, 
    LPVOID *lplpBuffer, 
    PUINT puLen 
    )
{
    UINT nLen;

    BOOL bRet = ORIGINAL_API(VerQueryValueA)( 
           pBlock, 
           lpSubBlock, 
           lplpBuffer, 
           puLen);

    if (bRet)
    {                
        CSTRING_TRY
        {
            CString csSubBlock(lpSubBlock);
            
            if (csSubBlock.Find(L"ProductVersion") != -1 ||
                csSubBlock.Find(L"FileVersion") != -1)
            {
                int nLoc = 0;
                   
                DPFN(eDbgLevelError, "[VerQueryValueA] Asking for Product or File Version, trimming blanks");
                DPFN(eDbgLevelSpew, "[VerQueryValueA] Version info is <%s>", *lplpBuffer);
                
                CString csBuffer((char *)*lplpBuffer); 
                
                //
                // Search for first blank
                //
                nLoc = csBuffer.Find(L" ");
                if (nLoc != -1)
                {
                    // if a blank is found then truncate string to that point
                    csBuffer.Truncate(nLoc);
                    csBuffer.CopyAnsiChars((char *)*lplpBuffer, nLoc+1);
                    if (puLen)
                    {
                        *puLen = nLoc;                        
                        DPFN(eDbgLevelSpew, "[VerQueryValueA] Version info Length = %d.", *puLen);
                    }
                }
                
                DPFN(eDbgLevelSpew, "[VerQueryValueA] Version info after trim is <%s>.", *lplpBuffer);
            }
        }
    	CSTRING_CATCH
    	{
            /* do nothing */
    	}        
    }

    return bRet;
}

/*++

 Register hooked functions
 
--*/

HOOK_BEGIN
    APIHOOK_ENTRY(VERSION.DLL, VerQueryValueA)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\waveoutusepreferreddevice.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WaveOutUsePreferredDevice.cpp

 Abstract:

    Force the use of the preferred waveOut device (rather than a specific device)

 Notes:
    
    This is a general purpose shim.

 History:

    06/02/1999 robkenny Created

--*/


#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WaveOutUsePreferredDevice)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(waveOutOpen) 
    APIHOOK_ENUM_ENTRY(waveOutGetDevCapsA) 
    APIHOOK_ENUM_ENTRY(waveOutGetDevCapsW) 
    APIHOOK_ENUM_ENTRY(wod32Message) 
APIHOOK_ENUM_END

/*+

  Call waveOutOpen, saving dwCallback if it is a function.

--*/
MMRESULT APIHOOK(waveOutOpen)(
  LPHWAVEOUT phwo,
  UINT uDeviceID,
  LPWAVEFORMATEX pwfx,
  DWORD dwCallback,
  DWORD dwCallbackInstance,
  DWORD fdwOpen
)
{
    MMRESULT returnValue = ORIGINAL_API(waveOutOpen)(phwo, WAVE_MAPPER, pwfx, dwCallback, dwCallbackInstance, fdwOpen);
    return returnValue;
}

MMRESULT APIHOOK(waveOutGetDevCapsA)(
    UINT uDeviceID,
    LPWAVEOUTCAPSA pwoc,
    UINT cbwoc)
{
    MMRESULT returnValue = ORIGINAL_API(waveOutGetDevCapsA)(WAVE_MAPPER, pwoc, cbwoc);
    return returnValue;
}

MMRESULT APIHOOK(waveOutGetDevCapsW)(
    UINT uDeviceID,
    LPWAVEOUTCAPSW pwoc,
    UINT cbwoc)
{
    MMRESULT returnValue = ORIGINAL_API(waveOutGetDevCapsW)(WAVE_MAPPER, pwoc, cbwoc);
    return returnValue;
}

/*+

  Catch the 16 bit applications, WOW calls this routine for 16 bit apps.

--*/

#define WODM_GETDEVCAPS         4
#define WODM_OPEN               5

DWORD APIHOOK(wod32Message)(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
    // Change device 0 to WAVE_MAPPER for Open and GetDevCaps
    if (uDeviceID == 0) {
        if (uMessage == WODM_OPEN ||
            uMessage == WODM_GETDEVCAPS) {
            uDeviceID = -1; // Force device to WAVE_MAPPER
        }
    }

    MMRESULT returnValue = ORIGINAL_API(wod32Message)(uDeviceID, uMessage, dwInstance, dwParam1, dwParam2);
    return returnValue;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(WINMM.DLL, waveOutOpen)
    APIHOOK_ENTRY(WINMM.DLL, waveOutGetDevCapsA)
    APIHOOK_ENTRY(WINMM.DLL, waveOutGetDevCapsW)
    APIHOOK_ENTRY(WINMM.DLL, wod32Message)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\wing32systosys32.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WinG32SysToSys32.cpp

 Abstract:
    
    During its dllmain WinG32 checks its install location. It does this by parsing the path returned from
    GetModuleFileName. If it finds that it was installed in the system directory, it will post a message box
    and fail. This is fixed by checking and tweaking the string returned from the API call.
        
 History:

    03/21/2001  alexsm  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WinG32SysToSys32)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
   APIHOOK_ENUM_ENTRY(GetModuleFileNameA)
APIHOOK_ENUM_END


DWORD
APIHOOK(GetModuleFileNameA)(HMODULE hModule, LPSTR lpFileName, DWORD nSize)
{
    DWORD nReturn = 0;
    int nFound = -1;
    char * lpNewFileName = NULL;
    WCHAR * lpSystemCheck = L"SYSTEM\\WING32.DLL";
    WCHAR * lpWinG32 = L"WING32.dll";
    CString csOldFileName;
    CString csNewFileName;
    
    nReturn = ORIGINAL_API(GetModuleFileNameA)(hModule, lpFileName, nSize);

    // Check the string. If the string is not pointing to system32, we need to redirect.
    CSTRING_TRY
    {
        csOldFileName = lpFileName;
        csOldFileName.MakeUpper();
        nFound = csOldFileName.Find(lpSystemCheck);
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    if(nFound >= 0)
    {
        DPFN(
            eDbgLevelInfo,
            "[WinG32SysToSys32] Changing system\\wing32.dll to system32\\wing32.dll");

        CSTRING_TRY
        {
            csNewFileName.GetSystemDirectoryW();
            csNewFileName.AppendPath(lpWinG32);
            lpNewFileName = csNewFileName.GetAnsiNIE();
            if(lpNewFileName)
            {
                nReturn = csNewFileName.GetLength();
                memcpy(lpFileName, lpNewFileName, sizeof(char) * (nReturn + 1));
            }
        }
        CSTRING_CATCH
        {
            DPFN(
                eDbgLevelInfo,
                "[WinG32SysToSys32] Error parsing new string");
        }
    }

    return nReturn;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetModuleFileNameA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\stackswap_exports.h ===
#ifndef _EXPORTS_H_
#define _EXPORTS_H_

typedef struct _LOADED_IMAGE 
{
    PSTR                  ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
    PIMAGE_NT_HEADERS32   FileHeader;
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
} LOADED_IMAGE, *PLOADED_IMAGE;

typedef struct _EXPORT_ENUM 
{
    /*user area - BEGIN*/
    PCSTR    ExportFunction;
    DWORD    ExportFunctionOrd;
    /*user area - END*/

    PLOADED_IMAGE Image;
    PIMAGE_EXPORT_DIRECTORY ImageDescriptor;
    PDWORD ExportNamesAddr;
    PUSHORT ExportOrdAddr;
    DWORD CurrExportNr;
} EXPORT_ENUM, *PEXPORT_ENUM;

BOOL LoadModule(PCSTR ModuleName, PLOADED_IMAGE ModuleImage);
BOOL UnloadModule(PLOADED_IMAGE ModuleImage);
BOOL EnumFirstExport(PLOADED_IMAGE ModuleImage, PEXPORT_ENUM ModuleExports);
BOOL EnumNextExport(PEXPORT_ENUM ModuleExports);

#endif //_EXPORTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\stackswap_exports.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    Exports.cpp

 Abstract:

    Helper functions for enumerating module exports.
    
 Notes:

    Although only used by the stack swapping shim, it may later be included in
    the library, since it's general.

    Most of these routines are copied out of the source for imagehlp.dll. We 
    are not including this dll since it doesn't work in the Win2K shim layer.

 History:

    05/10/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(StackSwap)
#include "StackSwap_Exports.h"

// User APIs
BOOL LoadModule(PCSTR lpName, PLOADED_IMAGE lpImage);
BOOL UnloadModule(PLOADED_IMAGE lpImage);
BOOL EnumFirstExport(PLOADED_IMAGE lpImage, PEXPORT_ENUM lpExports);
BOOL EnumNextExport(PEXPORT_ENUM lpExports);

// Internal APIs
BOOL CalculateImagePtrs(PLOADED_IMAGE lpImage);
PIMAGE_SECTION_HEADER ImageRvaToSection(PIMAGE_NT_HEADERS NtHeaders, PVOID Base, ULONG Rva);
PVOID ImageRvaToVa(PIMAGE_NT_HEADERS NtHeaders, PVOID Base, ULONG Rva, PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL);
PVOID ImageDirectoryEntryToData32(PVOID Base, BOOLEAN MappedAsImage, USHORT DirectoryEntry, PULONG Size, PIMAGE_SECTION_HEADER *FoundSection OPTIONAL, PIMAGE_FILE_HEADER FileHeader, PIMAGE_OPTIONAL_HEADER32 OptionalHeader);
PVOID ImageDirectoryEntryToData(PVOID Base, BOOLEAN MappedAsImage, USHORT DirectoryEntry, PULONG Size);

/*++

 Open a file handle to a module and map it's image.

--*/

BOOL
LoadModule(
    PCSTR lpName,
    PLOADED_IMAGE lpImage
    )
{
    HANDLE hFile;
    CHAR szSearchBuffer[MAX_PATH];
    DWORD dwLen;
    LPSTR lpFilePart;
    LPSTR lpOpenName;
    BOOL bRet = FALSE;
    
    ZeroMemory(lpImage, sizeof(LOADED_IMAGE));

    lpOpenName = (PSTR)lpName;
    dwLen = 0;

Retry:
    hFile = CreateFileA(
                lpOpenName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL);

    if (hFile == INVALID_HANDLE_VALUE) 
    {
        if (!dwLen) 
        {
            //
            // open failed try to find the file on the search path
            //

            dwLen = SearchPathA(
                NULL,
                lpName,
                ".DLL",
                MAX_PATH,
                szSearchBuffer,
                &lpFilePart
                );

            if (dwLen && dwLen < MAX_PATH) 
            {
                lpOpenName = szSearchBuffer;
                goto Retry;
            }
        }

        goto Exit;
    }

    HANDLE hFileMap;

    hFileMap = CreateFileMapping(
                    hFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    0,
                    NULL);

    if (!hFileMap) 
    {
        goto Exit;
    }

    lpImage->MappedAddress = (PUCHAR) MapViewOfFile(
        hFileMap,
        FILE_MAP_READ,
        0,
        0,
        0
        );

    CloseHandle(hFileMap);

    lpImage->SizeOfImage = GetFileSize(hFile, NULL);

    if (!lpImage->MappedAddress ||
        !CalculateImagePtrs(lpImage)) 
    {
        goto Exit;
    }

    bRet = TRUE;

Exit:
    if (bRet == FALSE)
    {
        CloseHandle(hFile);
        UnmapViewOfFile(lpImage->MappedAddress);
    }

    return bRet;
}

/*++

 Helper function for LoadImage. Fill in all the pointers in a LOADED_IMAGE 
 structure.

--*/

BOOL
CalculateImagePtrs(
    PLOADED_IMAGE lpImage
    )
{
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_FILE_HEADER FileHeader;
    BOOL bRet;

    // Everything is mapped. Now check the image and find nt image headers

    bRet = TRUE;  // Assume the best

    __try 
    {
        DosHeader = (PIMAGE_DOS_HEADER)lpImage->MappedAddress;

        if ((DosHeader->e_magic != IMAGE_DOS_SIGNATURE) &&
            (DosHeader->e_magic != IMAGE_NT_SIGNATURE)) 
        {
            bRet = FALSE;
            goto tryout;
        }

        if (DosHeader->e_magic == IMAGE_DOS_SIGNATURE) 
        {
            if (DosHeader->e_lfanew == 0) 
            {
                lpImage->fDOSImage = TRUE;
                bRet = FALSE;
                goto tryout;
            }
            lpImage->FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

            // If IMAGE_NT_HEADERS would extend past the end of file...
            if ((PBYTE)lpImage->FileHeader + sizeof(IMAGE_NT_HEADERS) >
                (PBYTE)lpImage->MappedAddress + lpImage->SizeOfImage ||

                 // ..or if it would begin in, or before the IMAGE_DOS_HEADER...
                (PBYTE)lpImage->FileHeader <
                (PBYTE)lpImage->MappedAddress + sizeof(IMAGE_DOS_HEADER))
            {
                // ...then e_lfanew is not as expected.
                // (Several Win95 files are in this category.)
                bRet = FALSE;
                goto tryout;
            }
        } 
        else 
        {
            // No DOS header indicates an image built w/o a dos stub
            lpImage->FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader);
        }

        NtHeaders = lpImage->FileHeader;

        if ( NtHeaders->Signature != IMAGE_NT_SIGNATURE ) 
        {
            if ((USHORT)NtHeaders->Signature == (USHORT)IMAGE_OS2_SIGNATURE ||
                (USHORT)NtHeaders->Signature == (USHORT)IMAGE_OS2_SIGNATURE_LE)
            {
                lpImage->fDOSImage = TRUE;
            }

            bRet = FALSE;
            goto tryout;

        } 
        else 
        {
            lpImage->fDOSImage = FALSE;
        }

        FileHeader = &NtHeaders->FileHeader;

        // No optional header indicates an object...

        if (FileHeader->SizeOfOptionalHeader == 0) 
        {
            bRet = FALSE;
            goto tryout;
        }

        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) 
        {
            // 32-bit image.  Do some tests.
            if (((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase >= 0x80000000) 
            {
                lpImage->fSystemImage = TRUE;
            } 
            else 
            {
                lpImage->fSystemImage = FALSE;
            }

            if (((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.MajorLinkerVersion < 3 &&
                ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.MinorLinkerVersion < 5)
            {
                bRet = FALSE;
                goto tryout;
            }

        } 
        else 
        {
            lpImage->fSystemImage = FALSE;
        }

        lpImage->Sections = IMAGE_FIRST_SECTION(NtHeaders);
        lpImage->Characteristics = FileHeader->Characteristics;
        lpImage->NumberOfSections = FileHeader->NumberOfSections;
        lpImage->LastRvaSection = lpImage->Sections;
tryout:
    ;
    }
    __except ( EXCEPTION_EXECUTE_HANDLER ) 
    {
        bRet = FALSE;
    }

    return bRet;
}


/*++

 Unmap the loaded image.

--*/

BOOL
UnloadModule(
    PLOADED_IMAGE lpImage
    )
{
    UnmapViewOfFile(lpImage->MappedAddress);
    CloseHandle(lpImage->hFile);

    return TRUE;
}

/*++

 Description:

    Locates an RVA within the image header of a file that is mapped as a file and 
    returns a pointer to the section table entry for that virtual address.

 Arguments:

    NtHeaders - pointer to the image or data file
    Base      - base of the image or data file
    Rva       - relative virtual address (RVA) to locate

 Returns:

    NULL      - no data for the specified directory entry
    NON-NULL  - pointer of the section entry containing the data

--*/

PIMAGE_SECTION_HEADER
ImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION(NtHeaders);

    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) 
    {
        if (Rva >= NtSection->VirtualAddress &&
            Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData) 
        {
            return NtSection;
        }

        ++NtSection;
    }

    return NULL;
}

/*++

 Description:

    This function locates an RVA within the image header of a file that is 
    mapped as a file and returns the virtual addrees of the corresponding 
    byte in the file.

 Arguments:

    NtHeaders - pointer to the image or data file.
    Base      - base of the image or data file.
    Rva       - relative virtual address (RVA) to locate.
    LastRvaSection - optional parameter that if specified, points to a variable
                that contains the last section value used for the specified 
                image to translate and RVA to a VA.

 Returns:

    NULL      - does not contain the specified RVA
    NON-NULL  - virtual address in the mapped file.

--*/

PVOID
ImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL
    )
{
    PIMAGE_SECTION_HEADER NtSection;

    if (LastRvaSection == NULL ||
        (NtSection = *LastRvaSection) == NULL ||
        NtSection == NULL ||
        Rva < NtSection->VirtualAddress ||
        Rva >= NtSection->VirtualAddress + NtSection->SizeOfRawData) 
    {
        NtSection = NS_StackSwap::ImageRvaToSection(
            NtHeaders,
            Base,
            Rva);
    }

    if (NtSection != NULL) 
    {
        if (LastRvaSection != NULL) 
        {
            *LastRvaSection = NtSection;
        }

        return (PVOID)((ULONG_PTR)Base +
                       (Rva - NtSection->VirtualAddress) +
                       NtSection->PointerToRawData);
    }
    else 
    {
        return NULL;
    }
}

/*++

 See ImageDirectoryEntryToData.

--*/

PVOID
ImageDirectoryEntryToData32(
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundSection OPTIONAL,
    IN PIMAGE_FILE_HEADER FileHeader,
    IN PIMAGE_OPTIONAL_HEADER32 OptionalHeader
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;
    ULONG DirectoryAddress;

    if (DirectoryEntry >= OptionalHeader->NumberOfRvaAndSizes) 
    {
        *Size = 0;
        return( NULL );
    }

    if (!(DirectoryAddress = OptionalHeader->DataDirectory[ DirectoryEntry ].VirtualAddress)) 
    {
        *Size = 0;
        return( NULL );
    }
    
    *Size = OptionalHeader->DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < OptionalHeader->SizeOfHeaders) 
    {
        if (FoundSection) 
        {
            *FoundSection = NULL;
        }
        return ((PVOID)((ULONG_PTR)Base + DirectoryAddress));
    }

    NtSection = (PIMAGE_SECTION_HEADER)((ULONG_PTR)OptionalHeader +
                        FileHeader->SizeOfOptionalHeader);

    for (i=0; i<FileHeader->NumberOfSections; i++) 
    {
        if (DirectoryAddress >= NtSection->VirtualAddress &&
           DirectoryAddress < NtSection->VirtualAddress + NtSection->SizeOfRawData) 
        {
            if (FoundSection) 
            {
                *FoundSection = NtSection;
            }
            
            return( (PVOID)((ULONG_PTR)Base + (DirectoryAddress - NtSection->VirtualAddress) + NtSection->PointerToRawData) );
        }

        ++NtSection;
    }

    return( NULL );
}

/*++

 Description:

    This function locates a directory entry within the image header and returns 
    either the virtual address or seek address of the data the Directory 
    describes.  It may optionally return the section header, if any, for the 
    found data.

 Arguments:

    Base           - base of the image or data file.
    MappedAsImage  - FALSE if the file is mapped as a data file.
                   - TRUE if the file is mapped as an image.
    DirectoryEntry - directory entry to locate.
    Size           - return the size of the directory.
    FoundSection   - Returns the section header, if any, for the data

 Returns:

    NULL           - The file does not contain data for the specified directory entry.
    NON-NULL       - Returns the address of the raw data the directory describes.

--*/

PVOID
ImageDirectoryEntryToData(
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    )
{
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;

    if ((ULONG_PTR)Base & 0x00000001) 
    {
        Base = (PVOID)((ULONG_PTR)Base & ~0x1);
        MappedAsImage = FALSE;
     }

    NtHeader = RtlpImageNtHeader(Base);

    if (NtHeader) 
    {
        FileHeader = &NtHeader->FileHeader;
        OptionalHeader = &NtHeader->OptionalHeader;
    } 
    else 
    {
        // Handle case where Image passed in doesn't have a dos stub (ROM images for instance);
        FileHeader = (PIMAGE_FILE_HEADER)Base;
        OptionalHeader = (PIMAGE_OPTIONAL_HEADER) ((ULONG_PTR)Base + IMAGE_SIZEOF_FILE_HEADER);
    }

    if (OptionalHeader->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) 
    {
        return (ImageDirectoryEntryToData32(
            Base,
            MappedAsImage,
            DirectoryEntry,
            Size,
            NULL,
            FileHeader,
            (PIMAGE_OPTIONAL_HEADER32)OptionalHeader));
    } 
    else
    {
        return NULL;
    }
}

/*++

 Enumerate the first exported function.

--*/

BOOL
EnumFirstExport(
    PLOADED_IMAGE lpImage,
    PEXPORT_ENUM lpExports
    )
{
    ULONG imageSize;

    ZeroMemory (lpExports, sizeof (EXPORT_ENUM));

    lpExports->Image = lpImage;

    lpExports->ImageDescriptor = (PIMAGE_EXPORT_DIRECTORY)
        ImageDirectoryEntryToData(
            lpImage->MappedAddress,
            FALSE,
            IMAGE_DIRECTORY_ENTRY_EXPORT,
            &imageSize);

    if (!lpExports->ImageDescriptor) 
    {
        //DPF(eDbgLevelError, "Cannot load export directory for %s", lpImage->ModuleName);
        return FALSE;
    }

    if (lpExports->ImageDescriptor->NumberOfNames == 0) 
    {
        return FALSE;
    }

    lpExports->ExportNamesAddr = (PDWORD) NS_StackSwap::ImageRvaToVa(
        lpExports->Image->FileHeader,
        lpExports->Image->MappedAddress,
        lpExports->ImageDescriptor->AddressOfNames,
        NULL);

    lpExports->ExportOrdAddr = (PUSHORT) NS_StackSwap::ImageRvaToVa(
        lpExports->Image->FileHeader,
        lpExports->Image->MappedAddress,
        lpExports->ImageDescriptor->AddressOfNameOrdinals,
        NULL
        );

    lpExports->CurrExportNr = 0;

    return EnumNextExport(lpExports);
}

/*++

 Enumerate the next exported function.

--*/

BOOL
EnumNextExport(
    IN OUT  PEXPORT_ENUM lpExports
    )
{
    if (lpExports->CurrExportNr >= lpExports->ImageDescriptor->NumberOfNames) 
    {
        return FALSE;
    }

    if (*lpExports->ExportNamesAddr == 0) 
    {
        return FALSE;
    }

    lpExports->ExportFunction = (CHAR *)NS_StackSwap::ImageRvaToVa(
        lpExports->Image->FileHeader,
        lpExports->Image->MappedAddress,
        *lpExports->ExportNamesAddr,
        NULL);

    lpExports->ExportFunctionOrd = *lpExports->ExportOrdAddr + 
        lpExports->ImageDescriptor->Base;

    lpExports->ExportNamesAddr++;
    lpExports->ExportOrdAddr++;
    lpExports->CurrExportNr++;

    return (lpExports->ExportFunction != NULL);
}

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\inc\charvector.h ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   CharVector.h

 Abstract:

   A light-weight vector implementation.


 Created:

   03/14/2000 robkenny

 Modified:
    06/19/2000  robkenny    Converted Resize() and Append() to return BOOL to know if malloc failed.
    08/14/2001  robkenny    Inserted inside the ShimLib namespace.


--*/
#pragma once


#include <new>  // for in-place new



namespace ShimLib
{


/*++

    Vector template
    This vector is extremely fast and simple.

--*/
template <class ClassType> class VectorT
{
public:
    typedef VectorT<ClassType> MyType;

protected:
    ClassType * vectorList;
    int         nVectorListMax;     // Current size of vectorList array
    int         nVectorList;        // Number of entries in the vectorList array
    bool        bListIsLocked;      // Are we allowed to modify the array? 

    inline void ValidateIndex(int index) const
    {
#if DBG
        if (index < 0 || index >= nVectorList)
        {
            DebugPrintf("VectorT", eDbgLevelError, "VectorT: index %d out of bounds.\n", index);
        }
        if (nVectorListMax < 0 || nVectorList > nVectorListMax)
        {
            DebugPrintf("VectorT", eDbgLevelError, "VectorT: invalid nVectorListMax(%d) nVectorList(%d).\n", nVectorListMax, nVectorList);
        }
#endif
    }

public:
    VectorT()
    {
        // Init
        vectorList        = NULL;
        nVectorListMax    = 0;
        nVectorList       = 0;
        bListIsLocked     = false;
    }
    ~VectorT()
    {
        Erase();
    }

    // A Copy constructor
    VectorT(const MyType & copyMe)
    {
        // Init
        vectorList        = NULL;
        nVectorListMax    = 0;
        nVectorList       = 0;
        bListIsLocked     = false;

        Duplicate(copyMe);
    }

    // Assignment operator, this gets a copy of other 
    MyType & operator = (const MyType & other)
    {
        if (this != & other)
            Duplicate(other);

        return *this;
    }

    // Copy copyMe into this
    void Duplicate(const MyType & copyMe)
    {
        Erase();

        // Copy class data
        Resize(copyMe.Size());  // Allocates space
        nVectorListMax      = copyMe.nVectorListMax;
        nVectorList         = copyMe.nVectorList;
        bListIsLocked       = copyMe.bListIsLocked;

        // Copy array data
        size_t nBytes = nVectorListMax * sizeof(ClassType);
        memcpy(vectorList, copyMe.vectorList, nBytes);
    }

    void CopyElement(int index, const ClassType & element)
    {
        // Use memcpy to avoid any assignment operators.
        void * dest = & Get(index);
        const void * src  = & element;
        memcpy(dest, src, sizeof(ClassType));
    }

    // Allow this to be treated like an array.
    ClassType & operator [] (int index)
    {
        ValidateIndex(index);
        return vectorList[index];
    }

    // return the value of the index member
    ClassType & Get(int index)
    {
        ValidateIndex(index);
        return vectorList[index];
    }

    // return the const value of the index member
    const ClassType & Get(int index) const
    {
        ValidateIndex(index);
        return vectorList[index];
    }

    BOOL Resize(int size)
    {
        if (size > nVectorListMax)
        {
            size_t newVectorListSize = size * sizeof(ClassType);
            ClassType * newVectorList = (ClassType *)malloc(newVectorListSize);
            if (newVectorList)
            {
                size_t origSize = nVectorListMax * sizeof(ClassType);
                memcpy(newVectorList, vectorList, origSize);

                free(vectorList);
                vectorList = newVectorList;
                nVectorListMax = size;
            }
        }
        // We were successful if there is enough space in the array
        return nVectorListMax >= size;
    }

    // return the number of entries in the list
    int Size() const
    {
        return nVectorList;
    }

    // return the current MAXIMUM number of entries in the list
    int MaxSize() const
    {
        return nVectorListMax;
    }

    // Lock the list (prevent further additions)
    void Lock(bool lock = true)
    {
        bListIsLocked = lock;
    }

    // return true if the list is locked.
    bool IsLocked() const
    {
        return bListIsLocked;
    }

    // Reset number of entries in the list to 0
    void Reset()
    {
        nVectorList = 0;
    }

    // Remove all entries in the list
    void Erase()
    {
        Reset();
        if (vectorList)
            free(vectorList);
        vectorList = NULL;
        nVectorListMax = 0;
    }

    // Search for the member in the list, return index or -1
    int Find(const ClassType & member) const
    {
        for (int i = 0; i < Size(); ++i)
        {
            if (Get(i) == member)
                return i;
        }
        return -1;
    }

    // Add this item to the end of the list
    BOOL Append(const ClassType & member)
    {
        if (!bListIsLocked)
        {
            // Increase array size
            if (Resize(nVectorList + 1))
            {
                nVectorList += 1;
                CopyElement(nVectorList-1, member);
                return TRUE;
            }
        }
        return FALSE;
    }

    // Append this to the list, if it does not already exist
    // Return FALSE if any allocation failed.
    BOOL AppendUnique(const ClassType & member)
    {
        if (!bListIsLocked)
        {
            int index = Find(member);
            if (index == -1)
            {
                return Append(member);
            }
        }
        return TRUE;
    }

    // Add this item to the end of the list,
    // Use the assignment operator to set the new member.
    BOOL AppendConstruct(const ClassType & member)
    {
        if (!bListIsLocked)
        {
            // Increase array size
            if (Resize(nVectorList + 1))
            {
                // Must increase the size of the array before calling Get()
                // otherwise we'll over index the array.
                nVectorList += 1;

                ClassType & last = Get(nVectorList-1);
                new (&last) ClassType;  // inplace new
                last = member;

                return TRUE;
            }
        }
        return FALSE;
    }

    // remove this index from the list.  This does not keep the list order.
    void Remove(int index)
    {
        if (!bListIsLocked)
        {
            if (index >= 0 && index < Size())
            {
                // Remove the entry by copying the last entry over this index

                // Only move if this is not the last entry.
                if (index < Size() - 1)
                {
                    CopyElement(index, Get(Size() - 1));
                }

                nVectorList -= 1;
            }
        }
    }
};

/*++

    Char Vector type class.

--*/
class CharVector : public VectorT<char *>
{
};


};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\general\unmirrorimagelist.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    UnMirrorImageList.cpp

 Abstract:
 
    PictureIt 2001 calls CImageListCache::AddImage() with the ICIFLAG_MIRROR set 
	if the user default UI language is Arabic or Hebrew, This is shim to lie about 
	the default UI language.

	GetUserDefaultUILanguage will rerun English for Arabic and Hebrew languages.
    
    This shim is app specific

 History:

 04/17/2001 mhamid  created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(UnMirrorImageList)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetUserDefaultUILanguage) 
APIHOOK_ENUM_END

LANGID  
APIHOOK(GetUserDefaultUILanguage)(VOID)
{
	LANGID LangID = ORIGINAL_API(GetUserDefaultUILanguage)();
	if ((LangID == MAKELANGID(LANG_ARABIC, SUBLANG_DEFAULT))||
		(LangID == MAKELANGID(LANG_HEBREW, SUBLANG_DEFAULT)))
	{
		LangID = MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT);
	}
	return LangID;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GetUserDefaultUILanguage)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\inc\legalstr.h ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 LegalStr.h: Companion file to MakeIllegalStr.h

 LegalStr and MakeIllegalStr are used to pop/push the legal-ness
 of the strXXX routines.

 This file has no effect if IllegalStr.h has not been included;
 use MakeIllegalStr.h to undo the effects of this file.

 #include "LegalStr.h" to re-enable the strXXX routines.
 #include "MakeIllegalStr.h" to re-disable the strXXX routines


 History:

    03/13/2001  robkenny        Created
    03/21/2001  robkenny        Only undo effect of LegalStr.h

--*/


#ifdef _STRXXX_ROUTINES_ARE_ILLEGAL_

#define _STRXXX_ROUTINES_FORCE_LEGAL_
#include "IllegalStr.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\inc\makeillegalstr.h ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 MakeIllegalStr.h: Companion file to LegalStr.h

 LegalStr and MakeIllegalStr are used to pop/push the legal-ness
 of the strXXX routines.

 This file has no effect if LegalStr.h has not been included.

 #include "LegalStr.h" to re-enable the strXXX routines.
 #include "MakeIllegalStr.h" to re-disable the strXXX routines


 History:

    03/13/2001  robkenny        Created
    03/21/2001  robkenny        Only undo effect of LegalStr.h

--*/

#ifndef _STRXXX_ROUTINES_ARE_ILLEGAL_

#ifdef _STRXXX_ROUTINES_FORCE_LEGAL_

#undef _STRXXX_ROUTINES_FORCE_LEGAL_
#include "IllegalStr.h"

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\inc\parsedde.h ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    ParseDDE.h

 Abstract:

    Helpful routines for parsing DDE commands.

 Notes:

    None

 History:

    08/14/2001  robkenny    Inserted inside the ShimLib namespace.

--*/

#pragma once


//==============================================================================
//
// This code was copied from:
// \nt\shell\shell32\unicpp\dde.cpp
//
//==============================================================================
#include <dde.h>
#include <ddeml.h>



namespace ShimLib
{

// If this were included in ShimProto.h, we would have to include all kinds of DDE include files
typedef HDDEDATA       (WINAPI *_pfn_DdeClientTransaction)(
  LPBYTE pData,       // pointer to data to pass to server
  DWORD cbData,       // length of data
  HCONV hConv,        // handle to conversation
  HSZ hszItem,        // handle to item name string
  UINT wFmt,          // clipboard data format
  UINT wType,         // transaction type
  DWORD dwTimeout,    // time-out duration
  LPDWORD pdwResult   // pointer to transaction result
);



// Extracts an alphabetic string and looks it up in a list of possible
// commands, returning a pointer to the character after the command and
// sticking the command index somewhere.
UINT* GetDDECommands(LPSTR lpCmd, const char * lpsCommands[], BOOL fLFN);
void GetGroupPath(LPCSTR pszName, LPSTR pszPath, DWORD dwFlags, INT iCommonGroup);


};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\inc\secutils.h ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    secutils.h

 Abstract:
    The security utility functions for the shims.

 History:

    02/09/2001  maonis      Created
    08/14/2001  robkenny    Inserted inside the ShimLib namespace.

--*/

#ifndef _SEC_UTILS_H_
#define _SEC_UTILS_H_

#include "ShimHook.h"
#include <aclapi.h>

namespace ShimLib
{

#define ComputeDeniedAccesses(GrantedAccess, DesiredAccess) \
    ((~(GrantedAccess)) & (DesiredAccess))

BOOL SearchGroupForSID(DWORD dwGroup, BOOL* pfIsMember);

BOOL GetCurrentThreadSid(PSID* ppCurrentUserSid);

BOOL ShouldApplyShim();

BOOL AdjustPrivilege(LPCWSTR pwszPrivilege, BOOL fEnable);

//
// File specific
// 

BOOL RequestWriteAccess(DWORD dwCreationDisposition, DWORD dwDesiredAccess);



};  // end of namespace ShimLib

#endif // _SEC_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\inc\illegalstr.h ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 IllegalStr.h: Make strXXX routines legal or Illegal.

 If  _STRXXX_ROUTINES_FORCE_LEGAL_ is defined, any changes made
 by this file are undone, otherwise the strXXX routines are defined
 to "Do Not Use StrXXX routines" which causes an extremely blatant syntax error. 

 LegalStr and MakeIllegalStr are used to pop/push the legal-ness
 of the strXXX routines.

 #include "LegalStr.h" to re-enable the strXXX routines.
 #include "MakeIllegalStr.h" to re-disable the strXXX routines


 History:

    03/13/2001  robkenny        Created
    03/21/2001  robkenny        Updated to mesh cleanly with LegalStr.h and MakeIllegalStr.h

--*/


#ifndef _STRXXX_ROUTINES_FORCE_LEGAL_


#define _STRXXX_ROUTINES_ARE_ILLEGAL_

// Win32 API
#define lstrlenA // only to force explicit use of _tcslenBytes of _tcslenChars


// C runtime
#define strcpy               Do Not Use StrXXX routines
#define strcat               Do Not Use StrXXX routines
#define strcmp               Do Not Use StrXXX routines
#define strlen               Do Not Use StrXXX routines
#define strchr               Do Not Use StrXXX routines
#define _strcmpi             Do Not Use StrXXX routines
#define _stricmp             Do Not Use StrXXX routines
#define strcoll              Do Not Use StrXXX routines
#define _stricoll            Do Not Use StrXXX routines
#define _strncoll            Do Not Use StrXXX routines
#define _strnicoll           Do Not Use StrXXX routines
#define strcspn              Do Not Use StrXXX routines
#define _strdup              Do Not Use StrXXX routines
#define _strerror            Do Not Use StrXXX routines
#define strerror             Do Not Use StrXXX routines
#define _strlwr              Do Not Use StrXXX routines
#define strncat              Do Not Use StrXXX routines
#define strncmp              Do Not Use StrXXX routines
#define _strnicmp            Do Not Use StrXXX routines
#define strncpy              Do Not Use StrXXX routines
#define _strnset             Do Not Use StrXXX routines
#define strpbrk              Do Not Use StrXXX routines
#define strrchr              Do Not Use StrXXX routines
#define _strrev              Do Not Use StrXXX routines
#define strspn               Do Not Use StrXXX routines
#define strstr               Do Not Use StrXXX routines
#define stristr              Do Not Use StrXXX routines
#define strtok               Do Not Use StrXXX routines
#define _strupr              Do Not Use StrXXX routines


#else
// Allow the use of the strxxx routines


#ifdef lstrlenA
#undef lstrlenA
#endif

#ifdef strcpy
#undef strcpy
#endif
#ifdef strcat
#undef strcat
#endif
#ifdef strcmp
#undef strcmp
#endif
#ifdef strlen
#undef strlen
#endif
#ifdef strchr
#undef strchr
#endif
#ifdef _strcmpi
#undef _strcmpi
#endif
#ifdef _stricmp
#undef _stricmp
#endif
#ifdef strcoll
#undef strcoll
#endif
#ifdef _stricoll
#undef _stricoll
#endif
#ifdef _strncoll
#undef _strncoll
#endif
#ifdef _strnicoll
#undef _strnicoll
#endif
#ifdef strcspn
#undef strcspn
#endif
#ifdef _strdup
#undef _strdup
#endif
#ifdef _strerror
#undef _strerror
#endif
#ifdef strerror
#undef strerror
#endif
#ifdef _strlwr
#undef _strlwr
#endif
#ifdef strncat
#undef strncat
#endif
#ifdef strncmp
#undef strncmp
#endif
#ifdef _strnicmp
#undef _strnicmp
#endif
#ifdef strncpy
#undef strncpy
#endif
#ifdef _strnset
#undef _strnset
#endif
#ifdef strpbrk
#undef strpbrk
#endif
#ifdef strrchr
#undef strrchr
#endif
#ifdef _strrev
#undef _strrev
#endif
#ifdef strspn
#undef strspn
#endif
#ifdef strstr
#undef strstr
#endif
#ifdef stristr
#undef stristr
#endif
#ifdef strtok
#undef strtok
#endif
#ifdef _strupr
#undef _strupr
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\inc\heap.h ===
/*
#pragma once
*/
#ifndef _HEAP_H
#define _HEAP_H

#include <windows.h>
#include <stdio.h>
// Disable warning C4201: nonstandard extension used : nameless struct/union
// Allows shims to be compiled at Warning Level 4
#pragma warning ( disable : 4201 ) 
#include <mmsystem.h>
#pragma warning ( default : 4201 ) 
#include <winerror.h>
#include <shellapi.h>
#include <shlobj.h>
#include <ole2.h>
#include <ddraw.h>
#include <dsound.h>
#include <commdlg.h>
#include <winspool.h>
#include "ShimDebug.h"

/*
 *  heap.h - structures and equates for the Windows 32-bit heap
 *

/***LT  busyblock_s - busy heap block header structure
 *
 *  This structure is stored at the head of every busy (not free) heap
 *  block.
 *
 *  The bh_size field is in bytes and includes the size of the
 *  heap header and any slop at the end of the block that might have
 *  been included because of the heap granularity, or to keep us
 *  from leaving a block too small to hold a free heap header.
 *
 *  bh_size is also used as a forward link to the next heap block.
 *
 *  The low two bits of the bh_size field are used to hold flags
 *  (BP_FREE must be clear and HP_PREVFREE is optionally set).
 */
struct busyheap_s {
    unsigned long   bh_size;    /* block size + flags in low 2 bits */
};

/*XLATOFF*/
#define BH_SIGNATURE    0x4842      /* busy heap block signature (BH) */
/*XLATON*/

#define BH_CDWSUM   3       /* count of dwords to sum in struct */


/***LT  freeblock_s - free heap block header structure
 *
 *  This structure is stored at the head of every free block on the
 *  heap.  In the last dword of every free heap block is a pointer
 *  the this structure.
 *
 *  The fh_size field is in bytes and includes the size of the
 *  heap header and any slop at the end of the block that might have
 *  been included because of the heap granularity, or to keep us
 *  from leaving a block too small to hold a free heap header.
 *
 *  fh_size is also used as a forward link to the next heap block.
 *
 *  The low two bits of the fh_size field are used to hold flags
 *  (HP_FREE must be set and HP_PREVFREE must be clear).
 */

struct freeheap_s {
    unsigned long      fh_size; /* block size + flags in low 2 bits */
    struct freeheap_s *fh_flink;    /* forward link to next free block */
    struct freeheap_s *fh_blink;    /* back link to previous free block */
};

/*XLATOFF*/
#define FH_SIGNATURE    0x4846      /* free heap block signature (FH) */
/*XLATON*/

#define FH_CDWSUM   4       /* count of dwords to sum in struct */

/*
 *  Equates common to all heap blocks.
 *
 *  HP_FREE and HP_PREVFREE (HP_FLAGS) are stored in the low two
 *  bits of the fh_ and bh_size field.
 *  The signature is stored in the high three bits of the size.
 */
#define HP_FREE     0x00000001  /* block is free */
#define HP_PREVFREE 0x00000002  /* previous block is free */
#define HP_FLAGS    0x00000003  /* mask for all the flags */
#define HP_SIZE     0x0ffffffc  /* mask for clearing flags */
#define HP_SIGBITS  0xf0000000  /* bits used for signature */
#define HP_SIGNATURE    0xa0000000  /* valid value of signature */

/*
 *  Misc heap equates
 */
#define hpGRANULARITY   4       /* granularity for heap allocations */
#define hpGRANMASK  (hpGRANULARITY - 1)     /* for rounding */
/*XLATOFF*/
#define hpMINSIZE   (sizeof(struct freeheap_s)+sizeof(struct freeheap_s *))
            /* min block size */

#define hpMAXALLOC  (HP_SIZE - 100) /* biggest allocatable heap block */

/* overhead for a new heap segment (header plus end sentinel) */
#define hpSEGOVERHEAD   (sizeof(struct busyheap_s) + sizeof(struct heapseg_s))

/* default reserved size of new segments added to growable heaps */
#define hpCBRESERVE (4*1024*1024)


/*XLATON*/


/*
 * Exported flags for heap calls
 */

#define HP_ZEROINIT 0x40    /* zero initialize block on HP(Re)Alloc */
#define HP_MOVEABLE 0x02    /* block can be moved (HP(Re)Alloc) */
#define HP_NOCOPY   0x20    /* don't copy data on HPReAlloc */
#define HP_NOSERIALIZE  0x01    /* don't serialize heap access */
#define HP_EXCEPT   0x04    /* generate exceptions on error */

#define HP_FIXED    0x00    /* block is at a fixed address (HPAlloc) */
#define HP_GROWABLE 0x40    /* heap can grow beyond cbreserve (HPInit) */
/*
 *  Note that flags above 0x80 will not be stored into the heap header in
 *  HPInit calls because the flags field in the header is only a byte
 */
#define HP_INITSEGMENT 0x100    /* just initialize a heap segment (HPInit) */
#define HP_DECOMMIT    0x200    /* decommit pages in free block (hpFreeSub) */
#define HP_GROWUP      0x400    /* waste last page of heap (HPInit) */

/*XLATOFF*/

/***LP  hpSize - pull size field from heap header
 *
 *  This routine depends on the size field being the first
 *  dword in the header.
 *
 *  ENTRY:  ph - pointer to heap header
 *  EXIT:   count of bytes in block (counting header).
 */
#define hpSize(ph) (*((unsigned long *)(ph)) & HP_SIZE)

/***LP  hpSetSize - set the size parameter in a heap header
 *
 *  This routine depends on the size field being the first
 *  dword in the header.
 *
 *  ENTRY:  ph - pointer to busy heap header
 *      cb - count of bytes (should be rounded using hpRoundUp)
 *  EXIT:   size is set in heap header
 */
#define hpSetSize(ph, cb) (((struct busyheap_s *)(ph))->bh_size =  \
             ((((struct busyheap_s *)(ph))->bh_size & ~HP_SIZE) | (cb)))

/* the compiler used to do a better version with this macro than the above,
 * but not any more
#define hpSetSize2(ph, cb) *(unsigned long *)(ph) &= ~HP_SIZE; \
               *(unsigned long *)(ph) |= (cb);
 */

/***LP  hpSetBusySize - set the entire bh_size dword for a busy block
 *
 *  This macro will set the bh_size field of the given heap header
 *  to the given size as well as setting the HP_SIGNATURE and clearing
 *  any HP_FREE or HP_PREVFREE bits.
 *
 *  ENTRY:  ph - pointer to busy heap header
 *      cb - count of bytes (should be rounded using hpRoundUp)
 *  EXIT:   bh_size field is initialized
 */
#define hpSetBusySize(ph, cb)   ((ph)->bh_size = ((cb) | HP_SIGNATURE))


/***LP  hpSetFreeSize - set the entire fh_size dword for a free block
 *
 *  This macro will set the fh_size field of the given heap header
 *  to the given size as well as setting the HP_SIGNATURE and HP_FREE
 *  and clearing HP_PREVFREE.
 *
 *  ENTRY:  ph - pointer to free heap header
 *      cb - count of bytes (should be rounded using hpRoundUp)
 *  EXIT:   bh_size field is initialized
 */
#define hpSetFreeSize(ph, cb)   ((ph)->fh_size = ((cb) | HP_SIGNATURE | HP_FREE))


/***LP  hpIsBusySignatureValid - check a busy heap block's signature
 *
 *  This macro checks the tiny signature (HP_SIGNATURE) in the bh_size
 *  field to see if it is set properly and makes sure that the HP_FREE
 *  bit is clear.
 *
 *  ENTRY:  ph - pointer to a busy heap header
 *  EXIT:   TRUE if signature is ok, else FALSE
 */
#define hpIsBusySignatureValid(ph) \
            (((ph)->bh_size & (HP_SIGBITS | HP_FREE)) == HP_SIGNATURE)


/***LP  hpIsFreeSignatureValid - check a free heap block's signature
 *
 *  This macro checks the tiny signature (HP_SIGNATURE) in the fh_size
 *  field to see if it is set properly and makes sure that the HP_FREE
 *  bit is also set and HP_PREVFREE is clear.
 *
 *  ENTRY:  ph - pointer to a free heap header
 *  EXIT:   TRUE if signature is ok, else FALSE
 */
#define hpIsFreeSignatureValid(ph) \
      (((ph)->fh_size & (HP_SIGBITS | HP_FREE | HP_PREVFREE)) == \
                             (HP_SIGNATURE | HP_FREE))


#define maximum(a,b)    \
        ( (a) > (b) ) ? (a) : (b)


/***LP  hpRoundUp - round up byte count to appropriate heap block size
 *
 *  Heap blocks have a minimum size of hpMINSIZE and hpGRANULARITY
 *  granularity.  This macro also adds on size for the heap header.
 *
 *  ENTRY:  cb - count of bytes
 *  EXIT:   count rounded up to hpGANULARITY boundary
 */
#define hpRoundUp(cb)   \
      max(hpMINSIZE,    \
      (((cb) + sizeof(struct busyheap_s) + hpGRANMASK) & ~hpGRANMASK))



/*XLATON*/

/***LK  freelist_s - heap free list head
 */
struct freelist_s {
    unsigned long     fl_cbmax; /* max size block in this free list */
    struct freeheap_s fl_header;    /* pseudo heap header as list head */
};
#define hpFREELISTHEADS 4   /* number of free list heads in heapinfo_s */

/***LK  heapinfo_s - per-heap information (stored at start of heap)
 *
 */
struct heapinfo_s {

    /* These first three fields must match the fields of heapseg_s */
    unsigned long   hi_cbreserve;       /* bytes reserved for heap */
    struct heapseg_s *hi_psegnext;      /* pointer to next heap segment*/

    struct freelist_s hi_freelist[hpFREELISTHEADS]; /* free list heads */
    struct heapinfo_s *hi_procnext;     /* linked list of process heaps */
    CRITICAL_SECTION  *hi_pcritsec;    /* pointer to serialization obj*/
    CRITICAL_SECTION    hi_critsec;             /* serialize access to heap */
    unsigned char   hi_flags;       /* HP_SERIALIZE, HP_LOCKED */
    unsigned char   hi_pad2;        /* unused */
    unsigned short  hi_signature;       /* should be HI_SIGNATURE */
};

/*
 * Heap Measurement functions
 */
#define  HPMEASURE_FREE    0x8000000L

#define  SAMPLE_CACHE_SIZE 1024

struct measure_s {
   char  szFile[260];
   unsigned iCur;
   unsigned uSamples[SAMPLE_CACHE_SIZE];
};

/*XLATOFF*/
#define HI_SIGNATURE  0x4948        /* heapinfo_s signature (HI) */
/*XLATON*/

#define HI_CDWSUM  1            /* count of dwords to sum */

typedef struct heapinfo_s *HHEAP;


/***LK  heapseg_s - per-heap segment structure
 *
 *  Growable heaps can have multiple discontiguous sections of memory
 *  allocated to them.  Each is headed by one of these structures.  The
 *  first segment is special, in that it has a full heapinfo_s structure,
 *  but the first fields of heapinfo_s match heapseg_s, so it can be
 *  treated as just another segment when convenient.
 */
struct heapseg_s {
    unsigned long   hs_cbreserve;   /* bytes reserved for this segment */
    struct heapseg_s *hs_psegnext;  /* pointer to next heap segment*/
};
/* XLATOFF */

/* smallest possible heap */
#define hpMINHEAPSIZE   (sizeof(struct heapinfo_s) + hpMINSIZE + \
             sizeof(struct busyheap_s))

/***LP  hpRemove - remove item from free list
 *
 *  ENTRY:  pfh - pointer to free heap block to remove from list
 *  EXIT:   none
 */
#define hpRemoveNoSum(pfh)              \
    (pfh)->fh_flink->fh_blink = (pfh)->fh_blink;    \
    (pfh)->fh_blink->fh_flink = (pfh)->fh_flink;


#define hpRemove(pfh)   hpRemoveNoSum(pfh)


/***LP  hpInsert - insert item onto the free list
 *
 *  ENTRY:  pfh - free heap block to insert onto the list
 *      pfhprev - insert pfh after this item
 *  EXIT:   none
 */
#define hpInsertNoSum(pfh, pfhprev)     \
    (pfh)->fh_flink = (pfhprev)->fh_flink;  \
    (pfh)->fh_flink->fh_blink = (pfh);  \
    (pfh)->fh_blink = (pfhprev);        \
    (pfhprev)->fh_flink = (pfh)

#define hpInsert(pfh, pfhprev)  hpInsertNoSum(pfh, pfhprev)



/*
 * critical section macros to be used by all internal heap functions
 */
    #define hpEnterCriticalSection(hheap) EnterCriticalSection(hheap->hi_pcritsec)
    #define hpLeaveCriticalSection(hheap) LeaveCriticalSection(hheap->hi_pcritsec)
    #define hpInitializeCriticalSection(hheap)              \
         {                                        \
            hheap->hi_pcritsec = &(hheap->hi_critsec);  \
            InitializeCriticalSection(hheap->hi_pcritsec);               \
         }


/*
 * Exported heap functions
 */

/*
extern HHEAP HPInit(void *hheap, void *pmem, unsigned long cbreserve,
                 unsigned long flags);
extern void * HPAlloc(HHEAP hheap, unsigned long cb,
                 unsigned long flags);

extern void * HPReAlloc(HHEAP hheap, void *pblock, unsigned long cb,
                   unsigned long flags);
*/

/*
 * Local heap functions
 */

/*
extern void hpFreeSub(HHEAP hheap, void *pblock, unsigned cb,
                   unsigned flags);
extern BOOL hpCommit(unsigned page, int npages, unsigned flags);
extern unsigned hpCarve(HHEAP hheap, struct freeheap_s *pfh,
                unsigned cb, unsigned flags);

extern unsigned hpTakeSem(HHEAP hheap, struct busyheap_s *pbh, unsigned long flags);
extern void hpClearSem(HHEAP hheap, unsigned flags);
*/


#define hpWalk(hheap) 1



#define mmError(rc, string) SetLastError(rc)
#define mmAssert(exp, psz)

#define PAGESIZE    1024*4
#define PAGEMASK    0x00000FFF      /* Extract the page-relative offset*/

#define ERR_OUT_OF_RANGE 2

// Function prototypes
extern unsigned 
hpCarve(HHEAP hheap, struct freeheap_s *pfh, unsigned cb, unsigned flags);

extern unsigned 
hpTakeSem(HHEAP hheap, struct busyheap_s *pbh, unsigned long htsflags);

extern void 
hpClearSem(HHEAP hheap, unsigned flags);

extern void
hpFreeSub(HHEAP hheap, struct freeheap_s *pblock, unsigned cb, unsigned flags);

extern void *
HPAlloc(HHEAP hheap, unsigned long cb, unsigned long flags);

extern HHEAP 
HPInit(struct heapinfo_s *hheap,
       struct heapinfo_s *pmem,
       unsigned long cbreserve,
       unsigned long flags);

extern HANDLE SimHeapCreate(DWORD flOptions, DWORD dwInitialSize, DWORD dwMaximumSize);

extern BOOL 
hpCommit( unsigned pmem,
               int nSize,
               unsigned flags
               );
extern VOID 
hpDeCommit(unsigned pmem,
           int nSize,
           unsigned flags
          );
extern LPVOID PageReserve(unsigned Size);
extern  VOID PageFree(LPVOID pmem);
extern  void * HPReAlloc(HHEAP hheap, void *pblock, unsigned long cb, unsigned long flags);
extern  BOOL HeapFreeInternal(HHEAP hheap, DWORD flags, LPSTR lpMem);
extern  BOOL SimHeapDestroy(HHEAP hHeap);
extern  HANDLE SIMLocalAlloc(HHEAP hHeap,UINT dwFlags, UINT dwBytes);
extern  HANDLE SIMLocalFree(HHEAP hHeap,HANDLE hMem);
extern  HANDLE SIMLocalReAlloc(HHEAP hHeap,HANDLE hMem, UINT dwBytes, UINT dwFlags);
extern LPVOID SIMLocalLock(HHEAP hHeap,HANDLE hMem);
extern BOOL SIMLocalUnlock(HHEAP hHeap,HANDLE hMem);
extern HANDLE SIMLocalHandle(HHEAP hHeap,PVOID pMem);
extern DWORD SIMHeapSize(HHEAP hheap, DWORD flags, LPSTR lpMem);
extern UINT SIMLocalSize(HHEAP hHeap,HANDLE hMem);
extern UINT SIMLocalFlags(HHEAP hHeap,HANDLE hMem);
extern ULONG VerifyOnHeap(HHEAP hheap, PVOID p);
extern BOOL SIMHeapValidate(HHEAP hheap, DWORD dwFlags, LPCVOID lpMem);
extern UINT SIMHeapCompact(HHEAP hheap,DWORD dwFlags);
#endif //_AH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\inc\classcfp.h ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    CorrectPathChangesBase.cpp

 Abstract:
    Several paths were changed between Win9x and WinNT.  This routine defines
    the CorrectPathChangesBase routines that is called with a Win9x path and returns
    the corresponding WinNT path.

 History:
 
    03-Mar-00   robkenny    Converted CorrectPathChanges.cpp to this class.
    08/14/2001  robkenny    Inserted inside the ShimLib namespace.

--*/
#pragma once

#include "ShimHook.h"
#include "ShimLib.h"
#include "CharVector.h"


namespace ShimLib
{

class StringPairW
{
public:
    WCHAR       lpOld[MAX_PATH];
    DWORD       dwLenOld;

    WCHAR       lpNew[MAX_PATH];
    DWORD       dwLenNew;

    StringPairW(const WCHAR * lpszOld, const WCHAR * lpszNew)
    {
        dwLenOld = wcslen(lpszOld);
        SafeStringCopyW(lpOld, MAX_PATH, lpszOld, dwLenOld + 1);
        dwLenNew = wcslen(lpszNew);
        SafeStringCopyW(lpNew, MAX_PATH, lpszNew, dwLenNew + 1);
    }
};

class EnvironmentValues : public VectorT<StringPairW>
{
protected:
    BOOL            bInitialized;

public:
    EnvironmentValues();
    ~EnvironmentValues();

    void            Initialize();

    WCHAR *         ExpandEnvironmentValueW(const WCHAR * lpOld);
    char *          ExpandEnvironmentValueA(const char * lpOld);

    void            AddEnvironmentValue(const WCHAR * lpOld, const WCHAR * lpNew);

    enum eAddNameEnum
    {
        eIgnoreName   = 0,
        eAddName      = 1,
    };
    enum eAddNoDLEnum
    {
        eIgnoreNoDL   = 0,
        eAddNoDL      = 1,
    };

    void            AddAll_CSIDL();
    void            Add_Variants(const WCHAR * lpEnvName, const WCHAR * lpEnvValue, eAddNameEnum eName, eAddNoDLEnum eNoDL);
    void            Add_CSIDL(const WCHAR * lpEnvName, int nFolder, eAddNameEnum eName, eAddNoDLEnum eNoDL);
};

class CorrectPathChangesBase
{
protected:

    EnvironmentValues * lpEnvironmentValues;
    DWORD               dwKnownPathFixesCount;
    StringPairW *       lpKnownPathFixes;

    BOOL                bInitialized;
    BOOL                bEnabled;

    CRITICAL_SECTION    csCritical;

protected:
    virtual void    InitializeCorrectPathChanges();
    virtual void    InitializePathFixes();
    virtual void    InitializeEnvironmentValuesW();

    void            AddEnvironmentValue(const WCHAR * lpOld, const WCHAR * lpNew);
    void            InsertPathChangeW( const WCHAR * lpOld, const WCHAR * lpNew);

    void            EnterCS();
    void            LeaveCS();

public:
    CorrectPathChangesBase();
    virtual ~CorrectPathChangesBase();

    virtual WCHAR * ExpandEnvironmentValueW(const WCHAR * lpOld);
    virtual char *  ExpandEnvironmentValueA(const char * lpOld);

    virtual void    AddPathChangeW(const WCHAR * lpOld, const WCHAR * lpNew);

    virtual void    AddCommandLineA(const char * lpCommandLine );
    virtual void    AddCommandLineW(const WCHAR * lpCommandLine );
    
    virtual void    AddFromToPairW(const WCHAR * lpFromToPair );

    virtual char *  CorrectPathAllocA(const char * str);
    virtual WCHAR * CorrectPathAllocW(const WCHAR * str);

    inline void     Enable(BOOL enable);
};


/*++
    Enable (or disable if value is FALSE) changing of paths.
--*/
inline void CorrectPathChangesBase::Enable(BOOL isEnabled)
{
    bEnabled = isEnabled;
}

// Typical path fixes
class CorrectPathChangesUser : public CorrectPathChangesBase
{
protected:
    virtual void    InitializePathFixes();
};

// Typical path fixes, moving user directories to All Users
class CorrectPathChangesAllUser : public CorrectPathChangesUser
{
protected:

    virtual void    InitializePathFixes();
};

};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\inc\rtlutils.h ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    pathutils.h

 Abstract:
    
    Contains prototypes for functions from ntdll
    on XP that are not available on W2K.

 History:

    09/10/2001  rparsons    Created

--*/

#ifndef _RTLUTILS_H_
#define _RTLUTILS_H_

#include "ShimHook.h"

namespace ShimLib
{

PVOID
ShimAllocateStringRoutine(
    SIZE_T NumberOfBytes
    );

VOID
ShimFreeStringRoutine(
    PVOID Buffer
    );

const PRTL_ALLOCATE_STRING_ROUTINE RtlAllocateStringRoutine = ShimAllocateStringRoutine;
const PRTL_FREE_STRING_ROUTINE RtlFreeStringRoutine = ShimFreeStringRoutine;

RTL_PATH_TYPE
NTAPI
ShimDetermineDosPathNameType_Ustr(
    IN PCUNICODE_STRING String
    );

NTSTATUS
NTAPI
ShimNtPathNameToDosPathName(
    IN     ULONG                      Flags,
    IN OUT PRTL_UNICODE_STRING_BUFFER Path,
    OUT    ULONG*                     Disposition OPTIONAL,
    IN OUT PWSTR*                     FilePart OPTIONAL
    );

NTSTATUS
ShimDuplicateUnicodeString(
    ULONG Flags,
    PCUNICODE_STRING StringIn,
    PUNICODE_STRING StringOut
    );

NTSTATUS
NTAPI
ShimpEnsureBufferSize(
    IN ULONG           Flags,
    IN OUT PRTL_BUFFER Buffer,
    IN SIZE_T          Size
    );

NTSTATUS
ShimValidateUnicodeString(
    ULONG Flags,
    const UNICODE_STRING *String
    );

//
// Taken from %SDXROOT%\public\sdk\inc\NtRtlStringAndBuffer.h
//
#define ShimEnsureBufferSize(Flags, Buff, NewSizeBytes) \
    (   ((Buff) != NULL && (NewSizeBytes) <= (Buff)->Size) \
        ? STATUS_SUCCESS \
        : ShimpEnsureBufferSize((Flags), (Buff), (NewSizeBytes)) \
    )

#define ShimEnsureUnicodeStringBufferSizeBytes(Buff_, NewSizeBytes_)                            \
    (     ( ((NewSizeBytes_) + sizeof((Buff_)->String.Buffer[0])) > UNICODE_STRING_MAX_BYTES ) \
        ? STATUS_NAME_TOO_LONG                                                                 \
        : !NT_SUCCESS(ShimEnsureBufferSize(0, &(Buff_)->ByteBuffer, ((NewSizeBytes_) + sizeof((Buff_)->String.Buffer[0])))) \
        ? STATUS_NO_MEMORY                                                                      \
        : (RtlSyncStringToBuffer(Buff_))                                                       \
    )

#define ShimEnsureUnicodeStringBufferSizeChars(Buff_, NewSizeChars_) \
    (ShimEnsureUnicodeStringBufferSizeBytes((Buff_), (NewSizeChars_) * sizeof((Buff_)->String.Buffer[0])))

//
// Taken from %SDXROOT%\public\sdk\inc\NtRtlStringAndBuffer.h
//
//++
//
// NTSTATUS
// RtlAppendUnicodeStringBuffer(
//     OUT PRTL_UNICODE_STRING_BUFFER Destination,
//     IN  PCUNICODE_STRING           Source
//     );
//
// Routine Description:
//
//
// Arguments:
//
//     Destination - 
//     Source - 
//
// Return Value:
//
//     STATUS_SUCCESS
//     STATUS_NO_MEMORY
//     STATUS_NAME_TOO_LONG (64K UNICODE_STRING length would be exceeded)
//
//--
#define ShimAppendUnicodeStringBuffer(Dest, Source)                            \
    ( ( ( (Dest)->String.Length + (Source)->Length + sizeof((Dest)->String.Buffer[0]) ) > UNICODE_STRING_MAX_BYTES ) \
        ? STATUS_NAME_TOO_LONG                                                \
        : (!NT_SUCCESS(                                                       \
                ShimEnsureBufferSize(                                         \
                    0,                                                        \
                    &(Dest)->ByteBuffer,                                          \
                    (Dest)->String.Length + (Source)->Length + sizeof((Dest)->String.Buffer[0]) ) ) \
                ? STATUS_NO_MEMORY                                            \
                : ( ( (Dest)->String.Buffer = (PWSTR)(Dest)->ByteBuffer.Buffer ), \
                    ( RtlMoveMemory(                                          \
                        (Dest)->String.Buffer + (Dest)->String.Length / sizeof((Dest)->String.Buffer[0]), \
                        (Source)->Buffer,                                     \
                        (Source)->Length) ),                                  \
                    ( (Dest)->String.MaximumLength = (RTL_STRING_LENGTH_TYPE)((Dest)->String.Length + (Source)->Length + sizeof((Dest)->String.Buffer[0]))), \
                    ( (Dest)->String.Length += (Source)->Length ),            \
                    ( (Dest)->String.Buffer[(Dest)->String.Length / sizeof((Dest)->String.Buffer[0])] = 0 ), \
                    ( STATUS_SUCCESS ) ) ) )
                    
//
// Taken from %SDXROOT%\public\sdk\inc\NtRtlStringAndBuffer.h
//
//++
//
// NTSTATUS
// RtlAssignUnicodeStringBuffer(
//     IN OUT PRTL_UNICODE_STRING_BUFFER Buffer,
//     PCUNICODE_STRING                  String
//     );
// Routine Description:
//
// Arguments:
//
//     Buffer - 
//     String - 
//
// Return Value:
//
//     STATUS_SUCCESS
//     STATUS_NO_MEMORY
//--
#define ShimAssignUnicodeStringBuffer(Buff, Str) \
    (((Buff)->String.Length = 0), (ShimAppendUnicodeStringBuffer((Buff), (Str))))


};  // end of namespace ShimLib

#endif // _RTLUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\addwritepermissionstodevicefiles.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    AddWritePermissionsToDeviceFiles.cpp

 Abstract:

    Add write permissions for IOCTL_SCSI_PASS_THROUGH under SECUROM.

    SecuRom can be debugged under a user-mode debugger but the following must 
    be done before hitting 'g' after attach:

        1. sxi av   <- ignore access violations
        2. sxi sse  <- ignore single step exception
        3. sxi ssec <- ignore single step exception continue
        4. sxi dz   <- ignore divide by zero

    It checksums it's executable, so breakpoints in certain places don't work.

 Notes:
    
    This is a general purpose shim.

 History:

    09/03/1999 v-johnwh Created
    03/09/2001 linstev  Rewrote DeviceIoControl to handle bad buffers and added 
                        debugging comments

--*/

#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(AddWritePermissionsToDeviceFiles)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(DeviceIoControl)
    APIHOOK_ENUM_ENTRY(CloseHandle)
APIHOOK_ENUM_END

VectorT<HANDLE> * g_hDevices;

/*++

 We need to add write permission to all CD-ROM devices

--*/

HANDLE 
APIHOOK(CreateFileA)(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    DWORD dwAccessMode = dwDesiredAccess;

    if ((lpFileName[0] == '\\') && 
        (lpFileName[1] == '\\') && 
        (lpFileName[2] == '.') && 
        (lpFileName[3] == '\\')) {
        //
        // This file starts with \\.\ so it must be a device file.
        //

        if (!(dwAccessMode & GENERIC_WRITE)) {
            //
            // Make sure this device is a CD-ROM
            //
            char diskRootName[4];
            diskRootName[0] = lpFileName[4];
            diskRootName[1] = ':';
            diskRootName[2] = '\\';
            diskRootName[3] = 0;

            DWORD dwDriveType = GetDriveTypeA(diskRootName);
            if (DRIVE_CDROM == dwDriveType) {
                //
                // Add write permissions to give us NT4 behavior for device 
                // files
                //
                dwAccessMode |= GENERIC_WRITE;
            }
        }
    }

    HANDLE hRet = ORIGINAL_API(CreateFileA)(lpFileName, dwAccessMode, 
        dwShareMode, lpSecurityAttributes, dwCreationDisposition, 
        dwFlagsAndAttributes, hTemplateFile);

    if ((hRet != INVALID_HANDLE_VALUE) && (dwAccessMode != dwDesiredAccess)) {
        //
        // Add the handle to our list so we can clean it up later.
        // 
        g_hDevices->Append(hRet);
        LOGN( eDbgLevelError, "[CreateFileA] Added GENERIC_WRITE permission on device(%s)", lpFileName);
    }

    return hRet;
}

/*++

 Since we added write permission to CD-ROM devices for IOCTL_SCSI_PASS_THROUGH,
 we need to remove the write permission for all other IOCTLs passed to that device.

--*/

BOOL 
APIHOOK(DeviceIoControl)(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    )
{
    LPVOID lpOut = lpOutBuffer;
    if (lpOutBuffer && nOutBufferSize && lpBytesReturned) {
        // 
        // Create a new output buffer, if this fails we just keep the original 
        // buffer.
        //

        lpOut = malloc(nOutBufferSize);
        if (lpOut) {
            MoveMemory(lpOut, lpOutBuffer, nOutBufferSize);
        } else {
            DPFN( eDbgLevelError, "Out of memory");
            lpOut = lpOutBuffer;
        }
    }

    BOOL bRet;
    if (IOCTL_SCSI_PASS_THROUGH != dwIoControlCode) {
        //
        // We don't care about IOCTL_SCSI_PASS_THROUGH
        //

        if (g_hDevices->Find(hDevice) >= 0) {
            //
            // Check to see if this is a device that we added Write permissions
            // If it is, we need to create a handle with only Read permissions
            //

            HANDLE hDupped;

            bRet = DuplicateHandle(GetCurrentProcess(), hDevice, 
                GetCurrentProcess(), &hDupped, GENERIC_READ, FALSE, 0);

            if (bRet) {
                //
                // Call the IOCTL with the original (Read) permissions
                //
                bRet = ORIGINAL_API(DeviceIoControl)(hDupped, dwIoControlCode,
                    lpInBuffer, nInBufferSize, lpOut, nOutBufferSize, 
                    lpBytesReturned, lpOverlapped);

                CloseHandle(hDupped);

                goto Exit;
            }
        }
    }

    bRet = ORIGINAL_API(DeviceIoControl)(hDevice, dwIoControlCode, lpInBuffer,
        nInBufferSize, lpOut, nOutBufferSize, lpBytesReturned, lpOverlapped);

Exit:
    
    if (lpOut && (lpOut != lpOutBuffer)) {
        //
        // Need to copy the output back into the true output buffer
        //
        if (bRet && lpBytesReturned && *lpBytesReturned) {
            __try {
                MoveMemory(lpOutBuffer, lpOut, *lpBytesReturned);
            } __except(1) {
                DPFN( eDbgLevelError, "Failed to copy data into output buffer, perhaps it's read-only");
            }
        }

        free(lpOut);
    }

    return bRet;

} 

/*++

 If this handle is in our list, remove it.

--*/

BOOL 
APIHOOK(CloseHandle)(
    HANDLE hObject   
    )
{
    int index = g_hDevices->Find(hObject);
    
    if (index >= 0) {
        g_hDevices->Remove(index);
    }

    return ORIGINAL_API(CloseHandle)(hObject);
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hDevices = new VectorT<HANDLE>;
    }

    return g_hDevices != NULL;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, DeviceIoControl)
    APIHOOK_ENTRY(KERNEL32.DLL, CloseHandle)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\inc\shimstack.h ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ShimStack.h

 Abstract:

    Macros for giving APIs a temporary stack.

 Notes:

    None

 History:

    02/26/2000 linstev  Created

--*/

#ifndef _SHIMSTACK_H_
#define _SHIMSTACK_H_

#ifdef _X86_

CRITICAL_SECTION g_csStack;
LPVOID g_pStack;
DWORD g_dwStackSize;
DWORD g_dwStackCopy;

// Macro to initialize memory and critical section for stack protection macros
// TotalSize : the total size for the temporary stack (in DWORDS)
// CopySize  : the size of the current stack to copy  (in DWORDS) 

#define INIT_STACK(TotalSize, CopySize)                                       \
    InitializeCriticalSection(&g_csStack);                                    \
    g_pStack = VirtualAlloc(NULL, TotalSize * 4, MEM_COMMIT, PAGE_READWRITE); \
    g_dwStackSize = TotalSize;                                                \
    g_dwStackCopy = CopySize;                           

// Macro to free the temporary stack and the critical section
#define FREE_STACK()                                                          \
    VirtualFree(g_pStack, 0, MEM_RELEASE);                                    \
    DeleteCriticalSection(&g_csStack);

// Get a new stack by copying the old to a buffer.
#define NEW_STACK()                                                           \
    EnterCriticalSection(&g_csStack);                                         \
    DWORD dwTempESP;                                                          \
    DWORD dwDiff = (g_dwStackSize - g_dwStackCopy) * 4;                       \
    __asm { mov  dwTempESP,esp                  }                             \
    __asm { push ecx                            }                             \
    __asm { push esi                            }                             \
    __asm { push edi                            }                             \
    __asm { mov  esi,dwTempESP                  }                             \
    __asm { mov  edi,g_pStack                   }                             \
    __asm { add  edi,dwDiff                     }                             \
    __asm { mov  ecx,g_dwStackCopy              }                             \
    __asm { cld                                 }                             \
    __asm { rep  movsd                          }                             \
    __asm { pop  esi                            }                             \
    __asm { pop  edi                            }                             \
    __asm { pop  ecx                            }                             \
    __asm { mov  esp,g_pStack                   }                             \
    __asm { add  esp,dwDiff                     }       

// Revert to the old stack
#define OLD_STACK()                                                           \
    __asm { mov esp,dwTempESP                   }                             \
    LeaveCriticalSection(&g_csStack);

#endif // _X86_

#endif // _SHIMSTACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\changeauthenticationlevel.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   ChangeAuthenticationLevel.cpp

 Abstract:

   Sets the dwAuthnLevel for CoInitializeSecurity() to RPC_C_AUTHN_LEVEL_CONNECT.
   This fixes problems associated with a change with Windows 2000 and above where 
   RPC_C_AUTHN_LEVEL_NONE is nolonger promoted for local calls to PRIVACY.

 Notes:

   Only needed where app sets level to RPC_C_AUTHN_LEVEL_NONE.

 History:

   07/19/2000 jpipkins  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ChangeAuthenticationLevel)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CoInitializeSecurity)
APIHOOK_ENUM_END

/*++

 Adjust security level.

--*/

HRESULT
APIHOOK(CoInitializeSecurity)(
    PSECURITY_DESCRIPTOR pVoid,
    LONG cAuthSvc,
    SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
    void *pReserved1,
    DWORD dwAuthnLevel,
    DWORD dwImpLevel,
    SOLE_AUTHENTICATION_LIST *pAuthList,
    DWORD dwCapabilities,
    void *pReserved3
    )
{
    HRESULT hResult;

    DPFN( eDbgLevelInfo, "CoInitializeSecurity called");
    
    if (RPC_C_AUTHN_LEVEL_NONE == dwAuthnLevel)
    {
        LOGN( eDbgLevelWarning, "[APIHook_CoInitializeSecurity] Increasing authentication level");
        dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;    
    }

    hResult = ORIGINAL_API(CoInitializeSecurity)( 
        pVoid,
        cAuthSvc,
        asAuthSvc,
        pReserved1,
        dwAuthnLevel,
        dwImpLevel,
        pAuthList,
        dwCapabilities,
        pReserved3);
                                                
    return hResult;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(OLE32.DLL, CoInitializeSecurity)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\correctcreateeventname.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    CorrectCreateEventName.cpp

 Abstract:

    CreateEvent doesn't like event names that are similar to path names.
    This shim will replace all non alphabet and non number characters with
    an underscore.

 Notes:
    
    This is a general purpose shim.

 History:

    07/19/1999  robkenny    Created
    03/15/2001  robkenny    Converted to CString

--*/


#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CorrectCreateEventName)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateEventA)
APIHOOK_ENUM_END

/*+

 CreateEvent doesn't like event names that are similar to path names. This shim 
 will replace all non alphabet and non number characters with an underscore.

--*/

HANDLE 
APIHOOK(CreateEventA)(
    LPSECURITY_ATTRIBUTES lpEventAttributes, // SD
    BOOL bManualReset,                       // reset type
    BOOL bInitialState,                      // initial state
    LPCSTR lpName                            // object name
    )
{
    DPFN( eDbgLevelInfo, "CreateEventA called with event name = %s.", lpName);

    CSTRING_TRY
    {
        CString csName(lpName);
        int nCount = csName.Replace(L'\\', '_');

        LPCSTR lpCorrectName = csName.GetAnsi();
    
        if (nCount)
        {
            LOGN( eDbgLevelError, 
                "CreateEventA corrected event name from (%s) to (%s)", lpName, lpCorrectName);
        }
    
        HANDLE returnValue = ORIGINAL_API(CreateEventA)(lpEventAttributes,
                                                        bManualReset,
                                                        bInitialState,
                                                        lpCorrectName);
        return returnValue;
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    HANDLE returnValue = ORIGINAL_API(CreateEventA)(lpEventAttributes,
                                                    bManualReset,
                                                    bInitialState,
                                                    lpName);
    return returnValue;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateEventA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\correctfilepaths.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   CorrectFilePaths.cpp

 Abstract:

   This APIHooks CreateProcess and attempts to convert paths from Win9x locations to Win2000
   locations.  For example "C:\WINNT\WRITE.EXE" will be converted to C:\WINNT\SYSTEM32\WRITE.EXE"

 Notes:

   This APIHook emulates Windows 9x.

 Created:

   12/15/1999 robkenny

 Modified:

    03/14/2000  robkenny        Now uses ClassCFP instead of global routines.
    03/31/2000  robkenny        ShellExecuteEx now handle lpDirectory path as well.
    05/18/2000  a-sesk          GetCommandLineA and GetCommandLineW convert cmd line args to short path.
    06/20/2000  robkenny        Added SetFileAttributes() 
    06/22/2000  robkenny        Reordered enum list and DECLARE_APIHOOK list to match each other.
    --SERIOUS CHANGE--
    10/30/2000  robkenny        Added path specific fixes.
                                Command lines now have the EXE path removed and corrected
                                separately from the remainder of the command line.
    11/13/2000  a-alexsm        Added SetArguments & SetIconLocation hooks
    11/13/2000  robkenny        Changed CorrectPath to always return a valid string
                                by returning the original string.  Must call CorrectFree
                                to properly release the memory.
    12/14/2000  prashkud        Added hooks for _lopen and _lcreat
    03/10/2001  robkenny        Do not convert any paths until *after* all shims have been loaded.
    03/15/2001  robkenny        Converted to CString

--*/


#include "precomp.h"
#include "LegalStr.h"
#include "ClassCFP.h"

IMPLEMENT_SHIM_BEGIN(CorrectFilePaths)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(CreateProcessA)
    APIHOOK_ENUM_ENTRY(CreateProcessW)
    APIHOOK_ENUM_ENTRY(WinExec)
    APIHOOK_ENUM_ENTRY(ShellExecuteA)
    APIHOOK_ENUM_ENTRY(ShellExecuteW)
    APIHOOK_ENUM_ENTRY(ShellExecuteExA)
    APIHOOK_ENUM_ENTRY(ShellExecuteExW)

    APIHOOK_ENUM_ENTRY(GetCommandLineA)
    APIHOOK_ENUM_ENTRY(GetCommandLineW)

    APIHOOK_ENUM_ENTRY(GetPrivateProfileIntA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileIntW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionNamesA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionNamesW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStructW)

    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructW)

    APIHOOK_ENUM_ENTRY(CopyFileA)
    APIHOOK_ENUM_ENTRY(CopyFileW)
    APIHOOK_ENUM_ENTRY(CopyFileExA)
    APIHOOK_ENUM_ENTRY(CopyFileExW)
    APIHOOK_ENUM_ENTRY(CreateDirectoryA)
    APIHOOK_ENUM_ENTRY(CreateDirectoryW)
    APIHOOK_ENUM_ENTRY(CreateDirectoryExA)
    APIHOOK_ENUM_ENTRY(CreateDirectoryExW)

    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
    APIHOOK_ENUM_ENTRY(DeleteFileA)
    APIHOOK_ENUM_ENTRY(DeleteFileW)

    APIHOOK_ENUM_ENTRY(FindFirstFileA)
    APIHOOK_ENUM_ENTRY(FindFirstFileW)
    APIHOOK_ENUM_ENTRY(FindFirstFileExA)
    APIHOOK_ENUM_ENTRY(FindFirstFileExW)

    APIHOOK_ENUM_ENTRY(GetBinaryTypeA)
    APIHOOK_ENUM_ENTRY(GetBinaryTypeW)
    APIHOOK_ENUM_ENTRY(GetFileAttributesA)
    APIHOOK_ENUM_ENTRY(GetFileAttributesW)
    APIHOOK_ENUM_ENTRY(GetFileAttributesExA)
    APIHOOK_ENUM_ENTRY(GetFileAttributesExW)
    APIHOOK_ENUM_ENTRY(SetFileAttributesA)
    APIHOOK_ENUM_ENTRY(SetFileAttributesW)

    APIHOOK_ENUM_ENTRY(MoveFileA)
    APIHOOK_ENUM_ENTRY(MoveFileW)
    APIHOOK_ENUM_ENTRY(MoveFileExA)
    APIHOOK_ENUM_ENTRY(MoveFileExW)
    APIHOOK_ENUM_ENTRY(MoveFileWithProgressA)
    APIHOOK_ENUM_ENTRY(MoveFileWithProgressW)

    APIHOOK_ENUM_ENTRY(RemoveDirectoryA)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryW)
    APIHOOK_ENUM_ENTRY(SetCurrentDirectoryA)
    APIHOOK_ENUM_ENTRY(SetCurrentDirectoryW)

    APIHOOK_ENUM_ENTRY(OpenFile)

    APIHOOK_ENUM_ENTRY(RegSetValueA)
    APIHOOK_ENUM_ENTRY(RegSetValueW)
    APIHOOK_ENUM_ENTRY(RegSetValueExA)
    APIHOOK_ENUM_ENTRY(RegSetValueExW)

    APIHOOK_ENUM_ENTRY(_lopen)
    APIHOOK_ENUM_ENTRY(_lcreat)

    APIHOOK_ENUM_ENTRY_COMSERVER(SHELL32)

    APIHOOK_ENUM_ENTRY(LoadImageA)
APIHOOK_ENUM_END


// This is a private define (shlapip.h) that can mess up ShellExecuteEx
#ifndef SEE_MASK_FILEANDURL
#define SEE_MASK_FILEANDURL       0x00400000
#endif


/*++

    CorrectFree: free lpMalloc if it is different from lpOrig

--*/
inline void CorrectFree(char * lpMalloc, const char * lpOrig)
{
    if (lpMalloc != lpOrig)
    {
        free(lpMalloc);
    }
}

inline void CorrectFree(WCHAR * lpMalloc, const WCHAR * lpOrig)
{
    if (lpMalloc != lpOrig)
    {
        free(lpMalloc);
    }
}

/*++

    Our path changing class.
    Note: This is a pointer to the base class.

--*/
CorrectPathChangesBase * g_PathCorrector = NULL;


/*++

    Values that can be modified by the command line

--*/
enum PathCorrectorEnum
{
    ePathCorrectorBase,
    ePathCorrectorUser,
    ePathCorrectorAllUser,
};

BOOL g_bCreateProcessRoutines           = TRUE;
BOOL g_bGetCommandLineRoutines          = FALSE;
BOOL g_bRegSetValueRoutines             = FALSE;
BOOL g_bFileRoutines                    = TRUE;
BOOL g_bProfileRoutines                 = TRUE;
BOOL g_bShellLinkRoutines               = TRUE;
BOOL g_bW9xPath                         = FALSE;
BOOL g_bLoadImage                       = FALSE;

BOOL g_bShimsInitialized = FALSE;


PathCorrectorEnum g_pathcorrectorType   = ePathCorrectorAllUser;

int             g_nExtraPathCorrections     = 0;
CString *       g_ExtraPathCorrections;

/*++

    Parse the command line.

--*/
BOOL ParseCommandLine(const char * commandLine)
{
    // Force the default values
    g_bCreateProcessRoutines        = TRUE;
    g_bGetCommandLineRoutines       = FALSE;
    g_bRegSetValueRoutines          = FALSE;
    g_bFileRoutines                 = TRUE;
    g_bProfileRoutines              = TRUE;
    g_bShellLinkRoutines            = TRUE;
    g_bW9xPath                      = FALSE;
    g_bLoadImage                    = FALSE;

    g_pathcorrectorType             = ePathCorrectorAllUser;
    g_nExtraPathCorrections         = 0;
    g_ExtraPathCorrections          = NULL;

    // Search the beginning of the command line for these switches
    //
    // Switch           Default     Meaning
    //================  =======     =========================================================
    // -a                  Y        Force shortcuts to All Users
    // -c                  N        Do not shim Create process routines
    // -f                  N        Do not shim File routines
    // -p                  N        Do not shim GetPrivateProfile routines
    // -s                  N        Do not shim IShellLink routines
    // -b                  N        Bare: Use the base corrector (has no built-in path changes)
    // -u                  N        User: Built-in paths correct to <username>/Start Menu and <username>/Desktop
    // +GetCommandLine     N        shim GetCommandLine routines
    // +RegSetValue        N        shim the RegSetValue and RegSetValueEx routines
    // +Win9xPath          N        Apply Win9x *path* specific fixes (does not apply to command lines)
    // -Profiles           N        Do not force shortcuts to All Users
    // +LoadBitmap         N        shim the LoadBitmapA routine
    //

    CSTRING_TRY
    {
        CString csCl(commandLine);
        CStringParser csParser(csCl, L" ");
    
        int argc = csParser.GetCount();
        if (csParser.GetCount() == 0)
        {
            return TRUE; // Not an error
        }

        // allocate for worst case
        g_ExtraPathCorrections = new CString[argc];
        if (!g_ExtraPathCorrections)
        {
            return FALSE;   // Failure
        }
        g_nExtraPathCorrections = 0;
    
        for (int i = 0; i < argc; ++i)
        {
            BOOL bPathCorrection = FALSE;
            
            CString & csArg = csParser[i];
    
            DPFN( eDbgLevelSpew, "Argv[%d] == (%S)\n", i, csArg.Get());
        
            if (csArg == L"-a")
            {
                g_pathcorrectorType = ePathCorrectorAllUser;
            }
            else if (csArg == L"-b")
            {
                g_pathcorrectorType = ePathCorrectorBase;
            }
            else if (csArg == L"-u" || csArg == L"-Profiles")
            {
                g_pathcorrectorType = ePathCorrectorUser;
            }
            else if (csArg == L"-c")
            {
                g_bCreateProcessRoutines = FALSE;
            }
            else if (csArg == L"-f")
            {
                g_bFileRoutines = FALSE;
            }
            else if (csArg == L"-p")
            {
                g_bProfileRoutines = FALSE;
            }
            else if (csArg == L"-s")
            {
                g_bShellLinkRoutines = FALSE;
            }
            else if (csArg == L"+GetCommandLine")
            {
                DPFN( eDbgLevelInfo, "Command line routines will be shimmed\n");
                g_bGetCommandLineRoutines = TRUE;
            }
            else if (csArg == L"+RegSetValue")
            {
                DPFN( eDbgLevelInfo, "RegSetValue routines will be shimmed\n");
                g_bRegSetValueRoutines = TRUE;
            }
            else if (csArg == L"+Win9xPath")
            {
                DPFN( eDbgLevelInfo, "Win9x Path corrections will be applied\n");
                g_bW9xPath = TRUE;
            }
            else if (csArg == L"+LoadImage")
            {
                DPFN( eDbgLevelInfo, "LoadImageA will be shimmed\n");
                g_bLoadImage = TRUE;
            }
            else
            {
                g_ExtraPathCorrections[g_nExtraPathCorrections] = csArg;
                g_nExtraPathCorrections += 1;
            }
        }

#if DBG
        // Dump out the new path correction values.
        {
            const char *lpszPathCorrectorType = "Unknown"; 
            if (g_pathcorrectorType == ePathCorrectorBase)
            {
                lpszPathCorrectorType = "ePathCorrectorBase";
            }
            else if (g_pathcorrectorType == ePathCorrectorUser)
            {
                lpszPathCorrectorType = "ePathCorrectorUser";
            }
            else if (g_pathcorrectorType == ePathCorrectorAllUser)
            {
                lpszPathCorrectorType = "ePathCorrectorAllUser";
            }
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim CreateProcessRoutines  = %d\n", g_bCreateProcessRoutines);
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim GetCommandLineRoutines = %d\n", g_bGetCommandLineRoutines);
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim RegSetValueRoutines    = %d\n", g_bRegSetValueRoutines);
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim FileRoutines           = %d\n", g_bFileRoutines);
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim ProfileRoutines        = %d\n", g_bProfileRoutines);
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim ShellLinkRoutines      = %d\n", g_bShellLinkRoutines);
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim LoadImageA             = %d\n", g_bLoadImage);
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim W9xPath                = %d\n", g_bW9xPath);
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim Path Corrector Type    = %s\n", lpszPathCorrectorType);

            for (int i = 0; i < g_nExtraPathCorrections; ++i)
            {
                DPFN( eDbgLevelInfo, "[ParseCommandLine] Extra Path Change(%S)\n", g_ExtraPathCorrections[i].Get()); 
            }
        }
#endif

    }
    CSTRING_CATCH
    {
        return FALSE;
    }

    return TRUE;
}

/*++

    Create the appropriate g_PathCorrector

--*/
CorrectPathChangesBase * CreatePathcorrecter(PathCorrectorEnum pathCorrectorType)
{
    // It is not safe to create the path correctors until all the shims have been loaded.
    if (!g_bShimsInitialized)
    {
        return NULL;
    }

    switch (pathCorrectorType)
    {
    case ePathCorrectorBase:
        g_PathCorrector = new CorrectPathChangesBase;
        break;

    case ePathCorrectorUser:
        g_PathCorrector = new CorrectPathChangesUser;
        break;

    case ePathCorrectorAllUser:
    default:
        g_PathCorrector = new CorrectPathChangesAllUser;
        break;

    };

    if (g_ExtraPathCorrections && g_nExtraPathCorrections)
    {
        // Add the command line to this Path Corrector
        for (int i = 0; i < g_nExtraPathCorrections; ++i)
        {
            g_PathCorrector->AddFromToPairW(g_ExtraPathCorrections[i]);
        }

        delete [] g_ExtraPathCorrections;
        g_ExtraPathCorrections  = NULL;
        g_nExtraPathCorrections = 0;
    }

    return g_PathCorrector;
}

/*++

    Return a pointer to the PathCorrecting object

--*/
inline CorrectPathChangesBase * GetPathcorrecter()
{
    if (g_PathCorrector == NULL)
    {
        // Create our correct file path object
        g_PathCorrector = CreatePathcorrecter(g_pathcorrectorType);
    }

    return g_PathCorrector;
}

inline void DebugSpew(const WCHAR * uncorrect, const WCHAR * correct, const char * debugMsg)
{
    if (correct && uncorrect && _wcsicmp(correct, uncorrect) != 0)
    {
        LOGN( eDbgLevelError, "%s corrected path:\n    %S\n    %S\n",
            debugMsg, uncorrect, correct);
    }
    else // Massive Spew:
    {
        DPFN( eDbgLevelSpew, "%s unchanged %S\n", debugMsg, uncorrect);
    }
}

inline void DebugSpew(const char * uncorrect, const char * correct, const char * debugMsg)
{
    if (correct && uncorrect && _stricmp(correct, uncorrect) != 0)
    {
        LOGN( eDbgLevelError, "%s corrected path:\n    %s\n    %s\n",
            debugMsg, uncorrect, correct);
    }
    else // Massive Spew:
    {
        DPFN( eDbgLevelSpew, "%s unchanged %s\n", debugMsg, uncorrect);
    }
}




/*++

    Given a string, correct the path.
    bMassagePath determines of path specific fixes are applied
       (should be FALSE for command lines)

--*/
WCHAR * CorrectorCorrectPath(CorrectPathChangesBase * pathCorrector, const WCHAR * uncorrect, const char * debugMsg, BOOL bMassagePath)
{
    if (uncorrect == NULL)
        return NULL;

    if (!pathCorrector)
        return (WCHAR *)uncorrect;

    const WCHAR * W9xCorrectedPath = uncorrect;

    // Check and see if we need to perform the special Win9x path massaging
    if (bMassagePath)
    {
        W9xCorrectedPath = W9xPathMassageW(uncorrect);
    }

    WCHAR * strCorrectFile = pathCorrector->CorrectPathAllocW(W9xCorrectedPath);

    // If the allocation failed, return the original string.
    // This should allow the shim routines to pass along the orignal
    // values to the hooked APIs, which if they fail, will have the
    // proper error codes.
    if (!strCorrectFile)
    {
        strCorrectFile = (WCHAR *)uncorrect;
    }
    else if (debugMsg)
    {
        DebugSpew(uncorrect, strCorrectFile, debugMsg);
    }

    if (W9xCorrectedPath != uncorrect)
        free((WCHAR *)W9xCorrectedPath);

    return strCorrectFile;
}

WCHAR * CorrectPath(const WCHAR * uncorrect, const char * debugMsg, BOOL bMassagePath = g_bW9xPath)
{
    WCHAR *  wstrCorrectFile = (WCHAR *)uncorrect;
    CSTRING_TRY
    {
        CorrectPathChangesBase * pathCorrector = GetPathcorrecter();

        wstrCorrectFile = CorrectorCorrectPath(pathCorrector, uncorrect, debugMsg, bMassagePath);
    }
    CSTRING_CATCH
    {
        // Fall through
    }

    return wstrCorrectFile;
}

/*++

    Given a string, correct the path.
    bMassagePath determines of path specific fixes are applied
       (should be FALSE for command lines)

--*/
char * CorrectPath(const char * uncorrect, const char * debugMsg, BOOL bMassagePath = g_bW9xPath)
{
    char * strCorrectFile = (char *)uncorrect;

    CSTRING_TRY
    {
        CString csUncorrect(uncorrect);

        WCHAR * wstrCorrectFile = CorrectPath(csUncorrect, NULL, bMassagePath);

        // Don't assign to strCorrectFile unless we successfully allocate the memory.
        char * lpszChar = ToAnsi(wstrCorrectFile);
        if (lpszChar)
        {
            strCorrectFile = lpszChar;
        }

        CorrectFree(wstrCorrectFile, csUncorrect);
    }
    CSTRING_CATCH
    {
        // Fall through
    }

    if (debugMsg)
    {
        DebugSpew(uncorrect, strCorrectFile, debugMsg);
    }

    return strCorrectFile;
}


DWORD APIHOOK(GetFileAttributesA)(
  LPCSTR lpFileName   // name of file or directory
)
{
    char * strCorrect = CorrectPath(lpFileName, "GetFileAttributesA");

    DWORD returnValue = ORIGINAL_API(GetFileAttributesA)(strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

DWORD APIHOOK(GetFileAttributesW)(
  LPCWSTR lpFileName   // name of file or directory
)
{
    WCHAR * strCorrect = CorrectPath(lpFileName, "GetFileAttributesW");

    DWORD returnValue = ORIGINAL_API(GetFileAttributesW)(strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

BOOL APIHOOK(SetFileAttributesA)(
  LPCSTR lpFileName,      // file name
  DWORD dwFileAttributes   // attributes
)
{
    char * strCorrect = CorrectPath(lpFileName, "SetFileAttributesA");

    DWORD returnValue = ORIGINAL_API(SetFileAttributesA)(strCorrect, dwFileAttributes);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

DWORD APIHOOK(SetFileAttributesW)(
  LPCWSTR lpFileName,      // file name
  DWORD dwFileAttributes   // attributes
)
{
    WCHAR * strCorrect = CorrectPath(lpFileName, "SetFileAttributesW");

    DWORD returnValue = ORIGINAL_API(SetFileAttributesW)(strCorrect, dwFileAttributes);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

BOOL APIHOOK(GetFileAttributesExA)(
  LPCSTR lpFileName,                   // file or directory name
  GET_FILEEX_INFO_LEVELS fInfoLevelId,  // attribute 
  LPVOID lpFileInformation              // attribute information 
)
{
    char * strCorrect = CorrectPath(lpFileName, "GetFileAttributesExA");

    BOOL returnValue = ORIGINAL_API(GetFileAttributesExA)(strCorrect, fInfoLevelId, lpFileInformation);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

BOOL APIHOOK(GetFileAttributesExW)(
  LPCWSTR lpFileName,                   // file or directory name
  GET_FILEEX_INFO_LEVELS fInfoLevelId,  // attribute 
  LPVOID lpFileInformation              // attribute information 
)
{
    WCHAR * strCorrect = CorrectPath(lpFileName, "GetFileAttributesExW");

    BOOL returnValue = ORIGINAL_API(GetFileAttributesExW)(strCorrect, fInfoLevelId, lpFileInformation);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for CreateProcessA

--*/
BOOL APIHOOK(CreateProcessA)(
                    LPCSTR lpApplicationName,                 
                    LPSTR lpCommandLine,                      
                    LPSECURITY_ATTRIBUTES lpProcessAttributes,
                    LPSECURITY_ATTRIBUTES lpThreadAttributes, 
                    BOOL bInheritHandles,                     
                    DWORD dwCreationFlags,                    
                    LPVOID lpEnvironment,                     
                    LPCSTR lpCurrentDirectory,                
                    LPSTARTUPINFOA lpStartupInfo,             
                    LPPROCESS_INFORMATION lpProcessInformation)
{
    // Application name and command line that is passed to CreateProcess
    // Will either point to lpApplicationName or strCorrectApplicationName
    // Will either point to lpCommandLine     or strCorrectCommandLine
    const char * pstrCorrectApplicationName = lpApplicationName;
    char * pstrCorrectCommandLine = lpCommandLine;

    // Pointers to corrected strings, these may not be used
    const char * strCorrectApplicationName = NULL;
    char * strCorrectCommandLine = NULL;

    if (lpApplicationName != NULL)
    {
        // Get a buffer containing the application name with the corrected path
        strCorrectApplicationName = CorrectPath(lpApplicationName, "CreateProcessA ApplicationName:");
        pstrCorrectApplicationName = strCorrectApplicationName;
    }

    if (lpCommandLine != NULL)
    {
        // Get a buffer containing the command line with the corrected path
        strCorrectCommandLine = CorrectPath(lpCommandLine, "CreateProcessA CommandLine:", FALSE);
        pstrCorrectCommandLine = strCorrectCommandLine;
    }

    DPFN( eDbgLevelInfo, "CreateProcessA Application(%s) CommandLine(%s)\n", pstrCorrectApplicationName, pstrCorrectCommandLine);
    
    BOOL returnValue = ORIGINAL_API(CreateProcessA)(pstrCorrectApplicationName,
                                                 pstrCorrectCommandLine,
                                                 lpProcessAttributes,
                                                 lpThreadAttributes, 
                                                 bInheritHandles,                     
                                                 dwCreationFlags,                    
                                                 lpEnvironment,                     
                                                 lpCurrentDirectory,                
                                                 lpStartupInfo,             
                                                 lpProcessInformation);

    CorrectFree((char *)strCorrectApplicationName, lpApplicationName);
    CorrectFree(strCorrectCommandLine, lpCommandLine);

    return returnValue;
}


/*++

    Convert Win9x paths to WinNT paths for CreateProcessW

--*/

BOOL APIHOOK(CreateProcessW)(
                    LPCWSTR lpApplicationName,
                    LPWSTR lpCommandLine,
                    LPSECURITY_ATTRIBUTES lpProcessAttributes,
                    LPSECURITY_ATTRIBUTES lpThreadAttributes,
                    BOOL bInheritHandles,
                    DWORD dwCreationFlags,
                    LPVOID lpEnvironment,
                    LPCWSTR lpCurrentDirectory,
                    LPSTARTUPINFOW lpStartupInfo,
                    LPPROCESS_INFORMATION lpProcessInformation)
{
    // Application name and command line that is passed to CreateProcess
    // Will either point to lpApplicationName or strCorrectApplicationName
    // Will either point to lpCommandLine     or strCorrectCommandLine
    const WCHAR * pstrCorrectApplicationName = lpApplicationName;
    WCHAR * pstrCorrectCommandLine = lpCommandLine;

    // Pointers to corrected strings, these may not be used
    const WCHAR * strCorrectApplicationName = NULL;
    WCHAR * strCorrectCommandLine = NULL;

    if (lpApplicationName != NULL)
    {
        // Get a buffer containing the application name with the corrected path
        strCorrectApplicationName = CorrectPath(lpApplicationName, "CreateProcessW ApplicationName:");
        pstrCorrectApplicationName = strCorrectApplicationName;
    }

    if (lpCommandLine != NULL)
    {
        // Get a buffer containing the command line with the corrected path
        strCorrectCommandLine = CorrectPath(lpCommandLine, "CreateProcessW CommandLine:", FALSE);
        pstrCorrectCommandLine = strCorrectCommandLine;
    }

    DPFN( eDbgLevelInfo, "CreateProcessW Application(%S) CommandLine(%S)\n", pstrCorrectApplicationName, pstrCorrectCommandLine);

    BOOL returnValue = ORIGINAL_API(CreateProcessW)(pstrCorrectApplicationName,
                                                 pstrCorrectCommandLine,
                                                 lpProcessAttributes,
                                                 lpThreadAttributes, 
                                                 bInheritHandles,                     
                                                 dwCreationFlags,                    
                                                 lpEnvironment,                     
                                                 lpCurrentDirectory,                
                                                 lpStartupInfo,             
                                                 lpProcessInformation);

    CorrectFree((WCHAR *)strCorrectApplicationName, lpApplicationName);
    CorrectFree(strCorrectCommandLine, lpCommandLine);

    return returnValue;
}


/*++

    Convert Win9x paths to WinNT paths for WinExec

--*/

UINT APIHOOK(WinExec)(LPCSTR lpCmdLine, UINT uCmdShow)
{
    // Get a buffer containing the command line with the corrected path
    char * strCorrect = CorrectPath(lpCmdLine, "WinExec", FALSE);

    UINT returnValue = ORIGINAL_API(WinExec)(strCorrect, uCmdShow);

    CorrectFree(strCorrect, lpCmdLine);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for ShellExecuteA

--*/

HINSTANCE APIHOOK(ShellExecuteA)(
            HWND hwnd, 
            LPCSTR lpVerb,
            LPCSTR lpFile, 
            LPCSTR lpParameters, 
            LPCSTR lpDirectory,
            INT nShowCmd
           )
{
    // Since this command is executed by the shell, it may contain %env% variables,
    // expand them before calling correctpath.
    const char * expandedFile = lpFile;
    char expandedFileBuffer[MAX_PATH];
    if (ExpandEnvironmentStringsA(lpFile, expandedFileBuffer, MAX_PATH))
    {
        expandedFile = expandedFileBuffer;
    }

    char * strCorrect = CorrectPath(expandedFile, "ShellExecuteA");

    HINSTANCE returnValue = ORIGINAL_API(ShellExecuteA)(hwnd, lpVerb, strCorrect, lpParameters, lpDirectory, nShowCmd);

    CorrectFree(strCorrect, expandedFile);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for ShellExecuteW

--*/

HINSTANCE APIHOOK(ShellExecuteW)(
            HWND hwnd, 
            LPCWSTR lpVerb,
            LPCWSTR lpFile, 
            LPCWSTR lpParameters, 
            LPCWSTR lpDirectory,
            INT nShowCmd
           )
{
    // Since this command is executed by the shell, it may contain %env% variables,
    // expand them before calling correctpath.
    const WCHAR * expandedFile = lpFile;
    WCHAR expandedFileBuffer[MAX_PATH];
    if (ExpandEnvironmentStringsW(lpFile, expandedFileBuffer, MAX_PATH))
    {
        expandedFile = expandedFileBuffer;
    }

    WCHAR * strCorrect = CorrectPath(expandedFile, "ShellExecuteW");

    HINSTANCE returnValue = ORIGINAL_API(ShellExecuteW)(hwnd, lpVerb, strCorrect, lpParameters, lpDirectory, nShowCmd);

    CorrectFree(strCorrect, expandedFile);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for ShellExecuteExA

--*/

BOOL APIHOOK(ShellExecuteExA)(
            LPSHELLEXECUTEINFOA lpExecInfo
           )
{
    // Check for this magical *internal* flag that tells the system
    // that lpExecInfo->lpFile is actually a file and URL combined with
    // a 0 byte seperator, (file\0url\0)
    // Since this is internal only, we should not be receiving bad paths.
    if (lpExecInfo->fMask & SEE_MASK_FILEANDURL)
    {
        return ORIGINAL_API(ShellExecuteExA)(lpExecInfo);
    }

    // Since this command is executed by the shell, it may contain %env% variables,
    // expand them before calling correctpath.
    char expandedFile[MAX_PATH];
    char expandedDirectory[MAX_PATH];

    const char * lpFile      = lpExecInfo->lpFile;
    const char * lpDirectory = lpExecInfo->lpDirectory;

    // Check to see if app is expecting %env% substitution
    if (lpExecInfo->fMask & SEE_MASK_DOENVSUBST )
    {
        if (ExpandEnvironmentStringsA(lpExecInfo->lpFile, expandedFile, MAX_PATH))
        {
            lpFile = expandedFile;
        }
        if (ExpandEnvironmentStringsA(lpExecInfo->lpDirectory, expandedDirectory, MAX_PATH))
        {
            lpDirectory = expandedDirectory;
        }
    }

    char * strFileCorrect = CorrectPath(lpFile, "ShellExecuteExA");
    char * strDirCorrect  = CorrectPath(lpDirectory, "ShellExecuteExA");

    // Save the original fileName
    const char * lpFileSave      = lpExecInfo->lpFile;
    const char * lpDirSave       = lpExecInfo->lpDirectory;
    lpExecInfo->lpFile      = strFileCorrect;
    lpExecInfo->lpDirectory = strDirCorrect;
    BOOL returnValue        = ORIGINAL_API(ShellExecuteExA)(lpExecInfo);
    lpExecInfo->lpFile      = lpFileSave;
    lpExecInfo->lpDirectory = lpDirSave;

    CorrectFree(strFileCorrect, lpFile);
    CorrectFree(strDirCorrect, lpDirectory);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for ShellExecuteExW

--*/

BOOL APIHOOK(ShellExecuteExW)(
            LPSHELLEXECUTEINFOW lpExecInfo
           )
{
    // Check for this magical *internal* flag that tells the system
    // that lpExecInfo->lpFile is actually a file and URL combined with
    // a 0 byte seperator, (file\0url\0)
    // Since this is internal only, we should not be receiving bad paths.
    if (lpExecInfo->fMask & SEE_MASK_FILEANDURL)
    {
        return ORIGINAL_API(ShellExecuteExW)(lpExecInfo);
    }


    // Since this command is executed by the shell, it may contain %env% variables,
    // expand them before calling correctpath.
    WCHAR expandedFile[MAX_PATH];
    WCHAR expandedDirectory[MAX_PATH];

    const WCHAR * lpFile      = lpExecInfo->lpFile;
    const WCHAR * lpDirectory = lpExecInfo->lpDirectory;

    // Check to see if app is expecting %env% substitution
    if (lpExecInfo->fMask & SEE_MASK_DOENVSUBST )
    {
        if (ExpandEnvironmentStringsW(lpExecInfo->lpFile, expandedFile, MAX_PATH))
        {
            lpFile = expandedFile;
        }
        if (ExpandEnvironmentStringsW(lpExecInfo->lpDirectory, expandedDirectory, MAX_PATH))
        {
            lpDirectory = expandedDirectory;
        }
    }

    WCHAR * strFileCorrect = CorrectPath(lpFile, "ShellExecuteExW");
    WCHAR * strDirCorrect  = CorrectPath(lpDirectory, "ShellExecuteExW");

    // Save the original fileName
    const WCHAR * lpFileSave      = lpExecInfo->lpFile;
    const WCHAR * lpDirSave       = lpExecInfo->lpDirectory;
    lpExecInfo->lpFile      = strFileCorrect;
    lpExecInfo->lpDirectory = strDirCorrect;
    BOOL returnValue        = ORIGINAL_API(ShellExecuteExW)(lpExecInfo);
    lpExecInfo->lpFile      = lpFileSave;
    lpExecInfo->lpDirectory = lpDirSave;

    CorrectFree(strFileCorrect, lpFile);
    CorrectFree(strDirCorrect, lpDirectory);

    return returnValue;
}



/*++
    Convert long command line paths to short paths for GetCommandLineW

--*/

LPCWSTR APIHOOK(GetCommandLineW)()
{

    LPCWSTR wstrCommandLine = ORIGINAL_API(GetCommandLineW)();
    WCHAR * wstrCorrectCommandLine = CorrectPath(wstrCommandLine, "GetCommandLineW", FALSE);
    return wstrCorrectCommandLine;
}


/*++
    Convert long command line paths to short paths for GetCommandLineA

--*/

LPCSTR APIHOOK(GetCommandLineA)()
{
    LPCSTR strCommandLine = ORIGINAL_API(GetCommandLineA)();
    CHAR * strCorrectCommandLine = CorrectPath(strCommandLine, "GetCommandLineA", FALSE);
    return strCorrectCommandLine;
}


/*++

    The PrivateProfile routines treat filenames differently than pathnames.
    If we have Win9xPath corrections enabled, it is possible to "fix" a path
    from .\example.ini to example.ini.  Unfortunately the PrivateProfile routines
    look for example.ini in %windir%
    
    If we have a path that contains path seperators, we must ensure that
    the resulting string also contains path separators.

--*/

char * ProfileCorrectPath(const char * uncorrect, const char * debugMsg, BOOL bMassagePath = g_bW9xPath)
{
    char * strCorrect = CorrectPath(uncorrect, NULL, bMassagePath);

    if (bMassagePath && uncorrect != strCorrect)
    {
        char * returnString = NULL;

        CSTRING_TRY
        {
            CString csUncorrect(uncorrect);
            if (csUncorrect.FindOneOf(L"\\/") >= 0)
            {
                // Found some path separators in the original string, check the corrected string.
                // If the corrected string does  not have any path separators,
                // then the path was corrected from .\example.ini to example.ini

                CString csCorrect(strCorrect);
                if (csCorrect.FindOneOf(L"\\/") < 0)
                {
                    // No path seperators, make this a CWD relative path

                    csCorrect.Insert(0, L".\\");

                    returnString = csCorrect.ReleaseAnsi();
                }
            }
        }
        CSTRING_CATCH
        {
            // Some CString error occured, make sure returnString is NULL
            if (returnString != NULL)
            {
                free(returnString);
            }                      
            returnString = NULL;
        }

        if (returnString)
        {
            CorrectFree(strCorrect, uncorrect);
            strCorrect = returnString;
        }
    }

    if (debugMsg)
    {
        DebugSpew(uncorrect, strCorrect, debugMsg);
    }

    return strCorrect;
}


/*++

    The PrivateProfile routines treat filenames differently than pathnames.
    If we have Win9xPath corrections enabled, it is possible to "fix" a path
    from .\example.ini to example.ini.  Unfortunately the PrivateProfile routines
    look for example.ini in %windir%
    
    If we have a path that contains path seperators, we must ensure that
    the resulting string also contains path separators.

--*/

WCHAR * ProfileCorrectPath(const WCHAR * uncorrect, const char * debugMsg, BOOL bMassagePath = g_bW9xPath)
{
    WCHAR * strCorrect = CorrectPath(uncorrect, NULL, bMassagePath);

    if (bMassagePath && uncorrect != strCorrect)
    {
        WCHAR * returnString = NULL;

        CSTRING_TRY
        {
            CString csUncorrect(uncorrect);
            if (csUncorrect.FindOneOf(L"\\/") >= 0)
            {
                // Found some path separators in the original string, check the corrected string.
                // If the corrected string does  not have any path separators,
                // then the path was corrected from .\example.ini to example.ini

                CString csCorrect(strCorrect);
                if (csCorrect.FindOneOf(L"\\/") < 0)
                {
                    // No path seperators, make this a CWD relative path

                    csCorrect.Insert(0, L".\\");

                    // Manually copy the buffer
                    size_t nBytes = (csCorrect.GetLength() + 1) * sizeof(WCHAR);
                    returnString = (WCHAR*) malloc(nBytes);
                    if (returnString)
                    {
                        memcpy(returnString, csCorrect.Get(), nBytes);
                    }
                }
            }
        }
        CSTRING_CATCH
        {
            // Some CString error occured, make sure returnString is NULL
            if (returnString != NULL)
            {
                free(returnString);
            }                      
            returnString = NULL;
        }

        if (returnString)
        {
            CorrectFree(strCorrect, uncorrect);
            strCorrect = returnString;
        }
    }
 
    if (debugMsg)
    {
        DebugSpew(uncorrect, strCorrect, debugMsg);
    }

    return strCorrect;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileIntA

--*/

UINT APIHOOK(GetPrivateProfileIntA)(
        LPCSTR lpAppName,   // section name
        LPCSTR lpKeyName,   // key name
        INT nDefault,       // return value if key name not found
        LPCSTR lpFileName   // initialization file name
       )
{
    char * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileIntA");

    UINT returnValue = ORIGINAL_API(GetPrivateProfileIntA)(lpAppName, lpKeyName, nDefault, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileIntW

--*/

UINT APIHOOK(GetPrivateProfileIntW)(
        LPCWSTR lpAppName,  // section name
        LPCWSTR lpKeyName,  // key name
        INT nDefault,       // return value if key name not found
        LPCWSTR lpFileName  // initialization file name
       )
{
    WCHAR * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileIntW");

    UINT returnValue = ORIGINAL_API(GetPrivateProfileIntW)(lpAppName, lpKeyName, nDefault, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileSectionA

--*/

DWORD APIHOOK(GetPrivateProfileSectionA)(
        LPCSTR lpAppName,         // section name
        LPSTR lpReturnedString,   // return buffer
        DWORD nSize,              // size of return buffer
        LPCSTR lpFileName         // initialization file name
        )
{
    char * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileSectionA");

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileSectionA)(lpAppName, lpReturnedString, nSize, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileSectionW

--*/

DWORD APIHOOK(GetPrivateProfileSectionW)(
        LPCWSTR lpAppName,         // section name
        LPWSTR lpReturnedString,   // return buffer
        DWORD nSize,              // size of return buffer
        LPCWSTR lpFileName         // initialization file name
        )
{
    WCHAR * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileSectionW");

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileSectionW)(lpAppName, lpReturnedString, nSize, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}


/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileSectionNamesA

--*/

DWORD APIHOOK(GetPrivateProfileSectionNamesA)(
        LPSTR lpszReturnBuffer,  // return buffer
        DWORD nSize,              // size of return buffer
        LPCSTR lpFileName        // initialization file name
        )
{
    char * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileSectionNamesA");

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileSectionNamesA)(lpszReturnBuffer, nSize, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileSectionNamesW

--*/

DWORD APIHOOK(GetPrivateProfileSectionNamesW)(
        LPWSTR lpszReturnBuffer,  // return buffer
        DWORD nSize,              // size of return buffer
        LPCWSTR lpFileName        // initialization file name
        )
{
    WCHAR * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileSectionNamesW");

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileSectionNamesW)(lpszReturnBuffer, nSize, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileSectionNamesA

--*/

DWORD APIHOOK(GetPrivateProfileStringA)(
    LPCSTR lpAppName,        // section name
    LPCSTR lpKeyName,        // key name
    LPCSTR lpDefault,        // default string
    LPSTR lpReturnedString,  // destination buffer
    DWORD nSize,              // size of destination buffer
    LPCSTR lpFileName        // initialization file name
    )
{
    char * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileStringA");

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileStringA)(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileSectionNamesA

--*/

DWORD APIHOOK(GetPrivateProfileStringW)(
    LPCWSTR lpAppName,        // section name
    LPCWSTR lpKeyName,        // key name
    LPCWSTR lpDefault,        // default string
    LPWSTR lpReturnedString,  // destination buffer
    DWORD nSize,              // size of destination buffer
    LPCWSTR lpFileName        // initialization file name
    )
{
    WCHAR * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileStringW");

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileStringW)(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}
/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileStructA

--*/

BOOL APIHOOK(GetPrivateProfileStructA)(
    LPCSTR lpszSection,   // section name
    LPCSTR lpszKey,       // key name
    LPVOID lpStruct,      // return buffer
    UINT uSizeStruct,     // size of return buffer
    LPCSTR lpFileName     // initialization file name
    )
{
    char * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileStructA");

    BOOL returnValue = ORIGINAL_API(GetPrivateProfileStructA)(lpszSection, lpszKey, lpStruct, uSizeStruct, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileStructW

--*/

BOOL APIHOOK(GetPrivateProfileStructW)(
    LPCWSTR lpszSection,   // section name
    LPCWSTR lpszKey,       // key name
    LPVOID lpStruct,      // return buffer
    UINT uSizeStruct,     // size of return buffer
    LPCWSTR lpFileName     // initialization file name
    )
{
    WCHAR * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileStructW");

    BOOL returnValue = ORIGINAL_API(GetPrivateProfileStructW)(lpszSection, lpszKey, lpStruct, uSizeStruct, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileStructA

--*/

BOOL APIHOOK(WritePrivateProfileSectionA)(
    LPCSTR lpAppName,  // section name
    LPCSTR lpString,   // data
    LPCSTR lpFileName  // file name
    )
{
    char * strCorrect = ProfileCorrectPath(lpFileName, "WritePrivateProfileSectionA");

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileSectionA)(lpAppName, lpString, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for WritePrivateProfileSectionW

--*/

BOOL APIHOOK(WritePrivateProfileSectionW)(
    LPCWSTR lpAppName,  // section name
    LPCWSTR lpString,   // data
    LPCWSTR lpFileName  // file name
    )
{
    WCHAR * strCorrect = ProfileCorrectPath(lpFileName, "WritePrivateProfileSectionW");

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileSectionW)(lpAppName, lpString, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for WritePrivateProfileStringA

--*/

BOOL APIHOOK(WritePrivateProfileStringA)(
    LPCSTR lpAppName,  // section name
    LPCSTR lpKeyName,  // key name
    LPCSTR lpString,   // string to add
    LPCSTR lpFileName  // initialization file
    )
{
    char * strCorrect = ProfileCorrectPath(lpFileName, "WritePrivateProfileStringA");

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileStringA)(lpAppName, lpKeyName, lpString, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for WritePrivateProfileStringW

--*/

BOOL APIHOOK(WritePrivateProfileStringW)(
    LPCWSTR lpAppName,  // section name
    LPCWSTR lpKeyName,  // key name
    LPCWSTR lpString,   // string to add
    LPCWSTR lpFileName  // initialization file
    )
{
    WCHAR * strCorrect = ProfileCorrectPath(lpFileName, "WritePrivateProfileStringW");

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileStringW)(lpAppName, lpKeyName, lpString, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for WritePrivateProfileStructA

--*/
BOOL APIHOOK(WritePrivateProfileStructA)(
  LPCSTR lpszSection,  // section name
  LPCSTR lpszKey,      // key name
  LPVOID lpStruct,      // data buffer
  UINT uSizeStruct,     // size of data buffer
  LPCSTR lpFileName        // initialization file
)
{
    char * strCorrect = ProfileCorrectPath(lpFileName, "WritePrivateProfileStructA");

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileStructA)(lpszSection, lpszKey, lpStruct, uSizeStruct, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for WritePrivateProfileStructW

--*/
BOOL APIHOOK(WritePrivateProfileStructW)(
  LPCWSTR lpszSection,  // section name
  LPCWSTR lpszKey,      // key name
  LPVOID lpStruct,      // data buffer
  UINT uSizeStruct,     // size of data buffer
  LPCWSTR lpFileName        // initialization file
)
{
    WCHAR * strCorrect = ProfileCorrectPath(lpFileName, "WritePrivateProfileStructW");

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileStructW)(lpszSection, lpszKey, lpStruct, uSizeStruct, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}
/*++

    Convert Win9x paths to WinNT paths for IShellLinkA::SetArguments

--*/
HRESULT COMHOOK(IShellLinkA, SetArguments)( PVOID pThis, LPCSTR pszArgs )
{
    HRESULT hrReturn = E_FAIL;

    char * strCorrect = CorrectPath(pszArgs, "IShellLinkA::SetArguments", FALSE);

    _pfn_IShellLinkA_SetArguments pfnOld = ORIGINAL_COM(IShellLinkA, SetArguments, pThis);
    if (pfnOld)
        hrReturn = (*pfnOld)( pThis, strCorrect );

    free(strCorrect);
    
    return hrReturn;
}

/*++

    Convert Win9x paths to WinNT paths for IShellLinkW::SetArguments

--*/
HRESULT COMHOOK(IShellLinkW, SetArguments)( PVOID pThis, LPCWSTR pszArgs )
{
    HRESULT hrReturn = E_FAIL;

    WCHAR * strCorrect = CorrectPath(pszArgs, "IShellLinkA::SetArguments", FALSE);

    _pfn_IShellLinkW_SetArguments pfnOld = ORIGINAL_COM(IShellLinkW, SetArguments, pThis);
    if(pfnOld)
        hrReturn = (*pfnOld)( pThis, strCorrect );

    free(strCorrect);

    return hrReturn;
}

/*++

    Convert Win9x paths to WinNT paths for IShellLinkA::SetIconLocation

--*/
HRESULT COMHOOK(IShellLinkA, SetIconLocation)(PVOID pThis, LPCSTR pszIconLocation, int nIcon )
{
    HRESULT hrReturn = E_FAIL;

    char * strCorrect = CorrectPath(pszIconLocation, "IShellLinkA::SetIconLocation");

    _pfn_IShellLinkA_SetIconLocation pfnOld = ORIGINAL_COM(IShellLinkA, SetIconLocation, pThis);
    if (pfnOld)
        hrReturn = (*pfnOld)( pThis, strCorrect, nIcon );

    free(strCorrect);

    return hrReturn;
}

/*++

    Convert Win9x paths to WinNT paths for IShellLinkW::SetIconLocation

--*/
HRESULT COMHOOK(IShellLinkW, SetIconLocation)(PVOID pThis, LPCWSTR pszIconLocation, int nIcon )
{
    HRESULT hrReturn = E_FAIL;

    WCHAR * strCorrect = CorrectPath(pszIconLocation, "IShellLinkW::SetIconLocation");

    _pfn_IShellLinkW_SetIconLocation pfnOld = ORIGINAL_COM(IShellLinkW, SetIconLocation, pThis);
    if(pfnOld)
        hrReturn = (*pfnOld)( pThis, strCorrect, nIcon );

    free(strCorrect);

    return hrReturn;
}

/*++

    Convert Win9x paths to WinNT paths for IShellLinkA::SetPath

--*/
HRESULT COMHOOK(IShellLinkA, SetPath)(PVOID pThis,
                                   LPCSTR pszFile )
{
    HRESULT hrReturn = E_FAIL;

    char * strCorrect = CorrectPath(pszFile, "IShellLinkA::SetPath");

    _pfn_IShellLinkA_SetPath pfnOld = ORIGINAL_COM(IShellLinkA, SetPath, pThis);
    if (pfnOld)
        hrReturn = (*pfnOld)( pThis, strCorrect );

    CorrectFree(strCorrect, pszFile);

    return hrReturn;
}

/*++

    Convert Win9x paths to WinNT paths for IShellLinkW::SetPath

--*/
HRESULT COMHOOK(IShellLinkW, SetPath)(PVOID pThis,
                                   LPCWSTR pszFile )
{
    HRESULT hrReturn = E_FAIL;

    WCHAR * strCorrect = CorrectPath(pszFile, "IShellLinkW::SetPath");

    _pfn_IShellLinkW_SetPath pfnOld = ORIGINAL_COM(IShellLinkW, SetPath, pThis);
    if (pfnOld)
        hrReturn = (*pfnOld)( pThis, strCorrect );

    CorrectFree(strCorrect, pszFile);

    return hrReturn;
}

/*++

    Convert Win9x paths to WinNT paths for IPersistFile::Save

--*/
HRESULT COMHOOK(IPersistFile, Save)(PVOID pThis,
                                  LPCOLESTR pszFileName,
                                  BOOL fRemember)
{
    HRESULT hrReturn = E_FAIL;

    WCHAR * strCorrect = CorrectPath(pszFileName, "IPersistFile_Save");

    _pfn_IPersistFile_Save pfnOld = ORIGINAL_COM(IPersistFile, Save, pThis);
    if (pfnOld)
        hrReturn = (*pfnOld)( pThis, strCorrect, fRemember );

    CorrectFree(strCorrect, pszFileName);

    return hrReturn;
}


BOOL APIHOOK(CopyFileA)(
             LPCSTR lpExistingFileName, // name of an existing file
             LPCSTR lpNewFileName,      // name of new file
             BOOL bFailIfExists          // operation if file exists
)
{
    char * strExistingCorrect = CorrectPath(lpExistingFileName, "CopyFileA");
    char * strNewCorrect      = CorrectPath(lpNewFileName,      "CopyFileA");

    BOOL returnValue = ORIGINAL_API(CopyFileA)(strExistingCorrect, strNewCorrect, bFailIfExists);

    CorrectFree(strExistingCorrect, lpExistingFileName);
    CorrectFree(strNewCorrect, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(CopyFileW)(
             LPCWSTR lpExistingFileName, // name of an existing file
             LPCWSTR lpNewFileName,      // name of new file
             BOOL bFailIfExists          // operation if file exists
)
{
    WCHAR * strExistingCorrect = CorrectPath(lpExistingFileName, "CopyFileW");
    WCHAR * strNewCorrect      = CorrectPath(lpNewFileName,      "CopyFileW");

    BOOL returnValue = ORIGINAL_API(CopyFileW)(strExistingCorrect, strNewCorrect, bFailIfExists);

    CorrectFree(strExistingCorrect, lpExistingFileName);
    CorrectFree(strNewCorrect, lpNewFileName);

    return returnValue;
}


BOOL APIHOOK(CopyFileExA)(
  LPCSTR lpExistingFileName,           // name of existing file
  LPCSTR lpNewFileName,                // name of new file
  LPPROGRESS_ROUTINE lpProgressRoutine, // callback function
  LPVOID lpData,                        // callback parameter
  LPBOOL pbCancel,                      // cancel status
  DWORD dwCopyFlags                     // copy options
)
{
    char * strExistingCorrect = CorrectPath(lpExistingFileName, "CopyFileExA");
    char * strNewCorrect      = CorrectPath(lpNewFileName,      "CopyFileExA");

    BOOL returnValue = ORIGINAL_API(CopyFileExA)(strExistingCorrect, strNewCorrect, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);

    CorrectFree(strExistingCorrect, lpExistingFileName);
    CorrectFree(strNewCorrect, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(CopyFileExW)(
  LPCWSTR lpExistingFileName,           // name of existing file
  LPCWSTR lpNewFileName,                // name of new file
  LPPROGRESS_ROUTINE lpProgressRoutine, // callback function
  LPVOID lpData,                        // callback parameter
  LPBOOL pbCancel,                      // cancel status
  DWORD dwCopyFlags                     // copy options
)
{
    WCHAR * strExistingCorrect = CorrectPath(lpExistingFileName, "CopyFileExW");
    WCHAR * strNewCorrect      = CorrectPath(lpNewFileName,      "CopyFileExW");

    BOOL returnValue = ORIGINAL_API(CopyFileExW)(strExistingCorrect, strNewCorrect, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);

    CorrectFree(strExistingCorrect, lpExistingFileName);
    CorrectFree(strNewCorrect, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(CreateDirectoryA)(
  LPCSTR lpPathName,                         // directory name
  LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
)
{
    char * strCorrect = CorrectPath(lpPathName, "CreateDirectoryA");

    BOOL returnValue = ORIGINAL_API(CreateDirectoryA)(strCorrect, lpSecurityAttributes);

    CorrectFree(strCorrect, lpPathName);

    return returnValue;
}

BOOL APIHOOK(CreateDirectoryW)(
  LPCWSTR lpPathName,                         // directory name
  LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
)
{
    WCHAR * strCorrect = CorrectPath(lpPathName, "CreateDirectoryW");

    BOOL returnValue = ORIGINAL_API(CreateDirectoryW)(strCorrect, lpSecurityAttributes);

    CorrectFree(strCorrect, lpPathName);

    return returnValue;
}

BOOL APIHOOK(CreateDirectoryExA)(
  LPCSTR lpTemplateDirectory,               // template directory
  LPCSTR lpNewDirectory,                    // directory name
  LPSECURITY_ATTRIBUTES lpSecurityAttributes // SD
)
{
    char * strTemplateCorrect = CorrectPath(lpTemplateDirectory, "CreateDirectoryExA");
    char * strNewCorrect      = CorrectPath(lpNewDirectory,      "CreateDirectoryExA");

    BOOL returnValue = ORIGINAL_API(CreateDirectoryExA)(strTemplateCorrect, strNewCorrect, lpSecurityAttributes);

    CorrectFree(strTemplateCorrect, lpTemplateDirectory);
    CorrectFree(strNewCorrect, lpNewDirectory);

    return returnValue;
}

BOOL APIHOOK(CreateDirectoryExW)(
  LPCWSTR lpTemplateDirectory,               // template directory
  LPCWSTR lpNewDirectory,                    // directory name
  LPSECURITY_ATTRIBUTES lpSecurityAttributes // SD
)
{
    WCHAR * strTemplateCorrect = CorrectPath(lpTemplateDirectory, "CreateDirectoryExW");
    WCHAR * strNewCorrect      = CorrectPath(lpNewDirectory,      "CreateDirectoryExW");

    BOOL returnValue = ORIGINAL_API(CreateDirectoryExW)(strTemplateCorrect, strNewCorrect, lpSecurityAttributes);

    CorrectFree(strTemplateCorrect, lpTemplateDirectory);
    CorrectFree(strNewCorrect, lpNewDirectory);

    return returnValue;
}

HANDLE APIHOOK(CreateFileA)(
  LPCSTR lpFileName,                         // file name
  DWORD dwDesiredAccess,                      // access mode
  DWORD dwShareMode,                          // share mode
  LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
  DWORD dwCreationDisposition,                // how to create
  DWORD dwFlagsAndAttributes,                 // file attributes
  HANDLE hTemplateFile                        // handle to template file
)
{
    char * strCorrect = CorrectPath(lpFileName, "CreateFileA");

    HANDLE returnValue = ORIGINAL_API(CreateFileA)(strCorrect,
                dwDesiredAccess,
                dwShareMode,
                lpSecurityAttributes,
                dwCreationDisposition,
                dwFlagsAndAttributes,
                hTemplateFile);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

HANDLE APIHOOK(CreateFileW)(
  LPCWSTR lpFileName,                         // file name
  DWORD dwDesiredAccess,                      // access mode
  DWORD dwShareMode,                          // share mode
  LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
  DWORD dwCreationDisposition,                // how to create
  DWORD dwFlagsAndAttributes,                 // file attributes
  HANDLE hTemplateFile                        // handle to template file
)
{
    WCHAR * strCorrect = CorrectPath(lpFileName, "CreateFileW");

    HANDLE returnValue = ORIGINAL_API(CreateFileW)(
                strCorrect,
                dwDesiredAccess,
                dwShareMode,
                lpSecurityAttributes,
                dwCreationDisposition,
                dwFlagsAndAttributes,
                hTemplateFile);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

BOOL APIHOOK(DeleteFileA)(
  LPCSTR lpFileName   // file name
)
{
    char * strCorrect = CorrectPath(lpFileName, "DeleteFileA");

    BOOL returnValue = ORIGINAL_API(DeleteFileA)(strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

BOOL APIHOOK(DeleteFileW)(

  LPCWSTR lpFileName   // file name
)
{
    WCHAR * strCorrect = CorrectPath(lpFileName, "DeleteFileW");

    BOOL returnValue = ORIGINAL_API(DeleteFileW)(strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}


/*++

    Win9xPath corrections will strip a trailing . from the end of a search string.
    As a path, the . is not significant, but as a wildcard it is important--the
    difference between finding files without an extension and finding all files
    in the directory.

--*/

char * FindFirstFileCorrectPath(const char * uncorrect, const char * debugMsg, BOOL bMassagePath = g_bW9xPath)
{
    char * strCorrect = CorrectPath(uncorrect, NULL, bMassagePath);

    if (bMassagePath && uncorrect != strCorrect)
    {
        char * returnString = NULL;

        CSTRING_TRY
        {
            CString csUncorrect(uncorrect);
            CString csCorrect(strCorrect);

            CString csUncorrectLast;
            CString csCorrectLast;

            csUncorrect.GetLastPathComponent(csUncorrectLast);
            csCorrect.GetLastPathComponent(csCorrectLast);

            if (csUncorrectLast.Compare(L"*.") == 0 && csCorrectLast.Compare(L"*") == 0)
            {
                csCorrectLast += L".";
                returnString = csCorrectLast.ReleaseAnsi();
            }
        }
        CSTRING_CATCH
        {
            // Some CString error occured, make sure returnString is NULL
            if (returnString != NULL)
            {
                free(returnString);
            }                      
            returnString = NULL;
        }

        if (returnString)
        {
            CorrectFree(strCorrect, uncorrect);
            strCorrect = returnString;
        }
    }

    if (debugMsg)
    {
        DebugSpew(uncorrect, strCorrect, debugMsg);
    }

    return strCorrect;
}

/*++

    Win9xPath corrections will strip a trailing . from the end of a search string.
    As a path, the . is not significant, but as a wildcard it is important--the
    difference between finding files without an extension and finding all files
    in the directory.

--*/

WCHAR * FindFirstFileCorrectPath(const WCHAR * uncorrect, const char * debugMsg, BOOL bMassagePath = g_bW9xPath)
{
    WCHAR * strCorrect = CorrectPath(uncorrect, NULL, bMassagePath);

    if (bMassagePath && uncorrect != strCorrect)
    {
        WCHAR * returnString = NULL;

        CSTRING_TRY
        {
            CString csUncorrect(uncorrect);
            CString csCorrect(strCorrect);

            CString csUncorrectLast;
            CString csCorrectLast;

            csUncorrect.GetLastPathComponent(csUncorrectLast);
            csCorrect.GetLastPathComponent(csCorrectLast);

            if (csUncorrectLast.Compare(L"*.") == 0 && csCorrectLast.Compare(L"*") == 0)
            {
                csCorrectLast += L".";

                // Manually copy the buffer
                size_t nBytes = (csCorrectLast.GetLength() + 1) * sizeof(WCHAR);
                returnString = (WCHAR*) malloc(nBytes);
                if (returnString)
                {
                    memcpy(returnString, csCorrectLast.Get(), nBytes);
                }
            }
        }
        CSTRING_CATCH
        {
            // Some CString error occured, make sure returnString is NULL
            if (returnString != NULL)
            {
                free(returnString);
            }                      
            returnString = NULL;
        }

        if (returnString)
        {
            CorrectFree(strCorrect, uncorrect);
            strCorrect = returnString;
        }
    }

    if (debugMsg)
    {
        DebugSpew(uncorrect, strCorrect, debugMsg);
    }

    return strCorrect;
}

HANDLE APIHOOK(FindFirstFileA)(
  LPCSTR lpFileName,               // file name
  LPWIN32_FIND_DATAA lpFindFileData  // data buffer
)
{
    char * strCorrect = FindFirstFileCorrectPath(lpFileName, "FindFirstFileA");

    HANDLE returnValue = ORIGINAL_API(FindFirstFileA)(strCorrect, lpFindFileData);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

HANDLE APIHOOK(FindFirstFileW)(
  LPCWSTR lpFileName,               // file name
  LPWIN32_FIND_DATAW lpFindFileData  // data buffer
)
{
    WCHAR * strCorrect = FindFirstFileCorrectPath(lpFileName, "FindFirstFileW");

    HANDLE returnValue = ORIGINAL_API(FindFirstFileW)(strCorrect, lpFindFileData);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

HANDLE APIHOOK(FindFirstFileExA)(
  LPCSTR lpFileName,              // file name
  FINDEX_INFO_LEVELS fInfoLevelId, // information level
  LPVOID lpFindFileData,           // information buffer
  FINDEX_SEARCH_OPS fSearchOp,     // filtering type
  LPVOID lpSearchFilter,           // search criteria
  DWORD dwAdditionalFlags          // additional search control
)
{
    char * strCorrect = FindFirstFileCorrectPath(lpFileName, "FindFirstFileExA");

    HANDLE returnValue = ORIGINAL_API(FindFirstFileExA)(
                        strCorrect,
                        fInfoLevelId,
                        lpFindFileData,
                        fSearchOp,
                        lpSearchFilter,
                        dwAdditionalFlags);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

HANDLE APIHOOK(FindFirstFileExW)(
  LPCWSTR lpFileName,              // file name
  FINDEX_INFO_LEVELS fInfoLevelId, // information level
  LPVOID lpFindFileData,           // information buffer
  FINDEX_SEARCH_OPS fSearchOp,     // filtering type
  LPVOID lpSearchFilter,           // search criteria
  DWORD dwAdditionalFlags          // additional search control
)
{
    WCHAR * strCorrect = FindFirstFileCorrectPath(lpFileName, "FindFirstFileExW");

    HANDLE returnValue = ORIGINAL_API(FindFirstFileExW)(
                        strCorrect,
                        fInfoLevelId,
                        lpFindFileData,
                        fSearchOp,
                        lpSearchFilter,
                        dwAdditionalFlags);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

BOOL APIHOOK(GetBinaryTypeA)(
  LPCSTR lpApplicationName,  // full file path
  LPDWORD lpBinaryType        // binary type information
)
{
    char * strCorrect = CorrectPath(lpApplicationName, "GetBinaryTypeA");

    BOOL returnValue = ORIGINAL_API(GetBinaryTypeA)(strCorrect, lpBinaryType);

    CorrectFree(strCorrect, lpApplicationName);

    return returnValue;
}

BOOL APIHOOK(GetBinaryTypeW)(
  LPCWSTR lpApplicationName,  // full file path
  LPDWORD lpBinaryType        // binary type information
)
{
    WCHAR * strCorrect = CorrectPath(lpApplicationName, "GetBinaryTypeW");

    BOOL returnValue = ORIGINAL_API(GetBinaryTypeW)(strCorrect, lpBinaryType);

    CorrectFree(strCorrect, lpApplicationName);

    return returnValue;
}

BOOL APIHOOK(MoveFileA)(
  LPCSTR lpExistingFileName, // file name
  LPCSTR lpNewFileName       // new file name
)
{
    char * strCorrectExisting = CorrectPath(lpExistingFileName, "MoveFileA");
    char * strCorrectNew      = CorrectPath(lpNewFileName, "MoveFileA");

    BOOL returnValue = ORIGINAL_API(MoveFileA)(strCorrectExisting, strCorrectNew);

    CorrectFree(strCorrectExisting, lpExistingFileName);
    CorrectFree(strCorrectNew, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(MoveFileW)(
  LPCWSTR lpExistingFileName, // file name
  LPCWSTR lpNewFileName       // new file name
)
{
    WCHAR * strCorrectExisting = CorrectPath(lpExistingFileName, "MoveFileW");
    WCHAR * strCorrectNew      = CorrectPath(lpNewFileName, "MoveFileW");

    BOOL returnValue = ORIGINAL_API(MoveFileW)(strCorrectExisting, strCorrectNew);

    CorrectFree(strCorrectExisting, lpExistingFileName);
    CorrectFree(strCorrectNew, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(MoveFileExA)(
  LPCSTR lpExistingFileName,  // file name
  LPCSTR lpNewFileName,       // new file name
  DWORD dwFlags                // move options
)
{
    char * strCorrectExisting = CorrectPath(lpExistingFileName, "MoveFileExA");
    char * strCorrectNew      = CorrectPath(lpNewFileName, "MoveFileExA");

    BOOL returnValue = ORIGINAL_API(MoveFileExA)(strCorrectExisting, strCorrectNew, dwFlags);

    CorrectFree(strCorrectExisting, lpExistingFileName);
    CorrectFree(strCorrectNew, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(MoveFileExW)(
  LPCWSTR lpExistingFileName,  // file name
  LPCWSTR lpNewFileName,       // new file name
  DWORD dwFlags                // move options
)
{
    WCHAR * strCorrectExisting = CorrectPath(lpExistingFileName, "MoveFileExW");
    WCHAR * strCorrectNew      = CorrectPath(lpNewFileName, "MoveFileExW");

    BOOL returnValue = ORIGINAL_API(MoveFileExW)(strCorrectExisting, strCorrectNew, dwFlags);

    CorrectFree(strCorrectExisting, lpExistingFileName);
    CorrectFree(strCorrectNew, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(MoveFileWithProgressA)(
  LPCSTR lpExistingFileName,            // file name
  LPCSTR lpNewFileName,                 // new file name
  LPPROGRESS_ROUTINE lpProgressRoutine,  // callback function
  LPVOID lpData,                         // parameter for callback
  DWORD dwFlags                          // move options
)
{
    char * strCorrectExisting = CorrectPath(lpExistingFileName, "MoveFileWithProgressA");
    char * strCorrectNew      = CorrectPath(lpNewFileName, "MoveFileWithProgressA");

    BOOL returnValue = ORIGINAL_API(MoveFileWithProgressA)(strCorrectExisting, strCorrectNew, lpProgressRoutine, lpData, dwFlags);

    CorrectFree(strCorrectExisting, lpExistingFileName);
    CorrectFree(strCorrectNew, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(MoveFileWithProgressW)(
  LPCWSTR lpExistingFileName,            // file name
  LPCWSTR lpNewFileName,                 // new file name
  LPPROGRESS_ROUTINE lpProgressRoutine,  // callback function
  LPVOID lpData,                         // parameter for callback
  DWORD dwFlags                          // move options
)
{
    WCHAR * strCorrectExisting = CorrectPath(lpExistingFileName, "MoveFileW");
    WCHAR * strCorrectNew      = CorrectPath(lpNewFileName, "MoveFileW");

    BOOL returnValue = ORIGINAL_API(MoveFileWithProgressW)(strCorrectExisting, strCorrectNew, lpProgressRoutine, lpData, dwFlags);

    CorrectFree(strCorrectExisting, lpExistingFileName);
    CorrectFree(strCorrectNew, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(RemoveDirectoryA)(
  LPCSTR lpPathName   // directory name
)
{
    char * strCorrect = CorrectPath(lpPathName, "RemoveDirectoryA");

    BOOL returnValue = ORIGINAL_API(RemoveDirectoryA)(strCorrect);

    CorrectFree(strCorrect, lpPathName);

    return returnValue;
}

BOOL APIHOOK(RemoveDirectoryW)(
  LPCWSTR lpPathName   // directory name
)
{
    WCHAR * strCorrect = CorrectPath(lpPathName, "RemoveDirectoryW");

    BOOL returnValue = ORIGINAL_API(RemoveDirectoryW)(strCorrect);

    CorrectFree(strCorrect, lpPathName);

    return returnValue;
}

BOOL APIHOOK(SetCurrentDirectoryA)(
  LPCSTR lpPathName   // new directory name
)
{
    char * strCorrect = CorrectPath(lpPathName, "SetCurrentDirectoryA");

    BOOL returnValue = ORIGINAL_API(SetCurrentDirectoryA)(strCorrect);

    CorrectFree(strCorrect, lpPathName);

    return returnValue;
}

BOOL APIHOOK(SetCurrentDirectoryW)(
  LPCWSTR lpPathName   // new directory name
)
{
    WCHAR * strCorrect = CorrectPath(lpPathName, "SetCurrentDirectoryW");

    BOOL returnValue = ORIGINAL_API(SetCurrentDirectoryW)(strCorrect);

    CorrectFree(strCorrect, lpPathName);

    return returnValue;
}

HFILE APIHOOK(OpenFile)(
  LPCSTR lpFileName,        // file name
  LPOFSTRUCT lpReOpenBuff,  // file information
  UINT uStyle               // action and attributes
)
{
    char * strCorrect = CorrectPath(lpFileName, "OpenFile");

    HFILE returnValue = ORIGINAL_API(OpenFile)(strCorrect, lpReOpenBuff, uStyle);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

LONG APIHOOK(RegSetValueA)(
  HKEY hKey,         // handle to key
  LPCSTR lpSubKey,  // subkey name
  DWORD dwType,      // information type
  LPCSTR lpData,    // value data
  DWORD cbData       // size of value data
)
{
    char * strCorrect = CorrectPath(lpData, "RegSetValueA", FALSE);

    // Data key is length of string *not* including null byte.
    if (strCorrect)
    {
        cbData = strlen(strCorrect);
    }

    LONG returnValue = ORIGINAL_API(RegSetValueA)(hKey, lpSubKey, dwType, strCorrect, cbData);

    CorrectFree(strCorrect, lpData);

    return returnValue;
}

LONG APIHOOK(RegSetValueW)(
  HKEY hKey,         // handle to key
  LPCWSTR lpSubKey,  // subkey name
  DWORD dwType,      // information type
  LPCWSTR lpData,    // value data
  DWORD cbData       // size of value data
)
{
    WCHAR * strCorrect = CorrectPath(lpData, "RegSetValueW", FALSE);

    // Data key is length of string *not* including null byte.
    if (strCorrect)
        cbData = wcslen(strCorrect);

    LONG returnValue = ORIGINAL_API(RegSetValueW)(hKey, lpSubKey, dwType, strCorrect, cbData);

    CorrectFree(strCorrect, lpData);

    return returnValue;
}

LONG APIHOOK(RegSetValueExA)(
  HKEY hKey,           // handle to key
  LPCSTR lpValueName, // value name
  DWORD Reserved,      // reserved
  DWORD dwType,        // value type
  CONST BYTE *lpData,  // value data
  DWORD cbData         // size of value data
)
{
    if (dwType == REG_SZ)
    {
        char * strCorrect = CorrectPath((const char *)lpData, "RegSetValueExA", FALSE);

        // Data key is length of string *not* including null byte.
        if (strCorrect)
        {
            cbData = strlen(strCorrect);
        }

        LONG returnValue = ORIGINAL_API(RegSetValueExA)(
                hKey,           // handle to key
                lpValueName, // value name
                Reserved,      // reserved
                dwType,        // value type
                (CONST BYTE *)strCorrect,  // value data
                cbData);
        CorrectFree(strCorrect, (const char *)lpData);

        return returnValue;
    }
    else
    {
        // Pass data on through
        LONG returnValue = ORIGINAL_API(RegSetValueExA)(
                hKey,           // handle to key
                lpValueName, // value name
                Reserved,      // reserved
                dwType,        // value type
                lpData,  // value data
                cbData);
        return returnValue;
    }
}

LONG APIHOOK(RegSetValueExW)(
  HKEY hKey,           // handle to key
  LPCWSTR lpValueName, // value name
  DWORD Reserved,      // reserved
  DWORD dwType,        // value type
  CONST BYTE *lpData,  // value data
  DWORD cbData         // size of value data
)
{
    if (dwType == REG_SZ)
    {
        WCHAR * strCorrect = CorrectPath((const WCHAR*)lpData, "RegSetValueExW", FALSE);

        // Data key is length of string *not* including null byte.
        if (strCorrect)
            cbData = wcslen(strCorrect);

        LONG returnValue = ORIGINAL_API(RegSetValueExW)(
                hKey,           // handle to key
                lpValueName, // value name
                Reserved,      // reserved
                dwType,        // value type
                (CONST BYTE *)strCorrect,  // value data
                cbData);
        CorrectFree(strCorrect, (const WCHAR *)lpData);

        return returnValue;
    }
    else
    {
        // Pass data on through
        LONG returnValue = ORIGINAL_API(RegSetValueExW)(
                hKey,           // handle to key
                lpValueName, // value name
                Reserved,      // reserved
                dwType,        // value type
                lpData,  // value data
                cbData);
        return returnValue;
    }
}

HFILE APIHOOK(_lopen)(
    LPCSTR lpPathName,
    int iReadWrite
    )
{
    char * strCorrect = CorrectPath(lpPathName, "lopen");

    HFILE returnValue = ORIGINAL_API(_lopen)(strCorrect, iReadWrite);

    CorrectFree(strCorrect, lpPathName);

    return returnValue;    
}

HFILE APIHOOK(_lcreat)(
    LPCSTR lpPathName,
    int iAttribute
    )
{
    char * strCorrect = CorrectPath(lpPathName, "lcreat");

    HFILE returnValue = ORIGINAL_API(_lcreat)(strCorrect, iAttribute);

    CorrectFree(strCorrect, lpPathName);

    return returnValue;    
}

HANDLE 
APIHOOK(LoadImageA)(
    HINSTANCE hinst,   // handle to instance
    LPCSTR lpszName,   // name or identifier of the image
    UINT uType,        // image type
    int cxDesired,     // desired width
    int cyDesired,     // desired height
    UINT fuLoad        // load options
    )
{
    HANDLE returnValue = NULL;

    // Another one of those incredibly overloaded API's:
    // lpszName is not always a path
    if ((uType == IMAGE_BITMAP)    &&
        (fuLoad & LR_LOADFROMFILE) &&
        !IsBadStringPtrA(lpszName, MAX_PATH))
    {
        char * strCorrect = CorrectPath(lpszName, "LoadImageA");

        returnValue = ORIGINAL_API(LoadImageA)(hinst, strCorrect, uType, cxDesired, cyDesired, fuLoad);

        CorrectFree(strCorrect, lpszName);
    }
    else
    {
        returnValue = ORIGINAL_API(LoadImageA)(hinst, lpszName, uType, cxDesired, cyDesired, fuLoad);
    }

    return returnValue;    
}



IMPLEMENT_COMSERVER_HOOK(SHELL32)

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    BOOL bSuccess = TRUE;

    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        bSuccess = ParseCommandLine(COMMAND_LINE);
    }
    else if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) 
    {
        g_bShimsInitialized = TRUE;
    }
    return bSuccess;
}

/*++

  Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    if (g_bCreateProcessRoutines)
    {
        APIHOOK_ENTRY(KERNEL32.DLL,                   CreateProcessA)
        APIHOOK_ENTRY(KERNEL32.DLL,                   CreateProcessW)
        APIHOOK_ENTRY(KERNEL32.DLL,                          WinExec)

        APIHOOK_ENTRY(SHELL32.DLL,                     ShellExecuteA)
        APIHOOK_ENTRY(SHELL32.DLL,                     ShellExecuteW)
        APIHOOK_ENTRY(SHELL32.DLL,                   ShellExecuteExA)
        APIHOOK_ENTRY(SHELL32.DLL,                   ShellExecuteExW)
    }

    if (g_bGetCommandLineRoutines)
    {
        APIHOOK_ENTRY(KERNEL32.DLL,                  GetCommandLineA)
        APIHOOK_ENTRY(KERNEL32.DLL,                  GetCommandLineW)
    }

    if (g_bProfileRoutines)
    {
        APIHOOK_ENTRY(KERNEL32.DLL,            GetPrivateProfileIntA)
        APIHOOK_ENTRY(KERNEL32.DLL,            GetPrivateProfileIntW)
        APIHOOK_ENTRY(KERNEL32.DLL,        GetPrivateProfileSectionA)
        APIHOOK_ENTRY(KERNEL32.DLL,        GetPrivateProfileSectionW)
        APIHOOK_ENTRY(KERNEL32.DLL,   GetPrivateProfileSectionNamesA)
        APIHOOK_ENTRY(KERNEL32.DLL,   GetPrivateProfileSectionNamesW)
        APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileStringA)
        APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileStringW)
        APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileStructA)
        APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileStructW)
        APIHOOK_ENTRY(KERNEL32.DLL,      WritePrivateProfileSectionA)
        APIHOOK_ENTRY(KERNEL32.DLL,      WritePrivateProfileSectionW)
        APIHOOK_ENTRY(KERNEL32.DLL,       WritePrivateProfileStringA)
        APIHOOK_ENTRY(KERNEL32.DLL,       WritePrivateProfileStringW)
        APIHOOK_ENTRY(KERNEL32.DLL,       WritePrivateProfileStructA)
        APIHOOK_ENTRY(KERNEL32.DLL,       WritePrivateProfileStructW)
    }

    if (g_bFileRoutines)
    {
        APIHOOK_ENTRY(KERNEL32.DLL,                        CopyFileA)
        APIHOOK_ENTRY(KERNEL32.DLL,                        CopyFileW)
        APIHOOK_ENTRY(KERNEL32.DLL,                      CopyFileExA)
        APIHOOK_ENTRY(KERNEL32.DLL,                      CopyFileExW)
        APIHOOK_ENTRY(KERNEL32.DLL,                 CreateDirectoryA)
        APIHOOK_ENTRY(KERNEL32.DLL,                 CreateDirectoryW)
        APIHOOK_ENTRY(KERNEL32.DLL,               CreateDirectoryExA)
        APIHOOK_ENTRY(KERNEL32.DLL,               CreateDirectoryExW)

        APIHOOK_ENTRY(KERNEL32.DLL,                      CreateFileA)
        APIHOOK_ENTRY(KERNEL32.DLL,                      CreateFileW)
        APIHOOK_ENTRY(KERNEL32.DLL,                      DeleteFileA)
        APIHOOK_ENTRY(KERNEL32.DLL,                      DeleteFileW)

        APIHOOK_ENTRY(KERNEL32.DLL,                   FindFirstFileA)
        APIHOOK_ENTRY(KERNEL32.DLL,                   FindFirstFileW)
        APIHOOK_ENTRY(KERNEL32.DLL,                 FindFirstFileExA)
        APIHOOK_ENTRY(KERNEL32.DLL,                 FindFirstFileExW)

        APIHOOK_ENTRY(KERNEL32.DLL,                   GetBinaryTypeA)
        APIHOOK_ENTRY(KERNEL32.DLL,                   GetBinaryTypeW)
        APIHOOK_ENTRY(KERNEL32.DLL,               GetFileAttributesA)
        APIHOOK_ENTRY(KERNEL32.DLL,               GetFileAttributesW)
        APIHOOK_ENTRY(KERNEL32.DLL,             GetFileAttributesExA)
        APIHOOK_ENTRY(KERNEL32.DLL,             GetFileAttributesExW)
        APIHOOK_ENTRY(KERNEL32.DLL,               SetFileAttributesA)
        APIHOOK_ENTRY(KERNEL32.DLL,               SetFileAttributesW)

        APIHOOK_ENTRY(KERNEL32.DLL,                        MoveFileA)
        APIHOOK_ENTRY(KERNEL32.DLL,                        MoveFileW)
        APIHOOK_ENTRY(KERNEL32.DLL,                      MoveFileExA)
        APIHOOK_ENTRY(KERNEL32.DLL,                      MoveFileExW)
        APIHOOK_ENTRY(KERNEL32.DLL,            MoveFileWithProgressA)
        APIHOOK_ENTRY(KERNEL32.DLL,            MoveFileWithProgressW)

        APIHOOK_ENTRY(KERNEL32.DLL,                 RemoveDirectoryA)
        APIHOOK_ENTRY(KERNEL32.DLL,                 RemoveDirectoryW)
        APIHOOK_ENTRY(KERNEL32.DLL,             SetCurrentDirectoryA)
        APIHOOK_ENTRY(KERNEL32.DLL,             SetCurrentDirectoryW)

        APIHOOK_ENTRY(KERNEL32.DLL,                         OpenFile)
    
        // 16 bit compatibility file routines
        APIHOOK_ENTRY(KERNEL32.DLL,                         _lopen)
        APIHOOK_ENTRY(KERNEL32.DLL,                         _lcreat)
    }

    if (g_bRegSetValueRoutines)
    {
        APIHOOK_ENTRY(ADVAPI32.DLL,                     RegSetValueA)
        APIHOOK_ENTRY(ADVAPI32.DLL,                     RegSetValueW)
        APIHOOK_ENTRY(ADVAPI32.DLL,                   RegSetValueExA)
        APIHOOK_ENTRY(ADVAPI32.DLL,                   RegSetValueExW)
    }

    if (g_bShellLinkRoutines)
    {
        APIHOOK_ENTRY_COMSERVER(SHELL32)

        COMHOOK_ENTRY(ShellLink, IShellLinkA, SetPath, 20)
        COMHOOK_ENTRY(ShellLink, IShellLinkW, SetPath, 20)
        COMHOOK_ENTRY(ShellLink, IShellLinkA, SetArguments, 11)
        COMHOOK_ENTRY(ShellLink, IShellLinkW, SetArguments, 11)
        COMHOOK_ENTRY(ShellLink, IShellLinkA, SetIconLocation, 17)
        COMHOOK_ENTRY(ShellLink, IShellLinkW, SetIconLocation, 17)

        COMHOOK_ENTRY(ShellLink, IPersistFile, Save, 6)
    }

    if (g_bLoadImage)
    {
        APIHOOK_ENTRY(USER32.DLL, LoadImageA)
    }

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\inc\tcs.h ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    tcs.h

 Abstract:
    Overload the TCS routines to allow simultaneous use of bot char and WCHAR versions

 History:

    02/22/2001   robkenny     Created
    
--*/

#pragma once


#ifdef TCHAR
#pragma message( "TCHAR is defined.  Do not include TCHAR.H" )
#endif


#include <stdio.h> // for _vsnwprintf

#include "LegalStr.h"

// Overload the _tcs routines to automatically handle Ansi/MBCS or UNICODE

// Crystal clear replacement routines
inline       size_t   _tcslenBytes(const char  * s1)                                { return strlen(s1); }
inline       size_t   _tcslenChars(const char  * s1)                                
{
    const char * send = s1;
    while (*send)
    {
        // Can't use CharNextA, since User32 might not be initialized
        if (IsDBCSLeadByte(*send))
        {
            ++send;
        }
        ++send;
    }
    return send - s1;
}
inline       size_t   _tcslenBytes(const WCHAR * s1)                                { return wcslen(s1) * sizeof(WCHAR); }
inline       size_t   _tcslenChars(const WCHAR * s1)                                { return wcslen(s1); }


// Allow these routines
inline       char *  _tcscpy  (      char *s1, const  char *s2)                     { return strcpy(s1, s2); }
inline       char *  _tcsncpy (      char *s1, const char *s2, size_t count )       { return strncpy(s1, s2, count); }
inline       int     _tcsicmp (const char * s1, const char * s2)                    { return _stricmp(s1, s2); }



inline       int     _tcscmp  (const WCHAR * s1, const WCHAR * s2)                  { return           wcscmp(s1, s2); }
inline       int     _tcsncmp (const WCHAR * s1, const WCHAR * s2, size_t count )   { return           wcsncmp(s1, s2, count); }
inline       int     _tcsnicmp (const WCHAR * s1, const WCHAR * s2, size_t count )  { return           _wcsnicmp(s1, s2, count); }
inline       int     _tcsicmp (const WCHAR * s1, const WCHAR * s2)                  { return           _wcsicmp(s1, s2); }
inline       int     _tcscoll (const WCHAR * s1, const WCHAR * s2)                  { return           wcscoll(s1, s2); }
inline       int     _tcsicoll(const WCHAR * s1, const WCHAR * s2)                  { return           _wcsicoll(s1, s2); }
inline const WCHAR * _tcschr  (const WCHAR * s1,       WCHAR ch)                    { return           wcschr(s1, ch); }
inline       WCHAR * _tcschr  (      WCHAR * s1,       WCHAR ch)                    { return           wcschr(s1, ch); }
inline const WCHAR * _tcspbrk (const WCHAR * s1, const WCHAR * s2)                  { return           wcspbrk(s1, s2); }
inline       WCHAR * _tcspbrk (      WCHAR * s1, const WCHAR * s2)                  { return           wcspbrk(s1, s2); }
inline       WCHAR * _tcsupr  (      WCHAR * s1)                                    { return           _wcsupr(s1); }
inline       WCHAR * _tcslwr  (      WCHAR * s1)                                    { return           _wcslwr(s1); }
inline       WCHAR * _tcsrev  (      WCHAR * s1)                                    { return           _wcsrev(s1); }
inline const WCHAR * _tcsinc  (const WCHAR * s1)                                    { return           (s1) + 1; }
inline       WCHAR * _tcsinc  (      WCHAR * s1)                                    { return           (s1) + 1; }
inline const WCHAR * _tcsstr  (const WCHAR * s1, const WCHAR * s2)                  { return           wcsstr(s1, s2); }
inline       WCHAR * _tcsstr  (      WCHAR * s1, const WCHAR * s2)                  { return           wcsstr(s1, s2); }
inline       size_t  _tcsspn  (const WCHAR * s1, const WCHAR * s2)                  { return           wcsspn(s1, s2); }
inline       size_t  _tcscspn (const WCHAR * s1, const WCHAR * s2)                  { return           wcscspn(s1, s2); }
inline const WCHAR * _tcsrchr (      WCHAR * s1, WCHAR ch)                          { return           wcsrchr(s1, ch); }
inline       WCHAR * _tcsrchr (const WCHAR * s1, WCHAR ch)                          { return           wcsrchr(s1, ch); }
inline       size_t  _tclen   (const WCHAR * /*s1*/)                                { return           1; }
inline       size_t  _tcslen  (const WCHAR * s1)                                    { return           _tcslenChars(s1); }
inline       int     _ttoi    (const WCHAR * s1)                                    { return           _wtoi(s1); } 
inline       int     _istspace(      WCHAR ch)                                      { return           iswspace(ch); }
inline       int     _istdigit(      WCHAR ch)                                      { return           iswdigit(ch); }
inline       WCHAR * _tcsncpy (      WCHAR *s1, const WCHAR *s2, size_t count )     { return           wcsncpy(s1, s2, count); }
inline       WCHAR * _tcscpy  (     WCHAR *s1, const WCHAR *s2)                     { return wcscpy(s1, s2); }

inline       int     _tcsnprintf(WCHAR *buffer, size_t count, const WCHAR *format, va_list argptr) { return _vsnwprintf(buffer, count, format, argptr); }

inline       BOOL    IsPathSep(WCHAR ch)                                            { return ch ==  L'\\' || ch ==  L'/'; }


#include "MakeIllegalStr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\correctbitmapheader.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    CorrectBitmapHeader.cpp

 Abstract:
    If a BITMAPINFOHEADER specifies a non BI_RGB value for biCompression, it
    is supposed to specify a non zero biSizeImage.

 Notes:

    This is a general purpose shim.

 History:

    10/18/2000  maonis      Created
    03/15/2001  robkenny    Converted to CString

--*/

#include "precomp.h"
#include <userenv.h>

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(CorrectBitmapHeader)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadImageA)
    APIHOOK_ENUM_ENTRY(LoadBitmapA)
APIHOOK_ENUM_END

typedef HBITMAP (*_pfn_LoadBitmapA)(HINSTANCE hinst, LPCSTR lpszName);

/*++

 Function Description:

    Get the temporary directory. We don't use GetTempPath here because it doesn't verify if 
    the temporary directory (specified by either the TEMP or the TMP enviorment variable) exists.
    If no TEMP or TMP is defined or the directory doesn't exist we get the user profile directory.

 Arguments:

    IN/OUT pszTemparoryDir - buffer to hold the temp directory upon return.

 Return Value:

    TRUE - we are able to find an appropriate temporary directory.
    FALSE otherwise.

 History:

    10/18/2000 maonis  Created

--*/

BOOL 
GetTemporaryDirA(
    LPSTR pszTemparoryDir
    )
{
    if ((GetEnvironmentVariableA("TEMP", pszTemparoryDir, MAX_PATH) == 0) || 
        !(GetFileAttributesA(pszTemparoryDir) & FILE_ATTRIBUTE_DIRECTORY))
    {
        if ((GetEnvironmentVariableA("TMP", pszTemparoryDir, MAX_PATH) == 0) || 
            !(GetFileAttributesA(pszTemparoryDir) & FILE_ATTRIBUTE_DIRECTORY))
        {
            HANDLE hToken = INVALID_HANDLE_VALUE;
            DWORD dwSize = MAX_PATH;

            if ((OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken) != 0) && 
               (GetUserProfileDirectoryA(hToken, pszTemparoryDir, &dwSize) != 0) &&
               (GetFileAttributesA(pszTemparoryDir) & FILE_ATTRIBUTE_DIRECTORY))
            {
                return TRUE;
            }
            else
            {
                // All failed. If the user has a system like that, we might as well 
                // just forget about fixing this for him.
                DPFN( eDbgLevelError, "[GetTemporaryDirA] Error finding an appropriate temp directory");
                return FALSE;
            }
        }
        else
        {
            DPFN( eDbgLevelInfo, "[GetTemporaryDirA] found TMP var");
        }
    }
    else
    {
        DPFN( eDbgLevelInfo, "[GetTemporaryDirA] found TEMP var");
    }

    return TRUE;
}

/*++

 Function Description:

    Copy the original file to a temporary file in the temporary directory. We use GetTempFileName
    to generate a temporary name but append .bmp to the filename because LoadImage doesn't recognize
    it if it doesn't have a .bmp extension.

 Arguments:

    IN pszFile - the name of the original file.
    IN/OUT pszNewFile - buffer to hold the new file name upon return.

 Return Value:

    TRUE - we are able to create a temporary file.
    FALSE otherwise.

 History:

    10/18/2000 maonis  Created

--*/

BOOL 
CreateTempFileA(
    LPCSTR pszFile, 
    LPSTR pszNewFile
    )
{
    CHAR szDir[MAX_PATH];
    CHAR szTempFile[MAX_PATH];
    return (GetTemporaryDirA(szDir) && 
        (GetTempFileNameA(szDir, "abc", 0, szTempFile) != 0) && 
        strcpy(pszNewFile, szTempFile) &&
        strcat(pszNewFile, ".bmp") && 
        MoveFileA(szTempFile, pszNewFile) && 
        CopyFileA(pszFile, pszNewFile, FALSE) &&
        SetFileAttributesA(pszNewFile, FILE_ATTRIBUTE_NORMAL));
}

/*++

 Function Description:

    Clean up the mapped file.

 Arguments:

    IN hFile - handle to the file.
    IN hFileMap - handle to the file view.
    IN pFileMap - pointer to the file view.

 Return Value:

    VOID.

 History:

    10/18/2000 maonis  Created

--*/

VOID 
CleanupFileMapping(
    HANDLE hFile, 
    HANDLE hFileMap, 
    LPVOID pFileMap)
{
    if (pFileMap != NULL)
    {
        UnmapViewOfFile(pFileMap);
    }

    if (hFileMap)
    {
        CloseHandle(hFileMap);
    }

    if (hFile && (hFile != INVALID_HANDLE_VALUE))
    {
        CloseHandle(hFile);
    }
}

/*++

 Function Description:

    Examine the BITMAPINFOHEADER from a bitmap file and decide if we need to fix it.

 Arguments:

    IN pszFile - the name of the .bmp file.
    IN/OUT pszNewFile - buffer to hold the temporary file name if the function returns TRUE.
    
 Return Value:

    TRUE - We need to correct the header and we successfully copied the file to a temporary file.
    FALSE - Either we don't need to correct the header or we failed to create a temporary file.

 History:

    10/18/2000 maonis  Created

--*/

BOOL 
ProcessHeaderInFileA(
    LPCSTR pszFile, 
    LPSTR pszNewFile
    )
{
    BOOL fIsSuccess = TRUE;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hFileMap = NULL;
    LPBYTE pFileMap = NULL;
    BITMAPINFOHEADER* pbih = NULL;

    if (!IsBadReadPtr(pszFile, 1) && 
        ((hFile = CreateFileA(pszFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL)) != INVALID_HANDLE_VALUE) && 
        ((hFileMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL)) != NULL) &&
        ((pFileMap = (LPBYTE)MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 0)) != NULL))
    {
        pbih = (BITMAPINFOHEADER*)(pFileMap + sizeof(BITMAPFILEHEADER));        

        if (pbih->biSizeImage == 0 && pbih->biCompression != BI_RGB)
        {
            // We need to correct the header by creating a new bmp file that
            // is identical to the original file except the header has correct
            // image size.
            if (CreateTempFileA(pszFile, pszNewFile))
            {
                DPFN( eDbgLevelInfo, "[FixHeaderInFileA] Created a temp file %s", pszNewFile);
            }
            else
            {
                DPFN( eDbgLevelError, "[FixHeaderInFileA] Error create the temp file");
                fIsSuccess = FALSE;
                goto EXIT;
            }
        }
        else
        {
            DPFN( eDbgLevelInfo, "[FixHeaderInFileA] The Bitmap header looks OK");
            fIsSuccess = FALSE;
            goto EXIT;
        }
    }
    else
    {
        DPFN( eDbgLevelError, "[FixHeaderInFileA] Error creating file mapping");
        fIsSuccess = FALSE;
        goto EXIT;
    }

EXIT:
    
    CleanupFileMapping(hFile, hFileMap, pFileMap);    
    return fIsSuccess;
}

/*++

 Function Description:

    Make the biSizeImage field of the BITMAPINFOHEADER struct the size of the bitmap data.

 Arguments:

    IN pszFile - the name of the .bmp file.
    
 Return Value:

    TRUE - We successfully corrected the header.
    FALSE otherwise.

 History:

    10/18/2000 maonis  Created

--*/

BOOL FixHeaderInFileA(
    LPCSTR pszFile
    )
{
    BOOL fIsSuccess = TRUE;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hFileMap = NULL;
    LPBYTE pFileMap = NULL;
    BITMAPINFOHEADER* pbih = NULL;
    BITMAPFILEHEADER* pbfh = NULL;

    if (((hFile = CreateFileA(
            pszFile, 
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL)) != INVALID_HANDLE_VALUE) && 
        ((hFileMap = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL)) != NULL) &&
        ((pFileMap = (LPBYTE)MapViewOfFile(hFileMap, FILE_MAP_WRITE, 0, 0, 0)) != NULL))
    {
        pbfh = (BITMAPFILEHEADER*)pFileMap;
        pbih = (BITMAPINFOHEADER*)(pFileMap + sizeof(BITMAPFILEHEADER));        

        // We make the image size the bitmap data size.
        pbih->biSizeImage = GetFileSize(hFile, NULL) - pbfh->bfOffBits;
    }
    else
    {
        fIsSuccess = FALSE;
    }
    
    CleanupFileMapping(hFile, hFileMap, pFileMap);
    return fIsSuccess;
}

/*++

 Function Description:

    Adopted from the HowManyColors in \windows\core\ntuser\client\clres.c.

 Arguments:

    IN pbih - the BITMAPINFOHEADER* pointer.
    
 Return Value:

    The number of entries in the color table.

 History:

    10/18/2000 maonis  Created

--*/

DWORD HowManyColors(
    BITMAPINFOHEADER* pbih
    )
{
    if (pbih->biClrUsed) 
    {
         // If the bitmap header explicitly provides the number of colors
         // in the color table, use it.
        return (DWORD)pbih->biClrUsed;
    } 
    else if (pbih->biBitCount <= 8) 
    {
         // If the bitmap header describes a pallete-bassed bitmap
         // (8bpp or less) then the color table must be big enough
         // to hold all palette indecies.
        return (1 << pbih->biBitCount);
    } 
    else 
    {
        // For highcolor+ bitmaps, there's no need for a color table.
        // However, 16bpp and 32bpp bitmaps contain 3 DWORDS that 
        // describe the masks for the red, green, and blue components 
        // of entry in the bitmap.
        if (pbih->biCompression == BI_BITFIELDS) 
        {
            return 3;
        }
    }

    return 0;
}

/*++

 Function Description:

    Examine the BITMAPINFOHEADER in a bitmap resource and fix it as necessary.

 Arguments:

    IN hinst - the module instance where the bitmap resource resides.
    IN pszName - the resource name.
    OUT phglbBmp - the handle to the resource global memory.
    
 Return Value:

    TRUE - We successfully corrected the bitmap header if necessary.
    FALSE - otherwise.

 History:

    10/18/2000 maonis  Created

--*/

BOOL ProcessAndFixHeaderInResourceA(
    HINSTANCE hinst,   // handle to instance
    LPCSTR pszName,    // name or identifier of the image
    HGLOBAL* phglbBmp
    )
{
    HRSRC hrcBmp = NULL;
    BITMAPINFOHEADER* pbih = NULL;
    
    if (((hrcBmp = FindResourceA(hinst, pszName, (LPCSTR)RT_BITMAP)) != NULL) &&
        ((*phglbBmp = LoadResource(hinst, hrcBmp)) != NULL) && 
        ((pbih = (BITMAPINFOHEADER*)LockResource(*phglbBmp))))
    {
        if (pbih->biSizeImage == 0 && pbih->biCompression != BI_RGB)
        {
            // We need to correct the header by setting the right size in memory.
            pbih->biSizeImage = 
                SizeofResource(hinst, hrcBmp) - 
                sizeof(BITMAPINFOHEADER) -  
                HowManyColors(pbih) * sizeof(RGBQUAD);

            return TRUE;
        }
    }

    return FALSE;
}

HANDLE 
APIHOOK(LoadImageA)(
    HINSTANCE hinst,   // handle to instance
    LPCSTR lpszName,   // name or identifier of the image
    UINT uType,        // image type
    int cxDesired,     // desired width
    int cyDesired,     // desired height
    UINT fuLoad        // load options
    )
{
    HANDLE hImage = INVALID_HANDLE_VALUE;

    // First call LoadImage see if it succeeds.
    if (hImage = ORIGINAL_API(LoadImageA)(
        hinst, 
        lpszName,
        uType,
        cxDesired,
        cyDesired,
        fuLoad))
    {
        return hImage;
    }

    if (uType != IMAGE_BITMAP)
    {
        DPFN( eDbgLevelInfo, "We don't fix the non-bitmap types");
        return NULL;
    }

    // It failed. We'll correct the header.
    if (fuLoad & LR_LOADFROMFILE)
    {
        CHAR szNewFile[MAX_PATH];

        if (ProcessHeaderInFileA(lpszName, szNewFile))
        {
            // We now fix the bad header.
            if (FixHeaderInFileA(szNewFile))
            {
                // Call the API with the new file.
                hImage = ORIGINAL_API(LoadImageA)(hinst, szNewFile, uType, cxDesired, cyDesired, fuLoad);

                // Delete the temporary file.
                DeleteFileA(szNewFile);
            }
            else
            {
                DPFN( eDbgLevelError, "[LoadImageA] Error fixing the bad header in bmp file");
            }
        }
    }
    else
    {
        HGLOBAL hglbBmp = NULL;

        if (ProcessAndFixHeaderInResourceA(hinst, lpszName, &hglbBmp))
        {
            hImage = ORIGINAL_API(LoadImageA)(hinst, lpszName, uType, cxDesired, cyDesired, fuLoad);

            FreeResource(hglbBmp);
        }
    }

    if (hImage) 
    {
        LOGN( eDbgLevelInfo, "Bitmap header corrected");
    }

    return hImage;
}

HBITMAP 
APIHOOK(LoadBitmapA)(
    HINSTANCE hInstance,  // handle to application instance
    LPCSTR lpBitmapName   // name of bitmap resource
    )
{
    HBITMAP hImage = NULL;

    // First call LoadImage see if it succeeds.
    if (hImage = ORIGINAL_API(LoadBitmapA)(hInstance, lpBitmapName))
    {
        return hImage;
    }

    HGLOBAL hglbBmp = NULL;

    if (ProcessAndFixHeaderInResourceA(hInstance, lpBitmapName, &hglbBmp))
    {
        hImage = ORIGINAL_API(LoadBitmapA)(hInstance, lpBitmapName);

        if (hImage) 
        {
            LOGN( eDbgLevelInfo, "Bitmap header corrected");
        }

        FreeResource(hglbBmp);
    }

    return hImage;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, LoadImageA)
    APIHOOK_ENTRY(USER32.DLL, LoadBitmapA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\correctsounddeviceid.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   CorrectSoundDeviceId.cpp

 Abstract:

    This shim fixes calls to waveOutOpen, waveOutGetDevC